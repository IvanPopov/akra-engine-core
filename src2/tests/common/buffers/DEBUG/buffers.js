


/*---------------------------------------------
 * assembled at: Thu Jul 11 2013 15:09:56 GMT+0400 (Московское время (зима))
 * directory: tests/common/buffers/DEBUG/
 * file: tests/common/buffers/buffers.ts
 * name: buffers
 *--------------------------------------------*/


var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// @data: data
/// @DATA: {data}|location()
// #define CRYPTO_API 1
// #define GUI 1
// #define WEBGL_DEBUG 1
// #define DETAILED_LOG 1
//trace all render entry
// #define __VIEW_INTERNALS__ 1
var akra;
(function (akra) {
    (function (ELogLevel) {
        ELogLevel._map = [];
        ELogLevel.NONE = 0x0000;
        ELogLevel.LOG = 0x0001;
        ELogLevel.INFORMATION = 0x0002;
        ELogLevel.WARNING = 0x0004;
        ELogLevel.ERROR = 0x0008;
        ELogLevel.CRITICAL = 0x0010;
        ELogLevel.ALL = 0x001F;
    })(akra.ELogLevel || (akra.ELogLevel = {}));
    var ELogLevel = akra.ELogLevel;
})(akra || (akra = {}));
/*I ## */
/*I ## */
/*I ## */
/*I ## */
var akra;
(function (akra) {
    var p = document.getElementsByTagName("script");
    /**@const*/ akra.DATA = (akra.DATA || ((p[p.length - 1]).getAttribute("data")) || data) + "/";
    akra.DEBUG = true;
    akra.logger;
    akra.typeOf;
    akra.typeOf = function typeOf(x) {
        var s = typeof x;
        if (s === "object") {
            if (x) {
                if (x instanceof Array) {
                    return 'array';
                } else if (x instanceof Object) {
                    return s;
                }
                var sClassName = Object.prototype.toString.call(x);
                if (sClassName == '[object Window]') {
                    return 'object';
                }
                if ((sClassName == '[object Array]' || typeof x.length == 'number' && typeof x.splice != 'undefined' && typeof x.propertyIsEnumerable != 'undefined' && !x.propertyIsEnumerable('splice'))) {
                    return 'array';
                }
                if ((sClassName == '[object Function]' || typeof x.call != 'undefined' && typeof x.propertyIsEnumerable != 'undefined' && !x.propertyIsEnumerable('call'))) {
                    return 'function';
                }
            } else {
                return 'null';
            }
        } else if (s == 'function' && typeof x.call == 'undefined') {
            return 'object';
        }
        return s;
    };
    /** @inline */
    akra.isDef = /** @inline */function (x) {
        return x !== undefined;
    };
    /** @inline */
    akra.isEmpty = /** @inline */function (x) {
        return x.length == 0;
    };
    // Note that undefined == null.
    /** @inline */
    akra.isDefAndNotNull = /** @inline */function (x) {
        return x != null;
    };
    /** @inline */
    akra.isNull = /** @inline */function (x) {
        return x === null;
    };
    /** @inline */
    akra.isBoolean = /** @inline */function (x) {
        return typeof x === "boolean";
    };
    /** @inline */
    akra.isString = /** @inline */function (x) {
        return typeof x === "string";
    };
    /** @inline */
    akra.isNumber = /** @inline */function (x) {
        return typeof x === "number";
    };
    /** @inline */
    akra.isFloat = akra.isNumber;
    /** @inline */
    akra.isInt = akra.isNumber;
    /** @inline */
    akra.isFunction = /** @inline */function (x) {
        return akra.typeOf(x) === "function";
    };
    /** @inline */
    akra.isObject = function (x) {
        var type = akra.typeOf(x);
        return type == "object" || type == "array" || type == "function";
    };
    akra.isArrayBuffer = /** @inline */function (x) {
        return x instanceof ArrayBuffer;
    };
    akra.isTypedArray = /** @inline */function (x) {
        return x !== null && typeof x === "object" && typeof x.byteOffset === "number";
    };
    akra.isBlob = /** @inline */function (x) {
        return x instanceof Blob;
    };
    /** @inline */
    akra.isArray = function (x) {
        return akra.typeOf(x) == "array";
    };
    ;
    // if (!isDef(console.assert)) {
    //     console.assert = function (isOK?: bool, ...pParams: any[]): void {
    //         if (!isOK) {
    //             trace('---------------------------');
    //             trace.apply(null, pParams);
    //             throw new Error("[assertion failed]");
    //         }
    //     }
    // }
    // export var trace = console.log.bind(console);
    // export var assert = console.assert.bind(console);
    // export var warning = console.warn.bind(console);
    // export var error = console.error.bind(console);
    // export var debug_print = (pArg:any, ...pParams: any[]): void => {
    //         trace.apply(null, arguments);
    // }
    // export var debug_assert = (isOK: bool, ...pParams: any[]): void => {
    //         assert.apply(null, arguments);
    // }
    // export var debug_warning = (pArg:any, ...pParams: any[]): void => {
    //         warning.apply(null, arguments);
    // }
    // export var debug_error = (pArg:any, ...pParams: any[]): void => {
    //         error.apply(null, arguments);
    // }
    function genArray(pType, nSize) {
        var tmp = new Array(nSize);
        for(var i = 0; i < nSize; ++i) {
            tmp[i] = (pType ? new pType() : null);
        }
        return tmp;
    }
    akra.genArray = genArray;
    /**@const*/ akra.INVALID_INDEX = 0xffff;
    // (-2147483646);
    /**@const*/ akra.MIN_INT32 = 0xffffffff;
    // ( 2147483647);
    /**@const*/ akra.MAX_INT32 = 0x7fffffff;
    // (-32768);
    /**@const*/ akra.MIN_INT16 = 0xffff;
    // ( 32767);
    /**@const*/ akra.MAX_INT16 = 0x7fff;
    // (-128);
    /**@const*/ akra.MIN_INT8 = 0xff;
    // ( 127);
    /**@const*/ akra.MAX_INT8 = 0x7f;
    /**@const*/ akra.MIN_UINT32 = 0;
    /**@const*/ akra.MAX_UINT32 = 0xffffffff;
    /**@const*/ akra.MIN_UINT16 = 0;
    /**@const*/ akra.MAX_UINT16 = 0xffff;
    /**@const*/ akra.MIN_UINT8 = 0;
    /**@const*/ akra.MAX_UINT8 = 0xff;
    /**@const*/ akra.SIZE_FLOAT64 = 8;
    /**@const*/ akra.SIZE_REAL64 = 8;
    /**@const*/ akra.SIZE_FLOAT32 = 4;
    /**@const*/ akra.SIZE_REAL32 = 4;
    /**@const*/ akra.SIZE_INT32 = 4;
    /**@const*/ akra.SIZE_UINT32 = 4;
    /**@const*/ akra.SIZE_INT16 = 2;
    /**@const*/ akra.SIZE_UINT16 = 2;
    /**@const*/ akra.SIZE_INT8 = 1;
    /**@const*/ akra.SIZE_UINT8 = 1;
    /**@const*/ akra.SIZE_BYTE = 1;
    /**@const*/ akra.SIZE_UBYTE = 1;
    //1.7976931348623157e+308
    /**@const*/ akra.MAX_FLOAT64 = Number.MAX_VALUE;
    //-1.7976931348623157e+308
    /**@const*/ akra.MIN_FLOAT64 = -Number.MAX_VALUE;
    //5e-324
    /**@const*/ akra.TINY_FLOAT64 = Number.MIN_VALUE;
    //    export const MAX_REAL64: number = Number.MAX_VALUE;   //1.7976931348623157e+308
    //    export const MIN_REAL64: number = -Number.MAX_VALUE;  //-1.7976931348623157e+308
    //    export const TINY_REAL64: number = Number.MIN_VALUE;  //5e-324
    //3.4e38
    /**@const*/ akra.MAX_FLOAT32 = 3.4e38;
    //-3.4e38
    /**@const*/ akra.MIN_FLOAT32 = -3.4e38;
    //1.5e-45
    /**@const*/ akra.TINY_FLOAT32 = 1.5e-45;
    //    export const MAX_REAL32: number = 3.4e38;     //3.4e38
    //    export const MIN_REAL32: number = -3.4e38;    //-3.4e38
    //    export const TINY_REAL32: number = 1.5e-45;   //1.5e-45
    /**@const*/ akra.DEFAULT_MATERIAL_NAME = "default";
    (function (EDataTypes) {
        EDataTypes._map = [];
        EDataTypes.BYTE = 0x1400;
        EDataTypes.UNSIGNED_BYTE = 0x1401;
        EDataTypes.SHORT = 0x1402;
        EDataTypes.UNSIGNED_SHORT = 0x1403;
        EDataTypes.INT = 0x1404;
        EDataTypes.UNSIGNED_INT = 0x1405;
        EDataTypes.FLOAT = 0x1406;
    })(akra.EDataTypes || (akra.EDataTypes = {}));
    var EDataTypes = akra.EDataTypes;
    ;
    (function (EDataTypeSizes) {
        EDataTypeSizes._map = [];
        EDataTypeSizes.BYTES_PER_BYTE = 1;
        EDataTypeSizes.BYTES_PER_UNSIGNED_BYTE = 1;
        EDataTypeSizes.BYTES_PER_UBYTE = 1;
        EDataTypeSizes.BYTES_PER_SHORT = 2;
        EDataTypeSizes.BYTES_PER_UNSIGNED_SHORT = 2;
        EDataTypeSizes.BYTES_PER_USHORT = 2;
        EDataTypeSizes.BYTES_PER_INT = 4;
        EDataTypeSizes.BYTES_PER_UNSIGNED_INT = 4;
        EDataTypeSizes.BYTES_PER_UINT = 4;
        EDataTypeSizes.BYTES_PER_FLOAT = 4;
    })(akra.EDataTypeSizes || (akra.EDataTypeSizes = {}));
    var EDataTypeSizes = akra.EDataTypeSizes;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
        function getTypeSize(eType) {
        switch(eType) {
            case EDataTypes.BYTE:
            case EDataTypes.UNSIGNED_BYTE:
                return 1;
            case EDataTypes.SHORT:
            case EDataTypes.UNSIGNED_SHORT:
                //case EImageTypes.UNSIGNED_SHORT_4_4_4_4:
                //case EImageTypes.UNSIGNED_SHORT_5_5_5_1:
                //case EImageTypes.UNSIGNED_SHORT_5_6_5:
                return 2;
            case EDataTypes.INT:
            case EDataTypes.UNSIGNED_INT:
            case EDataTypes.FLOAT:
                return 4;
            default:
 {
                    akra.logger.setSourceLocation("common.ts", 425);
                    akra.logger.error('unknown data/image type used');
                }
                ;
        }
    }
    akra.getTypeSize = getTypeSize;
    akra.sid = /** @inline */function () {
        return (++akra.sid._iTotal);
    };
    akra.sid._iTotal = 0;
    /** @inline */function now() {
        return Date.now();
    }
    akra.now = now;
    /** @inline */function memcpy(pDst, iDstOffset, pSrc, iSrcOffset, nLength) {
        var dstU8 = new Uint8Array(pDst, iDstOffset, nLength);
        var srcU8 = new Uint8Array(pSrc, iSrcOffset, nLength);
        dstU8.set(srcU8);
    }
    akra.memcpy = memcpy;
    ;
    //export function
    (window).URL = (window).URL ? (window).URL : (window).webkitURL ? (window).webkitURL : null;
    (window).BlobBuilder = (window).WebKitBlobBuilder || (window).MozBlobBuilder || (window).BlobBuilder;
    (window).requestFileSystem = (window).requestFileSystem || (window).webkitRequestFileSystem;
    (window).requestAnimationFrame = (window).requestAnimationFrame || (window).webkitRequestAnimationFrame || (window).mozRequestAnimationFrame;
    (window).WebSocket = (window).WebSocket || (window).MozWebSocket;
    // (<any>window).storageInfo = (<any>window).storageInfo || (<any>window).webkitPersistentStorage ;
    (window).storageInfo = (window).storageInfo || (window).webkitTemporaryStorage;
    (navigator).gamepads = (navigator).gamepads || (navigator).webkitGamepads;
    (navigator).getGamepads = (navigator).getGamepads || (navigator).webkitGetGamepads;
    Worker.prototype.postMessage = (Worker).prototype.webkitPostMessage || Worker.prototype.postMessage;
})(akra || (akra = {}));
;
function utf8_encode(argString) {
    // Encodes an ISO-8859-1 string to UTF-8
    //
    // version: 1109.2015
    // discuss at: http://phpjs.org/functions/utf8_encode
    // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +   improved by: sowberry
    // +    tweaked by: Jack
    // +   bugfixed by: Onno Marsman
    // +   improved by: Yves Sucaet
    // +   bugfixed by: Onno Marsman
    // +   bugfixed by: Ulrich
    // +   bugfixed by: Rafal Kukawski
    // *     example 1: utf8_encode('Kevin van Zonneveld');
    // *     returns 1: 'Kevin van Zonneveld'
    if (argString === null || typeof argString === "undefined") {
        return "";
    }
    // .replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    var string = (argString + "");
    var utftext = "", start, end, stringl = 0;
    start = end = 0;
    stringl = string.length;
    for(var n = 0; n < stringl; n++) {
        var c1 = string.charCodeAt(n);
        var enc = null;
        if (c1 < 128) {
            end++;
        } else if (c1 > 127 && c1 < 2048) {
            enc = String.fromCharCode((c1 >> 6) | 192) + String.fromCharCode((c1 & 63) | 128);
        } else {
            enc = String.fromCharCode((c1 >> 12) | 224) + String.fromCharCode(((c1 >> 6) & 63) | 128) + String.fromCharCode((c1 & 63) | 128);
        }
        if (enc !== null) {
            if (end > start) {
                utftext += string.slice(start, end);
            }
            utftext += enc;
            start = end = n + 1;
        }
    }
    if (end > start) {
        utftext += string.slice(start, stringl);
    }
    return utftext;
}
function utf8_decode(str_data) {
    // http://kevin.vanzonneveld.net
    // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
    // +      input by: Aman Gupta
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +   improved by: Norman "zEh" Fuchs
    // +   bugfixed by: hitwork
    // +   bugfixed by: Onno Marsman
    // +      input by: Brett Zamir (http://brett-zamir.me)
    // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // *     example 1: utf8_decode('Kevin van Zonneveld');
    // *     returns 1: 'Kevin van Zonneveld'
        var tmp_arr = [], i = 0, ac = 0, c1 = 0, c2 = 0, c3 = 0;
    str_data += "";
    while(i < str_data.length) {
        c1 = str_data.charCodeAt(i);
        if (c1 < 128) {
            tmp_arr[ac++] = String.fromCharCode(c1);
            i++;
        } else if (c1 > 191 && c1 < 224) {
            c2 = str_data.charCodeAt(i + 1);
            tmp_arr[ac++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
            i += 2;
        } else {
            c2 = str_data.charCodeAt(i + 1);
            c3 = str_data.charCodeAt(i + 2);
            tmp_arr[ac++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
            i += 3;
        }
    }
    return tmp_arr.join("");
}
var akra;
(function (akra) {
    (function (libs) {
        /**
        * Encodes an ISO-8859-1 string to UTF-8
        * @treturn String
        */
        String.prototype.toUTF8 = function () {
            return utf8_encode(this);
        };
        /**
        * Converts a UTF-8 encoded string to ISO-8859-1
        * @treturn String
        */
        String.prototype.fromUTF8 = function () {
            return utf8_decode(this);
        };
        String.prototype.replaceAt = function (n, chr) {
            return this.substr(0, n) + chr + this.substr(n + chr.length);
        };
        Object.defineProperty(Array.prototype, 'first', {
            enumerable: false,
            configurable: true,
            get: function () {
                return this[0];
            }
        });
        Object.defineProperty(Array.prototype, 'last', {
            enumerable: false,
            configurable: true,
            get: function () {
                return this[this.length - 1];
            }
        });
        Object.defineProperty(Array.prototype, 'el', {
            enumerable: false,
            configurable: true,
            value: function (i) {
                i = i || 0;
                return this[i < 0 ? this.length + i : i];
            }
        });
        Object.defineProperty(Array.prototype, 'clear', {
            enumerable: false,
            configurable: true,
            value: function () {
                this.length = 0;
            }
        });
        Object.defineProperty(Array.prototype, 'swap', {
            enumerable: false,
            configurable: true,
            value: function (i, j) {
                if (i < this.length && j < this.length) {
                    var t = this[i];
                    this[i] = this[j];
                    this[j] = t;
                }
            }
        });
        Object.defineProperty(Array.prototype, 'insert', {
            enumerable: false,
            configurable: true,
            value: function (pElement) {
                if (typeof pElement.length === 'number') {
                    for(var i = 0, n = pElement.length; i < n; ++i) {
                        this.push(pElement[i]);
                    }
                    ;
                } else {
                    this.push(pElement);
                }
                return this;
            }
        });
        Number.prototype.toHex = function (iLength) {
            var sValue = this.toString(16);
            for(var i = 0; i < iLength - sValue.length; ++i) {
                sValue = '0' + sValue;
            }
            return sValue;
        };
        Number.prototype.printBinary = function (isPretty) {
            if (typeof isPretty === "undefined") { isPretty = true; }
            var res = "";
            for(var i = 0; i < 32; ++i) {
                if (i && (i % 4) == 0 && isPretty) {
                    res = ' ' + res;
                }
                (this >> i & 0x1 ? res = '1' + res : res = '0' + res);
            }
            return res;
        };
    })(akra.libs || (akra.libs = {}));
    var libs = akra.libs;
})(akra || (akra = {}));
var akra;
(function (akra) {
    /**
    * FLAG(x)
    * Сдвиг единицы на @a x позиций влево.
    */
    /**
    * TEST_BIT(value, bit)
    * Проверка того что у @a value бит под номером @a bit равен единице.
    */
    /**
    * TEST_ALL(value, set)
    * Проверка того что у @a value равны единице все биты,
    * которые равны единице у @a set.
    */
    /**
    * TEST_ANY(value, set)
    * Проверка того что у @a value равны единице хотя бы какие то из битов,
    * которые равны единице у @a set.
    */
    /**
    * SET_BIT(value, bit)
    * Выставляет бит под номером @a bit у числа @a value равным единице
    */
    /**
    * CLEAR_BIT(value, bit)
    * Выставляет бит под номером @a bit у числа @a value равным нулю
    */
    /**
    * SET_ALL(value, set)
    * Выставляет все биты у числа @a value равными единице,
    * которые равны единице у числа @a set
    */
    /**
    * CLEAR_ALL(value, set)
    * Выставляет все биты у числа @a value равными нулю,
    * которые равны единице у числа @a set
    */
    //#define SET_ALL(value, set, setting) (setting ? SET_ALL(value, set) : CLEAR_ALL(value, set))
    (function (bf) {
        /**
        * Сдвиг единицы на @a x позиций влево.
        * @inline
        */
        bf.flag = /** @inline */function (x) {
            return (1 << (x));
        };
        /**
        * Проверка того что у @a value бит под номером @a bit равен единице.
        * @inline
        */
        bf.testBit = /** @inline */function (value, bit) {
            return ((value & ((1 << (bit)))) != 0);
        };
        /**
        * Проверка того что у @a value равны единице все биты,
        * которые равны единице у @a set.
        * @inline
        */
        bf.testAll = /** @inline */function (value, set) {
            return (((value) & (set)) == (set));
        };
        /**
        * Проверка того что у @a value равны единице хотя бы какие то из битов,
        * которые равны единице у @a set.
        * @inline
        */
        bf.testAny = /** @inline */function (value, set) {
            return (((value) & (set)) != 0);
        };
        /**
        * Выставляет бит под номером @a bit у числа @a value равным единице
        * @inline
        */
        bf.setBit = /** @inline */function (value, bit, setting) {
            if (typeof setting === "undefined") { setting = true; }
            return (setting ? ((value) |= ((1 << ((bit))))) : (((value) &= ~((1 << ((bit)))))));
        };
        /**
        *
        * @inline
        */
        bf.clearBit = /** @inline */function (value, bit) {
            return ((value) &= ~((1 << ((bit)))));
        };
        /**
        * Выставляет бит под номером @a bit у числа @a value равным нулю
        * @inline
        */
        bf.setAll = /** @inline */function (value, set, setting) {
            if (typeof setting === "undefined") { setting = true; }
            return (setting ? ((value) |= (set)) : ((value) &= ~(set)));
        };
        /**
        * Выставляет все биты у числа @a value равными единице,
        * которые равны единице у числа @a set
        * @inline
        */
        bf.clearAll = /** @inline */function (value, set) {
            return ((value) &= ~(set));
        };
        /**
        * Выставляет все биты у числа @a value равными нулю,
        * которые равны единице у числа @a set
        * @inline
        */
        bf.equal = function (value, src) {
            value = src;
        };
        /**
        * Прирасваивает числу @a value число @a src
        * @inline
        */
        bf.isEqual = /** @inline */function (value, src) {
            return value == src;
        };
        /**
        * Если число @a value равно числу @a src возвращается true
        * @inline
        */
        bf.isNotEqaul = /** @inline */function (value, src) {
            return value != src;
        };
        /**
        * Прирасваивает числу @a value число @a src
        * @inline
        */
        bf.set = function (value, src) {
            value = src;
        };
        /**
        * Обнуляет число @a value
        * @inline
        */
        bf.clear = function (value) {
            value = 0;
        };
        /**
        * Выставляет все биты у числа @a value равными единице,
        * которые равны единице у числа @a src
        * @inline
        */
        bf.setFlags = /** @inline */function (value, src) {
            return (value |= src);
        };
        /**
        * Выставляет все биты у числа @a value равными нулю,
        * которые равны единице у числа @a src
        * @inline
        */
        bf.clearFlags = /** @inline */function (value, src) {
            return value &= ~src;
        };
        /**
        * Проверяет равно ли число @a value нулю. Если равно возвращает true.
        * Если не равно возвращает false.
        * @inline
        */
        bf.isEmpty = /** @inline */function (value) {
            return (value == 0);
        };
        /**
        * Возвращает общее количество бит числа @a value.
        * На самом деле возвращает всегда 32.
        * @inline
        */
        bf.totalBits = /** @inline */function (value) {
            return 32;
        };
        /**
        * Возвращает общее количество ненулевых бит числа @a value.
        * @inline
        */
        bf.totalSet = function (value) {
            var count = 0;
            var total = (32);
            for(var i = total; i; --i) {
                count += (value & 1);
                value >>= 1;
            }
            return (count);
        };
        /**
        * Convert N bit colour channel value to P bits. It fills P bits with the
        * bit pattern repeated. (this is /((1<<n)-1) in fixed point)
        */
        /** @inline */function fixedToFixed(value, n, p) {
            if (n > p) {
                // Less bits required than available; this is easy
                value >>= n - p;
            } else if (n < p) {
                // More bits required than are there, do the fill
                // Use old fashioned division, probably better than a loop
                if (value == 0) {
                    value = 0;
                } else if (value == ((1) << n) - 1) {
                    value = (1 << p) - 1;
                } else {
                    value = value * (1 << p) / ((1 << n) - 1);
                }
            }
            return value;
        }
        bf.fixedToFixed = fixedToFixed;
        /**
        * Convert floating point colour channel value between 0.0 and 1.0 (otherwise clamped)
        * to integer of a certain number of bits. Works for any value of bits between 0 and 31.
        */
        /** @inline */function floatToFixed(value, bits) {
            if (value <= 0.0) {
                return 0;
            } else if (value >= 1.0) {
                return (1 << bits) - 1;
            } else {
                return (value * (1 << bits));
            }
        }
        bf.floatToFixed = floatToFixed;
        /**
        * Fixed point to float
        */
        /** @inline */function fixedToFloat(value, bits) {
            return (value & ((1 << bits) - 1)) / ((1 << bits) - 1);
        }
        bf.fixedToFloat = fixedToFloat;
        /**
        * Write a n*8 bits integer value to memory in native endian.
        */
        /** @inline */function intWrite(pDest, n, value) {
            switch(n) {
                case 1:
                    pDest[0] = value;
                    break;
                case 2:
                    pDest[1] = ((value >> 8) & 0xFF);
                    pDest[0] = (value & 0xFF);
                    break;
                case 3:
                    pDest[2] = ((value >> 16) & 0xFF);
                    pDest[1] = ((value >> 8) & 0xFF);
                    pDest[0] = (value & 0xFF);
                    break;
                case 4:
                    pDest[3] = ((value >> 24) & 0xFF);
                    pDest[2] = ((value >> 16) & 0xFF);
                    pDest[1] = ((value >> 8) & 0xFF);
                    pDest[0] = (value & 0xFF);
                    break;
            }
        }
        bf.intWrite = intWrite;
        /**
        * Read a n*8 bits integer value to memory in native endian.
        */
        /** @inline */function intRead(pSrc, n) {
            switch(n) {
                case 1:
                    return pSrc[0];
                case 2:
                    return pSrc[0] | pSrc[1] << 8;
                case 3:
                    return pSrc[0] | pSrc[1] << 8 | pSrc[2] << 16;
                case 4:
                    return (pSrc[0]) | (pSrc[1] << 8) | (pSrc[2] << 16) | (pSrc[3] << 24);
            }
            return 0;
        }
        bf.intRead = intRead;
                //float32/uint32 union
        var _u32 = new Uint32Array(1);
        var _f32 = new Float32Array(_u32.buffer);
        /** @inline */function floatToHalf(f) {
            _f32[0] = f;
            return floatToHalfI(_u32[0]);
        }
        bf.floatToHalf = floatToHalf;
        /** @inline */function floatToHalfI(i) {
            var s = (i >> 16) & 0x00008000;
            var e = ((i >> 23) & 0x000000ff) - (127 - 15);
            var m = i & 0x007fffff;
            if (e <= 0) {
                if (e < -10) {
                    return 0;
                }
                m = (m | 0x00800000) >> (1 - e);
                return (s | (m >> 13));
            } else if (e == 0xff - (127 - 15)) {
                // Inf
                if (m == 0) {
                    return (s | 0x7c00);
                } else// NAN
                 {
                    m >>= 13;
                    return (s | 0x7c00 | m | (m == 0));
                }
            } else {
                // Overflow
                if (e > 30) {
                    return (s | 0x7c00);
                }
                return (s | (e << 10) | (m >> 13));
            }
        }
        bf.floatToHalfI = floatToHalfI;
        /**
        * Convert a float16 (NV_half_float) to a float32
        * Courtesy of OpenEXR
        */
        /** @inline */function halfToFloat(y) {
            _u32[0] = /*not inlined, because supportes only single statement functions(cur. st. count: 8)*/halfToFloatI(y);
            return _f32[0];
        }
        bf.halfToFloat = halfToFloat;
        /** Converts a half in uint16 format to a float
        in uint32 format
        */
        /** @inline */function halfToFloatI(y) {
            var s = (y >> 15) & 0x00000001;
            var e = (y >> 10) & 0x0000001f;
            var m = y & 0x000003ff;
            if (e == 0) {
                // Plus or minus zero
                if (m == 0) {
                    return s << 31;
                } else// Denormalized number -- renormalize it
                 {
                    while(!(m & 0x00000400)) {
                        m <<= 1;
                        e -= 1;
                    }
                    e += 1;
                    m &= ~0x00000400;
                }
            } else if (e == 31) {
                //Inf
                if (m == 0) {
                    return (s << 31) | 0x7f800000;
                } else//NaN
                 {
                    return (s << 31) | 0x7f800000 | (m << 13);
                }
            }
            e = e + (127 - 15);
            m = m << 13;
            return (s << 31) | (e << 23) | m;
        }
        bf.halfToFloatI = halfToFloatI;
    })(akra.bf || (akra.bf = {}));
    var bf = akra.bf;
})(akra || (akra = {}));
var akra;
(function (akra) {
    // #include "Singleton.ts"
    (function (util) {
        /* extends Singleton*/
        var Logger = (function () {
            function Logger() {
                //super();
                this._eUnknownCode = 0;
                this._sUnknownMessage = "Unknown code";
                this._eLogLevel = akra.ELogLevel.ALL;
                this._pGeneralRoutineMap = {};
                this._pCurrentSourceLocation = {
                    file: "",
                    line: 0
                };
                this._pLastLogEntity = {
                    code: this._eUnknownCode,
                    location: this._pCurrentSourceLocation,
                    message: this._sUnknownMessage,
                    info: null
                };
                this._pCodeFamilyMap = {};
                this._pCodeFamilyList = [];
                this._pCodeInfoMap = {};
                this._pCodeFamilyRoutineDMap = {};
                this._nFamilyGenerator = 0;
            }
            Logger._sDefaultFamilyName = "CodeFamily";
            Logger.prototype.init = function () {
                //TODO: Load file
                return true;
            };
            Logger.prototype.setLogLevel = function (eLevel) {
                this._eLogLevel = eLevel;
            };
            Logger.prototype.getLogLevel = function () {
                return this._eLogLevel;
            };
            Logger.prototype.registerCode = function (eCode, sMessage) {
                if (typeof sMessage === "undefined") { sMessage = this._sUnknownMessage; }
                if (((((this)._pCodeInfoMap[(eCode)]) !== undefined))) {
                    return false;
                }
                var sFamilyName = this.getFamilyName(eCode);
                if (((sFamilyName) === null)) {
                    return false;
                }
                var pCodeInfo = {
                    code: eCode,
                    message: sMessage,
                    familyName: sFamilyName
                };
                this._pCodeInfoMap[eCode] = pCodeInfo;
                return true;
            };
            Logger.prototype.setUnknownCode = function (eCode, sMessage) {
                this._eUnknownCode = eCode;
                this._sUnknownMessage = sMessage;
            };
            Logger.prototype.registerCodeFamily = function (eCodeMin, eCodeMax, sFamilyName) {
                if (!((sFamilyName) !== undefined)) {
                    sFamilyName = this.generateFamilyName();
                }
                if (((((this)._pCodeFamilyMap[(sFamilyName)]) !== undefined))) {
                    return false;
                }
                if (!this.isValidCodeInterval(eCodeMin, eCodeMax)) {
                    return false;
                }
                var pCodeFamily = {
                    familyName: sFamilyName,
                    codeMin: eCodeMin,
                    codeMax: eCodeMax
                };
                this._pCodeFamilyMap[sFamilyName] = pCodeFamily;
                this._pCodeFamilyList.push(pCodeFamily);
                return true;
            };
            Logger.prototype.getFamilyName = function (eCode) {
                var i = 0;
                var pCodeFamilyList = this._pCodeFamilyList;
                var pCodeFamily;
                for(i = 0; i < pCodeFamilyList.length; i++) {
                    pCodeFamily = pCodeFamilyList[i];
                    if (pCodeFamily.codeMin <= eCode && pCodeFamily.codeMax >= eCode) {
                        return pCodeFamily.familyName;
                    }
                }
                return null;
            };
            Logger.prototype.setCodeFamilyRoutine = function () {
                var sFamilyName = null;
                var fnLogRoutine = null;
                var eLevel = akra.ELogLevel.LOG;
                if ((typeof (arguments[0]) === "number")) {
                    sFamilyName = this.getFamilyName(arguments[0]);
                    fnLogRoutine = arguments[1];
                    eLevel = arguments[2];
                    if (((sFamilyName) === null)) {
                        return false;
                    }
                } else if ((typeof (arguments[0]) === "string")) {
                    sFamilyName = arguments[0];
                    fnLogRoutine = arguments[1];
                    eLevel = arguments[2];
                }
                if (!((((this)._pCodeFamilyMap[(sFamilyName)]) !== undefined))) {
                    return false;
                }
                var pCodeFamilyRoutineMap = this._pCodeFamilyRoutineDMap[sFamilyName];
                if (!((pCodeFamilyRoutineMap) !== undefined)) {
                    pCodeFamilyRoutineMap = this._pCodeFamilyRoutineDMap[sFamilyName] = {};
                }
                if (((((eLevel) & (/*checked (origin: akra)>>*/akra.ELogLevel.LOG)) == (/*checked (origin: akra)>>*/akra.ELogLevel.LOG)))) {
                    pCodeFamilyRoutineMap[akra.ELogLevel.LOG] = fnLogRoutine;
                }
                if (((((eLevel) & (/*checked (origin: akra)>>*/akra.ELogLevel.INFORMATION)) == (/*checked (origin: akra)>>*/akra.ELogLevel.INFORMATION)))) {
                    pCodeFamilyRoutineMap[akra.ELogLevel.INFORMATION] = fnLogRoutine;
                }
                if (((((eLevel) & (/*checked (origin: akra)>>*/akra.ELogLevel.WARNING)) == (/*checked (origin: akra)>>*/akra.ELogLevel.WARNING)))) {
                    pCodeFamilyRoutineMap[akra.ELogLevel.WARNING] = fnLogRoutine;
                }
                if (((((eLevel) & (/*checked (origin: akra)>>*/akra.ELogLevel.ERROR)) == (/*checked (origin: akra)>>*/akra.ELogLevel.ERROR)))) {
                    pCodeFamilyRoutineMap[akra.ELogLevel.ERROR] = fnLogRoutine;
                }
                if (((((eLevel) & (/*checked (origin: akra)>>*/akra.ELogLevel.CRITICAL)) == (/*checked (origin: akra)>>*/akra.ELogLevel.CRITICAL)))) {
                    pCodeFamilyRoutineMap[akra.ELogLevel.CRITICAL] = fnLogRoutine;
                }
                return true;
            };
            Logger.prototype.setLogRoutine = function (fnLogRoutine, eLevel) {
                if (((((eLevel) & (/*checked (origin: akra)>>*/akra.ELogLevel.LOG)) == (/*checked (origin: akra)>>*/akra.ELogLevel.LOG)))) {
                    this._pGeneralRoutineMap[akra.ELogLevel.LOG] = fnLogRoutine;
                }
                if (((((eLevel) & (/*checked (origin: akra)>>*/akra.ELogLevel.INFORMATION)) == (/*checked (origin: akra)>>*/akra.ELogLevel.INFORMATION)))) {
                    this._pGeneralRoutineMap[akra.ELogLevel.INFORMATION] = fnLogRoutine;
                }
                if (((((eLevel) & (/*checked (origin: akra)>>*/akra.ELogLevel.WARNING)) == (/*checked (origin: akra)>>*/akra.ELogLevel.WARNING)))) {
                    this._pGeneralRoutineMap[akra.ELogLevel.WARNING] = fnLogRoutine;
                }
                if (((((eLevel) & (/*checked (origin: akra)>>*/akra.ELogLevel.ERROR)) == (/*checked (origin: akra)>>*/akra.ELogLevel.ERROR)))) {
                    this._pGeneralRoutineMap[akra.ELogLevel.ERROR] = fnLogRoutine;
                }
                if (((((eLevel) & (/*checked (origin: akra)>>*/akra.ELogLevel.CRITICAL)) == (/*checked (origin: akra)>>*/akra.ELogLevel.CRITICAL)))) {
                    this._pGeneralRoutineMap[akra.ELogLevel.CRITICAL] = fnLogRoutine;
                }
            };
            Logger.prototype.setSourceLocation = function () {
                var sFile;
                var iLine;
                if (arguments.length === 2) {
                    sFile = arguments[0];
                    iLine = arguments[1];
                } else {
                    if (((arguments[0]) !== undefined) && !(((arguments[0]) === null))) {
                        sFile = arguments[0].file;
                        iLine = arguments[0].line;
                    } else {
                        sFile = "";
                        iLine = 0;
                    }
                }
                this._pCurrentSourceLocation.file = sFile;
                this._pCurrentSourceLocation.line = iLine;
            };
            Logger.prototype.log = function () {
                var pArgs = [];
                for (var _i = 0; _i < (arguments.length - 0); _i++) {
                    pArgs[_i] = arguments[_i + 0];
                }
                if (!((((this._eLogLevel) & (/*checked (origin: akra)>>*/akra.ELogLevel.LOG)) == (/*checked (origin: akra)>>*/akra.ELogLevel.LOG)))) {
                    return;
                }
                var fnLogRoutine = this._pGeneralRoutineMap[akra.ELogLevel.LOG];
                if (!((fnLogRoutine) !== undefined)) {
                    return;
                }
                var pLogEntity = this._pLastLogEntity;
                pLogEntity.code = this._eUnknownCode;
                pLogEntity.location = this._pCurrentSourceLocation;
                pLogEntity.info = pArgs;
                pLogEntity.message = this._sUnknownMessage;
                fnLogRoutine.call(null, pLogEntity);
            };
            Logger.prototype.info = function () {
                if (!((((this._eLogLevel) & (/*checked (origin: akra)>>*/akra.ELogLevel.INFORMATION)) == (/*checked (origin: akra)>>*/akra.ELogLevel.INFORMATION)))) {
                    return;
                }
                var pLogEntity;
                var fnLogRoutine;
                pLogEntity = this.prepareLogEntity.apply(this, arguments);
                fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, akra.ELogLevel.INFORMATION);
                if (((fnLogRoutine) === null)) {
                    return;
                }
                fnLogRoutine.call(null, pLogEntity);
            };
            Logger.prototype.warning = function () {
                if (!((((this._eLogLevel) & (/*checked (origin: akra)>>*/akra.ELogLevel.WARNING)) == (/*checked (origin: akra)>>*/akra.ELogLevel.WARNING)))) {
                    return;
                }
                var pLogEntity;
                var fnLogRoutine;
                pLogEntity = this.prepareLogEntity.apply(this, arguments);
                fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, akra.ELogLevel.WARNING);
                if (((fnLogRoutine) === null)) {
                    return;
                }
                fnLogRoutine.call(null, pLogEntity);
            };
            Logger.prototype.error = function () {
                if (!((((this._eLogLevel) & (/*checked (origin: akra)>>*/akra.ELogLevel.ERROR)) == (/*checked (origin: akra)>>*/akra.ELogLevel.ERROR)))) {
                    return;
                }
                var pLogEntity;
                var fnLogRoutine;
                pLogEntity = this.prepareLogEntity.apply(this, arguments);
                fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, akra.ELogLevel.ERROR);
                if (((fnLogRoutine) === null)) {
                    return;
                }
                fnLogRoutine.call(null, pLogEntity);
            };
            Logger.prototype.criticalError = function () {
                var pLogEntity;
                var fnLogRoutine;
                pLogEntity = this.prepareLogEntity.apply(this, arguments);
                fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, akra.ELogLevel.CRITICAL);
                var sSystemMessage = "A Critical error has occured! Code: " + pLogEntity.code.toString();
                if (((((this._eLogLevel) & (/*checked (origin: akra)>>*/akra.ELogLevel.CRITICAL)) == (/*checked (origin: akra)>>*/akra.ELogLevel.CRITICAL))) && !((fnLogRoutine) === null)) {
                    fnLogRoutine.call(null, pLogEntity);
                }
                alert(sSystemMessage);
                throw new Error(sSystemMessage);
            };
            Logger.prototype.assert = function () {
                var bCondition = arguments[0];
                if (!bCondition) {
                    var pLogEntity;
                    var fnLogRoutine;
                    var pArgs = [];
                    for(var i = 1; i < arguments.length; i++) {
                        pArgs[i - 1] = arguments[i];
                    }
                    pLogEntity = this.prepareLogEntity.apply(this, pArgs);
                    fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, akra.ELogLevel.CRITICAL);
                    var sSystemMessage = "A error has occured! Code: " + pLogEntity.code.toString() + "\n Accept to exit, refuse to continue.";
                    if (((((this._eLogLevel) & (/*checked (origin: akra)>>*/akra.ELogLevel.CRITICAL)) == (/*checked (origin: akra)>>*/akra.ELogLevel.CRITICAL))) && !((fnLogRoutine) === null)) {
                        fnLogRoutine.call(null, pLogEntity);
                    }
                    if (confirm(sSystemMessage)) {
                        throw new Error(sSystemMessage);
                    }
                }
            };
            Logger.prototype.generateFamilyName = function () {
                var sSuffix = (this._nFamilyGenerator++);
                var sName = Logger._sDefaultFamilyName + sSuffix;
                if (((((this)._pCodeFamilyMap[(sName)]) !== undefined))) {
                    return this.generateFamilyName();
                } else {
                    return sName;
                }
            };
            Logger.prototype.isValidCodeInterval = function (eCodeMin, eCodeMax) {
                if (eCodeMin > eCodeMax) {
                    return false;
                }
                var i = 0;
                var pCodeFamilyList = this._pCodeFamilyList;
                var pCodeFamily;
                for(i = 0; i < pCodeFamilyList.length; i++) {
                    pCodeFamily = pCodeFamilyList[i];
                    if ((pCodeFamily.codeMin <= eCodeMin && pCodeFamily.codeMax >= eCodeMin) || (pCodeFamily.codeMin <= eCodeMax && pCodeFamily.codeMax >= eCodeMax)) {
                        return false;
                    }
                }
                return true;
            };
            Logger.prototype.isUsedFamilyName = /** @inline */function (sFamilyName) {
                return ((this._pCodeFamilyMap[sFamilyName]) !== undefined);
            };
            Logger.prototype.isUsedCode = /** @inline */function (eCode) {
                return ((this._pCodeInfoMap[eCode]) !== undefined);
            };
            Logger.prototype.isLogEntity = function (pObj) {
                if (akra.isObject(pObj) && ((pObj.code) !== undefined) && ((pObj.location) !== undefined)) {
                    return true;
                }
                return false;
            };
            Logger.prototype.isLogCode = /** @inline */function (eCode) {
                return (typeof (eCode) === "number");
            };
            Logger.prototype.prepareLogEntity = function () {
                var eCode = this._eUnknownCode;
                var sMessage = this._sUnknownMessage;
                var pInfo = null;
                if (arguments.length === 1 && this.isLogEntity(arguments[0])) {
                    var pEntity = arguments[0];
                    eCode = pEntity.code;
                    pInfo = pEntity.info;
                    this.setSourceLocation(pEntity.location);
                    if (!((pEntity.message) !== undefined)) {
                        var pCodeInfo = this._pCodeInfoMap[eCode];
                        if (((pCodeInfo) !== undefined)) {
                            sMessage = pCodeInfo.message;
                        }
                    }
                } else {
                    if (((typeof ((arguments[0])) === "number"))) {
                        eCode = arguments[0];
                        if (arguments.length > 1) {
                            pInfo = new Array(arguments.length - 1);
                            var i = 0;
                            for(i = 0; i < pInfo.length; i++) {
                                pInfo[i] = arguments[i + 1];
                            }
                        }
                    } else {
                        eCode = this._eUnknownCode;
                        // if(arguments.length > 0){
                        pInfo = new Array(arguments.length);
                        var i = 0;
                        for(i = 0; i < pInfo.length; i++) {
                            pInfo[i] = arguments[i];
                        }
                        // }
                        // else {
                        //     pInfo = null;
                        // }
                                            }
                    var pCodeInfo = this._pCodeInfoMap[eCode];
                    if (((pCodeInfo) !== undefined)) {
                        sMessage = pCodeInfo.message;
                    }
                }
                var pLogEntity = this._pLastLogEntity;
                pLogEntity.code = eCode;
                pLogEntity.location = this._pCurrentSourceLocation;
                pLogEntity.message = sMessage;
                pLogEntity.info = pInfo;
                return pLogEntity;
            };
            Logger.prototype.getCodeRoutineFunc = function (eCode, eLevel) {
                var pCodeInfo = this._pCodeInfoMap[eCode];
                var fnLogRoutine;
                if (!((pCodeInfo) !== undefined)) {
                    fnLogRoutine = this._pGeneralRoutineMap[eLevel];
                    return ((fnLogRoutine) !== undefined) ? fnLogRoutine : null;
                }
                var pCodeFamilyRoutineMap = this._pCodeFamilyRoutineDMap[pCodeInfo.familyName];
                if (!((pCodeFamilyRoutineMap) !== undefined) || !((pCodeFamilyRoutineMap[eLevel]) !== undefined)) {
                    fnLogRoutine = this._pGeneralRoutineMap[eLevel];
                    return ((fnLogRoutine) !== undefined) ? fnLogRoutine : null;
                }
                fnLogRoutine = pCodeFamilyRoutineMap[eLevel];
                return fnLogRoutine;
            };
            return Logger;
        })();
        util.Logger = Logger;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        util.logger = new util.Logger();
        util.logger.init();
        util.logger.setUnknownCode(0, "Unknown code.");
        util.logger.setLogLevel(akra.ELogLevel.ALL);
        //Default code families
        util.logger.registerCodeFamily(0, 100, "SystemCodes");
        util.logger.registerCodeFamily(2000, 2199, "ParserSyntaxErrors");
        util.logger.registerCodeFamily(2200, 2500, "EffectSyntaxErrors");
        //Default log routines
        function sourceLocationToString(pLocation) {
            var pDate = new Date();
            var sTime = pDate.getHours() + ":" + pDate.getMinutes() + "." + pDate.getSeconds();
            var sLocation = "[" + pLocation.file + ":" + pLocation.line.toString() + " " + sTime + "]: ";
            return sLocation;
        }
        function logRoutine(pLogEntity) {
            var pArgs = pLogEntity.info;
            pArgs.unshift(sourceLocationToString(pLogEntity.location));
            console["log"].apply(console, pArgs);
        }
        function warningRoutine(pLogEntity) {
            var pArgs = pLogEntity.info;
            pArgs.unshift("Code: " + pLogEntity.code.toString());
            pArgs.unshift(sourceLocationToString(pLogEntity.location));
            console["warn"].apply(console, pArgs);
        }
        function errorRoutine(pLogEntity) {
            var pArgs = pLogEntity.info;
            pArgs.unshift(pLogEntity.message);
            pArgs.unshift("Error code: " + pLogEntity.code.toString() + ".");
            pArgs.unshift(sourceLocationToString(pLogEntity.location));
            console["error"].apply(console, pArgs);
        }
        util.logger.setLogRoutine(logRoutine, akra.ELogLevel.LOG | akra.ELogLevel.INFORMATION);
        util.logger.setLogRoutine(warningRoutine, akra.ELogLevel.WARNING);
        util.logger.setLogRoutine(errorRoutine, akra.ELogLevel.ERROR | akra.ELogLevel.CRITICAL);
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.logger = akra.util.logger;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        window.prompt = function (message, defaul) {
            console.warn("prompt > " + message);
            return null;
        };
        /*window.alert = function(message?: string): void {
        console.warn("alert > " + message);
        }*/
        window.confirm = function (message) {
            console.warn("confirm > " + message);
            return false;
        };
        var pTestCondList = [];
        var pTestList = [];
        var isPassed;
        var pTest = null;
        var iBegin;
        function addCond(pCond) {
            pTestCondList.unshift(pCond);
        }
        var TestCond = (function () {
            function TestCond(sDescription) {
                this.sDescription = sDescription;
            }
            TestCond.prototype.toString = function () {
                return this.sDescription;
            };
            TestCond.prototype.verify = function (pArgv) {
                return false;
            };
            Object.defineProperty(TestCond.prototype, "description", {
                get: function () {
                    return this.sDescription;
                },
                enumerable: true,
                configurable: true
            });
            return TestCond;
        })();        
        var ArrayCond = (function (_super) {
            __extends(ArrayCond, _super);
            function ArrayCond(sDescription, pArr) {
                        _super.call(this, sDescription);
                this._pArr = pArr;
            }
            ArrayCond.prototype.verify = function (pArgv) {
                var pArr = pArgv[0];
                if (pArr.length != this._pArr.length) {
                    return false;
                }
                for(var i = 0; i < pArr.length; ++i) {
                    if (pArr[i] != this._pArr[i]) {
                        return false;
                    }
                }
                ;
                return true;
            };
            return ArrayCond;
        })(TestCond);        
        var ValueCond = (function (_super) {
            __extends(ValueCond, _super);
            function ValueCond(sDescription, pValue, isNegate) {
                if (typeof isNegate === "undefined") { isNegate = false; }
                        _super.call(this, sDescription);
                this._pValue = pValue;
                this._isNegate = isNegate;
            }
            ValueCond.prototype.verify = function (pArgv) {
                var bResult = pArgv[0] === this._pValue;
                // console.warn(">", pArgv[0], "!==", this._pValue);
                return this._isNegate ? !bResult : bResult;
            };
            return ValueCond;
        })(TestCond);        
        // function output(sText: string): void {
        // 	document.body.innerHTML += sText;
        // }
        function output(sText) {
            var pElement = document.createElement("div");
            pElement.innerHTML = sText;
            document.body.appendChild(pElement);
        }
        function check() {
            var pArgv = [];
            for (var _i = 0; _i < (arguments.length - 0); _i++) {
                pArgv[_i] = arguments[_i + 0];
            }
            var pTest = pTestCondList.pop();
            var bResult;
            if (!pTest) {
                console.log(((new Error())).stack);
                console.warn("chech() without condition...");
                return;
            }
            bResult = pTest.verify(pArgv);
            isPassed = isPassed && bResult;
            if (bResult) {
                output("<pre style=\"margin: 0; margin-left: 20px;\"><span style=\"color: green;\"><b>[ PASSED ]</b></span> " + pTest.toString() + "</pre>");
            } else {
                output("<pre style=\"margin: 0; margin-left: 20px;\"><span style=\"color: red;\"><b>[ FAILED ]</b></span> " + pTest.toString() + "</pre>");
            }
        }
        util.check = check;
        function failed(e) {
            if (((e) !== undefined)) {
                printError(e.message, (e).stack);
            }
            var iTotal = pTestCondList.length;
            for(var i = 0; i < iTotal; ++i) {
                check(false);
            }
            isPassed = false;
            pTest = null;
            printResults();
            run();
        }
        util.failed = failed;
        function shouldBeTrue(sDescription) {
            addCond(new ValueCond(sDescription, true));
        }
        util.shouldBeTrue = shouldBeTrue;
        function shouldBeFalse(sDescription) {
            addCond(new ValueCond(sDescription, false));
        }
        util.shouldBeFalse = shouldBeFalse;
        function shouldBeArray(sDescription, pArr) {
            addCond(new ArrayCond(sDescription, pArr));
        }
        util.shouldBeArray = shouldBeArray;
        function shouldBe(sDescription, pValue) {
            addCond(new ValueCond(sDescription, pValue));
        }
        util.shouldBe = shouldBe;
        function shouldBeNotNull(sDescription) {
            addCond(new ValueCond(sDescription, null, true));
        }
        util.shouldBeNotNull = shouldBeNotNull;
                        function test(manifest, fnWrapper, isAsync) {
            if (typeof isAsync === "undefined") { isAsync = false; }
            var pManifest;
            if ((typeof (manifest) === "string")) {
                pManifest = {
                    name: arguments[0],
                    description: null,
                    entry: fnWrapper
                };
            } else {
                pManifest = arguments[0];
                pManifest.entry = fnWrapper;
            }
            pManifest.async = isAsync;
            pTestList.unshift(pManifest);
        }
        util.test = test;
        function printInfo() {
            output("<h4 style=\"font-family: monospace;\">" + pTest.name || "" + "</h4>");
        }
        function printResults() {
            output("<pre style=\"margin-left: 20px;\">" + "<hr align=\"left\" style=\"border: 0; background-color: gray; height: 1px; width: 500px;\"/><span style=\"color: gray;\">total time: " + ((Date.now()) - iBegin) + " msec" + "</span>" + "<br /><b>" + (isPassed ? "<span style=\"color: green\">TEST PASSED</span>" : "<span style=\"color: red\">TEST FAILED</span>") + "</b>" + "</pre>");
        }
        function printError(message, stack) {
            message = "<b>" + message + "</b>";
            if (((stack) !== undefined)) {
                message += "\n" + stack;
            }
            output("<pre style=\"margin-left: 20px;\">" + "<span style=\"color: red; background-color: rgba(255, 0, 0, .1);\">" + message + "</span>" + "</pre>");
        }
        function asyncTest(manifest, fnWrapper) {
            test(manifest, fnWrapper, true);
        }
        util.asyncTest = asyncTest;
        function run() {
            //если вдруг остались тесты.
            if (pTestCondList.length) {
                failed();
            }
            //если предыдущий тест был асинхронным, значит он кончился и надо распечатать результаты
            if (!((pTest) === null) && pTest.async == true) {
                printResults();
            }
            while(pTestList.length) {
                //начинаем новый тест
                pTest = pTestList.pop();
                iBegin = (Date.now());
                isPassed = true;
                printInfo();
                //start test
                try  {
                    pTest.entry();
                } catch (e) {
                    failed(e);
                    return;
                }
                if (!pTest.async) {
                    printResults();
                    pTest = null;
                } else {
                    return;
                }
            }
            ;
        }
        util.run = run;
        window.onload = function () {
            run();
        };
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var test = akra.util.test;
var asyncTest = akra.util.asyncTest;
var failed = akra.util.failed;
var run = akra.util.run;
var shouldBe = akra.util.shouldBe;
var shouldBeArray = akra.util.shouldBeArray;
var shouldBeTrue = akra.util.shouldBeTrue;
var shouldBeFalse = akra.util.shouldBeFalse;
var shouldBeNotNull = akra.util.shouldBeNotNull;
var check = akra.util.check;
var ok = check;
//"use strict";
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    akra.createEngine;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    (function (EEventTypes) {
        EEventTypes._map = [];
        EEventTypes._map[0] = "BROADCAST";
        EEventTypes.BROADCAST = 0;
        EEventTypes._map[1] = "UNICAST";
        EEventTypes.UNICAST = 1;
    })(akra.EEventTypes || (akra.EEventTypes = {}));
    var EEventTypes = akra.EEventTypes;
    ;
    // callOnce(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool;
    })(akra || (akra = {}));
var akra;
(function (akra) {
    (function (ESceneTypes) {
        ESceneTypes._map = [];
        ESceneTypes._map[0] = "TYPE_3D";
        ESceneTypes.TYPE_3D = 0;
        ESceneTypes._map[1] = "TYPE_2D";
        ESceneTypes.TYPE_2D = 1;
    })(akra.ESceneTypes || (akra.ESceneTypes = {}));
    var ESceneTypes = akra.ESceneTypes;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    /** Семейства ресурсов */
    (function (EResourceFamilies) {
        EResourceFamilies._map = [];
        EResourceFamilies.VIDEO_RESOURCE = 0;
        EResourceFamilies._map[1] = "AUDIO_RESOURCE";
        EResourceFamilies.AUDIO_RESOURCE = 1;
        EResourceFamilies._map[2] = "GAME_RESOURCE";
        EResourceFamilies.GAME_RESOURCE = 2;
        EResourceFamilies._map[3] = "TOTAL_RESOURCE_FAMILIES";
        EResourceFamilies.TOTAL_RESOURCE_FAMILIES = 3;
    })(akra.EResourceFamilies || (akra.EResourceFamilies = {}));
    var EResourceFamilies = akra.EResourceFamilies;
    ;
    /** Члены семейства видео ресурсов */
    (function (EVideoResources) {
        EVideoResources._map = [];
        EVideoResources._map[0] = "TEXTURE_RESOURCE";
        EVideoResources.TEXTURE_RESOURCE = 0;
        EVideoResources._map[1] = "VIDEOBUFFER_RESOURCE";
        EVideoResources.VIDEOBUFFER_RESOURCE = 1;
        EVideoResources._map[2] = "VERTEXBUFFER_RESOURCE";
        EVideoResources.VERTEXBUFFER_RESOURCE = 2;
        EVideoResources._map[3] = "INDEXBUFFER_RESOURCE";
        EVideoResources.INDEXBUFFER_RESOURCE = 3;
        EVideoResources._map[4] = "EFFECT_RESOURCE";
        EVideoResources.EFFECT_RESOURCE = 4;
        EVideoResources._map[5] = "RENDERMETHOD_RESOURCE";
        EVideoResources.RENDERMETHOD_RESOURCE = 5;
        EVideoResources._map[6] = "MODEL_RESOURCE";
        EVideoResources.MODEL_RESOURCE = 6;
        EVideoResources._map[7] = "EFFECTFILEDATA_RESOURCE";
        EVideoResources.EFFECTFILEDATA_RESOURCE = 7;
        EVideoResources._map[8] = "IMAGE_RESOURCE";
        EVideoResources.IMAGE_RESOURCE = 8;
        EVideoResources._map[9] = "SURFACEMATERIAL_RESOURCE";
        EVideoResources.SURFACEMATERIAL_RESOURCE = 9;
        EVideoResources._map[10] = "SHADERPROGRAM_RESOURCE";
        EVideoResources.SHADERPROGRAM_RESOURCE = 10;
        EVideoResources._map[11] = "COMPONENT_RESOURCE";
        EVideoResources.COMPONENT_RESOURCE = 11;
        EVideoResources._map[12] = "EFFECTDATA_RESOURCE";
        EVideoResources.EFFECTDATA_RESOURCE = 12;
        EVideoResources._map[13] = "TOTAL_VIDEO_RESOURCES";
        EVideoResources.TOTAL_VIDEO_RESOURCES = 13;
    })(akra.EVideoResources || (akra.EVideoResources = {}));
    var EVideoResources = akra.EVideoResources;
    ;
    (function (EAudioResources) {
        EAudioResources._map = [];
        EAudioResources._map[0] = "TOTAL_AUDIO_RESOURCES";
        EAudioResources.TOTAL_AUDIO_RESOURCES = 0;
    })(akra.EAudioResources || (akra.EAudioResources = {}));
    var EAudioResources = akra.EAudioResources;
    ;
    (function (EGameResources) {
        EGameResources._map = [];
        EGameResources._map[0] = "TOTAL_GAME_RESOURCES";
        EGameResources.TOTAL_GAME_RESOURCES = 0;
    })(akra.EGameResources || (akra.EGameResources = {}));
    var EGameResources = akra.EGameResources;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (ECompareFunction) {
        ECompareFunction._map = [];
        ECompareFunction._map[0] = "ALWAYS_FAIL";
        ECompareFunction.ALWAYS_FAIL = 0;
        ECompareFunction._map[1] = "ALWAYS_PASS";
        ECompareFunction.ALWAYS_PASS = 1;
        ECompareFunction._map[2] = "LESS";
        ECompareFunction.LESS = 2;
        ECompareFunction._map[3] = "LESS_EQUAL";
        ECompareFunction.LESS_EQUAL = 3;
        ECompareFunction._map[4] = "EQUAL";
        ECompareFunction.EQUAL = 4;
        ECompareFunction._map[5] = "NOT_EQUAL";
        ECompareFunction.NOT_EQUAL = 5;
        ECompareFunction._map[6] = "GREATER_EQUAL";
        ECompareFunction.GREATER_EQUAL = 6;
        ECompareFunction._map[7] = "GREATER";
        ECompareFunction.GREATER = 7;
    })(akra.ECompareFunction || (akra.ECompareFunction = {}));
    var ECompareFunction = akra.ECompareFunction;
    (function (ECullingMode) {
        ECullingMode._map = [];
        ECullingMode.NONE = 1;
        ECullingMode.CLOCKWISE = 2;
        ECullingMode.ANTICLOCKWISE = 3;
    })(akra.ECullingMode || (akra.ECullingMode = {}));
    var ECullingMode = akra.ECullingMode;
    (function (EFrameBufferTypes) {
        EFrameBufferTypes._map = [];
        EFrameBufferTypes.COLOR = 0x1;
        EFrameBufferTypes.DEPTH = 0x2;
        EFrameBufferTypes.STENCIL = 0x4;
    })(akra.EFrameBufferTypes || (akra.EFrameBufferTypes = {}));
    var EFrameBufferTypes = akra.EFrameBufferTypes;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    //API SPECIFIFC CONSTANTS
    (function (EPrimitiveTypes) {
        EPrimitiveTypes._map = [];
        EPrimitiveTypes.POINTLIST = 0;
        EPrimitiveTypes._map[1] = "LINELIST";
        EPrimitiveTypes.LINELIST = 1;
        EPrimitiveTypes._map[2] = "LINELOOP";
        EPrimitiveTypes.LINELOOP = 2;
        EPrimitiveTypes._map[3] = "LINESTRIP";
        EPrimitiveTypes.LINESTRIP = 3;
        EPrimitiveTypes._map[4] = "TRIANGLELIST";
        EPrimitiveTypes.TRIANGLELIST = 4;
        EPrimitiveTypes._map[5] = "TRIANGLESTRIP";
        EPrimitiveTypes.TRIANGLESTRIP = 5;
        EPrimitiveTypes._map[6] = "TRIANGLEFAN";
        EPrimitiveTypes.TRIANGLEFAN = 6;
    })(akra.EPrimitiveTypes || (akra.EPrimitiveTypes = {}));
    var EPrimitiveTypes = akra.EPrimitiveTypes;
    ;
    (function (ERenderCapabilitiesCategory) {
        ERenderCapabilitiesCategory._map = [];
        ERenderCapabilitiesCategory.C_COMMON = 0;
        ERenderCapabilitiesCategory.C_COMMON_2 = 1;
        ERenderCapabilitiesCategory.C_WEBGL = 2;
        ERenderCapabilitiesCategory.COUNT = 3;
    })(akra.ERenderCapabilitiesCategory || (akra.ERenderCapabilitiesCategory = {}));
    var ERenderCapabilitiesCategory = akra.ERenderCapabilitiesCategory;
    (function (ERenderCapabilities) {
        ERenderCapabilities._map = [];
        ERenderCapabilities.AUTOMIPMAP = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 0));
        ERenderCapabilities.BLENDING = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 1));
        /// Supports anisotropic texture filtering
        ERenderCapabilities.ANISOTROPY = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 2));
        /// Supports fixed-function DOT3 texture blend
        ERenderCapabilities.DOT3 = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 3));
        /// Supports cube mapping
        ERenderCapabilities.CUBEMAPPING = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 4));
        /// Supports hardware stencil buffer
        ERenderCapabilities.HWSTENCIL = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 5));
        /// Supports hardware vertex and index buffers
        ERenderCapabilities.VBO = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 7));
        /// Supports vertex programs (vertex shaders)
        ERenderCapabilities.VERTEX_PROGRAM = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 9));
        /// Supports fragment programs (pixel shaders)
        ERenderCapabilities.FRAGMENT_PROGRAM = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 10));
        /// Supports performing a scissor test to exclude areas of the screen
        ERenderCapabilities.SCISSOR_TEST = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 11));
        /// Supports separate stencil updates for both front and back faces
        ERenderCapabilities.TWO_SIDED_STENCIL = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 12));
        /// Supports wrapping the stencil value at the range extremeties
        ERenderCapabilities.STENCIL_WRAP = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 13));
        /// Supports hardware occlusion queries
        ERenderCapabilities.HWOCCLUSION = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 14));
        /// Supports user clipping planes
        ERenderCapabilities.USER_CLIP_PLANES = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 15));
        /// Supports the VET_UBYTE4 vertex element type
        ERenderCapabilities.VERTEX_FORMAT_UBYTE4 = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 16));
        /// Supports infinite far plane projection
        ERenderCapabilities.INFINITE_FAR_PLANE = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 17));
        /// Supports hardware render-to-texture (bigger than framebuffer)
        ERenderCapabilities.HWRENDER_TO_TEXTURE = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 18));
        /// Supports float textures and render targets
        ERenderCapabilities.TEXTURE_FLOAT = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 19));
        /// Supports non-power of two textures
        ERenderCapabilities.NON_POWER_OF_2_TEXTURES = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 20));
        /// Supports 3d (volume) textures
        ERenderCapabilities.TEXTURE_3D = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 21));
        /// Supports basic point sprite rendering
        ERenderCapabilities.POINT_SPRITES = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 22));
        /// Supports extra point parameters (minsize, maxsize, attenuation)
        ERenderCapabilities.POINT_EXTENDED_PARAMETERS = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 23));
        /// Supports vertex texture fetch
        ERenderCapabilities.VERTEX_TEXTURE_FETCH = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 24));
        /// Supports mipmap LOD biasing
        ERenderCapabilities.MIPMAP_LOD_BIAS = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 25));
        /// Supports hardware geometry programs
        ERenderCapabilities.GEOMETRY_PROGRAM = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 26));
        /// Supports rendering to vertex buffers
        ERenderCapabilities.HWRENDER_TO_VERTEX_BUFFER = ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 27));
        /// Supports compressed textures
        ERenderCapabilities.TEXTURE_COMPRESSION = ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 0));
        /// Supports compressed textures in the DXT/ST3C formats
        ERenderCapabilities.TEXTURE_COMPRESSION_DXT = ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 1));
        /// Supports compressed textures in the VTC format
        ERenderCapabilities.TEXTURE_COMPRESSION_VTC = ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 2));
        /// Supports compressed textures in the PVRTC format
        ERenderCapabilities.TEXTURE_COMPRESSION_PVRTC = ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 3));
        /// Supports fixed-function pipeline
        ERenderCapabilities.FIXED_FUNCTION = ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 4));
        /// Supports MRTs with different bit depths
        ERenderCapabilities.MRT_DIFFERENT_BIT_DEPTHS = ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 5));
        /// Supports Alpha to Coverage (A2C)
        ERenderCapabilities.ALPHA_TO_COVERAGE = ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 6));
        /// Supports Blending operations other than +
        ERenderCapabilities.ADVANCED_BLEND_OPERATIONS = ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 7));
        /// Supports a separate depth buffer for RTTs. D3D 9 & 10, OGL w/FBO (FBO implies this flag)
        ERenderCapabilities.RTT_SEPARATE_DEPTHBUFFER = ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 8));
        /// Supports using the MAIN depth buffer for RTTs. D3D 9&10, OGL w/FBO support unknown
        /// (undefined behavior?), OGL w/ copy supports it
        ERenderCapabilities.RTT_MAIN_DEPTHBUFFER_ATTACHABLE = ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 9));
        /// Supports attaching a depth buffer to an RTT that has width & height less or equal than RTT's.
        /// Otherwise must be of _exact_ same resolution. D3D 9, OGL 3.0 (not 2.0, not D3D10)
        ERenderCapabilities.RTT_DEPTHBUFFER_RESOLUTION_LESSEQUAL = ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 10));
        /// Supports using vertex buffers for instance data
        ERenderCapabilities.VERTEX_BUFFER_INSTANCE_DATA = ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 11));
        /// Supports using vertex buffers for instance data
        ERenderCapabilities.CAN_GET_COMPILED_SHADER_BUFFER = ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 12));
        // ***** GL Specific Caps *****
        /// Supports openGL GLEW version 1.5
        ERenderCapabilities.GL1_5_NOVBO = ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 1));
        /// Support for Frame Buffer Objects (FBOs)
        ERenderCapabilities.FBO = ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 2));
        /// Support for Frame Buffer Objects ARB implementation (regular FBO is higher precedence)
        ERenderCapabilities.FBO_ARB = ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 3));
        /// Support for Frame Buffer Objects ATI implementation (ARB FBO is higher precedence)
        ERenderCapabilities.FBO_ATI = ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 4));
        /// Support for PBuffer
        ERenderCapabilities.PBUFFER = ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 5));
        /// Support for GL 1.5 but without HW occlusion workaround
        ERenderCapabilities.GL1_5_NOHWOCCLUSION = ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 6));
        /// Support for point parameters ARB implementation
        ERenderCapabilities.POINT_EXTENDED_PARAMETERS_ARB = ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 7));
        /// Support for point parameters EXT implementation
        ERenderCapabilities.POINT_EXTENDED_PARAMETERS_EXT = ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 8));
        /// Support for Separate Shader Objects
        ERenderCapabilities.SEPARATE_SHADER_OBJECTS = ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 9));
    })(akra.ERenderCapabilities || (akra.ERenderCapabilities = {}));
    var ERenderCapabilities = akra.ERenderCapabilities;
    // export enum EGLSpecifics {
    //     UNPACK_ALIGNMENT = 0x0CF5,
    //     PACK_ALIGNMENT = 0x0D05,
    //     UNPACK_FLIP_Y_WEBGL = 0x9240,
    //     UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241,
    //     CONTEXT_LOST_WEBGL = 0x9242,
    //     UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243,
    //     BROWSER_DEFAULT_WEBGL = 0x9244
    // };
    // export enum EBufferMasks {
    //     DEPTH_BUFFER_BIT               = 0x00000100,
    //     STENCIL_BUFFER_BIT             = 0x00000400,
    //     COLOR_BUFFER_BIT               = 0x00004000
    // };
    // export enum EBufferUsages {
    //     STREAM_DRAW = 0x88E0,
    //     STATIC_DRAW = 0x88E4,
    //     DYNAMIC_DRAW = 0x88E8
    // };
    // export enum EBufferTypes {
    //     ARRAY_BUFFER = 0x8892,
    //     ELEMENT_ARRAY_BUFFER = 0x8893,
    //     FRAME_BUFFER = 0x8D40,
    //     RENDER_BUFFER = 0x8D41
    // };
    (function (EAttachmentTypes) {
        EAttachmentTypes._map = [];
        EAttachmentTypes.COLOR_ATTACHMENT0 = 0x8CE0;
        EAttachmentTypes.DEPTH_ATTACHMENT = 0x8D00;
        EAttachmentTypes.STENCIL_ATTACHMENT = 0x8D20;
        EAttachmentTypes.DEPTH_STENCIL_ATTACHMENT = 0x821A;
    })(akra.EAttachmentTypes || (akra.EAttachmentTypes = {}));
    var EAttachmentTypes = akra.EAttachmentTypes;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EUtilTimerCommands) {
        EUtilTimerCommands._map = [];
        EUtilTimerCommands._map[0] = "TIMER_RESET";
        //! <to reset the timer
        EUtilTimerCommands.TIMER_RESET = 0;
        EUtilTimerCommands._map[1] = "TIMER_START";
        //! <to start the timer
        EUtilTimerCommands.TIMER_START = 1;
        EUtilTimerCommands._map[2] = "TIMER_STOP";
        //! <to stop (or pause) the timer
        EUtilTimerCommands.TIMER_STOP = 2;
        EUtilTimerCommands._map[3] = "TIMER_ADVANCE";
        //! <to advance the timer by 0.1 seconds
        EUtilTimerCommands.TIMER_ADVANCE = 3;
        EUtilTimerCommands._map[4] = "TIMER_GET_ABSOLUTE_TIME";
        //! <to get the absolute system time
        EUtilTimerCommands.TIMER_GET_ABSOLUTE_TIME = 4;
        EUtilTimerCommands._map[5] = "TIMER_GET_APP_TIME";
        //! <to get the current time
        EUtilTimerCommands.TIMER_GET_APP_TIME = 5;
        EUtilTimerCommands._map[6] = "TIMER_GET_ELAPSED_TIME";
        EUtilTimerCommands.TIMER_GET_ELAPSED_TIME = 6;//! to get the time that elapsed between TIMER_GETELAPSEDTIME calls
        
    })(akra.EUtilTimerCommands || (akra.EUtilTimerCommands = {}));
    var EUtilTimerCommands = akra.EUtilTimerCommands;
    //static start(): IUtilTimer;
    })(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    //default parameters
    // ambient: IColor;
    // diffuse: IColor;
    // specular: IColor;
    // attenuation: IVec3;
    (function (ELightTypes) {
        ELightTypes._map = [];
        ELightTypes._map[0] = "UNKNOWN";
        ELightTypes.UNKNOWN = 0;
        ELightTypes._map[1] = "PROJECT";
        ELightTypes.PROJECT = 1;
        ELightTypes._map[2] = "OMNI";
        ELightTypes.OMNI = 2;
        ELightTypes._map[3] = "SUN";
        ELightTypes.SUN = 3;
    })(akra.ELightTypes || (akra.ELightTypes = {}));
    var ELightTypes = akra.ELightTypes;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (ENodeCreateMode) {
        ENodeCreateMode._map = [];
        ENodeCreateMode._map[0] = "k_Default";
        ENodeCreateMode.k_Default = 0;
        ENodeCreateMode._map[1] = "k_Necessary";
        ENodeCreateMode.k_Necessary = 1;
        ENodeCreateMode._map[2] = "k_Not";
        ENodeCreateMode.k_Not = 2;
    })(akra.ENodeCreateMode || (akra.ENodeCreateMode = {}));
    var ENodeCreateMode = akra.ENodeCreateMode;
    (function (EParserCode) {
        EParserCode._map = [];
        EParserCode._map[0] = "k_Pause";
        EParserCode.k_Pause = 0;
        EParserCode._map[1] = "k_Ok";
        EParserCode.k_Ok = 1;
        EParserCode._map[2] = "k_Error";
        EParserCode.k_Error = 2;
    })(akra.EParserCode || (akra.EParserCode = {}));
    var EParserCode = akra.EParserCode;
    (function (EParserType) {
        EParserType._map = [];
        EParserType._map[0] = "k_LR0";
        EParserType.k_LR0 = 0;
        EParserType._map[1] = "k_LR1";
        EParserType.k_LR1 = 1;
        EParserType._map[2] = "k_LALR";
        EParserType.k_LALR = 2;
    })(akra.EParserType || (akra.EParserType = {}));
    var EParserType = akra.EParserType;
    (function (EParseMode) {
        EParseMode._map = [];
        EParseMode.k_AllNode = 0x0001;
        EParseMode.k_Negate = 0x0002;
        EParseMode.k_Add = 0x0004;
        EParseMode.k_Optimize = 0x0008;
        EParseMode.k_DebugMode = 0x0010;
    })(akra.EParseMode || (akra.EParseMode = {}));
    var EParseMode = akra.EParseMode;
    (function (ETokenType) {
        ETokenType._map = [];
        ETokenType.k_NumericLiteral = 1;
        ETokenType._map[2] = "k_CommentLiteral";
        ETokenType.k_CommentLiteral = 2;
        ETokenType._map[3] = "k_StringLiteral";
        ETokenType.k_StringLiteral = 3;
        ETokenType._map[4] = "k_PunctuatorLiteral";
        ETokenType.k_PunctuatorLiteral = 4;
        ETokenType._map[5] = "k_WhitespaceLiteral";
        ETokenType.k_WhitespaceLiteral = 5;
        ETokenType._map[6] = "k_IdentifierLiteral";
        ETokenType.k_IdentifierLiteral = 6;
        ETokenType._map[7] = "k_KeywordLiteral";
        ETokenType.k_KeywordLiteral = 7;
        ETokenType._map[8] = "k_Unknown";
        ETokenType.k_Unknown = 8;
        ETokenType._map[9] = "k_End";
        ETokenType.k_End = 9;
    })(akra.ETokenType || (akra.ETokenType = {}));
    var ETokenType = akra.ETokenType;
    (function (EOperationType) {
        EOperationType._map = [];
        EOperationType.k_Error = 100;
        EOperationType._map[101] = "k_Shift";
        EOperationType.k_Shift = 101;
        EOperationType._map[102] = "k_Reduce";
        EOperationType.k_Reduce = 102;
        EOperationType._map[103] = "k_Success";
        EOperationType.k_Success = 103;
        EOperationType._map[104] = "k_Pause";
        EOperationType.k_Pause = 104;
        EOperationType._map[105] = "k_Ok";
        EOperationType.k_Ok = 105;
    })(akra.EOperationType || (akra.EOperationType = {}));
    var EOperationType = akra.EOperationType;
    // _getLexer(): ILexer;
    // _getSource(): string;
    // _getIndex(): uint;
    // _getTypeMap(): BoolMap;
    // _getStack(): uint[];
    // _getToken(): IToken;
    // _getCallback(): IFinishFunc;
    // _getCaller(): any;
    // _setParserState(sSource: string,
    //                 iIndex: uint,
    //                 sFileName: string,
    //                 pTree: IParseTree,
    //                 pTypes: BoolMap,
    //                 pStack: uint[],
    //                 pToken: IToken,
    //                 fnCallback: IFinishFunc,
    //                 pCaller: any): void;
    })(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    ;
    ;
    /**
    * Отражает состояние ресурса
    **/
    (function (EResourceItemEvents) {
        EResourceItemEvents._map = [];
        EResourceItemEvents._map[0] = "CREATED";
        //ресур создан
        EResourceItemEvents.CREATED = 0;
        EResourceItemEvents._map[1] = "LOADED";
        //ресур заполнен данным и готов к использованию
        EResourceItemEvents.LOADED = 1;
        EResourceItemEvents._map[2] = "DISABLED";
        //ресур в данный момент отключен для использования
        EResourceItemEvents.DISABLED = 2;
        EResourceItemEvents._map[3] = "ALTERED";
        //ресур был изменен после загрузки
        EResourceItemEvents.ALTERED = 3;
        EResourceItemEvents._map[4] = "TOTALRESOURCEFLAGS";
        EResourceItemEvents.TOTALRESOURCEFLAGS = 4;
    })(akra.EResourceItemEvents || (akra.EResourceItemEvents = {}));
    var EResourceItemEvents = akra.EResourceItemEvents;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EAFXInstructionTypes) {
        EAFXInstructionTypes._map = [];
        EAFXInstructionTypes.k_Instruction = 0;
        EAFXInstructionTypes._map[1] = "k_InstructionCollector";
        EAFXInstructionTypes.k_InstructionCollector = 1;
        EAFXInstructionTypes._map[2] = "k_SimpleInstruction";
        EAFXInstructionTypes.k_SimpleInstruction = 2;
        EAFXInstructionTypes._map[3] = "k_VariableTypeInstruction";
        EAFXInstructionTypes.k_VariableTypeInstruction = 3;
        EAFXInstructionTypes._map[4] = "k_SystemTypeInstruction";
        EAFXInstructionTypes.k_SystemTypeInstruction = 4;
        EAFXInstructionTypes._map[5] = "k_ComplexTypeInstruction";
        EAFXInstructionTypes.k_ComplexTypeInstruction = 5;
        EAFXInstructionTypes._map[6] = "k_TypedInstruction";
        EAFXInstructionTypes.k_TypedInstruction = 6;
        EAFXInstructionTypes._map[7] = "k_DeclInstruction";
        EAFXInstructionTypes.k_DeclInstruction = 7;
        EAFXInstructionTypes._map[8] = "k_IntInstruction";
        EAFXInstructionTypes.k_IntInstruction = 8;
        EAFXInstructionTypes._map[9] = "k_FloatInstruction";
        EAFXInstructionTypes.k_FloatInstruction = 9;
        EAFXInstructionTypes._map[10] = "k_BoolInstruction";
        EAFXInstructionTypes.k_BoolInstruction = 10;
        EAFXInstructionTypes._map[11] = "k_StringInstruction";
        EAFXInstructionTypes.k_StringInstruction = 11;
        EAFXInstructionTypes._map[12] = "k_IdInstruction";
        EAFXInstructionTypes.k_IdInstruction = 12;
        EAFXInstructionTypes._map[13] = "k_KeywordInstruction";
        EAFXInstructionTypes.k_KeywordInstruction = 13;
        EAFXInstructionTypes._map[14] = "k_TypeDeclInstruction";
        EAFXInstructionTypes.k_TypeDeclInstruction = 14;
        EAFXInstructionTypes._map[15] = "k_VariableDeclInstruction";
        EAFXInstructionTypes.k_VariableDeclInstruction = 15;
        EAFXInstructionTypes._map[16] = "k_AnnotationInstruction";
        EAFXInstructionTypes.k_AnnotationInstruction = 16;
        EAFXInstructionTypes._map[17] = "k_UsageTypeInstruction";
        EAFXInstructionTypes.k_UsageTypeInstruction = 17;
        EAFXInstructionTypes._map[18] = "k_BaseTypeInstruction";
        EAFXInstructionTypes.k_BaseTypeInstruction = 18;
        EAFXInstructionTypes._map[19] = "k_StructDeclInstruction";
        EAFXInstructionTypes.k_StructDeclInstruction = 19;
        EAFXInstructionTypes._map[20] = "k_StructFieldsInstruction";
        EAFXInstructionTypes.k_StructFieldsInstruction = 20;
        EAFXInstructionTypes._map[21] = "k_ExprInstruction";
        EAFXInstructionTypes.k_ExprInstruction = 21;
        EAFXInstructionTypes._map[22] = "k_IdExprInstruction";
        EAFXInstructionTypes.k_IdExprInstruction = 22;
        EAFXInstructionTypes._map[23] = "k_ArithmeticExprInstruction";
        EAFXInstructionTypes.k_ArithmeticExprInstruction = 23;
        EAFXInstructionTypes._map[24] = "k_AssignmentExprInstruction";
        EAFXInstructionTypes.k_AssignmentExprInstruction = 24;
        EAFXInstructionTypes._map[25] = "k_RelationalExprInstruction";
        EAFXInstructionTypes.k_RelationalExprInstruction = 25;
        EAFXInstructionTypes._map[26] = "k_LogicalExprInstruction";
        EAFXInstructionTypes.k_LogicalExprInstruction = 26;
        EAFXInstructionTypes._map[27] = "k_ConditionalExprInstruction";
        EAFXInstructionTypes.k_ConditionalExprInstruction = 27;
        EAFXInstructionTypes._map[28] = "k_CastExprInstruction";
        EAFXInstructionTypes.k_CastExprInstruction = 28;
        EAFXInstructionTypes._map[29] = "k_UnaryExprInstruction";
        EAFXInstructionTypes.k_UnaryExprInstruction = 29;
        EAFXInstructionTypes._map[30] = "k_PostfixIndexInstruction";
        EAFXInstructionTypes.k_PostfixIndexInstruction = 30;
        EAFXInstructionTypes._map[31] = "k_PostfixPointInstruction";
        EAFXInstructionTypes.k_PostfixPointInstruction = 31;
        EAFXInstructionTypes._map[32] = "k_PostfixArithmeticInstruction";
        EAFXInstructionTypes.k_PostfixArithmeticInstruction = 32;
        EAFXInstructionTypes._map[33] = "k_PrimaryExprInstruction";
        EAFXInstructionTypes.k_PrimaryExprInstruction = 33;
        EAFXInstructionTypes._map[34] = "k_ComplexExprInstruction";
        EAFXInstructionTypes.k_ComplexExprInstruction = 34;
        EAFXInstructionTypes._map[35] = "k_FunctionCallInstruction";
        EAFXInstructionTypes.k_FunctionCallInstruction = 35;
        EAFXInstructionTypes._map[36] = "k_SystemCallInstruction";
        EAFXInstructionTypes.k_SystemCallInstruction = 36;
        EAFXInstructionTypes._map[37] = "k_ConstructorCallInstruction";
        EAFXInstructionTypes.k_ConstructorCallInstruction = 37;
        EAFXInstructionTypes._map[38] = "k_CompileExprInstruction";
        EAFXInstructionTypes.k_CompileExprInstruction = 38;
        EAFXInstructionTypes._map[39] = "k_InitExprInstruction";
        EAFXInstructionTypes.k_InitExprInstruction = 39;
        EAFXInstructionTypes._map[40] = "k_SamplerStateBlockInstruction";
        EAFXInstructionTypes.k_SamplerStateBlockInstruction = 40;
        EAFXInstructionTypes._map[41] = "k_SamplerStateInstruction";
        EAFXInstructionTypes.k_SamplerStateInstruction = 41;
        EAFXInstructionTypes._map[42] = "k_ExtractExprInstruction";
        EAFXInstructionTypes.k_ExtractExprInstruction = 42;
        EAFXInstructionTypes._map[43] = "k_MemExprInstruction";
        EAFXInstructionTypes.k_MemExprInstruction = 43;
        EAFXInstructionTypes._map[44] = "k_FunctionDeclInstruction";
        EAFXInstructionTypes.k_FunctionDeclInstruction = 44;
        EAFXInstructionTypes._map[45] = "k_ShaderFunctionInstruction";
        EAFXInstructionTypes.k_ShaderFunctionInstruction = 45;
        EAFXInstructionTypes._map[46] = "k_SystemFunctionInstruction";
        EAFXInstructionTypes.k_SystemFunctionInstruction = 46;
        EAFXInstructionTypes._map[47] = "k_FunctionDefInstruction";
        EAFXInstructionTypes.k_FunctionDefInstruction = 47;
        EAFXInstructionTypes._map[48] = "k_StmtInstruction";
        EAFXInstructionTypes.k_StmtInstruction = 48;
        EAFXInstructionTypes._map[49] = "k_StmtBlockInstruction";
        EAFXInstructionTypes.k_StmtBlockInstruction = 49;
        EAFXInstructionTypes._map[50] = "k_ExprStmtInstruction";
        EAFXInstructionTypes.k_ExprStmtInstruction = 50;
        EAFXInstructionTypes._map[51] = "k_BreakStmtInstruction";
        EAFXInstructionTypes.k_BreakStmtInstruction = 51;
        EAFXInstructionTypes._map[52] = "k_WhileStmtInstruction";
        EAFXInstructionTypes.k_WhileStmtInstruction = 52;
        EAFXInstructionTypes._map[53] = "k_ForStmtInstruction";
        EAFXInstructionTypes.k_ForStmtInstruction = 53;
        EAFXInstructionTypes._map[54] = "k_IfStmtInstruction";
        EAFXInstructionTypes.k_IfStmtInstruction = 54;
        EAFXInstructionTypes._map[55] = "k_DeclStmtInstruction";
        EAFXInstructionTypes.k_DeclStmtInstruction = 55;
        EAFXInstructionTypes._map[56] = "k_ReturnStmtInstruction";
        EAFXInstructionTypes.k_ReturnStmtInstruction = 56;
        EAFXInstructionTypes._map[57] = "k_ExtractStmtInstruction";
        EAFXInstructionTypes.k_ExtractStmtInstruction = 57;
        EAFXInstructionTypes._map[58] = "k_SemicolonStmtInstruction";
        EAFXInstructionTypes.k_SemicolonStmtInstruction = 58;
        EAFXInstructionTypes._map[59] = "k_PassInstruction";
        EAFXInstructionTypes.k_PassInstruction = 59;
        EAFXInstructionTypes._map[60] = "k_TechniqueInstruction";
        EAFXInstructionTypes.k_TechniqueInstruction = 60;
    })(akra.EAFXInstructionTypes || (akra.EAFXInstructionTypes = {}));
    var EAFXInstructionTypes = akra.EAFXInstructionTypes;
    (function (EFunctionType) {
        EFunctionType._map = [];
        EFunctionType.k_Vertex = 0;
        EFunctionType.k_Pixel = 1;
        EFunctionType.k_Fragment = 1;
        EFunctionType.k_Function = 2;
        EFunctionType.k_PassFunction = 3;
    })(akra.EFunctionType || (akra.EFunctionType = {}));
    var EFunctionType = akra.EFunctionType;
    (function (ECheckStage) {
        ECheckStage._map = [];
        ECheckStage._map[0] = "CODE_TARGET_SUPPORT";
        /* Отсутсвуют конструкции не поддерживаемые языком назначения (GLSL) */
        ECheckStage.CODE_TARGET_SUPPORT = 0;
        ECheckStage._map[1] = "SELF_CONTAINED";
        /* Код замкнут, нет не определенных функций, пассов, техник. Нет мертвых функций. */
        ECheckStage.SELF_CONTAINED = 1;// VALIDATION  /* Код не содерит синтаксиески неправильных выражений, то что не исчерпывается */
        
    })(akra.ECheckStage || (akra.ECheckStage = {}));
    var ECheckStage = akra.ECheckStage;
    (function (EVarUsedMode) {
        EVarUsedMode._map = [];
        EVarUsedMode._map[0] = "k_Read";
        EVarUsedMode.k_Read = 0;
        EVarUsedMode._map[1] = "k_Write";
        EVarUsedMode.k_Write = 1;
        EVarUsedMode._map[2] = "k_ReadWrite";
        EVarUsedMode.k_ReadWrite = 2;
        EVarUsedMode._map[3] = "k_Undefined";
        EVarUsedMode.k_Undefined = 3;
        EVarUsedMode.k_Default = EVarUsedMode.k_ReadWrite;
    })(akra.EVarUsedMode || (akra.EVarUsedMode = {}));
    var EVarUsedMode = akra.EVarUsedMode;
    (function (EExtractExprType) {
        EExtractExprType._map = [];
        EExtractExprType._map[0] = "k_Header";
        EExtractExprType.k_Header = 0;
        EExtractExprType._map[1] = "k_Float";
        EExtractExprType.k_Float = 1;
        EExtractExprType._map[2] = "k_Int";
        EExtractExprType.k_Int = 2;
        EExtractExprType._map[3] = "k_Bool";
        EExtractExprType.k_Bool = 3;
        EExtractExprType._map[4] = "k_Float2";
        EExtractExprType.k_Float2 = 4;
        EExtractExprType._map[5] = "k_Int2";
        EExtractExprType.k_Int2 = 5;
        EExtractExprType._map[6] = "k_Bool2";
        EExtractExprType.k_Bool2 = 6;
        EExtractExprType._map[7] = "k_Float3";
        EExtractExprType.k_Float3 = 7;
        EExtractExprType._map[8] = "k_Int3";
        EExtractExprType.k_Int3 = 8;
        EExtractExprType._map[9] = "k_Bool3";
        EExtractExprType.k_Bool3 = 9;
        EExtractExprType._map[10] = "k_Float4";
        EExtractExprType.k_Float4 = 10;
        EExtractExprType._map[11] = "k_Int4";
        EExtractExprType.k_Int4 = 11;
        EExtractExprType._map[12] = "k_Bool4";
        EExtractExprType.k_Bool4 = 12;
        EExtractExprType._map[13] = "k_Float4x4";
        EExtractExprType.k_Float4x4 = 13;
    })(akra.EExtractExprType || (akra.EExtractExprType = {}));
    var EExtractExprType = akra.EExtractExprType;
    (function (EAFXBlendMode) {
        EAFXBlendMode._map = [];
        EAFXBlendMode._map[0] = "k_Shared";
        EAFXBlendMode.k_Shared = 0;
        EAFXBlendMode._map[1] = "k_Uniform";
        EAFXBlendMode.k_Uniform = 1;
        EAFXBlendMode._map[2] = "k_Attribute";
        EAFXBlendMode.k_Attribute = 2;
        EAFXBlendMode._map[3] = "k_Foreign";
        EAFXBlendMode.k_Foreign = 3;
        EAFXBlendMode._map[4] = "k_Global";
        EAFXBlendMode.k_Global = 4;
        EAFXBlendMode._map[5] = "k_Varying";
        EAFXBlendMode.k_Varying = 5;
        EAFXBlendMode._map[6] = "k_TypeDecl";
        EAFXBlendMode.k_TypeDecl = 6;
        EAFXBlendMode._map[7] = "k_VertexOut";
        EAFXBlendMode.k_VertexOut = 7;
    })(akra.EAFXBlendMode || (akra.EAFXBlendMode = {}));
    var EAFXBlendMode = akra.EAFXBlendMode;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EPixelFormats) {
        EPixelFormats._map = [];
        /*Unknown pixel format.*/
        EPixelFormats.UNKNOWN = 0;
        /*8-bit pixel format, all bits luminance.*/
        EPixelFormats.L8 = 1;
        EPixelFormats.BYTE_L = EPixelFormats.L8;
        /*16-bit pixel format, all bits luminance.*/
        EPixelFormats.L16 = 2;
        EPixelFormats.SHORT_L = EPixelFormats.L16;
        /*8-bit pixel format, all bits alpha.*/
        EPixelFormats.A8 = 3;
        EPixelFormats.BYTE_A = EPixelFormats.A8;
        /*8-bit pixel format, 4 bits alpha, 4 bits luminance.*/
        EPixelFormats.A4L4 = 4;
        /*2 byte pixel format, 1 byte luminance, 1 byte alpha*/
        EPixelFormats.BYTE_LA = 5;
        /*16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.*/
        EPixelFormats.R5G6B5 = 6;
        /*16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.*/
        EPixelFormats.B5G6R5 = 7;
        /*8-bit pixel format, 2 bits blue, 3 bits green, 3 bits red.*/
        EPixelFormats.R3G3B2 = 31;
        /*16-bit pixel format, 4 bits for alpha, red, green and blue.*/
        EPixelFormats.A4R4G4B4 = 8;
        /*16-bit pixel format, 5 bits for blue, green, red and 1 for alpha.*/
        EPixelFormats.A1R5G5B5 = 9;
        /*24-bit pixel format, 8 bits for red, green and blue.*/
        EPixelFormats.R8G8B8 = 10;
        /*24-bit pixel format, 8 bits for blue, green and red.*/
        EPixelFormats.B8G8R8 = 11;
        /*32-bit pixel format, 8 bits for alpha, red, green and blue.*/
        EPixelFormats.A8R8G8B8 = 12;
        /*32-bit pixel format, 8 bits for blue, green, red and alpha.*/
        EPixelFormats.A8B8G8R8 = 13;
        /*32-bit pixel format, 8 bits for blue, green, red and alpha.*/
        EPixelFormats.B8G8R8A8 = 14;
        /*32-bit pixel format, 8 bits for red, green, blue and alpha.*/
        EPixelFormats.R8G8B8A8 = 28;
        /*32-bit pixel format, 8 bits for red, 8 bits for green, 8 bits for blue like A8R8G8B8, but alpha will get discarded*/
        EPixelFormats.X8R8G8B8 = 26;
        /*32-bit pixel format, 8 bits for blue, 8 bits for green, 8 bits for red like A8B8G8R8, but alpha will get discarded*/
        EPixelFormats.X8B8G8R8 = 27;
        /*3 byte pixel format, 1 byte for red, 1 byte for green, 1 byte for blue*/
        EPixelFormats.BYTE_RGB = EPixelFormats.R8G8B8;
        /*3 byte pixel format, 1 byte for blue, 1 byte for green, 1 byte for red*/
        EPixelFormats.BYTE_BGR = EPixelFormats.B8G8R8;
        /*4 byte pixel format, 1 byte for blue, 1 byte for green, 1 byte for red and one byte for alpha*/
        EPixelFormats.BYTE_BGRA = EPixelFormats.B8G8R8A8;
        /*4 byte pixel format, 1 byte for red, 1 byte for green, 1 byte for blue, and one byte for alpha*/
        EPixelFormats.BYTE_RGBA = EPixelFormats.R8G8B8A8;
        EPixelFormats.BYTE_ABGR = EPixelFormats.A8B8G8R8;
        EPixelFormats.BYTE_ARGB = EPixelFormats.A8R8G8B8;
        /*32-bit pixel format, 2 bits for alpha, 10 bits for red, green and blue.*/
        EPixelFormats.A2R10G10B10 = 15;
        /*32-bit pixel format, 10 bits for blue, green and red, 2 bits for alpha.*/
        EPixelFormats.A2B10G10R10 = 16;
        /*DDS (DirectDraw Surface) DXT1 format.*/
        EPixelFormats.DXT1 = 17;
        /*DDS (DirectDraw Surface) DXT2 format.*/
        EPixelFormats.DXT2 = 18;
        /*DDS (DirectDraw Surface) DXT3 format.*/
        EPixelFormats.DXT3 = 19;
        /*DDS (DirectDraw Surface) DXT4 format.*/
        EPixelFormats.DXT4 = 20;
        /*DDS (DirectDraw Surface) DXT5 format.*/
        EPixelFormats.DXT5 = 21;
        /*16-bit pixel format, 16 bits (float) for red*/
        EPixelFormats.FLOAT16_R = 32;
        /*48-bit pixel format, 16 bits (float) for red, 16 bits (float) for green, 16 bits (float) for blue*/
        EPixelFormats.FLOAT16_RGB = 22;
        /*64-bit pixel format, 16 bits (float) for red, 16 bits (float) for green, 16 bits (float) for blue, 16 bits (float) for alpha*/
        EPixelFormats.FLOAT16_RGBA = 23;
        /*32-bit pixel format, 32 bits (float) for red*/
        EPixelFormats.FLOAT32_R = 33;
        /*96-bit pixel format, 32 bits (float) for red, 32 bits (float) for green, 32 bits (float) for blue*/
        EPixelFormats.FLOAT32_RGB = 24;
        /*128-bit pixel format, 32 bits (float) for red, 32 bits (float) for green, 32 bits (float) for blue, 32 bits (float) for alpha*/
        EPixelFormats.FLOAT32_RGBA = 25;
        /*32-bit, 2-channel s10e5 floating point pixel format, 16-bit green, 16-bit red*/
        EPixelFormats.FLOAT16_GR = 35;
        /*64-bit, 2-channel floating point pixel format, 32-bit green, 32-bit red*/
        EPixelFormats.FLOAT32_GR = 36;
        /*Float Depth texture format*/
        EPixelFormats.FLOAT32_DEPTH = 29;
        EPixelFormats.DEPTH8 = 44;
        /*Byte Depth texture format */
        EPixelFormats.BYTE_DEPTH = EPixelFormats.DEPTH8;
        EPixelFormats.DEPTH16 = 45;
        EPixelFormats.SHORT_DEPTH = EPixelFormats.DEPTH16;
        EPixelFormats.DEPTH32 = 46;
        EPixelFormats.DEPTH24STENCIL8 = 47;
        /*64-bit pixel format, 16 bits for red, green, blue and alpha*/
        EPixelFormats.SHORT_RGBA = 30;
        /*32-bit pixel format, 16-bit green, 16-bit red*/
        EPixelFormats.SHORT_GR = 34;
        /*48-bit pixel format, 16 bits for red, green and blue*/
        EPixelFormats.SHORT_RGB = 37;
        /*PVRTC (PowerVR) RGB 2 bpp.*/
        EPixelFormats.PVRTC_RGB2 = 38;
        /*PVRTC (PowerVR) RGBA 2 bpp.*/
        EPixelFormats.PVRTC_RGBA2 = 39;
        /*PVRTC (PowerVR) RGB 4 bpp.*/
        EPixelFormats.PVRTC_RGB4 = 40;
        /*PVRTC (PowerVR) RGBA 4 bpp.*/
        EPixelFormats.PVRTC_RGBA4 = 41;
        /*8-bit pixel format, all bits red.*/
        EPixelFormats.R8 = 42;
        /*16-bit pixel format, 8 bits red, 8 bits green.*/
        EPixelFormats.RG8 = 43;
        EPixelFormats.TOTAL = 48;
    })(akra.EPixelFormats || (akra.EPixelFormats = {}));
    var EPixelFormats = akra.EPixelFormats;
    ;
    /**
    * Flags defining some on/off properties of pixel formats
    */
    (function (EPixelFormatFlags) {
        EPixelFormatFlags._map = [];
        // This format has an alpha channel
        EPixelFormatFlags.HASALPHA = 0x00000001;
        // This format is compressed. This invalidates the values in elemBytes,
        // elemBits and the bit counts as these might not be fixed in a compressed format.
        EPixelFormatFlags.COMPRESSED = 0x00000002;
        // This is a floating point format
        EPixelFormatFlags.FLOAT = 0x00000004;
        // This is a depth format (for depth textures)
        EPixelFormatFlags.DEPTH = 0x00000008;
        // Format is in native endian. Generally true for the 16, 24 and 32 bits
        // formats which can be represented as machine integers.
        EPixelFormatFlags.NATIVEENDIAN = 0x00000010;
        // This is an intensity format instead of a RGB one. The luminance
        // replaces R,G and B. (but not A)
        EPixelFormatFlags.LUMINANCE = 0x00000020;
        EPixelFormatFlags.STENCIL = 0x00000040;
    })(akra.EPixelFormatFlags || (akra.EPixelFormatFlags = {}));
    var EPixelFormatFlags = akra.EPixelFormatFlags;
    /** Pixel component format */
    (function (EPixelComponentTypes) {
        EPixelComponentTypes._map = [];
        /*Byte per component (8 bit fixed 0.0..1.0)*/
        EPixelComponentTypes.BYTE = 0;
        /*Short per component (16 bit fixed 0.0..1.0))*/
        EPixelComponentTypes.SHORT = 1;
        EPixelComponentTypes.INT = 2;
        /*16 bit float per component*/
        EPixelComponentTypes.FLOAT16 = 3;
        /*32 bit float per component*/
        EPixelComponentTypes.FLOAT32 = 4;
        /*Number of pixel types*/
        EPixelComponentTypes.COUNT = 5;
    })(akra.EPixelComponentTypes || (akra.EPixelComponentTypes = {}));
    var EPixelComponentTypes = akra.EPixelComponentTypes;
    ;
    (function (EFilters) {
        EFilters._map = [];
        EFilters._map[0] = "NEAREST";
        EFilters.NEAREST = 0;
        EFilters._map[1] = "LINEAR";
        EFilters.LINEAR = 1;
        EFilters._map[2] = "BILINEAR";
        EFilters.BILINEAR = 2;
        EFilters._map[3] = "BOX";
        EFilters.BOX = 3;
        EFilters._map[4] = "TRIANGLE";
        EFilters.TRIANGLE = 4;
        EFilters._map[5] = "BICUBIC";
        EFilters.BICUBIC = 5;
    })(akra.EFilters || (akra.EFilters = {}));
    var EFilters = akra.EFilters;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EHardwareBufferFlags) {
        EHardwareBufferFlags._map = [];
        EHardwareBufferFlags.STATIC = 0x01;
        EHardwareBufferFlags.DYNAMIC = 0x02;
        EHardwareBufferFlags.STREAM = 0x80;
        EHardwareBufferFlags.READABLE = 0x04;
        EHardwareBufferFlags.BACKUP_COPY = 0x08;
        /** indicate, that buffer does not use GPU memory or other specific memory. */
        EHardwareBufferFlags.SOFTWARE = 0x10;
        /** Indicate, tha buffer uses specific data aligment */
        EHardwareBufferFlags.ALIGNMENT = 0x20;
        /** Indicates that the application will be refilling the contents
        of the buffer regularly (not just updating, but generating the
        contents from scratch), and therefore does not mind if the contents
        of the buffer are lost somehow and need to be recreated. This
        allows and additional level of optimisation on the buffer.
        This option only really makes sense when combined with
        DYNAMIC and without READING.
        */
        EHardwareBufferFlags.DISCARDABLE = 0x40;
        EHardwareBufferFlags.STATIC_READABLE = EHardwareBufferFlags.STATIC | EHardwareBufferFlags.READABLE;
        EHardwareBufferFlags.DYNAMIC_DISCARDABLE = EHardwareBufferFlags.DYNAMIC | EHardwareBufferFlags.DISCARDABLE;
    })(akra.EHardwareBufferFlags || (akra.EHardwareBufferFlags = {}));
    var EHardwareBufferFlags = akra.EHardwareBufferFlags;
    (function (ELockFlags) {
        ELockFlags._map = [];
        ELockFlags.READ = 0x01;
        ELockFlags.WRITE = 0x02;
        ELockFlags.DISCARD = 0x04;
        ELockFlags.NO_OVERWRITE = 0x08;
        ELockFlags.NORMAL = ELockFlags.READ | ELockFlags.WRITE;
    })(akra.ELockFlags || (akra.ELockFlags = {}));
    var ELockFlags = akra.ELockFlags;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    (function (ETextureFlags) {
        ETextureFlags._map = [];
        ETextureFlags.STATIC = akra.EHardwareBufferFlags.STATIC;
        ETextureFlags.DYNAMIC = akra.EHardwareBufferFlags.DYNAMIC;
        ETextureFlags.READEBLE = akra.EHardwareBufferFlags.READABLE;
        ETextureFlags.DYNAMIC_DISCARDABLE = akra.EHardwareBufferFlags.DYNAMIC_DISCARDABLE;
        /// mipmaps will be automatically generated for this texture
        ETextureFlags.AUTOMIPMAP = 0x100;
        /// this texture will be a render target, i.e. used as a target for render to texture
        /// setting this flag will ignore all other texture usages except AUTOMIPMAP
        ETextureFlags.RENDERTARGET = 0x200;
        /// default to automatic mipmap generation static textures
        ETextureFlags.DEFAULT = ETextureFlags.STATIC;
    })(akra.ETextureFlags || (akra.ETextureFlags = {}));
    var ETextureFlags = akra.ETextureFlags;
    (function (ETextureFilters) {
        ETextureFilters._map = [];
        ETextureFilters.NEAREST = 0x2600;
        ETextureFilters.LINEAR = 0x2601;
        ETextureFilters.NEAREST_MIPMAP_NEAREST = 0x2700;
        ETextureFilters.LINEAR_MIPMAP_NEAREST = 0x2701;
        ETextureFilters.NEAREST_MIPMAP_LINEAR = 0x2702;
        ETextureFilters.LINEAR_MIPMAP_LINEAR = 0x2703;
    })(akra.ETextureFilters || (akra.ETextureFilters = {}));
    var ETextureFilters = akra.ETextureFilters;
    ;
    (function (ETextureWrapModes) {
        ETextureWrapModes._map = [];
        ETextureWrapModes.REPEAT = 0x2901;
        ETextureWrapModes.CLAMP_TO_EDGE = 0x812F;
        ETextureWrapModes.MIRRORED_REPEAT = 0x8370;
    })(akra.ETextureWrapModes || (akra.ETextureWrapModes = {}));
    var ETextureWrapModes = akra.ETextureWrapModes;
    ;
    (function (ETextureParameters) {
        ETextureParameters._map = [];
        ETextureParameters.MAG_FILTER = 0x2800;
        ETextureParameters._map[10241] = "MIN_FILTER";
        ETextureParameters.MIN_FILTER = 10241;
        ETextureParameters._map[10242] = "WRAP_S";
        ETextureParameters.WRAP_S = 10242;
        ETextureParameters._map[10243] = "WRAP_T";
        ETextureParameters.WRAP_T = 10243;
    })(akra.ETextureParameters || (akra.ETextureParameters = {}));
    var ETextureParameters = akra.ETextureParameters;
    ;
    (function (ETextureTypes) {
        ETextureTypes._map = [];
        ETextureTypes.TEXTURE_2D = 0x0DE1;
        ETextureTypes.TEXTURE_CUBE_MAP = 0x8513;
    })(akra.ETextureTypes || (akra.ETextureTypes = {}));
    var ETextureTypes = akra.ETextureTypes;
    ;
    (function (ECubeFace) {
        ECubeFace._map = [];
        ECubeFace.POSITIVE_X = 0;
        ECubeFace.NEGATIVE_X = 1;
        ECubeFace.POSITIVE_Y = 2;
        ECubeFace.NEGATIVE_Y = 3;
        ECubeFace.POSITIVE_Z = 4;
        ECubeFace.NEGATIVE_Z = 5;
    })(akra.ECubeFace || (akra.ECubeFace = {}));
    var ECubeFace = akra.ECubeFace;
    ;
    (function (ETextureCubeFlags) {
        ETextureCubeFlags._map = [];
        ETextureCubeFlags.POSITIVE_X = 0x00000001;
        ETextureCubeFlags.NEGATIVE_X = 0x00000002;
        ETextureCubeFlags.POSITIVE_Y = 0x00000004;
        ETextureCubeFlags.NEGATIVE_Y = 0x00000008;
        ETextureCubeFlags.POSITIVE_Z = 0x0000000c;
        ETextureCubeFlags.NEGATIVE_Z = 0x000000010;
    })(akra.ETextureCubeFlags || (akra.ETextureCubeFlags = {}));
    var ETextureCubeFlags = akra.ETextureCubeFlags;
    ;
    (function (ETextureUnits) {
        ETextureUnits._map = [];
        ETextureUnits.TEXTURE0 = 0x84C0;
    })(akra.ETextureUnits || (akra.ETextureUnits = {}));
    var ETextureUnits = akra.ETextureUnits;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    (function (ESurfaceMaterialTextures) {
        ESurfaceMaterialTextures._map = [];
        ESurfaceMaterialTextures.TEXTURE0 = 0;
        ESurfaceMaterialTextures._map[1] = "TEXTURE1";
        ESurfaceMaterialTextures.TEXTURE1 = 1;
        ESurfaceMaterialTextures._map[2] = "TEXTURE2";
        ESurfaceMaterialTextures.TEXTURE2 = 2;
        ESurfaceMaterialTextures._map[3] = "TEXTURE3";
        ESurfaceMaterialTextures.TEXTURE3 = 3;
        ESurfaceMaterialTextures._map[4] = "TEXTURE4";
        ESurfaceMaterialTextures.TEXTURE4 = 4;
        ESurfaceMaterialTextures._map[5] = "TEXTURE5";
        ESurfaceMaterialTextures.TEXTURE5 = 5;
        ESurfaceMaterialTextures._map[6] = "TEXTURE6";
        ESurfaceMaterialTextures.TEXTURE6 = 6;
        ESurfaceMaterialTextures._map[7] = "TEXTURE7";
        ESurfaceMaterialTextures.TEXTURE7 = 7;
        ESurfaceMaterialTextures._map[8] = "TEXTURE8";
        ESurfaceMaterialTextures.TEXTURE8 = 8;
        ESurfaceMaterialTextures._map[9] = "TEXTURE9";
        ESurfaceMaterialTextures.TEXTURE9 = 9;
        ESurfaceMaterialTextures._map[10] = "TEXTURE10";
        ESurfaceMaterialTextures.TEXTURE10 = 10;
        ESurfaceMaterialTextures._map[11] = "TEXTURE11";
        ESurfaceMaterialTextures.TEXTURE11 = 11;
        ESurfaceMaterialTextures._map[12] = "TEXTURE12";
        ESurfaceMaterialTextures.TEXTURE12 = 12;
        ESurfaceMaterialTextures._map[13] = "TEXTURE13";
        ESurfaceMaterialTextures.TEXTURE13 = 13;
        ESurfaceMaterialTextures._map[14] = "TEXTURE14";
        ESurfaceMaterialTextures.TEXTURE14 = 14;
        ESurfaceMaterialTextures._map[15] = "TEXTURE15";
        ESurfaceMaterialTextures.TEXTURE15 = 15;
        ESurfaceMaterialTextures.DIFFUSE = ESurfaceMaterialTextures.TEXTURE0;
        ESurfaceMaterialTextures.AMBIENT = ESurfaceMaterialTextures.TEXTURE1;
        ESurfaceMaterialTextures.SPECULAR = ESurfaceMaterialTextures.TEXTURE2;
        ESurfaceMaterialTextures.EMISSIVE = ESurfaceMaterialTextures.TEXTURE3;
        ESurfaceMaterialTextures.NORMAL = ESurfaceMaterialTextures.TEXTURE4;
        ESurfaceMaterialTextures.EMISSION = ESurfaceMaterialTextures.EMISSIVE;
    })(akra.ESurfaceMaterialTextures || (akra.ESurfaceMaterialTextures = {}));
    var ESurfaceMaterialTextures = akra.ESurfaceMaterialTextures;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EAFXShaderVariableType) {
        EAFXShaderVariableType._map = [];
        EAFXShaderVariableType.k_NotVar = 0;
        EAFXShaderVariableType.k_Texture = 2;
        EAFXShaderVariableType._map[3] = "k_Float";
        EAFXShaderVariableType.k_Float = 3;
        EAFXShaderVariableType._map[4] = "k_Int";
        EAFXShaderVariableType.k_Int = 4;
        EAFXShaderVariableType._map[5] = "k_Bool";
        EAFXShaderVariableType.k_Bool = 5;
        EAFXShaderVariableType._map[6] = "k_Float2";
        EAFXShaderVariableType.k_Float2 = 6;
        EAFXShaderVariableType._map[7] = "k_Int2";
        EAFXShaderVariableType.k_Int2 = 7;
        EAFXShaderVariableType._map[8] = "k_Bool2";
        EAFXShaderVariableType.k_Bool2 = 8;
        EAFXShaderVariableType._map[9] = "k_Float3";
        EAFXShaderVariableType.k_Float3 = 9;
        EAFXShaderVariableType._map[10] = "k_Int3";
        EAFXShaderVariableType.k_Int3 = 10;
        EAFXShaderVariableType._map[11] = "k_Bool3";
        EAFXShaderVariableType.k_Bool3 = 11;
        EAFXShaderVariableType._map[12] = "k_Float4";
        EAFXShaderVariableType.k_Float4 = 12;
        EAFXShaderVariableType._map[13] = "k_Int4";
        EAFXShaderVariableType.k_Int4 = 13;
        EAFXShaderVariableType._map[14] = "k_Bool4";
        EAFXShaderVariableType.k_Bool4 = 14;
        EAFXShaderVariableType._map[15] = "k_Float2x2";
        EAFXShaderVariableType.k_Float2x2 = 15;
        EAFXShaderVariableType._map[16] = "k_Float3x3";
        EAFXShaderVariableType.k_Float3x3 = 16;
        EAFXShaderVariableType._map[17] = "k_Float4x4";
        EAFXShaderVariableType.k_Float4x4 = 17;
        EAFXShaderVariableType._map[18] = "k_Sampler2D";
        EAFXShaderVariableType.k_Sampler2D = 18;
        EAFXShaderVariableType._map[19] = "k_SamplerCUBE";
        EAFXShaderVariableType.k_SamplerCUBE = 19;
        EAFXShaderVariableType._map[20] = "k_SamplerVertexTexture";
        EAFXShaderVariableType.k_SamplerVertexTexture = 20;
        EAFXShaderVariableType._map[21] = "k_CustomSystem";
        EAFXShaderVariableType.k_CustomSystem = 21;
        EAFXShaderVariableType._map[22] = "k_Complex";
        EAFXShaderVariableType.k_Complex = 22;
    })(akra.EAFXShaderVariableType || (akra.EAFXShaderVariableType = {}));
    var EAFXShaderVariableType = akra.EAFXShaderVariableType;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    (function (EDataFlowTypes) {
        EDataFlowTypes._map = [];
        /*!< The data stream can be marked up its index.*/
        EDataFlowTypes.MAPPABLE = 1;
        /*!< The data stream cannot be marked up its index.*/
        EDataFlowTypes.UNMAPPABLE = 0;
    })(akra.EDataFlowTypes || (akra.EDataFlowTypes = {}));
    var EDataFlowTypes = akra.EDataFlowTypes;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    (function (EModelFormats) {
        EModelFormats._map = [];
        EModelFormats._map[0] = "COLLADA";
        EModelFormats.COLLADA = 0;
    })(akra.EModelFormats || (akra.EModelFormats = {}));
    var EModelFormats = akra.EModelFormats;
})(akra || (akra = {}));
// totalAnimations: uint;
// totalMeshes: uint;
// node: ISceneNode;
// getAnimation(iAnim: uint): IAnimationBase;
// setAnimation(iAnim: uint, pAnimation: IAnimationBase): void;
// addAnimation(pAnimation: IAnimationBase): void;
// getAnimationController(): IAnimationController;
// getMesh(iMesh: uint): IMesh;
// addMesh(pMesh: IMesh): void;
// addNode(pNode: ISceneNode): void;
// addSkeleton(pSkeleton: ISkeleton): void;
// addToScene(pScene: IScene3d): bool;
//    attachToScene(pNode: ISceneNode): bool;
// getRootNodes(): ISceneNode[];
// loadResource(sFilename?: string, pOptions?: IColladaLoadOptions, fnCallback?: (pModel: IModel) => void): bool;
// loadAnimation(sFilename: string): bool;
// //instead old method: applyShadow();
// _setup(): bool;
// _notifyFileLoaded(): uint;
// _notifyFileLoad(): uint;
// _totalFiles(): uint;
var akra;
(function (akra) {
    (function (EResourceCodes) {
        EResourceCodes._map = [];
        EResourceCodes.INVALID_CODE = 0xFFFFFFFF;
    })(akra.EResourceCodes || (akra.EResourceCodes = {}));
    var EResourceCodes = akra.EResourceCodes;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            var ResourceCode = (function () {
                function ResourceCode(iFamily, iType) {
                    this.iValue = (akra.EResourceCodes.INVALID_CODE);
                    switch(arguments.length) {
                        case 0:
                            this.iValue = akra.EResourceCodes.INVALID_CODE;
                            break;
                        case 1:
                            if (arguments[0] instanceof ResourceCode) {
                                this.iValue = arguments[0].iValue;
                            } else {
                                this.iValue = arguments[0];
                            }
                            break;
                        case 2:
                            this.family = arguments[0];
                            this.type = arguments[1];
                            break;
                    }
                }
                Object.defineProperty(ResourceCode.prototype, "family", {
                    get: function () {
                        return this.iValue >> 16;
                    },
                    set: function (iNewFamily) {
                        this.iValue &= 0x0000FFFF;
                        this.iValue |= iNewFamily << 16;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourceCode.prototype, "type", {
                    get: function () {
                        return this.iValue & 0x0000FFFF;
                    },
                    set: function (iNewType) {
                        this.iValue &= 0xFFFF0000;
                        this.iValue |= iNewType & 0x0000FFFF;
                    },
                    enumerable: true,
                    configurable: true
                });
                ResourceCode.prototype.setInvalid = function () {
                    this.iValue = akra.EResourceCodes.INVALID_CODE;
                };
                ResourceCode.prototype.less = function (pSrc) {
                    return this.iValue < pSrc.valueOf();
                };
                ResourceCode.prototype.eq = function (pSrc) {
                    this.iValue = pSrc.valueOf();
                    return this;
                };
                ResourceCode.prototype.valueOf = function () {
                    return this.iValue;
                };
                ResourceCode.prototype.toNumber = function () {
                    return this.iValue;
                };
                return ResourceCode;
            })();
            pool.ResourceCode = ResourceCode;            
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var ReferenceCounter = (function () {
            function ReferenceCounter(pSrc) {
                this.nReferenceCount = 0;
            }
            ReferenceCounter.prototype.referenceCount = /** @inline */
            function () {
                return this.nReferenceCount;
            };
            ReferenceCounter.prototype.destructor = /** @inline */
            function () {
 {
                    util.logger.setSourceLocation("util/ReferenceCounter.ts", 26);
                    util.logger.assert(this.nReferenceCount === 0, 'object is used');
                }
                ;
            };
            ReferenceCounter.prototype.release = function () {
 {
                    util.logger.setSourceLocation("util/ReferenceCounter.ts", 30);
                    util.logger.assert(this.nReferenceCount > 0, 'object is used');
                }
                ;
                this.nReferenceCount--;
                return this.nReferenceCount;
            };
            ReferenceCounter.prototype.addRef = function () {
 {
                    util.logger.setSourceLocation("util/ReferenceCounter.ts", 36);
                    util.logger.assert(this.nReferenceCount != akra.MIN_INT32, 'reference fail');
                }
                ;
                this.nReferenceCount++;
                return this.nReferenceCount;
            };
            ReferenceCounter.prototype.eq = /** @inline */
            function (pSrc) {
                return this;
            };
            return ReferenceCounter;
        })();
        util.ReferenceCounter = ReferenceCounter;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    /*console.error(this.getEventTable());*/
    /**event, signal, slot*/
    /**event, signal, slot*/
    //#define END_EVENT_TABLE()
    (function (events) {
        var EventTable = (function () {
            function EventTable() {
                this.broadcast = {};
                this.unicast = {};
            }
            EventTable.prototype.addDestination = function (iGuid, sSignal, pTarget, sSlot, eType) {
                if (typeof eType === "undefined") { eType = akra.EEventTypes.BROADCAST; }
                if (eType === akra.EEventTypes.BROADCAST) {
                    if (this.findDestinationIndexBC(iGuid, sSignal, pTarget, sSlot) === -1) {
                        this.findBroadcastSignalMap(iGuid, sSignal).push({
                            target: pTarget,
                            callback: sSlot,
                            listener: null
                        });
                    }
                    return true;
                } else {
                    this.unicast[iGuid] = this.unicast[iGuid] || {};
                    //console.log(iGuid, sSignal, pTarget, sSlot, eType);
                    //console.warn(this.unicast);
                    if (!((this.unicast[iGuid][sSignal]) !== undefined)) {
                        this.unicast[iGuid][sSignal] = {
                            target: pTarget,
                            callback: sSlot,
                            listener: null
                        };
                        return true;
                    }
                }
                return false;
            };
            EventTable.prototype.findDestinationIndexBC = function (iGuid, sSignal, pTarget, sSlot) {
                var pList = this.findBroadcastSignalMap(iGuid, sSignal);
                for(var i = 0; i < pList.length; ++i) {
                    if (pList[i].target === pTarget && pList[i].callback === sSlot) {
                        return i;
                    }
                }
                return -1;
            };
            EventTable.prototype.removeDestination = function (iGuid, sSignal, pTarget, sSlot, eType) {
                if (typeof eType === "undefined") { eType = akra.EEventTypes.BROADCAST; }
                if (eType === akra.EEventTypes.BROADCAST) {
                    var pList = this.findBroadcastSignalMap(iGuid, sSignal);
                    var i = this.findDestinationIndexBC(iGuid, sSignal, pTarget, sSlot);
                    if (i != -1) {
                        pList.splice(i, 1);
                        return true;
                    }
                } else {
                    if (this.unicast[iGuid] && this.unicast[iGuid][sSignal]) {
                        delete this.unicast[iGuid][sSignal];
                        return true;
                    }
                }
 {
                    akra.logger.setSourceLocation("events/events.ts", 134);
                    akra.logger.warning("cannot remove destination for GUID <%s> with signal <%s>", iGuid, sSignal);
                }
                ;
                return false;
            };
            EventTable.prototype.addListener = function (iGuid, sSignal, fnListener, eType) {
                if (typeof eType === "undefined") { eType = akra.EEventTypes.BROADCAST; }
                if (eType === akra.EEventTypes.BROADCAST) {
                    // console.log("add listener(", iGuid, "):: ", "listener: ", fnListener, "signal: ", sSignal);
                    this.findBroadcastSignalMap(iGuid, sSignal).push({
                        target: null,
                        callback: null,
                        listener: fnListener
                    });
                    return true;
                } else {
                    this.unicast[iGuid] = this.unicast[iGuid] || {};
                    if (!((this.unicast[iGuid][sSignal]) !== undefined)) {
                        this.unicast[iGuid][sSignal] = {
                            target: null,
                            callback: null,
                            listener: fnListener
                        };
                        return true;
                    }
                }
 {
                    akra.logger.setSourceLocation("events/events.ts", 151);
                    akra.logger.warning("cannot add listener for GUID <%s> with signal <%s>", iGuid, sSignal);
                }
                ;
                return false;
            };
            EventTable.prototype.removeListener = function (iGuid, sSignal, fnListener, eType) {
                if (typeof eType === "undefined") { eType = akra.EEventTypes.BROADCAST; }
                if (eType === akra.EEventTypes.BROADCAST) {
                    var pList = this.findBroadcastSignalMap(iGuid, sSignal);
                    for(var i = 0; i < pList.length; ++i) {
                        if (pList[i].listener === fnListener) {
                            pList.splice(i, 1);
                            return true;
                        }
                    }
                } else {
                    if (this.unicast[iGuid] && this.unicast[iGuid][sSignal]) {
                        delete this.unicast[iGuid][sSignal];
                        return true;
                    }
                }
                return false;
            };
            EventTable.prototype.findBroadcastList = /** @inline */function (iGuid) {
                return (this.broadcast[iGuid] = this.broadcast[iGuid] || {});
            };
            EventTable.prototype.findUnicastList = function (iGuid) {
                //console.error(iGuid,this.unicast[iGuid]);
                this.unicast[iGuid] = this.unicast[iGuid] || {};
                return this.unicast[iGuid];
            };
            EventTable.prototype._sync = function (pTarget, pFrom) {
                //FIXME: release events of target...
                this.broadcast[pTarget.getGuid()] = this.broadcast[pFrom.getGuid()];
                this.unicast[pTarget.getGuid()] = this.unicast[pFrom.getGuid()];
            };
            EventTable.prototype.findBroadcastSignalMap = function (iGuid, sSignal) {
                this.broadcast[iGuid] = this.broadcast[iGuid] || {};
                this.broadcast[iGuid][sSignal] = this.broadcast[iGuid][sSignal] || [];
                return this.broadcast[iGuid][sSignal];
            };
            return EventTable;
        })();
        events.EventTable = EventTable;        
        var EventProvider = (function () {
            function EventProvider() {
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
            }
            EventProvider.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            EventProvider._pEventTable = new events.EventTable();
            EventProvider.prototype.getEventTable = /** @inline */function () {
                return EventProvider._pEventTable;
            };
            EventProvider.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            EventProvider.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            EventProvider.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (EventProvider._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            EventProvider.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (EventProvider._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            EventProvider.prototype._syncTable = /** @inline */function (pFrom) {
                (EventProvider._pEventTable)._sync(this, pFrom);
            };
            return EventProvider;
        })();
        events.EventProvider = EventProvider;        
    })(akra.events || (akra.events = {}));
    var events = akra.events;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            var ResourcePool = (function (_super) {
                __extends(ResourcePool, _super);
                function ResourcePool(pManager, tTemplate) {
                                _super.call(this);
                    this.pManager = null;
                    /** Конструктор для создания данных в пуле ресурсов */
                    this.tTemplate = null;
                    this.sExt = null;
                    this.pRegistrationCode = new pool.ResourceCode(akra.EResourceCodes.INVALID_CODE);
                    /*{[index: number]: string;}*/
                    this.pNameMap = new Array();
                    this.pDataPool = null;
                    /**@protected*/ this._iGuid = akra.sid();
                    /**@protected*/ this._pUnicastSlotMap = null;
                    /**@protected*/ this._pBroadcastSlotList = null;
                    this.pManager = pManager;
                    this.tTemplate = tTemplate;
                    this.pDataPool = new pool.DataPool(this.pManager, tTemplate);
                }
                Object.defineProperty(ResourcePool.prototype, "iFourcc", {
                    get: /** @inline */function () {
                        return (this.sExt.charCodeAt(3) << 24) | (this.sExt.charCodeAt(2) << 16) | (this.sExt.charCodeAt(1) << 8) | (this.sExt.charCodeAt(0));
                    },
                    set: function (iNewFourcc) {
                        this.sExt = String.fromCharCode((iNewFourcc & 0x000000FF), (iNewFourcc & 0x0000FF00) >>> 8, (iNewFourcc & 0x00FF0000) >>> 16, (iNewFourcc & 0xFF000000) >>> 24);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePool.prototype, "manager", {
                    get: /** @inline */function () {
                        return this.pManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                ResourcePool.prototype.registerResourcePool = /** Добавление данного пула в менеджер ресурсво по его коду */
                function (pCode) {
                    this.pRegistrationCode.eq(pCode);
                    this.pManager.registerResourcePool(this.pRegistrationCode, this);
                };
                ResourcePool.prototype.unregisterResourcePool = /** Удаление данного пула в менеджер ресурсво по его коду */
                function () {
                    this.pManager.unregisterResourcePool(this.pRegistrationCode);
                    this.pRegistrationCode.setInvalid();
                };
                ResourcePool.prototype.findResourceHandle = /** По имени ресурса возвращает его хендл */
                function (sName) {
                    // look up the name in our map
                    var iNewHandle = akra.INVALID_INDEX;
                    for(var iHandle = 0; iHandle < this.pNameMap.length; ++iHandle) {
                        if (this.pNameMap[iHandle] === sName) {
                            return iHandle;
                        }
                    }
                    return iNewHandle;
                };
                ResourcePool.prototype.findResourceName = /**
                * Get resource name by handle.
                * @inline
                */
                function (iHandle) {
                    return this.pNameMap[iHandle];
                };
                ResourcePool.prototype.setResourceName = function (iHandle, sName) {
                    this.pNameMap[iHandle] = sName;
                };
                ResourcePool.prototype.initialize = function (iGrowSize) {
                    this.pDataPool.initialize(iGrowSize);
                };
                ResourcePool.prototype.destroy = /** @inline */
                function () {
                    this.pDataPool.destroy();
                };
                ResourcePool.prototype.clean = function () {
                    this.pDataPool.forEach(ResourcePool.callbackClean);
                };
                ResourcePool.prototype.destroyAll = function () {
                    this.pDataPool.forEach(ResourcePool.callbackDestroy);
                };
                ResourcePool.prototype.restoreAll = function () {
                    this.pDataPool.forEach(ResourcePool.callbackRestore);
                };
                ResourcePool.prototype.disableAll = function () {
                    this.pDataPool.forEach(ResourcePool.callbackDisable);
                };
                ResourcePool.prototype.isInitialized = /** @inline */
                function () {
                    return this.pDataPool.isInitialized();
                };
                ResourcePool.prototype.createResource = function (sResourceName) {
                    var iHandle = this.internalCreateResource(sResourceName);
                    if (iHandle !== akra.INVALID_INDEX) {
                        var pResource = this.getResource(iHandle);
                        pResource.setResourcePool(this);
                        pResource.setResourceHandle(iHandle);
                        pResource.setResourceCode(this.pRegistrationCode);
                        this.createdResource(pResource);
                        return pResource;
                    }
                    return null;
                };
                ResourcePool.prototype.loadResource = function (sResourceName) {
                    // does the resource already exist?
                    var pResource = this.findResource(sResourceName);
                    if (pResource == null) {
                        // create a new resource
                        pResource = this.createResource(sResourceName);
                        if (pResource != null) {
                            // attempt to load the desired data
                            if (pResource.loadResource(sResourceName)) {
                                // ok!
                                return pResource;
                            }
                            // loading failed.
                            // destroy the resource we created
                            // destroyResource(pResource);
                            pResource.release();
                            pResource = null;
                        }
                    }
                    return pResource;
                };
                ResourcePool.prototype.saveResource = function (pResource) {
                    if (pResource != null) {
                        // save the resource using it's own name as the file path
                        return pResource.saveResource();
                    }
                    return false;
                };
                ResourcePool.prototype.destroyResource = function (pResource) {
                    if (pResource != null) {
                        var iReferenceCount = pResource.referenceCount();
 {
                            akra.logger.setSourceLocation("ResourcePool.ts", 180);
                            akra.logger.assert(iReferenceCount == 0, "destruction of non-zero reference count!");
                        }
                        ;
                        if (iReferenceCount <= 0) {
                            var iHandle = pResource.resourceHandle;
                            this.internalDestroyResource(iHandle);
                        }
                    }
                };
                ResourcePool.prototype.findResource = function (sName) {
                    // look up the name in our map
                    for(var iHandle = 0; iHandle < this.pNameMap.length; ++iHandle) {
                        if (this.pNameMap[iHandle] == sName) {
                            if (iHandle != akra.INVALID_INDEX) {
                                var pResource = this.getResource(iHandle);
                                return pResource;
                            }
                        }
                    }
                    return null;
                };
                ResourcePool.prototype.getResource = function (iHandle) {
                    var pResource = this.internalGetResource(iHandle);
                    if (pResource != null) {
                        pResource.addRef();
                    }
                    return pResource;
                };
                ResourcePool.prototype.getResources = function () {
                    var pResources = [];
                    for(var iHandleResource in this.pNameMap) {
                        pResources.push(this.getResource(parseInt(iHandleResource)));
                    }
                    return pResources;
                };
                ResourcePool.prototype.internalGetResource = function (iHandle) {
                    return this.pDataPool.getPtr(iHandle);
                };
                ResourcePool.prototype.internalDestroyResource = function (iHandle) {
                    // get a pointer to the resource and call it's destruction handler
                    var pResource = this.pDataPool.getPtr(iHandle);
                    pResource.destroyResource();
                    delete this.pNameMap[iHandle];
                    // free the resource slot associated with the handle
                    this.pDataPool.release(iHandle);
                };
                ResourcePool.prototype.internalCreateResource = function (sResourceName) {
                    var iHandle = this.pDataPool.nextHandle();
                    // make sure this name is not already in use
                    for(var iter in this.pNameMap) {
 {
                            akra.logger.setSourceLocation("ResourcePool.ts", 247);
                            akra.logger.assert((this.pNameMap[iter] != sResourceName), "A resource with this name already exists: " + sResourceName);
                        }
                        ;
                    }
                    // add this resource name to our map of handles
                    this.pNameMap[iHandle] = sResourceName;
                    // get a pointer to the resource and call it's creation function
                    var pResource = this.pDataPool.getPtr(iHandle);
                    pResource.createResource();
                    return iHandle;
                };
                ResourcePool.callbackDestroy = function callbackDestroy(pPool, iHandle, pResource) {
                    pResource.destroyResource();
                };
                ResourcePool.callbackDisable = function callbackDisable(pPool, iHandle, pResource) {
                    pResource.disableResource();
                };
                ResourcePool.callbackRestore = function callbackRestore(pPool, iHandle, pResource) {
                    pResource.restoreResource();
                };
                ResourcePool.callbackClean = function callbackClean(pPool, iHandle, pResource) {
                    if (pResource.referenceCount() == 0) {
                        pPool.release(iHandle);
                    }
                };
                ResourcePool.prototype.getGuid = /** @inline */function () {
                    return this._iGuid;
                };
                ResourcePool._pEventTable = new akra.events.EventTable();
                ResourcePool.prototype.getEventTable = /** @inline */function () {
                    return ResourcePool._pEventTable;
                };
                ResourcePool.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                    return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
                };
                ResourcePool.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                    return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
                };
                ResourcePool.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                    return (ResourcePool._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
                };
                ResourcePool.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                    return (ResourcePool._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
                };
                ResourcePool.prototype._syncTable = /** @inline */function (pFrom) {
                    (ResourcePool._pEventTable)._sync(this, pFrom);
                };
                ResourcePool.prototype.createdResource = function (pResource) {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || (((((ResourcePool._pEventTable))).broadcast[(this._iGuid)] = (((ResourcePool._pEventTable))).broadcast[(this._iGuid)] || {}));
                    var _broadcast = (this._pBroadcastSlotList).createdResource;
                    var _recivier = this;
                    if (((_broadcast) !== undefined)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pResource) : _broadcast[i].listener(_recivier, pResource);
                        }
                    }
                };
                return ResourcePool;
            })(akra.util.ReferenceCounter);
            pool.ResourcePool = ResourcePool;            
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            var PoolGroup = (function () {
                function PoolGroup(pManager, tTemplate, iMaxCount) {
                    /** Число свободных элементов группы */
                    this.iTotalOpen = 0;
                    /** Первый свободный элемент группы */
                    this.iFirstOpen = 0;
                    /** Колмичество элементов в группе */
                    this.iMaxCount = 0;
                    /** Список свободных элементов группы */
                    this.pNextOpenList = null;
                    /** Массив элементов группы */
                    this.pMemberList = null;
                    this.pManager = pManager;
                    this.tTemplate = tTemplate;
                    this.iMaxCount = iMaxCount;
                }
                Object.defineProperty(PoolGroup.prototype, "manager", {
                    get: /** @inline */function () {
                        return this.pManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(PoolGroup.prototype, "totalOpen", {
                    get: /**
                    * Возвращает количесвто свободных мест в группе
                    * @inline
                    */
                    function () {
                        return this.iTotalOpen;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(PoolGroup.prototype, "totalUsed", {
                    get: /**
                    * Возвращает количесвто занятых мест в группе
                    * @inline
                    */
                    function () {
                        return this.iMaxCount - this.iTotalOpen;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(PoolGroup.prototype, "firstOpen", {
                    get: /**
                    * Номер первого свободного элемента в группе
                    * @inline
                    */
                    function () {
                        return this.iFirstOpen;
                    },
                    enumerable: true,
                    configurable: true
                });
                PoolGroup.prototype.create = /** Создание группы, создается массив элементов, инициализирется список свободный и т.д. */
                function () {
                    var i;
 {
                        akra.logger.setSourceLocation("DataPool.ts", 70);
                        akra.logger.assert(this.pMemberList == null && this.pNextOpenList == null, "Group has already been created");
                    }
                    ;
                    this.pNextOpenList = new Array(this.iMaxCount);
 {
                        akra.logger.setSourceLocation("DataPool.ts", 74);
                        akra.logger.assert(this.pNextOpenList != null, "tragic memory allocation failure!");
                    }
                    ;
                    this.pMemberList = new Array(this.iMaxCount);
                    for(i = 0; i < this.iMaxCount; i++) {
                        this.pMemberList[i] = new this.tTemplate(this.pManager);
                    }
 {
                        akra.logger.setSourceLocation("DataPool.ts", 83);
                        akra.logger.assert(this.pNextOpenList != null, "tragic memory allocation failure!");
                    }
                    ;
                    for(i = 0; i < this.iMaxCount - 1; i++) {
                        this.pNextOpenList[i] = i + 1;
                    }
                    this.pNextOpenList[i] = i;
                    this.iTotalOpen = this.iMaxCount;
                    this.iFirstOpen = 0;
                };
                PoolGroup.prototype.destroy = /**
                * Удаление группы: удаление массива элементов, списка совбодных элементов и т.д.
                * Выдается ошибка если группа не пуста
                * */
                function () {
 {
                        akra.logger.setSourceLocation("DataPool.ts", 99);
                        akra.logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("DataPool.ts", 100);
                        akra.logger.assert(this.iTotalOpen == this.iMaxCount, "Group is not empty");
                    }
                    ;
                    delete this.pMemberList;
                    this.pMemberList = null;
                    delete this.pNextOpenList;
                    this.pNextOpenList = null;
                    this.iTotalOpen = 0;
                    this.iMaxCount = 0;
                };
                PoolGroup.prototype.nextMember = /** Возвращает номер следующего совбодного элемента в списке, и помечает его как используемый */
                function () {
 {
                        akra.logger.setSourceLocation("DataPool.ts", 114);
                        akra.logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("DataPool.ts", 115);
                        akra.logger.assert(this.iTotalOpen != null, "no open slots");
                    }
                    ;
                    //Возвращает номер первого свободного элемента в группе,
                    //и изменяет номер первого свободного на следующего свободного
                    var iSlot = this.iFirstOpen;
                    this.iFirstOpen = this.pNextOpenList[iSlot];
                    this.iTotalOpen--;
 {
                        akra.logger.setSourceLocation("DataPool.ts", 123);
                        akra.logger.assert(this.iFirstOpen != akra.INVALID_INDEX, "Invalid Open Index");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("DataPool.ts", 124);
                        akra.logger.assert(this.isOpen(iSlot), "invalid index");
                    }
                    ;
                    //помечаем что элемент который отдали является используемым
                    this.pNextOpenList[iSlot] = akra.INVALID_INDEX;
                    return iSlot;
                };
                PoolGroup.prototype.addMember = /** Добавляем новый элемент в список */
                function (pMember) {
                    var iSlot = this.nextMember();
                    this.pMemberList[iSlot] = pMember;
                    return iSlot;
                };
                PoolGroup.prototype.release = /** Исключение элемента из списка по его номеру */
                function (iIndex) {
 {
                        akra.logger.setSourceLocation("DataPool.ts", 142);
                        akra.logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("DataPool.ts", 143);
                        akra.logger.assert(iIndex < this.iMaxCount, "invalid index");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("DataPool.ts", 144);
                        akra.logger.assert(this.isOpen(iIndex) == false, "invalid index to release");
                    }
                    ;
                    this.pNextOpenList[iIndex] = this.iTotalOpen > 0 ? this.iFirstOpen : iIndex;
                    this.iTotalOpen++;
                    this.iFirstOpen = iIndex;
                };
                PoolGroup.prototype.isOpen = /** Проверить свободна ли эта ячейка в группе */
                function (iIndex) {
 {
                        akra.logger.setSourceLocation("DataPool.ts", 154);
                        akra.logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("DataPool.ts", 155);
                        akra.logger.assert(iIndex < this.iMaxCount, "invalid index");
                    }
                    ;
                    return this.pNextOpenList[iIndex] != akra.INVALID_INDEX;
                };
                PoolGroup.prototype.member = /** Получение элемента по его номеру */
                function (iIndex) {
 {
                        akra.logger.setSourceLocation("DataPool.ts", 162);
                        akra.logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("DataPool.ts", 163);
                        akra.logger.assert(iIndex < this.iMaxCount, "invalid index");
                    }
                    ;
                    return this.pMemberList[iIndex];
                };
                PoolGroup.prototype.memberPtr = function (iIndex) {
 {
                        akra.logger.setSourceLocation("DataPool.ts", 168);
                        akra.logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("DataPool.ts", 169);
                        akra.logger.assert(iIndex < this.iMaxCount, "invalid index");
                    }
                    ;
                    return this.pMemberList[iIndex];
                };
                return PoolGroup;
            })();
            pool.PoolGroup = PoolGroup;            
            var DataPool = (function () {
                function DataPool(pManager, tTemplate) {
                    this.bInitialized = false;
                    /** Массив групп */
                    this.pGroupList = [];
                    /** Общее число ячеек */
                    this.iTotalMembers = 0;
                    /** Количесвто свободных ячеек */
                    this.iTotalOpen = 0;
                    /** Количесвто элементов в группе */
                    this.iGroupCount = 0;
                    /**
                    * Номер элемента состоит из номер группы сдвинутого на _iIndexShift
                    * и номера элемента в этой группе, который можно вырезать маской _iIndexMask
                    */
                    this.iIndexMask = 0;
                    /**
                    * Номер элемента состоит из номер группы сдвинутого на _iIndexShift
                    * и номера элемента в этой группе, который можно вырезать маской _iIndexMask
                    */
                    this.iIndexShift = 0;
                    this.pManager = pManager;
                    this.tTemplate = tTemplate;
                }
                Object.defineProperty(DataPool.prototype, "manager", {
                    get: /** @inline */function () {
                        return this.pManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                DataPool.prototype.initialize = function (iGrowSize) {
 {
                        akra.logger.setSourceLocation("DataPool.ts", 209);
                        akra.logger.assert(this.isInitialized() == false, "the cDataPool is already initialized");
                    }
                    ;
                    this.bInitialized = true;
                    this.iGroupCount = akra.math.nearestPowerOfTwo(iGrowSize);
                    this.iIndexShift = akra.math.lowestBitSet(this.iGroupCount);
                    this.iIndexShift = (/*checked (origin: math)>>*/akra.math.max((1), /*checked (origin: math)>>*/akra.math.min((this.iIndexShift), (15))));
                    this.iGroupCount = 1 << this.iIndexShift;
                    this.iIndexMask = this.iGroupCount - 1;
                };
                DataPool.prototype.isInitialized = /** @inline */
                function () {
                    return this.bInitialized;
                };
                DataPool.prototype.destroy = function () {
                    this.clear();
                    this.bInitialized = false;
                };
                DataPool.prototype.release = function (iHandle) {
 {
                        akra.logger.setSourceLocation("DataPool.ts", 233);
                        akra.logger.assert(this.isInitialized() == true, "the cDataPool is not initialized");
                    }
                    ;
                    if (this.isHandleValid(iHandle) == true) {
 {
                            akra.logger.setSourceLocation("DataPool.ts", 236);
                            akra.logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created");
                        }
                        ;
                        var iGroupIndex = this.getGroupNumber(iHandle);
                        var iItemIndex = this.getItemIndex(iHandle);
                        var pGroup = this.getGroup(iGroupIndex);
                        pGroup.release(iItemIndex);
                        var pGroupBack = this.pGroupList[this.pGroupList.length - 1];
                        if (pGroupBack.totalOpen == this.iGroupCount) {
                            pGroupBack.destroy();
                            this.pGroupList.splice(this.pGroupList.length - 1, 1);
                        }
                        this.iTotalOpen++;
                    }
                };
                DataPool.prototype.clear = function () {
                    // destroy all groups in the list
                    for(var iGroupIter = 0; iGroupIter < this.pGroupList.length; ++iGroupIter) {
                        this.pGroupList[iGroupIter].destroy();
                    }
                    // now clear the list itself
                    this.pGroupList.clear();
                };
                DataPool.prototype.add = function (pMembers) {
 {
                        akra.logger.setSourceLocation("DataPool.ts", 265);
                        akra.logger.assert(this.isInitialized() == true, "the cDataPool is not initialized");
                    }
                    ;
                    var iGroupNumber = {
                        value: 0
                    };
                    var pOpenGroup = this.findOpenGroup(iGroupNumber);
                    var iIndex = pOpenGroup.addMember(pMembers);
                    this.iTotalOpen--;
                    return this.buildHandle(iGroupNumber.value, iIndex);
                };
                DataPool.prototype.forEach = function (fFunction) {
 {
                        akra.logger.setSourceLocation("DataPool.ts", 278);
                        akra.logger.assert(this.isInitialized() == true, "the cDataPool is not initialized");
                    }
                    ;
                    // iterate through every group
                    var iGroupNumber = 0;
                    for(var iGroupIter = 0; iGroupIter < this.pGroupList.length; iGroupIter++) {
                        var nCallbackCount = this.pGroupList[iGroupIter].totalUsed;
                        var iItemIndex = 0;
                        while(nCallbackCount != 0 && iItemIndex < this.iGroupCount) {
                            if (this.pGroupList[iGroupIter].isOpen(iItemIndex) == false) {
                                fFunction(this, this.buildHandle(iGroupNumber, iItemIndex), this.pGroupList[iGroupIter].member(iItemIndex));
                                nCallbackCount--;
                            }
                            ++iItemIndex;
                        }
                        ++iGroupNumber;
                    }
                };
                DataPool.prototype.nextHandle = function () {
 {
                        akra.logger.setSourceLocation("DataPool.ts", 305);
                        akra.logger.assert(this.isInitialized() == true, "the cDataPool is not initialized");
                    }
                    ;
                    var iGroupNumber = {
                        value: 0
                    };
                    var pOpenGroup = this.findOpenGroup(iGroupNumber);
                    var iIndex = pOpenGroup.nextMember();
                    this.iTotalOpen--;
                    return this.buildHandle(iGroupNumber.value, iIndex);
                };
                DataPool.prototype.isHandleValid = function (iHandle) {
 {
                        akra.logger.setSourceLocation("DataPool.ts", 317);
                        akra.logger.assert(this.isInitialized() == true, "the cDataPool is not initialized");
                    }
                    ;
                    if (iHandle !== akra.INVALID_INDEX) {
 {
                            akra.logger.setSourceLocation("DataPool.ts", 320);
                            akra.logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created");
                        }
                        ;
                        var pGroup = this.getGroup(this.getGroupNumber(iHandle));
                        return !pGroup.isOpen(this.getItemIndex(iHandle));
                    }
                    return false;
                };
                DataPool.prototype.get = function (iHandle) {
 {
                        akra.logger.setSourceLocation("DataPool.ts", 331);
                        akra.logger.assert(this.isInitialized() == true, "the cDataPool is not initialized");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("DataPool.ts", 332);
                        akra.logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created");
                    }
                    ;
                    var pGroup = this.getGroup(this.getGroupNumber(iHandle));
                    var iItemIndex = this.getItemIndex(iHandle);
                    return pGroup.member(iItemIndex);
                };
                DataPool.prototype.getPtr = function (iHandle) {
 {
                        akra.logger.setSourceLocation("DataPool.ts", 341);
                        akra.logger.assert(this.isInitialized() == true, "the cDataPool is not initialized");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("DataPool.ts", 342);
                        akra.logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created");
                    }
                    ;
                    var pGroup = this.getGroup(this.getGroupNumber(iHandle));
                    var iItemIndex = this.getItemIndex(iHandle);
                    return pGroup.memberPtr(iItemIndex);
                };
                DataPool.prototype.getGenericPtr = function (iHandle) {
 {
                        akra.logger.setSourceLocation("DataPool.ts", 351);
                        akra.logger.assert(this.isInitialized() == true, "the cDataPool is not initialized");
                    }
                    ;
                    return this.getPtr(iHandle);
                };
                DataPool.prototype.getGroupNumber = /**
                * @inline
                * Получение номера группы по номеру элемента
                */
                function (iHandle) {
                    return iHandle >> this.iIndexShift;
                };
                DataPool.prototype.getItemIndex = /**
                * @inline
                * Получение номера элеменат в группе по его номеру
                */
                function (iHandle) {
                    return iHandle & this.iIndexMask;
                };
                DataPool.prototype.buildHandle = /**
                * @inline
                * Полученяи номера элеменат по его номеру группы и группе
                */
                function (iGroup, iIndex) {
                    return (iGroup << this.iIndexShift) + iIndex;
                };
                DataPool.prototype.addGroup = /** Добавление группы в пул */
                function () {
                    // append a new group to the list to start things off
                    var pNewGroup = new PoolGroup(this.pManager, this.tTemplate, this.iGroupCount);
                    this.pGroupList.push(pNewGroup);
                    // gain access to the new group and innitialize it
                    pNewGroup.create();
                    // increment our internal counters
                    this.iTotalMembers += this.iGroupCount;
                    this.iTotalOpen += this.iGroupCount;
                    return pNewGroup;
                };
                DataPool.prototype.findOpenGroup = /** Поиск первой группы которая имеет свободную область */
                function (pGroupNumber) {
                    pGroupNumber.value = 0;
                    //найдем и вренем первую группу имеющую свободную группу
                    for(var iGroupIter = 0; iGroupIter < this.pGroupList.length; iGroupIter++) {
                        if (this.pGroupList[iGroupIter].totalOpen > 0) {
                            return this.pGroupList[iGroupIter];
                        }
                        pGroupNumber.value++;
                    }
                    //свободных областей нет, поэтому мы должны добавить новую группу в пул,
                    //но пержде чем содавать убедимся что не достигли максимума
                     {
                        akra.logger.setSourceLocation("DataPool.ts", 411);
                        akra.logger.assert((this.pGroupList.length + 1) < akra.MAX_UINT16, "the cDataPool is full!!!!");
                    }
                    ;
                    //добавим новую группу
                    return this.addGroup();
                };
                DataPool.prototype.getGroup = /**
                * @inline
                * Возвращает группу по ее номеру
                */
                function (iIndex) {
 {
                        akra.logger.setSourceLocation("DataPool.ts", 422);
                        akra.logger.assert(iIndex < this.pGroupList.length, "Invalid group index requested");
                    }
                    ;
                    return this.pGroupList[iIndex];
                };
                return DataPool;
            })();
            pool.DataPool = DataPool;            
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            var ResourcePoolItem = (function (_super) {
                __extends(ResourcePoolItem, _super);
                /** Constructor of ResourcePoolItem class */
                /*pManager: IResourcePoolManager*/
                function ResourcePoolItem() {
                                _super.call(this);
                    this.pResourcePool = null;
                    this.iResourceHandle = 0;
                    this.iResourceFlags = 0;
                    /**@protected*/ this._iGuid = akra.sid();
                    /**@protected*/ this._pUnicastSlotMap = null;
                    /**@protected*/ this._pBroadcastSlotList = null;
                    //this.pManager = pManager;
                    this.pResourceCode = new pool.ResourceCode(0);
                    this.pCallbackFunctions = [];
                    this.pStateWatcher = [];
                    this.pCallbackSlots = akra.genArray(null, akra.EResourceItemEvents.TOTALRESOURCEFLAGS);
                }
                Object.defineProperty(ResourcePoolItem.prototype, "resourceCode", {
                    get: /** @inline */function () {
                        return this.pResourceCode;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolItem.prototype, "resourcePool", {
                    get: /** @inline */function () {
                        return this.pResourcePool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolItem.prototype, "resourceHandle", {
                    get: /** @inline */function () {
                        return this.iResourceHandle;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolItem.prototype, "resourceFlags", {
                    get: /** @inline */function () {
                        return this.iResourceFlags;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolItem.prototype, "alteredFlag", {
                    get: /** @inline */function () {
                        return ((((this.iResourceFlags) & ((1 << ((/*checked (origin: akra)>>*/akra.EResourceItemEvents.ALTERED))))) != 0));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolItem.prototype, "manager", {
                    get: /** @inline */function () {
                        return (((((this).pResourcePool)).pManager));
                    },
                    enumerable: true,
                    configurable: true
                });
                ResourcePoolItem.prototype.getEngine = /** @inline */function () {
                    var pManager = (((((this).pResourcePool)).pManager));
                    if (pManager) {
                        return pManager.getEngine();
                    }
                    return null;
                };
                ResourcePoolItem.prototype.getManager = /** @inline */function () {
                    return (((this.pResourcePool)).pManager);
                };
                ResourcePoolItem.prototype.createResource = function () {
                    return false;
                };
                ResourcePoolItem.prototype.destroyResource = function () {
                    return false;
                };
                ResourcePoolItem.prototype.disableResource = function () {
                    return false;
                };
                ResourcePoolItem.prototype.restoreResource = function () {
                    return false;
                };
                ResourcePoolItem.prototype.loadResource = function (sFilename) {
                    if (typeof sFilename === "undefined") { sFilename = null; }
                    return false;
                };
                ResourcePoolItem.prototype.saveResource = function (sFilename) {
                    if (typeof sFilename === "undefined") { sFilename = null; }
                    return false;
                };
                ResourcePoolItem.prototype.setChangesNotifyRoutine = function (fn) {
                    for(var i = 0; i < this.pCallbackFunctions.length; i++) {
                        if (this.pCallbackFunctions[i] == fn) {
                            return;
                        }
                    }
                    this.pCallbackFunctions.push(fn);
                };
                ResourcePoolItem.prototype.delChangesNotifyRoutine = function (fn) {
                    for(var i = 0; i < this.pCallbackFunctions.length; i++) {
                        if (this.pCallbackFunctions[i] == fn) {
                            this.pCallbackFunctions[i] = null;
                        }
                    }
                };
                ResourcePoolItem.prototype.setStateWatcher = function (eEvent, fnWatcher) {
                    this.pStateWatcher[eEvent] = fnWatcher;
                };
                ResourcePoolItem.prototype.isSyncedTo = function (eSlot) {
                    return !((this.pCallbackSlots[eSlot]) === null) && this.pCallbackSlots[eSlot].length > 0;
                };
                ResourcePoolItem.prototype.sync = function (pResourceItem, eSignal, eSlot) {
                    eSlot = ((eSlot) !== undefined) ? eSlot : eSignal;
                    eSlot = ResourcePoolItem.parseEvent(eSlot);
                    eSignal = ResourcePoolItem.parseEvent(eSignal);
                    var pSlots = this.pCallbackSlots, pSignSlots;
                    var me = this;
                    var n;
                    var fn;
                    var bState;
                    if (((pSlots[eSlot]) === null)) {
                        pSlots[eSlot] = [];
                    }
                    pSignSlots = pSlots[eSlot];
                    n = pSignSlots.length;
                    bState = ((((pResourceItem.resourceFlags) & ((1 << ((eSignal))))) != 0));
                    fn = function (eFlag, iResourceFlags, isSet) {
                        if (eFlag == eSignal) {
                            pSignSlots[n].bState = isSet;
                            me.notifyStateChange(eSlot, this);
                            for(var i = 0; i < pSignSlots.length; ++i) {
                                if (pSignSlots[i].bState === false) {
                                    if (((((me.resourceFlags) & ((1 << ((eFlag))))) != 0))) {
                                        me.setResourceFlag(eFlag, false);
                                    }
                                    return;
                                }
                            }
                            me.setResourceFlag(eFlag, true);
                        }
                    };
                    pSignSlots.push({
                        bState: bState,
                        fn: fn,
                        pResourceItem: pResourceItem
                    });
                    fn.call(pResourceItem, eSignal, pResourceItem.resourceFlags, bState);
                    pResourceItem.setChangesNotifyRoutine(fn);
                    return true;
                };
                ResourcePoolItem.prototype.unsync = function (pResourceItem, eSignal, eSlot) {
                    eSlot = ((eSlot) !== undefined) ? eSlot : eSignal;
                    eSlot = ResourcePoolItem.parseEvent(eSlot);
                    eSignal = ResourcePoolItem.parseEvent(eSignal);
                    var pSlots = this.pCallbackSlots, pSignSlots;
                    var me = this;
                    var isRem = false;
                    pSignSlots = pSlots[eSlot];
                    for(var i = 0, n = pSignSlots.length; i < n; ++i) {
                        if (pSignSlots[i].pResourceItem === pResourceItem) {
                            pSignSlots[i].pResourceItem.delChangesNotifyRoutine(pSignSlots[i].fn);
                            pSignSlots.splice(i, 1);
                            --n;
                            --i;
                            isRem = true;
                        }
                    }
                    return isRem;
                };
                ResourcePoolItem.prototype.isResourceCreated = /** @inline */function () {
                    return ((((this.iResourceFlags) & ((1 << ((/*checked (origin: akra)>>*/akra.EResourceItemEvents.CREATED))))) != 0));
                };
                ResourcePoolItem.prototype.isResourceLoaded = /** @inline */function () {
                    return ((((this.iResourceFlags) & ((1 << ((/*checked (origin: akra)>>*/akra.EResourceItemEvents.LOADED))))) != 0));
                };
                ResourcePoolItem.prototype.isResourceDisabled = /** @inline */function () {
                    return ((((this.iResourceFlags) & ((1 << ((/*checked (origin: akra)>>*/akra.EResourceItemEvents.DISABLED))))) != 0));
                };
                ResourcePoolItem.prototype.isResourceAltered = /** @inline */function () {
                    return ((((this.iResourceFlags) & ((1 << ((/*checked (origin: akra)>>*/akra.EResourceItemEvents.ALTERED))))) != 0));
                };
                ResourcePoolItem.prototype.setAlteredFlag = function (isOn) {
                    if (typeof isOn === "undefined") { isOn = true; }
                    //notify always, when altered called
                    if (this.setResourceFlag(akra.EResourceItemEvents.ALTERED, isOn) || isOn) {
                        isOn ? this.altered() : this.saved();
                        return true;
                    }
                    return false;
                };
                ResourcePoolItem.prototype.setResourceName = /** @inline */function (sName) {
                    if (this.pResourcePool != null) {
                        this.pResourcePool.setResourceName(this.iResourceHandle, sName);
                    }
                };
                ResourcePoolItem.prototype.findResourceName = function () {
                    if (this.pResourcePool != null) {
                        return this.pResourcePool.findResourceName(this.iResourceHandle);
                    }
                    return null;
                };
                ResourcePoolItem.prototype.release = function () {
                    var iRefCount = _super.prototype.release.call(this);
                    if (iRefCount == 0) {
                        //Если у нас есть менеджер попросим его удалить нас
                        if (this.pResourcePool != null) {
                            this.pResourcePool.destroyResource(this);
                        }
                    }
                    return iRefCount;
                };
                ResourcePoolItem.prototype.notifyCreated = /** @inline */function () {
                    if (this.setResourceFlag(akra.EResourceItemEvents.CREATED, true)) {
                        this.created();
                    }
                };
                ResourcePoolItem.prototype.notifyDestroyed = /** @inline */function () {
                    if (this.setResourceFlag(akra.EResourceItemEvents.CREATED, false)) {
                        this.destroyed();
                    }
                };
                ResourcePoolItem.prototype.notifyLoaded = /** @inline */function () {
                    this.setAlteredFlag(false);
                    // LOG("ResourcePoolItem::notifyLoaded();");
                    if (this.setResourceFlag(akra.EResourceItemEvents.LOADED, true)) {
                        // LOG("ResourcePoolItem::loaded();");
                        this.loaded();
                    }
                };
                ResourcePoolItem.prototype.notifyUnloaded = /** @inline */function () {
                    if (this.setResourceFlag(akra.EResourceItemEvents.LOADED, false)) {
                        this.unloaded();
                    }
                };
                ResourcePoolItem.prototype.notifyRestored = /** @inline */function () {
                    if (this.setResourceFlag(akra.EResourceItemEvents.DISABLED, false)) {
                        this.restored();
                    }
                };
                ResourcePoolItem.prototype.notifyDisabled = /** @inline */function () {
                    if (this.setResourceFlag(akra.EResourceItemEvents.DISABLED, true)) {
                        this.disabled();
                    }
                };
                ResourcePoolItem.prototype.notifyAltered = /** @inline */function () {
                    this.setAlteredFlag(true);
                };
                ResourcePoolItem.prototype.notifySaved = /** @inline */function () {
                    this.setAlteredFlag(false);
                };
                ResourcePoolItem.prototype.setResourceCode = /**
                * Назначение кода ресурсу
                * @inline
                */
                function (pCode) {
                    this.pResourceCode.eq(pCode);
                };
                ResourcePoolItem.prototype.setResourcePool = /**
                * Чтобы ресурс знал какому пулу ресурсов принадлжит
                * @inline
                */
                function (pPool) {
                    this.pResourcePool = pPool;
                };
                ResourcePoolItem.prototype.setResourceHandle = /**
                * Назначение хендла ресурсу
                * @inline
                */
                function (iHandle) {
                    this.iResourceHandle = iHandle;
                };
                ResourcePoolItem.prototype.notifyStateChange = function (eEvent, pTarget) {
                    if (typeof pTarget === "undefined") { pTarget = null; }
                    if (!this.pStateWatcher[eEvent]) {
                        return;
                    }
                    var pSignSlots = this.pCallbackSlots[eEvent];
                    var nTotal = pSignSlots.length, nLoaded = 0;
                    for(var i = 0; i < nTotal; ++i) {
                        if (pSignSlots[i].bState) {
                            ++nLoaded;
                        }
                    }
                    this.pStateWatcher[eEvent](nLoaded, nTotal, pTarget);
                };
                ResourcePoolItem.prototype.setResourceFlag = function (iFlagBit, isSetting) {
                    var iTempFlags = this.iResourceFlags;
                    this.iResourceFlags = (((isSetting) ? ((this.iResourceFlags) |= ((1 << ((iFlagBit))))) : ((((this.iResourceFlags)) &= ~((1 << (((iFlagBit)))))))));
                    // LOG("before !=", iFlagBit, "(" + EResourceItemEvents.LOADED + ")", iTempFlags, "==>", this.iResourceFlags);
                    if (iTempFlags != this.iResourceFlags) {
                        // LOG("!+");
                        for(var i = 0; i < this.pCallbackFunctions.length; i++) {
                            if (this.pCallbackFunctions[i]) {
                                this.pCallbackFunctions[i].call(this, iFlagBit, this.iResourceFlags, isSetting);
                            }
                        }
                        return true;
                    }
                    return false;
                };
                ResourcePoolItem.parseEvent = function parseEvent(pEvent) {
                    if ((typeof (pEvent) === "number")) {
                        return pEvent;
                    }
                    switch(pEvent.toLowerCase()) {
                        case 'loaded':
                            return akra.EResourceItemEvents.LOADED;
                        case 'created':
                            return akra.EResourceItemEvents.CREATED;
                        case 'disabled':
                            return akra.EResourceItemEvents.DISABLED;
                        case 'altered':
                            return akra.EResourceItemEvents.ALTERED;
                        default:
 {
                                akra.logger.setSourceLocation("../ResourcePoolItem.ts", 386);
                                akra.logger.error('Использовано неизвестное событие для ресурса.');
                            }
                            ;
                            return 0;
                    }
                };
                ResourcePoolItem.prototype.getGuid = /** @inline */function () {
                    return this._iGuid;
                };
                ResourcePoolItem._pEventTable = new akra.events.EventTable();
                ResourcePoolItem.prototype.getEventTable = /** @inline */function () {
                    return ResourcePoolItem._pEventTable;
                };
                ResourcePoolItem.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                    return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
                };
                ResourcePoolItem.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                    return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
                };
                ResourcePoolItem.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                    return (ResourcePoolItem._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
                };
                ResourcePoolItem.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                    return (ResourcePoolItem._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
                };
                ResourcePoolItem.prototype._syncTable = /** @inline */function (pFrom) {
                    (ResourcePoolItem._pEventTable)._sync(this, pFrom);
                };
                ResourcePoolItem.prototype.created = function () {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || (((((ResourcePoolItem._pEventTable))).broadcast[(this._iGuid)] = (((ResourcePoolItem._pEventTable))).broadcast[(this._iGuid)] || {}));
                    var _broadcast = (this._pBroadcastSlotList).created;
                    var _recivier = this;
                    if (((_broadcast) !== undefined)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                ResourcePoolItem.prototype.destroyed = function () {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || (((((ResourcePoolItem._pEventTable))).broadcast[(this._iGuid)] = (((ResourcePoolItem._pEventTable))).broadcast[(this._iGuid)] || {}));
                    var _broadcast = (this._pBroadcastSlotList).destroyed;
                    var _recivier = this;
                    if (((_broadcast) !== undefined)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                ResourcePoolItem.prototype.loaded = function () {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || (((((ResourcePoolItem._pEventTable))).broadcast[(this._iGuid)] = (((ResourcePoolItem._pEventTable))).broadcast[(this._iGuid)] || {}));
                    var _broadcast = (this._pBroadcastSlotList).loaded;
                    var _recivier = this;
                    if (((_broadcast) !== undefined)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                ResourcePoolItem.prototype.unloaded = function () {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || (((((ResourcePoolItem._pEventTable))).broadcast[(this._iGuid)] = (((ResourcePoolItem._pEventTable))).broadcast[(this._iGuid)] || {}));
                    var _broadcast = (this._pBroadcastSlotList).unloaded;
                    var _recivier = this;
                    if (((_broadcast) !== undefined)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                ResourcePoolItem.prototype.restored = function () {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || (((((ResourcePoolItem._pEventTable))).broadcast[(this._iGuid)] = (((ResourcePoolItem._pEventTable))).broadcast[(this._iGuid)] || {}));
                    var _broadcast = (this._pBroadcastSlotList).restored;
                    var _recivier = this;
                    if (((_broadcast) !== undefined)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                ResourcePoolItem.prototype.disabled = function () {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || (((((ResourcePoolItem._pEventTable))).broadcast[(this._iGuid)] = (((ResourcePoolItem._pEventTable))).broadcast[(this._iGuid)] || {}));
                    var _broadcast = (this._pBroadcastSlotList).disabled;
                    var _recivier = this;
                    if (((_broadcast) !== undefined)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                ResourcePoolItem.prototype.altered = function () {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || (((((ResourcePoolItem._pEventTable))).broadcast[(this._iGuid)] = (((ResourcePoolItem._pEventTable))).broadcast[(this._iGuid)] || {}));
                    var _broadcast = (this._pBroadcastSlotList).altered;
                    var _recivier = this;
                    if (((_broadcast) !== undefined)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                ResourcePoolItem.prototype.saved = function () {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || (((((ResourcePoolItem._pEventTable))).broadcast[(this._iGuid)] = (((ResourcePoolItem._pEventTable))).broadcast[(this._iGuid)] || {}));
                    var _broadcast = (this._pBroadcastSlotList).saved;
                    var _recivier = this;
                    if (((_broadcast) !== undefined)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                return ResourcePoolItem;
            })(akra.util.ReferenceCounter);
            pool.ResourcePoolItem = ResourcePoolItem;            
            /** @inline */function isVideoResource(pItem) {
                return !((pItem) === null) && pItem.resourceCode.family === akra.EResourceFamilies.VIDEO_RESOURCE;
            }
            pool.isVideoResource = isVideoResource;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var RenderMethod = (function (_super) {
                    __extends(RenderMethod, _super);
                    function RenderMethod() {
                        _super.apply(this, arguments);

                        /**@protected*/ this._pEffect = null;
                        /**@protected*/ this._pSurfaceMaterial = null;
                    }
                    Object.defineProperty(RenderMethod.prototype, "effect", {
                        get: // protected $pSurfaceMaterial: ISurfaceMaterial = null;
                        // get _pSurfaceMaterial(): ISurfaceMaterial {
                        // 	return this.$pSurfaceMaterial;
                        // }
                        // set _pSurfaceMaterial(pMat: ISurfaceMaterial) {
                        // 	LOG("prev: ", this.$pSurfaceMaterial, "next: ", pMat);
                        // 	this.$pSurfaceMaterial = pMat;
                        // }
                        // createResource(): bool {
                        // 	this.notifyLoaded();
                        // 	return true;
                        // }
                        /** @inline */function () {
                            return this._pEffect;
                        },
                        set: function (pEffect) {
                            if (!((this._pEffect) === null)) {
                                this.unsync(this._pEffect, akra.EResourceItemEvents.LOADED);
                                ((this._pEffect).getEventTable().removeDestination(((((this._pEffect)))._iGuid), ("altered"), (this), ("notifyAltered"), (/*checked (origin: akra)>>*/akra.EEventTypes.BROADCAST)));
                                this._pEffect.release();
                            }
                            this._pEffect = pEffect;
                            if (!((pEffect) === null)) {
                                this.sync(this._pEffect, akra.EResourceItemEvents.LOADED);
                                ((this._pEffect).getEventTable().addDestination(((((this._pEffect)))._iGuid), ("altered"), (this), ("notifyAltered"), (/*checked (origin: akra)>>*/akra.EEventTypes.BROADCAST)));
                            }
                            this._pEffect.addRef();
                            ((this).setAlteredFlag(true));
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(RenderMethod.prototype, "surfaceMaterial", {
                        get: /** @inline */function () {
                            return this._pSurfaceMaterial;
                        },
                        set: /** @inline */function (pMaterial) {
                            if (!((this._pSurfaceMaterial) === null)) {
                                this.unsync(this._pSurfaceMaterial, akra.EResourceItemEvents.LOADED);
                                ((this._pSurfaceMaterial).getEventTable().removeDestination(((((this._pSurfaceMaterial)))._iGuid), ("altered"), (this), ("notifyAltered"), (/*checked (origin: akra)>>*/akra.EEventTypes.BROADCAST)));
                                this._pSurfaceMaterial.release();
                            }
                            this._pSurfaceMaterial = pMaterial;
                            if (!((pMaterial) === null)) {
                                this.sync(this._pSurfaceMaterial, akra.EResourceItemEvents.LOADED);
                                ((this._pSurfaceMaterial).getEventTable().addDestination(((((this._pSurfaceMaterial)))._iGuid), ("altered"), (this), ("notifyAltered"), (/*checked (origin: akra)>>*/akra.EEventTypes.BROADCAST)));
                            }
                            this._pSurfaceMaterial.addRef();
                            ((this).setAlteredFlag(true));
                        },
                        enumerable: true,
                        configurable: true
                    });
                    RenderMethod.prototype.isEqual = function (pRenderMethod) {
                        return false;
                    };
                    return RenderMethod;
                })(pool.ResourcePoolItem);
                resources.RenderMethod = RenderMethod;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    /**@const*/ akra.DeclarationUsages = {
        POSITION: "POSITION",
        POSITION1: "POSITION1",
        POSITION2: "POSITION2",
        POSITION3: "POSITION3",
        BLENDWEIGHT: "BLENDWEIGHT",
        BLENDINDICES: "BLENDINDICES",
        BLENDMETA: "BLENDMETA",
        NORMAL: "NORMAL",
        NORMAL1: "NORMAL1",
        NORMAL2: "NORMAL2",
        NORMAL3: "NORMAL3",
        PSIZE: "PSIZE",
        TEXCOORD: "TEXCOORD",
        TEXCOORD1: "TEXCOORD1",
        TEXCOORD2: "TEXCOORD2",
        TEXCOORD3: "TEXCOORD3",
        TEXCOORD4: "TEXCOORD4",
        TEXCOORD5: "TEXCOORD5",
        TANGENT: "TANGENT",
        BINORMAL: "BINORMAL",
        TESSFACTOR: "TESSFACTOR",
        COLOR: "COLOR",
        FOG: "FOG",
        DEPTH: "DEPTH",
        SAMPLE: "SAMPLE",
        INDEX: "INDEX",
        INDEX0: "INDEX0",
        INDEX1: "INDEX1",
        INDEX2: "INDEX2",
        INDEX3: "INDEX3",
        INDEX10: //system indices starts from 10
        "INDEX10",
        INDEX11: "INDEX11",
        INDEX12: "INDEX12",
        INDEX13: "INDEX13",
        MATERIAL: "MATERIAL",
        MATERIAL1: "MATERIAL1",
        MATERIAL2: "MATERIAL2",
        DIFFUSE: "DIFFUSE",
        AMBIENT: "AMBIENT",
        SPECULAR: "SPECULAR",
        EMISSIVE: "EMISSIVE",
        SHININESS: "SHININESS",
        TEXTURE_HEADER: //special semantic for video buffer
        "TEXTURE_HEADER",
        UNKNOWN: "UNKNOWN",
        END: "\a\n\r"
    };
    /**@const*/ akra.DeclUsages = akra.DeclarationUsages;
    /** @inline */function VE_CUSTOM(sUsage, eType, iCount, iOffset) {
        if (typeof eType === "undefined") { eType = akra.EDataTypes.FLOAT; }
        if (typeof iCount === "undefined") { iCount = 1; }
        if (typeof iOffset === "undefined") { iOffset = akra.MAX_INT32; }
        return {
            count: iCount,
            type: eType,
            usage: sUsage,
            offset: iOffset
        };
    }
    akra.VE_CUSTOM = VE_CUSTOM;
    /** @inline */function VE_FLOAT(sUsage, iOffset) {
        if (typeof iOffset === "undefined") { iOffset = akra.MAX_INT32; }
        return ({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (sUsage),
offset: (iOffset)
});
    }
    akra.VE_FLOAT = VE_FLOAT;
    ;
    /** @inline */function VE_FLOAT2(sUsage, iOffset) {
        if (typeof iOffset === "undefined") { iOffset = akra.MAX_INT32; }
        return ({
count: (2),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (sUsage),
offset: (iOffset)
});
    }
    akra.VE_FLOAT2 = VE_FLOAT2;
    ;
    /** @inline */function VE_FLOAT3(sUsage, iOffset) {
        if (typeof iOffset === "undefined") { iOffset = akra.MAX_INT32; }
        return ({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (sUsage),
offset: (iOffset)
});
    }
    akra.VE_FLOAT3 = VE_FLOAT3;
    ;
    /** @inline */function VE_FLOAT4(sUsage, iOffset) {
        if (typeof iOffset === "undefined") { iOffset = akra.MAX_INT32; }
        return ({
count: (4),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (sUsage),
offset: (iOffset)
});
    }
    akra.VE_FLOAT4 = VE_FLOAT4;
    ;
    /** @inline */function VE_FLOAT4x4(sUsage, iOffset) {
        if (typeof iOffset === "undefined") { iOffset = akra.MAX_INT32; }
        return ({
count: (16),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (sUsage),
offset: (iOffset)
});
    }
    akra.VE_FLOAT4x4 = VE_FLOAT4x4;
    ;
    /** @inline */function VE_VEC2(sUsage, iOffset) {
        if (typeof iOffset === "undefined") { iOffset = akra.MAX_INT32; }
        return ({
count: (2),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (sUsage),
offset: (iOffset)
});
    }
    akra.VE_VEC2 = VE_VEC2;
    ;
    /** @inline */function VE_VEC3(sUsage, iOffset) {
        if (typeof iOffset === "undefined") { iOffset = akra.MAX_INT32; }
        return ({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (sUsage),
offset: (iOffset)
});
    }
    akra.VE_VEC3 = VE_VEC3;
    ;
    /** @inline */function VE_VEC4(sUsage, iOffset) {
        if (typeof iOffset === "undefined") { iOffset = akra.MAX_INT32; }
        return ({
count: (4),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (sUsage),
offset: (iOffset)
});
    }
    akra.VE_VEC4 = VE_VEC4;
    ;
    /** @inline */function VE_MAT4(sUsage, iOffset) {
        if (typeof iOffset === "undefined") { iOffset = akra.MAX_INT32; }
        return ({
count: (16),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (sUsage),
offset: (iOffset)
});
    }
    akra.VE_MAT4 = VE_MAT4;
    ;
    /** @inline */function VE_INT(sUsage, iOffset) {
        if (typeof iOffset === "undefined") { iOffset = akra.MAX_INT32; }
        return ({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.INT),
usage: (sUsage),
offset: (iOffset)
});
    }
    akra.VE_INT = VE_INT;
    ;
    /** @inline */function VE_END(iOffset) {
        if (typeof iOffset === "undefined") { iOffset = 0; }
        return ({
count: (0),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.UNSIGNED_BYTE),
usage: (/*checked (origin: akra)>>*/akra.DeclUsages.END),
offset: (iOffset)
});
    }
    akra.VE_END = VE_END;
    ;
    //export var createVertexDeclaration: (pData?) => IVertexDeclaration;
    })(akra || (akra = {}));
var akra;
(function (akra) {
    (function (data) {
        var VertexElement = (function () {
            function VertexElement(nCount, eType, eUsage, //mark invalid offset, for determine true offset in VertexDeclaration::_update();
            iOffset) {
                if (typeof nCount === "undefined") { nCount = 1; }
                if (typeof eType === "undefined") { eType = akra.EDataTypes.FLOAT; }
                if (typeof eUsage === "undefined") { eUsage = akra.DeclarationUsages.POSITION; }
                if (typeof iOffset === "undefined") { iOffset = akra.MAX_INT32; }
                // this properties is readonly for public usage.
                this.size = 0;
                this.index = 0;
                this.semantics = akra.DeclarationUsages.UNKNOWN;
                this.count = nCount;
                this.type = eType;
                this.usage = eUsage;
                this.offset = iOffset;
                this.update();
            }
            VertexElement.prototype.update = function () {
                this.size = this.count * akra.getTypeSize(this.type);
                this.index = 0;
                this.semantics = null;
                var pMatches = this.usage.match(/^(.*?\w)(\d+)$/i);
                if (!((pMatches) === null)) {
                    this.semantics = pMatches[1];
                    this.index = parseInt(pMatches[2]);
                    // To avoid the colosseum between the "usage" of the element as POSITION & POSITION0,
                    // given that this is the same thing, here are the elements with index 0
                    // for "usage" with the POSITION.
                    // if (this.index === 0) {
                    // 	this.usage = this.semantics;
                    // }
                                    } else {
                    this.semantics = this.usage;
                }
            };
            VertexElement.prototype.clone = function () {
                return new VertexElement(this.count, this.type, this.usage, this.offset);
            };
            VertexElement.hasUnknownOffset = /** @inline */function hasUnknownOffset(pElement) {
                return (!((pElement.offset) !== undefined) || (pElement.offset === akra.MAX_INT32));
            };
            VertexElement.prototype.isEnd = /** @inline */function () {
                return this.semantics === akra.DeclUsages.END;
            };
            VertexElement.prototype.toString = function () {
                function _an(data, n, bBackward) {
                    if (typeof bBackward === "undefined") { bBackward = false; }
                    var s = String(data);
                    for(var i = 0, t = n - s.length; i < t; ++i) {
                        if (bBackward) {
                            s = " " + s;
                        } else {
                            s += " ";
                        }
                    }
                    return s;
                }
                var s = "[ USAGE: " + _an(this.usage == akra.DeclUsages.END ? "<END>" : this.usage, 12) + ", OFFSET " + _an(this.offset, 4) + ", SIZE " + _an(this.size, 4) + " ]";
                return s;
            };
            return VertexElement;
        })();
        data.VertexElement = VertexElement;        
    })(akra.data || (akra.data = {}));
    var data = akra.data;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.VertexElement = akra.data.VertexElement;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (data) {
        var VertexDeclaration = (function () {
            function VertexDeclaration(pElements) {
                //readonly property for public usage
                this.stride = 0;
                this._pElements = [];
                if (arguments.length > 0 && ((pElements) != null)) {
                    this.append.apply(this, arguments);
                }
            }
            Object.defineProperty(VertexDeclaration.prototype, "length", {
                get: /** @inline */function () {
                    return this._pElements.length;
                },
                enumerable: true,
                configurable: true
            });
            VertexDeclaration.prototype.element = /** @inline */function (i) {
                return this._pElements[i] || null;
            };
            VertexDeclaration.prototype.append = function (pData) {
                var pElements;
                if (!akra.isArray(arguments[0])) {
                    pElements = arguments;
                } else {
                    pElements = arguments[0];
                }
                for(var i = 0; i < pElements.length; i++) {
                    var pElement = pElements[i];
                    var iOffset;
                    if (((!(((pElement).offset) !== undefined) || ((pElement).offset === /*checked (origin: akra)>>*/akra.MAX_INT32)))) {
                        //add element to end
                        iOffset = this.stride;
                    } else {
                        iOffset = pElement.offset;
                    }
                    var pVertexElement = new data.VertexElement(pElement.count, pElement.type, pElement.usage, iOffset);
                    this._pElements.push(pVertexElement);
                    var iStride = iOffset + pVertexElement.size;
                    if (this.stride < iStride) {
                        this.stride = iStride;
                    }
                }
                return this._update();
            };
            VertexDeclaration.prototype._update = function () {
                var iStride;
                for(var i = 0; i < ((this)._pElements.length); ++i) {
                    //move "END" element to end of declaration
                    if (this._pElements[i].usage === akra.DeclUsages.END) {
                        this._pElements.swap(i, i + 1);
                    }
                    //recalc total stride
                    iStride = this._pElements[i].size + this._pElements[i].offset;
                    if (this.stride < iStride) {
                        this.stride = iStride;
                    }
                }
                var pLast = this._pElements.last;
                if (pLast.usage === akra.DeclUsages.END && pLast.offset < this.stride) {
                    pLast.offset = this.stride;
                }
                return true;
            };
            VertexDeclaration.prototype.extend = function (decl) {
                var pDecl = decl;
                var pElement;
                for(var i = 0; i < ((this)._pElements.length); ++i) {
                    for(var j = 0; j < (pDecl._pElements.length); ++j) {
                        if ((pDecl._pElements[(j)] || null).usage == this._pElements[i].usage) {
 {
                                akra.logger.setSourceLocation("data/VertexDeclaration.ts", 110);
                                akra.logger.log('inconsistent declarations:', this, pDecl);
                            }
                            ;
 {
                                akra.logger.setSourceLocation("data/VertexDeclaration.ts", 111);
                                akra.logger.error('The attempt to combine the declaration containing the exact same semantics.');
                            }
                            ;
                            return false;
                        }
                    }
                }
                for(var i = 0; i < (pDecl._pElements.length); i++) {
                    pElement = (pDecl._pElements[(i)] || null).clone();
                    pElement.offset += this.stride;
                    this._pElements.push(pElement);
                }
                return this._update();
            };
            VertexDeclaration.prototype.hasSemantics = /** @inline */function (sSemantics) {
                return this.findElement(sSemantics) !== null;
            };
            VertexDeclaration.prototype.findElement = function (sSemantics, iCount) {
                if (typeof iCount === "undefined") { iCount = akra.MAX_INT32; }
                sSemantics = sSemantics.toUpperCase();
                for(var i = 0; i < ((this)._pElements.length); ++i) {
                    if (this._pElements[i].usage === sSemantics && (iCount === akra.MAX_INT32 || this._pElements[i].count == iCount)) {
                        return this._pElements[i];
                    }
                }
                return null;
            };
            VertexDeclaration.prototype.clone = function () {
                var pElements = [];
                var pDecl;
                for(var i = 0; i < ((this)._pElements.length); ++i) {
                    pElements.push(this._pElements[i].clone());
                }
                pDecl = new VertexDeclaration(pElements);
                if (pDecl._update()) {
                    return pDecl;
                }
                return null;
            };
            VertexDeclaration.prototype.toString = ///DEBUG!!!
            function () {
                var s = "\n";
                s += "  VERTEX DECLARATION ( " + this.stride + " b. ) \n";
                s += "---------------------------------------\n";
                for(var i = 0; i < ((this)._pElements.length); ++i) {
                    s += this._pElements[i].toString() + '\n';
                }
                return s;
            };
            return VertexDeclaration;
        })();
        data.VertexDeclaration = VertexDeclaration;        
    })(akra.data || (akra.data = {}));
    var data = akra.data;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.VertexDeclaration = akra.data.VertexDeclaration;
    akra.createVertexDeclaration = function (pData) {
        if (!(pData instanceof akra.VertexDeclaration)) {
            if (!(pData instanceof Array) && ((pData) != null)) {
                pData = [
                    pData
                ];
            }
            pData = new akra.VertexDeclaration(pData);
        }
        return pData;
    };
})(akra || (akra = {}));
;
var akra;
(function (akra) {
    (function (math) {
        var Vec2 = (function () {
            function Vec2(fValue1, fValue2) {
                this.x = 0.;
                this.y = 0.;
                var nArgumentsLength = arguments.length;
                var v2fVec = this;
                // if (<any>this === window || <any>this === akra || <any>this === akra.math) {
                //     v2fVec = Vec2.stack[Vec2.stackPosition ++];
                //     if(Vec2.stackPosition == Vec2.stackSize){
                //         Vec2.stackPosition = 0;
                //     }
                // }
                switch(nArgumentsLength) {
                    case 1:
                        v2fVec.set(arguments[0]);
                        break;
                    case 2:
                        v2fVec.set(arguments[0], arguments[1]);
                        break;
                    default:
                        v2fVec.x = v2fVec.y = 0.;
                        break;
                }
            }
            Object.defineProperty(Vec2.prototype, "xx", {
                get: function () {
                    return Vec2.stackCeil.set(this.x, this.x);
                },
                set: function (v2fVec) {
                    this.x = v2fVec.x;
                    this.x = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec2.prototype, "xy", {
                get: function () {
                    return Vec2.stackCeil.set(this.x, this.y);
                },
                set: function (v2fVec) {
                    this.x = v2fVec.x;
                    this.y = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec2.prototype, "yx", {
                get: function () {
                    return Vec2.stackCeil.set(this.y, this.x);
                },
                set: function (v2fVec) {
                    this.y = v2fVec.x;
                    this.x = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec2.prototype, "yy", {
                get: function () {
                    return Vec2.stackCeil.set(this.y, this.y);
                },
                set: function (v2fVec) {
                    this.y = v2fVec.x;
                    this.y = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Vec2.prototype.set = function (fValue1, fValue2) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 0:
                        this.x = this.y = 0.;
                        break;
                    case 1:
                        if ((typeof (arguments[0]) === "number")) {
                            this.x = this.y = arguments[0];
                        } else if (arguments[0] instanceof Vec2) {
                            var v2fVec = arguments[0];
                            this.x = v2fVec.x;
                            this.y = v2fVec.y;
                        } else {
                            var pArray = arguments[0];
                            this.x = pArray[0];
                            this.y = pArray[1];
                        }
                        break;
                    case 2:
                        this.x = arguments[0];
                        this.y = arguments[1];
                        break;
                }
                ;
                return this;
            };
            Vec2.prototype.clear = /** @inline */function () {
                this.x = this.y = 0.;
                return this;
            };
            Vec2.prototype.add = function (v2fVec, v2fDestination) {
                if (!((v2fDestination) !== undefined)) {
                    v2fDestination = this;
                }
                v2fDestination.x = this.x + v2fVec.x;
                v2fDestination.y = this.y + v2fVec.y;
                return v2fDestination;
            };
            Vec2.prototype.subtract = function (v2fVec, v2fDestination) {
                if (!((v2fDestination) !== undefined)) {
                    v2fDestination = this;
                }
                v2fDestination.x = this.x - v2fVec.x;
                v2fDestination.y = this.y - v2fVec.y;
                return v2fDestination;
            };
            Vec2.prototype.dot = /** @inline */function (v2fVec) {
                return this.x * v2fVec.x + this.y * v2fVec.y;
            };
            Vec2.prototype.isEqual = function (v2fVec, fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if (fEps === 0.) {
                    if (this.x != v2fVec.x || this.y != v2fVec.y) {
                        return false;
                    }
                } else {
                    if (math.abs(this.x - v2fVec.x) > fEps || math.abs(this.y - v2fVec.y) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Vec2.prototype.isClear = function (fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if (fEps === 0.) {
                    if (this.x != 0. || this.y != 0.) {
                        return false;
                    }
                } else {
                    if (math.abs(this.x) > fEps || math.abs(this.y) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Vec2.prototype.negate = function (v2fDestination) {
                if (!((v2fDestination) !== undefined)) {
                    v2fDestination = this;
                }
                v2fDestination.x = -this.x;
                v2fDestination.y = -this.y;
                return v2fDestination;
            };
            Vec2.prototype.scale = function (fScale, v2fDestination) {
                if (!((v2fDestination) !== undefined)) {
                    v2fDestination = this;
                }
                v2fDestination.x = this.x * fScale;
                v2fDestination.y = this.y * fScale;
                return v2fDestination;
            };
            Vec2.prototype.normalize = function (v2fDestination) {
                if (!((v2fDestination) !== undefined)) {
                    v2fDestination = this;
                }
                var x = this.x, y = this.y;
                var fLength = math.sqrt(x * x + y * y);
                if (fLength !== 0.) {
                    var fInvLength = 1. / fLength;
                    x *= fInvLength;
                    y *= fInvLength;
                }
                v2fDestination.x = x;
                v2fDestination.y = y;
                return v2fDestination;
            };
            Vec2.prototype.length = /** @inline */function () {
                var x = this.x, y = this.y;
                return math.sqrt(x * x + y * y);
            };
            Vec2.prototype.lengthSquare = /** @inline */function () {
                var x = this.x, y = this.y;
                return x * x + y * y;
            };
            Vec2.prototype.direction = function (v2fVec, v2fDestination) {
                if (!((v2fDestination) !== undefined)) {
                    v2fDestination = this;
                }
                var x = v2fVec.x - this.x;
                var y = v2fVec.y - this.y;
                var fLength = math.sqrt(x * x + y * y);
                if (fLength !== 0.) {
                    var fInvLength = 1. / fLength;
                    x *= fInvLength;
                    y *= fInvLength;
                }
                v2fDestination.x = x;
                v2fDestination.y = y;
                return v2fDestination;
            };
            Vec2.prototype.mix = function (v2fVec, fA, v2fDestination) {
                if (!((v2fDestination) !== undefined)) {
                    v2fDestination = this;
                }
                fA = (/*checked (origin: math)>>*/akra.math.max((0.), /*checked (origin: math)>>*/akra.math.min((fA), (1.))));
                var fA1 = 1. - fA;
                var fA2 = fA;
                v2fDestination.x = fA1 * this.x + fA2 * v2fVec.x;
                v2fDestination.y = fA1 * this.y + fA2 * v2fVec.y;
                return v2fDestination;
            };
            Vec2.prototype.toString = /** @inline */function () {
                return "[x: " + this.x + ", y: " + this.y + "]";
            };
            Object.defineProperty(Vec2, "stackCeil", {
                get: function () {
                    Vec2.stackPosition = Vec2.stackPosition === Vec2.stackSize - 1 ? 0 : Vec2.stackPosition;
                    return Vec2.stack[Vec2.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            Vec2.stackSize = 100;
            Vec2.stackPosition = 0;
            Vec2.stack = (function () {
                var pStack = new Array(Vec2.stackSize);
                for(var i = 0; i < Vec2.stackSize; i++) {
                    pStack[i] = new Vec2();
                }
                return pStack;
            })();
            return Vec2;
        })();
        math.Vec2 = Vec2;        
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
;
;
var akra;
(function (akra) {
    (function (math) {
        var Vec3 = (function () {
            function Vec3(fValue1, fValue2, fValue3) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 2:
                        this.set(arguments[0], arguments[1]);
                        break;
                    case 3:
                        this.set(arguments[0], arguments[1], arguments[2]);
                        break;
                    default:
                        this.x = this.y = this.z = 0.;
                        break;
                }
            }
            Object.defineProperty(Vec3.prototype, "xx", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.x, this.x);
                },
                set: function (v2fVec) {
                    this.x = v2fVec.x;
                    this.x = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xy", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.x, this.y);
                },
                set: function (v2fVec) {
                    this.x = v2fVec.x;
                    this.y = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xz", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.x, this.z);
                },
                set: function (v2fVec) {
                    this.x = v2fVec.x;
                    this.z = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yx", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.y, this.x);
                },
                set: function (v2fVec) {
                    this.y = v2fVec.x;
                    this.x = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yy", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.y, this.y);
                },
                set: function (v2fVec) {
                    this.y = v2fVec.x;
                    this.y = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yz", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.y, this.z);
                },
                set: function (v2fVec) {
                    this.y = v2fVec.x;
                    this.z = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zx", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.z, this.x);
                },
                set: function (v2fVec) {
                    this.z = v2fVec.x;
                    this.x = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zy", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.z, this.y);
                },
                set: function (v2fVec) {
                    this.z = v2fVec.x;
                    this.y = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zz", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.z, this.z);
                },
                set: function (v2fVec) {
                    this.z = v2fVec.x;
                    this.z = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xxx", {
                get: function () {
                    return Vec3.stackCeil.set(this.x, this.x, this.x);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.x = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xxy", {
                get: function () {
                    return Vec3.stackCeil.set(this.x, this.x, this.y);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.x = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xxz", {
                get: function () {
                    return Vec3.stackCeil.set(this.x, this.x, this.z);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.x = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xyx", {
                get: function () {
                    return Vec3.stackCeil.set(this.x, this.y, this.x);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.y = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xyy", {
                get: function () {
                    return Vec3.stackCeil.set(this.x, this.y, this.y);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.y = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xyz", {
                get: function () {
                    return Vec3.stackCeil.set(this.x, this.y, this.z);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.y = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xzx", {
                get: function () {
                    return Vec3.stackCeil.set(this.x, this.z, this.x);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.z = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xzy", {
                get: function () {
                    return Vec3.stackCeil.set(this.x, this.z, this.y);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.z = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xzz", {
                get: function () {
                    return Vec3.stackCeil.set(this.x, this.z, this.z);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.z = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yxx", {
                get: function () {
                    return Vec3.stackCeil.set(this.y, this.x, this.x);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.x = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yxy", {
                get: function () {
                    return Vec3.stackCeil.set(this.y, this.x, this.y);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.x = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yxz", {
                get: function () {
                    return Vec3.stackCeil.set(this.y, this.x, this.z);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.x = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yyx", {
                get: function () {
                    return Vec3.stackCeil.set(this.y, this.y, this.x);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.y = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yyy", {
                get: function () {
                    return Vec3.stackCeil.set(this.y, this.y, this.y);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.y = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yyz", {
                get: function () {
                    return Vec3.stackCeil.set(this.y, this.y, this.z);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.y = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yzx", {
                get: function () {
                    return Vec3.stackCeil.set(this.y, this.z, this.x);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.z = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yzy", {
                get: function () {
                    return Vec3.stackCeil.set(this.y, this.z, this.y);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.z = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yzz", {
                get: function () {
                    return Vec3.stackCeil.set(this.y, this.z, this.z);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.z = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zxx", {
                get: function () {
                    return Vec3.stackCeil.set(this.z, this.x, this.x);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.x = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zxy", {
                get: function () {
                    return Vec3.stackCeil.set(this.z, this.x, this.y);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.x = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zxz", {
                get: function () {
                    return Vec3.stackCeil.set(this.z, this.x, this.z);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.x = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zyx", {
                get: function () {
                    return Vec3.stackCeil.set(this.z, this.y, this.x);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.y = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zyy", {
                get: function () {
                    return Vec3.stackCeil.set(this.z, this.y, this.y);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.y = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zyz", {
                get: function () {
                    return Vec3.stackCeil.set(this.z, this.y, this.z);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.y = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zzx", {
                get: function () {
                    return Vec3.stackCeil.set(this.z, this.z, this.x);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.z = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zzy", {
                get: function () {
                    return Vec3.stackCeil.set(this.z, this.z, this.y);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.z = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zzz", {
                get: function () {
                    return Vec3.stackCeil.set(this.z, this.z, this.z);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.z = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Vec3.prototype.set = function (fValue1, fValue2, fValue3) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 0:
                        this.x = this.y = this.z = 0.;
                        break;
                    case 1:
                        if ((typeof (arguments[0]) === "number")) {
                            this.x = this.y = this.z = arguments[0];
                        } else if (arguments[0] instanceof Vec3) {
                            var v3fVec = arguments[0];
                            this.x = v3fVec.x;
                            this.y = v3fVec.y;
                            this.z = v3fVec.z;
                        } else {
                            var pArray = arguments[0];
                            this.x = pArray[0];
                            this.y = pArray[1];
                            this.z = pArray[2];
                        }
                        break;
                    case 2:
                        if ((typeof (arguments[0]) === "number")) {
                            var fValue = arguments[0];
                            var v2fVec = arguments[1];
                            this.x = fValue;
                            this.y = v2fVec.x;
                            this.z = v2fVec.y;
                        } else {
                            var v2fVec = arguments[0];
                            var fValue = arguments[1];
                            this.x = v2fVec.x;
                            this.y = v2fVec.y;
                            this.z = fValue;
                        }
                        break;
                    case 3:
                        this.x = arguments[0];
                        this.y = arguments[1];
                        this.z = arguments[2];
                        break;
                }
                return this;
            };
            Vec3.prototype.clear = /** @inline */function () {
                this.x = this.y = this.z = 0.;
                return this;
            };
            Vec3.prototype.add = function (v3fVec, v3fDestination) {
                if (!((v3fDestination) !== undefined)) {
                    v3fDestination = this;
                }
                v3fDestination.x = this.x + v3fVec.x;
                v3fDestination.y = this.y + v3fVec.y;
                v3fDestination.z = this.z + v3fVec.z;
                return v3fDestination;
            };
            Vec3.prototype.subtract = function (v3fVec, v3fDestination) {
                if (!((v3fDestination) !== undefined)) {
                    v3fDestination = this;
                }
                v3fDestination.x = this.x - v3fVec.x;
                v3fDestination.y = this.y - v3fVec.y;
                v3fDestination.z = this.z - v3fVec.z;
                return v3fDestination;
            };
            Vec3.prototype.dot = /** @inline */function (v3fVec) {
                return this.x * v3fVec.x + this.y * v3fVec.y + this.z * v3fVec.z;
            };
            Vec3.prototype.cross = function (v3fVec, v3fDestination) {
                if (!((v3fDestination) !== undefined)) {
                    v3fDestination = this;
                }
                var x1 = this.x, y1 = this.y, z1 = this.z;
                var x2 = v3fVec.x, y2 = v3fVec.y, z2 = v3fVec.z;
                v3fDestination.x = y1 * z2 - z1 * y2;
                v3fDestination.y = z1 * x2 - x1 * z2;
                v3fDestination.z = x1 * y2 - y1 * x2;
                return v3fDestination;
            };
            Vec3.prototype.isEqual = function (v3fVec, fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if (fEps === 0.) {
                    if (this.x != v3fVec.x || this.y != v3fVec.y || this.z != v3fVec.z) {
                        return false;
                    }
                } else {
                    if (math.abs(this.x - v3fVec.x) > fEps || math.abs(this.y - v3fVec.y) > fEps || math.abs(this.z - v3fVec.z) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Vec3.prototype.isClear = function (fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if (fEps === 0.) {
                    if (this.x != 0. || this.y != 0. || this.z != 0.) {
                        return false;
                    }
                } else {
                    if (math.abs(this.x) > fEps || math.abs(this.y) > fEps || math.abs(this.z) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Vec3.prototype.negate = function (v3fDestination) {
                if (!((v3fDestination) !== undefined)) {
                    v3fDestination = this;
                }
                v3fDestination.x = -this.x;
                v3fDestination.y = -this.y;
                v3fDestination.z = -this.z;
                return v3fDestination;
            };
            Vec3.prototype.scale = function (fScale, v3fDestination) {
                if (!((v3fDestination) !== undefined)) {
                    v3fDestination = this;
                }
                if ((typeof (arguments[0]) === "number")) {
                    var fScale = arguments[0];
                    v3fDestination.x = this.x * fScale;
                    v3fDestination.y = this.y * fScale;
                    v3fDestination.z = this.z * fScale;
                } else {
                    var v3fScale = arguments[0];
                    v3fDestination.x = this.x * v3fScale.x;
                    v3fDestination.y = this.y * v3fScale.y;
                    v3fDestination.z = this.z * v3fScale.z;
                }
                return v3fDestination;
            };
            Vec3.prototype.normalize = function (v3fDestination) {
                if (!v3fDestination) {
                    v3fDestination = this;
                }
                var x = this.x, y = this.y, z = this.z;
                var fLength = math.sqrt(x * x + y * y + z * z);
                if (fLength !== 0.) {
                    var fInvLength = 1. / fLength;
                    x *= fInvLength;
                    y *= fInvLength;
                    z *= fInvLength;
                }
                v3fDestination.x = x;
                v3fDestination.y = y;
                v3fDestination.z = z;
                return v3fDestination;
            };
            Vec3.prototype.length = /** @inline */function () {
                return math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            };
            Vec3.prototype.lengthSquare = /** @inline */function () {
                var x = this.x, y = this.y, z = this.z;
                return x * x + y * y + z * z;
            };
            Vec3.prototype.direction = function (v3fVec, v3fDestination) {
                if (!((v3fDestination) !== undefined)) {
                    v3fDestination = this;
                }
                var x = v3fVec.x - this.x;
                var y = v3fVec.y - this.y;
                var z = v3fVec.z - this.z;
                var fLength = math.sqrt(x * x + y * y + z * z);
                if (fLength !== 0.) {
                    var fInvLength = 1. / fLength;
                    x *= fInvLength;
                    y *= fInvLength;
                    z *= fInvLength;
                }
                v3fDestination.x = x;
                v3fDestination.y = y;
                v3fDestination.z = z;
                return v3fDestination;
            };
            Vec3.prototype.mix = function (v3fVec, fA, v3fDestination) {
                if (!((v3fDestination) !== undefined)) {
                    v3fDestination = this;
                }
                fA = (/*checked (origin: math)>>*/akra.math.max((0.), /*checked (origin: math)>>*/akra.math.min((fA), (1.))));
                var fA1 = 1. - fA;
                var fA2 = fA;
                v3fDestination.x = fA1 * this.x + fA2 * v3fVec.x;
                v3fDestination.y = fA1 * this.y + fA2 * v3fVec.y;
                v3fDestination.z = fA1 * this.z + fA2 * v3fVec.z;
                return v3fDestination;
            };
            Vec3.prototype.toString = /** @inline */function () {
                return "[x: " + this.x + " ,y: " + this.y + ", z: " + this.z + "]";
            };
            Vec3.prototype.toTranslationMatrix = function (m4fDestination) {
                if (!((m4fDestination) !== undefined)) {
                    m4fDestination = new math.Mat4(1.);
                } else {
                    m4fDestination.set(1.);
                }
                var pData = m4fDestination.data;
                pData[12] = this.x;
                pData[13] = this.y;
                pData[14] = this.z;
                return m4fDestination;
            };
            Vec3.prototype.vec3TransformCoord = function (m4fTransformation, v3fDestination) {
                if (!v3fDestination) {
                    v3fDestination = this;
                }
                var pData = m4fTransformation.data;
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var w;
                x = pData[0] * x + pData[4] * y + pData[8] * z + pData[12];
                y = pData[1] * x + pData[5] * y + pData[9] * z + pData[13];
                z = pData[2] * x + pData[6] * y + pData[10] * z + pData[14];
                w = pData[2] * x + pData[7] * y + pData[11] * z + pData[15];
                var fInvW = 1. / w;
                v3fDestination.x = x * fInvW;
                v3fDestination.y = y * fInvW;
                v3fDestination.z = z * fInvW;
                return v3fDestination;
            };
            Object.defineProperty(Vec3, "stackCeil", {
                get: function () {
                    Vec3.stackPosition = Vec3.stackPosition === Vec3.stackSize - 1 ? 0 : Vec3.stackPosition;
                    return Vec3.stack[Vec3.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            Vec3.stackSize = 256;
            Vec3.stackPosition = 0;
            Vec3.stack = (function () {
                var pStack = new Array(Vec3.stackSize);
                for(var i = 0; i < Vec3.stackSize; i++) {
                    pStack[i] = new Vec3();
                }
                return pStack;
            })();
            return Vec3;
        })();
        math.Vec3 = Vec3;        
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (math) {
        var Vec4 = (function () {
            function Vec4(fValue1, fValue2, fValue3, fValue4) {
                var nArgumentsLength = arguments.length;
                var v4fVec = this;
                // if (<any>this === window || <any>this === akra || <any>this === akra.math) {
                //     v4fVec = Vec4.stack[Vec4.stackPosition ++];
                //     if(Vec4.stackPosition == Vec4.stackSize){
                //         Vec4.stackPosition = 0;
                //     }
                // }
                switch(nArgumentsLength) {
                    case 1:
                        v4fVec.set(arguments[0]);
                        break;
                    case 2:
                        v4fVec.set(arguments[0], arguments[1]);
                        break;
                    case 3:
                        v4fVec.set(arguments[0], arguments[1], arguments[2]);
                        break;
                    case 4:
                        v4fVec.set(arguments[0], arguments[1], arguments[2], arguments[3]);
                        break;
                    default:
                        v4fVec.x = v4fVec.y = v4fVec.z = v4fVec.w = 0.;
                        break;
                }
            }
            Object.defineProperty(Vec4.prototype, "xx", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.x, this.x);
                },
                set: function (v2fVec) {
                    this.x = v2fVec.x;
                    this.x = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xy", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.x, this.y);
                },
                set: function (v2fVec) {
                    this.x = v2fVec.x;
                    this.y = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xz", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.x, this.z);
                },
                set: function (v2fVec) {
                    this.x = v2fVec.x;
                    this.z = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xw", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.x, this.w);
                },
                set: function (v2fVec) {
                    this.x = v2fVec.x;
                    this.w = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yx", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.y, this.x);
                },
                set: function (v2fVec) {
                    this.y = v2fVec.x;
                    this.x = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yy", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.y, this.y);
                },
                set: function (v2fVec) {
                    this.y = v2fVec.x;
                    this.y = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yz", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.y, this.z);
                },
                set: function (v2fVec) {
                    this.y = v2fVec.x;
                    this.z = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yw", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.y, this.w);
                },
                set: function (v2fVec) {
                    this.y = v2fVec.x;
                    this.w = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zx", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.z, this.x);
                },
                set: function (v2fVec) {
                    this.z = v2fVec.x;
                    this.x = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zy", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.z, this.y);
                },
                set: function (v2fVec) {
                    this.z = v2fVec.x;
                    this.y = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zz", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.z, this.z);
                },
                set: function (v2fVec) {
                    this.z = v2fVec.x;
                    this.z = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zw", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.z, this.w);
                },
                set: function (v2fVec) {
                    this.z = v2fVec.x;
                    this.w = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wx", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.w, this.x);
                },
                set: function (v2fVec) {
                    this.w = v2fVec.x;
                    this.x = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wy", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.w, this.y);
                },
                set: function (v2fVec) {
                    this.w = v2fVec.x;
                    this.y = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wz", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.w, this.z);
                },
                set: function (v2fVec) {
                    this.w = v2fVec.x;
                    this.z = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ww", {
                get: function () {
                    return math.Vec2.stackCeil.set(this.w, this.w);
                },
                set: function (v2fVec) {
                    this.w = v2fVec.x;
                    this.w = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxx", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.x, this.x, this.x);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.x = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxy", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.x, this.x, this.y);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.x = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxz", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.x, this.x, this.z);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.x = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxw", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.x, this.x, this.w);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.x = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyx", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.x, this.y, this.x);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.y = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyy", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.x, this.y, this.y);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.y = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyz", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.x, this.y, this.z);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.y = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyw", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.x, this.y, this.w);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.y = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzx", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.x, this.z, this.x);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.z = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzy", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.x, this.z, this.y);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.z = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzz", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.x, this.z, this.z);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.z = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzw", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.x, this.z, this.w);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.z = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwx", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.x, this.w, this.x);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.w = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwy", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.x, this.w, this.y);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.w = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwz", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.x, this.w, this.z);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.w = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xww", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.x, this.w, this.w);
                },
                set: function (v3fVec) {
                    this.x = v3fVec.x;
                    this.w = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxx", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.y, this.x, this.x);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.x = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxy", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.y, this.x, this.y);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.x = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxz", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.y, this.x, this.z);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.x = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxw", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.y, this.x, this.w);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.x = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyx", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.y, this.y, this.x);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.y = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyy", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.y, this.y, this.y);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.y = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyz", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.y, this.y, this.z);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.y = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyw", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.y, this.y, this.w);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.y = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzx", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.y, this.z, this.x);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.z = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzy", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.y, this.z, this.y);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.z = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzz", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.y, this.z, this.z);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.z = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzw", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.y, this.z, this.w);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.z = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywx", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.y, this.w, this.x);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.w = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywy", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.y, this.w, this.y);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.w = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywz", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.y, this.w, this.z);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.w = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yww", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.y, this.w, this.w);
                },
                set: function (v3fVec) {
                    this.y = v3fVec.x;
                    this.w = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxx", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.z, this.x, this.x);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.x = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxy", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.z, this.x, this.y);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.x = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxz", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.z, this.x, this.z);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.x = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxw", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.z, this.x, this.w);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.x = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyx", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.z, this.y, this.x);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.y = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyy", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.z, this.y, this.y);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.y = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyz", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.z, this.y, this.z);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.y = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyw", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.z, this.y, this.w);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.y = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzx", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.z, this.z, this.x);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.z = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzy", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.z, this.z, this.y);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.z = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzz", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.z, this.z, this.z);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.z = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzw", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.z, this.z, this.w);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.z = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwx", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.z, this.w, this.x);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.w = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwy", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.z, this.w, this.y);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.w = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwz", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.z, this.w, this.z);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.w = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zww", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.z, this.w, this.w);
                },
                set: function (v3fVec) {
                    this.z = v3fVec.x;
                    this.w = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxx", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.w, this.x, this.x);
                },
                set: function (v3fVec) {
                    this.w = v3fVec.x;
                    this.x = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxy", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.w, this.x, this.y);
                },
                set: function (v3fVec) {
                    this.w = v3fVec.x;
                    this.x = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxz", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.w, this.x, this.z);
                },
                set: function (v3fVec) {
                    this.w = v3fVec.x;
                    this.x = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxw", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.w, this.x, this.w);
                },
                set: function (v3fVec) {
                    this.w = v3fVec.x;
                    this.x = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyx", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.w, this.y, this.x);
                },
                set: function (v3fVec) {
                    this.w = v3fVec.x;
                    this.y = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyy", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.w, this.y, this.y);
                },
                set: function (v3fVec) {
                    this.w = v3fVec.x;
                    this.y = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyz", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.w, this.y, this.z);
                },
                set: function (v3fVec) {
                    this.w = v3fVec.x;
                    this.y = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyw", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.w, this.y, this.w);
                },
                set: function (v3fVec) {
                    this.w = v3fVec.x;
                    this.y = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzx", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.w, this.z, this.x);
                },
                set: function (v3fVec) {
                    this.w = v3fVec.x;
                    this.z = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzy", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.w, this.z, this.y);
                },
                set: function (v3fVec) {
                    this.w = v3fVec.x;
                    this.z = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzz", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.w, this.z, this.z);
                },
                set: function (v3fVec) {
                    this.w = v3fVec.x;
                    this.z = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzw", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.w, this.z, this.w);
                },
                set: function (v3fVec) {
                    this.w = v3fVec.x;
                    this.z = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwx", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.w, this.w, this.x);
                },
                set: function (v3fVec) {
                    this.w = v3fVec.x;
                    this.w = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwy", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.w, this.w, this.y);
                },
                set: function (v3fVec) {
                    this.w = v3fVec.x;
                    this.w = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwz", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.w, this.w, this.z);
                },
                set: function (v3fVec) {
                    this.w = v3fVec.x;
                    this.w = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "www", {
                get: function () {
                    return math.Vec3.stackCeil.set(this.w, this.w, this.w);
                },
                set: function (v3fVec) {
                    this.w = v3fVec.x;
                    this.w = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxxx", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.x, this.x, this.x);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxxy", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.x, this.x, this.y);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxxz", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.x, this.x, this.z);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxxw", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.x, this.x, this.w);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxyx", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.x, this.y, this.x);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxyy", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.x, this.y, this.y);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxyz", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.x, this.y, this.z);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxyw", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.x, this.y, this.w);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxzx", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.x, this.z, this.x);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxzy", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.x, this.z, this.y);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxzz", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.x, this.z, this.z);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxzw", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.x, this.z, this.w);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxwx", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.x, this.w, this.x);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxwy", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.x, this.w, this.y);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxwz", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.x, this.w, this.z);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxww", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.x, this.w, this.w);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyxx", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.y, this.x, this.x);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyxy", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.y, this.x, this.y);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyxz", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.y, this.x, this.z);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyxw", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.y, this.x, this.w);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyyx", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.y, this.y, this.x);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyyy", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.y, this.y, this.y);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyyz", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.y, this.y, this.z);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyyw", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.y, this.y, this.w);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyzx", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.y, this.z, this.x);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyzy", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.y, this.z, this.y);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyzz", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.y, this.z, this.z);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyzw", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.y, this.z, this.w);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xywx", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.y, this.w, this.x);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xywy", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.y, this.w, this.y);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xywz", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.y, this.w, this.z);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyww", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.y, this.w, this.w);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzxx", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.z, this.x, this.x);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzxy", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.z, this.x, this.y);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzxz", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.z, this.x, this.z);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzxw", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.z, this.x, this.w);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzyx", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.z, this.y, this.x);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzyy", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.z, this.y, this.y);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzyz", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.z, this.y, this.z);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzyw", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.z, this.y, this.w);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzzx", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.z, this.z, this.x);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzzy", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.z, this.z, this.y);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzzz", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.z, this.z, this.z);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzzw", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.z, this.z, this.w);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzwx", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.z, this.w, this.x);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzwy", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.z, this.w, this.y);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzwz", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.z, this.w, this.z);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzww", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.z, this.w, this.w);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwxx", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.w, this.x, this.x);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwxy", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.w, this.x, this.y);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwxz", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.w, this.x, this.z);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwxw", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.w, this.x, this.w);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwyx", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.w, this.y, this.x);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwyy", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.w, this.y, this.y);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwyz", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.w, this.y, this.z);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwyw", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.w, this.y, this.w);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwzx", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.w, this.z, this.x);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwzy", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.w, this.z, this.y);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwzz", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.w, this.z, this.z);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwzw", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.w, this.z, this.w);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwwx", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.w, this.w, this.x);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwwy", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.w, this.w, this.y);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwwz", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.w, this.w, this.z);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwww", {
                get: function () {
                    return Vec4.stackCeil.set(this.x, this.w, this.w, this.w);
                },
                set: function (v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxxx", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.x, this.x, this.x);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxxy", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.x, this.x, this.y);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxxz", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.x, this.x, this.z);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxxw", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.x, this.x, this.w);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxyx", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.x, this.y, this.x);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxyy", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.x, this.y, this.y);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxyz", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.x, this.y, this.z);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxyw", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.x, this.y, this.w);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxzx", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.x, this.z, this.x);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxzy", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.x, this.z, this.y);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxzz", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.x, this.z, this.z);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxzw", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.x, this.z, this.w);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxwx", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.x, this.w, this.x);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxwy", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.x, this.w, this.y);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxwz", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.x, this.w, this.z);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxww", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.x, this.w, this.w);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyxx", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.y, this.x, this.x);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyxy", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.y, this.x, this.y);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyxz", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.y, this.x, this.z);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyxw", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.y, this.x, this.w);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyyx", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.y, this.y, this.x);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyyy", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.y, this.y, this.y);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyyz", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.y, this.y, this.z);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyyw", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.y, this.y, this.w);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyzx", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.y, this.z, this.x);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyzy", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.y, this.z, this.y);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyzz", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.y, this.z, this.z);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyzw", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.y, this.z, this.w);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yywx", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.y, this.w, this.x);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yywy", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.y, this.w, this.y);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yywz", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.y, this.w, this.z);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyww", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.y, this.w, this.w);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzxx", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.z, this.x, this.x);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzxy", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.z, this.x, this.y);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzxz", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.z, this.x, this.z);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzxw", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.z, this.x, this.w);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzyx", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.z, this.y, this.x);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzyy", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.z, this.y, this.y);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzyz", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.z, this.y, this.z);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzyw", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.z, this.y, this.w);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzzx", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.z, this.z, this.x);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzzy", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.z, this.z, this.y);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzzz", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.z, this.z, this.z);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzzw", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.z, this.z, this.w);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzwx", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.z, this.w, this.x);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzwy", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.z, this.w, this.y);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzwz", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.z, this.w, this.z);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzww", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.z, this.w, this.w);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywxx", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.w, this.x, this.x);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywxy", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.w, this.x, this.y);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywxz", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.w, this.x, this.z);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywxw", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.w, this.x, this.w);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywyx", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.w, this.y, this.x);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywyy", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.w, this.y, this.y);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywyz", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.w, this.y, this.z);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywyw", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.w, this.y, this.w);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywzx", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.w, this.z, this.x);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywzy", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.w, this.z, this.y);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywzz", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.w, this.z, this.z);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywzw", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.w, this.z, this.w);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywwx", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.w, this.w, this.x);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywwy", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.w, this.w, this.y);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywwz", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.w, this.w, this.z);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywww", {
                get: function () {
                    return Vec4.stackCeil.set(this.y, this.w, this.w, this.w);
                },
                set: function (v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxxx", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.x, this.x, this.x);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxxy", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.x, this.x, this.y);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxxz", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.x, this.x, this.z);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxxw", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.x, this.x, this.w);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxyx", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.x, this.y, this.x);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxyy", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.x, this.y, this.y);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxyz", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.x, this.y, this.z);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxyw", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.x, this.y, this.w);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxzx", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.x, this.z, this.x);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxzy", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.x, this.z, this.y);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxzz", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.x, this.z, this.z);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxzw", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.x, this.z, this.w);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxwx", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.x, this.w, this.x);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxwy", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.x, this.w, this.y);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxwz", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.x, this.w, this.z);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxww", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.x, this.w, this.w);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyxx", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.y, this.x, this.x);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyxy", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.y, this.x, this.y);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyxz", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.y, this.x, this.z);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyxw", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.y, this.x, this.w);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyyx", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.y, this.y, this.x);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyyy", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.y, this.y, this.y);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyyz", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.y, this.y, this.z);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyyw", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.y, this.y, this.w);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyzx", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.y, this.z, this.x);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyzy", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.y, this.z, this.y);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyzz", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.y, this.z, this.z);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyzw", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.y, this.z, this.w);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zywx", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.y, this.w, this.x);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zywy", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.y, this.w, this.y);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zywz", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.y, this.w, this.z);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyww", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.y, this.w, this.w);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzxx", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.z, this.x, this.x);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzxy", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.z, this.x, this.y);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzxz", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.z, this.x, this.z);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzxw", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.z, this.x, this.w);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzyx", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.z, this.y, this.x);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzyy", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.z, this.y, this.y);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzyz", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.z, this.y, this.z);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzyw", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.z, this.y, this.w);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzzx", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.z, this.z, this.x);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzzy", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.z, this.z, this.y);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzzz", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.z, this.z, this.z);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzzw", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.z, this.z, this.w);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzwx", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.z, this.w, this.x);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzwy", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.z, this.w, this.y);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzwz", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.z, this.w, this.z);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzww", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.z, this.w, this.w);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwxx", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.w, this.x, this.x);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwxy", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.w, this.x, this.y);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwxz", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.w, this.x, this.z);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwxw", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.w, this.x, this.w);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwyx", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.w, this.y, this.x);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwyy", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.w, this.y, this.y);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwyz", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.w, this.y, this.z);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwyw", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.w, this.y, this.w);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwzx", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.w, this.z, this.x);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwzy", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.w, this.z, this.y);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwzz", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.w, this.z, this.z);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwzw", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.w, this.z, this.w);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwwx", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.w, this.w, this.x);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwwy", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.w, this.w, this.y);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwwz", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.w, this.w, this.z);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwww", {
                get: function () {
                    return Vec4.stackCeil.set(this.z, this.w, this.w, this.w);
                },
                set: function (v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxxx", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.x, this.x, this.x);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxxy", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.x, this.x, this.y);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxxz", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.x, this.x, this.z);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxxw", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.x, this.x, this.w);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxyx", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.x, this.y, this.x);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxyy", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.x, this.y, this.y);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxyz", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.x, this.y, this.z);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxyw", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.x, this.y, this.w);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxzx", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.x, this.z, this.x);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxzy", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.x, this.z, this.y);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxzz", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.x, this.z, this.z);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxzw", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.x, this.z, this.w);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxwx", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.x, this.w, this.x);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxwy", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.x, this.w, this.y);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxwz", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.x, this.w, this.z);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxww", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.x, this.w, this.w);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyxx", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.y, this.x, this.x);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyxy", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.y, this.x, this.y);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyxz", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.y, this.x, this.z);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyxw", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.y, this.x, this.w);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyyx", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.y, this.y, this.x);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyyy", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.y, this.y, this.y);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyyz", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.y, this.y, this.z);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyyw", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.y, this.y, this.w);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyzx", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.y, this.z, this.x);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyzy", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.y, this.z, this.y);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyzz", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.y, this.z, this.z);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyzw", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.y, this.z, this.w);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wywx", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.y, this.w, this.x);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wywy", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.y, this.w, this.y);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wywz", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.y, this.w, this.z);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyww", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.y, this.w, this.w);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzxx", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.z, this.x, this.x);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzxy", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.z, this.x, this.y);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzxz", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.z, this.x, this.z);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzxw", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.z, this.x, this.w);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzyx", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.z, this.y, this.x);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzyy", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.z, this.y, this.y);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzyz", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.z, this.y, this.z);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzyw", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.z, this.y, this.w);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzzx", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.z, this.z, this.x);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzzy", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.z, this.z, this.y);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzzz", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.z, this.z, this.z);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzzw", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.z, this.z, this.w);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzwx", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.z, this.w, this.x);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzwy", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.z, this.w, this.y);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzwz", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.z, this.w, this.z);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzww", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.z, this.w, this.w);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwxx", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.w, this.x, this.x);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwxy", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.w, this.x, this.y);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwxz", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.w, this.x, this.z);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwxw", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.w, this.x, this.w);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwyx", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.w, this.y, this.x);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwyy", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.w, this.y, this.y);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwyz", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.w, this.y, this.z);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwyw", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.w, this.y, this.w);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwzx", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.w, this.z, this.x);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwzy", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.w, this.z, this.y);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwzz", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.w, this.z, this.z);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwzw", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.w, this.z, this.w);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwwx", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.w, this.w, this.x);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwwy", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.w, this.w, this.y);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwwz", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.w, this.w, this.z);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwww", {
                get: function () {
                    return Vec4.stackCeil.set(this.w, this.w, this.w, this.w);
                },
                set: function (v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Vec4.prototype.set = function () {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 0:
                        this.x = this.y = this.z = this.w = 0.;
                        break;
                    case 1:
                        if ((typeof (arguments[0]) === "number")) {
                            this.x = this.y = this.z = this.w = arguments[0];
                        } else if (arguments[0] instanceof Vec4) {
                            var v4fVec = arguments[0];
                            this.x = v4fVec.x;
                            this.y = v4fVec.y;
                            this.z = v4fVec.z;
                            this.w = v4fVec.w;
                        } else //color
                        if (((arguments[0].r) !== undefined)) {
                            this.x = arguments[0].r;
                            this.y = arguments[0].g;
                            this.z = arguments[0].b;
                            this.w = arguments[0].a;
                        } else {
                            //array
                            var pArray = arguments[0];
                            this.x = pArray[0];
                            this.y = pArray[1];
                            this.z = pArray[2];
                            this.w = pArray[3];
                        }
                        break;
                    case 2:
                        if ((typeof (arguments[0]) === "number")) {
                            var fValue = arguments[0];
                            var v3fVec = arguments[1];
                            this.x = fValue;
                            this.y = v3fVec.x;
                            this.z = v3fVec.y;
                            this.w = v3fVec.z;
                        } else if (arguments[0] instanceof math.Vec2) {
                            var v2fVec1 = arguments[0];
                            var v2fVec2 = arguments[1];
                            this.x = v2fVec1.x;
                            this.y = v2fVec1.y;
                            this.z = v2fVec2.x;
                            this.w = v2fVec2.y;
                        } else {
                            var v3fVec = arguments[0];
                            var fValue = arguments[1];
                            this.x = v3fVec.x;
                            this.y = v3fVec.y;
                            this.z = v3fVec.z;
                            this.w = fValue;
                        }
                        break;
                    case 3:
                        if ((typeof (arguments[0]) === "number")) {
                            var fValue1 = arguments[0];
                            if ((typeof (arguments[1]) === "number")) {
                                var fValue2 = arguments[1];
                                var v2fVec = arguments[2];
                                this.x = fValue1;
                                this.y = fValue2;
                                this.z = v2fVec.x;
                                this.w = v2fVec.y;
                            } else {
                                var v2fVec = arguments[1];
                                var fValue2 = arguments[2];
                                this.x = fValue1;
                                this.y = v2fVec.x;
                                this.z = v2fVec.y;
                                this.w = fValue2;
                            }
                        } else {
                            var v2fVec = arguments[0];
                            var fValue1 = arguments[1];
                            var fValue2 = arguments[2];
                            this.x = v2fVec.x;
                            this.y = v2fVec.y;
                            this.z = fValue1;
                            this.w = fValue2;
                        }
                        break;
                    case 4:
                        this.x = arguments[0];
                        this.y = arguments[1];
                        this.z = arguments[2];
                        this.w = arguments[3];
                        break;
                }
                return this;
            };
            Vec4.prototype.clear = /** @inline */function () {
                this.x = this.y = this.z = this.w = 0.;
                return this;
            };
            Vec4.prototype.add = function (v4fVec, v4fDestination) {
                if (!((v4fDestination) !== undefined)) {
                    v4fDestination = this;
                }
                v4fDestination.x = this.x + v4fVec.x;
                v4fDestination.y = this.y + v4fVec.y;
                v4fDestination.z = this.z + v4fVec.z;
                v4fDestination.w = this.w + v4fVec.w;
                return v4fDestination;
            };
            Vec4.prototype.subtract = function (v4fVec, v4fDestination) {
                if (!((v4fDestination) !== undefined)) {
                    v4fDestination = this;
                }
                v4fDestination.x = this.x - v4fVec.x;
                v4fDestination.y = this.y - v4fVec.y;
                v4fDestination.z = this.z - v4fVec.z;
                v4fDestination.w = this.w - v4fVec.w;
                return v4fDestination;
            };
            Vec4.prototype.dot = /** @inline */function (v4fVec) {
                return this.x * v4fVec.x + this.y * v4fVec.y + this.z * v4fVec.z + this.w * v4fVec.w;
            };
            Vec4.prototype.isEqual = function (v4fVec, fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if (fEps === 0.) {
                    if (this.x != v4fVec.x || this.y != v4fVec.y || this.z != v4fVec.z || this.w != v4fVec.w) {
                        return false;
                    }
                } else {
                    if (math.abs(this.x - v4fVec.x) > fEps || math.abs(this.y - v4fVec.y) > fEps || math.abs(this.z - v4fVec.z) > fEps || math.abs(this.w - v4fVec.w) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Vec4.prototype.isClear = function (fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if (fEps === 0.) {
                    if (this.x != 0. || this.y != 0. || this.z != 0. || this.w != 0.) {
                        return false;
                    }
                } else {
                    if (math.abs(this.x) > fEps || math.abs(this.y) > fEps || math.abs(this.z) > fEps || math.abs(this.w) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Vec4.prototype.negate = function (v4fDestination) {
                if (!((v4fDestination) !== undefined)) {
                    v4fDestination = this;
                }
                v4fDestination.x = -this.x;
                v4fDestination.y = -this.y;
                v4fDestination.z = -this.z;
                v4fDestination.w = -this.w;
                return v4fDestination;
            };
            Vec4.prototype.scale = function (fScale, v4fDestination) {
                if (!((v4fDestination) !== undefined)) {
                    v4fDestination = this;
                }
                v4fDestination.x = this.x * fScale;
                v4fDestination.y = this.y * fScale;
                v4fDestination.z = this.z * fScale;
                v4fDestination.w = this.w * fScale;
                return v4fDestination;
            };
            Vec4.prototype.normalize = function (v4fDestination) {
                if (!((v4fDestination) !== undefined)) {
                    v4fDestination = this;
                }
                var x = this.x, y = this.y, z = this.z, w = this.w;
                var fLength = math.sqrt(x * x + y * y + z * z + w * w);
                if (fLength !== 0.) {
                    var fInvLength = 1. / fLength;
                    x *= fInvLength;
                    y *= fInvLength;
                    z *= fInvLength;
                    w *= fInvLength;
                }
                v4fDestination.x = x;
                v4fDestination.y = y;
                v4fDestination.z = z;
                v4fDestination.w = w;
                return v4fDestination;
            };
            Vec4.prototype.length = /** @inline */function () {
                var x = this.x, y = this.y, z = this.z, w = this.w;
                return math.sqrt(x * x + y * y + z * z + w * w);
            };
            Vec4.prototype.lengthSquare = /** @inline */function () {
                var x = this.x, y = this.y, z = this.z, w = this.w;
                return x * x + y * y + z * z + w * w;
            };
            Vec4.prototype.direction = function (v4fVec, v4fDestination) {
                if (!((v4fDestination) !== undefined)) {
                    v4fDestination = this;
                }
                var x = v4fVec.x - this.x;
                var y = v4fVec.y - this.y;
                var z = v4fVec.z - this.z;
                var w = v4fVec.w - this.w;
                var fLength = math.sqrt(x * x + y * y + z * z + w * w);
                if (fLength !== 0.) {
                    var fInvLength = 1. / fLength;
                    x *= fInvLength;
                    y *= fInvLength;
                    z *= fInvLength;
                    w *= fInvLength;
                }
                v4fDestination.x = x;
                v4fDestination.y = y;
                v4fDestination.z = z;
                v4fDestination.w = w;
                return v4fDestination;
            };
            Vec4.prototype.mix = function (v4fVec, fA, v4fDestination) {
                if (!((v4fDestination) !== undefined)) {
                    v4fDestination = this;
                }
                fA = (/*checked (origin: math)>>*/akra.math.max((0.), /*checked (origin: math)>>*/akra.math.min((fA), (1.))));
                var fA1 = 1. - fA;
                var fA2 = fA;
                v4fDestination.x = fA1 * this.x + fA2 * v4fVec.x;
                v4fDestination.y = fA1 * this.y + fA2 * v4fVec.y;
                v4fDestination.z = fA1 * this.z + fA2 * v4fVec.z;
                v4fDestination.w = fA1 * this.w + fA2 * v4fVec.w;
                return v4fDestination;
            };
            Vec4.prototype.toString = /** @inline */function () {
                return "[x: " + this.x + ", y: " + this.y + ", z: " + this.z + ", w: " + this.w + "]";
            };
            Object.defineProperty(Vec4, "stackCeil", {
                get: function () {
                    Vec4.stackPosition = Vec4.stackPosition === Vec4.stackSize - 1 ? 0 : Vec4.stackPosition;
                    return Vec4.stack[Vec4.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            Vec4.stackSize = 100;
            Vec4.stackPosition = 0;
            Vec4.stack = (function () {
                var pStack = new Array(Vec4.stackSize);
                for(var i = 0; i < Vec4.stackSize; i++) {
                    pStack[i] = new Vec4();
                }
                return pStack;
            })();
            return Vec4;
        })();
        math.Vec4 = Vec4;        
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
;
;
var akra;
(function (akra) {
    (function (math) {
        var Mat3 = (function () {
            function Mat3(fValue1, fValue2, fValue3, fValue4, fValue5, fValue6, fValue7, fValue8, fValue9) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 3:
                        this.set(arguments[0], arguments[1], arguments[2]);
                        break;
                    case 9:
                        this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]);
                        break;
                    default:
                        break;
                }
            }
            Mat3.prototype.set = function (fValue1, fValue2, fValue3, fValue4, fValue5, fValue6, fValue7, fValue8, fValue9) {
                this.data = this.data || new Float32Array(9);
                var pData = this.data;
                //без аргументов инициализируется нулями
                var nArgumentsLength = arguments.length;
                if (nArgumentsLength == 0) {
                    pData[0] = pData[3] = pData[6] = 0;
                    pData[1] = pData[4] = pData[7] = 0;
                    pData[2] = pData[5] = pData[8] = 0;
                }
                if (nArgumentsLength == 1) {
                    if ((typeof (arguments[0]) === "number")) {
                        var nValue = arguments[0];
                        pData[0] = nValue;
                        pData[3] = 0;
                        pData[6] = 0;
                        pData[1] = 0;
                        pData[4] = nValue;
                        pData[7] = 0;
                        pData[2] = 0;
                        pData[5] = 0;
                        pData[8] = nValue;
                    } else if (((arguments[0].data) !== undefined)) {
                        var pElements = arguments[0].data;
                        if (pElements.length === 9) {
                            //Mat3
                            pData[0] = pElements[0];
                            pData[3] = pElements[3];
                            pData[6] = pElements[6];
                            pData[1] = pElements[1];
                            pData[4] = pElements[4];
                            pData[7] = pElements[7];
                            pData[2] = pElements[2];
                            pData[5] = pElements[5];
                            pData[8] = pElements[8];
                        } else {
                            //Mat4
                            pData[0] = pElements[0];
                            pData[3] = pElements[4];
                            pData[6] = pElements[8];
                            pData[1] = pElements[1];
                            pData[4] = pElements[5];
                            pData[7] = pElements[9];
                            pData[2] = pElements[2];
                            pData[5] = pElements[6];
                            pData[8] = pElements[10];
                        }
                    } else if (arguments[0] instanceof math.Vec3) {
                        var v3fVec = arguments[0];
                        //диагональ
                        pData[0] = v3fVec.x;
                        pData[3] = 0;
                        pData[6] = 0;
                        pData[1] = 0;
                        pData[4] = v3fVec.y;
                        pData[7] = 0;
                        pData[2] = 0;
                        pData[5] = 0;
                        pData[8] = v3fVec.z;
                    } else {
                        var pElements = arguments[0];
                        if (pElements.length == 3) {
                            //ложим диагональ
                            pData[0] = pElements[0];
                            pData[3] = 0;
                            pData[6] = 0;
                            pData[1] = 0;
                            pData[4] = pElements[1];
                            pData[7] = 0;
                            pData[2] = 0;
                            pData[5] = 0;
                            pData[8] = pElements[2];
                        } else {
                            pData[0] = pElements[0];
                            pData[3] = pElements[3];
                            pData[6] = pElements[6];
                            pData[1] = pElements[1];
                            pData[4] = pElements[4];
                            pData[7] = pElements[7];
                            pData[2] = pElements[2];
                            pData[5] = pElements[5];
                            pData[8] = pElements[8];
                        }
                    }
                } else if (nArgumentsLength == 3) {
                    if ((typeof (arguments[0]) === "number")) {
                        //выставляем диагональ
                        pData[0] = arguments[0];
                        pData[3] = 0;
                        pData[6] = 0;
                        pData[1] = 0;
                        pData[4] = arguments[1];
                        pData[7] = 0;
                        pData[2] = 0;
                        pData[5] = 0;
                        pData[8] = arguments[2];
                    } else {
                        var pData1, pData2, pData3;
                        if (arguments[0] instanceof math.Vec3) {
                            var v3fVec1 = arguments[0];
                            var v3fVec2 = arguments[1];
                            var v3fVec3 = arguments[2];
                            //ложим по столбцам
                            pData[0] = v3fVec1.x;
                            pData[3] = v3fVec2.x;
                            pData[6] = v3fVec3.x;
                            pData[1] = v3fVec1.y;
                            pData[4] = v3fVec2.y;
                            pData[7] = v3fVec3.y;
                            pData[2] = v3fVec1.z;
                            pData[5] = v3fVec2.z;
                            pData[8] = v3fVec3.z;
                        } else {
                            var v3fVec1 = arguments[0];
                            var v3fVec2 = arguments[1];
                            var v3fVec3 = arguments[2];
                            //ложим по столбцам
                            pData[0] = v3fVec1[0];
                            pData[3] = v3fVec2[0];
                            pData[6] = v3fVec3[0];
                            pData[1] = v3fVec1[1];
                            pData[4] = v3fVec2[1];
                            pData[7] = v3fVec3[1];
                            pData[2] = v3fVec1[2];
                            pData[5] = v3fVec2[2];
                            pData[8] = v3fVec3[2];
                        }
                    }
                } else if (nArgumentsLength == 9) {
                    //просто числа
                    pData[0] = arguments[0];
                    pData[3] = arguments[3];
                    pData[6] = arguments[6];
                    pData[1] = arguments[1];
                    pData[4] = arguments[4];
                    pData[7] = arguments[7];
                    pData[2] = arguments[2];
                    pData[5] = arguments[5];
                    pData[8] = arguments[8];
                }
                return this;
            };
            Mat3.prototype.identity = function () {
                var pData = this.data;
                pData[0] = 1.;
                pData[3] = 0.;
                pData[6] = 0.;
                pData[1] = 0.;
                pData[4] = 1.;
                pData[7] = 0.;
                pData[2] = 0.;
                pData[5] = 0.;
                pData[8] = 1.;
                return this;
            };
            Mat3.prototype.add = function (m3fMat, m3fDestination) {
                if (!((m3fDestination) !== undefined)) {
                    m3fDestination = this;
                }
                var pData1 = this.data;
                var pData2 = m3fMat.data;
                var pDataDestination = m3fDestination.data;
                pDataDestination[0] = pData1[0] + pData2[0];
                pDataDestination[3] = pData1[3] + pData2[3];
                pDataDestination[6] = pData1[6] + pData2[6];
                pDataDestination[1] = pData1[1] + pData2[1];
                pDataDestination[4] = pData1[4] + pData2[4];
                pDataDestination[7] = pData1[7] + pData2[7];
                pDataDestination[2] = pData1[2] + pData2[2];
                pDataDestination[5] = pData1[5] + pData2[5];
                pDataDestination[8] = pData1[8] + pData2[8];
                return m3fDestination;
            };
            Mat3.prototype.subtract = function (m3fMat, m3fDestination) {
                if (!((m3fDestination) !== undefined)) {
                    m3fDestination = this;
                }
                var pData1 = this.data;
                var pData2 = m3fMat.data;
                var pDataDestination = m3fDestination.data;
                pDataDestination[0] = pData1[0] - pData2[0];
                pDataDestination[3] = pData1[3] - pData2[3];
                pDataDestination[6] = pData1[6] - pData2[6];
                pDataDestination[1] = pData1[1] - pData2[1];
                pDataDestination[4] = pData1[4] - pData2[4];
                pDataDestination[7] = pData1[7] - pData2[7];
                pDataDestination[2] = pData1[2] - pData2[2];
                pDataDestination[5] = pData1[5] - pData2[5];
                pDataDestination[8] = pData1[8] - pData2[8];
                return m3fDestination;
            };
            Mat3.prototype.multiply = function (m3fMat, m3fDestination) {
                var pData1 = this.data;
                var pData2 = m3fMat.data;
                if (!((m3fDestination) !== undefined)) {
                    m3fDestination = this;
                }
                var pDataDestination = m3fDestination.data;
                // Cache the matrix values (makes for huge speed increases!)
                                var a11 = pData1[0], a12 = pData1[3], a13 = pData1[6];
                var a21 = pData1[1], a22 = pData1[4], a23 = pData1[7];
                var a31 = pData1[2], a32 = pData1[5], a33 = pData1[8];
                var b11 = pData2[0], b12 = pData2[3], b13 = pData2[6];
                var b21 = pData2[1], b22 = pData2[4], b23 = pData2[7];
                var b31 = pData2[2], b32 = pData2[5], b33 = pData2[8];
                pDataDestination[0] = a11 * b11 + a12 * b21 + a13 * b31;
                pDataDestination[3] = a11 * b12 + a12 * b22 + a13 * b32;
                pDataDestination[6] = a11 * b13 + a12 * b23 + a13 * b33;
                pDataDestination[1] = a21 * b11 + a22 * b21 + a23 * b31;
                pDataDestination[4] = a21 * b12 + a22 * b22 + a23 * b32;
                pDataDestination[7] = a21 * b13 + a22 * b23 + a23 * b33;
                pDataDestination[2] = a31 * b11 + a32 * b21 + a33 * b31;
                pDataDestination[5] = a31 * b12 + a32 * b22 + a33 * b32;
                pDataDestination[8] = a31 * b13 + a32 * b23 + a33 * b33;
                return m3fDestination;
            };
            Mat3.prototype.multiplyVec3 = function (v3fVec, v3fDestination) {
                var pData = this.data;
                if (!((v3fDestination) !== undefined)) {
                    v3fDestination = v3fVec;
                }
                var x = v3fVec.x, y = v3fVec.y, z = v3fVec.z;
                v3fDestination.x = pData[0] * x + pData[3] * y + pData[6] * z;
                v3fDestination.y = pData[1] * x + pData[4] * y + pData[7] * z;
                v3fDestination.z = pData[2] * x + pData[5] * y + pData[8] * z;
                return v3fDestination;
            };
            Mat3.prototype.transpose = function (m3fDestination) {
                var pData = this.data;
                if (!((m3fDestination) !== undefined)) {
                    //быстрее будет явно обработать оба случая
                                        var a12 = pData[3], a13 = pData[6], a23 = pData[7];
                    pData[3] = pData[1];
                    pData[6] = pData[2];
                    pData[1] = a12;
                    pData[7] = pData[5];
                    pData[2] = a13;
                    pData[5] = a23;
                    return this;
                }
                var pDataDestination = m3fDestination.data;
                pDataDestination[0] = pData[0];
                pDataDestination[3] = pData[1];
                pDataDestination[6] = pData[2];
                pDataDestination[1] = pData[3];
                pDataDestination[4] = pData[4];
                pDataDestination[7] = pData[5];
                pDataDestination[2] = pData[6];
                pDataDestination[5] = pData[7];
                pDataDestination[8] = pData[8];
                return m3fDestination;
            };
            Mat3.prototype.determinant = function () {
                var pData = this.data;
                var a11 = pData[0], a12 = pData[3], a13 = pData[6];
                var a21 = pData[1], a22 = pData[4], a23 = pData[7];
                var a31 = pData[2], a32 = pData[5], a33 = pData[8];
                return a11 * (a22 * a33 - a23 * a32) - a12 * (a21 * a33 - a23 * a31) + a13 * (a21 * a32 - a22 * a31);
            };
            Mat3.prototype.inverse = function (m3fDestination) {
                if (!((m3fDestination) !== undefined)) {
                    m3fDestination = this;
                }
                var pData = this.data;
                var pDataDestination = m3fDestination.data;
                var a11 = pData[0], a12 = pData[3], a13 = pData[6];
                var a21 = pData[1], a22 = pData[4], a23 = pData[7];
                var a31 = pData[2], a32 = pData[5], a33 = pData[8];
                var A11 = a22 * a33 - a23 * a32;
                var A12 = a21 * a33 - a23 * a31;
                var A13 = a21 * a32 - a22 * a31;
                var A21 = a12 * a33 - a13 * a32;
                var A22 = a11 * a33 - a13 * a31;
                var A23 = a11 * a32 - a12 * a31;
                var A31 = a12 * a23 - a13 * a22;
                var A32 = a11 * a23 - a13 * a21;
                var A33 = a11 * a22 - a12 * a21;
                var fDeterminant = a11 * A11 - a12 * A12 + a13 * A13;
                if (fDeterminant == 0.) {
 {
                        akra.logger.setSourceLocation("Mat3.ts", 445);
                        akra.logger.error("обращение матрицы с нулевым детеминантом:\n", this.toString());
                    }
                    ;
                    return m3fDestination.set(1.);
                    //чтоб все не навернулось
                                    }
                var fInverseDeterminant = 1. / fDeterminant;
                pDataDestination[0] = A11 * fInverseDeterminant;
                pDataDestination[3] = -A21 * fInverseDeterminant;
                pDataDestination[6] = A31 * fInverseDeterminant;
                pDataDestination[1] = -A12 * fInverseDeterminant;
                pDataDestination[4] = A22 * fInverseDeterminant;
                pDataDestination[7] = -A32 * fInverseDeterminant;
                pDataDestination[2] = A13 * fInverseDeterminant;
                pDataDestination[5] = -A23 * fInverseDeterminant;
                pDataDestination[8] = A33 * fInverseDeterminant;
                return m3fDestination;
            };
            Mat3.prototype.isEqual = function (m3fMat, fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                var pData1 = this.data;
                var pData2 = m3fMat.data;
                if (fEps == 0) {
                    if (pData1[0] != pData2[0] || pData1[3] != pData2[3] || pData1[6] != pData2[6] || pData1[1] != pData2[1] || pData1[4] != pData2[4] || pData1[7] != pData2[7] || pData1[2] != pData2[2] || pData1[5] != pData2[5] || pData1[8] != pData2[8]) {
                        return false;
                    }
                } else {
                    if (Math.abs(pData1[0] - pData2[0]) > fEps || Math.abs(pData1[3] - pData2[3]) > fEps || Math.abs(pData1[6] - pData2[6]) > fEps || Math.abs(pData1[1] - pData2[1]) > fEps || Math.abs(pData1[4] - pData2[4]) > fEps || Math.abs(pData1[7] - pData2[7]) > fEps || Math.abs(pData1[2] - pData2[2]) > fEps || Math.abs(pData1[5] - pData2[5]) > fEps || Math.abs(pData1[8] - pData2[8]) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Mat3.prototype.isDiagonal = function (fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                var pData = this.data;
                if (fEps == 0) {
                    if (pData[3] != 0 || pData[6] != 0 || pData[1] != 0 || pData[7] != 0 || pData[2] != 0 || pData[5] != 0) {
                        return false;
                    }
                } else {
                    if (Math.abs(pData[3]) > fEps || Math.abs(pData[6]) > fEps || Math.abs(pData[1]) > fEps || Math.abs(pData[7]) > fEps || Math.abs(pData[2]) > fEps || Math.abs(pData[5]) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Mat3.prototype.toMat4 = function (m4fDestination) {
                if (!((m4fDestination) !== undefined)) {
                    m4fDestination = new math.Mat4();
                }
                var pData = this.data;
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = pData[0];
                pDataDestination[4] = pData[3];
                pDataDestination[8] = pData[6];
                pDataDestination[12] = 0;
                pDataDestination[1] = pData[1];
                pDataDestination[5] = pData[4];
                pDataDestination[9] = pData[7];
                pDataDestination[13] = 0;
                pDataDestination[2] = pData[2];
                pDataDestination[6] = pData[5];
                pDataDestination[10] = pData[8];
                pDataDestination[14] = 0;
                pDataDestination[3] = 0;
                pDataDestination[7] = 0;
                pDataDestination[11] = 0;
                pDataDestination[15] = 1;
                return m4fDestination;
            };
            Mat3.prototype.toQuat4 = function (q4fDestination) {
                if (!((q4fDestination) !== undefined)) {
                    q4fDestination = new math.Quat4();
                }
                var pData = this.data;
                var a11 = pData[0], a12 = pData[3], a13 = pData[6];
                var a21 = pData[1], a22 = pData[4], a23 = pData[7];
                var a31 = pData[2], a32 = pData[5], a33 = pData[8];
                /*x^2*/
                var x2 = ((a11 - a22 - a33) + 1) / 4;
                /*y^2*/
                var y2 = ((a22 - a11 - a33) + 1) / 4;
                /*z^2*/
                var z2 = ((a33 - a11 - a22) + 1) / 4;
                /*w^2*/
                var w2 = ((a11 + a22 + a33) + 1) / 4;
                var fMax = Math.max(x2, Math.max(y2, Math.max(z2, w2)));
                if (fMax == x2) {
                    //максимальная компонента берется положительной
                    var x = Math.sqrt(x2);
                    q4fDestination.x = x;
                    q4fDestination.y = (a21 + a12) / 4 / x;
                    q4fDestination.z = (a31 + a13) / 4 / x;
                    q4fDestination.w = (a32 - a23) / 4 / x;
                } else if (fMax == y2) {
                    //максимальная компонента берется положительной
                    var y = Math.sqrt(y2);
                    q4fDestination.x = (a21 + a12) / 4 / y;
                    q4fDestination.y = y;
                    q4fDestination.z = (a32 + a23) / 4 / y;
                    q4fDestination.w = (a13 - a31) / 4 / y;
                } else if (fMax == z2) {
                    //максимальная компонента берется положительной
                    var z = Math.sqrt(z2);
                    q4fDestination.x = (a31 + a13) / 4 / z;
                    q4fDestination.y = (a32 + a23) / 4 / z;
                    q4fDestination.z = z;
                    q4fDestination.w = (a21 - a12) / 4 / z;
                } else {
                    //максимальная компонента берется положительной
                    var w = Math.sqrt(w2);
                    q4fDestination.x = (a32 - a23) / 4 / w;
                    q4fDestination.y = (a13 - a31) / 4 / w;
                    q4fDestination.z = (a21 - a12) / 4 / w;
                    q4fDestination.w = w;
                }
                return q4fDestination;
            };
            Mat3.prototype.toString = function () {
                var pData = this.data;
                return '[' + pData[0] + ', ' + pData[3] + ', ' + pData[6] + ',\n' + +pData[1] + ', ' + pData[4] + ', ' + pData[7] + ',\n' + +pData[2] + ', ' + pData[5] + ', ' + pData[8] + ']';
            };
            Mat3.prototype.decompose = function (q4fRotation, v3fScale) {
                //изначально предполагаем, что порядок умножения был rot * scale
                var m3fRotScale = this;
                var m3fRotScaleTransposed = this.transpose(Mat3.stackCeil.set());
                var isRotScale = true;
                //понадобятся если порядок умножения был другим
                                var m3fScaleRot = null, m3fScaleRotTransposed = null;
                //было отражение или нет
                var scaleSign = (m3fRotScale.determinant() >= 0.) ? 1 : -1;
                var m3fResult = Mat3.stackCeil.set();
                //first variant rot * scale
                // (rot * scale)T * (rot * scale) =
                // scaleT * rotT * rot * scale = scaleT *rot^-1 * rot * scale =
                // scaleT * scale
                m3fRotScaleTransposed.multiply(m3fRotScale, m3fResult);
                if (!m3fResult.isDiagonal(1e-4)) {
                    //предположение было неверным
                    isRotScale = false;
                    //просто переобозначения чтобы не было путаницы
                    m3fScaleRot = m3fRotScale;
                    m3fScaleRotTransposed = m3fRotScaleTransposed;
                    //second variant scale * rot
                    // (scale * rot) * (scale * rot)T =
                    // scale * rot * rotT * scaleT = scale *rot * rot^-1 * scaleT =
                    // scale * scaleT
                    m3fScaleRot.multiply(m3fScaleRotTransposed, m3fResult);
                }
                var pResultData = m3fResult.data;
                var x = math.sqrt(pResultData[0]);
                /*если было отражение, считается что оно было по y*/
                var y = math.sqrt(pResultData[4]) * scaleSign;
                var z = math.sqrt(pResultData[8]);
                v3fScale.x = x;
                v3fScale.y = y;
                v3fScale.z = z;
                var m3fInverseScale = Mat3.stackCeil.set(1. / x, 1. / y, 1. / z);
                if (isRotScale) {
                    m3fRotScale.multiply(m3fInverseScale, Mat3.stackCeil.set()).toQuat4(q4fRotation);
                    return true;
                } else {
                    m3fInverseScale.multiply(m3fScaleRot, Mat3.stackCeil.set()).toQuat4(q4fRotation);
 {
                        akra.logger.setSourceLocation("Mat3.ts", 674);
                        akra.logger.assert(false, "порядок умножения scale rot в данный момент не поддерживается");
                    }
                    ;
                    return false;
                }
            };
            Mat3.prototype.row = function (iRow, v3fDestination) {
                if (!((v3fDestination) !== undefined)) {
                    v3fDestination = new math.Vec3();
                }
                var pData = this.data;
                switch(iRow) {
                    case 1:
                        v3fDestination.x = pData[0];
                        v3fDestination.y = pData[3];
                        v3fDestination.z = pData[6];
                        break;
                    case 2:
                        v3fDestination.x = pData[1];
                        v3fDestination.y = pData[4];
                        v3fDestination.z = pData[7];
                        break;
                    case 3:
                        v3fDestination.x = pData[2];
                        v3fDestination.y = pData[5];
                        v3fDestination.z = pData[8];
                        break;
                }
                return v3fDestination;
            };
            Mat3.prototype.column = function (iColumn, v3fDestination) {
                if (!((v3fDestination) !== undefined)) {
                    v3fDestination = new math.Vec3();
                }
                var pData = this.data;
                switch(iColumn) {
                    case 1:
                        v3fDestination.x = pData[0];
                        v3fDestination.y = pData[1];
                        v3fDestination.z = pData[2];
                        break;
                    case 2:
                        v3fDestination.x = pData[3];
                        v3fDestination.y = pData[4];
                        v3fDestination.z = pData[5];
                        break;
                    case 3:
                        v3fDestination.x = pData[6];
                        v3fDestination.y = pData[7];
                        v3fDestination.z = pData[8];
                        break;
                }
                return v3fDestination;
            };
            Mat3.fromYawPitchRoll = function fromYawPitchRoll(fYaw, fPitch, fRoll, m3fDestination) {
                if (arguments.length <= 2) {
                    //Vec3 + m3fDestination
                    var v3fVec = arguments[0];
                    fYaw = v3fVec.x;
                    fPitch = v3fVec.y;
                    fRoll = v3fVec.z;
                    m3fDestination = arguments[1];
                }
                if (!((m3fDestination) !== undefined)) {
                    m3fDestination = new Mat3();
                }
                var pDataDestination = m3fDestination.data;
                var fSin1 = Math.sin(fYaw);
                var fSin2 = Math.sin(fPitch);
                var fSin3 = Math.sin(fRoll);
                var fCos1 = Math.cos(fYaw);
                var fCos2 = Math.cos(fPitch);
                var fCos3 = Math.cos(fRoll);
                pDataDestination[0] = fCos1 * fCos3 + fSin1 * fSin2 * fSin3;
                pDataDestination[3] = fCos3 * fSin1 * fSin2 - fCos1 * fSin3;
                pDataDestination[6] = fCos2 * fSin1;
                pDataDestination[1] = fCos2 * fSin3;
                pDataDestination[4] = fCos2 * fCos3;
                pDataDestination[7] = -fSin2;
                pDataDestination[2] = fCos1 * fSin2 * fSin3 - fCos3 * fSin1;
                pDataDestination[5] = fSin1 * fSin3 + fCos1 * fCos3 * fSin2;
                pDataDestination[8] = fCos1 * fCos2;
                return m3fDestination;
            };
            Mat3.fromXYZ = function fromXYZ(fX, fY, fZ, m3fDestination) {
                if (arguments.length <= 2) {
                    //Vec3 + m3fDestination
                    var v3fVec = arguments[0];
                    return Mat3.fromYawPitchRoll(v3fVec.y, v3fVec.x, v3fVec.z, arguments[1]);
                } else {
                    //fX fY fZ m3fDestination
                    var fX = arguments[0];
                    var fY = arguments[1];
                    var fZ = arguments[2];
                    return Mat3.fromYawPitchRoll(fY, fX, fZ, arguments[3]);
                }
            };
            Object.defineProperty(Mat3, "stackCeil", {
                get: function () {
                    Mat3.stackPosition = Mat3.stackPosition === Mat3.stackSize - 1 ? 0 : Mat3.stackPosition;
                    return Mat3.stack[Mat3.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            Mat3.stackSize = 100;
            Mat3.stackPosition = 0;
            Mat3.stack = (function () {
                var pStack = new Array(Mat3.stackSize);
                for(var i = 0; i < Mat3.stackSize; i++) {
                    pStack[i] = new Mat3();
                }
                return pStack;
            })();
            return Mat3;
        })();
        math.Mat3 = Mat3;        
        ;
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
;
;
var akra;
(function (akra) {
    (function (math) {
        var Mat4 = (function () {
            function Mat4(fValue1, fValue2, fValue3, fValue4, fValue5, fValue6, fValue7, fValue8, fValue9, fValue10, fValue11, fValue12, fValue13, fValue14, fValue15, fValue16) {
                var nArgumentsLength = arguments.length;
                if (nArgumentsLength === 2) {
                    if ((typeof (arguments[1]) === "boolean")) {
                        if (arguments[1]) {
                            this.data = arguments[0];
                        } else {
                            this.data = new Float32Array(16);
                            this.set(arguments[0]);
                        }
                    } else {
                        this.data = new Float32Array(16);
                        this.set(arguments[0], arguments[1]);
                    }
                } else {
                    this.data = new Float32Array(16);
                    switch(nArgumentsLength) {
                        case 1:
                            if (arguments[0] instanceof math.Mat3) {
                                this.set(arguments[0], math.Vec3.stackCeil.set(0.));
                            } else {
                                this.set(arguments[0]);
                            }
                            break;
                        case 4:
                            this.set(arguments[0], arguments[1], arguments[2], arguments[3]);
                            break;
                        case 16:
                            this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8], arguments[9], arguments[10], arguments[11], arguments[12], arguments[13], arguments[14], arguments[15]);
                            break;
                        default:
                            break;
                    }
                }
            }
            Mat4.prototype.set = function () {
                var nArgumentsLength = arguments.length;
                var pData = this.data;
                if (nArgumentsLength === 0) {
                    pData[0] = pData[4] = pData[8] = pData[12] = pData[1] = pData[5] = pData[9] = pData[13] = pData[2] = pData[6] = pData[10] = pData[14] = pData[3] = pData[7] = pData[11] = pData[15] = 0.;
                    return this;
                }
                if (nArgumentsLength === 1) {
                    if ((typeof (arguments[0]) === "number")) {
                        var fValue = arguments[0];
                        pData[0] = fValue;
                        pData[4] = 0.;
                        pData[8] = 0.;
                        pData[12] = 0.;
                        pData[1] = 0.;
                        pData[5] = fValue;
                        pData[9] = 0.;
                        pData[13] = 0.;
                        pData[2] = 0.;
                        pData[6] = 0.;
                        pData[10] = fValue;
                        pData[14] = 0.;
                        pData[3] = 0.;
                        pData[7] = 0.;
                        pData[11] = 0.;
                        pData[15] = fValue;
                    } else if (arguments[0] instanceof math.Vec4) {
                        var v4fVec = arguments[0];
                        pData[0] = v4fVec.x;
                        pData[4] = 0.;
                        pData[8] = 0.;
                        pData[12] = 0.;
                        pData[1] = 0.;
                        pData[5] = v4fVec.y;
                        pData[9] = 0.;
                        pData[13] = 0.;
                        pData[2] = 0.;
                        pData[6] = 0.;
                        pData[10] = v4fVec.z;
                        pData[14] = 0.;
                        pData[3] = 0.;
                        pData[7] = 0.;
                        pData[11] = 0.;
                        pData[15] = v4fVec.w;
                    } else if (((arguments[0].data) !== undefined)) {
                        var pMatrixData = arguments[0].data;
                        if (pMatrixData.length == 16) {
                            //Mat4
                            pData.set(pMatrixData);
                        } else {
                            //Mat3
                            pData[0] = pMatrixData[0];
                            pData[4] = pMatrixData[3];
                            pData[8] = pMatrixData[6];
                            pData[1] = pMatrixData[1];
                            pData[5] = pMatrixData[4];
                            pData[9] = pMatrixData[7];
                            pData[2] = pMatrixData[2];
                            pData[6] = pMatrixData[5];
                            pData[10] = pMatrixData[8];
                            pData[3] = 0.;
                            pData[7] = 0.;
                            pData[11] = 0.;
                            pData[15] = 1.;
                        }
                    } else {
                        //array
                        var pArray = arguments[0];
                        if (pArray.length === 4) {
                            pData[0] = pArray[0];
                            pData[4] = 0.;
                            pData[8] = 0.;
                            pData[12] = 0.;
                            pData[1] = 0.;
                            pData[5] = pArray[1];
                            pData[9] = 0.;
                            pData[13] = 0.;
                            pData[2] = 0.;
                            pData[6] = 0.;
                            pData[10] = pArray[2];
                            pData[14] = 0.;
                            pData[3] = 0.;
                            pData[7] = 0.;
                            pData[11] = 0.;
                            pData[15] = pArray[3];
                        } else {
                            //length == 16
                            pData[0] = pArray[0];
                            pData[4] = pArray[4];
                            pData[8] = pArray[8];
                            pData[12] = pArray[12];
                            pData[1] = pArray[1];
                            pData[5] = pArray[5];
                            pData[9] = pArray[9];
                            pData[13] = pArray[13];
                            pData[2] = pArray[2];
                            pData[6] = pArray[6];
                            pData[10] = pArray[10];
                            pData[14] = pArray[14];
                            pData[3] = pArray[3];
                            pData[7] = pArray[7];
                            pData[11] = pArray[11];
                            pData[15] = pArray[15];
                        }
                    }
                } else if (nArgumentsLength == 2) {
                    var pMatrixData = arguments[0];
                    var v3fTranslation = arguments[1];
                    pData[0] = pMatrixData[0];
                    pData[4] = pMatrixData[3];
                    pData[8] = pMatrixData[6];
                    pData[12] = v3fTranslation.x;
                    pData[1] = pMatrixData[1];
                    pData[5] = pMatrixData[4];
                    pData[9] = pMatrixData[7];
                    pData[13] = v3fTranslation.y;
                    pData[2] = pMatrixData[2];
                    pData[6] = pMatrixData[5];
                    pData[10] = pMatrixData[8];
                    pData[14] = v3fTranslation.z;
                    pData[3] = 0.;
                    pData[7] = 0.;
                    pData[11] = 0.;
                    pData[15] = 1.;
                } else if (nArgumentsLength == 4) {
                    if ((typeof (arguments[0]) === "number")) {
                        pData[0] = arguments[0];
                        pData[4] = 0;
                        pData[8] = 0;
                        pData[12] = 0;
                        pData[1] = 0;
                        pData[5] = arguments[1];
                        pData[9] = 0;
                        pData[13] = 0;
                        pData[2] = 0;
                        pData[6] = 0;
                        pData[10] = arguments[2];
                        pData[14] = 0;
                        pData[3] = 0;
                        pData[7] = 0;
                        pData[11] = 0;
                        pData[15] = arguments[3];
                    } else if (arguments[0] instanceof math.Vec4) {
                        var v4fColumn1 = arguments[0];
                        var v4fColumn2 = arguments[1];
                        var v4fColumn3 = arguments[2];
                        var v4fColumn4 = arguments[3];
                        pData[0] = v4fColumn1.x;
                        pData[4] = v4fColumn2.x;
                        pData[8] = v4fColumn3.x;
                        pData[12] = v4fColumn4.x;
                        pData[1] = v4fColumn1.y;
                        pData[5] = v4fColumn2.y;
                        pData[9] = v4fColumn3.y;
                        pData[13] = v4fColumn4.y;
                        pData[2] = v4fColumn1.z;
                        pData[6] = v4fColumn2.z;
                        pData[10] = v4fColumn3.z;
                        pData[14] = v4fColumn4.z;
                        pData[3] = v4fColumn1.w;
                        pData[7] = v4fColumn2.w;
                        pData[11] = v4fColumn3.w;
                        pData[15] = v4fColumn4.w;
                    } else {
                        //arrays
                        var v4fColumn1 = arguments[0];
                        var v4fColumn2 = arguments[1];
                        var v4fColumn3 = arguments[2];
                        var v4fColumn4 = arguments[3];
                        pData[0] = v4fColumn1[0];
                        pData[4] = v4fColumn2[0];
                        pData[8] = v4fColumn3[0];
                        pData[12] = v4fColumn4[0];
                        pData[1] = v4fColumn1[1];
                        pData[5] = v4fColumn2[1];
                        pData[9] = v4fColumn3[1];
                        pData[13] = v4fColumn4[1];
                        pData[2] = v4fColumn1[2];
                        pData[6] = v4fColumn2[2];
                        pData[10] = v4fColumn3[2];
                        pData[14] = v4fColumn4[2];
                        pData[3] = v4fColumn1[3];
                        pData[7] = v4fColumn2[3];
                        pData[11] = v4fColumn3[3];
                        pData[15] = v4fColumn4[3];
                    }
                } else {
                    //nArgumentsLength === 16
                    pData[0] = arguments[0];
                    pData[4] = arguments[4];
                    pData[8] = arguments[8];
                    pData[12] = arguments[12];
                    pData[1] = arguments[1];
                    pData[5] = arguments[5];
                    pData[9] = arguments[9];
                    pData[13] = arguments[13];
                    pData[2] = arguments[2];
                    pData[6] = arguments[6];
                    pData[10] = arguments[10];
                    pData[14] = arguments[14];
                    pData[3] = arguments[3];
                    pData[7] = arguments[7];
                    pData[11] = arguments[11];
                    pData[15] = arguments[15];
                }
                return this;
            };
            Mat4.prototype.identity = function () {
                var pData = this.data;
                pData[0] = 1.;
                pData[4] = 0.;
                pData[8] = 0.;
                pData[12] = 0.;
                pData[1] = 0.;
                pData[5] = 1.;
                pData[9] = 0.;
                pData[13] = 0.;
                pData[2] = 0.;
                pData[6] = 0.;
                pData[10] = 1.;
                pData[14] = 0.;
                pData[3] = 0.;
                pData[7] = 0.;
                pData[11] = 0.;
                pData[15] = 1.;
                return this;
            };
            Mat4.prototype.add = function (m4fMat, m4fDestination) {
                if (!((m4fDestination) !== undefined)) {
                    m4fDestination = this;
                }
                var pData1 = this.data;
                var pData2 = m4fMat.data;
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = pData1[0] + pData2[0];
                pDataDestination[4] = pData1[4] + pData2[4];
                pDataDestination[8] = pData1[8] + pData2[8];
                pDataDestination[12] = pData1[12] + pData2[12];
                pDataDestination[1] = pData1[1] + pData2[1];
                pDataDestination[5] = pData1[5] + pData2[5];
                pDataDestination[9] = pData1[9] + pData2[9];
                pDataDestination[13] = pData1[13] + pData2[13];
                pDataDestination[2] = pData1[2] + pData2[2];
                pDataDestination[6] = pData1[6] + pData2[6];
                pDataDestination[10] = pData1[10] + pData2[10];
                pDataDestination[14] = pData1[14] + pData2[14];
                pDataDestination[3] = pData1[3] + pData2[3];
                pDataDestination[7] = pData1[7] + pData2[7];
                pDataDestination[11] = pData1[11] + pData2[11];
                pDataDestination[15] = pData1[15] + pData2[15];
                return m4fDestination;
            };
            Mat4.prototype.subtract = function (m4fMat, m4fDestination) {
                if (!((m4fDestination) !== undefined)) {
                    m4fDestination = this;
                }
                var pData1 = this.data;
                var pData2 = m4fMat.data;
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = pData1[0] - pData2[0];
                pDataDestination[4] = pData1[4] - pData2[4];
                pDataDestination[8] = pData1[8] - pData2[8];
                pDataDestination[12] = pData1[12] - pData2[12];
                pDataDestination[1] = pData1[1] - pData2[1];
                pDataDestination[5] = pData1[5] - pData2[5];
                pDataDestination[9] = pData1[9] - pData2[9];
                pDataDestination[13] = pData1[13] - pData2[13];
                pDataDestination[2] = pData1[2] - pData2[2];
                pDataDestination[6] = pData1[6] - pData2[6];
                pDataDestination[10] = pData1[10] - pData2[10];
                pDataDestination[14] = pData1[14] - pData2[14];
                pDataDestination[3] = pData1[3] - pData2[3];
                pDataDestination[7] = pData1[7] - pData2[7];
                pDataDestination[11] = pData1[11] - pData2[11];
                pDataDestination[15] = pData1[15] - pData2[15];
                return m4fDestination;
            };
            Mat4.prototype.multiply = function (m4fMat, m4fDestination) {
                if (!((m4fDestination) !== undefined)) {
                    m4fDestination = this;
                }
                var pData1 = this.data;
                var pData2 = m4fMat.data;
                var pDataDestination = m4fDestination.data;
                //кешируем значения матриц для ускорения
                                var a11 = pData1[0], a12 = pData1[4], a13 = pData1[8], a14 = pData1[12];
                var a21 = pData1[1], a22 = pData1[5], a23 = pData1[9], a24 = pData1[13];
                var a31 = pData1[2], a32 = pData1[6], a33 = pData1[10], a34 = pData1[14];
                var a41 = pData1[3], a42 = pData1[7], a43 = pData1[11], a44 = pData1[15];
                var b11 = pData2[0], b12 = pData2[4], b13 = pData2[8], b14 = pData2[12];
                var b21 = pData2[1], b22 = pData2[5], b23 = pData2[9], b24 = pData2[13];
                var b31 = pData2[2], b32 = pData2[6], b33 = pData2[10], b34 = pData2[14];
                var b41 = pData2[3], b42 = pData2[7], b43 = pData2[11], b44 = pData2[15];
                pDataDestination[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
                pDataDestination[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
                pDataDestination[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
                pDataDestination[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
                pDataDestination[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
                pDataDestination[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
                pDataDestination[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
                pDataDestination[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
                pDataDestination[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
                pDataDestination[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
                pDataDestination[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
                pDataDestination[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
                pDataDestination[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
                pDataDestination[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
                pDataDestination[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
                pDataDestination[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
                return m4fDestination;
            };
            Mat4.prototype.multiplyLeft = /** @inline */function (m4fMat, m4fDestination) {
                if (!((m4fDestination) !== undefined)) {
                    m4fDestination = this;
                }
                return m4fMat.multiply(this, m4fDestination);
            };
            Mat4.prototype.multiplyVec4 = function (v4fVec, v4fDestination) {
                if (!((v4fDestination) !== undefined)) {
                    v4fDestination = v4fVec;
                }
                var pData = this.data;
                var x = v4fVec.x, y = v4fVec.y, z = v4fVec.z, w = v4fVec.w;
                v4fDestination.x = pData[0] * x + pData[4] * y + pData[8] * z + pData[12] * w;
                v4fDestination.y = pData[1] * x + pData[5] * y + pData[9] * z + pData[13] * w;
                v4fDestination.z = pData[2] * x + pData[6] * y + pData[10] * z + pData[14] * w;
                v4fDestination.w = pData[3] * x + pData[7] * y + pData[11] * z + pData[15] * w;
                return v4fDestination;
            };
            Mat4.prototype.transpose = function (m4fDestination) {
                var pData = this.data;
                if (!((m4fDestination) !== undefined)) {
                    var a12 = pData[4], a13 = pData[8], a14 = pData[12];
                    var a23 = pData[9], a24 = pData[13];
                    var a34 = pData[14];
                    pData[4] = pData[1];
                    pData[8] = pData[2];
                    pData[12] = pData[3];
                    pData[1] = a12;
                    pData[9] = pData[6];
                    pData[13] = pData[7];
                    pData[2] = a13;
                    pData[6] = a23;
                    pData[14] = pData[11];
                    pData[3] = a14;
                    pData[7] = a24;
                    pData[11] = a34;
                    return this;
                }
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = pData[0];
                pDataDestination[4] = pData[1];
                pDataDestination[8] = pData[2];
                pDataDestination[12] = pData[3];
                pDataDestination[1] = pData[4];
                pDataDestination[5] = pData[5];
                pDataDestination[9] = pData[6];
                pDataDestination[13] = pData[7];
                pDataDestination[2] = pData[8];
                pDataDestination[6] = pData[9];
                pDataDestination[10] = pData[10];
                pDataDestination[14] = pData[11];
                pDataDestination[3] = pData[12];
                pDataDestination[7] = pData[13];
                pDataDestination[11] = pData[14];
                pDataDestination[15] = pData[15];
                return m4fDestination;
            };
            Mat4.prototype.determinant = function () {
                var pData = this.data;
                var a11 = pData[0], a12 = pData[4], a13 = pData[8], a14 = pData[12];
                var a21 = pData[1], a22 = pData[5], a23 = pData[9], a24 = pData[13];
                var a31 = pData[2], a32 = pData[6], a33 = pData[10], a34 = pData[14];
                var a41 = pData[3], a42 = pData[7], a43 = pData[11], a44 = pData[15];
                return a41 * a32 * a23 * a14 - a31 * a42 * a23 * a14 - a41 * a22 * a33 * a14 + a21 * a42 * a33 * a14 + a31 * a22 * a43 * a14 - a21 * a32 * a43 * a14 - a41 * a32 * a13 * a24 + a31 * a42 * a13 * a24 + a41 * a12 * a33 * a24 - a11 * a42 * a33 * a24 - a31 * a12 * a43 * a24 + a11 * a32 * a43 * a24 + a41 * a22 * a13 * a34 - a21 * a42 * a13 * a34 - a41 * a12 * a23 * a34 + a11 * a42 * a23 * a34 + a21 * a12 * a43 * a34 - a11 * a22 * a43 * a34 - a31 * a22 * a13 * a44 + a21 * a32 * a13 * a44 + a31 * a12 * a23 * a44 - a11 * a32 * a23 * a44 - a21 * a12 * a33 * a44 + a11 * a22 * a33 * a44;
            };
            Mat4.prototype.inverse = function (m4fDestination) {
                if (!((m4fDestination) !== undefined)) {
                    m4fDestination = this;
                }
                var pData = this.data;
                var pDataDestination = m4fDestination.data;
                // Cache the matrix values (makes for huge speed increases!)
                                var a11 = pData[0], a12 = pData[4], a13 = pData[8], a14 = pData[12];
                var a21 = pData[1], a22 = pData[5], a23 = pData[9], a24 = pData[13];
                var a31 = pData[2], a32 = pData[6], a33 = pData[10], a34 = pData[14];
                var a41 = pData[3], a42 = pData[7], a43 = pData[11], a44 = pData[15];
                var b00 = a11 * a22 - a12 * a21;
                var b01 = a11 * a23 - a13 * a21;
                var b02 = a11 * a24 - a14 * a21;
                var b03 = a12 * a23 - a13 * a22;
                var b04 = a12 * a24 - a14 * a22;
                var b05 = a13 * a24 - a14 * a23;
                var b06 = a31 * a42 - a32 * a41;
                var b07 = a31 * a43 - a33 * a41;
                var b08 = a31 * a44 - a34 * a41;
                var b09 = a32 * a43 - a33 * a42;
                var b10 = a32 * a44 - a34 * a42;
                var b11 = a33 * a44 - a34 * a43;
                var fDeterminant = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                if (fDeterminant === 0.) {
 {
                        akra.logger.setSourceLocation("Mat4.ts", 621);
                        akra.logger.assert(false, "обращение матрицы с нулевым детеминантом:\n" + this.toString());
                    }
                    ;
                    //чтоб все не навернулось
                    return m4fDestination.set(1.);
                }
                var fInverseDeterminant = 1 / fDeterminant;
                pDataDestination[0] = (a22 * b11 - a23 * b10 + a24 * b09) * fInverseDeterminant;
                pDataDestination[4] = (-a12 * b11 + a13 * b10 - a14 * b09) * fInverseDeterminant;
                pDataDestination[8] = (a42 * b05 - a43 * b04 + a44 * b03) * fInverseDeterminant;
                pDataDestination[12] = (-a32 * b05 + a33 * b04 - a34 * b03) * fInverseDeterminant;
                pDataDestination[1] = (-a21 * b11 + a23 * b08 - a24 * b07) * fInverseDeterminant;
                pDataDestination[5] = (a11 * b11 - a13 * b08 + a14 * b07) * fInverseDeterminant;
                pDataDestination[9] = (-a41 * b05 + a43 * b02 - a44 * b01) * fInverseDeterminant;
                pDataDestination[13] = (a31 * b05 - a33 * b02 + a34 * b01) * fInverseDeterminant;
                pDataDestination[2] = (a21 * b10 - a22 * b08 + a24 * b06) * fInverseDeterminant;
                pDataDestination[6] = (-a11 * b10 + a12 * b08 - a14 * b06) * fInverseDeterminant;
                pDataDestination[10] = (a41 * b04 - a42 * b02 + a44 * b00) * fInverseDeterminant;
                pDataDestination[14] = (-a31 * b04 + a32 * b02 - a34 * b00) * fInverseDeterminant;
                pDataDestination[3] = (-a21 * b09 + a22 * b07 - a23 * b06) * fInverseDeterminant;
                pDataDestination[7] = (a11 * b09 - a12 * b07 + a13 * b06) * fInverseDeterminant;
                pDataDestination[11] = (-a41 * b03 + a42 * b01 - a43 * b00) * fInverseDeterminant;
                pDataDestination[15] = (a31 * b03 - a32 * b01 + a33 * b00) * fInverseDeterminant;
                return m4fDestination;
            };
            Mat4.prototype.trace = /** @inline */function () {
                var pData = this.data;
                return pData[0] + pData[5] + pData[10] + pData[15];
            };
            Mat4.prototype.isEqual = function (m4fMat, fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                var pData1 = this.data;
                var pData2 = m4fMat.data;
                if (fEps === 0.) {
                    if (pData1[0] != pData2[0] || pData1[4] != pData2[4] || pData1[8] != pData2[8] || pData1[12] != pData2[12] || pData1[1] != pData2[1] || pData1[5] != pData2[5] || pData1[9] != pData2[9] || pData1[13] != pData2[13] || pData1[2] != pData2[2] || pData1[6] != pData2[6] || pData1[10] != pData2[10] || pData1[14] != pData2[14] || pData1[3] != pData2[3] || pData1[7] != pData2[7] || pData1[11] != pData2[11] || pData1[15] != pData2[15]) {
                        return false;
                    }
                } else {
                    if (math.abs(pData1[0] - pData2[0]) > fEps || math.abs(pData1[4] - pData2[4]) > fEps || math.abs(pData1[8] - pData2[8]) > fEps || math.abs(pData1[12] - pData2[12]) > fEps || math.abs(pData1[1] - pData2[1]) > fEps || math.abs(pData1[5] - pData2[5]) > fEps || math.abs(pData1[9] - pData2[9]) > fEps || math.abs(pData1[13] - pData2[13]) > fEps || math.abs(pData1[2] - pData2[2]) > fEps || math.abs(pData1[6] - pData2[6]) > fEps || math.abs(pData1[10] - pData2[10]) > fEps || math.abs(pData1[14] - pData2[14]) > fEps || math.abs(pData1[3] - pData2[3]) > fEps || math.abs(pData1[7] - pData2[7]) > fEps || math.abs(pData1[11] - pData2[11]) > fEps || math.abs(pData1[15] - pData2[15]) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Mat4.prototype.isDiagonal = function (fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                var pData = this.data;
                if (fEps === 0.) {
                    if (pData[4] !== 0. || pData[8] !== 0. || pData[12] != 0. || pData[1] !== 0. || pData[9] !== 0. || pData[13] != 0. || pData[2] !== 0. || pData[6] !== 0. || pData[14] != 0. || pData[3] !== 0. || pData[7] !== 0. || pData[11] != 0.) {
                        return false;
                    }
                } else {
                    if (math.abs(pData[4]) > fEps || math.abs(pData[8]) > fEps || math.abs(pData[12]) > fEps || math.abs(pData[1]) > fEps || math.abs(pData[9]) > fEps || math.abs(pData[13]) > fEps || math.abs(pData[2]) > fEps || math.abs(pData[6]) > fEps || math.abs(pData[14]) > fEps || math.abs(pData[3]) > fEps || math.abs(pData[7]) > fEps || math.abs(pData[11]) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Mat4.prototype.toMat3 = function (m3fDestination) {
                if (!((m3fDestination) !== undefined)) {
                    m3fDestination = new math.Mat3();
                }
                var pData = this.data;
                var pDataDestination = m3fDestination.data;
                pDataDestination[0] = pData[0];
                pDataDestination[3] = pData[4];
                pDataDestination[6] = pData[8];
                pDataDestination[1] = pData[1];
                pDataDestination[4] = pData[5];
                pDataDestination[7] = pData[9];
                pDataDestination[2] = pData[2];
                pDataDestination[5] = pData[6];
                pDataDestination[8] = pData[10];
                return m3fDestination;
            };
            Mat4.prototype.toQuat4 = function (q4fDestination) {
                if (!((q4fDestination) !== undefined)) {
                    q4fDestination = new math.Quat4();
                }
                var pData = this.data;
                var a11 = pData[0], a12 = pData[4], a13 = pData[8];
                var a21 = pData[1], a22 = pData[5], a23 = pData[9];
                var a31 = pData[2], a32 = pData[6], a33 = pData[10];
                /*x^2*/
                var x2 = ((a11 - a22 - a33) + 1.) / 4.;
                /*y^2*/
                var y2 = ((a22 - a11 - a33) + 1.) / 4.;
                /*z^2*/
                var z2 = ((a33 - a11 - a22) + 1.) / 4.;
                /*w^2*/
                var w2 = ((a11 + a22 + a33) + 1.) / 4.;
                var fMax = math.max(x2, math.max(y2, math.max(z2, w2)));
                if (fMax == x2) {
                    //максимальная компонента берется положительной
                    var x = math.sqrt(x2);
                    q4fDestination.x = x;
                    q4fDestination.y = (a21 + a12) / 4. / x;
                    q4fDestination.z = (a31 + a13) / 4. / x;
                    q4fDestination.w = (a32 - a23) / 4. / x;
                } else if (fMax == y2) {
                    //максимальная компонента берется положительной
                    var y = math.sqrt(y2);
                    q4fDestination.x = (a21 + a12) / 4. / y;
                    q4fDestination.y = y;
                    q4fDestination.z = (a32 + a23) / 4. / y;
                    q4fDestination.w = (a13 - a31) / 4. / y;
                } else if (fMax == z2) {
                    //максимальная компонента берется положительной
                    var z = math.sqrt(z2);
                    q4fDestination.x = (a31 + a13) / 4. / z;
                    q4fDestination.y = (a32 + a23) / 4. / z;
                    q4fDestination.z = z;
                    q4fDestination.w = (a21 - a12) / 4. / z;
                } else {
                    //максимальная компонента берется положительной
                    var w = math.sqrt(w2);
                    q4fDestination.x = (a32 - a23) / 4. / w;
                    q4fDestination.y = (a13 - a31) / 4. / w;
                    q4fDestination.z = (a21 - a12) / 4. / w;
                    q4fDestination.w = w;
                }
                return q4fDestination;
            };
            Mat4.prototype.toRotationMatrix = function (m4fDestination) {
                if (!((m4fDestination) !== undefined)) {
                    m4fDestination = new Mat4();
                }
                var pData = this.data;
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = pData[0];
                pDataDestination[4] = pData[4];
                pDataDestination[8] = pData[8];
                pDataDestination[12] = 0.;
                pDataDestination[1] = pData[1];
                pDataDestination[5] = pData[5];
                pDataDestination[9] = pData[9];
                pDataDestination[13] = 0.;
                pDataDestination[2] = pData[2];
                pDataDestination[6] = pData[6];
                pDataDestination[10] = pData[10];
                pDataDestination[14] = 0.;
                pDataDestination[3] = 0.;
                pDataDestination[7] = 0.;
                pDataDestination[11] = 0.;
                pDataDestination[15] = 1.;
                return m4fDestination;
            };
            Mat4.prototype.toString = function (iFixed) {
                if (typeof iFixed === "undefined") { iFixed = 2; }
                var pData = this.data;
                return '[' + pData[0].toFixed(iFixed) + ", " + pData[4].toFixed(iFixed) + ', ' + pData[8].toFixed(iFixed) + ', ' + pData[12].toFixed(iFixed) + ',\n' + pData[1].toFixed(iFixed) + ", " + pData[5].toFixed(iFixed) + ', ' + pData[9].toFixed(iFixed) + ', ' + pData[13].toFixed(iFixed) + ',\n' + pData[2].toFixed(iFixed) + ", " + pData[6].toFixed(iFixed) + ', ' + pData[10].toFixed(iFixed) + ', ' + pData[14].toFixed(iFixed) + ',\n' + pData[3].toFixed(iFixed) + ", " + pData[7].toFixed(iFixed) + ', ' + pData[11].toFixed(iFixed) + ', ' + pData[15].toFixed(iFixed) + ']';
            };
            Mat4.prototype.rotateRight = function (fAngle, v3fAxis, m4fDestination) {
                var pData = this.data;
                var x = v3fAxis.x, y = v3fAxis.y, z = v3fAxis.z;
                var fLength = Math.sqrt(x * x + y * y + z * z);
                if (fLength === 0.) {
 {
                        akra.logger.setSourceLocation("Mat4.ts", 857);
                        akra.logger.assert(false, "попытка вращения вокруг оси нулевой длины. Угол " + fAngle + ". Ось " + v3fAxis.toString());
                    }
                    ;
                    if (((m4fDestination) !== undefined)) {
                        m4fDestination.set(this);
                    } else {
                        m4fDestination = this;
                    }
                    return m4fDestination;
                }
                var fInvLength = 1. / fLength;
                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;
                var a11 = pData[0], a12 = pData[4], a13 = pData[8];
                var a21 = pData[1], a22 = pData[5], a23 = pData[9];
                var a31 = pData[2], a32 = pData[6], a33 = pData[10];
                var fSin = math.sin(fAngle);
                var fCos = math.cos(fAngle);
                var fTmp = 1. - fCos;
                //build Rotation matrix
                                var b11 = fCos + fTmp * x * x, b12 = fTmp * x * y - fSin * z, b13 = fTmp * x * z + fSin * y;
                var b21 = fTmp * y * z + fSin * z, b22 = fCos + fTmp * y * y, b23 = fTmp * y * z - fSin * x;
                var b31 = fTmp * z * x - fSin * y, b32 = fTmp * z * y + fSin * x, b33 = fCos + fTmp * z * z;
                if (!((m4fDestination) !== undefined)) {
                    pData[0] = a11 * b11 + a12 * b21 + a13 * b31;
                    pData[4] = a11 * b12 + a12 * b22 + a13 * b32;
                    pData[8] = a11 * b13 + a12 * b23 + a13 * b33;
                    pData[1] = a21 * b11 + a22 * b21 + a23 * b31;
                    pData[5] = a21 * b12 + a22 * b22 + a23 * b32;
                    pData[9] = a21 * b13 + a22 * b23 + a23 * b33;
                    pData[2] = a31 * b11 + a32 * b21 + a33 * b31;
                    pData[6] = a31 * b12 + a32 * b22 + a33 * b32;
                    pData[10] = a31 * b13 + a32 * b23 + a33 * b33;
                    return this;
                }
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = a11 * b11 + a12 * b21 + a13 * b31;
                pDataDestination[4] = a11 * b12 + a12 * b22 + a13 * b32;
                pDataDestination[8] = a11 * b13 + a12 * b23 + a13 * b33;
                pDataDestination[12] = pData[12];
                pDataDestination[1] = a21 * b11 + a22 * b21 + a23 * b31;
                pDataDestination[5] = a21 * b12 + a22 * b22 + a23 * b32;
                pDataDestination[9] = a21 * b13 + a22 * b23 + a23 * b33;
                pDataDestination[13] = pData[13];
                pDataDestination[2] = a31 * b11 + a32 * b21 + a33 * b31;
                pDataDestination[6] = a31 * b12 + a32 * b22 + a33 * b32;
                pDataDestination[10] = a31 * b13 + a32 * b23 + a33 * b33;
                pDataDestination[14] = pData[14];
                pDataDestination[3] = pData[3];
                pDataDestination[7] = pData[7];
                pDataDestination[11] = pData[11];
                pDataDestination[15] = pData[15];
                return m4fDestination;
            };
            Mat4.prototype.rotateLeft = function (fAngle, v3fAxis, m4fDestination) {
                var pData = this.data;
                var x = v3fAxis.x, y = v3fAxis.y, z = v3fAxis.z;
                var fLength = Math.sqrt(x * x + y * y + z * z);
                if (fLength === 0.) {
 {
                        akra.logger.setSourceLocation("Mat4.ts", 935);
                        akra.logger.assert(false, "попытка вращения вокруг оси нулевой длины. Угол " + fAngle + ". Ось " + v3fAxis.toString());
                    }
                    ;
                    if (((m4fDestination) !== undefined)) {
                        m4fDestination.set(this);
                    } else {
                        m4fDestination = this;
                    }
                    return m4fDestination;
                }
                var fInvLength = 1. / fLength;
                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;
                var a11 = pData[0], a12 = pData[4], a13 = pData[8], a14 = pData[12];
                var a21 = pData[1], a22 = pData[5], a23 = pData[9], a24 = pData[13];
                var a31 = pData[2], a32 = pData[6], a33 = pData[10], a34 = pData[14];
                var fSin = math.sin(fAngle);
                var fCos = math.cos(fAngle);
                var fTmp = 1. - fCos;
                //build Rotation matrix
                                var b11 = fCos + fTmp * x * x, b12 = fTmp * x * y - fSin * z, b13 = fTmp * x * z + fSin * y;
                var b21 = fTmp * y * z + fSin * z, b22 = fCos + fTmp * y * y, b23 = fTmp * y * z - fSin * x;
                var b31 = fTmp * z * x - fSin * y, b32 = fTmp * z * y + fSin * x, b33 = fCos + fTmp * z * z;
                if (!((m4fDestination) !== undefined)) {
                    pData[0] = b11 * a11 + b12 * a21 + b13 * a31;
                    pData[4] = b11 * a12 + b12 * a22 + b13 * a32;
                    pData[8] = b11 * a13 + b12 * a23 + b13 * a33;
                    pData[12] = b11 * a14 + b12 * a24 + b13 * a34;
                    pData[1] = b21 * a11 + b22 * a21 + b23 * a31;
                    pData[5] = b21 * a12 + b22 * a22 + b23 * a32;
                    pData[9] = b21 * a13 + b22 * a23 + b23 * a33;
                    pData[13] = b21 * a14 + b22 * a24 + b23 * a34;
                    pData[2] = b31 * a11 + b32 * a21 + b33 * a31;
                    pData[6] = b31 * a12 + b32 * a22 + b33 * a32;
                    pData[10] = b31 * a13 + b32 * a23 + b33 * a33;
                    pData[14] = b31 * a14 + b32 * a24 + b33 * a34;
                    return this;
                }
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = b11 * a11 + b12 * a21 + b13 * a31;
                pDataDestination[4] = b11 * a12 + b12 * a22 + b13 * a32;
                pDataDestination[8] = b11 * a13 + b12 * a23 + b13 * a33;
                pDataDestination[12] = b11 * a14 + b12 * a24 + b13 * a34;
                pDataDestination[1] = b21 * a11 + b22 * a21 + b23 * a31;
                pDataDestination[5] = b21 * a12 + b22 * a22 + b23 * a32;
                pDataDestination[9] = b21 * a13 + b22 * a23 + b23 * a33;
                pDataDestination[13] = b21 * a14 + b22 * a24 + b23 * a34;
                pDataDestination[2] = b31 * a11 + b32 * a21 + b33 * a31;
                pDataDestination[6] = b31 * a12 + b32 * a22 + b33 * a32;
                pDataDestination[10] = b31 * a13 + b32 * a23 + b33 * a33;
                pDataDestination[14] = b31 * a14 + b32 * a24 + b33 * a34;
                pDataDestination[3] = pData[3];
                pDataDestination[7] = pData[7];
                pDataDestination[11] = pData[11];
                pDataDestination[15] = pData[15];
                return m4fDestination;
            };
            Mat4.prototype.setTranslation = /** @inline */function (v3fTranslation) {
                var pData = this.data;
                pData[12] = v3fTranslation.x;
                pData[13] = v3fTranslation.y;
                pData[14] = v3fTranslation.z;
                return this;
            };
            Mat4.prototype.getTranslation = /** @inline */function (v3fTranslation) {
                if (!((v3fTranslation) !== undefined)) {
                    v3fTranslation = new math.Vec3();
                }
                var pData = this.data;
                v3fTranslation.x = pData[12];
                v3fTranslation.y = pData[13];
                v3fTranslation.z = pData[14];
                return v3fTranslation;
            };
            Mat4.prototype.translateRight = function (v3fTranslation, m4fDestination) {
                var pData = this.data;
                var x = v3fTranslation.x, y = v3fTranslation.y, z = v3fTranslation.z;
                if (!((m4fDestination) !== undefined)) {
                    pData[12] = pData[0] * x + pData[4] * y + pData[8] * z + pData[12];
                    pData[13] = pData[1] * x + pData[5] * y + pData[9] * z + pData[13];
                    pData[14] = pData[2] * x + pData[6] * y + pData[10] * z + pData[14];
                    pData[15] = pData[3] * x + pData[7] * y + pData[11] * z + pData[15];
                    //строго говоря последнюю строчку умножать не обязательно, так как она должна быть -> 0 0 0 1
                    return this;
                }
                var pDataDestination = m4fDestination.data;
                //кешируем матрицу вращений
                                var a11 = pData[0], a12 = pData[4], a13 = pData[8];
                var a21 = pData[0], a22 = pData[5], a23 = pData[9];
                var a31 = pData[0], a32 = pData[6], a33 = pData[10];
                var a41 = pData[0], a42 = pData[7], a43 = pData[11];
                pDataDestination[0] = a11;
                pDataDestination[4] = a12;
                pDataDestination[8] = a13;
                pDataDestination[12] = a11 * x + a12 * y + a13 * z + pData[12];
                pDataDestination[1] = a21;
                pDataDestination[5] = a22;
                pDataDestination[9] = a23;
                pDataDestination[13] = a21 * x + a22 * y + a23 * z + pData[13];
                pDataDestination[2] = a31;
                pDataDestination[6] = a32;
                pDataDestination[10] = a33;
                pDataDestination[14] = a31 * x + a32 * y + a33 * z + pData[14];
                pDataDestination[3] = a41;
                pDataDestination[7] = a42;
                pDataDestination[11] = a43;
                pDataDestination[15] = a41 * x + a42 * y + a43 * z + pData[15];
                return m4fDestination;
            };
            Mat4.prototype.translateLeft = function (v3fTranslation, m4fDestination) {
                var pData = this.data;
                var x = v3fTranslation.x, y = v3fTranslation.y, z = v3fTranslation.z;
                if (!((m4fDestination) !== undefined)) {
                    pData[12] = x + pData[12];
                    pData[13] = y + pData[13];
                    pData[14] = z + pData[14];
                    return this;
                }
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = pData[0];
                pDataDestination[4] = pData[4];
                pDataDestination[8] = pData[8];
                pDataDestination[12] = x + pData[12];
                pDataDestination[1] = pData[1];
                pDataDestination[5] = pData[5];
                pDataDestination[9] = pData[9];
                pDataDestination[13] = y + pData[13];
                pDataDestination[2] = pData[2];
                pDataDestination[6] = pData[6];
                pDataDestination[10] = pData[10];
                pDataDestination[14] = z + pData[14];
                pDataDestination[3] = pData[3];
                pDataDestination[7] = pData[7];
                pDataDestination[11] = pData[11];
                pDataDestination[15] = pData[15];
                return m4fDestination;
            };
            Mat4.prototype.scaleRight = function (v3fScale, m4fDestination) {
                var pData = this.data;
                var x = v3fScale.x, y = v3fScale.y, z = v3fScale.z;
                if (!((m4fDestination) !== undefined)) {
                    pData[0] *= x;
                    pData[4] *= y;
                    pData[8] *= z;
                    pData[1] *= x;
                    pData[5] *= y;
                    pData[9] *= z;
                    pData[2] *= x;
                    pData[6] *= y;
                    pData[10] *= z;
                    //скейлить эти компоненты необязательно, так как там должны лежать нули
                    pData[3] *= x;
                    pData[7] *= y;
                    pData[11] *= z;
                    return this;
                }
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = pData[0] * x;
                pDataDestination[4] = pData[4] * y;
                pDataDestination[8] = pData[8] * z;
                pDataDestination[12] = pData[12];
                pDataDestination[1] = pData[1] * x;
                pDataDestination[5] = pData[5] * y;
                pDataDestination[9] = pData[9] * z;
                pDataDestination[13] = pData[13];
                pDataDestination[2] = pData[2] * x;
                pDataDestination[6] = pData[6] * y;
                pDataDestination[10] = pData[10] * z;
                pDataDestination[14] = pData[14];
                //скейлить эти компоненты необязательно, так как там должны лежать нули
                pDataDestination[3] = pData[3] * x;
                pDataDestination[7] = pData[7] * y;
                pDataDestination[11] = pData[11] * z;
                pDataDestination[15] = pData[15];
                return m4fDestination;
            };
            Mat4.prototype.scaleLeft = function (v3fScale, m4fDestination) {
                var pData = this.data;
                var x = v3fScale.x, y = v3fScale.y, z = v3fScale.z;
                if (!((m4fDestination) !== undefined)) {
                    pData[0] *= x;
                    pData[4] *= x;
                    pData[8] *= x;
                    pData[12] *= x;
                    pData[1] *= y;
                    pData[5] *= y;
                    pData[9] *= y;
                    pData[13] *= y;
                    pData[2] *= z;
                    pData[6] *= z;
                    pData[10] *= z;
                    pData[14] *= z;
                    return this;
                }
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = pData[0] * x;
                pDataDestination[4] = pData[4] * x;
                pDataDestination[8] = pData[8] * x;
                pDataDestination[12] = pData[12] * x;
                pDataDestination[1] = pData[1] * y;
                pDataDestination[5] = pData[5] * y;
                pDataDestination[9] = pData[9] * y;
                pDataDestination[13] = pData[13] * y;
                pDataDestination[2] = pData[2] * z;
                pDataDestination[6] = pData[6] * z;
                pDataDestination[10] = pData[10] * z;
                pDataDestination[14] = pData[14] * z;
                pDataDestination[3] = pData[3];
                pDataDestination[7] = pData[7];
                pDataDestination[11] = pData[11];
                pDataDestination[15] = pData[15];
                return m4fDestination;
            };
            Mat4.prototype.decompose = /** @inline */function (q4fRotation, v3fScale, v3fTranslation) {
                /*not inlined, because supportes only single statement functions(cur. st. count: 7)*/this.getTranslation(v3fTranslation);
                var m3fRotScale = this.toMat3(math.Mat3.stackCeil.set());
                return m3fRotScale.decompose(q4fRotation, v3fScale);
            };
            Mat4.prototype.row = function (iRow, v4fDestination) {
                if (!((v4fDestination) !== undefined)) {
                    v4fDestination = new math.Vec4();
                }
                var pData = this.data;
                switch(iRow) {
                    case 1:
                        v4fDestination.x = pData[0];
                        v4fDestination.y = pData[4];
                        v4fDestination.z = pData[8];
                        v4fDestination.w = pData[12];
                        break;
                    case 2:
                        v4fDestination.x = pData[1];
                        v4fDestination.y = pData[5];
                        v4fDestination.z = pData[9];
                        v4fDestination.w = pData[13];
                        break;
                    case 3:
                        v4fDestination.x = pData[2];
                        v4fDestination.y = pData[6];
                        v4fDestination.z = pData[10];
                        v4fDestination.w = pData[14];
                        break;
                    case 4:
                        v4fDestination.x = pData[3];
                        v4fDestination.y = pData[7];
                        v4fDestination.z = pData[11];
                        v4fDestination.w = pData[15];
                        break;
                }
                return v4fDestination;
            };
            Mat4.prototype.column = function (iColumn, v4fDestination) {
                if (!((v4fDestination) !== undefined)) {
                    v4fDestination = new math.Vec4();
                }
                var pData = this.data;
                switch(iColumn) {
                    case 1:
                        v4fDestination.x = pData[0];
                        v4fDestination.y = pData[1];
                        v4fDestination.z = pData[2];
                        v4fDestination.w = pData[3];
                        break;
                    case 2:
                        v4fDestination.x = pData[4];
                        v4fDestination.y = pData[5];
                        v4fDestination.z = pData[6];
                        v4fDestination.w = pData[7];
                        break;
                    case 3:
                        v4fDestination.x = pData[8];
                        v4fDestination.y = pData[9];
                        v4fDestination.z = pData[10];
                        v4fDestination.w = pData[11];
                        break;
                    case 4:
                        v4fDestination.x = pData[12];
                        v4fDestination.y = pData[13];
                        v4fDestination.z = pData[14];
                        v4fDestination.w = pData[15];
                        break;
                }
                return v4fDestination;
            };
            Mat4.prototype.unproj = function (v, v4fDestination) {
                if (!((v4fDestination) !== undefined)) {
                    v4fDestination = new math.Vec4();
                }
                var pData = this.data;
                var v3fScreen = v;
                var x, y, z;
                if (((((this).data[15] === 1) ? true : false))) {
                    //orthogonal projection case
                    z = (v3fScreen.z - pData[14]) / pData[10];
                    y = (v3fScreen.y - pData[13]) / pData[5];
                    x = (v3fScreen.x - pData[12]) / pData[0];
                } else {
                    //frustum case
                    z = -pData[14] / (pData[10] + v3fScreen.z);
                    y = -(v3fScreen.y + pData[9]) * z / pData[5];
                    x = -(v3fScreen.x + pData[8]) * z / pData[0];
                }
                v4fDestination.x = x;
                v4fDestination.y = y;
                v4fDestination.z = z;
                v4fDestination.w = 1.;
                return v4fDestination;
            };
            Mat4.prototype.unprojZ = function (fZ) {
                var pData = this.data;
                if (((((this).data[15] === 1) ? true : false))) {
                    //orthogonal projection case
                    return (fZ - pData[14]) / pData[10];
                } else {
                    //pData[__43] === -1
                    //frustum case
                    return -pData[14] / (pData[10] + fZ);
                }
            };
            Mat4.prototype.isOrthogonalProjection = /** @inline */function () {
                // var pData: Float32Array = this.data;
                // if(pData[__44] === 1){
                // 	//orthogonal projection
                // 	return true;
                // }
                // else{
                // 	//pData[__43] === -1
                // 	//frustum projection
                // 	return false;
                // }
                return ((this.data[15] === 1) ? true : false);
            };
            Mat4.fromYawPitchRoll = function fromYawPitchRoll(fYaw, fPitch, fRoll, m4fDestination) {
                if (arguments.length <= 2) {
                    //Vec3 + m4fDestination
                    var v3fVec = arguments[0];
                    fYaw = v3fVec.x;
                    fPitch = v3fVec.y;
                    fRoll = v3fVec.z;
                    m4fDestination = arguments[1];
                }
                if (!((m4fDestination) !== undefined)) {
                    m4fDestination = new Mat4();
                }
                var pDataDestination = m4fDestination.data;
                var fSin1 = Math.sin(fYaw);
                var fSin2 = Math.sin(fPitch);
                var fSin3 = Math.sin(fRoll);
                var fCos1 = Math.cos(fYaw);
                var fCos2 = Math.cos(fPitch);
                var fCos3 = Math.cos(fRoll);
                pDataDestination[0] = fCos1 * fCos3 + fSin1 * fSin2 * fSin3;
                pDataDestination[4] = fCos3 * fSin1 * fSin2 - fCos1 * fSin3;
                pDataDestination[8] = fCos2 * fSin1;
                pDataDestination[12] = 0.;
                pDataDestination[1] = fCos2 * fSin3;
                pDataDestination[5] = fCos2 * fCos3;
                pDataDestination[9] = -fSin2;
                pDataDestination[13] = 0.;
                pDataDestination[2] = fCos1 * fSin2 * fSin3 - fCos3 * fSin1;
                pDataDestination[6] = fSin1 * fSin3 + fCos1 * fCos3 * fSin2;
                pDataDestination[10] = fCos1 * fCos2;
                pDataDestination[14] = 0.;
                pDataDestination[3] = 0.;
                pDataDestination[7] = 0.;
                pDataDestination[11] = 0.;
                pDataDestination[15] = 1.;
                return m4fDestination;
            };
            Mat4.fromXYZ = function fromXYZ(fX, fY, fZ, m4fDestination) {
                if (arguments.length <= 2) {
                    //Vec3 + m4fDestination
                    var v3fVec = arguments[0];
                    return Mat4.fromYawPitchRoll(v3fVec.y, v3fVec.x, v3fVec.z, arguments[1]);
                } else {
                    //fX fY fZ m4fDestination
                    var fX = arguments[0];
                    var fY = arguments[1];
                    var fZ = arguments[2];
                    return Mat4.fromYawPitchRoll(fY, fX, fZ, arguments[3]);
                }
            };
            Mat4.frustum = function frustum(fLeft, fRight, fBottom, fTop, fNear, fFar, m4fDestination) {
                if (!((m4fDestination) !== undefined)) {
                    m4fDestination = new Mat4();
                }
                var pDataDestination = m4fDestination.data;
                var fRL = fRight - fLeft;
                var fTB = fTop - fBottom;
                var fFN = fFar - fNear;
                pDataDestination[0] = 2. * fNear / fRL;
                pDataDestination[4] = 0.;
                pDataDestination[8] = (fRight + fLeft) / fRL;
                pDataDestination[12] = 0.;
                pDataDestination[1] = 0.;
                pDataDestination[5] = 2. * fNear / fTB;
                pDataDestination[9] = (fTop + fBottom) / fTB;
                pDataDestination[13] = 0.;
                pDataDestination[2] = 0.;
                pDataDestination[6] = 0.;
                pDataDestination[10] = -(fFar + fNear) / fFN;
                pDataDestination[14] = -2. * fFar * fNear / fFN;
                pDataDestination[3] = 0.;
                pDataDestination[7] = 0.;
                pDataDestination[11] = -1.;
                pDataDestination[15] = 0.;
                return m4fDestination;
            };
            Mat4.perspective = /** @inline */function perspective(fFovy, fAspect, fNear, fFar, m4fDestination) {
                var fTop = fNear * math.tan(fFovy / 2.);
                var fRight = fTop * fAspect;
                return Mat4.frustum(-fRight, fRight, -fTop, fTop, fNear, fFar, m4fDestination);
            };
            Mat4.orthogonalProjectionAsymmetric = function orthogonalProjectionAsymmetric(fLeft, fRight, fBottom, fTop, fNear, fFar, m4fDestination) {
                if (!((m4fDestination) !== undefined)) {
                    m4fDestination = new Mat4();
                }
                var pDataDestination = m4fDestination.data;
                var fRL = fRight - fLeft;
                var fTB = fTop - fBottom;
                var fFN = fFar - fNear;
                pDataDestination[0] = 2. / fRL;
                pDataDestination[4] = 0.;
                pDataDestination[8] = 0.;
                pDataDestination[12] = -(fRight + fLeft) / fRL;
                pDataDestination[1] = 0.;
                pDataDestination[5] = 2. / fTB;
                pDataDestination[9] = 0.;
                pDataDestination[13] = -(fTop + fBottom) / fTB;
                pDataDestination[2] = 0.;
                pDataDestination[6] = 0.;
                pDataDestination[10] = -2. / fFN;
                pDataDestination[14] = -(fFar + fNear) / fFN;
                pDataDestination[3] = 0.;
                pDataDestination[7] = 0.;
                pDataDestination[11] = 0.;
                pDataDestination[15] = 1.;
                return m4fDestination;
            };
            Mat4.orthogonalProjection = /** @inline */function orthogonalProjection(fWidth, fHeight, fNear, fFar, m4fDestination) {
                var fRight = fWidth / 2.;
                var fTop = fHeight / 2.;
                return Mat4.orthogonalProjectionAsymmetric(-fRight, fRight, -fTop, fTop, fNear, fFar, m4fDestination);
            };
            Mat4.lookAt = function lookAt(v3fEye, v3fCenter, v3fUp, m4fDestination) {
                if (!((m4fDestination) !== undefined)) {
                    m4fDestination = new Mat4(1.);
                }
                var fEyeX = v3fEye.x, fEyeY = v3fEye.y, fEyeZ = v3fEye.z;
                var fCenterX = v3fCenter.x, fCenterY = v3fCenter.y, fCenterZ = v3fCenter.z;
                var fUpX = v3fUp.x, fUpY = v3fUp.y, fUpZ = v3fUp.z;
                var fLength;
                var fInvLength;
                if (fEyeX === fCenterX && fEyeY === fCenterY && fEyeZ === fCenterZ) {
                    return m4fDestination;
                }
                var fXNewX, fXNewY, fXNewZ;
                var fYNewX, fYNewY, fYNewZ;
                var fZNewX, fZNewY, fZNewZ;
                //ось Z направлена на наблюдателя
                fZNewX = fEyeX - fCenterX;
                fZNewY = fEyeY - fCenterY;
                fZNewZ = fEyeZ - fCenterZ;
                fLength = math.sqrt(fZNewX * fZNewX + fZNewY * fZNewY + fZNewZ * fZNewZ);
                fInvLength = 1. / fLength;
                //новая ось Z
                fZNewX = fZNewX * fInvLength;
                fZNewY = fZNewY * fInvLength;
                fZNewZ = fZNewZ * fInvLength;
                //новая ось X
                fXNewX = fUpY * fZNewZ - fUpZ * fZNewY;
                fXNewY = fUpZ * fZNewX - fUpX * fZNewZ;
                fXNewZ = fUpX * fZNewY - fUpY * fZNewX;
                fLength = math.sqrt(fXNewX * fXNewX + fXNewY * fXNewY + fXNewZ * fXNewZ);
                if (fLength) {
                    fInvLength = 1. / fLength;
                    fXNewX = fXNewX * fInvLength;
                    fXNewY = fXNewY * fInvLength;
                    fXNewZ = fXNewZ * fInvLength;
                }
                //новая ось Y
                fYNewX = fZNewY * fXNewZ - fZNewZ * fXNewY;
                fYNewY = fZNewZ * fXNewX - fZNewX * fXNewZ;
                fYNewZ = fZNewX * fXNewY - fZNewY * fXNewX;
                //нормировать ненужно, так как было векторное умножение двух ортонормированных векторов
                //положение камеры в новых осях
                var fEyeNewX = fEyeX * fXNewX + fEyeY * fXNewY + fEyeZ * fXNewZ;
                var fEyeNewY = fEyeX * fYNewX + fEyeY * fYNewY + fEyeZ * fYNewZ;
                var fEyeNewZ = fEyeX * fZNewX + fEyeY * fZNewY + fEyeZ * fZNewZ;
                var pDataDestination = m4fDestination.data;
                //lookAt matrix === camera view matrix
                //почему новый базис записывается по строкам?
                //это сзязано с тем, что это получающаяся матрица -
                //это viewMatrix камеры, а на эту матрицу умножается при рендеринге, то есть
                //модель должна испытать преобразования противоположные тем, которые испытывает камера
                //то есть вращение в другую сторону(базис по строкам) и сдвиг в противоположную сторону
                pDataDestination[0] = fXNewX;
                pDataDestination[4] = fXNewY;
                pDataDestination[8] = fXNewZ;
                /*отъезжаем в позицию камеры*/
                pDataDestination[12] = -fEyeNewX;
                pDataDestination[1] = fYNewX;
                pDataDestination[5] = fYNewY;
                pDataDestination[9] = fYNewZ;
                /*отъезжаем в позицию камеры*/
                pDataDestination[13] = -fEyeNewY;
                pDataDestination[2] = fZNewX;
                pDataDestination[6] = fZNewY;
                pDataDestination[10] = fZNewZ;
                /*отъезжаем в позицию камеры*/
                pDataDestination[14] = -fEyeNewZ;
                pDataDestination[3] = 0.;
                pDataDestination[7] = 0.;
                pDataDestination[11] = 0.;
                pDataDestination[15] = 1.;
                return m4fDestination;
            };
            Object.defineProperty(Mat4, "stackCeil", {
                get: function () {
                    Mat4.stackPosition = Mat4.stackPosition === Mat4.stackSize - 1 ? 0 : Mat4.stackPosition;
                    return Mat4.stack[Mat4.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            Mat4.stackSize = 100;
            Mat4.stackPosition = 0;
            Mat4.stack = (function () {
                var pStack = new Array(Mat4.stackSize);
                for(var i = 0; i < Mat4.stackSize; i++) {
                    pStack[i] = new Mat4();
                }
                return pStack;
            })();
            return Mat4;
        })();
        math.Mat4 = Mat4;        
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (math) {
        var Quat4 = (function () {
            function Quat4(fX, fY, fZ, fW) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 2:
                        this.set(arguments[0], arguments[1]);
                        break;
                    case 4:
                        this.set(arguments[0], arguments[1], arguments[2], arguments[3]);
                        break;
                    default:
                        this.x = this.y = this.z = 0.;
                        this.w = 1.;
                        break;
                }
            }
            Quat4.prototype.set = function (fX, fY, fZ, fW) {
                var nArgumentsLength = arguments.length;
                if (nArgumentsLength === 0) {
                    this.x = this.y = this.z = 0.;
                    this.w = 1.;
                }
                if (nArgumentsLength === 1) {
                    if (arguments[0] instanceof Quat4) {
                        var q4fQuat = arguments[0];
                        this.x = q4fQuat.x;
                        this.y = q4fQuat.y;
                        this.z = q4fQuat.z;
                        this.w = q4fQuat.w;
                    } else {
                        //Array
                        var pElements = arguments[0];
                        this.x = pElements[0];
                        this.y = pElements[1];
                        this.z = pElements[2];
                        this.w = pElements[3];
                    }
                } else if (nArgumentsLength === 2) {
                    //float float
                    //vec3 float
                    if ((typeof (arguments[0]) === "number")) {
                        //float float
                        var fValue = arguments[0];
                        this.x = fValue;
                        this.y = fValue;
                        this.z = fValue;
                        this.w = arguments[1];
                    } else {
                        //vec3 float
                        var v3fValue = arguments[0];
                        this.x = v3fValue.x;
                        this.y = v3fValue.y;
                        this.z = v3fValue.z;
                        this.w = arguments[1];
                    }
                } else if (nArgumentsLength === 4) {
                    this.x = arguments[0];
                    this.y = arguments[1];
                    this.z = arguments[2];
                    this.w = arguments[3];
                }
                return this;
            };
            Quat4.prototype.multiply = function (q4fQuat, q4fDestination) {
                if (!((q4fDestination) !== undefined)) {
                    q4fDestination = this;
                }
                var x1 = this.x, y1 = this.y, z1 = this.z, w1 = this.w;
                var x2 = q4fQuat.x, y2 = q4fQuat.y, z2 = q4fQuat.z, w2 = q4fQuat.w;
                q4fDestination.x = x1 * w2 + x2 * w1 + y1 * z2 - z1 * y2;
                q4fDestination.y = y1 * w2 + y2 * w1 + z1 * x2 - x1 * z2;
                q4fDestination.z = z1 * w2 + z2 * w1 + x1 * y2 - y1 * x2;
                q4fDestination.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
                return q4fDestination;
            };
            Quat4.prototype.multiplyVec3 = function (v3fVec, v3fDestination) {
                if (!((v3fDestination) !== undefined)) {
                    v3fDestination = v3fVec;
                }
                var q4fVec = Quat4.stackCeil.set(v3fVec, 0.);
                var qInverse = this.inverse(Quat4.stackCeil.set());
                var qResult = this.multiply(q4fVec.multiply(qInverse), Quat4.stackCeil.set());
                v3fDestination.x = qResult.x;
                v3fDestination.y = qResult.y;
                v3fDestination.z = qResult.z;
                return v3fDestination;
            };
            Quat4.prototype.conjugate = function (q4fDestination) {
                if (!((q4fDestination) !== undefined)) {
                    this.x = -this.x;
                    this.y = -this.y;
                    this.z = -this.z;
                    return this;
                }
                q4fDestination.x = -this.x;
                q4fDestination.y = -this.y;
                q4fDestination.z = -this.z;
                q4fDestination.w = this.w;
                return q4fDestination;
            };
            Quat4.prototype.inverse = function (q4fDestination) {
                if (!((q4fDestination) !== undefined)) {
                    q4fDestination = this;
                }
                var x = this.x, y = this.y, z = this.z, w = this.w;
                var fSqLength = x * x + y * y + z * z + w * w;
                if (fSqLength === 0.) {
                    q4fDestination.x = 0.;
                    q4fDestination.y = 0.;
                    q4fDestination.z = 0.;
                    q4fDestination.w = 0.;
                } else {
                    var fInvSqLength = 1. / fSqLength;
                    q4fDestination.x = -x * fInvSqLength;
                    q4fDestination.y = -y * fInvSqLength;
                    q4fDestination.z = -z * fInvSqLength;
                    q4fDestination.w = w * fInvSqLength;
                }
                return q4fDestination;
            };
            Quat4.prototype.length = /** @inline */function () {
                var x = this.x, y = this.y, z = this.z, w = this.w;
                return math.sqrt(x * x + y * y + z * z + w * w);
            };
            Quat4.prototype.normalize = function (q4fDestination) {
                if (!((q4fDestination) !== undefined)) {
                    q4fDestination = this;
                }
                var x = this.x, y = this.y, z = this.z, w = this.w;
                var fLength = math.sqrt(x * x + y * y + z * z + w * w);
                if (fLength === 0.) {
                    q4fDestination.x = 0.;
                    q4fDestination.y = 0.;
                    q4fDestination.z = 0.;
                    q4fDestination.w = 0.;
                } else {
                    var fInvLength = 1 / fLength;
                    q4fDestination.x = x * fInvLength;
                    q4fDestination.y = y * fInvLength;
                    q4fDestination.z = z * fInvLength;
                    q4fDestination.w = w * fInvLength;
                }
                return q4fDestination;
            };
            Quat4.prototype.calculateW = function (q4fDestination) {
                var x = this.x, y = this.y, z = this.z;
                if (!((q4fDestination) !== undefined)) {
                    this.w = math.sqrt(1. - x * x - y * y - z * z);
                    return this;
                }
                q4fDestination.x = x;
                q4fDestination.y = y;
                q4fDestination.z = z;
                q4fDestination.w = math.sqrt(1. - x * x - y * y - z * z);
                return q4fDestination;
            };
            Quat4.prototype.isEqual = function (q4fQuat, fEps, asMatrix) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if (typeof asMatrix === "undefined") { asMatrix = false; }
                var x1 = this.x, y1 = this.y, z1 = this.z, w1 = this.w;
                var x2 = q4fQuat.x, y2 = q4fQuat.y, z2 = q4fQuat.z, w2 = q4fQuat.w;
                var fLength1 = math.sqrt(x1 * x1 + y1 * y1 + z1 * z1 + w1 * w1);
                var fLength2 = math.sqrt(x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2);
                if (math.abs(fLength2 - fLength2) > fEps) {
                    return false;
                }
                var cosHalfTheta = (x1 * x2 + y1 * y2 + z1 * z2 + w1 * w2) / fLength1 / fLength2;
                if (asMatrix) {
                    cosHalfTheta = math.abs(cosHalfTheta);
                }
                if (1. - cosHalfTheta > fEps) {
                    return false;
                }
                return true;
            };
            Quat4.prototype.getYaw = function () {
                var fYaw;
                var x = this.x, y = this.y, z = this.z, w = this.w;
                var fx2 = x * 2.;
                var fy2 = y * 2.;
                if (math.abs(x) == math.abs(w)) {
                    //вырожденный случай обрабатывается отдельно
                    //
                    var wTemp = w * math.sqrt(2.);
                    //cos(Yaw/2)*cos(Roll/2) + sin(Yaw/2)*sin(Roll/2) = cos((Yaw-Roll)/2); Roll = 0;
                    //x==-w
                    //cos(Yaw/2)*cos(Roll/2) - sin(Yaw/2)*sin(Roll/2) = cos((Yaw+Roll)/2); Roll = 0;
                    var yTemp = y * math.sqrt(2.);
                    //sin(Yaw/2)*cos(Roll/2) - cos(Yaw/2)*sin(Roll/2) = sin((Yaw-Roll)/2); Roll = 0;
                    //x==-w
                    //sin(Yaw/2)*cos(Roll/2) + cos(Yaw/2)*sin(Roll/2) = sin((Yaw+Roll)/2); Roll = 0;
                    fYaw = math.atan2(yTemp, wTemp) * 2.;
                    //fRoll = 0;
                    //убираем дополнительный оборот
                    var pi = math.PI;
                    if (fYaw > pi) {
                        fYaw -= pi;
                        //fRoll = (x == w) ? -pi : pi;
                                            } else if (fYaw < -pi) {
                        fYaw += pi;
                        //fRoll = (x == w) ? pi : -pi;
                                            }
                } else {
                    //Math.atan2(sin(Yaw)*cos(Pitch),cos(Yaw)*cos(Pitch));
                    fYaw = math.atan2(fx2 * z + fy2 * w, 1. - (fx2 * x + fy2 * y));
                }
                return fYaw;
            };
            Quat4.prototype.getPitch = function () {
                var fPitch;
                var x = this.x, y = this.y, z = this.z, w = this.w;
                var fx2 = x * 2.;
                var fy2 = y * 2.;
                /*в очень редких случаях из-за ошибок округления получается результат > 1*/
                var fSinPitch = (/*checked (origin: math)>>*/akra.math.max((-1.), /*checked (origin: math)>>*/akra.math.min((fx2 * w - fy2 * z), (1.))));
                fPitch = math.asin(fSinPitch);
                return fPitch;
            };
            Quat4.prototype.getRoll = function () {
                var fRoll;
                var x = this.x, y = this.y, z = this.z, w = this.w;
                var fx2 = x * 2.;
                var fz2 = z * 2.;
                if (math.abs(x) == math.abs(w)) {
                    //вырожденный случай обрабатывается отдельно
                    //
                    var wTemp = w * math.sqrt(2.);
                    //cos(Yaw/2)*cos(Roll/2) + sin(Yaw/2)*sin(Roll/2) = cos((Yaw-Roll)/2); Roll = 0;
                    //x==-w
                    //cos(Yaw/2)*cos(Roll/2) - sin(Yaw/2)*sin(Roll/2) = cos((Yaw+Roll)/2); Roll = 0;
                    var yTemp = y * math.sqrt(2.);
                    //sin(Yaw/2)*cos(Roll/2) - cos(Yaw/2)*sin(Roll/2) = sin((Yaw-Roll)/2); Roll = 0;
                    //x==-w
                    //sin(Yaw/2)*cos(Roll/2) + cos(Yaw/2)*sin(Roll/2) = sin((Yaw+Roll)/2); Roll = 0;
                    var fYaw = math.atan2(yTemp, wTemp) * 2.;
                    fRoll = 0.;
                    //убираем дополнительный оборот
                    var pi = math.PI;
                    if (fYaw > pi) {
                        //fYaw -= pi;
                        fRoll = (x == w) ? -pi : pi;
                    } else if (fYaw < -pi) {
                        //fYaw += pi;
                        fRoll = (x == w) ? pi : -pi;
                    }
                } else {
                    //Math.atan2(cos(Pitch) * sin(Roll),cos(Pitch)*cos(Roll));
                    fRoll = math.atan2(fx2 * y + fz2 * w, 1. - (fx2 * x + fz2 * z));
                }
                return fRoll;
            };
            Quat4.prototype.toYawPitchRoll = function (v3fDestination) {
                if (!((v3fDestination) !== undefined)) {
                    v3fDestination = new math.Vec3();
                }
                var fYaw, fPitch, fRoll;
                var x = this.x, y = this.y, z = this.z, w = this.w;
                var fx2 = x * 2.;
                var fy2 = y * 2.;
                var fz2 = z * 2.;
                var fw2 = w * 2.;
                /*в очень редких случаях из-за ошибок округления получается результат > 1*/
                var fSinPitch = (/*checked (origin: math)>>*/akra.math.max((-1.), /*checked (origin: math)>>*/akra.math.min((fx2 * w - fy2 * z), (1.))));
                fPitch = math.asin(fSinPitch);
                //не известен знак косинуса, как следствие это потребует дополнительной проверки.
                //как показала практика - это не на что не влияет, просто один и тот же кватернион можно получить двумя разными вращениями
                if (math.abs(x) == math.abs(w)) {
                    //вырожденный случай обрабатывается отдельно
                    //
                    var wTemp = w * math.sqrt(2.);
                    //cos(Yaw/2)*cos(Roll/2) + sin(Yaw/2)*sin(Roll/2) = cos((Yaw-Roll)/2); Roll = 0;
                    //x==-w
                    //cos(Yaw/2)*cos(Roll/2) - sin(Yaw/2)*sin(Roll/2) = cos((Yaw+Roll)/2); Roll = 0;
                    var yTemp = y * math.sqrt(2.);
                    //sin(Yaw/2)*cos(Roll/2) - cos(Yaw/2)*sin(Roll/2) = sin((Yaw-Roll)/2); Roll = 0;
                    //x==-w
                    //sin(Yaw/2)*cos(Roll/2) + cos(Yaw/2)*sin(Roll/2) = sin((Yaw+Roll)/2); Roll = 0;
                    fYaw = math.atan2(yTemp, wTemp) * 2.;
                    fRoll = 0.;
                    //убираем дополнительный оборот
                    var pi = math.PI;
                    if (fYaw > pi) {
                        fYaw -= pi;
                        fRoll = (x == w) ? -pi : pi;
                    } else if (fYaw < -pi) {
                        fYaw += pi;
                        fRoll = (x == w) ? pi : -pi;
                    }
                } else {
                    //Math.atan2(sin(Yaw)*cos(Pitch),cos(Yaw)*cos(Pitch));
                    fYaw = math.atan2(fx2 * z + fy2 * w, 1. - (fx2 * x + fy2 * y));
                    //Math.atan2(cos(Pitch) * sin(Roll),cos(Pitch)*cos(Roll));
                    fRoll = math.atan2(fx2 * y + fz2 * w, 1. - (fx2 * x + fz2 * z));
                }
                v3fDestination.x = fYaw;
                v3fDestination.y = fPitch;
                v3fDestination.z = fRoll;
                return v3fDestination;
            };
            Quat4.prototype.toMat3 = function (m3fDestination) {
                if (!((m3fDestination) !== undefined)) {
                    m3fDestination = new math.Mat3();
                }
                var pDataDestination = m3fDestination.data;
                var x = this.x, y = this.y, z = this.z, w = this.w;
                //потом необходимо ускорить
                pDataDestination[0] = 1. - 2. * (y * y + z * z);
                pDataDestination[3] = 2. * (x * y - z * w);
                pDataDestination[6] = 2. * (x * z + y * w);
                pDataDestination[1] = 2. * (x * y + z * w);
                pDataDestination[4] = 1. - 2. * (x * x + z * z);
                pDataDestination[7] = 2. * (y * z - x * w);
                pDataDestination[2] = 2. * (x * z - y * w);
                pDataDestination[5] = 2. * (y * z + x * w);
                pDataDestination[8] = 1. - 2. * (x * x + y * y);
                return m3fDestination;
            };
            Quat4.prototype.toMat4 = function (m4fDestination) {
                if (!((m4fDestination) !== undefined)) {
                    m4fDestination = new math.Mat4();
                }
                var pDataDestination = m4fDestination.data;
                var x = this.x, y = this.y, z = this.z, w = this.w;
                //потом необходимо ускорить
                pDataDestination[0] = 1. - 2. * (y * y + z * z);
                pDataDestination[4] = 2. * (x * y - z * w);
                pDataDestination[8] = 2. * (x * z + y * w);
                pDataDestination[12] = 0.;
                pDataDestination[1] = 2. * (x * y + z * w);
                pDataDestination[5] = 1. - 2. * (x * x + z * z);
                pDataDestination[9] = 2. * (y * z - x * w);
                pDataDestination[13] = 0.;
                pDataDestination[2] = 2. * (x * z - y * w);
                pDataDestination[6] = 2. * (y * z + x * w);
                pDataDestination[10] = 1. - 2. * (x * x + y * y);
                pDataDestination[14] = 0.;
                pDataDestination[3] = 0.;
                pDataDestination[7] = 0.;
                pDataDestination[11] = 0.;
                pDataDestination[15] = 1.;
                return m4fDestination;
            };
            Quat4.prototype.toString = /** @inline */function () {
                return "[x: " + this.x + ", y: " + this.y + ", z: " + this.z + ", w: " + this.w + "]";
            };
            Quat4.prototype.mix = function (q4fQuat, fA, q4fDestination, bShortestPath) {
                if (typeof bShortestPath === "undefined") { bShortestPath = true; }
                if (!((q4fDestination) !== undefined)) {
                    q4fDestination = this;
                }
                fA = (/*checked (origin: math)>>*/akra.math.max((0), /*checked (origin: math)>>*/akra.math.min((fA), (1))));
                var x1 = this.x, y1 = this.y, z1 = this.z, w1 = this.w;
                var x2 = q4fQuat.x, y2 = q4fQuat.y, z2 = q4fQuat.z, w2 = q4fQuat.w;
                //скалярное произведение
                var fCos = x1 * x2 + y1 * y2 + z1 * z2 + w1 * w2;
                if (fCos < 0. && bShortestPath) {
                    x2 = -x2;
                    y2 = -y2;
                    z2 = -z2;
                    w2 = -w2;
                }
                var k1 = 1. - fA;
                var k2 = fA;
                q4fDestination.x = x1 * k1 + x2 * k2;
                q4fDestination.y = y1 * k1 + y2 * k2;
                q4fDestination.z = z1 * k1 + z2 * k2;
                q4fDestination.w = w1 * k1 + w2 * k2;
                return q4fDestination;
            };
            Quat4.prototype.smix = function (q4fQuat, fA, q4fDestination, bShortestPath) {
                if (typeof bShortestPath === "undefined") { bShortestPath = true; }
                if (!((q4fDestination) !== undefined)) {
                    q4fDestination = this;
                }
                fA = (/*checked (origin: math)>>*/akra.math.max((0), /*checked (origin: math)>>*/akra.math.min((fA), (1))));
                var x1 = this.x, y1 = this.y, z1 = this.z, w1 = this.w;
                var x2 = q4fQuat.x, y2 = q4fQuat.y, z2 = q4fQuat.z, w2 = q4fQuat.w;
                //скалярное произведение
                var fCos = x1 * x2 + y1 * y2 + z1 * z2 + w1 * w2;
                if (fCos < 0 && bShortestPath) {
                    fCos = -fCos;
                    x2 = -x2;
                    y2 = -y2;
                    z2 = -z2;
                    w2 = -w2;
                }
                var fEps = 1e-3;
                if (math.abs(fCos) < 1. - fEps) {
                    var fSin = math.sqrt(1. - fCos * fCos);
                    var fInvSin = 1. / fSin;
                    var fAngle = math.atan2(fSin, fCos);
                    var k1 = math.sin((1. - fA) * fAngle) * fInvSin;
                    var k2 = math.sin(fA * fAngle) * fInvSin;
                    q4fDestination.x = x1 * k1 + x2 * k2;
                    q4fDestination.y = y1 * k1 + y2 * k2;
                    q4fDestination.z = z1 * k1 + z2 * k2;
                    q4fDestination.w = w1 * k1 + w2 * k2;
                } else {
                    //два кватерниона или очень близки (тогда можно делать линейную интерполяцию)
                    //или два кватениона диаметрально противоположны, тогда можно интерполировать любым способом
                    //позже надо будет реализовать какой-нибудь, а пока тоже линейная интерполяция
                    var k1 = 1 - fA;
                    var k2 = fA;
                    var x = x1 * k1 + x2 * k2;
                    var y = y1 * k1 + y2 * k2;
                    var z = z1 * k1 + z2 * k2;
                    var w = w1 * k1 + w2 * k2;
                    // и нормализуем так-как мы сошли со сферы
                    var fLength = math.sqrt(x * x + y * y + z * z + w * w);
                    var fInvLen = fLength ? 1 / fLength : 0;
                    q4fDestination.x = x * fInvLen;
                    q4fDestination.y = y * fInvLen;
                    q4fDestination.z = z * fInvLen;
                    q4fDestination.w = w * fInvLen;
                }
                return q4fDestination;
            };
            Quat4.fromForwardUp = function fromForwardUp(v3fForward, v3fUp, q4fDestination) {
                if (!((q4fDestination) !== undefined)) {
                    q4fDestination = new Quat4();
                }
                var fForwardX = v3fForward.x, fForwardY = v3fForward.y, fForwardZ = v3fForward.z;
                var fUpX = v3fUp.x, fUpY = v3fUp.y, fUpZ = v3fUp.z;
                var m3fTemp = math.Mat3.stackCeil.set();
                var pTempData = m3fTemp.data;
                pTempData[0] = fUpY * fForwardZ - fUpZ * fForwardY;
                pTempData[3] = fUpX;
                pTempData[6] = fForwardX;
                pTempData[1] = fUpZ * fForwardX - fUpX * fForwardZ;
                pTempData[4] = fUpY;
                pTempData[7] = fForwardY;
                pTempData[2] = fUpX * fForwardY - fUpY * fForwardX;
                pTempData[5] = fUpZ;
                pTempData[8] = fForwardZ;
                return m3fTemp.toQuat4(q4fDestination);
            };
            Quat4.fromAxisAngle = function fromAxisAngle(v3fAxis, fAngle, q4fDestination) {
                if (!((q4fDestination) !== undefined)) {
                    q4fDestination = new Quat4();
                }
                var x = v3fAxis.x, y = v3fAxis.y, z = v3fAxis.z;
                var fLength = math.sqrt(x * x + y * y + z * z);
                if (fLength === 0.) {
                    q4fDestination.x = q4fDestination.y = q4fDestination.z = 0;
                    q4fDestination.w = 1;
                    return q4fDestination;
                }
                var fInvLength = 1 / fLength;
                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;
                var fSin = math.sin(fAngle / 2);
                var fCos = math.cos(fAngle / 2);
                q4fDestination.x = x * fSin;
                q4fDestination.y = y * fSin;
                q4fDestination.z = z * fSin;
                q4fDestination.w = fCos;
                return q4fDestination;
            };
            Quat4.fromYawPitchRoll = function fromYawPitchRoll(fYaw, fPitch, fRoll, q4fDestination) {
                if (arguments.length <= 2) {
                    var v3fVec = arguments[0];
                    fYaw = v3fVec.x;
                    fPitch = v3fVec.y;
                    fRoll = v3fVec.z;
                    q4fDestination = arguments[1];
                }
                if (!((q4fDestination) !== undefined)) {
                    q4fDestination = new Quat4();
                }
                var fHalfYaw = fYaw * 0.5;
                var fHalfPitch = fPitch * 0.5;
                var fHalfRoll = fRoll * 0.5;
                var fCos1 = math.cos(fHalfYaw), fSin1 = math.sin(fHalfYaw);
                var fCos2 = math.cos(fHalfPitch), fSin2 = math.sin(fHalfPitch);
                var fCos3 = math.cos(fHalfRoll), fSin3 = math.sin(fHalfRoll);
                q4fDestination.x = fCos1 * fSin2 * fCos3 + fSin1 * fCos2 * fSin3;
                q4fDestination.y = fSin1 * fCos2 * fCos3 - fCos1 * fSin2 * fSin3;
                q4fDestination.z = fCos1 * fCos2 * fSin3 - fSin1 * fSin2 * fCos3;
                q4fDestination.w = fCos1 * fCos2 * fCos3 + fSin1 * fSin2 * fSin3;
                return q4fDestination;
            };
            Quat4.fromXYZ = function fromXYZ(fX, fY, fZ, q4fDestination) {
                if (arguments.length <= 2) {
                    //Vec3 + m4fDestination
                    var v3fVec = arguments[0];
                    return Quat4.fromYawPitchRoll(v3fVec.y, v3fVec.x, v3fVec.z, arguments[1]);
                } else {
                    //fX fY fZ m4fDestination
                    var fX = arguments[0];
                    var fY = arguments[1];
                    var fZ = arguments[2];
                    return Quat4.fromYawPitchRoll(fY, fX, fZ, arguments[3]);
                }
            };
            Object.defineProperty(Quat4, "stackCeil", {
                get: function () {
                    Quat4.stackPosition = Quat4.stackPosition === Quat4.stackSize - 1 ? 0 : Quat4.stackPosition;
                    return Quat4.stack[Quat4.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            Quat4.stackSize = 256;
            Quat4.stackPosition = 0;
            Quat4.stack = (function () {
                var pStack = new Array(Quat4.stackSize);
                for(var i = 0; i < Quat4.stackSize; i++) {
                    pStack[i] = new Quat4();
                }
                return pStack;
            })();
            return Quat4;
        })();
        math.Quat4 = Quat4;        
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (math) {
        //
        // BASIC MATH AND UNIT CONVERSION CONSTANTS
        //
        math.E = Math.E;
        math.LN2 = Math.LN2;
        math.LOG2E = Math.LOG2E;
        math.LOG10E = Math.LOG10E;
        math.PI = Math.PI;
        math.SQRT1_2 = Math.SQRT1_2;
        math.SQRT2 = Math.SQRT2;
        math.LN10 = Math.LN10;
        math.POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
        math.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY;
        math.FLOAT_PRECISION = (3.4e-8);
        math.TWO_PI = (2.0 * math.PI);
        math.HALF_PI = (math.PI / 2.0);
        math.QUARTER_PI = (math.PI / 4.0);
        math.EIGHTH_PI = (math.PI / 8.0);
        math.PI_SQUARED = (9.86960440108935861883449099987615113531369940724079);
        math.PI_INVERSE = (0.31830988618379067153776752674502872406891929148091);
        math.PI_OVER_180 = (math.PI / 180);
        math.PI_DIV_180 = (180 / math.PI);
        math.NATURAL_LOGARITHM_BASE = (2.71828182845904523536028747135266249775724709369996);
        math.EULERS_CONSTANT = (0.57721566490153286060651);
        math.SQUARE_ROOT_2 = (1.41421356237309504880168872420969807856967187537695);
        math.INVERSE_ROOT_2 = (0.707106781186547524400844362105198);
        math.SQUARE_ROOT_3 = (1.73205080756887729352744634150587236694280525381038);
        math.SQUARE_ROOT_5 = (2.23606797749978969640917366873127623544061835961153);
        math.SQUARE_ROOT_10 = (3.16227766016837933199889354443271853371955513932522);
        math.CUBE_ROOT_2 = (1.25992104989487316476721060727822835057025146470151);
        math.CUBE_ROOT_3 = (1.44224957030740838232163831078010958839186925349935);
        math.FOURTH_ROOT_2 = (1.18920711500272106671749997056047591529297209246382);
        math.NATURAL_LOG_2 = (0.69314718055994530941723212145817656807550013436026);
        math.NATURAL_LOG_3 = (1.09861228866810969139524523692252570464749055782275);
        math.NATURAL_LOG_10 = (2.30258509299404568401799145468436420760110148862877);
        math.NATURAL_LOG_PI = (1.14472988584940017414342735135305871164729481291531);
        math.BASE_TEN_LOG_PI = (0.49714987269413385435126828829089887365167832438044);
        math.NATURAL_LOGARITHM_BASE_INVERSE = (0.36787944117144232159552377016146086744581113103177);
        math.NATURAL_LOGARITHM_BASE_SQUARED = (7.38905609893065022723042746057500781318031557055185);
        math.GOLDEN_RATIO = ((math.SQUARE_ROOT_5 + 1.0) / 2.0);
        math.DEGREE_RATIO = (math.PI_DIV_180);
        math.RADIAN_RATIO = (math.PI_OVER_180);
        math.GRAVITY_CONSTANT = 9.81;
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (math) {
        //
        // MATH AND UNIT CONVERSION FUNCTION PROTOTYPES
        //
        math.abs = Math.abs;
        math.acos = Math.acos;
        math.asin = Math.asin;
        math.atan = Math.atan;
        math.atan2 = Math.atan2;
        math.exp = Math.exp;
        math.min = Math.min;
        math.random = Math.random;
        math.sqrt = Math.sqrt;
        math.log = Math.log;
        math.round = Math.round;
        math.floor = Math.floor;
        math.ceil = Math.ceil;
        math.sin = Math.sin;
        math.cos = Math.cos;
        math.tan = Math.tan;
        math.pow = Math.pow;
        math.max = Math.max;
        /*
        -----------------------------------------------------------------
        
        Floating Point Macros
        
        -----------------------------------------------------------------
        */
        // reinterpret a float as an int32
        /** @inline */
        math.fpBits = /** @inline */function (f) {
            return math.floor(f);
        };
        // reinterpret an int32 as a float
        /** @inline */
        math.intBits = /** @inline */function (i) {
            return i;
        };
        // return 0 or -1 based on the sign of the float
        /** @inline */
        math.fpSign = /** @inline */function (f) {
            return (f >> 31);
        };
        // extract the 8 bits of exponent as a signed integer
        // by masking out this bits, shifting down by 23,
        // and subtracting the bias value of 127
        /** @inline */
        math.fpExponent = /** @inline */function (f) {
            return ((((/*checked (origin: math)>>*/akra.math.floor((f))) & 0x7fffffff) >> 23) - 127);
        };
        // return 0 or -1 based on the sign of the exponent
        /** @inline */
        math.fpExponentSign = /** @inline */function (f) {
            return ((((((/*checked (origin: math)>>*/akra.math.floor(((f)))) & 0x7fffffff) >> 23) - 127)) >> 31);
        };
        // get the 23 bits of mantissa without the implied bit
        /** @inline */
        math.fpPureMantissa = /** @inline */function (f) {
            return ((/*checked (origin: math)>>*/akra.math.floor((f))) & 0x7fffff);
        };
        // get the 23 bits of mantissa with the implied bit replaced
        /** @inline */
        math.fpMantissa = /** @inline */function (f) {
            return ((((/*checked (origin: math)>>*/akra.math.floor(((f)))) & 0x7fffff)) | (1 << 23));
        };
        math.fpOneBits = 0x3F800000;
        // flipSign is a helper Macro to
        // invert the sign of i if flip equals -1,
        // if flip equals 0, it does nothing
        //export var flipSign = (i, flip) ((i^ flip) - flip)
        /** @inline */
        math.flipSign = /** @inline */function (i, flip) {
            return ((flip == -1) ? -i : i);
        };
        /**
        * Абсолютное значение числа
        */
        math.absoluteValue = math.abs;
        /**
        * Pow
        */
        math.raiseToPower = math.pow;
        /**
        * Число положительно?
        */
        math.isPositive = /** @inline */function (a) {
            return (a >= 0);
        };
        /**
        * Число отрицательно?
        */
        math.isNegative = /** @inline */function (a) {
            return (a < 0);
        };
        /**
        * Число одного знака?
        */
        math.sameSigns = /** @inline */function (a, b) {
            return ((((a) < 0)) == (((b) < 0)));
        };
        /**
        * Копировать знак
        */
        math.copySign = /** @inline */function (a, b) {
            return ((((b) < 0)) ? -math.absoluteValue(a) : math.absoluteValue(a));
        };
        /**
        * Растояние между а и b меньше epsilon?
        */
        math.deltaRangeTest = /** @inline */function (a, b, epsilon) {
            if (typeof epsilon === "undefined") { epsilon = 0.0000001; }
            return ((math.absoluteValue(a - b) < epsilon) ? true : false);
        };
        /**
        * Ограничивает value интервалом [low,high]
        */
        math.clamp = /** @inline */function (value, low, high) {
            return math.max(low, math.min(value, high));
        };
        /**
        * Ограничивает value интервалом [0,+Infinity]
        */
        math.clampPositive = /** @inline */function (value) {
            return (value < 0 ? 0 : value);
        };
        /**
        * Ограничивает value интервалом [-Infinity,0]
        */
        math.clampNegative = /** @inline */function (value) {
            return (value > 0 ? 0 : value);
        };
        /**
        * Ограничивает value интервалом [-1,1]
        */
        math.clampUnitSize = /** @inline */function (value) {
            return (/*checked (origin: math)>>*/akra.math.max((-1), /*checked (origin: math)>>*/akra.math.min((value), (1))));
        };
        math.sign = /** @inline */function (value) {
            return value >= 0 ? 1 : -1;
        };
        /**
        * Номер с права начиная от нуля, самого левого установленного бита
        */
        math.highestBitSet = /** @inline */function (value) {
            return value == 0 ? (null) : (value < 0 ? 31 : ((math.log(value) / math.LN2) << 0));
        };
        /**
        * Номер с права начиная от нуля, самого правого установленного бита
        */
        math.lowestBitSet = function (value) {
            var temp;
            if (value == 0) {
                return null;
            }
            for(temp = 0; temp <= 31; temp++) {
                if (value & (1 << temp)) {
                    return temp;
                }
            }
            return null;
        };
        /**
        * Является ли число степенью двойки
        */
        math.isPowerOfTwo = /** @inline */function (value) {
            return (value > 0 && ((value) == 0 ? (null) : ((value) < 0 ? 31 : ((/*checked (origin: math)>>*/akra.math.log((value)) / /*checked (origin: math)>>*/akra.math.LN2) << 0))) == math.lowestBitSet(value));
        };
        /**
        * Округление до числа наиболее близкого к степени двойки
        */
        math.nearestPowerOfTwo = function (value) {
            if (value <= 1) {
                return 1;
            }
            var highestBit = ((value) == 0 ? (null) : ((value) < 0 ? 31 : ((/*checked (origin: math)>>*/akra.math.log((value)) / /*checked (origin: math)>>*/akra.math.LN2) << 0)));
            var roundingTest = value & (1 << (highestBit - 1));
            if (roundingTest != 0) {
                ++highestBit;
            }
            return 1 << highestBit;
        };
        /**
        * Округление до следующего числа являющегося к степени двойки
        */
        math.ceilingPowerOfTwo = function (value) {
            if (value <= 1) {
                return 1;
            }
            var highestBit = ((value) == 0 ? (null) : ((value) < 0 ? 31 : ((/*checked (origin: math)>>*/akra.math.log((value)) / /*checked (origin: math)>>*/akra.math.LN2) << 0)));
            var mask = value & ((1 << highestBit) - 1);
            highestBit += mask && 1;
            return 1 << highestBit;
        };
        /**
        * Округление до предыдущего числа являющегося к степени двойки
        */
        math.floorPowerOfTwo = function (value) {
            if (value <= 1) {
                return 1;
            }
            var highestBit = ((value) == 0 ? (null) : ((value) < 0 ? 31 : ((/*checked (origin: math)>>*/akra.math.log((value)) / /*checked (origin: math)>>*/akra.math.LN2) << 0)));
            return 1 << highestBit;
        };
        /**
        * Деление по модулю
        */
        math.modulus = /** @inline */function (e, divisor) {
            return (e - math.floor(e / divisor) * divisor);
        };
        /**
        *
        */
        math.mod = math.modulus;
        /**
        * Вырвнивание числа на alignment вверх
        */
        math.alignUp = function (value, alignment) {
            var iRemainder = (((value) - /*checked (origin: math)>>*/akra.math.floor((value) / (alignment)) * (alignment)));
            if (iRemainder == 0) {
                return (value);
            }
            return (value + (alignment - iRemainder));
        };
        /**
        * Вырвнивание числа на alignment вниз
        */
        math.alignDown = function (value, alignment) {
            var remainder = (((value) - /*checked (origin: math)>>*/akra.math.floor((value) / (alignment)) * (alignment)));
            if (remainder == 0) {
                return (value);
            }
            return (value - remainder);
        };
        /**
        * пнвертировать число
        */
        math.inverse = /** @inline */function (a) {
            return 1. / a;
        };
        /**
        * log base 2
        */
        math.log2 = /** @inline */function (f) {
            return math.log(f) / math.LN2;
        };
        /**
        * Округлени числа с определенной точностью, где округляется до значащих чисел как 1/(2^precision)
        */
        math.trimFloat = /** @inline */function (f, precision) {
            return f;
        };
        /**
        * Перевод дробного в целое с усеением
        */
        math.realToInt32_chop = /** @inline */function (a) {
            return math.round(a);
        };
        /**
        * Перевод дробного в целое до меньшего
        */
        math.realToInt32_floor = /** @inline */function (a) {
            return math.floor(a);
        };
        /**
        * Перевод дробного в целое до большего
        */
        math.realToInt32_ceil = /** @inline */function (a) {
            return math.ceil(a);
        };
        /**
        * Наибольший общий делитель
        */
        math.nod = function (n, m) {
            var p = n % m;
            while(p != 0) {
                n = m;
                m = p;
                p = n % m;
            }
            return m;
        };
        /**
        * Наименьшее общее кратное
        */
        math.nok = /** @inline */function (n, m) {
            return math.abs(n * m) / math.nod(n, m);
        };
        /**
        * Greatest common devider
        */
        math.gcd = math.nod;
        /**
        * Least common multiple
        */
        math.lcm = math.nok;
        // var pMat3Stack = new Array(100);
        // var iMat3StackIndex = 0;
        math.isRealEqual = function (a, b, tolerance) {
            if (typeof tolerance === "undefined") { tolerance = 1.19209e-007; }
            if (akra.math.abs(b - a) <= tolerance) {
                return true;
            } else {
                return false;
            }
        };
        function calcPOTtextureSize(nPixels) {
            var w, h;
            var n = nPixels;
            w = Math.ceil(Math.log(n) / Math.LN2 / 2.0);
            h = Math.ceil(Math.log(n / Math.pow(2, w)) / Math.LN2);
            w = Math.pow(2, w);
            h = Math.pow(2, h);
            n = w * h;
            return [
                w, 
                h, 
                n
            ];
        }
        math.calcPOTtextureSize = calcPOTtextureSize;
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (math) {
        //    export function vec2(): IVec2;
        //    export function vec2(fValue: float): IVec2;
        //    export function vec2(v2fVec: IVec2): IVec2;
        //    export function vec2(pArray: float[]): IVec2;
        //    export function vec2(fValue1: float, fValue2: float): IVec2;
        //    export function vec2(fValue1?, fValue2?): IVec2{
        //        var nArgumentsLength: uint = arguments.length;
        //        var v2fVec: IVec2 = Vec2.stack[Vec2.stackPosition ++];
        //        if(Vec2.stackPosition == Vec2.stackSize){
        //            Vec2.stackPosition = 0;
        //        }
        //        switch(nArgumentsLength){
        //            case 1:
        //                v2fVec.set(arguments[0]);
        //                break;
        //            case 2:
        //                v2fVec.set(arguments[0], arguments[1]);
        //                break;
        //            default:
        //                v2fVec.x = v2fVec.y = 0.;
        //                break;
        //        }
        //        return v2fVec;
        //    };
        //    export function vec3(): IVec3;
        //    export function vec3(fValue: float): IVec3;
        //    export function vec3(v3fVec: IVec3): IVec3;
        //    export function vec3(pArray: float[]): IVec3;
        //    export function vec3(fValue: float, v2fVec: IVec2): IVec3;
        //    export function vec3(v2fVec: IVec2, fValue: float): IVec3;
        //    export function vec3(fValue1: float, fValue2: float, fValue3: float): IVec3;
        //    export function vec3(fValue1?, fValue2?, fValue3?): IVec3{
        //        var nArgumentsLength: uint = arguments.length;
        //        var v3fVec: IVec3 = Vec3.stack[Vec3.stackPosition ++];
        //        if(Vec3.stackPosition == Vec3.stackSize){
        //            Vec3.stackPosition = 0;
        //        }
        //        switch(nArgumentsLength){
        //            case 1:
        //                v3fVec.set(arguments[0]);
        //                break;
        //            case 2:
        //                v3fVec.set(arguments[0], arguments[1]);
        //                break;
        //            case 3:
        //                v3fVec.set(arguments[0], arguments[1], arguments[2]);
        //                break;
        //            default:
        //                v3fVec.x = v3fVec.y = v3fVec.z = 0.;
        //                break;
        //        }
        //        return v3fVec;
        //    };
        //    export function vec4(): IVec4;
        //    export function vec4(fValue: float): IVec4;
        //    export function vec4(v4fVec: IVec4): IVec4;
        //    export function vec4(pArray: float[]): IVec4;
        //    export function vec4(fValue: float, v3fVec: IVec3): IVec4;
        //    export function vec4(v2fVec1: IVec2, v2fVec2: IVec2): IVec4;
        //    export function vec4(v3fVec: IVec3, fValue: float): IVec4;
        //    export function vec4(fValue1: float, fValue2: float, v2fVec: IVec2): IVec4;
        //    export function vec4(fValue1: float, v2fVec: IVec2, fValue2: float): IVec4;
        //    export function vec4(v2fVec: IVec2 ,fValue1: float, fValue2: float): IVec4;
        //    export function vec4(fValue1: float, fValue2: float, fValue3: float, fValue4: float): IVec4;
        //    export function vec4(fValue1?, fValue2?, fValue3?, fValue4?): IVec4{
        //        var nArgumentsLength: uint = arguments.length;
        //        var v4fVec: IVec4 = Vec4.stack[Vec4.stackPosition ++];
        //        if(Vec4.stackPosition == Vec4.stackSize){
        //            Vec4.stackPosition = 0;
        //        }
        //        switch(nArgumentsLength){
        //            case 1:
        //                v4fVec.set(arguments[0]);
        //                break;
        //            case 2:
        //                v4fVec.set(arguments[0],arguments[1]);
        //                break;
        //            case 3:
        //                v4fVec.set(arguments[0],arguments[1], arguments[2]);
        //                break;
        //            case 4:
        //                v4fVec.set(arguments[0],arguments[1], arguments[2], arguments[3]);
        //                break;
        //            default:
        //                v4fVec.x = v4fVec.y = v4fVec.z = v4fVec.w = 0.;
        //                break;
        //        }
        //        return v4fVec;
        //    };
        //    export function quat4(): IQuat4;
        // export function quat4(q4fQuat: IQuat4): IQuat4;
        // export function quat4(pArray: float[]): IQuat4;
        // export function quat4(fValue: float, fW: float): IQuat4;
        // export function quat4(v3fValue: IVec3, fW: float): IQuat4;
        // export function quat4(fX: float, fY: float, fZ: float, fW: float): IQuat4;
        // export function quat4(fX?, fY?, fZ?, fW?): IQuat4{
        // 	var nArgumentsLength: uint = arguments.length;
        // 	var q4fQuat: IQuat4 = Quat4.stack[Quat4.stackPosition ++];
        // 	if(Quat4.stackPosition == Quat4.stackSize){
        //            Quat4.stackPosition = 0;
        // 	}
        // 	switch(nArgumentsLength){
        // 		case 1:
        // 			q4fQuat.set(arguments[0]);
        // 			break;
        // 		case 2:
        // 			q4fQuat.set(arguments[0], arguments[1]);
        // 			break;
        // 		case 4:
        // 			q4fQuat.set(arguments[0], arguments[1], arguments[2], arguments[3]);
        // 			break;
        // 		default:
        // 			q4fQuat.x = q4fQuat.y = q4fQuat.z = 0.;
        // 			q4fQuat.w = 1.;
        // 			break;
        // 	}
        // 	return q4fQuat;
        // };
        // export function mat3(): IMat3;
        // export function mat3(fValue: float): IMat3;
        // export function mat3(v3fVec: IVec3): IMat3;
        // export function mat3(m3fMat: IMat3): IMat3;
        // export function mat3(m4fMat: IMat4): IMat3;
        // export function mat3(pArray: float[]): IMat3;
        // export function mat3(fValue1: float, fValue2: float, fValue3: float): IMat3;
        // export function mat3(v3fVec1: IVec3, v3fVec2: IVec3, v3fVec3: IVec3): IMat3;
        // export function mat3(pArray1: float[], pArray2: float[], pArray3: float[]): IMat3;
        // export function mat3(fValue1: float, fValue2: float, fValue3: float,
        // 			fValue4: float, fValue5: float, fValue6: float,
        // 			fValue7: float, fValue8: float, fValue9: float): IMat3;
        // export function mat3(fValue1?, fValue2?, fValue3?,
        // 			fValue4?, fValue5?, fValue6?,
        // 			fValue7?, fValue8?, fValue9?): IMat3{
        // 	var nArgumentsLength: uint = arguments.length;
        // 	var m3fMat: IMat3 = Mat3.stack[Mat3.stackPosition ++];
        //        if(Mat3.stackPosition == Mat3.stackSize){
        //            Mat3.stackPosition = 0;
        // 	}
        // 	switch(nArgumentsLength){
        // 		case 1:
        // 			m3fMat.set(arguments[0]);
        // 			break;
        // 		case 3:
        // 			m3fMat.set(arguments[0], arguments[1], arguments[2]);
        // 			break;
        // 		case 9:
        // 			m3fMat.set(arguments[0], arguments[1], arguments[2],
        // 					 arguments[3], arguments[4], arguments[5],
        // 					 arguments[6], arguments[7], arguments[8]);
        // 			break;
        // 		default:
        // 			m3fMat.set(0.);
        // 			break;
        // 	}
        // 	return m3fMat;
        // };
        // export function mat4(): IMat4;
        // export function mat4(fValue: float): IMat4;
        // export function mat4(v4fVec: IVec4): IMat4;
        // export function mat4(m3fMat: IMat3, v3fTranslation?: IVec3): IMat4;
        // export function mat4(m4fMat: IMat4): IMat4;
        // export function mat4(pArray: float[]): IMat4;
        // export function mat4(pArray: Float32Array, bFlag: bool): IMat4;
        // export function mat4(fValue1: float, fValue2: float,
        // 		fValue3: float, fValue4: float): IMat4;
        // export function mat4(v4fVec1: IVec4, v4fVec2: IVec4,
        // 		v4fVec3: IVec4, v4fVec4: IVec4): IMat4;
        // export function mat4(pArray1: float[], pArray2: float[],
        // 		pArray3: float[], pArray4: float[]): IMat4;
        // export function mat4(fValue1: float, fValue2: float, fValue3: float, fValue4: float,
        // 		fValue5: float, fValue6: float, fValue7: float, fValue8: float,
        // 		fValue9: float, fValue10: float, fValue11: float, fValue12: float,
        // 		fValue13: float, fValue14: float, fValue15: float, fValue16: float): IMat4;
        // export function mat4(fValue1?, fValue2?, fValue3?, fValue4?,
        // 			fValue5?, fValue6?, fValue7?, fValue8?,
        // 			fValue9?, fValue10?, fValue11?, fValue12?,
        // 			fValue13?, fValue14?, fValue15?, fValue16?): IMat4{
        // 	var nArgumentsLength: uint = arguments.length;
        // 	var m4fMat: IMat4 = Mat4.stack[Mat4.stackPosition ++];
        //        if(Mat4.stackPosition == Mat4.stackSize){
        //            Mat4.stackPosition = 0;
        // 	}
        // 	if(nArgumentsLength === 2){
        // 		if(isBoolean(arguments[1])){
        // 			if(arguments[1]){
        // 				m4fMat.data = arguments[0];
        // 			}
        // 			else{
        // 				m4fMat.set(arguments[0]);
        // 			}
        // 		}
        // 		else{
        // 			m4fMat.set(arguments[0], arguments[1]);
        // 		}
        // 	}
        // 	else{
        // 		switch(nArgumentsLength){
        // 			case 1:
        // 				if(arguments[0] instanceof Mat3){
        // 					m4fMat.set(arguments[0],vec3(0.));
        // 				}
        // 				else{
        // 					m4fMat.set(arguments[0]);
        // 				}
        // 				break;
        // 			case 4:
        // 				m4fMat.set(arguments[0],arguments[1],arguments[2],arguments[3]);
        // 				break;
        // 			case 16:
        // 				m4fMat.set(arguments[0], arguments[1], arguments[2], arguments[3],
        // 					 arguments[4], arguments[5], arguments[6], arguments[7],
        // 					 arguments[8], arguments[9], arguments[10], arguments[11],
        // 					 arguments[12], arguments[13], arguments[14], arguments[15]);
        // 				 break;
        // 			 default:
        // 			 	break;
        // 		}
        // 	}
        // 	return m4fMat;
        // };
        function floatToFloat3(value) {
            var data = value;
            var result = math.Vec3.stackCeil.set(0.);
            if (data == 0.) {
                var signedZeroTest = 1. / value;
                if (signedZeroTest < 0.) {
                    result.x = 128.;
                }
                return result;
            }
            if (data < 0.) {
                result.x = 128.;
                data = -data;
            }
            var power = 0.;
            var counter = 0.;
            while(counter < 64.) {
                counter += 1.;
                if (data >= 2.) {
                    data = data * 0.5;
                    power += 1.;
                    if (power == 63.) {
                        counter = 65.;
                    }
                } else {
                    if (data < 1.) {
                        data = data * 2.;
                        power -= 1.;
                        if (power == -62.) {
                            counter = 65.;
                        }
                    } else {
                        counter = 65.;
                    }
                }
            }
            if (power == -62. && data < 1.) {
                power = 0.;
            } else {
                power = power + 63.;
                data = data - 1.;
            }
            result.x += power;
            data *= 256.;
            result.y = math.floor(data);
            data -= math.floor(data);
            data *= 256.;
            result.z = math.floor(data);
            return result;
        }
        math.floatToFloat3 = floatToFloat3;
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.Vec2 = akra.math.Vec2;
    akra.Vec3 = akra.math.Vec3;
    akra.Vec4 = akra.math.Vec4;
    akra.Mat3 = akra.math.Mat3;
    akra.Mat4 = akra.math.Mat4;
    akra.Quat4 = akra.math.Quat4;
    // export var vec2 = math.vec2;
    // export var vec3 = math.vec3;
    // export var vec4 = math.vec4;
    // export var quat4 = math.quat4;
    // export var mat3 = math.mat3;
    // export var mat4 = math.mat4;
    })(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var Color = (function () {
            function Color(r, g, b, a) {
                this.set.apply(this, arguments);
            }
            Object.defineProperty(Color.prototype, "html", {
                get: function () {
                    // LOG(this.r, this.g, this.b);
                    var r = akra.math.round(this.r * 255).toString(16);
                    var g = akra.math.round(this.g * 255).toString(16);
                    var b = akra.math.round(this.b * 255).toString(16);
                    r = r.length < 2 ? "0" + r : r;
                    g = g.length < 2 ? "0" + g : g;
                    b = b.length < 2 ? "0" + b : b;
                    // LOG(r, g, b);
                    return "#" + r + g + b;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "htmlRgba", {
                get: function () {
                    return "rgba(" + akra.math.floor(255 * this.r) + ", " + akra.math.floor(255 * this.g) + ", " + akra.math.floor(255 * this.b) + ", " + this.a + ")";
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "rgba", {
                get: function () {
                    var val32 = 0;
                    // Convert to 32bit pattern
                    val32 = (this.a * 255) << 24;
                    val32 += (this.b * 255) << 16;
                    val32 += (this.g * 255) << 8;
                    val32 += (this.r * 255);
                    val32 = val32 >>> 0;
                    return val32;
                },
                set: function (c) {
                    var val32 = c;
                    // Convert from 32bit pattern
                    this.a = ((val32 >> 24) & 0xFF) / 255.0;
                    this.b = ((val32 >> 16) & 0xFF) / 255.0;
                    this.g = ((val32 >> 8) & 0xFF) / 255.0;
                    this.r = (val32 & 0xFF) / 255.0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "argb", {
                get: function () {
                    var val32 = 0;
                    // Convert to 32bit pattern
                    val32 = (this.b * 255) << 24;
                    val32 += (this.g * 255) << 16;
                    val32 += (this.r * 255) << 8;
                    val32 += (this.a * 255);
                    val32 = val32 >>> 0;
                    return val32;
                },
                set: function (c) {
                    var val32 = c;
                    // Convert from 32bit pattern
                    this.b = ((val32 >> 24) & 0xFF) / 255.0;
                    this.g = ((val32 >> 16) & 0xFF) / 255.0;
                    this.r = ((val32 >> 8) & 0xFF) / 255.0;
                    this.a = (val32 & 0xFF) / 255.0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "bgra", {
                get: function () {
                    var val32 = 0;
                    // Convert to 32bit pattern
                    val32 = (this.a * 255) << 24;
                    val32 += (this.r * 255) << 16;
                    val32 += (this.g * 255) << 8;
                    val32 += (this.b * 255);
                    val32 = val32 >>> 0;
                    return val32;
                },
                set: function (c) {
                    var val32 = c;
                    // Convert from 32bit pattern
                    this.a = ((val32 >> 24) & 0xFF) / 255.0;
                    this.r = ((val32 >> 16) & 0xFF) / 255.0;
                    this.g = ((val32 >> 8) & 0xFF) / 255.0;
                    this.b = (val32 & 0xFF) / 255.0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "abgr", {
                get: function () {
                    var val32 = 0;
                    // Convert to 32bit pattern
                    val32 = (this.r * 255) << 24;
                    val32 += (this.g * 255) << 16;
                    val32 += (this.b * 255) << 8;
                    val32 += (this.a * 255);
                    val32 = val32 >>> 0;
                    return val32;
                },
                set: function (c) {
                    var val32 = c;
                    // Convert from 32bit pattern
                    this.r = ((val32 >> 24) & 0xFF) / 255.0;
                    this.g = ((val32 >> 16) & 0xFF) / 255.0;
                    this.b = ((val32 >> 8) & 0xFF) / 255.0;
                    this.a = (val32 & 0xFF) / 255.0;
                },
                enumerable: true,
                configurable: true
            });
            Color.prototype.set = function (r, g, b, a) {
                switch(arguments.length) {
                    case 0:
                        this.r = this.g = this.b = 0.;
                        this.a = 1.;
                        break;
                    case 1:
                        if ((typeof (arguments[0]) === "number")) {
                            this.r = this.g = this.b = r;
                            this.a = 1.;
                        } else if (((arguments[0].buffer) !== undefined)) {
                            var c = arguments[0];
                            this.r = c[0];
                            this.g = c[1];
                            this.b = c[2];
                            this.a = c[3];
                        } else {
                            var v = arguments[0];
                            this.r = v.r;
                            this.g = v.g;
                            this.b = v.b;
                            this.a = v.a;
                        }
                        break;
                    case 2:
                        this.r = this.g = this.b = r;
                        this.a = g;
                        break;
                    case 3:
                    case 4:
                        this.r = r;
                        this.g = g;
                        this.b = b;
                        this.a = ((a) !== undefined) ? a : 1.;
                        break;
                }
                return this;
            };
            Color.prototype.saturate = function () {
                if (this.r < 0.) {
                    this.r = 0.;
                } else if (this.r > 1.) {
                    this.r = 1.;
                }
                if (this.g < 0.) {
                    this.g = 0.;
                } else if (this.g > 1.) {
                    this.g = 1.;
                }
                if (this.b < 0.) {
                    this.b = 0.;
                } else if (this.b > 1.) {
                    this.b = 1.;
                }
                if (this.a < 0.) {
                    this.a = 0.;
                } else if (this.a > 1.) {
                    this.a = 1.;
                }
                return this;
            };
            Color.prototype.saturateCopy = /** As saturate, except that this colour value is unaffected and
            the saturated colour value is returned as a copy. */
            function () {
                var ret = new Color(this);
                ret.saturate();
                return ret;
            };
            Color.prototype.add = function (cColor, ppDest) {
                if (typeof ppDest === "undefined") { ppDest = new Color(); }
                ppDest.r = this.r + cColor.r;
                ppDest.g = this.g + cColor.g;
                ppDest.b = this.b + cColor.b;
                ppDest.a = this.a + cColor.a;
                return ppDest;
            };
            Color.prototype.subtract = function (cColor, ppDest) {
                if (typeof ppDest === "undefined") { ppDest = new Color(); }
                ppDest.r = this.r - cColor.r;
                ppDest.g = this.g - cColor.g;
                ppDest.b = this.b - cColor.b;
                ppDest.a = this.a - cColor.a;
                return ppDest;
            };
            Color.prototype.multiply = function (fScalar, ppDest) {
                if (typeof ppDest === "undefined") { ppDest = new Color(); }
                if ((typeof (fScalar) === "number")) {
                    var f = fScalar;
                    ppDest.r = this.r * f;
                    ppDest.g = this.g * f;
                    ppDest.b = this.b * f;
                    ppDest.a = this.a * f;
                } else {
                    var c = arguments[0];
                    ppDest.r = this.r * c.r;
                    ppDest.g = this.g * c.g;
                    ppDest.b = this.b * c.b;
                    ppDest.a = this.a * c.a;
                }
                return ppDest;
            };
            Color.prototype.divide = function (fScalar, ppDest) {
                if (typeof ppDest === "undefined") { ppDest = new Color(); }
                if ((typeof (fScalar) === "number")) {
                    var f = fScalar;
                    ppDest.r = this.r / f;
                    ppDest.g = this.g / f;
                    ppDest.b = this.b / f;
                    ppDest.a = this.a / f;
                } else {
                    var c = arguments[0];
                    ppDest.r = this.r / c.r;
                    ppDest.g = this.g / c.g;
                    ppDest.b = this.b / c.b;
                    ppDest.a = this.a / c.a;
                }
                return ppDest;
            };
            Color.prototype.setHSB = function (fHue, fSaturation, fBrightness) {
                // wrap hue
                if (fHue > 1.0) {
                    fHue -= fHue;
                } else if (fHue < 0.0) {
                    fHue += fHue + 1;
                }
                // clamp saturation / fBrightness
                fSaturation = akra.math.min(fSaturation, 1.0);
                fSaturation = akra.math.max(fSaturation, 0.0);
                fBrightness = akra.math.min(fBrightness, 1.0);
                fBrightness = akra.math.max(fBrightness, 0.0);
                if (fBrightness == 0.0) {
                    // early exit, this has to be black
                    this.r = this.g = this.b = 0.0;
                    return;
                }
                if (fSaturation == 0.0) {
                    // early exit, this has to be grey
                    this.r = this.g = this.b = fBrightness;
                    return;
                }
                var fHueDomain = fHue * 6.0;
                if (fHueDomain >= 6.0) {
                    // wrap around, and allow mathematical errors
                    fHueDomain = 0.0;
                }
                var domain = fHueDomain;
                var f1 = fBrightness * (1 - fSaturation);
                var f2 = fBrightness * (1 - fSaturation * (fHueDomain - domain));
                var f3 = fBrightness * (1 - fSaturation * (1 - (fHueDomain - domain)));
                switch(domain) {
                    case 0:
                        // red domain; green ascends
                        this.r = fBrightness;
                        this.g = f3;
                        this.b = f1;
                        break;
                    case 1:
                        // yellow domain; red descends
                        this.r = f2;
                        this.g = fBrightness;
                        this.b = f1;
                        break;
                    case 2:
                        // green domain; blue ascends
                        this.r = f1;
                        this.g = fBrightness;
                        this.b = f3;
                        break;
                    case 3:
                        // cyan domain; green descends
                        this.r = f1;
                        this.g = f2;
                        this.b = fBrightness;
                        break;
                    case 4:
                        // blue domain; red ascends
                        this.r = f3;
                        this.g = f1;
                        this.b = fBrightness;
                        break;
                    case 5:
                        // magenta domain; blue descends
                        this.r = fBrightness;
                        this.g = f1;
                        this.b = f2;
                        break;
                }
                return this;
            };
            Color.prototype.getHSB = function (pHsb) {
                if (typeof pHsb === "undefined") { pHsb = [
                    0., 
                    0., 
                    0.
                ]; }
                var vMin = akra.math.min(this.r, akra.math.min(this.g, this.b));
                var vMax = akra.math.max(this.r, akra.math.max(this.g, this.b));
                var delta = vMax - vMin;
                var brightness = vMax;
                var hue = 0.;
                var saturation;
                if (akra.math.isRealEqual(delta, 0.0, 1e-6)) {
                    // grey
                    hue = 0.;
                    saturation = 0.;
                } else {
                    // a colour
                    saturation = delta / vMax;
                    var deltaR = (((vMax - this.r) / 6.0) + (delta / 2.0)) / delta;
                    var deltaG = (((vMax - this.g) / 6.0) + (delta / 2.0)) / delta;
                    var deltaB = (((vMax - this.b) / 6.0) + (delta / 2.0)) / delta;
                    if (akra.math.isRealEqual(this.r, vMax)) {
                        hue = deltaB - deltaG;
                    } else if (akra.math.isRealEqual(this.g, vMax)) {
                        hue = 0.3333333 + deltaR - deltaB;
                    } else if (akra.math.isRealEqual(this.b, vMax)) {
                        hue = 0.6666667 + deltaG - deltaR;
                    }
                    if (hue < 0.0) {
                        hue += 1.0;
                    }
                    if (hue > 1.0) {
                        hue -= 1.0;
                    }
                }
                pHsb[0] = hue;
                pHsb[1] = saturation;
                pHsb[2] = brightness;
                return pHsb;
            };
            Color.prototype.toString = function () {
                return "{R: " + this.r + ", G: " + this.g + ", B: " + this.b + ", A: " + this.a + "} " + "( 0x" + this.rgba.toString(16) + " )";
            };
            Color.toFloat32Array = function toFloat32Array(pValue) {
                var pArr = new Float32Array(4);
                pArr[0] = pValue.r;
                pArr[1] = pValue.g;
                pArr[2] = pValue.b;
                pArr[3] = pValue.a;
                return pArr;
            };
            Color.BLACK = new Color(0);
            Color.WHITE = new Color(0xFF, 0xFF, 0xFF);
            Color.ZERO = new Color(0., 0., 0., 0.);
            Color.isEqual = function isEqual(c1, c2) {
                return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b && c1.a === c2.a;
            };
            Color.ALICE_BLUE = new Color(0xF0 / 255., 0xF8 / 255., 0xFF / 255.);
            Color.ANTIQUE_WHITE = new Color(0xFA / 255., 0xEB / 255., 0xD7 / 255.);
            Color.AQUA = new Color(0x00 / 255., 0xFF / 255., 0xFF / 255.);
            Color.AQUA_MARINE = new Color(0x7F / 255., 0xFF / 255., 0xD4 / 255.);
            Color.AZURE = new Color(0xF0 / 255., 0xFF / 255., 0xFF / 255.);
            Color.BEIGE = new Color(0xF5 / 255., 0xF5 / 255., 0xDC / 255.);
            Color.BISQUE = new Color(0xFF / 255., 0xE4 / 255., 0xC4 / 255.);
            Color.BLANCHED_ALMOND = new Color(0xFF / 255., 0xEB / 255., 0xCD / 255.);
            Color.BLUE = new Color(0x00 / 255., 0x00 / 255., 0xFF / 255.);
            Color.BLUE_VIOLET = new Color(0x8A / 255., 0x2B / 255., 0xE2 / 255.);
            Color.BROWN = new Color(0xA5 / 255., 0x2A / 255., 0x2A / 255.);
            Color.BURLY_WOOD = new Color(0xDE / 255., 0xB8 / 255., 0x87 / 255.);
            Color.CADET_BLUE = new Color(0x5F / 255., 0x9E / 255., 0xA0 / 255.);
            Color.CHARTREUSE = new Color(0x7F / 255., 0xFF / 255., 0x00 / 255.);
            Color.CHOCOLATE = new Color(0xD2 / 255., 0x69 / 255., 0x1E / 255.);
            Color.CORAL = new Color(0xFF / 255., 0x7F / 255., 0x50 / 255.);
            Color.CORNFLOWER_BLUE = new Color(0x64 / 255., 0x95 / 255., 0xED / 255.);
            Color.CORNSILK = new Color(0xFF / 255., 0xF8 / 255., 0xDC / 255.);
            Color.CRIMSON = new Color(0xDC / 255., 0x14 / 255., 0x3C / 255.);
            Color.CYAN = new Color(0x00 / 255., 0xFF / 255., 0xFF / 255.);
            Color.DARK_BLUE = new Color(0x00 / 255., 0x00 / 255., 0x8B / 255.);
            Color.DARK_CYAN = new Color(0x00 / 255., 0x8B / 255., 0x8B / 255.);
            Color.DARK_GOLDEN_ROD = new Color(0xB8 / 255., 0x86 / 255., 0x0B / 255.);
            Color.DARK_GRAY = new Color(0xA9 / 255., 0xA9 / 255., 0xA9 / 255.);
            Color.DARK_GREEN = new Color(0x00 / 255., 0x64 / 255., 0x00 / 255.);
            Color.DARK_KHAKI = new Color(0xBD / 255., 0xB7 / 255., 0x6B / 255.);
            Color.DARK_MAGENTA = new Color(0x8B / 255., 0x00 / 255., 0x8B / 255.);
            Color.DARK_OLIVE_GREEN = new Color(0x55 / 255., 0x6B / 255., 0x2F / 255.);
            Color.DARK_ORANGE = new Color(0xFF / 255., 0x8C / 255., 0x00 / 255.);
            Color.DARK_ORCHID = new Color(0x99 / 255., 0x32 / 255., 0xCC / 255.);
            Color.DARK_RED = new Color(0x8B / 255., 0x00 / 255., 0x00 / 255.);
            Color.DARK_SALMON = new Color(0xE9 / 255., 0x96 / 255., 0x7A / 255.);
            Color.DARK_SEA_GREEN = new Color(0x8F / 255., 0xBC / 255., 0x8F / 255.);
            Color.DARK_SLATE_BLUE = new Color(0x48 / 255., 0x3D / 255., 0x8B / 255.);
            Color.DARK_SLATE_GRAY = new Color(0x2F / 255., 0x4F / 255., 0x4F / 255.);
            Color.DARK_TURQUOISE = new Color(0x00 / 255., 0xCE / 255., 0xD1 / 255.);
            Color.DARK_VIOLET = new Color(0x94 / 255., 0x00 / 255., 0xD3 / 255.);
            Color.DEEP_PINK = new Color(0xFF / 255., 0x14 / 255., 0x93 / 255.);
            Color.DEEP_SKY_BLUE = new Color(0x00 / 255., 0xBF / 255., 0xFF / 255.);
            Color.DIM_GRAY = new Color(0x69 / 255., 0x69 / 255., 0x69 / 255.);
            Color.DIM_GREY = new Color(0x69 / 255., 0x69 / 255., 0x69 / 255.);
            Color.DODGER_BLUE = new Color(0x1E / 255., 0x90 / 255., 0xFF / 255.);
            Color.FIRE_BRICK = new Color(0xB2 / 255., 0x22 / 255., 0x22 / 255.);
            Color.FLORAL_WHITE = new Color(0xFF / 255., 0xFA / 255., 0xF0 / 255.);
            Color.FOREST_GREEN = new Color(0x22 / 255., 0x8B / 255., 0x22 / 255.);
            Color.FUCHSIA = new Color(0xFF / 255., 0x00 / 255., 0xFF / 255.);
            Color.GAINSBORO = new Color(0xDC / 255., 0xDC / 255., 0xDC / 255.);
            Color.GHOST_WHITE = new Color(0xF8 / 255., 0xF8 / 255., 0xFF / 255.);
            Color.GOLD = new Color(0xFF / 255., 0xD7 / 255., 0x00 / 255.);
            Color.GOLDEN_ROD = new Color(0xDA / 255., 0xA5 / 255., 0x20 / 255.);
            Color.GRAY = new Color(0x80 / 255., 0x80 / 255., 0x80 / 255.);
            Color.GREEN = new Color(0x00 / 255., 0x80 / 255., 0x00 / 255.);
            Color.GREEN_YELLOW = new Color(0xAD / 255., 0xFF / 255., 0x2F / 255.);
            Color.HONEY_DEW = new Color(0xF0 / 255., 0xFF / 255., 0xF0 / 255.);
            Color.HOT_PINK = new Color(0xFF / 255., 0x69 / 255., 0xB4 / 255.);
            Color.INDIAN_RED = new Color(0xCD / 255., 0x5C / 255., 0x5C / 255.);
            Color.INDIGO = new Color(0x4B / 255., 0x00 / 255., 0x82 / 255.);
            Color.IVORY = new Color(0xFF / 255., 0xFF / 255., 0xF0 / 255.);
            Color.KHAKI = new Color(0xF0 / 255., 0xE6 / 255., 0x8C / 255.);
            Color.LAVENDER = new Color(0xE6 / 255., 0xE6 / 255., 0xFA / 255.);
            Color.LAVENDER_BLUSH = new Color(0xFF / 255., 0xF0 / 255., 0xF5 / 255.);
            Color.LAWN_GREEN = new Color(0x7C / 255., 0xFC / 255., 0x00 / 255.);
            Color.LEMON_CHIFFON = new Color(0xFF / 255., 0xFA / 255., 0xCD / 255.);
            Color.LIGHT_BLUE = new Color(0xAD / 255., 0xD8 / 255., 0xE6 / 255.);
            Color.LIGHT_CORAL = new Color(0xF0 / 255., 0x80 / 255., 0x80 / 255.);
            Color.LIGHT_CYAN = new Color(0xE0 / 255., 0xFF / 255., 0xFF / 255.);
            Color.LIGHT_GOLDEN_ROD_YELLOW = new Color(0xFA / 255., 0xFA / 255., 0xD2 / 255.);
            Color.LIGHT_GRAY = new Color(0xD3 / 255., 0xD3 / 255., 0xD3 / 255.);
            Color.LIGHT_GREEN = new Color(0x90 / 255., 0xEE / 255., 0x90 / 255.);
            Color.LIGHT_PINK = new Color(0xFF / 255., 0xB6 / 255., 0xC1 / 255.);
            Color.LIGHT_SALMON = new Color(0xFF / 255., 0xA0 / 255., 0x7A / 255.);
            Color.LIGHT_SEA_GREEN = new Color(0x20 / 255., 0xB2 / 255., 0xAA / 255.);
            Color.LIGHT_SKY_BLUE = new Color(0x87 / 255., 0xCE / 255., 0xFA / 255.);
            Color.LIGHT_SLATE_GRAY = new Color(0x77 / 255., 0x88 / 255., 0x99 / 255.);
            Color.LIGHT_STEEL_BLUE = new Color(0xB0 / 255., 0xC4 / 255., 0xDE / 255.);
            Color.LIGHT_YELLOW = new Color(0xFF / 255., 0xFF / 255., 0xE0 / 255.);
            Color.LIME = new Color(0x00 / 255., 0xFF / 255., 0x00 / 255.);
            Color.LIME_GREEN = new Color(0x32 / 255., 0xCD / 255., 0x32 / 255.);
            Color.LINEN = new Color(0xFA / 255., 0xF0 / 255., 0xE6 / 255.);
            Color.MAGENTA = new Color(0xFF / 255., 0x00 / 255., 0xFF / 255.);
            Color.MAROON = new Color(0x80 / 255., 0x00 / 255., 0x00 / 255.);
            Color.MEDIUM_AQUA_MARINE = new Color(0x66 / 255., 0xCD / 255., 0xAA / 255.);
            Color.MEDIUM_BLUE = new Color(0x00 / 255., 0x00 / 255., 0xCD / 255.);
            Color.MEDIUM_ORCHID = new Color(0xBA / 255., 0x55 / 255., 0xD3 / 255.);
            Color.MEDIUM_PURPLE = new Color(0x93 / 255., 0x70 / 255., 0xDB / 255.);
            Color.MEDIUM_SEA_GREEN = new Color(0x3C / 255., 0xB3 / 255., 0x71 / 255.);
            Color.MEDIUM_SLATE_BLUE = new Color(0x7B / 255., 0x68 / 255., 0xEE / 255.);
            Color.MEDIUM_SPRING_GREEN = new Color(0x00 / 255., 0xFA / 255., 0x9A / 255.);
            Color.MEDIUM_TURQUOISE = new Color(0x48 / 255., 0xD1 / 255., 0xCC / 255.);
            Color.MEDIUM_VIOLET_RED = new Color(0xC7 / 255., 0x15 / 255., 0x85 / 255.);
            Color.MIDNIGHT_BLUE = new Color(0x19 / 255., 0x19 / 255., 0x70 / 255.);
            Color.MINT_CREAM = new Color(0xF5 / 255., 0xFF / 255., 0xFA / 255.);
            Color.MISTY_ROSE = new Color(0xFF / 255., 0xE4 / 255., 0xE1 / 255.);
            Color.MOCCASIN = new Color(0xFF / 255., 0xE4 / 255., 0xB5 / 255.);
            Color.NAVAJO_WHITE = new Color(0xFF / 255., 0xDE / 255., 0xAD / 255.);
            Color.NAVY = new Color(0x00 / 255., 0x00 / 255., 0x80 / 255.);
            Color.OLD_LACE = new Color(0xFD / 255., 0xF5 / 255., 0xE6 / 255.);
            Color.OLIVE = new Color(0x80 / 255., 0x80 / 255., 0x00 / 255.);
            Color.OLIVE_DRAB = new Color(0x6B / 255., 0x8E / 255., 0x23 / 255.);
            Color.ORANGE = new Color(0xFF / 255., 0xA5 / 255., 0x00 / 255.);
            Color.ORANGE_RED = new Color(0xFF / 255., 0x45 / 255., 0x00 / 255.);
            Color.ORCHID = new Color(0xDA / 255., 0x70 / 255., 0xD6 / 255.);
            Color.PALE_GOLDEN_ROD = new Color(0xEE / 255., 0xE8 / 255., 0xAA / 255.);
            Color.PALE_GREEN = new Color(0x98 / 255., 0xFB / 255., 0x98 / 255.);
            Color.PALE_TURQUOISE = new Color(0xAF / 255., 0xEE / 255., 0xEE / 255.);
            Color.PALE_VIOLET_RED = new Color(0xDB / 255., 0x70 / 255., 0x93 / 255.);
            Color.PAPAYA_WHIP = new Color(0xFF / 255., 0xEF / 255., 0xD5 / 255.);
            Color.PEACH_PUFF = new Color(0xFF / 255., 0xDA / 255., 0xB9 / 255.);
            Color.PERU = new Color(0xCD / 255., 0x85 / 255., 0x3F / 255.);
            Color.PINK = new Color(0xFF / 255., 0xC0 / 255., 0xCB / 255.);
            Color.PLUM = new Color(0xDD / 255., 0xA0 / 255., 0xDD / 255.);
            Color.POWDER_BLUE = new Color(0xB0 / 255., 0xE0 / 255., 0xE6 / 255.);
            Color.PURPLE = new Color(0x80 / 255., 0x00 / 255., 0x80 / 255.);
            Color.RED = new Color(0xFF / 255., 0x00 / 255., 0x00 / 255.);
            Color.ROSY_BROWN = new Color(0xBC / 255., 0x8F / 255., 0x8F / 255.);
            Color.ROYAL_BLUE = new Color(0x41 / 255., 0x69 / 255., 0xE1 / 255.);
            Color.SADDLE_BROWN = new Color(0x8B / 255., 0x45 / 255., 0x13 / 255.);
            Color.SALMON = new Color(0xFA / 255., 0x80 / 255., 0x72 / 255.);
            Color.SANDY_BROWN = new Color(0xF4 / 255., 0xA4 / 255., 0x60 / 255.);
            Color.SEA_GREEN = new Color(0x2E / 255., 0x8B / 255., 0x57 / 255.);
            Color.SEA_SHELL = new Color(0xFF / 255., 0xF5 / 255., 0xEE / 255.);
            Color.SIENNA = new Color(0xA0 / 255., 0x52 / 255., 0x2D / 255.);
            Color.SILVER = new Color(0xC0 / 255., 0xC0 / 255., 0xC0 / 255.);
            Color.SKY_BLUE = new Color(0x87 / 255., 0xCE / 255., 0xEB / 255.);
            Color.SLATE_BLUE = new Color(0x6A / 255., 0x5A / 255., 0xCD / 255.);
            Color.SLATE_GRAY = new Color(0x70 / 255., 0x80 / 255., 0x90 / 255.);
            Color.SNOW = new Color(0xFF / 255., 0xFA / 255., 0xFA / 255.);
            Color.SPRING_GREEN = new Color(0x00 / 255., 0xFF / 255., 0x7F / 255.);
            Color.STEEL_BLUE = new Color(0x46 / 255., 0x82 / 255., 0xB4 / 255.);
            Color.TAN = new Color(0xD2 / 255., 0xB4 / 255., 0x8C / 255.);
            Color.TEAL = new Color(0x00 / 255., 0x80 / 255., 0x80 / 255.);
            Color.THISTLE = new Color(0xD8 / 255., 0xBF / 255., 0xD8 / 255.);
            Color.TOMATO = new Color(0xFF / 255., 0x63 / 255., 0x47 / 255.);
            Color.TURQUOISE = new Color(0x40 / 255., 0xE0 / 255., 0xD0 / 255.);
            Color.VIOLET = new Color(0xEE / 255., 0x82 / 255., 0xEE / 255.);
            Color.WHEAT = new Color(0xF5 / 255., 0xDE / 255., 0xB3 / 255.);
            Color.WHITE_SMOKE = new Color(0xF5 / 255., 0xF5 / 255., 0xF5 / 255.);
            Color.YELLOW = new Color(0xFF / 255., 0xFF / 255., 0x00 / 255.);
            Color.YELLOW_GREEN = new Color(0x9A / 255., 0xCD / 255., 0x32 / 255.);
            Object.defineProperty(Color, "stackCeil", {
                get: function () {
                    Color.stackPosition = Color.stackPosition === Color.stackSize - 1 ? 0 : Color.stackPosition;
                    return Color.stack[Color.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            Color.stackSize = 20;
            Color.stackPosition = 0;
            Color.stack = (function () {
                var pStack = new Array(Color.stackSize);
                for(var i = 0; i < Color.stackSize; i++) {
                    pStack[i] = new Color();
                }
                return pStack;
            })();
            return Color;
        })();
        util.Color = Color;        
        var pVariousColors = [
            "BLUE", 
            "BLUE_VIOLET", 
            "BROWN", 
            "CADET_BLUE", 
            "CHARTREUSE", 
            "CRIMSON", 
            "CYAN", 
            "DEEP_PINK", 
            "DEEP_SKY_BLUE", 
            "DODGER_BLUE", 
            "FIRE_BRICK", 
            "FUCHSIA", 
            "GOLD", 
            "GREEN", 
            "GREEN_YELLOW", 
            "HOT_PINK", 
            "LAWN_GREEN", 
            "LIME", 
            "LIME_GREEN", 
            "MAGENTA", 
            "MEDIUM_BLUE", 
            "MEDIUM_ORCHID", 
            "MEDIUM_SPRING_GREEN", 
            "MEDIUM_VIOLET_RED", 
            "ORANGE", 
            "ORANGE_RED", 
            "PURPLE", 
            "RED", 
            "SPRING_GREEN", 
            "STEEL_BLUE", 
            "TOMATO", 
            "TURQUOISE", 
            "VIOLET", 
            "WHEAT", 
            "YELLOW", 
            "YELLOW_GREEN"
        ];
        var iVariousColor = 0;
        function randomColor(bVarious) {
            if (typeof bVarious === "undefined") { bVarious = false; }
            if (!bVarious) {
                return new Color(Math.random(), Math.random(), Math.random(), 1.);
            }
            if (iVariousColor === pVariousColors.length) {
                iVariousColor = 0;
            }
            return (Color)[pVariousColors[iVariousColor++]] || Color.WHITE;
        }
        util.randomColor = randomColor;
        /** @inline */function colorToVec4(pValue) {
            return akra.Vec4.stackCeil.set(pValue.r, pValue.g, pValue.b, pValue.a);
        }
        util.colorToVec4 = colorToVec4;
        function color() {
            var argv = [];
            for (var _i = 0; _i < (arguments.length - 0); _i++) {
                argv[_i] = arguments[_i + 0];
            }
            var pColor = Color.stackCeil;
            return pColor.set.apply(pColor, arguments);
        }
        util.color = color;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.Color = akra.util.Color;
    akra.color = akra.util.color;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (material) {
        var Material = (function () {
            function Material(sName, pMat) {
                if (typeof sName === "undefined") { sName = null; }
                this.name = null;
                this.diffuse = new akra.Color(.5);
                this.ambient = new akra.Color(.5);
                this.specular = new akra.Color(.5);
                this.emissive = new akra.Color(.5);
                this.shininess = 50.;
                this.name = sName;
                if (((pMat) != null)) {
                    this.set(pMat);
                }
            }
            Material.prototype.set = function (pMat) {
                //this.name = pMat.name;
                this.diffuse.set(pMat.diffuse);
                this.ambient.set(pMat.ambient);
                this.specular.set(pMat.specular);
                this.emissive.set(pMat.emissive);
                this.shininess = pMat.shininess;
                return this;
            };
            Material.prototype.isEqual = function (pMat) {
                return akra.Color.isEqual(this.diffuse, pMat.diffuse) && akra.Color.isEqual(this.ambient, pMat.ambient) && akra.Color.isEqual(this.specular, pMat.specular) && akra.Color.isEqual(this.emissive, pMat.emissive) && this.shininess === pMat.shininess;
            };
            Material.prototype.toString = function () {
                var s = "\nMATERIAL - " + this.name + "\n";
                s += "------------------------------------\n";
                s += "diffuse:   " + this.diffuse.toString() + "\n";
                s += "ambient:   " + this.ambient.toString() + "\n";
                s += "specular:  " + this.ambient.toString() + "\n";
                s += "emissive:  " + this.emissive.toString() + "\n";
                s += "shininess: " + this.shininess + "\n";
                return s;
            };
            return Material;
        })();
        material.Material = Material;        
        var FlexMaterial = (function () {
            function FlexMaterial(sName, pData) {
                this.name = null;
                this._pData = pData;
                this.name = sName;
            }
            Object.defineProperty(FlexMaterial.prototype, "diffuse", {
                get: /** @inline */function () {
                    return new akra.Color(this._pData.getTypedData(akra.DeclUsages.DIFFUSE, 0, 1));
                },
                set: /** @inline */function (pValue) {
                    this._pData.setData(akra.Color.toFloat32Array(pValue), akra.DeclUsages.DIFFUSE);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(FlexMaterial.prototype, "ambient", {
                get: /** @inline */function () {
                    return new akra.Color(this._pData.getTypedData(akra.DeclUsages.AMBIENT, 0, 1));
                },
                set: /** @inline */function (pValue) {
                    this._pData.setData(akra.Color.toFloat32Array(pValue), akra.DeclUsages.AMBIENT);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(FlexMaterial.prototype, "specular", {
                get: /** @inline */function () {
                    return new akra.Color(this._pData.getTypedData(akra.DeclUsages.SPECULAR, 0, 1));
                },
                set: /** @inline */function (pValue) {
                    this._pData.setData(akra.Color.toFloat32Array(pValue), akra.DeclUsages.SPECULAR);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(FlexMaterial.prototype, "emissive", {
                get: /** @inline */function () {
                    return new akra.Color(this._pData.getTypedData(akra.DeclUsages.EMISSIVE, 0, 1));
                },
                set: /** @inline */function (pValue) {
                    this._pData.setData(akra.Color.toFloat32Array(pValue), akra.DeclUsages.EMISSIVE);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(FlexMaterial.prototype, "shininess", {
                get: /** @inline */function () {
                    return this._pData.getTypedData(akra.DeclUsages.SHININESS, 0, 1)[0];
                },
                set: /** @inline */function (pValue) {
                    this._pData.setData(new Float32Array([
                        pValue
                    ]), akra.DeclUsages.SHININESS);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(FlexMaterial.prototype, "data", {
                get: /** @inline */function () {
                    return this._pData;
                },
                enumerable: true,
                configurable: true
            });
            FlexMaterial.prototype.set = function (pMat) {
                //this.name =
                ((this)._pData.setData(/*checked (origin: akra)>>*/akra.Color.toFloat32Array((pMat.diffuse)), /*checked (origin: akra)>>*/akra.DeclUsages.DIFFUSE));
                ((this)._pData.setData(/*checked (origin: akra)>>*/akra.Color.toFloat32Array((pMat.ambient)), /*checked (origin: akra)>>*/akra.DeclUsages.AMBIENT));
                ((this)._pData.setData(/*checked (origin: akra)>>*/akra.Color.toFloat32Array((pMat.specular)), /*checked (origin: akra)>>*/akra.DeclUsages.SPECULAR));
                ((this)._pData.setData(/*checked (origin: akra)>>*/akra.Color.toFloat32Array((pMat.emissive)), /*checked (origin: akra)>>*/akra.DeclUsages.EMISSIVE));
                ((this)._pData.setData(new Float32Array([
(pMat.shininess)
]), /*checked (origin: akra)>>*/akra.DeclUsages.SHININESS));
                return this;
            };
            FlexMaterial.prototype.isEqual = function (pMat) {
                return akra.Color.isEqual(this.diffuse, pMat.diffuse) && akra.Color.isEqual(this.ambient, pMat.ambient) && akra.Color.isEqual(this.specular, pMat.specular) && akra.Color.isEqual(this.emissive, pMat.emissive) && ((this)._pData.getTypedData(/*checked (origin: akra)>>*/akra.DeclUsages.SHININESS, 0, 1)[0]) === pMat.shininess;
            };
            FlexMaterial.prototype.toString = function () {
                var s = "\nFLEX MATERIAL - " + this.name + "\n";
                s += "------------------------------------\n";
                s += "diffuse:   " + this.diffuse.toString() + "\n";
                s += "ambient:   " + this.ambient.toString() + "\n";
                s += "specular:  " + this.ambient.toString() + "\n";
                s += "emissive:  " + this.emissive.toString() + "\n";
                s += "shininess: " + this.shininess + "\n";
                return s;
            };
            return FlexMaterial;
        })();        
        /**@const*/ material.VERTEX_DECL = akra.createVertexDeclaration([
            ({
count: (17),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (/*checked (origin: akra)>>*/akra.DeclUsages.MATERIAL),
offset: (/*checked (origin: akra)>>*/akra.MAX_INT32)
}), 
            ({
count: (4),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (/*checked (origin: akra)>>*/akra.DeclUsages.DIFFUSE),
offset: (0)
}), 
            ({
count: (4),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (/*checked (origin: akra)>>*/akra.DeclUsages.AMBIENT),
offset: (16)
}), 
            ({
count: (4),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (/*checked (origin: akra)>>*/akra.DeclUsages.SPECULAR),
offset: (32)
}), 
            ({
count: (4),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (/*checked (origin: akra)>>*/akra.DeclUsages.EMISSIVE),
offset: (48)
}), 
            ({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (/*checked (origin: akra)>>*/akra.DeclUsages.SHININESS),
offset: (64)
})
        ]);
        /**@const*/ material.DEFAULT = new Material();
        function create(sName, pMat) {
            if (typeof sName === "undefined") { sName = null; }
            if (typeof pMat === "undefined") { pMat = null; }
            return new Material(sName, pMat);
        }
        material.create = create;
        function _createFlex(sName, pData) {
            return new FlexMaterial(sName, pData);
        }
        material._createFlex = _createFlex;
    })(akra.material || (akra.material = {}));
    var material = akra.material;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.Material = akra.material.Material;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var SurfaceMaterial = (function (_super) {
                    __extends(SurfaceMaterial, _super);
                    function SurfaceMaterial() {
                                        _super.call(this);
                        /**@protected*/ this._pMaterial = new akra.Material();
                        /**@protected*/ this._nTotalTextures = 0;
                        /**@protected*/ this._iTextureFlags = 0;
                        /**@protected*/ this._iTextureMatrixFlags = 0;
                        /**@protected*/ this._pTextures = new Array(SurfaceMaterial.MAX_TEXTURES_PER_SURFACE);
                        /**@protected*/ this._pTexcoords = new Array(SurfaceMaterial.MAX_TEXTURES_PER_SURFACE);
                        /**@protected*/ this._pTextureMatrices = new Array(SurfaceMaterial.MAX_TEXTURES_PER_SURFACE);
                        //For acceleration of composer
                        /**@protected*/ this._sLastHash = "";
                        /**@protected*/ this._isNeedToUpdateHash = true;
                        for(var i = 0; i < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE; ++i) {
                            this._pTexcoords[i] = i;
                        }
                    }
                    Object.defineProperty(SurfaceMaterial.prototype, "totalTextures", {
                        get: /** @inline */function () {
                            return this._nTotalTextures;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SurfaceMaterial.prototype, "material", {
                        get: /** @inline */function () {
                            return this._pMaterial;
                        },
                        set: /** @inline */function (pMaterial) {
                            this._pMaterial.set(pMaterial);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SurfaceMaterial.prototype, "textureFlags", {
                        get: /** @inline */function () {
                            return this._iTextureFlags;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SurfaceMaterial.prototype, "textureMatrixFlags", {
                        get: /** @inline */function () {
                            return this._iTextureMatrixFlags;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    SurfaceMaterial.prototype.createResource = function () {
                        /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.notifyLoaded();
                        return _super.prototype.createResource.call(this);
                    };
                    SurfaceMaterial.prototype.setTexture = function (iIndex, texture, iTexcoord) {
                        if (typeof iTexcoord === "undefined") { iTexcoord = 0; }
                        //LOG(iIndex, pTexture, iTexcoord);
                         {
                            akra.logger.setSourceLocation("resources/SurfaceMaterial.ts", 48);
                            akra.logger.assert(iIndex < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE, "invalid texture slot");
                        }
                        ;
                        var pRmgr = (((((this).pResourcePool)).pManager));
                        var pTexture = null;
                        this._pTexcoords[iIndex] = iTexcoord;
                        if (iIndex !== iTexcoord) {
                            this._isNeedToUpdateHash = true;
                        }
                        if ((typeof (texture) === "string")) {
                            pTexture = this._pTextures[iIndex];
                            if (pTexture) {
                                //realise first
                                if (pTexture.release() == 0) {
                                    this._pTextures[iIndex] = null;
                                    //pTexture.destroyResource();
                                                                    } else {
 {
                                        akra.logger.setSourceLocation("resources/SurfaceMaterial.ts", 70);
                                        akra.logger.warning("cannot destroy resource...");
                                    }
                                }
                                ((this._iTextureFlags) &= ~(1 << (iIndex)));
                                --this._nTotalTextures;
                            }
                            this._pTextures[iIndex] = pRmgr.texturePool.loadResource(texture);
                            if (this._pTextures[iIndex]) {
                                ((this._iTextureFlags) |= (1 << (iIndex)));
                                ++this._nTotalTextures;
                                this.sync(this._pTextures[iIndex], akra.EResourceItemEvents.LOADED);
                            }
                            return true;
                        } else if (texture instanceof resources.Texture) {
                            if (!this._pTextures[iIndex] || pTexture != this._pTextures[iIndex]) {
                                pTexture = texture;
                                if (this._pTextures[iIndex]) {
                                    // realise first
                                    // DisplayManager.texturePool().releaseResource(this._pTextures[iIndex]);
                                    if (this._pTextures[iIndex].release() == 0) {
                                        // this._pTextureMatrices[iIndex].destroyResource();
                                        this._pTextures[iIndex] = null;
                                    } else {
 {
                                            akra.logger.setSourceLocation("resources/SurfaceMaterial.ts", 102);
                                            akra.logger.warning("cannot destroy resource...");
                                        }
                                        ;
                                    }
                                    ((this._iTextureFlags) &= ~(1 << (iIndex)));
                                    --this._nTotalTextures;
                                }
                                this._pTextures[iIndex] = pTexture;
                                this._pTextures[iIndex].addRef();
                                ((this._iTextureFlags) |= (1 << (iIndex)));
                                ++this._nTotalTextures;
                                this.sync(this._pTextures[iIndex], akra.EResourceItemEvents.LOADED);
                                // var me = this;
                                // trace('me get texture :)');
                                // pTexture.setChangesNotifyRoutine(function() {
                                //                 if (pTexture.isResourceLoaded()) {
                                //                     trace(arguments);
                                //                     trace('Texture <', pTexture.findResourceName(), '> loaded');
                                //                     if (me.isResourceLoaded()) {
                                //                         trace('Surface material loaded too.')
                                //                     }
                                //                 }
                                //             });
                                                            }
                            return true;
                        } else //similar to [cPoolHandle texture]
                        if ((typeof (texture) === "number")) {
                            if (!this._pTextures[iIndex] || this._pTextures[iIndex].resourceHandle != texture) {
                                if (this._pTextures[iIndex]) {
                                    //TheGameHost.displayManager().texturePool().releaseResource(m_pTextures[index]);
                                    if (this._pTextures[iIndex].release() === 0) {
                                        // this._pTextures[iIndex].destroyResource();
                                        this._pTextures[iIndex] = null;
                                    } else {
 {
                                            akra.logger.setSourceLocation("resources/SurfaceMaterial.ts", 141);
                                            akra.logger.warning("cannot destroy resource...");
                                        }
                                        ;
                                    }
                                    ((this._iTextureFlags) &= ~(1 << (iIndex)));
                                    --this._nTotalTextures;
                                }
                                this._pTextures[iIndex] = pRmgr.texturePool.getResource(texture);
                                if (this._pTextures[iIndex]) {
                                    ((this._iTextureFlags) |= (1 << (iIndex)));
                                    ++this._nTotalTextures;
                                    this.sync(this._pTextures[iIndex], akra.EResourceItemEvents.LOADED);
                                }
                            }
                            return true;
                        }
                        this._pTexcoords[iIndex] = iIndex;
                        return false;
                    };
                    SurfaceMaterial.prototype.setTextureMatrix = function (iIndex, m4fValue) {
 {
                            akra.logger.setSourceLocation("resources/SurfaceMaterial.ts", 167);
                            akra.logger.assert(iIndex < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE, "invalid texture slot");
                        }
                        ;
                        if (!m4fValue) {
                            this._pTextureMatrices[iIndex] = new akra.Mat4();
                        } else {
                            this._pTextureMatrices[iIndex] = new akra.Mat4(m4fValue);
                        }
                        ((this._iTextureMatrixFlags) |= (1 << (iIndex)));
                        return true;
                    };
                    SurfaceMaterial.prototype.setMaterial = /** @inline */function (pMaterial) {
                        this._pMaterial.set(pMaterial);
                    };
                    SurfaceMaterial.prototype.isEqual = function (pSurfaceMaterial) {
                        if (this._nTotalTextures === pSurfaceMaterial.totalTextures && this._iTextureFlags === pSurfaceMaterial.textureFlags && this._iTextureMatrixFlags === pSurfaceMaterial.textureMatrixFlags) {
                            if ((this._pMaterial && this._pMaterial.isEqual(pSurfaceMaterial.material)) || (pSurfaceMaterial.material === null)) {
                                for(var i = 0; i < this._pTextures.length; i++) {
                                    if (this._pTextures[i] !== pSurfaceMaterial.texture[i]) {
                                        return false;
                                    }
                                }
                                ;
                                for(var i = 0; i < this._pTextureMatrices.length; ++i) {
                                    for(var j = 0; j < this._pTextureMatrices[i].data.length; j++) {
                                        if (this._pTextureMatrices[i].data[j] !== pSurfaceMaterial.textureMatrix[i].data[j]) {
                                            return false;
                                        }
                                    }
                                    ;
                                }
                                return true;
                            }
                        }
                        return false;
                    };
                    SurfaceMaterial.prototype.texture = /** @inline */function (iSlot) {
                        // debug_assert((iSlot >= 0 && iSlot < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE),
                        //            "invalid texture slot");
                        return this._pTextures[iSlot];
                    };
                    SurfaceMaterial.prototype.texcoord = /** @inline */function (iSlot) {
                        // debug_assert((iSlot >= 0 && iSlot < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE),
                        //            "invalid texture slot");
                        return this._pTexcoords[iSlot];
                    };
                    SurfaceMaterial.prototype.textureMatrix = /** @inline */function (iSlot) {
 {
                            akra.logger.setSourceLocation("resources/SurfaceMaterial.ts", 227);
                            akra.logger.assert((iSlot >= 0 && iSlot < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE), "invalid texture slot");
                        }
                        ;
                        return this._pTextureMatrices[iSlot];
                    };
                    SurfaceMaterial.MAX_TEXTURES_PER_SURFACE = 16;
                    SurfaceMaterial.prototype._getHash = function () {
                        if (this._isNeedToUpdateHash) {
                            this._sLastHash = this.calcHash();
                            this._isNeedToUpdateHash = false;
                        }
                        return this._sLastHash;
                    };
                    SurfaceMaterial.prototype.calcHash = function () {
                        var sHash = "";
                        for(var i = 0; i < this._pTexcoords.length; i++) {
                            if (this._pTexcoords[i] !== i) {
                                sHash += i.toString() + "<" + this._pTexcoords[i].toString() + ".";
                            }
                        }
                        return sHash;
                    };
                    return SurfaceMaterial;
                })(pool.ResourcePoolItem);
                resources.SurfaceMaterial = SurfaceMaterial;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            //#include "resources/Model.ts"
            (function (resources) {
                var Effect = (function (_super) {
                    __extends(Effect, _super);
                    function Effect() {
                                        _super.call(this);
                    }
                    Object.defineProperty(Effect.prototype, "totalComponents", {
                        get: function () {
                            return (((((((((this))).pResourcePool)).pManager))).getEngine().getComposer()).getComponentCountForEffect(this);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Effect.prototype, "totalPasses", {
                        get: function () {
                            return (((((((((this))).pResourcePool)).pManager))).getEngine().getComposer()).getTotalPassesForEffect(this);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Effect.prototype.isEqual = function (pEffect) {
                        return false;
                    };
                    Effect.prototype.isReplicated = function () {
                        return false;
                    };
                    Effect.prototype.isMixid = function () {
                        return false;
                    };
                    Effect.prototype.isParameterUsed = function (pParam, iPass) {
                        return false;
                    };
                    Effect.prototype.createResource = function () {
                        /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.notifyLoaded();
                        return true;
                    };
                    Effect.prototype.replicable = function (bValue) {
                        return;
                    };
                    Effect.prototype.miscible = function (bValue) {
                        return;
                    };
                    Effect.prototype.addComponent = function (pComponent, iShift, iPass, isSet) {
                        if (typeof iShift === "undefined") { iShift = 0; }
                        if (typeof iPass === "undefined") { iPass = 0xffffff; }
                        if (typeof isSet === "undefined") { isSet = true; }
                        var pComponentPool = (((((((this)).pResourcePool)).pManager))).componentPool;
                        if ((typeof (pComponent) === "number")) {
                            pComponent = pComponentPool.getResource(pComponent);
                        } else if ((typeof (pComponent) === "string")) {
                            pComponent = pComponentPool.findResource(pComponent);
                        }
                        if (!((pComponent) !== undefined) || ((pComponent) === null)) {
 {
                                akra.logger.setSourceLocation("resources/Effect.ts", 49);
                                akra.logger.error("Bad component for add/delete: ", pComponent);
                            }
                            ;
                            return false;
                        }
                        if (isSet) {
                            if (!(((((((((this))).pResourcePool)).pManager))).getEngine().getComposer()).addComponentToEffect(this, pComponent, iShift, iPass)) {
 {
                                    akra.logger.setSourceLocation("resources/Effect.ts", 55);
                                    akra.logger.error("Can not add component '" + pComponent.findResourceName() + "'");
                                }
                                ;
                                return false;
                            }
                        } else {
                            if (!(((((((((this))).pResourcePool)).pManager))).getEngine().getComposer()).removeComponentFromEffect(this, pComponent, iShift, iPass)) {
 {
                                    akra.logger.setSourceLocation("resources/Effect.ts", 61);
                                    akra.logger.error("Can not delete component '" + pComponent.findResourceName() + "'");
                                }
                                ;
                                return false;
                            }
                        }
                        ((this).setAlteredFlag(true));
                        if (this.totalComponents === 1 && isSet) {
                            /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyRestored();
                        } else if (this.totalComponents === 0 && !isSet) {
                            /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyDisabled();
                        }
                        return true;
                    };
                    Effect.prototype.delComponent = function (pComponent, iShift, iPass) {
                        if (typeof iShift === "undefined") { iShift = 0; }
                        if (typeof iPass === "undefined") { iPass = 0xffffff; }
                        return this.addComponent(pComponent, iShift, iPass, false);
                    };
                    Effect.prototype.hasComponent = function (sComponent, iShift, iPass) {
                        if (typeof iShift === "undefined") { iShift = 0xfffffe; }
                        if (typeof iPass === "undefined") { iPass = 0xfffffe; }
                        var pComponentPool = (((((((this)).pResourcePool)).pManager))).componentPool;
                        var pComponent = null;
                        pComponent = pComponentPool.findResource(sComponent);
                        if (((pComponent) === null)) {
                            return false;
                        }
                        return (((((((((this))).pResourcePool)).pManager))).getEngine().getComposer()).hasComponentForEffect(this, pComponent, iShift, iPass);
                    };
                    Effect.prototype.activate = function (iShift) {
                        if (typeof iShift === "undefined") { iShift = 0; }
                        return (((((((((this))).pResourcePool)).pManager))).getEngine().getComposer()).activateEffectResource(this, iShift);
                    };
                    Effect.prototype.deactivate = function () {
                        return (((((((((this))).pResourcePool)).pManager))).getEngine().getComposer()).deactivateEffectResource(this);
                    };
                    Effect.prototype.findParameter = function (pParam, iPass) {
                        return null;
                    };
                    Effect.prototype.getComposer = /** @inline */function () {
                        return (((((((this)).pResourcePool)).pManager))).getEngine().getComposer();
                    };
                    return Effect;
                })(pool.ResourcePoolItem);
                resources.Effect = Effect;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EImageFlags) {
        EImageFlags._map = [];
        EImageFlags.COMPRESSED = 0x00000001;
        EImageFlags.CUBEMAP = 0x00000002;
        EImageFlags.TEXTURE_3D = 0x00000004;
    })(akra.EImageFlags || (akra.EImageFlags = {}));
    var EImageFlags = akra.EImageFlags;
    ;
    (function (EImageCubeFlags) {
        EImageCubeFlags._map = [];
        EImageCubeFlags.POSITIVE_X = 0x00000001;
        EImageCubeFlags.NEGATIVE_X = 0x00000002;
        EImageCubeFlags.POSITIVE_Y = 0x00000004;
        EImageCubeFlags.NEGATIVE_Y = 0x00000008;
        EImageCubeFlags.POSITIVE_Z = 0x000000010;
        EImageCubeFlags.NEGATIVE_Z = 0x000000020;
    })(akra.EImageCubeFlags || (akra.EImageCubeFlags = {}));
    var EImageCubeFlags = akra.EImageCubeFlags;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var Pathinfo = (function () {
            function Pathinfo(pPath) {
                this._sDirname = null;
                this._sExtension = null;
                this._sFilename = null;
                if (((pPath) !== undefined)) {
                    this.set(pPath);
                }
            }
            Object.defineProperty(Pathinfo.prototype, "path", {
                get: /** @inline */function () {
                    return this.toString();
                },
                set: /** @inline */function (sPath) {
                    this.set(sPath);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Pathinfo.prototype, "dirname", {
                get: /** @inline */function () {
                    return this._sDirname;
                },
                set: /** @inline */function (sDirname) {
                    this._sDirname = sDirname;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Pathinfo.prototype, "filename", {
                get: /** @inline */function () {
                    return this._sFilename;
                },
                set: /** @inline */function (sFilename) {
                    this._sFilename = sFilename;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Pathinfo.prototype, "ext", {
                get: /** @inline */function () {
                    return this._sExtension;
                },
                set: /** @inline */function (sExtension) {
                    this._sExtension = sExtension;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Pathinfo.prototype, "basename", {
                get: /** @inline */function () {
                    return (this._sFilename ? this._sFilename + (this._sExtension ? "." + this._sExtension : "") : "");
                },
                set: /** @inline */function (sBasename) {
                    var nPos = sBasename.lastIndexOf(".");
                    if (nPos < 0) {
                        this._sFilename = sBasename.substr(0);
                        this._sExtension = null;
                    } else {
                        this._sFilename = sBasename.substr(0, nPos);
                        this._sExtension = sBasename.substr(nPos + 1);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Pathinfo.prototype.set = function (sPath) {
                if ((typeof (sPath) === "string")) {
                    var pParts = sPath.replace('\\', '/').split('/');
                    /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.basename = pParts.pop();
                    this._sDirname = pParts.join('/');
                } else if (sPath instanceof Pathinfo) {
                    this._sDirname = sPath.dirname;
                    this._sFilename = sPath.filename;
                    this._sExtension = sPath.ext;
                } else {
                    //critical_error
                     {
                        util.logger.setSourceLocation("Pathinfo.ts", 68);
                        util.logger.error("Unexpected data type was used.");
                    }
                    ;
                }
            };
            Pathinfo.prototype.isAbsolute = function () {
                return this._sDirname[0] === "/";
            };
            Pathinfo.prototype.toString = function () {
                return (this._sDirname ? this._sDirname + "/" : "") + ((((this)._sFilename ? (this)._sFilename + ((this)._sExtension ? "." + (this)._sExtension : "") : "")));
            };
            return Pathinfo;
        })();
        util.Pathinfo = Pathinfo;        
        // export var pathinfo: (sPath: string) => IPathinfo;
        // export var pathinfo: (pPath: IPathinfo) => IPathinfo;
        util.pathinfo;
        util.pathinfo = function (pPath) {
            return new Pathinfo(pPath);
        };
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.Pathinfo = akra.util.Pathinfo;
    akra.pathinfo = akra.util.pathinfo;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var URI = (function () {
            function URI(pUri) {
                this.sScheme = null;
                this.sUserinfo = null;
                this.sHost = null;
                this.nPort = 0;
                this.sPath = null;
                this.sQuery = null;
                this.sFragment = null;
                if (pUri) {
                    this.set(pUri);
                }
            }
            Object.defineProperty(URI.prototype, "urn", {
                get: function () {
                    return (this.sPath ? this.sPath : "") + (this.sQuery ? '?' + this.sQuery : "") + (this.sFragment ? '#' + this.sFragment : "");
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "url", {
                get: function () {
                    return (this.sScheme ? this.sScheme : "") + this.authority;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "authority", {
                get: function () {
                    return (this.sHost ? '//' + (this.sUserinfo ? this.sUserinfo + '@' : "") + this.sHost + (this.nPort ? ':' + this.nPort : "") : "");
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "scheme", {
                get: /** @inline */function () {
                    return this.sScheme;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "protocol", {
                get: function () {
                    if (!this.sScheme) {
                        return this.sScheme;
                    }
                    return (this.sScheme.substr(0, this.sScheme.lastIndexOf(':')));
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "userinfo", {
                get: /** @inline */function () {
                    return this.sUserinfo;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "host", {
                get: /** @inline */function () {
                    return this.sHost;
                },
                set: /** @inline */function (sHost) {
                    //TODO: check host format
                    this.sHost = sHost;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "port", {
                get: /** @inline */function () {
                    return this.nPort;
                },
                set: /** @inline */function (iPort) {
                    this.nPort = iPort;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "path", {
                get: /** @inline */function () {
                    return this.sPath;
                },
                set: /** @inline */function (sPath) {
                    // debug_assert(!isNull(sPath.match(new RegExp("^(/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)$"))),
                    // 	"invalid path used: " + sPath);
                    //TODO: check path format
                    this.sPath = sPath;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "query", {
                get: /** @inline */function () {
                    //TODO: check query format
                    return this.sQuery;
                },
                set: /** @inline */function (sQuery) {
                    this.sQuery = sQuery;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "fragment", {
                get: /** @inline */function () {
                    return this.sFragment;
                },
                enumerable: true,
                configurable: true
            });
            URI.prototype.set = function (pData) {
                if ((typeof (pData) === "string")) {
                    var pUri = URI.uriExp.exec(pData);
 {
                        util.logger.setSourceLocation("URI.ts", 103);
                        util.logger.assert(pUri !== null, 'Invalid URI format used.\nused uri: ' + pData);
                    }
                    ;
                    if (!pUri) {
                        return null;
                    }
                    this.sScheme = pUri[1] || null;
                    this.sUserinfo = pUri[2] || null;
                    this.sHost = pUri[3] || null;
                    this.nPort = parseInt(pUri[4]) || null;
                    this.sPath = pUri[5] || pUri[6] || null;
                    this.sQuery = pUri[7] || null;
                    this.sFragment = pUri[8] || null;
                    return this;
                } else if (pData instanceof URI) {
                    return this.set(pData.toString());
                }
 {
                    util.logger.setSourceLocation("URI.ts", 124);
                    util.logger.error('Unexpected data type was used.');
                }
                ;
                return null;
            };
            URI.prototype.toString = function () {
                return this.url + this.urn;
            };
            URI.here = function here() {
                return new URI(document.location.href);
            };
            URI.uriExp = new RegExp("^([a-z0-9+.-]+:)?(?:\\/\\/(?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(?::(\\d*))?(\\/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?|(\\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})*(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?)(?:\\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?(?:#((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?$", "i");
            URI.resolve = /*
            composed as follows:
            ^
            ([a-z0-9+.-]+):							#scheme
            (?:
            //							#it has an authority:
            (?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?	#userinfo
            ((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)		#host
            (?::(\d*))?						#port
            (/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?	#path
            |
            #it doesn't have an authority:
            (/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})+(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?	#path
            )
            (?:
            \?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)	#query string
            )?
            (?:
            #((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)	#fragment
            )?
            $
            */
            function resolve(sFile, sAbsolutePath) {
                if (typeof sAbsolutePath === "undefined") { sAbsolutePath = document.location.pathname; }
                var pCurrentPath = null;
                var pFile = (new /*checked (origin: akra)>>*/akra.util.URI((sFile)));
                if (!((pFile.host) === null) || akra.util.pathinfo(pFile.path).isAbsolute()) {
                    //another server or absolute path
                    return sFile;
                }
                pCurrentPath = (new /*checked (origin: akra)>>*/akra.util.URI((sAbsolutePath)));
                pCurrentPath.path = akra.util.pathinfo(pCurrentPath.path).dirname + "/" + sFile;
                // console.log(sFile, sAbsolutePath, pCurrentPath.toString());
                return pCurrentPath.toString();
            };
            return URI;
        })();
        util.URI = URI;        
        util.uri = /** @inline */function (sUri) {
            return new akra.util.URI(sUri);
        };
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.uri = akra.util.uri;
})(akra || (akra = {}));
var akra;
(function (akra) {
    // #include "ReferenceCounter.ts"
    // #include "Singleton.ts"
    // #include "BrowserInfo.ts"
    // #include "ApiInfo.ts"
    // #include "ScreenInfo.ts"
    // #include "DeviceInfo.ts"
    // #include "UtilTimer.ts"
    // #include "Entity.ts"
    // #include "ThreadManager.ts"
    (function (util) {
        //string to array buffer
        util.stoab = function (s) {
            var len = s.length;
            var pCodeList = new Uint8Array(len);
            for(var i = 0; i < len; ++i) {
                /*& 0xFF;*/
                pCodeList[i] = s.charCodeAt(i);
            }
            return pCodeList.buffer;
        };
        util.abtos = function (pBuf) {
            var pData = new Uint8Array(pBuf);
            var s = "";
            for(var n = 0; n < pData.length; ++n) {
                s += String.fromCharCode(pData[n]);
            }
            return s;
            // return String.fromCharCode.apply(null, Array.prototype.slice.call(new Uint8Array(pBuf), 0));
                    };
        function abtota(pBuffer, eType) {
            switch(eType) {
                case akra.EDataTypes.FLOAT:
                    return new Float32Array(pBuffer);
                case akra.EDataTypes.SHORT:
                    return new Int16Array(pBuffer);
                case akra.EDataTypes.UNSIGNED_SHORT:
                    return new Uint16Array(pBuffer);
                case akra.EDataTypes.INT:
                    return new Int32Array(pBuffer);
                case akra.EDataTypes.UNSIGNED_INT:
                    return new Uint32Array(pBuffer);
                case akra.EDataTypes.BYTE:
                    return new Int8Array(pBuffer);
                default:
                case akra.EDataTypes.UNSIGNED_BYTE:
                    return new Uint8Array(pBuffer);
            }
        }
        util.abtota = abtota;
        function parseJSON(sJSON) {
            return eval('(' + sJSON + ')');
        }
        util.parseJSON = parseJSON;
        function btoa(pBlob, fn) {
            var pReader = new FileReader();
            pReader.onload = function (e) {
                fn(null, e.target.result);
            };
            pReader.onerror = function (e) {
                fn(e, null);
            };
            pReader.readAsArrayBuffer(pBlob);
        }
        util.btoa = btoa;
        /**
        * Преобразование html-сформированного текста
        * в dom.
        */
        function parseHTML(sHTML, useDocFragment) {
            if (typeof useDocFragment === "undefined") { useDocFragment = true; }
            var pDivEl = document.createElement('div');
            var pDocFrag;
            pDivEl.innerHTML = sHTML;
            if (!useDocFragment) {
                return pDivEl.childNodes;
            }
            pDocFrag = document.createDocumentFragment();
            for(var i = 0, len = pDivEl.childNodes.length; i < len; ++i) {
                if (!((pDivEl.childNodes[i]) !== undefined)) {
                    continue;
                }
                pDocFrag.appendChild(pDivEl.childNodes[i]);
            }
            return pDocFrag;
        }
        util.parseHTML = parseHTML;
        ;
        function blobFromDataURL(sBlobURL, fn) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", sBlobURL, true);
            xhr.responseType = "blob";
            xhr.onload = function (e) {
                if (this.status == 200) {
                    fn(this.response);
                }
            };
            xhr.send();
        }
        util.blobFromDataURL = blobFromDataURL;
        function dataURItoBlob(dataURI) {
            // convert base64 to raw binary data held in a string
            // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
            var byteString = atob(dataURI.split(',')[1]);
            // separate out the mime component
            var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
            // write the bytes of the string to an ArrayBuffer
            var ab = new ArrayBuffer(byteString.length);
            var ia = new Uint8Array(ab);
            for(var i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            // write the ArrayBuffer to a blob, and you're done
            var bb = new Blob([
                ab
            ], {
                type: mimeString
            });
            return bb;
        }
        util.dataURItoBlob = dataURItoBlob;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var Singleton = (function () {
            function Singleton() {
                var _constructor = (this).constructor;
 {
                    util.logger.setSourceLocation("Singleton.ts", 10);
                    util.logger.assert(!((_constructor._pInstance) !== undefined), 'Singleton class may be created only one time.');
                }
                ;
                _constructor._pInstance = this;
            }
            return Singleton;
        })();
        util.Singleton = Singleton;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var BrowserInfo = (function (_super) {
            __extends(BrowserInfo, _super);
            function BrowserInfo() {
                        _super.call(this);
                this.sBrowser = null;
                this.sVersion = null;
                this.sOS = null;
                this.sVersionSearch = null;
                this.init();
            }
            Object.defineProperty(BrowserInfo.prototype, "name", {
                get: function () {
                    return this.sBrowser;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BrowserInfo.prototype, "version", {
                get: function () {
                    return this.sVersion;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BrowserInfo.prototype, "os", {
                get: function () {
                    return this.sOS;
                },
                enumerable: true,
                configurable: true
            });
            BrowserInfo.prototype.init = function () {
                this.sBrowser = this.searchString(BrowserInfo.dataBrowser) || "An unknown browser";
                this.sVersion = this.searchVersion(navigator.userAgent) || this.searchVersion(navigator.appVersion) || "an unknown version";
                this.sOS = this.searchString(BrowserInfo.dataOS) || "an unknown OS";
            };
            BrowserInfo.prototype.searchString = function (pDataBrowser) {
                for(var i = 0; i < pDataBrowser.length; i++) {
                    var sData = pDataBrowser[i].string;
                    var dataProp = pDataBrowser[i].prop;
                    this.sVersionSearch = pDataBrowser[i].versionSearch || pDataBrowser[i].identity;
                    if (sData) {
                        if (sData.indexOf(pDataBrowser[i].subString) != -1) {
                            return pDataBrowser[i].identity;
                        }
                    } else if (dataProp) {
                        return pDataBrowser[i].identity;
                    }
                }
                return null;
            };
            BrowserInfo.prototype.searchVersion = function (sData) {
                var iStartIndex = sData.indexOf(this.sVersionSearch);
                if (iStartIndex == -1) {
                    return null;
                }
                iStartIndex = sData.indexOf('/', iStartIndex + 1);
                if (iStartIndex == -1) {
                    return null;
                }
                var iEndIndex = sData.indexOf(' ', iStartIndex + 1);
                if (iEndIndex == -1) {
                    iEndIndex = sData.indexOf(';', iStartIndex + 1);
                    if (iEndIndex == -1) {
                        return null;
                    }
                    return sData.slice(iStartIndex + 1);
                }
                return sData.slice((iStartIndex + 1), iEndIndex);
            };
            BrowserInfo.dataBrowser = [
                {
                    string: navigator.userAgent,
                    subString: "Chrome",
                    identity: "Chrome"
                }, 
                {
                    string: navigator.userAgent,
                    subString: "OmniWeb",
                    versionSearch: "OmniWeb/",
                    identity: "OmniWeb"
                }, 
                {
                    string: navigator.vendor,
                    subString: "Apple",
                    identity: "Safari",
                    versionSearch: "Version"
                }, 
                {
                    prop: window.opera,
                    identity: "Opera",
                    versionSearch: "Version"
                }, 
                {
                    string: navigator.vendor,
                    subString: "iCab",
                    identity: "iCab"
                }, 
                {
                    string: navigator.vendor,
                    subString: "KDE",
                    identity: "Konqueror"
                }, 
                {
                    string: navigator.userAgent,
                    subString: "Firefox",
                    identity: "Firefox"
                }, 
                {
                    string: navigator.vendor,
                    subString: "Camino",
                    identity: "Camino"
                }, 
                {
                    string: // for newer Netscapes (6+)
                    navigator.userAgent,
                    subString: "Netscape",
                    identity: "Netscape"
                }, 
                {
                    string: navigator.userAgent,
                    subString: "MSIE",
                    identity: "Explorer",
                    versionSearch: "MSIE"
                }, 
                {
                    string: navigator.userAgent,
                    subString: "Gecko",
                    identity: "Mozilla",
                    versionSearch: "rv"
                }, 
                {
                    string: // for older Netscapes (4-)
                    navigator.userAgent,
                    subString: "Mozilla",
                    identity: "Netscape",
                    versionSearch: "Mozilla"
                }
            ];
            BrowserInfo.dataOS = [
                {
                    string: navigator.platform,
                    subString: "Win",
                    identity: "Windows"
                }, 
                {
                    string: navigator.platform,
                    subString: "Mac",
                    identity: "Mac"
                }, 
                {
                    string: navigator.userAgent,
                    subString: "iPhone",
                    identity: "iPhone/iPod"
                }, 
                {
                    string: navigator.platform,
                    subString: "Linux",
                    identity: "Linux"
                }
            ];
            return BrowserInfo;
        })(util.Singleton);
        util.BrowserInfo = BrowserInfo;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var ScreenInfo = (function () {
            function ScreenInfo() { }
            Object.defineProperty(ScreenInfo.prototype, "width", {
                get: function () {
                    return screen.width;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ScreenInfo.prototype, "height", {
                get: function () {
                    return screen.height;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ScreenInfo.prototype, "aspect", {
                get: function () {
                    return screen.width / screen.height;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ScreenInfo.prototype, "pixelDepth", {
                get: function () {
                    return screen.pixelDepth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ScreenInfo.prototype, "colorDepth", {
                get: function () {
                    return screen.colorDepth;
                },
                enumerable: true,
                configurable: true
            });
            return ScreenInfo;
        })();
        util.ScreenInfo = ScreenInfo;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
var akra;
(function (akra) {
    /* ClearBufferMask */
    /* BeginMode */
    /* AlphaFunction (not supported in ES20) */
    /*      NEVER */
    /*      LESS */
    /*      EQUAL */
    /*      LEQUAL */
    /*      GREATER */
    /*      NOTEQUAL */
    /*      GEQUAL */
    /*      ALWAYS */
    /* BlendingFactorDest */
    /* BlendingFactorSrc */
    /*      ZERO */
    /*      ONE */
    /*      SRC_ALPHA */
    /*      ONE_MINUS_SRC_ALPHA */
    /*      DST_ALPHA */
    /*      ONE_MINUS_DST_ALPHA */
    /* BlendEquationSeparate */
    /* same as BLEND_EQUATION */
    /* BlendSubtract */
    /* Separate Blend Functions */
    /* Buffer Objects */
    /* CullFaceMode */
    /* DepthFunction */
    /*      NEVER */
    /*      LESS */
    /*      EQUAL */
    /*      LEQUAL */
    /*      GREATER */
    /*      NOTEQUAL */
    /*      GEQUAL */
    /*      ALWAYS */
    /* EnableCap */
    /* TEXTURE_2D */
    /* ErrorCode */
    /* FrontFaceDirection */
    /* GetPName */
    /*      SCISSOR_TEST */
    /*      POLYGON_OFFSET_FILL */
    /* GetTextureParameter */
    /*      TEXTURE_MAG_FILTER */
    /*      TEXTURE_MIN_FILTER */
    /*      TEXTURE_WRAP_S */
    /*      TEXTURE_WRAP_T */
    /* HintMode */
    /* HintTarget */
    /* DataType */
    /* PixelFormat */
    /* PixelType */
    /*      UNSIGNED_BYTE */
    /* Shaders */
    /* StencilFunction */
    /* StencilOp */
    /*      ZERO */
    /* StringName */
    /* TextureMagFilter */
    /* TextureMinFilter */
    /*      NEAREST */
    /*      LINEAR */
    /* TextureParameterName */
    /* TextureTarget */
    /* TextureUnit */
    /* TextureWrapMode */
    /* Uniform Types */
    /* Vertex Arrays */
    /* Shader Source */
    /* Shader Precision-Specified Types */
    /* Framebuffer Object. */
    /* WebGL-specific enums */
    //WebGL Extensions
    //draft
    //Future
    // #define box(...) Box.stackCeil.setPosition(__VA_ARGS__)
    (function (geometry) {
        var Box = (function () {
            function Box(l, t, ff, r, b, bb) {
                if (typeof l === "undefined") { l = 0; }
                if (typeof t === "undefined") { t = 0; }
                if (typeof ff === "undefined") { ff = 0; }
                if (typeof r === "undefined") { r = 1; }
                if (typeof b === "undefined") { b = 1; }
                if (typeof bb === "undefined") { bb = 1; }
                this.left = 0;
                this.top = 0;
                this.front = 0;
                this.right = 0;
                this.bottom = 0;
                this.back = 0;
                switch(arguments.length) {
                    case 1:
                        this.left = arguments[0].left;
                        this.top = arguments[0].top;
                        this.front = arguments[0].front;
                        this.right = arguments[0].right;
                        this.bottom = arguments[0].bottom;
                        this.back = arguments[0].back;
                        break;
                    case 0:
                    case 3:
                    case 6:
                        this.left = l;
                        this.top = t;
                        this.front = ff;
                        this.right = r;
                        this.bottom = b;
                        this.back = bb;
                        break;
                    case 4:
                        this.left = l;
                        this.top = t;
                        this.right = ff;
                        this.bottom = r;
                        this.back = 1;
                        this.front = 0;
                        break;
                    case 5:
 {
                            akra.logger.setSourceLocation("geometry/Box.ts", 64);
                            akra.logger.error("invalid number of arguments");
                        }
                        ;
                }
 {
                    akra.logger.setSourceLocation("geometry/Box.ts", 67);
                    akra.logger.assert(this.right >= this.left && this.bottom >= this.top && this.back >= this.front);
                }
                ;
            }
            Object.defineProperty(Box.prototype, "width", {
                get: /** @inline */function () {
                    return this.right - this.left;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Box.prototype, "height", {
                get: /** @inline */function () {
                    return this.bottom - this.top;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Box.prototype, "depth", {
                get: /** @inline */function () {
                    return this.back - this.front;
                },
                enumerable: true,
                configurable: true
            });
            Box.prototype.contains = function (pDest) {
                return (pDest.left >= this.left && pDest.top >= this.top && pDest.front >= this.front && pDest.right <= this.right && pDest.bottom <= this.bottom && pDest.back <= this.back);
            };
            Box.prototype.setPosition = function (iLeft, iTop, iWidth, iHeight, iFront, iDepth) {
                if (typeof iFront === "undefined") { iFront = 0; }
                if (typeof iDepth === "undefined") { iDepth = 1; }
                this.left = iLeft;
                this.top = iTop;
                this.right = iLeft + iWidth;
                this.bottom = iTop + iHeight;
                this.front = iFront;
                this.back = iFront + iDepth;
            };
            Box.prototype.isEqual = function (pDest) {
                return (pDest.left == this.left && pDest.top == this.top && pDest.front == this.front && pDest.right == this.right && pDest.bottom == this.bottom && pDest.back == this.back);
            };
            Box.prototype.toString = function () {
                return "---------------------------\n" + "left: " + this.left + ", right: " + this.right + "\n" + "top: " + this.top + ", bottom: " + this.bottom + "\n" + "front: " + this.front + ", back: " + this.back + "\n" + "---------------------------";
            };
            Object.defineProperty(Box, "stackCeil", {
                get: function () {
                    Box.stackPosition = Box.stackPosition === Box.stackSize - 1 ? 0 : Box.stackPosition;
                    return Box.stack[Box.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            Box.stackSize = 20;
            Box.stackPosition = 0;
            Box.stack = (function () {
                var pStack = new Array(Box.stackSize);
                for(var i = 0; i < Box.stackSize; i++) {
                    pStack[i] = new Box();
                }
                return pStack;
            })();
            return Box;
        })();
        geometry.Box = Box;        
                                                function box(l, t, ff, r, b, bb) {
            if (typeof l === "undefined") { l = 0; }
            if (typeof t === "undefined") { t = 0; }
            if (typeof ff === "undefined") { ff = 0; }
            if (typeof r === "undefined") { r = 1; }
            if (typeof b === "undefined") { b = 1; }
            if (typeof bb === "undefined") { bb = 1; }
            var pBox = Box.stack[Box.stackPosition++];
            if (Box.stackPosition === Box.stackSize) {
                Box.stackPosition = 0;
            }
            switch(arguments.length) {
                case 1:
                    pBox.setPosition(arguments[0].left, arguments[0].top, arguments[0].width, arguments[0].height, arguments[0].front, arguments[0].depth);
                    break;
                case 0:
                case 3:
                case 6:
                    pBox.setPosition(l, t, r - l, b - t, ff, bb - ff);
                    break;
                case 4:
                    pBox.setPosition(l, t, arguments[2] - l, arguments[3] - t, 0, 1);
                    break;
                default:
 {
                        akra.logger.setSourceLocation("geometry/Box.ts", 130);
                        akra.logger.error("Inavlid number of arguments");
                    }
                    ;
            }
            return pBox;
        }
        geometry.box = box;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (pixelUtil) {
        var PixelBox = (function (_super) {
            __extends(PixelBox, _super);
            function PixelBox(iWidth, iHeight, iDepth, ePixelFormat, pPixelData) {
                if (typeof pPixelData === "undefined") { pPixelData = null; }
                if (arguments.length === 0) {
                                _super.call(this);
                    this.data = null;
                    this.format = akra.EPixelFormats.UNKNOWN;
                    this.setConsecutive();
                    return;
                }
                if (arguments.length >= 4) {
                                _super.call(this, 0, 0, 0, iWidth, iHeight, iDepth);
                    this.data = ((arguments[4]) !== undefined) ? (arguments[4]) : null;
                    this.format = arguments[3];
                } else {
                                _super.call(this, arguments[0]);
                    this.data = arguments[2];
                    this.format = arguments[1];
                }
                this.setConsecutive();
            }
            PixelBox.prototype.setConsecutive = function () {
                this.rowPitch = ((this).right - (this).left);
                this.slicePitch = ((this).right - (this).left) * ((this).bottom - (this).top);
            };
            PixelBox.prototype.getRowSkip = function () {
                return this.rowPitch - ((this).right - (this).left);
            };
            PixelBox.prototype.getSliceSkip = function () {
                return this.slicePitch - (((this).bottom - (this).top) * this.rowPitch);
            };
            PixelBox.prototype.isConsecutive = function () {
                return this.rowPitch == ((this).right - (this).left) && this.slicePitch == ((this).right - (this).left) * ((this).bottom - (this).top);
            };
            PixelBox.prototype.getConsecutiveSize = function () {
                return pixelUtil.getMemorySize(((this).right - (this).left), ((this).bottom - (this).top), ((this).back - (this).front), this.format);
            };
            PixelBox.prototype.getSubBox = function (pDest, pDestPixelBox) {
                if (typeof pDestPixelBox === "undefined") { pDestPixelBox = null; }
                if ((((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor(((this.format))).flags) & /*checked (origin: akra)>>*/akra.EPixelFormatFlags.COMPRESSED) > 0)) {
                    if (pDest.left == this.left && pDest.top == this.top && pDest.front == this.front && pDest.right == this.right && pDest.bottom == this.bottom && pDest.back == this.back) {
                        // Entire buffer is being queried
                        return this;
                    }
 {
                        akra.logger.setSourceLocation("PixelBox.ts", 69);
                        akra.logger.error("Cannot return subvolume of compressed PixelBuffer", "PixelBox::getSubVolume");
                    }
                    ;
                }
                if (!this.contains(pDest)) {
 {
                        akra.logger.setSourceLocation("PixelBox.ts", 74);
                        akra.logger.error("Bounds out of range", "PixelBox::getSubVolume");
                    }
                    ;
                }
                var elemSize = (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor((this.format)).elemBytes);
                // Calculate new data origin
                // Notice how we do not propagate left/top/front from the incoming box, since
                // the returned pointer is already offset
                var rval = null;
                if (((pDestPixelBox) === null)) {
                    rval = new PixelBox();
                } else {
                    rval = pDestPixelBox;
                }
                rval.setPosition(0, 0, pDest.width, pDest.height, 0, pDest.depth);
                rval.format = this.format;
                rval.data = (this.data).subarray(((pDest.left - this.left) * elemSize) + ((pDest.top - this.top) * this.rowPitch * elemSize) + ((pDest.front - this.front) * this.slicePitch * elemSize));
                rval.rowPitch = this.rowPitch;
                rval.slicePitch = this.slicePitch;
                rval.format = this.format;
                return rval;
            };
            PixelBox.prototype.getColorAt = function (pColor, x, y, z) {
                if (typeof z === "undefined") { z = 0; }
                if (((pColor) === null)) {
                    pColor = new akra.Color(0.);
                }
                var pixelSize = (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor((this.format)).elemBytes);
                var pixelOffset = pixelSize * (z * this.slicePitch + y * this.rowPitch + x);
                pixelUtil.unpackColour(pColor, this.format, this.data.subarray(pixelOffset, pixelOffset + pixelSize));
                return pColor;
            };
            PixelBox.prototype.setColorAt = function (pColor, x, y, z) {
                if (typeof z === "undefined") { z = 0; }
                var pixelSize = (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor((this.format)).elemBytes);
                var pixelOffset = pixelSize * (z * this.slicePitch + y * this.rowPitch + x);
                (/*checked (origin: pixelUtil)>>*/akra.pixelUtil.packColourFloat((pColor).r, (pColor).g, (pColor).b, (pColor).a, (this.format), (this.data.subarray(pixelOffset, pixelOffset + pixelSize))));
            };
            PixelBox.prototype.scale = function (pDest, eFilter) {
                if (typeof eFilter === "undefined") { eFilter = akra.EFilters.BILINEAR; }
                return false;
            };
            PixelBox.prototype.refresh = function (pExtents, ePixelFormat, pPixelData) {
                this.left = pExtents.left;
                this.top = pExtents.top;
                this.front = pExtents.front;
                this.right = pExtents.right;
                this.bottom = pExtents.bottom;
                this.back = pExtents.back;
                this.data = pPixelData;
                this.format = ePixelFormat;
                this.setConsecutive();
            };
            PixelBox.prototype.toString = function () {
                return "|---------------------------|\n" + _super.prototype.toString.call(this) + "\n" + "length: " + (this.data ? this.data.length : 0) + "\n" + "|---------------------------|";
            };
            Object.defineProperty(PixelBox, "stackCeil", {
                get: function () {
                    PixelBox.stackPosition = PixelBox.stackPosition === PixelBox.stackSize - 1 ? 0 : PixelBox.stackPosition;
                    return PixelBox.stack[PixelBox.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            PixelBox.stackSize = 20;
            PixelBox.stackPosition = 0;
            PixelBox.stack = (function () {
                var pStack = new Array(PixelBox.stackSize);
                for(var i = 0; i < PixelBox.stackSize; i++) {
                    pStack[i] = new PixelBox();
                }
                return pStack;
            })();
            return PixelBox;
        })(akra.geometry.Box);
        pixelUtil.PixelBox = PixelBox;        
                                function pixelBox() {
            var pPixelBox = PixelBox.stack[PixelBox.stackPosition++];
            if (PixelBox.stackPosition === PixelBox.stackSize) {
                PixelBox.stackPosition = 0;
            }
            var pBox = null;
            var pPixelData = null;
            var ePixelFormat = akra.EPixelFormats.UNKNOWN;
            switch(arguments.length) {
                case 2:
                case 3:
                    pBox = arguments[0];
                    ePixelFormat = arguments[1];
                    pPixelData = arguments[2] || null;
                    break;
                case 4:
                case 5:
                    pBox = akra.geometry.box(0, 0, 0, arguments[0], arguments[1], arguments[2]);
                    ePixelFormat = arguments[3];
                    pPixelData = arguments[4] || null;
                    break;
                default:
                    pBox = akra.geometry.box(0, 0, 0, 1, 1, 1);
                    break;
            }
            pPixelBox.refresh(pBox, ePixelFormat, pPixelData);
            return pPixelBox;
        }
        pixelUtil.pixelBox = pixelBox;
    })(akra.pixelUtil || (akra.pixelUtil = {}));
    var pixelUtil = akra.pixelUtil;
})(akra || (akra = {}));
var akra;
(function (akra) {
    function fillPixelFormats(pData) {
        var pPixelFormats = [];
        for(var i = 0; i < pData.length; ++i) {
            var pEl = pData[i];
            pPixelFormats.push({
                name: pEl[0],
                elemBytes: pEl[1],
                flags: pEl[2],
                componentType: pEl[3],
                componentCount: pEl[4],
                rbits: pEl[5],
                gbits: pEl[6],
                bbits: pEl[7],
                abits: pEl[8],
                rmask: pEl[9],
                gmask: pEl[10],
                bmask: pEl[11],
                amask: pEl[12],
                rshift: pEl[13],
                gshift: pEl[14],
                bshift: pEl[15],
                ashift: pEl[16]
            });
        }
        return pPixelFormats;
    }
    var pPixelFormats = fillPixelFormats([
        [
            "PF_UNKNOWN", 
            /* Bytes per element */
            0, 
            /* Flags */
            0, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            0, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //1-----------------------------------------------------------------------
        [
            "PF_L8", 
            /* Bytes per element */
            1, 
            /* Flags */
            akra.EPixelFormatFlags.LUMINANCE | akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            1, 
            /* rbits, gbits, bbits, abits */
            8, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0xFF, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //2-----------------------------------------------------------------------
        [
            "PF_L16", 
            /* Bytes per element */
            2, 
            /* Flags */
            akra.EPixelFormatFlags.LUMINANCE | akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.SHORT, 
            1, 
            /* rbits, gbits, bbits, abits */
            16, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0xFFFF, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //3-----------------------------------------------------------------------
        [
            "PF_A8", 
            /* Bytes per element */
            1, 
            /* Flags */
            akra.EPixelFormatFlags.HASALPHA | akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            1, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            8, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0xFF, 
            0, 
            0, 
            0, 
            0
        ], 
        //4-----------------------------------------------------------------------
        [
            "PF_A4L4", 
            /* Bytes per element */
            1, 
            /* Flags */
            akra.EPixelFormatFlags.HASALPHA | akra.EPixelFormatFlags.LUMINANCE | akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            2, 
            /* rbits, gbits, bbits, abits */
            4, 
            0, 
            0, 
            4, 
            /* Masks and shifts */
            0x0F, 
            0, 
            0, 
            0xF0, 
            0, 
            0, 
            0, 
            4
        ], 
        //5-----------------------------------------------------------------------
        [
            "PF_BYTE_LA", 
            /* Bytes per element */
            2, 
            /* Flags */
            akra.EPixelFormatFlags.HASALPHA | akra.EPixelFormatFlags.LUMINANCE, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            2, 
            /* rbits, gbits, bbits, abits */
            8, 
            0, 
            0, 
            8, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //6-----------------------------------------------------------------------
        [
            "PF_R5G6B5", 
            /* Bytes per element */
            2, 
            /* Flags */
            akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            3, 
            /* rbits, gbits, bbits, abits */
            5, 
            6, 
            5, 
            0, 
            /* Masks and shifts */
            0xF800, 
            0x07E0, 
            0x001F, 
            0, 
            11, 
            5, 
            0, 
            0
        ], 
        //7-----------------------------------------------------------------------
        [
            "PF_B5G6R5", 
            /* Bytes per element */
            2, 
            /* Flags */
            akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            3, 
            /* rbits, gbits, bbits, abits */
            5, 
            6, 
            5, 
            0, 
            /* Masks and shifts */
            0x001F, 
            0x07E0, 
            0xF800, 
            0, 
            0, 
            5, 
            11, 
            0
        ], 
        //8-----------------------------------------------------------------------
        [
            "PF_A4R4G4B4", 
            /* Bytes per element */
            2, 
            /* Flags */
            akra.EPixelFormatFlags.HASALPHA | akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            4, 
            /* rbits, gbits, bbits, abits */
            4, 
            4, 
            4, 
            4, 
            /* Masks and shifts */
            0x0F00, 
            0x00F0, 
            0x000F, 
            0xF000, 
            8, 
            4, 
            0, 
            12
        ], 
        //9-----------------------------------------------------------------------
        [
            "PF_A1R5G5B5", 
            /* Bytes per element */
            2, 
            /* Flags */
            akra.EPixelFormatFlags.HASALPHA | akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            4, 
            /* rbits, gbits, bbits, abits */
            5, 
            5, 
            5, 
            1, 
            /* Masks and shifts */
            0x7C00, 
            0x03E0, 
            0x001F, 
            0x8000, 
            10, 
            5, 
            0, 
            15, 
            
        ], 
        //10-----------------------------------------------------------------------
        [
            "PF_R8G8B8", 
            /* Bytes per element */
            /* 24 bit integer -- special*/
            3, 
            /* Flags */
            akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            3, 
            /* rbits, gbits, bbits, abits */
            8, 
            8, 
            8, 
            0, 
            /* Masks and shifts */
            0xFF0000, 
            0x00FF00, 
            0x0000FF, 
            0, 
            16, 
            8, 
            0, 
            0
        ], 
        //11-----------------------------------------------------------------------
        [
            "PF_B8G8R8", 
            /* Bytes per element */
            /* 24 bit integer -- special*/
            3, 
            /* Flags */
            akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            3, 
            /* rbits, gbits, bbits, abits */
            8, 
            8, 
            8, 
            0, 
            /* Masks and shifts */
            0x0000FF, 
            0x00FF00, 
            0xFF0000, 
            0, 
            0, 
            8, 
            16, 
            0
        ], 
        //12-----------------------------------------------------------------------
        [
            "PF_A8R8G8B8", 
            /* Bytes per element */
            4, 
            /* Flags */
            akra.EPixelFormatFlags.HASALPHA | akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            4, 
            /* rbits, gbits, bbits, abits */
            8, 
            8, 
            8, 
            8, 
            /* Masks and shifts */
            0x00FF0000, 
            0x0000FF00, 
            0x000000FF, 
            0xFF000000, 
            16, 
            8, 
            0, 
            24
        ], 
        //13-----------------------------------------------------------------------
        [
            "PF_A8B8G8R8", 
            /* Bytes per element */
            4, 
            /* Flags */
            akra.EPixelFormatFlags.HASALPHA | akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            4, 
            /* rbits, gbits, bbits, abits */
            8, 
            8, 
            8, 
            8, 
            /* Masks and shifts */
            0x000000FF, 
            0x0000FF00, 
            0x00FF0000, 
            0xFF000000, 
            0, 
            8, 
            16, 
            24, 
            
        ], 
        //14-----------------------------------------------------------------------
        [
            "PF_B8G8R8A8", 
            /* Bytes per element */
            4, 
            /* Flags */
            akra.EPixelFormatFlags.HASALPHA | akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            4, 
            /* rbits, gbits, bbits, abits */
            8, 
            8, 
            8, 
            8, 
            /* Masks and shifts */
            0x0000FF00, 
            0x00FF0000, 
            0xFF000000, 
            0x000000FF, 
            8, 
            16, 
            24, 
            0
        ], 
        //15-----------------------------------------------------------------------
        [
            "PF_A2R10G10B10", 
            /* Bytes per element */
            4, 
            /* Flags */
            akra.EPixelFormatFlags.HASALPHA | akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            4, 
            /* rbits, gbits, bbits, abits */
            10, 
            10, 
            10, 
            2, 
            /* Masks and shifts */
            0x3FF00000, 
            0x000FFC00, 
            0x000003FF, 
            0xC0000000, 
            20, 
            10, 
            0, 
            30
        ], 
        //16-----------------------------------------------------------------------
        [
            "PF_A2B10G10R10", 
            /* Bytes per element */
            4, 
            /* Flags */
            akra.EPixelFormatFlags.HASALPHA | akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            4, 
            /* rbits, gbits, bbits, abits */
            10, 
            10, 
            10, 
            2, 
            /* Masks and shifts */
            0x000003FF, 
            0x000FFC00, 
            0x3FF00000, 
            0xC0000000, 
            0, 
            10, 
            20, 
            30
        ], 
        //17-----------------------------------------------------------------------
        [
            "PF_DXT1", 
            /* Bytes per element */
            0, 
            /* Flags */
            akra.EPixelFormatFlags.COMPRESSED | akra.EPixelFormatFlags.HASALPHA, 
            /* Component type and count */
            /* No alpha*/
            akra.EPixelComponentTypes.BYTE, 
            3, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //18-----------------------------------------------------------------------
        [
            "PF_DXT2", 
            /* Bytes per element */
            0, 
            /* Flags */
            akra.EPixelFormatFlags.COMPRESSED | akra.EPixelFormatFlags.HASALPHA, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            4, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //19-----------------------------------------------------------------------
        [
            "PF_DXT3", 
            /* Bytes per element */
            0, 
            /* Flags */
            akra.EPixelFormatFlags.COMPRESSED | akra.EPixelFormatFlags.HASALPHA, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            4, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //20-----------------------------------------------------------------------
        [
            "PF_DXT4", 
            /* Bytes per element */
            0, 
            /* Flags */
            akra.EPixelFormatFlags.COMPRESSED | akra.EPixelFormatFlags.HASALPHA, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            4, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //21-----------------------------------------------------------------------
        [
            "PF_DXT5", 
            /* Bytes per element */
            0, 
            /* Flags */
            akra.EPixelFormatFlags.COMPRESSED | akra.EPixelFormatFlags.HASALPHA, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            4, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //22-----------------------------------------------------------------------
        [
            "PF_FLOAT16_RGB", 
            /* Bytes per element */
            6, 
            /* Flags */
            akra.EPixelFormatFlags.FLOAT, 
            /* Component type and count */
            akra.EPixelComponentTypes.FLOAT16, 
            3, 
            /* rbits, gbits, bbits, abits */
            16, 
            16, 
            16, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //23-----------------------------------------------------------------------
        [
            "PF_FLOAT16_RGBA", 
            /* Bytes per element */
            8, 
            /* Flags */
            akra.EPixelFormatFlags.FLOAT | akra.EPixelFormatFlags.HASALPHA, 
            /* Component type and count */
            akra.EPixelComponentTypes.FLOAT16, 
            4, 
            /* rbits, gbits, bbits, abits */
            16, 
            16, 
            16, 
            16, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //24-----------------------------------------------------------------------
        [
            "PF_FLOAT32_RGB", 
            /* Bytes per element */
            12, 
            /* Flags */
            akra.EPixelFormatFlags.FLOAT, 
            /* Component type and count */
            akra.EPixelComponentTypes.FLOAT32, 
            3, 
            /* rbits, gbits, bbits, abits */
            32, 
            32, 
            32, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //25-----------------------------------------------------------------------
        [
            "PF_FLOAT32_RGBA", 
            /* Bytes per element */
            16, 
            /* Flags */
            akra.EPixelFormatFlags.FLOAT | akra.EPixelFormatFlags.HASALPHA, 
            /* Component type and count */
            akra.EPixelComponentTypes.FLOAT32, 
            4, 
            /* rbits, gbits, bbits, abits */
            32, 
            32, 
            32, 
            32, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //26-----------------------------------------------------------------------
        [
            "PF_X8R8G8B8", 
            /* Bytes per element */
            4, 
            /* Flags */
            akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            3, 
            /* rbits, gbits, bbits, abits */
            8, 
            8, 
            8, 
            0, 
            /* Masks and shifts */
            0x00FF0000, 
            0x0000FF00, 
            0x000000FF, 
            0xFF000000, 
            16, 
            8, 
            0, 
            24
        ], 
        //27-----------------------------------------------------------------------
        [
            "PF_X8B8G8R8", 
            /* Bytes per element */
            4, 
            /* Flags */
            akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            3, 
            /* rbits, gbits, bbits, abits */
            8, 
            8, 
            8, 
            0, 
            /* Masks and shifts */
            0x000000FF, 
            0x0000FF00, 
            0x00FF0000, 
            0xFF000000, 
            0, 
            8, 
            16, 
            24
        ], 
        //28-----------------------------------------------------------------------
        [
            "PF_R8G8B8A8", 
            /* Bytes per element */
            4, 
            /* Flags */
            akra.EPixelFormatFlags.HASALPHA | akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            4, 
            /* rbits, gbits, bbits, abits */
            8, 
            8, 
            8, 
            8, 
            /* Masks and shifts */
            0xFF000000, 
            0x00FF0000, 
            0x0000FF00, 
            0x000000FF, 
            24, 
            16, 
            8, 
            0
        ], 
        //29-----------------------------------------------------------------------
        [
            "PF_FLOAT32_DEPTH", 
            /* Bytes per element */
            4, 
            /* Flags */
            akra.EPixelFormatFlags.DEPTH, 
            /* Component type and count */
            /* ?*/
            akra.EPixelComponentTypes.FLOAT32, 
            1, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //30-----------------------------------------------------------------------
        [
            "PF_SHORT_RGBA", 
            /* Bytes per element */
            8, 
            /* Flags */
            akra.EPixelFormatFlags.HASALPHA, 
            /* Component type and count */
            akra.EPixelComponentTypes.SHORT, 
            4, 
            /* rbits, gbits, bbits, abits */
            16, 
            16, 
            16, 
            16, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //31-----------------------------------------------------------------------
        [
            "PF_R3G3B2", 
            /* Bytes per element */
            1, 
            /* Flags */
            akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            3, 
            /* rbits, gbits, bbits, abits */
            3, 
            3, 
            2, 
            0, 
            /* Masks and shifts */
            0xE0, 
            0x1C, 
            0x03, 
            0, 
            5, 
            2, 
            0, 
            0
        ], 
        //32-----------------------------------------------------------------------
        [
            "PF_FLOAT16_R", 
            /* Bytes per element */
            2, 
            /* Flags */
            akra.EPixelFormatFlags.FLOAT, 
            /* Component type and count */
            akra.EPixelComponentTypes.FLOAT16, 
            1, 
            /* rbits, gbits, bbits, abits */
            16, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //33-----------------------------------------------------------------------
        [
            "PF_FLOAT32_R", 
            /* Bytes per element */
            4, 
            /* Flags */
            akra.EPixelFormatFlags.FLOAT, 
            /* Component type and count */
            akra.EPixelComponentTypes.FLOAT32, 
            1, 
            /* rbits, gbits, bbits, abits */
            32, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //34-----------------------------------------------------------------------
        [
            "PF_SHORT_GR", 
            /* Bytes per element */
            4, 
            /* Flags */
            akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.SHORT, 
            2, 
            /* rbits, gbits, bbits, abits */
            16, 
            16, 
            0, 
            0, 
            /* Masks and shifts */
            0x0000FFFF, 
            0xFFFF0000, 
            0, 
            0, 
            0, 
            16, 
            0, 
            0
        ], 
        //35-----------------------------------------------------------------------
        [
            "PF_FLOAT16_GR", 
            /* Bytes per element */
            4, 
            /* Flags */
            akra.EPixelFormatFlags.FLOAT, 
            /* Component type and count */
            akra.EPixelComponentTypes.FLOAT16, 
            2, 
            /* rbits, gbits, bbits, abits */
            16, 
            16, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //36-----------------------------------------------------------------------
        [
            "PF_FLOAT32_GR", 
            /* Bytes per element */
            8, 
            /* Flags */
            akra.EPixelFormatFlags.FLOAT, 
            /* Component type and count */
            akra.EPixelComponentTypes.FLOAT32, 
            2, 
            /* rbits, gbits, bbits, abits */
            32, 
            32, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //37-----------------------------------------------------------------------
        [
            "PF_SHORT_RGB", 
            /* Bytes per element */
            6, 
            /* Flags */
            0, 
            /* Component type and count */
            akra.EPixelComponentTypes.SHORT, 
            3, 
            /* rbits, gbits, bbits, abits */
            16, 
            16, 
            16, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //38-----------------------------------------------------------------------
        [
            "PF_PVRTC_RGB2", 
            /* Bytes per element */
            0, 
            /* Flags */
            akra.EPixelFormatFlags.COMPRESSED, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            3, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //39-----------------------------------------------------------------------
        [
            "PF_PVRTC_RGBA2", 
            /* Bytes per element */
            0, 
            /* Flags */
            akra.EPixelFormatFlags.COMPRESSED | akra.EPixelFormatFlags.HASALPHA, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            4, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //40-----------------------------------------------------------------------
        [
            "PF_PVRTC_RGB4", 
            /* Bytes per element */
            0, 
            /* Flags */
            akra.EPixelFormatFlags.COMPRESSED, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            3, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //41-----------------------------------------------------------------------
        [
            "PF_PVRTC_RGBA4", 
            /* Bytes per element */
            0, 
            /* Flags */
            akra.EPixelFormatFlags.COMPRESSED | akra.EPixelFormatFlags.HASALPHA, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            4, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //42-----------------------------------------------------------------------
        [
            "PF_R8", 
            /* Bytes per element */
            1, 
            /* Flags */
            akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            1, 
            /* rbits, gbits, bbits, abits */
            8, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0xFF0000, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //43-----------------------------------------------------------------------
        [
            "PF_RG8", 
            /* Bytes per element */
            2, 
            /* Flags */
            akra.EPixelFormatFlags.NATIVEENDIAN, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            2, 
            /* rbits, gbits, bbits, abits */
            8, 
            8, 
            0, 
            0, 
            /* Masks and shifts */
            0xFF0000, 
            0x00FF00, 
            0, 
            0, 
            8, 
            0, 
            0, 
            0
        ], 
        //44-----------------------------------------------------------------------
        [
            "PF_DEPTH_BYTE", 
            /* Bytes per element */
            1, 
            /* Flags */
            akra.EPixelFormatFlags.DEPTH, 
            /* Component type and count */
            akra.EPixelComponentTypes.BYTE, 
            1, 
            /* rbits, gbits, bbits, abits */
            8, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0xFF, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //45-----------------------------------------------------------------------
        [
            "PF_DEPTH_SHORT", 
            /* Bytes per element */
            2, 
            /* Flags */
            akra.EPixelFormatFlags.DEPTH, 
            /* Component type and count */
            akra.EPixelComponentTypes.SHORT, 
            1, 
            /* rbits, gbits, bbits, abits */
            16, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0xFFFF, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //46-----------------------------------------------------------------------
        [
            "PF_DEPTH_INT", 
            /* Bytes per element */
            4, 
            /* Flags */
            akra.EPixelFormatFlags.DEPTH, 
            /* Component type and count */
            akra.EPixelComponentTypes.INT, 
            1, 
            /* rbits, gbits, bbits, abits */
            32, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0xFFFFFFFF, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //47-----------------------------------------------------------------------
        [
            "PF_DEPTH24STENCIL8", 
            /* Bytes per element */
            4, 
            /* Flags */
            akra.EPixelFormatFlags.DEPTH | akra.EPixelFormatFlags.STENCIL, 
            /* Component type and count */
            akra.EPixelComponentTypes.INT, 
            1, 
            /* rbits, gbits, bbits, abits */
            24, 
            8, 
            0, 
            0, 
            /* Masks and shifts */
            0x00FFFFFF, 
            0xFF000000, 
            0, 
            0, 
            0, 
            24, 
            0, 
            0
        ], 
        
    ]);
    var _pColorValue = {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 1.
    };
    (function (pixelUtil) {
        /** @inline */function getDescriptionFor(eFmt) {
            var ord = eFmt;
 {
                akra.logger.setSourceLocation("pixelUtil/pixelUtil.ts", 736);
                akra.logger.assert(ord >= 0 && ord < akra.EPixelFormats.TOTAL, "getDescriptionFor:" + ord);
            }
            ;
            return pPixelFormats[ord];
        }
        pixelUtil.getDescriptionFor = getDescriptionFor;
        /** Returns the size in bytes of an element of the given pixel format.
        @return
        The size in bytes of an element. See Remarks.
        @remarks
        Passing PF_UNKNOWN will result in returning a size of 0 bytes.
        */
        /** @inline */function getNumElemBytes(eFormat) {
            return /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor(eFormat).elemBytes;
        }
        pixelUtil.getNumElemBytes = getNumElemBytes;
        /** Returns the size in bits of an element of the given pixel format.
        @return
        The size in bits of an element. See Remarks.
        @remarks
        Passing PF_UNKNOWN will result in returning a size of 0 bits.
        */
        /** @inline */function getNumElemBits(eFormat) {
            return /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor(eFormat).elemBytes * 8;
        }
        pixelUtil.getNumElemBits = getNumElemBits;
        /** Returns the size in memory of a region with the given extents and pixel
        format with consecutive memory layout.
        @param width
        The width of the area
        @param height
        The height of the area
        @param depth
        The depth of the area
        @param format
        The format of the area
        @return
        The size in bytes
        @remarks
        In case that the format is non-compressed, this simply returns
        width*height*depth*PixelUtil::getNumElemBytes(format). In the compressed
        case, this does serious magic.
        */
        function getMemorySize(iWidth, iHeight, iDepth, eFormat) {
            if ((((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor(((eFormat))).flags) & /*checked (origin: akra)>>*/akra.EPixelFormatFlags.COMPRESSED) > 0)) {
                switch(eFormat) {
                    case // DXT formats work by dividing the image into 4x4 blocks, then encoding each
                    // 4x4 block with a certain number of bytes.
                    akra.EPixelFormats.DXT1:
                        return Math.floor((iWidth + 3) / 4) * Math.floor((iHeight + 3) / 4) * 8 * iDepth;
                    case akra.EPixelFormats.DXT2:
                    case akra.EPixelFormats.DXT3:
                    case akra.EPixelFormats.DXT4:
                    case akra.EPixelFormats.DXT5:
                        return Math.floor((iWidth + 3) / 4) * Math.floor((iHeight + 3) / 4) * 16 * iDepth;
                        // Size calculations from the PVRTC OpenGL extension spec
                        // http://www.khronos.org/registry/gles/extensions/IMG/IMG_texture_compression_pvrtc.txt
                        // Basically, 32 bytes is the minimum texture size.  Smaller textures are padded up to 32 bytes
                                            case akra.EPixelFormats.PVRTC_RGB2:
                    case akra.EPixelFormats.PVRTC_RGBA2:
 {
                            akra.logger.setSourceLocation("pixelUtil/pixelUtil.ts", 798);
                            akra.logger.assert(iDepth == 1);
                        }
                        ;
                        return (akra.math.max(iWidth, 16) * akra.math.max(iHeight, 8) * 2 + 7) / 8;
                    case akra.EPixelFormats.PVRTC_RGB4:
                    case akra.EPixelFormats.PVRTC_RGBA4:
 {
                            akra.logger.setSourceLocation("pixelUtil/pixelUtil.ts", 802);
                            akra.logger.assert(iDepth == 1);
                        }
                        ;
                        return (akra.math.max(iWidth, 8) * akra.math.max(iHeight, 8) * 4 + 7) / 8;
                    default:
 {
                            akra.logger.setSourceLocation("pixelUtil/pixelUtil.ts", 805);
                            akra.logger.error("Invalid compressed pixel format", "PixelUtil::getMemorySize");
                        }
                        ;
                }
            } else {
                return iWidth * iHeight * iDepth * (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor((eFormat)).elemBytes);
            }
        }
        pixelUtil.getMemorySize = getMemorySize;
        /** Returns the property flags for this pixel format
        @return
        A bitfield combination of PFF_HASALPHA, PFF_ISCOMPRESSED,
        PFF_FLOAT, PFF_DEPTH, PFF_NATIVEENDIAN, PFF_LUMINANCE
        @remarks
        This replaces the separate functions for formatHasAlpha, formatIsFloat, ...
        */
        /** @inline */function getFlags(eFormat) {
            return /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor(eFormat).flags;
        }
        pixelUtil.getFlags = getFlags;
        /** Shortcut method to determine if the format has an alpha component */
        /** @inline */function hasAlpha(eFormat) {
            return ((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor((eFormat)).flags) & akra.EPixelFormatFlags.HASALPHA) > 0;
        }
        pixelUtil.hasAlpha = hasAlpha;
        /** Shortcut method to determine if the format is floating point */
        /** @inline */function isFloatingPoint(eFormat) {
            return ((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor((eFormat)).flags) & akra.EPixelFormatFlags.FLOAT) > 0;
        }
        pixelUtil.isFloatingPoint = isFloatingPoint;
        /** Shortcut method to determine if the format is compressed */
        /** @inline */function isCompressed(eFormat) {
            return ((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor((eFormat)).flags) & akra.EPixelFormatFlags.COMPRESSED) > 0;
        }
        pixelUtil.isCompressed = isCompressed;
        /** Shortcut method to determine if the format is a depth format. */
        /** @inline */function isDepth(eFormat) {
            return ((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor((eFormat)).flags) & akra.EPixelFormatFlags.DEPTH) > 0;
        }
        pixelUtil.isDepth = isDepth;
        /** Shortcut method to determine if the format is in native endian format. */
        /** @inline */function isNativeEndian(eFormat) {
            return ((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor((eFormat)).flags) & akra.EPixelFormatFlags.NATIVEENDIAN) > 0;
        }
        pixelUtil.isNativeEndian = isNativeEndian;
        /** Shortcut method to determine if the format is a luminance format. */
        /** @inline */function isLuminance(eFormat) {
            return ((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor((eFormat)).flags) & akra.EPixelFormatFlags.LUMINANCE) > 0;
        }
        pixelUtil.isLuminance = isLuminance;
        /** Return wether a certain image extent is valid for this image format.
        @param width
        The width of the area
        @param height
        The height of the area
        @param depth
        The depth of the area
        @param format
        The format of the area
        @remarks For non-compressed formats, this is always true. For DXT formats,
        only sizes with a width and height multiple of 4 and depth 1 are allowed.
        */
        function isValidExtent(iWidth, iHeight, iDepth, eFormat) {
            if ((((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor(((eFormat))).flags) & /*checked (origin: akra)>>*/akra.EPixelFormatFlags.COMPRESSED) > 0)) {
                switch(eFormat) {
                    case akra.EPixelFormats.DXT1:
                    case akra.EPixelFormats.DXT2:
                    case akra.EPixelFormats.DXT3:
                    case akra.EPixelFormats.DXT4:
                    case akra.EPixelFormats.DXT5:
                        return ((iWidth & 3) == 0 && (iHeight & 3) == 0 && iDepth == 1);
                    default:
                        return true;
                }
            } else {
                return true;
            }
        }
        pixelUtil.isValidExtent = isValidExtent;
        /** Gives the number of bits (RGBA) for a format. See remarks.
        @remarks      For non-colour formats (dxt, depth) this returns [0,0,0,0].
        */
        function getBitDepths(eFormat) {
            /**@const*/ var des = /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor(eFormat);
            var rgba = [];
            rgba[0] = des.rbits;
            rgba[1] = des.gbits;
            rgba[2] = des.bbits;
            rgba[3] = des.abits;
            return rgba;
        }
        pixelUtil.getBitDepths = getBitDepths;
        /** Gives the masks for the R, G, B and A component
        @note			Only valid for native endian formats
        */
        function getBitMasks(eFormat) {
            /**@const*/ var des = /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor(eFormat);
            var rgba = [];
            rgba[0] = des.rmask;
            rgba[1] = des.gmask;
            rgba[2] = des.bmask;
            rgba[3] = des.amask;
            return rgba;
        }
        pixelUtil.getBitMasks = getBitMasks;
        /** Gives the bit shifts for R, G, B and A component
        @note			Only valid for native endian formats
        */
        function getBitShifts(eFormat) {
            /**@const*/ var des = /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor(eFormat);
            var rgba = [];
            rgba[0] = des.rshift;
            rgba[1] = des.gshift;
            rgba[2] = des.bshift;
            rgba[3] = des.ashift;
            return rgba;
        }
        pixelUtil.getBitShifts = getBitShifts;
        /** Gets the name of an image format
        */
        /** @inline */function getFormatName(eSrcFormat) {
            return /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor(eSrcFormat).name;
        }
        pixelUtil.getFormatName = getFormatName;
        /** Returns wether the format can be packed or unpacked with the packColour()
        and unpackColour() functions. This is generally not true for compressed and
        depth formats as they are special. It can only be true for formats with a
        fixed element size.
        @return
        true if yes, otherwise false
        */
        function isAccessible(eSrcFormat) {
            if (eSrcFormat == akra.EPixelFormats.UNKNOWN) {
                return false;
            }
            var flags = (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor((eSrcFormat)).flags);
            return !((flags & akra.EPixelFormatFlags.COMPRESSED) || (flags & akra.EPixelFormatFlags.DEPTH));
        }
        pixelUtil.isAccessible = isAccessible;
        /** Returns the component type for a certain pixel format. Returns PCT_BYTE
        in case there is no clear component type like with compressed formats.
        This is one of PCT_BYTE, PCT_SHORT, PCT_FLOAT16, PCT_FLOAT32.
        */
        /** @inline */function getComponentType(eFmt) {
            return /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor(eFmt).componentType;
        }
        pixelUtil.getComponentType = getComponentType;
        /** Returns the component count for a certain pixel format. Returns 3(no alpha) or
        4 (has alpha) in case there is no clear component type like with compressed formats.
        */
        /** @inline */function getComponentCount(eFmt) {
            return /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor(eFmt).componentCount;
        }
        pixelUtil.getComponentCount = getComponentCount;
        /** @inline */function getComponentTypeBits(eFormat) {
            var eType = (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor((eFormat)).componentType);
            switch(eType) {
                case /*Byte per component (8 bit fixed 0.0..1.0)*/
                akra.EPixelComponentTypes.BYTE:
                    return 8;
                    /*Short per component (16 bit fixed 0.0..1.0))*/
                                    case akra.EPixelComponentTypes.SHORT:
                    return 16;
                    /*16 bit float per component*/
                                    case akra.EPixelComponentTypes.FLOAT16:
                    return 16;
                    /*32 bit float per component*/
                                    case akra.EPixelComponentTypes.FLOAT32:
                    return 32;
            }
            return 0;
        }
        pixelUtil.getComponentTypeBits = getComponentTypeBits;
        /** Gets the format from given name.
        @param  name            The string of format name
        @param  accessibleOnly  If true, non-accessible format will treat as invalid format,
        otherwise, all supported format are valid.
        @param  caseSensitive   Should be set true if string match should use case sensitivity.
        @return                The format match the format name, or PF_UNKNOWN if is invalid name.
        */
        function getFormatFromName(sName, isAccessibleOnly, isCaseSensitive) {
            if (typeof isAccessibleOnly === "undefined") { isAccessibleOnly = false; }
            if (typeof isCaseSensitive === "undefined") { isCaseSensitive = false; }
            var tmp = sName;
            if (!isCaseSensitive) {
                // We are stored upper-case format names.
                tmp = tmp.toUpperCase();
            }
            for(var i = 0; i < akra.EPixelFormats.TOTAL; ++i) {
                var ePf = i;
                if (!isAccessibleOnly || isAccessible(ePf)) {
                    if (tmp == (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor((ePf)).name)) {
                        return ePf;
                    }
                }
            }
            return akra.EPixelFormats.UNKNOWN;
        }
        pixelUtil.getFormatFromName = getFormatFromName;
        /** Gets the BNF expression of the pixel-formats.
        @note                   The string returned by this function is intended to be used as a BNF expression
        to work with Compiler2Pass.
        @param  accessibleOnly  If true, only accessible pixel format will take into account, otherwise all
        pixel formats list in EPixelFormats enumeration will being returned.
        @return                A string contains the BNF expression.
        */
        function getBNFExpressionOfPixelFormats(isAccessibleOnly) {
            if (typeof isAccessibleOnly === "undefined") { isAccessibleOnly = false; }
            // Collect format names sorted by length, it's required by BNF compiler
            // that similar tokens need longer ones comes first.
            var formatNames = new Array();
            for(var i = 0; i < akra.EPixelFormats.TOTAL; ++i) {
                var ePf = (i);
                if (!isAccessibleOnly || isAccessible(ePf)) {
                    var formatName = (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor((ePf)).name);
                    formatNames.push({
                        first: formatName.length,
                        second: formatName
                    });
                }
            }
            // Populate the BNF expression in reverse order
            var result = "";
            // Note: Stupid M$ VC7.1 can't dealing operator!= with FormatNameMap::const_reverse_iterator.
            for(var j in formatNames) {
                if (!((result).length == 0)) {
                    result += " | ";
                }
                result += "'" + formatNames[j] + "'";
            }
            return result;
        }
        pixelUtil.getBNFExpressionOfPixelFormats = getBNFExpressionOfPixelFormats;
        /** Returns the similar format but acoording with given bit depths.
        @param fmt      The original foamt.
        @param integerBits Preferred bit depth (pixel bits) for integer pixel format.
        Available values: 0, 16 and 32, where 0 (the default) means as it is.
        @param floatBits Preferred bit depth (channel bits) for float pixel format.
        Available values: 0, 16 and 32, where 0 (the default) means as it is.
        @return        The format that similar original format with bit depth according
        with preferred bit depth, or original format if no conversion occurring.
        */
        function getFormatForBitDepths(eFmt, iIntegerBits, iFloatBits) {
            switch(iIntegerBits) {
                case 16:
                    switch(eFmt) {
                        case akra.EPixelFormats.R8G8B8:
                        case akra.EPixelFormats.X8R8G8B8:
                            return akra.EPixelFormats.R5G6B5;
                        case akra.EPixelFormats.B8G8R8:
                        case akra.EPixelFormats.X8B8G8R8:
                            return akra.EPixelFormats.B5G6R5;
                        case akra.EPixelFormats.A8R8G8B8:
                        case akra.EPixelFormats.R8G8B8A8:
                        case akra.EPixelFormats.A8B8G8R8:
                        case akra.EPixelFormats.B8G8R8A8:
                            return akra.EPixelFormats.A4R4G4B4;
                        case akra.EPixelFormats.A2R10G10B10:
                        case akra.EPixelFormats.A2B10G10R10:
                            return akra.EPixelFormats.A1R5G5B5;
                        default:
                            // use original image format
                            break;
                    }
                    break;
                case 32:
                    switch(eFmt) {
                        case akra.EPixelFormats.R5G6B5:
                            return akra.EPixelFormats.X8R8G8B8;
                        case akra.EPixelFormats.B5G6R5:
                            return akra.EPixelFormats.X8B8G8R8;
                        case akra.EPixelFormats.A4R4G4B4:
                            return akra.EPixelFormats.A8R8G8B8;
                        case akra.EPixelFormats.A1R5G5B5:
                            return akra.EPixelFormats.A2R10G10B10;
                        default:
                            // use original image format
                            break;
                    }
                    break;
                default:
                    // use original image format
                    break;
            }
            switch(iFloatBits) {
                case 16:
                    switch(eFmt) {
                        case akra.EPixelFormats.FLOAT32_R:
                            return akra.EPixelFormats.FLOAT16_R;
                        case akra.EPixelFormats.FLOAT32_RGB:
                            return akra.EPixelFormats.FLOAT16_RGB;
                        case akra.EPixelFormats.FLOAT32_RGBA:
                            return akra.EPixelFormats.FLOAT16_RGBA;
                        default:
                            // use original image format
                            break;
                    }
                    break;
                case 32:
                    switch(eFmt) {
                        case akra.EPixelFormats.FLOAT16_R:
                            return akra.EPixelFormats.FLOAT32_R;
                        case akra.EPixelFormats.FLOAT16_RGB:
                            return akra.EPixelFormats.FLOAT32_RGB;
                        case akra.EPixelFormats.FLOAT16_RGBA:
                            return akra.EPixelFormats.FLOAT32_RGBA;
                        default:
                            // use original image format
                            break;
                    }
                    break;
                default:
                    // use original image format
                    break;
            }
            return eFmt;
        }
        pixelUtil.getFormatForBitDepths = getFormatForBitDepths;
        /** Pack a colour value to memory
        @param colour	The colour
        @param pf		Pixelformat in which to write the colour
        @param dest		Destination memory location
        */
        /** @inline */function packColour(cColour, ePf, pDest) {
            packColourFloat(cColour.r, cColour.g, cColour.b, cColour.a, ePf, pDest);
        }
        pixelUtil.packColour = packColour;
        /** Pack a colour value to memory
        @param r,g,b,a	The four colour components, range 0x00 to 0xFF
        @param pf		Pixelformat in which to write the colour
        @param dest		Destination memory location
        */
        function packColourUint(r, g, b, a, ePf, pDest) {
            // if (arguments.length < 4) {
            // 	var cColour: IColor = arguments[0];
            // 	packColour(cColour.r, cColour.g, cColour.b, cColour.a, ePf, pDest);
            // 	return;
            // }
            /**@const*/ var des = /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor(ePf);
            if (des.flags & akra.EPixelFormatFlags.NATIVEENDIAN) {
                // Shortcut for integer formats packing
                var value = ((/*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.fixedToFixed(r, 8, des.rbits) << des.rshift) & des.rmask) | ((/*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.fixedToFixed(g, 8, des.gbits) << des.gshift) & des.gmask) | ((/*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.fixedToFixed(b, 8, des.bbits) << des.bshift) & des.bmask) | ((/*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.fixedToFixed(a, 8, des.abits) << des.ashift) & des.amask);
                // And write to memory
                /*not inlined, because first statement is not return/call/dot(cur st.: Switch)*/akra.bf.intWrite(pDest, des.elemBytes, value);
            } else {
                // Convert to float
                packColourFloat(r / 255.0, g / 255.0, b / 255.0, a / 255.0, ePf, pDest);
            }
        }
        pixelUtil.packColourUint = packColourUint;
        /** Pack a colour value to memory
        @param r,g,b,a	The four colour components, range 0.0f to 1.0f
        (an exception to this case exists for floating point pixel
        formats, which don't clamp to 0.0f..1.0f)
        @param pf		Pixelformat in which to write the colour
        @param dest		Destination memory location
        */
        function packColourFloat(r, g, b, a, ePf, pDest) {
            // Catch-it-all here
            /**@const*/ var des = /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor(ePf);
            if (des.flags & akra.EPixelFormatFlags.NATIVEENDIAN) {
                // Do the packing
                //std::cerr << dest << " " << r << " " << g <<  " " << b << " " << a << std::endl;
                /**@const*/ var value = ((/*not inlined, because first statement is not return/call/dot(cur st.: If)*/akra.bf.floatToFixed(r, des.rbits) << des.rshift) & des.rmask) | ((/*not inlined, because first statement is not return/call/dot(cur st.: If)*/akra.bf.floatToFixed(g, des.gbits) << des.gshift) & des.gmask) | ((/*not inlined, because first statement is not return/call/dot(cur st.: If)*/akra.bf.floatToFixed(b, des.bbits) << des.bshift) & des.bmask) | ((/*not inlined, because first statement is not return/call/dot(cur st.: If)*/akra.bf.floatToFixed(a, des.abits) << des.ashift) & des.amask);
                // And write to memory
                /*not inlined, because first statement is not return/call/dot(cur st.: Switch)*/akra.bf.intWrite(pDest, des.elemBytes, value);
            } else {
                switch(ePf) {
                    case akra.EPixelFormats.FLOAT32_R:
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 1))[0] = r;
                        break;
                    case akra.EPixelFormats.FLOAT32_GR:
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 1))[0] = g;
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 2))[1] = r;
                        break;
                    case akra.EPixelFormats.FLOAT32_RGB:
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 1))[0] = r;
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 2))[1] = g;
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 3))[2] = b;
                        break;
                    case akra.EPixelFormats.FLOAT32_RGBA:
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 1))[0] = r;
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 2))[1] = g;
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 3))[2] = b;
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 4))[3] = a;
                        break;
                    case akra.EPixelFormats.FLOAT16_R:
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 1))[0] = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.floatToHalf(r);
                        break;
                    case akra.EPixelFormats.FLOAT16_GR:
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 1))[0] = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.floatToHalf(g);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 2))[1] = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.floatToHalf(r);
                        break;
                    case akra.EPixelFormats.FLOAT16_RGB:
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 1))[0] = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.floatToHalf(r);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 2))[1] = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.floatToHalf(g);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 3))[2] = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.floatToHalf(b);
                        break;
                    case akra.EPixelFormats.FLOAT16_RGBA:
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 1))[0] = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.floatToHalf(r);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 2))[1] = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.floatToHalf(g);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 3))[2] = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.floatToHalf(b);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 4))[3] = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.floatToHalf(a);
                        break;
                    case akra.EPixelFormats.SHORT_RGB:
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 1))[0] = /*not inlined, because first statement is not return/call/dot(cur st.: If)*/akra.bf.floatToFixed(r, 16);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 2))[1] = /*not inlined, because first statement is not return/call/dot(cur st.: If)*/akra.bf.floatToFixed(g, 16);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 3))[2] = /*not inlined, because first statement is not return/call/dot(cur st.: If)*/akra.bf.floatToFixed(b, 16);
                        break;
                    case akra.EPixelFormats.SHORT_RGBA:
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 1))[0] = /*not inlined, because first statement is not return/call/dot(cur st.: If)*/akra.bf.floatToFixed(r, 16);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 2))[1] = /*not inlined, because first statement is not return/call/dot(cur st.: If)*/akra.bf.floatToFixed(g, 16);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 3))[2] = /*not inlined, because first statement is not return/call/dot(cur st.: If)*/akra.bf.floatToFixed(b, 16);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 4))[3] = /*not inlined, because first statement is not return/call/dot(cur st.: If)*/akra.bf.floatToFixed(a, 16);
                        break;
                    case akra.EPixelFormats.BYTE_LA:
                        pDest[0] = /*not inlined, because first statement is not return/call/dot(cur st.: If)*/akra.bf.floatToFixed(r, 8);
                        pDest[1] = /*not inlined, because first statement is not return/call/dot(cur st.: If)*/akra.bf.floatToFixed(a, 8);
                        break;
                    default:
                        // Not yet supported
                         {
                            akra.logger.setSourceLocation("pixelUtil/pixelUtil.ts", 1249);
                            akra.logger.error("pack to " + (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor((ePf)).name) + " not implemented", "PixelUtil::packColour");
                        }
                        ;
                        break;
                }
            }
        }
        pixelUtil.packColourFloat = packColourFloat;
        /** Unpack a colour value from memory
        @param colour	The colour is returned here
        @param pf		Pixelformat in which to read the colour
        @param src		Source memory location
        */
        function unpackColour(cColour, ePf, pSrc) {
            unpackColourFloat(cColour, ePf, pSrc);
        }
        pixelUtil.unpackColour = unpackColour;
        /** Unpack a colour value from memory
        @param r,g,b,a	The colour is returned here (as byte)
        @param pf		Pixelformat in which to read the colour
        @param src		Source memory location
        @remarks 	This function returns the colour components in 8 bit precision,
        this will lose precision when coming from PF_A2R10G10B10 or floating
        point formats.
        */
        function unpackColourUint(rgba, ePf, pSrc) {
            /**@const*/ var des = /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor(ePf);
            var r = 0, g = 0, b = 0, a = 0;
            if (des.flags & akra.EPixelFormatFlags.NATIVEENDIAN) {
                // Shortcut for integer formats unpacking
                /**@const*/ var value = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.intRead(pSrc, des.elemBytes);
                if (des.flags & akra.EPixelFormatFlags.LUMINANCE) {
                    // Luminance format -- only rbits used
                    r = g = b = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.fixedToFixed((value & des.rmask) >> des.rshift, des.rbits, 8);
                } else {
                    r = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.fixedToFixed((value & des.rmask) >> des.rshift, des.rbits, 8);
                    g = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.fixedToFixed((value & des.gmask) >> des.gshift, des.gbits, 8);
                    b = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.fixedToFixed((value & des.bmask) >> des.bshift, des.bbits, 8);
                }
                if (des.flags & akra.EPixelFormatFlags.HASALPHA) {
                    a = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.fixedToFixed((value & des.amask) >> des.ashift, des.abits, 8);
                } else {
                    /* No alpha, default a component to full*/
                    a = 255;
                }
            } else {
                // Do the operation with the more generic floating point
                var pRGBA = _pColorValue;
                unpackColourFloat(pRGBA, ePf, pSrc);
                r = /*not inlined, because first statement is not return/call/dot(cur st.: If)*/akra.bf.floatToFixed(pRGBA.r, 8);
                g = /*not inlined, because first statement is not return/call/dot(cur st.: If)*/akra.bf.floatToFixed(pRGBA.g, 8);
                b = /*not inlined, because first statement is not return/call/dot(cur st.: If)*/akra.bf.floatToFixed(pRGBA.b, 8);
                a = /*not inlined, because first statement is not return/call/dot(cur st.: If)*/akra.bf.floatToFixed(pRGBA.a, 8);
            }
            rgba[0] = r;
            rgba[1] = g;
            rgba[2] = b;
            rgba[3] = a;
        }
        pixelUtil.unpackColourUint = unpackColourUint;
        /** Unpack a colour value from memory
        @param r,g,b,a	The colour is returned here (as float)
        @param pf		Pixelformat in which to read the colour
        @param src		Source memory location
        */
        function unpackColourFloat(rgba, ePf, pSrc) {
            /**@const*/ var des = /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor(ePf);
            var r = 0., g = 0., b = 0., a = 0.;
            if (des.flags & akra.EPixelFormatFlags.NATIVEENDIAN) {
                // Shortcut for integer formats unpacking
                /**@const*/ var value = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.intRead(pSrc, des.elemBytes);
                if (des.flags & akra.EPixelFormatFlags.LUMINANCE) {
                    // Luminance format -- only rbits used
                    r = g = b = ((((value & des.rmask) >>> des.rshift) & ((1 << (des.rbits)) - 1)) / ((1 << (des.rbits)) - 1));
                } else {
                    r = ((((value & des.rmask) >>> des.rshift) & ((1 << (des.rbits)) - 1)) / ((1 << (des.rbits)) - 1));
                    g = ((((value & des.gmask) >>> des.gshift) & ((1 << (des.gbits)) - 1)) / ((1 << (des.gbits)) - 1));
                    b = ((((value & des.bmask) >>> des.bshift) & ((1 << (des.bbits)) - 1)) / ((1 << (des.bbits)) - 1));
                }
                if (des.flags & akra.EPixelFormatFlags.HASALPHA) {
                    a = ((((value & des.amask) >>> des.ashift) & ((1 << (des.abits)) - 1)) / ((1 << (des.abits)) - 1));
                } else {
                    /* No alpha, default a component to full*/
                    a = 1.0;
                }
            } else {
                switch(ePf) {
                    case akra.EPixelFormats.FLOAT32_DEPTH:
                    case akra.EPixelFormats.FLOAT32_R:
                        r = g = b = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1))[0];
                        a = 1.0;
                        break;
                    case akra.EPixelFormats.FLOAT32_GR:
                        g = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1))[0];
                        r = b = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 2))[1];
                        a = 1.0;
                        break;
                    case akra.EPixelFormats.FLOAT32_RGB:
                        r = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1))[0];
                        g = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 2))[1];
                        b = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 3))[2];
                        a = 1.0;
                        break;
                    case akra.EPixelFormats.FLOAT32_RGBA:
                        r = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1))[0];
                        g = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 2))[1];
                        b = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 3))[2];
                        a = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 4))[3];
                        break;
                    case akra.EPixelFormats.FLOAT16_R:
                        r = g = b = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1))[0]);
                        a = 1.0;
                        break;
                    case akra.EPixelFormats.FLOAT16_GR:
                        g = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1))[0]);
                        r = b = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2))[1]);
                        a = 1.0;
                        break;
                    case akra.EPixelFormats.FLOAT16_RGB:
                        r = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1))[0]);
                        g = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1))[1]);
                        b = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2))[2]);
                        a = 1.0;
                        break;
                    case akra.EPixelFormats.FLOAT16_RGBA:
                        r = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1))[0]);
                        g = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2))[1]);
                        b = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 3))[2]);
                        a = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 4))[3]);
                        break;
                    case akra.EPixelFormats.SHORT_RGB:
                        r = ((((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1))[0]) & ((1 << (16)) - 1)) / ((1 << (16)) - 1));
                        g = ((((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2))[1]) & ((1 << (16)) - 1)) / ((1 << (16)) - 1));
                        b = ((((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 3))[2]) & ((1 << (16)) - 1)) / ((1 << (16)) - 1));
                        a = 1.0;
                        break;
                    case akra.EPixelFormats.SHORT_RGBA:
                        r = ((((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1))[0]) & ((1 << (16)) - 1)) / ((1 << (16)) - 1));
                        g = ((((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2))[1]) & ((1 << (16)) - 1)) / ((1 << (16)) - 1));
                        b = ((((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 3))[2]) & ((1 << (16)) - 1)) / ((1 << (16)) - 1));
                        a = ((((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 4))[3]) & ((1 << (16)) - 1)) / ((1 << (16)) - 1));
                        break;
                    case akra.EPixelFormats.BYTE_LA:
                        r = g = b = ((((pSrc)[0]) & ((1 << (8)) - 1)) / ((1 << (8)) - 1));
                        a = ((((pSrc)[1]) & ((1 << (8)) - 1)) / ((1 << (8)) - 1));
                        break;
                    default:
                        // Not yet supported
                         {
                            akra.logger.setSourceLocation("pixelUtil/pixelUtil.ts", 1421);
                            akra.logger.error("unpack from " + (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor((ePf)).name) + " not implemented", "PixelUtil::unpackColour");
                        }
                        ;
                        break;
                }
            }
            rgba.r = r;
            rgba.g = g;
            rgba.b = b;
            rgba.a = a;
        }
        pixelUtil.unpackColourFloat = unpackColourFloat;
                        function bulkPixelConversion(pSrc, eSrcFormat, pDest, eDstFormat, iCount) {
            var src = null, dst = null;
            if (arguments.length > 2) {
                src = new pixelUtil.PixelBox(iCount, 1, 1, eSrcFormat, pSrc);
                dst = new pixelUtil.PixelBox(iCount, 1, 1, eDstFormat, pDest);
            } else {
                src = arguments[0];
                dst = arguments[1];
            }
            if (src.width !== dst.width || src.height !== dst.height || src.depth !== dst.depth) {
 {
                    akra.logger.setSourceLocation("pixelUtil/pixelUtil.ts", 1469);
                    akra.logger.criticalError("Size dest and src pictures is different");
                }
                ;
                return;
            }
            // Check for compressed formats, we don't support decompression, compression or recoding
            if ((((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor(((src.format))).flags) & /*checked (origin: akra)>>*/akra.EPixelFormatFlags.COMPRESSED) > 0) || (((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor(((dst.format))).flags) & /*checked (origin: akra)>>*/akra.EPixelFormatFlags.COMPRESSED) > 0)) {
                if (src.format == dst.format) {
                    //_memcpy(dst.data.buffer, src.data.buffer, src.getConsecutiveSize());
                    dst.data.set(src.data.subarray(0, src.getConsecutiveSize()));
                    return;
                } else {
 {
                        akra.logger.setSourceLocation("pixelUtil/pixelUtil.ts", 1482);
                        akra.logger.error("This method can not be used to compress or decompress images", "PixelUtil::bulkPixelConversion");
                    }
                    ;
                }
            }
            // The easy case
            if (src.format == dst.format) {
                // Everything consecutive?
                if (src.isConsecutive() && dst.isConsecutive()) {
                    //_memcpy(dst.data.buffer, src.data.buffer, src.getConsecutiveSize());
                    dst.data.set(src.data.subarray(0, src.getConsecutiveSize()));
                    return;
                }
                var srcPixelSize = (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor((src.format)).elemBytes);
                var dstPixelSize = (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor((dst.format)).elemBytes);
                var srcptr = src.data.subarray((src.left + src.top * src.rowPitch + src.front * src.slicePitch) * srcPixelSize);
                var dstptr = dst.data.subarray((dst.left + dst.top * dst.rowPitch + dst.front * dst.slicePitch) * dstPixelSize);
                // Calculate pitches+skips in bytes
                var srcRowPitchBytes = src.rowPitch * srcPixelSize;
                //var size_t srcRowSkipBytes = src.getRowSkip()*srcPixelSize;
                var srcSliceSkipBytes = src.getSliceSkip() * srcPixelSize;
                var dstRowPitchBytes = dst.rowPitch * dstPixelSize;
                //var size_t dstRowSkipBytes = dst.getRowSkip()*dstPixelSize;
                var dstSliceSkipBytes = dst.getSliceSkip() * dstPixelSize;
                // Otherwise, copy per row
                /**@const*/ var rowSize = src.width * srcPixelSize;
                for(var z = src.front; z < src.back; z++) {
                    for(var y = src.top; y < src.bottom; y++) {
                        //_memcpy(dstptr.buffer, srcptr.buffer, rowSize);
                        dstptr.set(srcptr.subarray(0, rowSize));
                        srcptr = srcptr.subarray(srcRowPitchBytes);
                        dstptr = dstptr.subarray(dstRowPitchBytes);
                    }
                    srcptr = srcptr.subarray(srcSliceSkipBytes);
                    dstptr = dstptr.subarray(dstSliceSkipBytes);
                }
                return;
            }
            // Converting to PF_X8R8G8B8 is exactly the same as converting to
            // PF_A8R8G8B8. (same with PF_X8B8G8R8 and PF_A8B8G8R8)
            if (dst.format == akra.EPixelFormats.X8R8G8B8 || dst.format == akra.EPixelFormats.X8B8G8R8) {
                // Do the same conversion, with EPixelFormats.A8R8G8B8, which has a lot of
                // optimized conversions
                var tempdst = dst;
                tempdst.format = (dst.format == akra.EPixelFormats.X8R8G8B8) ? akra.EPixelFormats.A8R8G8B8 : akra.EPixelFormats.A8B8G8R8;
                bulkPixelConversion(src, tempdst);
                return;
            }
            // Converting from EPixelFormats.X8R8G8B8 is exactly the same as converting from
            // EPixelFormats.A8R8G8B8, given that the destination format does not have alpha.
            if ((src.format == akra.EPixelFormats.X8R8G8B8 || src.format == akra.EPixelFormats.X8B8G8R8) && !(((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor(((dst.format))).flags) & /*checked (origin: akra)>>*/akra.EPixelFormatFlags.HASALPHA) > 0)) {
                // Do the same conversion, with EPixelFormats.A8R8G8B8, which has a lot of
                // optimized conversions
                var tempsrc = src;
                tempsrc.format = src.format == akra.EPixelFormats.X8R8G8B8 ? akra.EPixelFormats.A8R8G8B8 : akra.EPixelFormats.A8B8G8R8;
                bulkPixelConversion(tempsrc, dst);
                return;
            }
            var srcPixelSize = (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor((src.format)).elemBytes);
            var dstPixelSize = (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/getDescriptionFor((dst.format)).elemBytes);
            var srcptr = src.data.subarray((src.left + src.top * src.rowPitch + src.front * src.slicePitch) * srcPixelSize);
            var dstptr = dst.data.subarray((dst.left + dst.top * dst.rowPitch + dst.front * dst.slicePitch) * dstPixelSize);
            // Old way, not taking into account box dimensions
            //uint8 *srcptr = static_cast<uint8*>(src.data), *dstptr = static_cast<uint8*>(dst.data);
            // Calculate pitches+skips in bytes
            var srcRowSkipBytes = src.getRowSkip() * srcPixelSize;
            var srcSliceSkipBytes = src.getSliceSkip() * srcPixelSize;
            var dstRowSkipBytes = dst.getRowSkip() * dstPixelSize;
            var dstSliceSkipBytes = dst.getSliceSkip() * dstPixelSize;
            // The brute force fallback
            // var r: float = 0, g: float = 0, b: float = 0, a: float = 1;
            var rgba = _pColorValue;
            for(var z = src.front; z < src.back; z++) {
                for(var y = src.top; y < src.bottom; y++) {
                    for(var x = src.left; x < src.right; x++) {
                        unpackColourFloat(rgba, src.format, srcptr);
                        packColourFloat(rgba.r, rgba.g, rgba.b, rgba.a, dst.format, dstptr);
                        srcptr = srcptr.subarray(srcPixelSize);
                        dstptr = dstptr.subarray(dstPixelSize);
                    }
                    srcptr = srcptr.subarray(srcRowSkipBytes);
                    dstptr = dstptr.subarray(dstRowSkipBytes);
                }
                srcptr = srcptr.subarray(srcSliceSkipBytes);
                dstptr = dstptr.subarray(dstSliceSkipBytes);
            }
        }
        pixelUtil.bulkPixelConversion = bulkPixelConversion;
        function calculateSizeForImage(nMipLevels, nFaces, iWidth, iHeight, iDepth, eFormat) {
            var iSize = 0;
            var mip = 0;
            for(mip = 0; mip < nMipLevels; ++mip) {
                iSize += getMemorySize(iWidth, iHeight, iDepth, eFormat) * nFaces;
                if (iWidth !== 1) {
                    iWidth /= 2;
                }
                if (iHeight !== 1) {
                    iHeight /= 2;
                }
                if (iDepth !== 1) {
                    iDepth /= 2;
                }
            }
            return iSize;
        }
        pixelUtil.calculateSizeForImage = calculateSizeForImage;
    })(akra.pixelUtil || (akra.pixelUtil = {}));
    var pixelUtil = akra.pixelUtil;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        webgl.maxTextureSize = 0;
        webgl.maxCubeMapTextureSize = 0;
        webgl.maxViewPortSize = 0;
        webgl.maxTextureImageUnits = 0;
        webgl.maxVertexAttributes = 0;
        webgl.maxVertexTextureImageUnits = 0;
        webgl.maxCombinedTextureImageUnits = 0;
        webgl.maxColorAttachments = 1;
        webgl.stencilBits = 0;
        webgl.colorBits = [
            0, 
            0, 
            0
        ];
        webgl.alphaBits = 0;
        webgl.multisampleType = 0.;
        webgl.shaderVersion = 0;
        webgl.hasNonPowerOf2Textures = false;
        webgl.isANGLE = false;
        var isSupported = false;
        webgl.pSupportedExtensionList = null;
        // var pLoadedExtensionList: Object = null;
        function makeDebugContext(pWebGLContext) {
            if ((((window).WebGLDebugUtils) !== undefined)) {
                pWebGLContext = WebGLDebugUtils.makeDebugContext(pWebGLContext, function (err, funcName, args) {
 {
                        akra.logger.setSourceLocation("webgl/WebGL.ts", 54);
                        akra.logger.log(("\n" + (new Error()).stack.split("\n").slice(1).join("\n")));
                    }
                    ;
                    throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName;
                }, function (funcName, args) {
 {
                        akra.logger.setSourceLocation("webgl/WebGL.ts", 58);
                        akra.logger.log("gl." + funcName + "(" + WebGLDebugUtils.glFunctionArgsToString(funcName, args) + ")");
                    }
                    ;
                });
            }
            return pWebGLContext;
        }
        function loadExtension(pWebGLContext, sExtName) {
            var pWebGLExtentionList = (pWebGLContext).extentionList = (pWebGLContext).extentionList || {};
            var pWebGLExtension;
            if (!hasExtension(sExtName)) {
 {
                    akra.logger.setSourceLocation("webgl/WebGL.ts", 70);
                    akra.logger.warning("Extension " + sExtName + " unsupported for this platform.");
                }
                ;
                return false;
            }
            if (pWebGLExtension = pWebGLContext.getExtension(sExtName)) {
                if (((pWebGLExtentionList[sExtName]) != null)) {
                    // debug_print("Extension " + sExtName + " already loaded for this context.");
                    return true;
                }
                pWebGLExtentionList[sExtName] = pWebGLExtension;
 {
                    akra.logger.setSourceLocation("webgl/WebGL.ts", 82);
                    akra.logger.log("loaded WebGL extension: ", sExtName);
                }
                ;
                for(var j in pWebGLExtension) {
                    if ((/*checked (origin: akra)>>*/akra.typeOf((pWebGLExtension[j])) === "function")) {
                        //debug_print("created func WebGLRenderingContext::" + j + "(...)");
                        pWebGLContext[j] = function () {
                            pWebGLContext[j] = new Function("var t = this.extentionList[" + sExtName + "];" + "t." + j + ".apply(t, arguments);");
                        };
                    } else {
                        //debug_print("created const WebGLRenderingContext::" + j + " = " + pWebGLExtension[j]);
                        pWebGLContext[j] = pWebGLExtension[j];
                    }
                }
                return true;
            }
 {
                akra.logger.setSourceLocation("webgl/WebGL.ts", 103);
                akra.logger.warning("cannot load extension: ", sExtName);
            }
            ;
            return false;
        }
        webgl.loadExtension = loadExtension;
        function checkIsAngle(pWebGLContext) {
            var pProgram = pWebGLContext.createProgram();
            var sVertex = "            attribute vec3 pos;            struct S {              vec3 b[1];            };            uniform S s[1];            void main(void) {              float t = s[0].b[0].x;              gl_Position = vec4(pos, 1. + t);            }";
            var sFragment = "void main(void){}";
            var pVertexShader = pWebGLContext.createShader(0x8B31);
            var pFragmentShader = pWebGLContext.createShader(0x8B30);
            pWebGLContext.shaderSource(pVertexShader, sVertex);
            pWebGLContext.compileShader(pVertexShader);
            pWebGLContext.shaderSource(pFragmentShader, sFragment);
            pWebGLContext.compileShader(pFragmentShader);
            pWebGLContext.attachShader(pProgram, pVertexShader);
            pWebGLContext.attachShader(pProgram, pFragmentShader);
            pWebGLContext.linkProgram(pProgram);
            if (!pWebGLContext.getProgramParameter(pProgram, 0x8B82)) {
 {
                    akra.logger.setSourceLocation("webgl/WebGL.ts", 138);
                    akra.logger.error("cannot compile GLSL shader for ANGLE renderer");
                }
                ;
 {
                    akra.logger.setSourceLocation("webgl/WebGL.ts", 140);
                    akra.logger.log(pWebGLContext.getShaderInfoLog(pVertexShader));
                }
                ;
 {
                    akra.logger.setSourceLocation("webgl/WebGL.ts", 141);
                    akra.logger.log(pWebGLContext.getShaderSource(pVertexShader) || sVertex);
                }
                ;
 {
                    akra.logger.setSourceLocation("webgl/WebGL.ts", 143);
                    akra.logger.log(pWebGLContext.getShaderInfoLog(pFragmentShader));
                }
                ;
 {
                    akra.logger.setSourceLocation("webgl/WebGL.ts", 144);
                    akra.logger.log(pWebGLContext.getShaderSource(pFragmentShader) || sFragment);
                }
                ;
                return false;
            }
 {
                akra.logger.setSourceLocation("webgl/WebGL.ts", 150);
                akra.logger.assert(pWebGLContext.getProgramParameter(pProgram, 0x8B86) > 0, "no uniforms founded in angle test shader!");
            }
            ;
            return pWebGLContext.getActiveUniform(pProgram, 0).name != "s[0].b[0]";
        }
        function setupContext(pWebGLContext) {
            //test context not created yet
            if (((/*checked (origin: webgl)>>*/akra.webgl.pSupportedExtensionList) === null)) {
                return pWebGLContext;
            }
            for(var i = 0; i < webgl.pSupportedExtensionList.length; ++i) {
                if (!loadExtension(pWebGLContext, webgl.pSupportedExtensionList[i])) {
                    webgl.pSupportedExtensionList.splice(i, 1);
                }
            }
            return pWebGLContext;
        }
        webgl.isEnabled = /** @inline */function () {
            return isSupported;
        };
        function createContext(pCanvas, pOptions) {
            if (typeof pCanvas === "undefined") { pCanvas = document.createElement("canvas"); }
            var pWebGLContext = null;
            try  {
                pWebGLContext = pCanvas.getContext("webgl", pOptions) || pCanvas.getContext("experimental-webgl", pOptions);
            } catch (e) {
                throw e;
            }
            if (((pWebGLContext) != null)) {
                return setupContext(pWebGLContext);
            }
 {
                akra.logger.setSourceLocation("webgl/WebGL.ts", 196);
                akra.logger.warning("cannot get 3d device");
            }
            ;
            return null;
        }
        webgl.createContext = createContext;
        (function (pWebGLContext) {
            if (!pWebGLContext) {
                return;
            }
            webgl.maxTextureSize = pWebGLContext.getParameter(0x0D33);
            webgl.maxCubeMapTextureSize = pWebGLContext.getParameter(0x851C);
            webgl.maxViewPortSize = pWebGLContext.getParameter(0x0D3A);
            webgl.maxTextureImageUnits = pWebGLContext.getParameter(0x8872);
            webgl.maxVertexAttributes = pWebGLContext.getParameter(0x8869);
            webgl.maxVertexTextureImageUnits = pWebGLContext.getParameter(0x8B4C);
            webgl.maxCombinedTextureImageUnits = pWebGLContext.getParameter(0x8B4D);
            webgl.stencilBits = pWebGLContext.getParameter(0x0D57);
            webgl.colorBits = [
                pWebGLContext.getParameter(0x0D52), 
                pWebGLContext.getParameter(0x0D53), 
                pWebGLContext.getParameter(0x0D54)
            ];
            webgl.alphaBits = pWebGLContext.getParameter(0x0D55);
            webgl.multisampleType = pWebGLContext.getParameter(0x80AA);
            webgl.pSupportedExtensionList = pWebGLContext.getSupportedExtensions();
            //pSupportedExtensionList.push(WEBGL_DEBUG_SHADERS, WEBGL_DEBUG_RENDERER_INFO);
            isSupported = true;
            webgl.isANGLE = checkIsAngle(pWebGLContext);
 {
                akra.logger.setSourceLocation("webgl/WebGL.ts", 237);
                akra.logger.log("WebGL running under " + (webgl.isANGLE ? "ANGLE/DirectX" : "Native GL"));
            }
            ;
        })(createContext());
        function hasExtension(sExtName) {
            for(var i = 0; i < webgl.pSupportedExtensionList.length; ++i) {
                if (webgl.pSupportedExtensionList[i].search(sExtName) != -1) {
                    return true;
                }
            }
            return false;
        }
        webgl.hasExtension = hasExtension;
        function getWebGLUsage(iFlags) {
            if ((((iFlags) & (akra.EHardwareBufferFlags.DYNAMIC)) != 0)) {
                return 0x88E8;
            } else if ((((iFlags) & (akra.EHardwareBufferFlags.STREAM)) != 0)) {
                return 0x88E0;
            }
            return 0x88E4;
        }
        webgl.getWebGLUsage = getWebGLUsage;
        function getWebGLFormat(eFormat) {
            switch(eFormat) {
                case akra.EPixelFormats.L8:
                case akra.EPixelFormats.L16:
                    return 0x1909;
                case akra.EPixelFormats.A8:
                    return 0x1906;
                case akra.EPixelFormats.A4L4:
                case akra.EPixelFormats.BYTE_LA:
                    return 0x190A;
                case akra.EPixelFormats.R5G6B5:
                    return 0;
                case akra.EPixelFormats.B5G6R5:
                    return 0x1907;
                case akra.EPixelFormats.R3G3B2:
                    return 0;
                case akra.EPixelFormats.A4R4G4B4:
                case akra.EPixelFormats.A1R5G5B5:
                    return 0x1908;
                case akra.EPixelFormats.R8G8B8:
                case akra.EPixelFormats.B8G8R8:
                    return 0x1907;
                case akra.EPixelFormats.A8R8G8B8:
                case akra.EPixelFormats.A8B8G8R8:
                    return 0x1908;
                case akra.EPixelFormats.B8G8R8A8:
                case akra.EPixelFormats.R8G8B8A8:
                case akra.EPixelFormats.X8R8G8B8:
                case akra.EPixelFormats.X8B8G8R8:
                    return 0x1908;
                case akra.EPixelFormats.A2R10G10B10:
                    return 0;
                case akra.EPixelFormats.A2B10G10R10:
                    return 0x1908;
                case akra.EPixelFormats.DXT1:
                    return 0x83F1;
                case akra.EPixelFormats.DXT2:
                    return 0;
                case akra.EPixelFormats.DXT3:
                    return 0x83F2;
                case akra.EPixelFormats.DXT4:
                    return 0;
                case akra.EPixelFormats.DXT5:
                    return 0x83F3;
                case akra.EPixelFormats.FLOAT16_R:
                    return 0;
                case akra.EPixelFormats.FLOAT16_RGB:
                    return 0x1907;
                case akra.EPixelFormats.FLOAT16_RGBA:
                    return 0x1908;
                case akra.EPixelFormats.FLOAT32_R:
                    return 0;
                case akra.EPixelFormats.FLOAT32_RGB:
                    return 0x1907;
                case akra.EPixelFormats.FLOAT32_RGBA:
                    return 0x1908;
                case akra.EPixelFormats.FLOAT16_GR:
                case akra.EPixelFormats.FLOAT32_GR:
                    return 0;
                case akra.EPixelFormats.FLOAT32_DEPTH:
                case akra.EPixelFormats.DEPTH32:
                case akra.EPixelFormats.DEPTH16:
                case akra.EPixelFormats.DEPTH8:
                    return 0x1902;
                case akra.EPixelFormats.DEPTH24STENCIL8:
                    return 0x84F9;
                case akra.EPixelFormats.SHORT_RGBA:
                    return 0x1908;
                case akra.EPixelFormats.SHORT_GR:
                    return 0;
                case akra.EPixelFormats.SHORT_RGB:
                    return 0x1907;
                case akra.EPixelFormats.PVRTC_RGB2:
                    return 0x8C01;
                case akra.EPixelFormats.PVRTC_RGBA2:
                    return 0x8C03;
                case akra.EPixelFormats.PVRTC_RGB4:
                    return 0x8C00;
                case akra.EPixelFormats.PVRTC_RGBA4:
                    return 0x8C02;
                case akra.EPixelFormats.R8:
                case akra.EPixelFormats.RG8:
                    return 0;
                default:
 {
                        akra.logger.setSourceLocation("webgl/WebGL.ts", 364);
                        akra.logger.warning("getWebGLFormat unknown format", eFormat);
                    }
                    ;
                    return 0;
            }
        }
        webgl.getWebGLFormat = getWebGLFormat;
        function isWebGLFormatSupport(eFormat) {
            switch(eFormat) {
                case akra.EPixelFormats.DXT1:
                case akra.EPixelFormats.DXT3:
                case akra.EPixelFormats.DXT5:
                    return webgl.hasExtension("WEBGL_compressed_texture_s3tc");
                case akra.EPixelFormats.PVRTC_RGB2:
                case akra.EPixelFormats.PVRTC_RGBA2:
                case akra.EPixelFormats.PVRTC_RGB4:
                case akra.EPixelFormats.PVRTC_RGBA4:
                    return webgl.hasExtension("WEBGL_compressed_texture_pvrtc");
                case akra.EPixelFormats.DEPTH32:
                case akra.EPixelFormats.DEPTH16:
                case akra.EPixelFormats.DEPTH24STENCIL8:
                    return webgl.hasExtension("WEBGL_depth_texture");
                case akra.EPixelFormats.DEPTH32:
                case akra.EPixelFormats.DEPTH16:
                case akra.EPixelFormats.DEPTH24STENCIL8:
                    return webgl.hasExtension("WEBGL_depth_texture");
                case akra.EPixelFormats.FLOAT16_RGB:
                case akra.EPixelFormats.FLOAT16_RGBA:
                    return webgl.hasExtension("OES_texture_half_float");
                case akra.EPixelFormats.FLOAT32_RGB:
                case akra.EPixelFormats.FLOAT32_RGBA:
                    return webgl.hasExtension("OES_texture_float");
            }
            if (getWebGLFormat(eFormat) && getWebGLDataType(eFormat)) {
                // switch(eFormat)
                // {
                //     case EPixelFormats.FLOAT32_DEPTH:
                //     case EPixelFormats.L16:
                //         return false;
                // }
                return true;
            }
            return false;
        }
        webgl.isWebGLFormatSupport = isWebGLFormatSupport;
        function getWebGLDataType(eFormat) {
            switch(eFormat) {
                case akra.EPixelFormats.L8:
                    return 0x1401;
                case akra.EPixelFormats.L16:
                    //return GL_UNSIGNED_SHORT;
                    return 0x1401;
                case akra.EPixelFormats.A8:
                    return 0x1401;
                case akra.EPixelFormats.A4L4:
                    return 0;
                case akra.EPixelFormats.BYTE_LA:
                    return 0x1401;
                case akra.EPixelFormats.R5G6B5:
                case akra.EPixelFormats.B5G6R5:
                    return 0x8363;
                case akra.EPixelFormats.R3G3B2:
                    return 0;
                case akra.EPixelFormats.A4R4G4B4:
                    return 0x8033;
                case akra.EPixelFormats.A1R5G5B5:
                    return 0x8034;
                case akra.EPixelFormats.R8G8B8:
                case akra.EPixelFormats.B8G8R8:
                case akra.EPixelFormats.A8R8G8B8:
                case akra.EPixelFormats.A8B8G8R8:
                case akra.EPixelFormats.B8G8R8A8:
                case akra.EPixelFormats.R8G8B8A8:
                case akra.EPixelFormats.X8R8G8B8:
                case akra.EPixelFormats.X8B8G8R8:
                    return 0x1401;
                case akra.EPixelFormats.A2R10G10B10:
                    return 0;
                case akra.EPixelFormats.A2B10G10R10:
                    return 0;
                case akra.EPixelFormats.DXT1:
                case akra.EPixelFormats.DXT2:
                case akra.EPixelFormats.DXT3:
                case akra.EPixelFormats.DXT4:
                case akra.EPixelFormats.DXT5:
                    return 0;
                case akra.EPixelFormats.FLOAT16_R:
                case akra.EPixelFormats.FLOAT16_RGB:
                case akra.EPixelFormats.FLOAT16_RGBA:
                    return 0x8D61;
                case akra.EPixelFormats.FLOAT32_R:
                case akra.EPixelFormats.FLOAT32_RGB:
                case akra.EPixelFormats.FLOAT32_RGBA:
                case akra.EPixelFormats.FLOAT16_GR:
                case akra.EPixelFormats.FLOAT32_GR:
                    return 0x1406;
                case akra.EPixelFormats.FLOAT32_DEPTH:
                    return 0x1406;
                case akra.EPixelFormats.DEPTH8:
                    return 0x1401;
                case akra.EPixelFormats.DEPTH16:
                    return 0x1403;
                case akra.EPixelFormats.DEPTH32:
                    return 0x1405;
                case akra.EPixelFormats.DEPTH24STENCIL8:
                    return 0x8367;
                case akra.EPixelFormats.SHORT_RGBA:
                case akra.EPixelFormats.SHORT_GR:
                case akra.EPixelFormats.SHORT_RGB:
                    return 0x1403;
                case akra.EPixelFormats.PVRTC_RGB2:
                case akra.EPixelFormats.PVRTC_RGBA2:
                case akra.EPixelFormats.PVRTC_RGB4:
                case akra.EPixelFormats.PVRTC_RGBA4:
                    return 0;
                case akra.EPixelFormats.R8:
                case akra.EPixelFormats.RG8:
                    return 0x1401;
                default:
 {
                        akra.logger.setSourceLocation("webgl/WebGL.ts", 504);
                        akra.logger.criticalError("getWebGLFormat unknown format");
                    }
                    ;
                    return 0;
            }
        }
        webgl.getWebGLDataType = getWebGLDataType;
        function getWebGLInternalFormat(eFormat) {
            if (!(((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor(((eFormat))).flags) & /*checked (origin: akra)>>*/akra.EPixelFormatFlags.COMPRESSED) > 0)) {
                return getWebGLFormat(eFormat);
            } else {
                switch(eFormat) {
                    case akra.EPixelFormats.DXT1:
                        return 0x83F1;
                    case akra.EPixelFormats.DXT2:
                        return 0;
                    case akra.EPixelFormats.DXT3:
                        return 0x83F2;
                    case akra.EPixelFormats.DXT4:
                        return 0;
                    case akra.EPixelFormats.DXT5:
                        return 0x83F3;
                    case akra.EPixelFormats.PVRTC_RGB2:
                        return 0x8C01;
                    case akra.EPixelFormats.PVRTC_RGBA2:
                        return 0x8C03;
                    case akra.EPixelFormats.PVRTC_RGB4:
                        return 0x8C00;
                    case akra.EPixelFormats.PVRTC_RGBA4:
                        return 0x8C02;
                }
            }
        }
        webgl.getWebGLInternalFormat = getWebGLInternalFormat;
        function getWebGLPrimitiveType(eType) {
            switch(eType) {
                case akra.EPrimitiveTypes.POINTLIST:
                    return 0x0000;
                case akra.EPrimitiveTypes.LINELIST:
                    return 0x0001;
                case akra.EPrimitiveTypes.LINELOOP:
                    return 0x0002;
                case akra.EPrimitiveTypes.LINESTRIP:
                    return 0x0003;
                case akra.EPrimitiveTypes.TRIANGLELIST:
                    return 0x0004;
                case akra.EPrimitiveTypes.TRIANGLESTRIP:
                    return 0x0005;
                case akra.EPrimitiveTypes.TRIANGLEFAN:
                    return 0x0006;
            }
            return 0x0000;
        }
        webgl.getWebGLPrimitiveType = getWebGLPrimitiveType;
        //не знаю что делает эта функция
        function getClosestWebGLInternalFormat(eFormat, isHWGamma) {
            if (typeof isHWGamma === "undefined") { isHWGamma = false; }
            var iGLFormat = webgl.getWebGLInternalFormat(eFormat);
            if (iGLFormat === 0) {
                if (isHWGamma) {
                    // TODO not supported
                    return 0;
                } else {
                    return 0x1908;
                }
            } else {
                return iGLFormat;
            }
        }
        webgl.getClosestWebGLInternalFormat = getClosestWebGLInternalFormat;
        /**
        * Convert GL format to EPixelFormat.
        */
        function getClosestAkraFormat(iGLFormat, iGLDataType) {
            switch(iGLFormat) {
                case 0x8C01:
                    return webgl.hasExtension("WEBGL_compressed_texture_pvrtc") ? akra.EPixelFormats.PVRTC_RGB2 : akra.EPixelFormats.A8R8G8B8;
                case 0x8C03:
                    return webgl.hasExtension("WEBGL_compressed_texture_pvrtc") ? akra.EPixelFormats.PVRTC_RGBA2 : akra.EPixelFormats.A8R8G8B8;
                case 0x8C00:
                    return webgl.hasExtension("WEBGL_compressed_texture_pvrtc") ? akra.EPixelFormats.PVRTC_RGB4 : akra.EPixelFormats.A8R8G8B8;
                case 0x8C02:
                    return webgl.hasExtension("WEBGL_compressed_texture_pvrtc") ? akra.EPixelFormats.PVRTC_RGBA4 : akra.EPixelFormats.A8R8G8B8;
                case 0x1909:
                    return akra.EPixelFormats.L8;
                case 0x1906:
                    return akra.EPixelFormats.A8;
                case 0x190A:
                    return akra.EPixelFormats.BYTE_LA;
                case 0x1907:
                    switch(iGLDataType) {
                        case 0x8363:
                            return akra.EPixelFormats.B5G6R5;
                        default:
                            return akra.EPixelFormats.R8G8B8;
                    }
                case 0x1908:
                    switch(iGLDataType) {
                        case 0x8034:
                            return akra.EPixelFormats.A1R5G5B5;
                        case 0x8033:
                            return akra.EPixelFormats.A4R4G4B4;
                        case 0x1406:
                            return akra.EPixelFormats.FLOAT32_RGBA;
                        default:
                            return akra.EPixelFormats.R8G8B8A8;
                            // return EPixelFormats.A8B8G8R8;
                                                }
                case 0x80E1:
                    return akra.EPixelFormats.A8B8G8R8;
                case 0x83F0:
                case 0x83F1:
                    return webgl.hasExtension("WEBGL_compressed_texture_s3tc") ? akra.EPixelFormats.DXT1 : akra.EPixelFormats.A8R8G8B8;
                case 0x83F2:
                    return webgl.hasExtension("WEBGL_compressed_texture_s3tc") ? akra.EPixelFormats.DXT3 : akra.EPixelFormats.A8R8G8B8;
                case 0x83F3:
                    return webgl.hasExtension("WEBGL_compressed_texture_s3tc") ? akra.EPixelFormats.DXT5 : akra.EPixelFormats.A8R8G8B8;
                case 0x8229:
                    return webgl.hasExtension("EXT_texture_rg") ? akra.EPixelFormats.R8 : akra.EPixelFormats.A8R8G8B8;
                case 0x822B:
                    return webgl.hasExtension("EXT_texture_rg") ? akra.EPixelFormats.RG8 : akra.EPixelFormats.A8R8G8B8;
                case 0x1902:
                    switch(iGLDataType) {
                        case 0x1406:
                            return akra.EPixelFormats.FLOAT32_DEPTH;
                        case 0x1405:
                            return akra.EPixelFormats.DEPTH32;
                        case 0x1403:
                            return akra.EPixelFormats.DEPTH16;
                        case 0x1401:
                            return akra.EPixelFormats.DEPTH8;
                    }
                case 0x84F9:
                    return akra.EPixelFormats.DEPTH24STENCIL8;
                default:
                    //TODO: not supported
                    return akra.EPixelFormats.A8R8G8B8;
            }
        }
        webgl.getClosestAkraFormat = getClosestAkraFormat;
        function optionalPO2(iValue) {
            if (webgl.hasNonPowerOf2Textures) {
                return iValue;
            } else {
                return akra.math.ceilingPowerOfTwo(iValue);
            }
        }
        webgl.optionalPO2 = optionalPO2;
        function convertToWebGLformat(pSource, pDest) {
            // Always need to convert PF_A4R4G4B4, GL expects the colors to be in the
            // reverse order
            if (pDest.format == akra.EPixelFormats.A4R4G4B4) {
                // Convert PF_A4R4G4B4 -> PF_B4G4R4A4
                // Reverse pixel order
                var iSrcPtr = (pSource.left + pSource.top * pSource.rowPitch + pSource.front * pSource.slicePitch);
                var iDstPtr = (pDest.left + pDest.top * pDest.rowPitch + pDest.front * pDest.slicePitch);
                var iSrcSliceSkip = pSource.getSliceSkip();
                var iDstSliceSkip = pDest.getSliceSkip();
                var k = pSource.right - pSource.left;
                var x = 0, y = 0, z = 0;
                for(z = pSource.front; z < pSource.back; z++) {
                    for(y = pSource.top; y < pSource.bottom; y++) {
                        for(x = 0; x < k; x++) {
                            /* B*/
                            pDest[iDstPtr + x] = ((pSource[iSrcPtr + x] & 0x000F) << 12) | /* G*/
                            ((pSource[iSrcPtr + x] & 0x00F0) << 4) | /* R*/
                            ((pSource[iSrcPtr + x] & 0x0F00) >> 4) | /* A*/
                            ((pSource[iSrcPtr + x] & 0xF000) >> 12);
                        }
                        iSrcPtr += pSource.rowPitch;
                        iDstPtr += pDest.rowPitch;
                    }
                    iSrcPtr += iSrcSliceSkip;
                    iDstPtr += iDstSliceSkip;
                }
            }
        }
        webgl.convertToWebGLformat = convertToWebGLformat;
        function checkFBOAttachmentFormat(eFormat) {
            if (eFormat === akra.EPixelFormats.R8G8B8A8 || eFormat === akra.EPixelFormats.R8G8B8) {
                return true;
            } else if (eFormat === akra.EPixelFormats.A8B8G8R8) {
                return true;
            } else if (eFormat === akra.EPixelFormats.FLOAT32_RGBA) {
                // return hasExtension(WEBGL_COLOR_BUFFER_FLOAT);
                return hasExtension("OES_texture_float");
            } else if (eFormat === akra.EPixelFormats.FLOAT16_RGBA) {
                // return hasExtension(EXT_COLOR_BUFFER_HALF_FLOAT);
                return hasExtension("OES_texture_half_float");
            } else if (eFormat === akra.EPixelFormats.DEPTH32) {
                return true;
            } else {
                return false;
            }
        }
        webgl.checkFBOAttachmentFormat = checkFBOAttachmentFormat;
        function checkReadPixelFormat(eFormat) {
            if (eFormat === akra.EPixelFormats.R8G8B8A8 || eFormat === akra.EPixelFormats.R8G8B8) {
                return true;
            } else // else if(eFormat === EPixelFormats.A8B8G8R8){
            //     return true;
            // }
            if (eFormat === akra.EPixelFormats.FLOAT32_RGBA) {
                //hasExtension(WEBGL_COLOR_BUFFER_FLOAT) || hasExtension(EXT_COLOR_BUFFER_HALF_FLOAT);
                return false;
            } else {
                return false;
            }
        }
        webgl.checkReadPixelFormat = checkReadPixelFormat;
        function checkCopyTexImage(eFormat) {
            switch(eFormat) {
                case akra.EPixelFormats.R8G8B8A8:
                case akra.EPixelFormats.R8G8B8:
                case akra.EPixelFormats.L8:
                case akra.EPixelFormats.L16:
                case akra.EPixelFormats.A8:
                    return true;
                default:
                    return false;
            }
        }
        webgl.checkCopyTexImage = checkCopyTexImage;
        function getSupportedAlternative(eFormat) {
            if (checkFBOAttachmentFormat(eFormat)) {
                return eFormat;
            }
            /// Find first alternative
            var pct = (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor((eFormat)).componentType);
            switch(pct) {
                case akra.EPixelComponentTypes.BYTE:
                    eFormat = akra.EPixelFormats.A8R8G8B8;
                    break;
                case akra.EPixelComponentTypes.SHORT:
                    eFormat = akra.EPixelFormats.SHORT_RGBA;
                    break;
                case akra.EPixelComponentTypes.FLOAT16:
                    eFormat = akra.EPixelFormats.FLOAT16_RGBA;
                    break;
                case akra.EPixelComponentTypes.FLOAT32:
                    eFormat = akra.EPixelFormats.FLOAT32_RGBA;
                    break;
                case akra.EPixelComponentTypes.COUNT:
                default:
                    break;
            }
            if (checkFBOAttachmentFormat(eFormat)) {
                return eFormat;
            }
            /// If none at all, return to default
            return akra.EPixelFormats.A8R8G8B8;
        }
        webgl.getSupportedAlternative = getSupportedAlternative;
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var ApiInfo = (function (_super) {
            __extends(ApiInfo, _super);
            function ApiInfo() {
                        _super.call(this);
                this.bWebGL = false;
                this.bWebAudio = false;
                this.bFile = false;
                this.bFileSystem = false;
                this.bWebWorker = false;
                this.bTransferableObjects = false;
                this.bLocalStorage = false;
                this.bWebSocket = false;
                this.bGamepad = false;
                var pApi = {};
                this.bWebAudio = ((window).AudioContext && (window).webkitAudioContext ? true : false);
                this.bFile = ((window).File && (window).FileReader && (window).FileList && (window).Blob ? true : false);
                this.bFileSystem = (this.bFile && (window).URL && (window).requestFileSystem ? true : false);
                this.bWebWorker = (((window).Worker) !== undefined);
                this.bLocalStorage = (((window).localStorage) !== undefined);
                this.bWebSocket = (((window).WebSocket) !== undefined);
                this.bGamepad = !!(navigator).webkitGetGamepads || !!(navigator).webkitGamepads || (navigator.userAgent.indexOf('Firefox/') != -1);
            }
            Object.defineProperty(ApiInfo.prototype, "webGL", {
                get: /** @inline */function () {
                    return (isSupported);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ApiInfo.prototype, "transferableObjects", {
                get: function () {
                    if (!this.bTransferableObjects) {
                        this.bTransferableObjects = (this.bWebWorker && this.chechTransferableObjects() ? true : false);
                    }
                    return this.bTransferableObjects;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ApiInfo.prototype, "file", {
                get: /** @inline */function () {
                    return this.bFile;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ApiInfo.prototype, "fileSystem", {
                get: /** @inline */function () {
                    return this.bFileSystem;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ApiInfo.prototype, "webAudio", {
                get: /** @inline */function () {
                    return this.bWebAudio;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ApiInfo.prototype, "webWorker", {
                get: /** @inline */function () {
                    return this.bWebWorker;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ApiInfo.prototype, "localStorage", {
                get: /** @inline */function () {
                    return this.bLocalStorage;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ApiInfo.prototype, "webSocket", {
                get: /** @inline */function () {
                    return this.bWebSocket;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ApiInfo.prototype, "gamepad", {
                get: /** @inline */function () {
                    return this.bGamepad;
                },
                enumerable: true,
                configurable: true
            });
            ApiInfo.prototype.chechTransferableObjects = function () {
                var pBlob = new Blob([
                    "onmessage = function(e) { postMessage(true); }"
                ], {
                    "type": "text\/javascript"
                });
                var sBlobURL = (window).URL.createObjectURL(pBlob);
                var pWorker = new Worker(sBlobURL);
                var pBuffer = new ArrayBuffer(1);
                try  {
                    pWorker.postMessage(pBuffer, [
                        pBuffer
                    ]);
                } catch (e) {
 {
                        util.logger.setSourceLocation("util/ApiInfo.ts", 85);
                        util.logger.log('transferable objects not supported in your browser...');
                    }
                    ;
                }
                pWorker.terminate();
                if (pBuffer.byteLength) {
                    return false;
                }
                return true;
            };
            return ApiInfo;
        })(util.Singleton);
        util.ApiInfo = ApiInfo;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (info) {
                        function canvas(id) {
            var pCanvas = (typeof (id) === "string") ? document.getElementById(id) : id;
            return {
                width: (typeof (pCanvas.width) === "number") ? pCanvas.width : parseInt(pCanvas.style.width),
                height: (typeof (pCanvas.height) === "number") ? pCanvas.height : parseInt(pCanvas.style.height),
                id: pCanvas.id
            };
        }
        info.canvas = canvas;
        info.browser = new akra.util.BrowserInfo();
        info.api = new akra.util.ApiInfo();
        info.screen = new akra.util.ScreenInfo();
        info.uri = (new /*checked (origin: akra)>>*/akra.util.URI((document.location.href)));
        var is;
        (function (is) {
            /**
            * show status - online or offline
            */
            is.online;
            /**
            * perform test on mobile device
            */
            is.mobile = (/mobile|iphone|ipad|ipod|android|blackberry|mini|windows\sce|palm/i).test(navigator.userAgent.toLowerCase());
            is.linux = info.browser.os === 'Linux';
            is.windows = info.browser.os === 'Windows';
            is.mac = info.browser.os === 'Mac';
            is.iPhone = info.browser.os === 'iPhone';
        })(is || (is = {}));
        //TODO: move it to [akra.info.is] module, when typescript access this.
        Object.defineProperty(is, 'online', {
            get: function () {
                return navigator.onLine;
            }
        });
    })(akra.info || (akra.info = {}));
    var info = akra.info;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        (function (EThreadStatuses) {
            EThreadStatuses._map = [];
            EThreadStatuses._map[0] = "k_WorkerBusy";
            EThreadStatuses.k_WorkerBusy = 0;
            EThreadStatuses._map[1] = "k_WorkerFree";
            EThreadStatuses.k_WorkerFree = 1;
        })(util.EThreadStatuses || (util.EThreadStatuses = {}));
        var EThreadStatuses = util.EThreadStatuses;
        var ThreadManager = (function () {
            function ThreadManager(sScript) {
                if (typeof sScript === "undefined") { sScript = null; }
                var _this = this;
                this._pWorkerList = [];
                this._pStatsList = [];
                this._sDefaultScript = sScript;
                setInterval(function () {
                    var pStats;
                    var iNow = (Date.now());
                    for(var i = 0, n = _this._pStatsList.length; i < n; ++i) {
                        pStats = _this._pStatsList[i];
                        if (pStats.releaseTime > 0 && iNow - pStats.releaseTime > 30 * 1000) {
                            if (_this.terminateThread(i)) {
 {
                                    util.logger.setSourceLocation("util/ThreadManager.ts", 45);
                                    util.logger.log("thread with id - " + i + " terminated. (" + i + "/" + n + ")");
                                }
                                ;
                                return;
                            }
 {
                                util.logger.setSourceLocation("util/ThreadManager.ts", 49);
                                util.logger.warning("thread must be removed: " + i);
                            }
                            ;
                        }
                    }
                    ;
                }, 30000);
            }
            ThreadManager.prototype.createThread = function () {
                //console.log((new Error).stack)
                if (this._pWorkerList.length === 32) {
 {
                        util.logger.setSourceLocation("util/ThreadManager.ts", 58);
                        util.logger.error("Reached limit the number of threads");
                    }
                    ;
                    return false;
                }
                if (!akra.info.api.webWorker) {
 {
                        util.logger.setSourceLocation("util/ThreadManager.ts", 63);
                        util.logger.error("WebWorkers unsupprted..");
                    }
                    ;
                    return false;
                }
                var pWorker = (new Worker(this._sDefaultScript));
                pWorker.id = this._pWorkerList.length;
                pWorker.send = (pWorker).postMessage;
                this._pWorkerList.push(pWorker);
                this._pStatsList.push({
                    status: EThreadStatuses.k_WorkerFree,
                    creationTime: (Date.now()),
                    releaseTime: (Date.now())
                });
                return true;
            };
            ThreadManager.prototype.occupyThread = function () {
                var pStats;
                for(var i = 0, n = this._pWorkerList.length; i < n; ++i) {
                    pStats = this._pStatsList[i];
                    if (pStats.status == EThreadStatuses.k_WorkerFree) {
                        pStats.status = EThreadStatuses.k_WorkerBusy;
                        pStats.releaseTime = 0;
                        return this._pWorkerList[i];
                    }
                }
                if (this.createThread()) {
                    return this.occupyThread();
                } else {
 {
                        util.logger.setSourceLocation("util/ThreadManager.ts", 99);
                        util.logger.error("cannot occupy thread");
                    }
                    ;
                    return null;
                }
            };
            ThreadManager.prototype.terminateThread = function (iThread) {
                var pStats = this._pStatsList[iThread];
                var pWorker = this._pWorkerList[iThread];
                if (!((pWorker) != null) && pStats.status != EThreadStatuses.k_WorkerFree) {
                    return false;
                }
                (pWorker).terminate();
                this._pStatsList.splice(iThread);
                this._pWorkerList.splice(iThread);
                return true;
            };
            ThreadManager.prototype.releaseThread = function (pThread) {
                var iThread;
                var pStats;
                if (!(typeof (pThread) === "number")) {
                    iThread = pThread.id;
                } else {
                    iThread = pThread;
                }
                if (((this._pStatsList[iThread]) !== undefined)) {
                    pStats = this._pStatsList[iThread];
                    pStats.status = EThreadStatuses.k_WorkerFree;
                    pStats.releaseTime = (Date.now());
                }
                return false;
            };
            ThreadManager.prototype.initialize = function () {
                return true;
            };
            ThreadManager.prototype.destroy = function () {
            };
            return ThreadManager;
        })();
        util.ThreadManager = ThreadManager;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    //переносим все зависисмости в папку js паки с данными
    //обычно, это data/js
    /// @: {data}/js/FileInterface.t.js|src(inc/io/FileInterface.t.js)|data_location({data},DATA)
    /// @FILE_LOCAL_THREAD: {data}/js/LocalFile.t.js|src(inc/io/LocalFile.t.js)|data_location({data},DATA)
    /// @FILE_REMOTE_THREAD: {data}/js/RemoteFile.t.js|src(inc/io/RemoteFile.t.js)|data_location({data},DATA)
    (function (io) {
        (function (EFileActions) {
            EFileActions._map = [];
            EFileActions.k_Open = 1;
            EFileActions.k_Read = 2;
            EFileActions._map[3] = "k_Write";
            EFileActions.k_Write = 3;
            EFileActions._map[4] = "k_Clear";
            EFileActions.k_Clear = 4;
            EFileActions._map[5] = "k_Exists";
            EFileActions.k_Exists = 5;
            EFileActions._map[6] = "k_Remove";
            EFileActions.k_Remove = 6;
        })(io.EFileActions || (io.EFileActions = {}));
        var EFileActions = io.EFileActions;
        ;
        (function (EFileTransferModes) {
            EFileTransferModes._map = [];
            EFileTransferModes._map[0] = "k_Normal";
            EFileTransferModes.k_Normal = 0;
            EFileTransferModes._map[1] = "k_Fast";
            EFileTransferModes.k_Fast = 1;
            EFileTransferModes._map[2] = "k_Slow";
            EFileTransferModes.k_Slow = 2;
        })(io.EFileTransferModes || (io.EFileTransferModes = {}));
        var EFileTransferModes = io.EFileTransferModes;
        var pLocalFileThreadManager = new akra.util.ThreadManager(akra.DATA + "/js/LocalFile.t.js");
        var pRemoteFileThreadManager = new akra.util.ThreadManager(akra.DATA + "/js/RemoteFile.t.js");
        io.getLocalFileThreadManager = /** @inline */function () {
            return pLocalFileThreadManager;
        };
        io.getRemoteFileThreadManager = /** @inline */function () {
            return pRemoteFileThreadManager;
        };
        var TOTAL_BYTES_READED = 0;
        var TFile = (function () {
            function TFile(sFilename, sMode, fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = TFile.defaultCallback; }
                /**@protected*/ this._pUri = null;
                /**@protected*/ this._nCursorPosition = 0;
                /**@protected*/ this._bOpened = false;
                /**@protected*/ this._eTransferMode = EFileTransferModes.k_Normal;
                /**@protected*/ this._pFileMeta = null;
                /**@protected*/ this._isLocal = false;
                if (((sMode) !== undefined)) {
                    this._iMode = (typeof (sMode) === "string") ? io.filemode(sMode) : sMode;
                }
                this.setAndValidateUri((new /*checked (origin: akra)>>*/akra.util.URI((sFilename))));
                if (akra.info.api.transferableObjects) {
                    this._eTransferMode = EFileTransferModes.k_Fast;
                }
                //OPERA MOVED TO WEBKIT, and this TRAP not more be needed!
                // else if (info.browser.name == "Opera") {
                // 	this._eTransferMode = EFileTransferModes.k_Slow;
                // }
                if (arguments.length > 2) {
                    this.open(sFilename, sMode, fnCallback);
                }
            }
            Object.defineProperty(TFile.prototype, "path", {
                get: /** @inline */function () {
 {
                        akra.logger.setSourceLocation("TFile.ts", 84);
                        akra.logger.assert(((this._pFileMeta) != null), "There is no file handle open.");
                    }
                    ;
                    return this._pUri.toString();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TFile.prototype, "name", {
                get: /** @inline */function () {
                    return akra.util.pathinfo(this._pUri.path).basename;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TFile.prototype, "mode", {
                get: /** @inline */function () {
                    return this._iMode;
                },
                set: //set mode(sMode: string);
                //set mode(iMode: int);
                function (sMode) {
                    this._iMode = (typeof (sMode) === "string") ? io.filemode(sMode) : sMode;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TFile.prototype, "onread", {
                set: /** @inline */function (fnCallback) {
                    this.read(fnCallback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TFile.prototype, "onopen", {
                set: /** @inline */function (fnCallback) {
                    this.open(fnCallback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TFile.prototype, "position", {
                get: /** @inline */function () {
 {
                        akra.logger.setSourceLocation("TFile.ts", 111);
                        akra.logger.assert(((this._pFileMeta) != null), 'There is no file handle open.');
                    }
                    ;
                    return this._nCursorPosition;
                },
                set: function (iOffset) {
 {
                        akra.logger.setSourceLocation("TFile.ts", 116);
                        akra.logger.assert(((this._pFileMeta) != null), 'There is no file handle open.');
                    }
                    ;
                    this._nCursorPosition = iOffset;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TFile.prototype, "byteLength", {
                get: /** @inline */function () {
                    return this._pFileMeta ? this._pFileMeta.size : 0;
                },
                enumerable: true,
                configurable: true
            });
            TFile.prototype.open = function (sFilename, iMode, fnCallback) {
                var pFile = this;
                var hasMode = !(/*checked (origin: akra)>>*/akra.typeOf((iMode)) === "function");
                if (arguments.length < 3) {
                    if ((typeof (arguments[0]) === "string")) {
                        this.setAndValidateUri((new /*checked (origin: akra)>>*/akra.util.URI((sFilename))));
                        fnCallback = arguments[1];
                    } else if ((typeof (arguments[0]) === "number")) {
                        this._iMode = arguments[0];
                        fnCallback = arguments[1];
                    } else {
                        fnCallback = arguments[0];
                    }
 {
                        akra.logger.setSourceLocation("TFile.ts", 168);
                        akra.logger.assert(((this._pUri) != null), "No filename provided.");
                    }
                    ;
                    this.open(this._pUri.toString(), this._iMode, fnCallback);
                    return;
                }
                fnCallback = arguments[hasMode ? 2 : 1];
                fnCallback = fnCallback || TFile.defaultCallback;
                if (this.isOpened()) {
 {
                        akra.logger.setSourceLocation("TFile.ts", 180);
                        akra.logger.warning("file already opened: " + (/*checked (origin: akra)>>*/akra.util.pathinfo((this)._pUri.path).basename));
                    }
                    ;
                    (fnCallback).call(pFile, null, this._pFileMeta);
                }
                this.setAndValidateUri((new /*checked (origin: akra)>>*/akra.util.URI((arguments[0]))));
                if (hasMode) {
                    this._iMode = ((typeof (arguments[1]) === "string") ? io.filemode(arguments[1]) : arguments[1]);
                }
                this.update(function (err) {
                    if (err) {
 {
                            akra.logger.setSourceLocation("TFile.ts", 192);
                            akra.logger.warning("file update err", err);
                        }
                        ;
                        fnCallback.call(pFile, err);
                        return;
                    }
                    if (((this._iMode & (1 << (3))) != 0)) {
                        this.position = this.size;
                    }
                    fnCallback.call(pFile, null, this._pFileMeta);
                });
            };
            TFile.prototype.close = function () {
                this._pUri = null;
                this._iMode = io.EIO.IN | io.EIO.OUT;
                this._nCursorPosition = 0;
                this._pFileMeta = null;
            };
            TFile.prototype.clear = function (fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = TFile.defaultCallback; }
                if (!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function (err) {
                        if (err) {
                            fnCallback(err);
                        }
                        this.clear.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                var pCommand = {
                    act: EFileActions.k_Clear,
                    name: /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.path,
                    mode: this._iMode
                };
                this.execCommand(pCommand, fnCallback);
            };
            TFile.prototype.read = function (fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = TFile.defaultCallback; }
                if (!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function (err) {
                        if (err) {
                            fnCallback(err);
                        }
                        this.read.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                var pFile = this;
                var eTransferMode = this._eTransferMode;
 {
                    akra.logger.setSourceLocation("TFile.ts", 231);
                    akra.logger.assert(((this._iMode & (1 << (0))) != 0), "The file is not readable.");
                }
                ;
                var pCommand = {
                    act: EFileActions.k_Read,
                    name: /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.path,
                    mode: this._iMode,
                    pos: this._nCursorPosition,
                    transfer: this._eTransferMode
                };
                var fnCallbackSystem = function (err, pBuffer) {
                    if (err) {
                        fnCallback.call(pFile, err);
                        return;
                    }
                    // if (eTransferMode == EFileTransferModes.k_Slow && IS_BINARY(this._iMode)) {
                    //     pData = new Uint8Array(pData).buffer;
                    // }
                    pFile.atEnd();
                    if (((pFile.mode & (1 << (5))) != 0)) {
                        fnCallback.call(pFile, null, pBuffer);
                    } else {
                        fnCallback.call(pFile, null, akra.util.abtos(pBuffer));
                    }
                };
                this.execCommand(pCommand, fnCallbackSystem);
            };
            TFile.prototype.write = function (pData, fnCallback, sContentType) {
                if (typeof fnCallback === "undefined") { fnCallback = TFile.defaultCallback; }
                if (!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function (err) {
                        if (err) {
                            fnCallback(err);
                        }
                        this.write.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                var pFile = this;
                var iMode = this._iMode;
                var pCommand;
                var fnCallbackSystem = function (err, pMeta) {
                    if (err) {
                        fnCallback.call(pFile, err);
                        return;
                    }
                    pFile.position += (typeof (pData) === "string") ? pData.length : pData.byteLength;
                    (pFile)._pFileMeta = pMeta;
                    fnCallback.call(pFile, null, pMeta);
                };
 {
                    akra.logger.setSourceLocation("TFile.ts", 285);
                    akra.logger.assert(((iMode & (1 << (1))) != 0), "The file is not writable.");
                }
                ;
                sContentType = sContentType || (((iMode & (1 << (5))) != 0) ? "application/octet-stream" : "text/plain");
                pCommand = {
                    act: EFileActions.k_Write,
                    name: /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.path,
                    mode: this._iMode,
                    data: pData,
                    contentType: sContentType,
                    pos: this._nCursorPosition
                };
                if (!(typeof (pData) === "string")) {
                    this.execCommand(pCommand, fnCallbackSystem, [
                        pData
                    ]);
                } else {
                    this.execCommand(pCommand, fnCallbackSystem);
                }
            };
            TFile.prototype.move = function (sFilename, fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = TFile.defaultCallback; }
                var pFile = this;
                this.copy(sFilename, function (err) {
                    if (err) {
                        fnCallback(err);
                        return;
                    }
                    pFile.remove(fnCallback);
                });
            };
            TFile.prototype.copy = function (sFilename, fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = TFile.defaultCallback; }
                var iMode = io.EIO.IN | io.EIO.OUT | io.EIO.TRUNC;
                var pFile = this;
                var pFileCopy;
                if (((this._iMode & (1 << (5))) != 0)) {
                    iMode |= io.EIO.BIN;
                }
                pFileCopy = new TFile(sFilename, iMode, function (err) {
                    if (err) {
                        fnCallback(err);
                    }
                    pFile.read(function (pData) {
                        pFile.write(pData, fnCallback);
                    });
                });
            };
            TFile.prototype.rename = function (sFilename, fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = TFile.defaultCallback; }
                var pName = akra.util.pathinfo(sFilename);
 {
                    akra.logger.setSourceLocation("TFile.ts", 343);
                    akra.logger.assert(!pName.dirname, 'only filename can be specified.');
                }
                ;
                this.move(akra.util.pathinfo(this._pUri.path).dirname + "/" + pName.basename, fnCallback);
            };
            TFile.prototype.remove = function (fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = TFile.defaultCallback; }
                if (!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function (err) {
                        if (err) {
                            fnCallback(err);
                        }
                        this.remove.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                var pFile = this;
                var pCommand = {
                    act: EFileActions.k_Remove,
                    name: /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.path,
                    mode: this._iMode
                };
                var fnCallbackSystem = function (err, pData) {
                    pFile.close();
                    if (((fnCallback) !== undefined)) {
                        fnCallback.call(pFile, err, pData);
                    }
                };
                this.execCommand(pCommand, fnCallbackSystem);
            };
            TFile.prototype.atEnd = //return current position
            function () {
                this.position = ((this)._pFileMeta ? (this)._pFileMeta.size : 0);
                return this._nCursorPosition;
            };
            TFile.prototype.seek = //return current position;
            function (iOffset) {
 {
                    akra.logger.setSourceLocation("TFile.ts", 375);
                    akra.logger.assert(((this._pFileMeta) != null), "There is no file handle open.");
                }
                ;
                var nSeek = this._nCursorPosition + iOffset;
                if (nSeek < 0) {
                    nSeek = ((this)._pFileMeta ? (this)._pFileMeta.size : 0) - (akra.math.abs(nSeek) % ((this)._pFileMeta ? (this)._pFileMeta.size : 0));
                }
 {
                    akra.logger.setSourceLocation("TFile.ts", 382);
                    akra.logger.assert(nSeek >= 0 && nSeek <= ((this)._pFileMeta ? (this)._pFileMeta.size : 0), "Invalid offset parameter");
                }
                ;
                this._nCursorPosition = nSeek;
                return this._nCursorPosition;
            };
            TFile.prototype.isOpened = function () {
                return this._pFileMeta !== null;
            };
            TFile.prototype.isExists = function (fnCallback) {
                var pCommand = {
                    act: EFileActions.k_Exists,
                    name: /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.path,
                    mode: this._iMode
                };
                this.execCommand(pCommand, fnCallback);
            };
            TFile.prototype.isLocal = /** @inline */function () {
                return this._isLocal;
            };
            TFile.prototype.getMetaData = function (fnCallback) {
 {
                    akra.logger.setSourceLocation("TFile.ts", 407);
                    akra.logger.assert(((this._pFileMeta) != null), 'There is no file handle open.');
                }
                ;
                fnCallback(null, {
                    lastModifiedDate: this._pFileMeta.lastModifiedDate
                });
            };
            TFile.prototype.setAndValidateUri = function (sFilename) {
                var pUri = (new /*checked (origin: akra)>>*/akra.util.URI((sFilename)));
                var pUriLocal;
                if (pUri.protocol === "filesystem") {
                    pUriLocal = (new /*checked (origin: akra)>>*/akra.util.URI((pUri.path)));
 {
                        akra.logger.setSourceLocation("TFile.ts", 422);
                        akra.logger.assert(!(pUriLocal.protocol && pUriLocal.host != akra.info.uri.host), "Поддерживаются только локальные файлы в пределах текущего домена.");
                    }
                    ;
                    var pFolders = pUriLocal.path.split('/');
                    if (pFolders[0] == "" || pFolders[0] == ".") {
                        pFolders = pFolders.slice(1);
                    }
 {
                        akra.logger.setSourceLocation("TFile.ts", 431);
                        akra.logger.assert(pUri.host === "temporary", "Поддерживаются только файловые системы типа \"temporary\".");
                    }
                    ;
                    this._pUri = (new /*checked (origin: akra)>>*/akra.util.URI((pFolders.join("/"))));
                    this._isLocal = true;
                } else {
                    this._pUri = pUri;
                }
            };
            TFile.prototype.update = function (fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = TFile.defaultCallback; }
                var pFile = this;
                var pCommand = {
                    act: EFileActions.k_Open,
                    name: this._pUri.toString(),
                    mode: this._iMode
                };
                var fnCallbackSystem = function (err, pMeta) {
                    (pFile)._pFileMeta = pMeta;
                    // console.log(pMeta);
                    fnCallback.call(pFile, err, pFile);
                };
                this.execCommand(pCommand, fnCallbackSystem);
            };
            TFile.prototype.execCommand = function (pCommand, fnCallback, pTransferables) {
                TFile.execCommand(this, ((this)._isLocal), pCommand, fnCallback);
            };
            TFile.defaultCallback = function (err) {
                if (err) {
                    throw err;
                }
            };
            TFile.execCommand = function execCommand(pFile, isLocal, pCommand, fnCallback, pTransferables) {
                // var pFile: IFile = this;
                var pManager = isLocal ? (pLocalFileThreadManager) : (pRemoteFileThreadManager);
                var pThread = pManager.occupyThread();
                pThread.onmessage = function (e) {
                    pManager.releaseThread(pThread);
                    pThread.onmessage = null;
                    if (pCommand.act === EFileActions.k_Read) {
                        TOTAL_BYTES_READED += e.data.byteLength;
 {
                            akra.logger.setSourceLocation("TFile.ts", 480);
                            akra.logger.log("TOTAL BYTES READED: ", (TOTAL_BYTES_READED / (1024 * 1024)).toFixed(2), "mb");
                        }
                        ;
                    }
                    fnCallback.call(pFile, null, e.data);
                    // (<any>window["gc"])();
                                    };
                pThread.onerror = function (e) {
                    pManager.releaseThread(pThread);
                    pThread.onmessage = null;
                    fnCallback.call(pFile, e);
                };
                if (((pTransferables) !== undefined)) {
                    pThread.send(pCommand, pTransferables);
                } else {
                    pThread.send(pCommand);
                }
            };
            return TFile;
        })();
        io.TFile = TFile;        
    })(akra.io || (akra.io = {}));
    var io = akra.io;
})(akra || (akra = {}));
var akra;
(function (akra) {
    /*local file via local files system(async)*/
    /**
    * FIle implementation via <Local filesystem>.
    * ONLY FOR LOCAL FILES!!
    */
    (function (io) {
        var LocalFileSystem = (function () {
            function LocalFileSystem() {
                this._pFileSystem = null;
                this._pCallbackQueue = [];
            }
            LocalFileSystem.prototype.setFileSystem = function (pFS) {
                this._pFileSystem = pFS;
            };
            LocalFileSystem.prototype.get = /**
            * Инициализация файловой системы.
            * @tparam Function fnCallback Функция, вызываемая
            * при успешной(получет в 1ом параметре fs)
            * инициализации системы.
            */
            function (fnCallback) {
                if (this._pFileSystem) {
                    fnCallback(this._pFileSystem);
                    return;
                }
                var pFileSystem = this;
                var pQueue = this._pCallbackQueue;
                pQueue.push(fnCallback);
                if (pQueue.length > 1) {
                    return;
                }
                window.storageInfo.requestQuota(window.TEMPORARY, (32 * 1024 * 1024), function (nGrantedBytes) {
                    window.requestFileSystem(window.TEMPORARY, nGrantedBytes, function (pFs) {
                        pFileSystem.setFileSystem(pFs);
                        if (pQueue.length) {
                            for(var i = 0; i < pQueue.length; ++i) {
                                pQueue[i](pFs);
                            }
                        }
                    }, LocalFileSystem.errorHandler);
                });
            };
            LocalFileSystem.errorHandler = function errorHandler(e) {
                var sMesg = "init filesystem: ";
                switch(e.code) {
                    case FileError.QUOTA_EXCEEDED_ERR:
                        sMesg += 'QUOTA_EXCEEDED_ERR';
                        break;
                    case FileError.NOT_FOUND_ERR:
                        sMesg += 'NOT_FOUND_ERR';
                        break;
                    case FileError.SECURITY_ERR:
                        sMesg += 'SECURITY_ERR';
                        break;
                    case FileError.INVALID_MODIFICATION_ERR:
                        sMesg += 'INVALID_MODIFICATION_ERR';
                        break;
                    case FileError.INVALID_STATE_ERR:
                        sMesg += 'INVALID_STATE_ERR';
                        break;
                    default:
                        sMesg += 'Unknown Error';
                        break;
                }
 {
                    akra.logger.setSourceLocation("LocalFile.ts", 102);
                    akra.logger.error(sMesg);
                }
                ;
            };
            return LocalFileSystem;
        })();        
        var pLocalFileSystem = new LocalFileSystem();
        function getFileSystem(fnCallback) {
            pLocalFileSystem.get(fnCallback);
        }
        io.getFileSystem = getFileSystem;
        var LocalFile = (function () {
            function LocalFile(sFilename, sMode, fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = LocalFile.defaultCallback; }
                this._nCursorPosition = 0;
                if (((sMode) !== undefined)) {
                    this._iMode = (typeof (sMode) === "string") ? io.filemode(sMode) : sMode;
                }
                this.setAndValidateUri((new /*checked (origin: akra)>>*/akra.util.URI((sFilename))));
                if (arguments.length > 2) {
                    this.open(sFilename, sMode, fnCallback);
                }
            }
            Object.defineProperty(LocalFile.prototype, "path", {
                get: /** @inline */function () {
 {
                        akra.logger.setSourceLocation("LocalFile.ts", 126);
                        akra.logger.assert(((this._pFile) != null), "There is no file handle open.");
                    }
                    ;
                    return this._pUri.toString();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(LocalFile.prototype, "name", {
                get: /** @inline */function () {
                    return akra.util.pathinfo(this._pUri.path).basename;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(LocalFile.prototype, "mode", {
                get: /** @inline */function () {
                    return this._iMode;
                },
                set: //set mode(sMode: string);
                //set mode(iMode: int);
                function (sMode) {
                    this._iMode = (typeof (sMode) === "string") ? io.filemode(sMode) : sMode;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(LocalFile.prototype, "onread", {
                set: /** @inline */function (fnCallback) {
                    this.read(fnCallback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(LocalFile.prototype, "onopen", {
                set: /** @inline */function (fnCallback) {
                    this.open(fnCallback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(LocalFile.prototype, "position", {
                get: /** @inline */function () {
 {
                        akra.logger.setSourceLocation("LocalFile.ts", 153);
                        akra.logger.assert(((this._pFile) != null), "There is no file handle open.");
                    }
                    ;
                    return this._nCursorPosition;
                },
                set: function (iOffset) {
 {
                        akra.logger.setSourceLocation("LocalFile.ts", 158);
                        akra.logger.assert(((this._pFile) != null), "There is no file handle open.");
                    }
                    ;
                    this._nCursorPosition = iOffset;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(LocalFile.prototype, "byteLength", {
                get: /** @inline */function () {
                    return this._pFile ? this._pFile.size : 0;
                },
                enumerable: true,
                configurable: true
            });
            LocalFile.prototype.open = function (sFilename, iMode, fnCallback) {
                var pFile = this;
                var hasMode = !(/*checked (origin: akra)>>*/akra.typeOf((iMode)) === "function");
                if (arguments.length < 3) {
                    if ((typeof (arguments[0]) === "string")) {
                        this.setAndValidateUri((new /*checked (origin: akra)>>*/akra.util.URI((sFilename))));
                        fnCallback = arguments[1];
                    } else if ((typeof (arguments[0]) === "number")) {
                        this._iMode = arguments[0];
                        fnCallback = arguments[1];
                    } else {
                        fnCallback = arguments[0];
                    }
 {
                        akra.logger.setSourceLocation("LocalFile.ts", 204);
                        akra.logger.assert(((this._pUri) != null), "No filename provided.");
                    }
                    ;
                    this.open(this._pUri.toString(), this._iMode, fnCallback);
                    return;
                }
                fnCallback = arguments[hasMode ? 2 : 1];
                fnCallback = fnCallback || LocalFile.defaultCallback;
                if (this.isOpened()) {
 {
                        akra.logger.setSourceLocation("LocalFile.ts", 216);
                        akra.logger.warning("file already opened: " + (/*checked (origin: akra)>>*/akra.util.pathinfo((this)._pUri.path).basename));
                    }
                    ;
                    (fnCallback)(null, this._pFile);
                }
                this.setAndValidateUri((new /*checked (origin: akra)>>*/akra.util.URI((arguments[0]))));
                if (hasMode) {
                    this._iMode = ((typeof (arguments[1]) === "string") ? io.filemode(arguments[1]) : arguments[1]);
                }
                var fnFSInited;
                var pFile = this;
                var pFileSystem = null;
                var fnErrorHandler = function (e) {
                    if (e.code == FileError.NOT_FOUND_ERR && ((pFile.mode & (1 << (1))) != 0)) {
                        LocalFile.createDir(pFileSystem.root, akra.util.pathinfo(pFile.path).dirname.split('/'), function (e) {
                            if (!((e) === null)) {
                                fnCallback.call(pFile, e);
                            } else {
                                fnFSInited.call(pFile, pFileSystem);
                            }
                        });
                    } else {
                        fnCallback.call(pFile, e);
                    }
                };
                fnFSInited = function (pFs) {
 {
                        akra.logger.setSourceLocation("LocalFile.ts", 250);
                        akra.logger.assert(((pFs) != null), "local file system not initialized");
                    }
                    ;
                    pFileSystem = pFs;
                    pFs.root.getFile(this.path, {
                        create: ((this._iMode & (1 << (1))) != 0),
                        exclusive: false
                    }, function (fileEntry) {
                        (pFile).setFileEntry(fileEntry);
                        (fileEntry).file(function (file) {
                            (pFile).setFile(file);
                            if (((pFile.mode & (1 << (4))) != 0) && pFile.byteLength) {
                                pFile.clear(function (err) {
                                    if (err) {
                                        fnCallback(err);
                                    } else {
                                        fnCallback.call(pFile, null, file);
                                    }
                                });
                                return;
                            }
                            if (((pFile.mode & (1 << (3))) != 0)) {
                                pFile.position = pFile.byteLength;
                            }
                            fnCallback.call(pFile, null, file);
                        }, fnErrorHandler);
                    }, fnErrorHandler);
                };
                getFileSystem(function (pFileSystem) {
                    fnFSInited.call(pFile, pFileSystem);
                });
            };
            LocalFile.prototype.close = function () {
                this._pUri = null;
                this._iMode = io.EIO.IN | io.EIO.OUT;
                this._nCursorPosition = 0;
                this._pFile = null;
            };
            LocalFile.prototype.clear = function (fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = LocalFile.defaultCallback; }
                if (!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function (err) {
                        if (err) {
                            fnCallback(err);
                        }
                        this.clear.apply(this, _pArgv);
                    });
                    return;
                }
                ;
 {
                    akra.logger.setSourceLocation("LocalFile.ts", 303);
                    akra.logger.assert(((this._pFile) != null), 'There is no file handle open');
                }
                ;
                var pFile = this;
                var pFileEntry = this._pFileEntry;
                pFileEntry.createWriter(function (pWriter) {
                    pWriter.seek(0);
                    pWriter.onwriteend = function () {
                        fnCallback.call(pFile, null);
                    };
                    pWriter.truncate(0);
                }, function (e) {
                    fnCallback.call(pFile, e);
                });
            };
            LocalFile.prototype.read = function (fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = LocalFile.defaultCallback; }
                if (!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function (err) {
                        if (err) {
                            fnCallback(err);
                        }
                        this.read.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                var pFile = this;
                var eTransferMode = this._iMode;
 {
                    akra.logger.setSourceLocation("LocalFile.ts", 330);
                    akra.logger.assert(((this._iMode & (1 << (0))) != 0), "The file is not readable.");
                }
                ;
                var pReader = this._pFileReader;
                var pFileObject = this._pFile;
                pReader.onloadend = function (e) {
                    var pData = ((e.target)).result;
                    var nPos = pFile.position;
                    if (nPos) {
                        if (((pFile.mode & (1 << (5))) != 0)) {
                            pData = (new Uint8Array((new Uint8Array(pData)).subarray(nPos))).buffer;
                        } else {
                            pData = pData.substr(nPos);
                        }
                    }
                    pFile.atEnd();
                    fnCallback.call(pFile, null, pData);
                };
                if (((pFile.mode & (1 << (5))) != 0)) {
                    pReader.readAsArrayBuffer(pFileObject);
                } else {
                    pReader.readAsText(pFileObject);
                }
            };
            LocalFile.prototype.write = function (pData, fnCallback, sContentType) {
                if (typeof fnCallback === "undefined") { fnCallback = LocalFile.defaultCallback; }
                if (!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function (err) {
                        if (err) {
                            fnCallback(err);
                        }
                        this.write.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                var pFile = this;
                var iMode = this._iMode;
 {
                    akra.logger.setSourceLocation("LocalFile.ts", 369);
                    akra.logger.assert(((iMode & (1 << (1))) != 0), "The file is not writable.");
                }
                ;
                sContentType = sContentType || (((iMode & (1 << (5))) != 0) ? "application/octet-stream" : "text/plain");
                var pFile = this;
                var pFileEntry = this._pFileEntry;
                pFileEntry.createWriter(function (pWriter) {
                    pWriter.seek(pFile.position);
                    pWriter.onerror = function (e) {
                        fnCallback.call(pFileEntry, e);
                    };
                    pWriter.onwriteend = function () {
                        if (((iMode & (1 << (5))) != 0)) {
                            pFile.seek(pData.byteLength);
                        } else {
                            pFile.seek(pData.length);
                        }
                        fnCallback.call(pFile, null);
                    };
                    pWriter.write((new (Blob)(pData, {
                        type: sContentType
                    })));
                }, function (e) {
                    fnCallback.call(pFile, e);
                });
            };
            LocalFile.prototype.move = function (sFilename, fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = LocalFile.defaultCallback; }
                var pFile = this;
                this.copy(sFilename, function (err) {
                    if (err) {
                        fnCallback(err);
                        return;
                    }
                    pFile.remove(fnCallback);
                });
            };
            LocalFile.prototype.copy = function (sFilename, fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = LocalFile.defaultCallback; }
                var iMode = io.EIO.IN | io.EIO.OUT | io.EIO.TRUNC;
                var pFile = this;
                var pFileCopy;
                if (((this._iMode & (1 << (5))) != 0)) {
                    iMode |= io.EIO.BIN;
                }
                pFileCopy = new LocalFile(sFilename, iMode, function (err) {
                    if (err) {
                        fnCallback(err);
                    }
                    pFile.read(function (pData) {
                        pFile.write(pData, fnCallback);
                    });
                });
            };
            LocalFile.prototype.rename = function (sFilename, fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = LocalFile.defaultCallback; }
                var pName = akra.util.pathinfo(sFilename);
 {
                    akra.logger.setSourceLocation("LocalFile.ts", 441);
                    akra.logger.assert(!pName.dirname, 'only filename can be specified.');
                }
                ;
                this.move(akra.util.pathinfo(this._pUri.path).dirname + "/" + pName.basename, fnCallback);
            };
            LocalFile.prototype.remove = function (fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = LocalFile.defaultCallback; }
                if (!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function (err) {
                        if (err) {
                            fnCallback(err);
                        }
                        this.remove.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                var pFile = this;
                this._pFileEntry.remove(function () {
                    pFile.close();
                    fnCallback.call(pFile, null);
                }, fnCallback);
            };
            LocalFile.prototype.atEnd = //return current position
            function () {
                this.position = ((this)._pFile ? (this)._pFile.size : 0);
                return this._nCursorPosition;
            };
            LocalFile.prototype.seek = //return current position;
            function (iOffset) {
 {
                    akra.logger.setSourceLocation("LocalFile.ts", 464);
                    akra.logger.assert(((this._pFile) != null), "There is no file handle open.");
                }
                ;
                var nSeek = this._nCursorPosition + iOffset;
                if (nSeek < 0) {
                    nSeek = ((this)._pFile ? (this)._pFile.size : 0) - (akra.math.abs(nSeek) % ((this)._pFile ? (this)._pFile.size : 0));
                }
 {
                    akra.logger.setSourceLocation("LocalFile.ts", 471);
                    akra.logger.assert(nSeek >= 0 && nSeek <= ((this)._pFile ? (this)._pFile.size : 0), "Invalid offset parameter");
                }
                ;
                this._nCursorPosition = nSeek;
                return this._nCursorPosition;
            };
            LocalFile.prototype.isOpened = function () {
                return this._pFile !== null;
            };
            LocalFile.prototype.isExists = function (fnCallback) {
                this.open(function (e) {
                    fnCallback(((e) === null) ? true : false);
                });
            };
            LocalFile.prototype.isLocal = function () {
                return true;
            };
            LocalFile.prototype.getMetaData = function (fnCallback) {
 {
                    akra.logger.setSourceLocation("LocalFile.ts", 493);
                    akra.logger.assert(((this._pFile) != null), 'There is no file handle open.');
                }
                ;
                fnCallback(null, {
                    lastModifiedDate: this._pFile.lastModifiedDate
                });
            };
            LocalFile.prototype.setFileEntry = function (pFileEntry) {
                if (!((this._pFileEntry) === null)) {
                    return false;
                }
                this._pFileEntry = pFileEntry;
                return true;
            };
            LocalFile.prototype.setFile = function (pFile) {
                if (!((this._pFile) === null)) {
                    return false;
                }
                this._pFile = pFile;
                return true;
            };
            LocalFile.prototype.setAndValidateUri = function (sFilename) {
                var pUri = (new /*checked (origin: akra)>>*/akra.util.URI((sFilename)));
                var pUriLocal;
                if (pUri.protocol === "filesystem") {
                    pUriLocal = (new /*checked (origin: akra)>>*/akra.util.URI((pUri.path)));
 {
                        akra.logger.setSourceLocation("LocalFile.ts", 528);
                        akra.logger.assert(!(pUriLocal.protocol && pUriLocal.host != akra.info.uri.host), "Поддерживаются только локальные файлы в пределах текущего домена.");
                    }
                    ;
                    var pFolders = pUriLocal.path.split('/');
                    if (pFolders[0] == "" || pFolders[0] == ".") {
                        pFolders = pFolders.slice(1);
                    }
 {
                        akra.logger.setSourceLocation("LocalFile.ts", 537);
                        akra.logger.assert(pUri.host === "temporary", "Поддерживаются только файловые системы типа \"temporary\".");
                    }
                    ;
                    this._pUri = (new /*checked (origin: akra)>>*/akra.util.URI((pFolders.join("/"))));
                } else {
 {
                        akra.logger.setSourceLocation("LocalFile.ts", 542);
                        akra.logger.error("used non local uri");
                    }
                    ;
                }
            };
            LocalFile.errorHandler = function errorHandler(e) {
                var sMesg = "";
                switch(e.code) {
                    case FileError.QUOTA_EXCEEDED_ERR:
                        sMesg += 'QUOTA_EXCEEDED_ERR';
                        break;
                    case FileError.NOT_FOUND_ERR:
                        sMesg += 'NOT_FOUND_ERR';
                        break;
                    case FileError.SECURITY_ERR:
                        sMesg += 'SECURITY_ERR';
                        break;
                    case FileError.INVALID_MODIFICATION_ERR:
                        sMesg += 'INVALID_MODIFICATION_ERR';
                        break;
                    case FileError.INVALID_STATE_ERR:
                        sMesg += 'INVALID_STATE_ERR';
                        break;
                    default:
                        sMesg += 'Unknown Error';
                        break;
                }
 {
                    akra.logger.setSourceLocation("LocalFile.ts", 570);
                    akra.logger.error(sMesg);
                }
                ;
            };
            LocalFile.createDir = function createDir(pRootDirEntry, pFolders, fnCallback) {
                if (pFolders[0] == "." || pFolders[0] == "") {
                    pFolders = pFolders.slice(1);
                }
                pRootDirEntry.getDirectory(pFolders[0], {
                    create: true
                }, function (dirEntry) {
                    if (pFolders.length) {
                        LocalFile.createDir(dirEntry, pFolders.slice(1), fnCallback);
                    } else {
                        fnCallback(null);
                    }
                }, fnCallback);
            };
            LocalFile.defaultCallback = function (err) {
                if (err) {
                    LocalFile.errorHandler(err);
                }
            };
            return LocalFile;
        })();
        io.LocalFile = LocalFile;        
    })(akra.io || (akra.io = {}));
    var io = akra.io;
})(akra || (akra = {}));
var akra;
(function (akra) {
    /*local file via local files system(async)*/
    /**
    * FIle implementation via <Local Storage>.
    * ONLY FOR LOCAL FILES!!
    */
    (function (io) {
        var StorageFile = (function (_super) {
            __extends(StorageFile, _super);
            function StorageFile(sFilename, sMode, fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = io.TFile.defaultCallback; }
                        _super.call(this, sFilename, sMode, fnCallback);
            }
            StorageFile.prototype.clear = function (fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = io.TFile.defaultCallback; }
                if (!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function (err) {
                        if (err) {
                            fnCallback(err);
                        }
                        this.clear.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                localStorage.setItem(/*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.path, "");
                this._pFileMeta.size = 0;
                fnCallback(null, this);
            };
            StorageFile.prototype.read = function (fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = io.TFile.defaultCallback; }
                if (!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function (err) {
                        if (err) {
                            fnCallback(err);
                        }
                        this.read.apply(this, _pArgv);
                    });
                    return;
                }
                ;
 {
                    akra.logger.setSourceLocation("StorageFile.ts", 36);
                    akra.logger.assert(((this._iMode & (1 << (1))) != 0), "The file is not readable.");
                }
                ;
                var pData = this.readData();
                var nPos = this._nCursorPosition;
                if (nPos) {
                    if (((this._iMode & (1 << (5))) != 0)) {
                        pData = (new Uint8Array((new Uint8Array(pData)).subarray(nPos))).buffer;
                    } else {
                        pData = pData.substr(nPos);
                    }
                }
                this.atEnd();
                if (fnCallback) {
                    fnCallback.call(this, null, pData);
                }
            };
            StorageFile.prototype.write = function (pData, fnCallback, sContentType) {
                if (typeof fnCallback === "undefined") { fnCallback = io.TFile.defaultCallback; }
                if (!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function (err) {
                        if (err) {
                            fnCallback(err);
                        }
                        this.write.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                var iMode = this._iMode;
                var nSeek;
                var pCurrentData;
 {
                    akra.logger.setSourceLocation("StorageFile.ts", 66);
                    akra.logger.assert(((iMode & (1 << (1))) != 0), "The file is not writable.");
                }
                ;
                sContentType = sContentType || (((iMode & (1 << (5))) != 0) ? "application/octet-stream" : "text/plain");
                pCurrentData = this.readData();
                if (!(typeof (pCurrentData) === "string")) {
                    pCurrentData = akra.util.abtos(pCurrentData);
                }
                nSeek = ((typeof (pData) === "string") ? pData.length : pData.byteLength);
                if (!(typeof (pData) === "string")) {
                    pData = akra.util.abtos(pData);
                }
                pData = (pCurrentData).substr(0, this._nCursorPosition) + (pData) + (pCurrentData).substr(this._nCursorPosition + (pData).length);
                try  {
                    localStorage.setItem(/*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.path, pData);
                } catch (e) {
                    fnCallback(e);
                }
                this._pFileMeta.size = pData.length;
                this._nCursorPosition += nSeek;
                fnCallback(null);
            };
            StorageFile.prototype.isExists = function (fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = io.TFile.defaultCallback; }
                fnCallback.call(this, null, localStorage.getItem(/*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.path) == null);
            };
            StorageFile.prototype.remove = function (fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = io.TFile.defaultCallback; }
                localStorage.removeItem(/*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.path);
                fnCallback.call(this, null);
            };
            StorageFile.prototype.readData = function () {
                var pFileMeta = this._pFileMeta;
                var pData = localStorage.getItem(/*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.path);
                var pDataBin;
                if (pData == null) {
                    pData = "";
                    if (((this._iMode & (1 << (1))) != 0)) {
                        localStorage.setItem(/*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.path, pData);
                    }
                }
                if (((this._iMode & (1 << (5))) != 0)) {
                    pDataBin = akra.util.stoab(pData);
                    pFileMeta.size = pDataBin.byteLength;
                    return pDataBin;
                } else {
                    pFileMeta.size = pData.length;
                    return pData;
                }
                //return null;
                            };
            StorageFile.prototype.update = function (fnCallback) {
                this._pFileMeta = null;
                this.readData();
                fnCallback.call(this, null);
            };
            return StorageFile;
        })(io.TFile);
        io.StorageFile = StorageFile;        
    })(akra.io || (akra.io = {}));
    var io = akra.io;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (io) {
        (function (EIO) {
            EIO._map = [];
            EIO.IN = 0x01;
            EIO.OUT = 0x02;
            EIO.ATE = 0x04;
            EIO.APP = 0x08;
            EIO.TRUNC = 0x10;
            EIO.BINARY = 0x20;
            EIO.BIN = 0x20;
            EIO.TEXT = 0x40;
        })(io.EIO || (io.EIO = {}));
        var EIO = io.EIO;
        ;
        function filemode(sMode) {
            switch(sMode.toLowerCase()) {
                case "a+t":
                    return EIO.IN | EIO.OUT | EIO.APP | EIO.TEXT;
                case "w+t":
                    return EIO.IN | EIO.OUT | EIO.TRUNC | EIO.TEXT;
                case "r+t":
                    return EIO.IN | EIO.OUT | EIO.TEXT;
                case "at":
                    return EIO.APP | EIO.TEXT;
                case "wt":
                    return EIO.OUT | EIO.TEXT;
                case "rt":
                    return EIO.IN | EIO.TEXT;
                case "a+b":
                    return EIO.IN | EIO.OUT | EIO.APP | EIO.BIN;
                case "w+b":
                    return EIO.IN | EIO.OUT | EIO.TRUNC | EIO.BIN;
                case "r+b":
                    return EIO.IN | EIO.OUT | EIO.BIN;
                case "ab":
                    return EIO.APP | EIO.BIN;
                case "wb":
                    return EIO.OUT | EIO.BIN;
                case "rb":
                    return EIO.IN | EIO.BIN;
                case "a+":
                    return EIO.IN | EIO.OUT | EIO.APP;
                case "w+":
                    return EIO.IN | EIO.OUT | EIO.TRUNC;
                case "r+":
                    return EIO.IN | EIO.OUT;
                case "a":
                    return EIO.APP | EIO.OUT;
                case "w":
                    return EIO.OUT;
                case "r":
                default:
                    return EIO.IN;
            }
        }
        io.filemode = filemode;
        // function _fopen (sUri: string, iMode?: int): IFile;
        // function _fopen (sUri: string, sMode?: int): IFile;
        // function _fopen (pUri: IURI, iMode: int): IFile;
        // function _fopen (pUri: IURI, sMode: string): IFile;
        function _fopen(sUri, pMode) {
            if (typeof pMode === "undefined") { pMode = EIO.IN; }
            sUri = akra.util.URI.resolve(sUri);
            if (akra.info.api.webWorker) {
                return new io.TFile(sUri, pMode);
            } else if (akra.info.api.fileSystem) {
                return new io.LocalFile(sUri, pMode);
            } else {
                return new io.StorageFile(sUri, pMode);
            }
        }
        io.fopen = _fopen;
    })(akra.io || (akra.io = {}));
    var io = akra.io;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.fopen = akra.io.fopen;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    var Codec = (function () {
        function Codec() { }
        Codec._pMapCodecs = {};
        Codec.registerCodec = function registerCodec(pCodec) {
            if (!((Codec._pMapCodecs[pCodec.getType()]) !== undefined)) {
                Codec._pMapCodecs[pCodec.getType()] = pCodec;
            } else {
 {
                    akra.logger.setSourceLocation("Codec.ts", 28);
                    akra.logger.criticalError(pCodec.getType() + " already has a registered codec. ");
                }
                ;
            }
        };
        Codec.isCodecRegistered = function isCodecRegistered(pCodec) {
            return ((Codec._pMapCodecs[pCodec.getType()]) !== undefined);
        };
        Codec.unRegisterCodec = function unRegisterCodec(pCodec) {
            delete Codec._pMapCodecs[pCodec.getType()];
        };
        Codec.getExtension = function getExtension() {
            var pExt = Array();
            var sExt = "";
            for(sExt in Codec._pMapCodecs) {
                pExt.push(sExt);
            }
            return pExt;
        };
        Codec.getCodec = function getCodec(pMagicNumber) {
            var sExt = "";
            if ((typeof (pMagicNumber) === "string")) {
                if (((Codec._pMapCodecs[pMagicNumber]) !== undefined)) {
                    return Codec._pMapCodecs[pMagicNumber];
                } else {
 {
                        akra.logger.setSourceLocation("Codec.ts", 66);
                        akra.logger.criticalError("Can not find codec for " + pMagicNumber);
                    }
                    ;
                    return null;
                }
            } else {
                for(sExt in Codec._pMapCodecs) {
                    var sExt1 = Codec._pMapCodecs[sExt].magicNumberToFileExt(pMagicNumber);
                    if (sExt1) {
                        if (sExt1 == Codec._pMapCodecs[sExt].getType()) {
                            return Codec._pMapCodecs[sExt];
                        } else {
                            return Codec.getCodec(sExt1);
                        }
                    }
                }
            }
            return null;
        };
        Codec.prototype.magicNumberMatch = function (pMagicNumber) {
            return !(this.magicNumberToFileExt(pMagicNumber).length == 0);
        };
        Codec.prototype.magicNumberToFileExt = function (pMagicNumber) {
 {
                akra.logger.setSourceLocation("Codec.ts", 100);
                akra.logger.criticalError("Codec.magicNumberToFileExt is virtual");
            }
            ;
            return null;
        };
        Codec.prototype.getType = function () {
 {
                akra.logger.setSourceLocation("Codec.ts", 106);
                akra.logger.criticalError("Codec.getType is virtual");
            }
            ;
            return null;
        };
        Codec.prototype.getDataType = function () {
 {
                akra.logger.setSourceLocation("Codec.ts", 112);
                akra.logger.criticalError("Codec.getDataType is virtual");
            }
            ;
            return null;
        };
        Codec.prototype.code = function (pInput, pData) {
 {
                akra.logger.setSourceLocation("Codec.ts", 118);
                akra.logger.criticalError("Codec.code is virtual");
            }
            ;
            return null;
        };
        Codec.prototype.decode = function (pData, pCodecData) {
 {
                akra.logger.setSourceLocation("Codec.ts", 123);
                akra.logger.criticalError("Codec.decode is virtual");
            }
            ;
            return null;
        };
        return Codec;
    })();
    akra.Codec = Codec;    
    var CodecData = (function () {
        function CodecData() { }
        Object.defineProperty(CodecData.prototype, "dataType", {
            get: /** @inline */function () {
 {
                    akra.logger.setSourceLocation("Codec.ts", 135);
                    akra.logger.criticalError("CodecData.dataType is virtual");
                }
                ;
                return "CodecData";
            },
            enumerable: true,
            configurable: true
        });
        return CodecData;
    })();
    akra.CodecData = CodecData;    
})(akra || (akra = {}));
var akra;
(function (akra) {
    var ImgCodec = (function (_super) {
        __extends(ImgCodec, _super);
        function ImgCodec() {
            _super.apply(this, arguments);

        }
        ImgCodec.prototype.getDataType = function () {
            return "ImgData";
        };
        return ImgCodec;
    })(akra.Codec);
    akra.ImgCodec = ImgCodec;    
    var ImgData = (function (_super) {
        __extends(ImgData, _super);
        function ImgData() {
            _super.apply(this, arguments);

            /**@protected*/ this._iHeight = 0;
            /**@protected*/ this._iWidth = 0;
            /**@protected*/ this._iDepth = 1;
            /**@protected*/ this._iSize = 0;
            /**@protected*/ this._nMipMaps = 0;
            /**@protected*/ this._iFlags = 0;
            /**@protected*/ this._eFormat = akra.EPixelFormats.UNKNOWN;
        }
        Object.defineProperty(ImgData.prototype, "width", {
            get: /** @inline */function () {
                return this._iWidth;
            },
            set: /** @inline */function (iWidth) {
                this._iWidth = iWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ImgData.prototype, "height", {
            get: /** @inline */function () {
                return this._iHeight;
            },
            set: /** @inline */function (iHeight) {
                this._iHeight = iHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ImgData.prototype, "depth", {
            get: /** @inline */function () {
                return this._iDepth;
            },
            set: /** @inline */function (iDepth) {
                this._iDepth = iDepth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ImgData.prototype, "size", {
            get: /** @inline */function () {
                return akra.core.pool.resources.Img.calculateSize(((this)._nMipMaps), /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.numFace, ((this)._iWidth), ((this)._iHeight), ((this)._iDepth), ((this)._eFormat));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ImgData.prototype, "numMipMaps", {
            get: /** @inline */function () {
                return this._nMipMaps;
            },
            set: /** @inline */function (nNumMipMaps) {
                this._nMipMaps = nNumMipMaps;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ImgData.prototype, "format", {
            get: /** @inline */function () {
                return this._eFormat;
            },
            set: /** @inline */function (ePixelFormat) {
                this._eFormat = ePixelFormat;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ImgData.prototype, "flags", {
            get: /** @inline */function () {
                return this._iFlags;
            },
            set: /** @inline */function (iFlags) {
                this._iFlags = iFlags;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ImgData.prototype, "cubeFlags", {
            get: /** @inline */function () {
                return this._iCubeFlags;
            },
            set: /** @inline */function (iFlags) {
                this._iCubeFlags = iFlags;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ImgData.prototype, "numFace", {
            get: /** @inline */function () {
                if (this._iFlags & akra.EImageFlags.CUBEMAP) {
                    var nFace = 0;
                    for(var i = 0; i < 32; i++) {
                        nFace++;
                    }
                    return nFace;
                } else {
                    return 1;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ImgData.prototype, "dataType", {
            get: /** @inline */function () {
                return "ImgData";
            },
            enumerable: true,
            configurable: true
        });
        return ImgData;
    })(akra.CodecData);
    akra.ImgData = ImgData;    
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var Img = (function (_super) {
                    __extends(Img, _super);
                    function Img() {
                                        _super.call(this);
                        /**@protected*/ this._iWidth = 0;
                        /**@protected*/ this._iHeight = 0;
                        /**@protected*/ this._iDepth = 0;
                        /**@protected*/ this._nMipMaps = 0;
                        /**@protected*/ this._iFlags = 0;
                        /**@protected*/ this._iCubeFlags = 0;
                        /**@protected*/ this._eFormat = akra.EPixelFormats.UNKNOWN;
                        /**@protected*/ this._pBuffer = null;
                    }
                    Object.defineProperty(Img.prototype, "byteLength", {
                        get: /** @inline */function () {
                            // console.log(__CALLSTACK__);
                            // console.log(this, this._pBuffer, this.isResourceLoaded(), "[", this.findResourceName(), "]");
                            return this._pBuffer.buffer.byteLength;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Img.prototype, "width", {
                        get: /** @inline */function () {
                            return this._iWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Img.prototype, "height", {
                        get: /** @inline */function () {
                            return this._iHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Img.prototype, "depth", {
                        get: /** @inline */function () {
                            return this._iDepth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Img.prototype, "numFaces", {
                        get: /** @inline */function () {
                            if (this._iFlags & akra.EImageFlags.CUBEMAP) {
                                var nFace = 0;
                                for(var i = 0; i < 6; i++) {
                                    if (this._iCubeFlags & (1 << i)) {
                                        nFace++;
                                    }
                                }
                                return nFace;
                            } else {
                                return 1;
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Img.prototype, "numMipMaps", {
                        get: /** @inline */function () {
                            return this._nMipMaps;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Img.prototype, "format", {
                        get: /** @inline */function () {
                            return this._eFormat;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Img.prototype, "flags", {
                        get: /** @inline */function () {
                            return this._iFlags;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Img.prototype, "cubeFlags", {
                        get: /** @inline */function () {
                            return this._iCubeFlags;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Img.prototype.createResource = function () {
                        // innitialize the resource (called once)
                         {
                            akra.logger.setSourceLocation("resources/Img.ts", 89);
                            akra.logger.assert(!((((((this).iResourceFlags) & ((1 << ((/*checked (origin: akra)>>*/akra.EResourceItemEvents.CREATED))))) != 0))), "The resource has already been created.");
                        }
                        ;
                        // signal that the resource is now created,
                        // but has not been enabled
                        /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyCreated();
                        /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyDisabled();
                        return true;
                    };
                    Img.prototype.destroyResource = function () {
                        // destroy the resource
                        //
                        // we permit redundant calls to destroy, so there are no asserts here
                        //
                        if (((((((this).iResourceFlags) & ((1 << ((/*checked (origin: akra)>>*/akra.EResourceItemEvents.CREATED))))) != 0)))) {
                            // disable the resource
                            this.disableResource();
                            this.freeMemory();
                            /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyUnloaded();
                            /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyDestroyed();
                            return (true);
                        }
                        return (false);
                    };
                    Img.prototype.restoreResource = function () {
 {
                            akra.logger.setSourceLocation("resources/Img.ts", 121);
                            akra.logger.assert(((((((this).iResourceFlags) & ((1 << ((/*checked (origin: akra)>>*/akra.EResourceItemEvents.CREATED))))) != 0))), "The resource has not been created.");
                        }
                        ;
                        /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyRestored();
                        return true;
                    };
                    Img.prototype.disableResource = function () {
 {
                            akra.logger.setSourceLocation("resources/Img.ts", 129);
                            akra.logger.assert(((((((this).iResourceFlags) & ((1 << ((/*checked (origin: akra)>>*/akra.EResourceItemEvents.CREATED))))) != 0))), "The resource has not been created.");
                        }
                        ;
                        /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyDisabled();
                        return true;
                    };
                    Img.prototype.loadResource = function (sFilename) {
                        return !((this.load(sFilename)) === null);
                    };
                    Img.prototype.saveResource = function (sFilename) {
                        return false;
                    };
                    Img.prototype.create = function (iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps) {
                        if (typeof iDepth === "undefined") { iDepth = 1; }
                        if (typeof eFormat === "undefined") { eFormat = akra.EPixelFormats.BYTE_RGBA; }
                        if (typeof nFaces === "undefined") { nFaces = 1; }
                        if (typeof nMipMaps === "undefined") { nMipMaps = 0; }
                        var iSize = Img.calculateSize(nMipMaps, nFaces, iWidth, iHeight, iDepth, eFormat);
                        var pBuffer = new Uint8Array(iSize);
                        return this.loadDynamicImage(pBuffer, iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps);
                    };
                    Img.prototype.freeMemory = function () {
                        this._iWidth = 0;
                        this._iHeight = 0;
                        this._iDepth = 0;
                        this._pBuffer = null;
                    };
                    Img.prototype.set = function (pSrc) {
                        this.freeMemory();
                        this._iWidth = pSrc.width;
                        this._iHeight = pSrc.height;
                        this._iDepth = pSrc.depth;
                        this._eFormat = pSrc.format;
                        this._iFlags = pSrc.flags;
                        this._nMipMaps = pSrc.numMipMaps;
                        this._pBuffer = new Uint8Array(pSrc.getData());
                        return this;
                    };
                    Img.prototype.flipY = function (pDest) {
                        return this;
                    };
                    Img.prototype.flipX = function (pDest) {
                        return this;
                    };
                    Img.prototype.load = /*pData: any, sType?: any, fnCallBack?: Function*/
                    function () {
                        var pMe = this;
                        if (arguments[0] instanceof HTMLCanvasElement) {
                            var pCanvas = arguments[0];
                            var fnCallBack = arguments[1];
                            var pTempContext = pCanvas.getContext('2d');
                            if (!pTempContext) {
                                if (((fnCallBack) != null)) {
                                    fnCallBack(false);
                                }
                                return this;
                            }
                            var pImageData = pTempContext.getImageData(0, 0, pCanvas.width, pCanvas.height);
                            this.loadDynamicImage(new Uint8Array(pImageData.data.buffer.slice(0, pImageData.data.buffer.byteLength)), pCanvas.width, pCanvas.height);
                            if (((fnCallBack) != null)) {
                                fnCallBack(true);
                            }
                            return this;
                        } else if ((typeof (arguments[0]) === "string")) {
                            var sFilename = arguments[0];
                            var fnCallBack = arguments[1];
                            var sExt = (((new /*checked (origin: akra)>>*/akra.Pathinfo(sFilename)))._sExtension);
                            if (sExt === "png" || sExt === "jpg" || sExt === "jpeg" || sExt === "gif" || sExt === "bmp") {
                                var pImg = new Image();
                                pImg.onload = function () {
                                    var pTempCanvas = document.createElement("canvas");
                                    pTempCanvas.width = pImg.width;
                                    pTempCanvas.height = pImg.height;
                                    var pTempContext = ((pTempCanvas).getContext("2d"));
                                    pTempContext.drawImage(pImg, 0, 0);
                                    var pImageData = pTempContext.getImageData(0, 0, pImg.width, pImg.height);
                                    pMe.loadDynamicImage(new Uint8Array(pImageData.data.buffer.slice(0, pImageData.data.buffer.byteLength)), pImg.width, pImg.height, 1, akra.EPixelFormats.BYTE_RGBA);
                                    if (((fnCallBack) != null)) {
                                        fnCallBack(true);
                                    }
                                };
                                pImg.onerror = function () {
                                    if (((fnCallBack) != null)) {
                                        fnCallBack(false);
                                    }
                                };
                                pImg.onabort = function () {
                                    if (((fnCallBack) != null)) {
                                        fnCallBack(false);
                                    }
                                };
                                pImg.src = sFilename;
                            } else {
                                akra.io.fopen(sFilename, "rb").onread = function (pError, pDataInFile) {
                                    pMe.load(new Uint8Array(pDataInFile), sExt, fnCallBack);
                                };
                            }
                            return this;
                        } else {
                            var pData = arguments[0];
                            var sType = arguments[1];
                            var fnCallBack = arguments[2];
                            var pCodec = null;
                            if (sType === "png" || sType === "jpg" || sType === "jpeg" || sType === "gif" || sType === "bmp") {
                                var pBlob = new Blob([
                                    pData
                                ], {
                                    'type': 'image\/' + sType
                                });
                                var pObjectURL = (window).URL.createObjectURL(pBlob);
                                var pImg = new Image();
                                pImg.onload = function () {
                                    var pTempCanvas = document.createElement("canvas");
                                    pTempCanvas.width = pImg.width;
                                    pTempCanvas.height = pImg.height;
                                    var pTempContext = ((pTempCanvas).getContext("2d"));
                                    pTempContext.drawImage(pImg, 0, 0);
                                    var pImageData = pTempContext.getImageData(0, 0, pImg.width, pImg.height);
                                    pMe.loadDynamicImage(new Uint8Array(pImageData.data.buffer.slice(0, pImageData.data.buffer.byteLength)), pImg.width, pImg.height, 1, akra.EPixelFormats.BYTE_RGBA);
                                    if (((fnCallBack) != null)) {
                                        fnCallBack(true);
                                    }
                                };
                                pImg.onerror = function () {
                                    if (((fnCallBack) != null)) {
                                        fnCallBack(false);
                                    }
                                };
                                pImg.onabort = function () {
                                    if (((fnCallBack) != null)) {
                                        fnCallBack(false);
                                    }
                                };
                                pImg.src = pObjectURL;
                                return this;
                            }
                            if (sType) {
                                pCodec = akra.Codec.getCodec(sType);
                            }
                            if (!pCodec) {
                                /*buffer.*/
                                var iMagicLen = Math.min(32, pData.byteLength);
                                pCodec = akra.Codec.getCodec(pData.subarray(pData.byteOffset, iMagicLen));
                            }
                            if (!pCodec) {
 {
                                    akra.logger.setSourceLocation("resources/Img.ts", 319);
                                    akra.logger.criticalError("Unable to load image: Image format is unknown. Unable to identify codec. Check it or specify format explicitly.\n" + "Img.load");
                                }
                                ;
                                if (fnCallBack) {
                                    fnCallBack(false);
                                }
                                return this;
                            }
                            var pImgData = new akra.ImgData();
                            this._pBuffer = pCodec.decode(pData, pImgData);
                            this._iWidth = pImgData.width;
                            this._iHeight = pImgData.height;
                            this._iDepth = pImgData.depth;
                            this._nMipMaps = pImgData.numMipMaps;
                            this._iFlags = pImgData.flags;
                            this._iCubeFlags = pImgData.cubeFlags;
                            //console.log(this._iCubeFlags.toString(16),this._iFlags.toString(16));
                            this._eFormat = pImgData.format;
                            /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.notifyLoaded();
                            if (fnCallBack) {
                                fnCallBack(true);
                            }
                            return this;
                        }
                    };
                    Img.prototype.loadRawData = function (pData, iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps) {
                        if (typeof iDepth === "undefined") { iDepth = 1; }
                        if (typeof eFormat === "undefined") { eFormat = akra.EPixelFormats.BYTE_RGB; }
                        if (typeof nFaces === "undefined") { nFaces = 1; }
                        if (typeof nMipMaps === "undefined") { nMipMaps = 0; }
                        var iSize = Img.calculateSize(nMipMaps, nFaces, iWidth, iHeight, iDepth, eFormat);
                        if (iSize != pData.buffer.byteLength) {
 {
                                akra.logger.setSourceLocation("resources/Img.ts", 363);
                                akra.logger.criticalError("Stream size does not match calculated image size\n" + "Img.loadRawData");
                            }
                            ;
                        }
                        var pBuffer = new Uint8Array(iSize);
                        pBuffer.set(pData);
                        return this.loadDynamicImage(pBuffer, iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps);
                    };
                    Img.prototype.loadDynamicImage = function (pData, iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps) {
                        if (typeof iDepth === "undefined") { iDepth = 1; }
                        if (typeof eFormat === "undefined") { eFormat = akra.EPixelFormats.BYTE_RGB; }
                        if (typeof nFaces === "undefined") { nFaces = 1; }
                        if (typeof nMipMaps === "undefined") { nMipMaps = 0; }
                        //size
                        this._iWidth = iWidth;
                        this._iHeight = iHeight;
                        this._iDepth = iDepth;
                        this._eFormat = eFormat;
                        this._nMipMaps = nMipMaps;
                        this._iFlags = 0;
                        if ((((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor(((this._eFormat))).flags) & /*checked (origin: akra)>>*/akra.EPixelFormatFlags.COMPRESSED) > 0)) {
                            this._iFlags |= akra.EImageFlags.COMPRESSED;
                        }
                        if (this._iDepth != 1) {
                            this._iFlags |= akra.EImageFlags.TEXTURE_3D;
                        }
                        if (nFaces == 6) {
                            this._iFlags |= akra.EImageFlags.CUBEMAP;
                        }
                        if (nFaces != 6 && nFaces != 1) {
 {
                                akra.logger.setSourceLocation("resources/Img.ts", 401);
                                akra.logger.criticalError("Number of faces currently must be 6 or 1.\n" + "Img.loadDynamicImage");
                            }
                            ;
                        }
                        this._pBuffer = pData;
                        /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.notifyLoaded();
                        return this;
                    };
                    Img.prototype.convert = function (eFormat) {
                        return false;
                    };
                    Img.prototype.getRawSpan = //Gets the physical width in bytes of each row of pixels.
                    function () {
                        return this._iWidth * this.getPixelSize();
                    };
                    Img.prototype.getBPP = function () {
                        return this.getPixelSize() * 8;
                    };
                    Img.prototype.getPixelSize = function () {
                        return (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor((this._eFormat)).elemBytes);
                    };
                    Img.prototype.getData = function () {
                        return this._pBuffer;
                    };
                    Img.prototype.hasFlag = function (eFlag) {
                        if (this._iFlags & eFlag) {
                            return true;
                        } else {
                            return false;
                        }
                    };
                    Img.prototype.hasAlpha = function () {
                        return (((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor(((this._eFormat))).flags) & /*checked (origin: akra)>>*/akra.EPixelFormatFlags.HASALPHA) > 0);
                    };
                    Img.prototype.isCompressed = function () {
                        return (((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor(((this._eFormat))).flags) & /*checked (origin: akra)>>*/akra.EPixelFormatFlags.COMPRESSED) > 0);
                    };
                    Img.prototype.isLuminance = function () {
                        return (((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor(((this._eFormat))).flags) & /*checked (origin: akra)>>*/akra.EPixelFormatFlags.LUMINANCE) > 0);
                    };
                    Img.prototype.getColorAt = function (pColor, x, y, z) {
                        if (typeof z === "undefined") { z = 0; }
                        var iStart = this.getPixelSize() * (z * this._iWidth * this._iHeight + this._iWidth * y + x);
                        akra.pixelUtil.unpackColour(pColor, this._eFormat, this._pBuffer.subarray(iStart, iStart + this.getPixelSize()));
                        return pColor;
                    };
                    Img.prototype.setColorAt = function (pColor, x, y, z) {
                        if (typeof z === "undefined") { z = 0; }
                        var iStart = this.getPixelSize() * (z * this._iWidth * this._iHeight + this._iWidth * y + x);
                        (/*checked (origin: pixelUtil)>>*/akra.pixelUtil.packColourFloat((pColor).r, (pColor).g, (pColor).b, (pColor).a, (this._eFormat), (this._pBuffer.subarray(iStart, iStart + this.getPixelSize()))));
                    };
                    Img.prototype.getPixels = function (iFace, iMipMap) {
                        // Image data is arranged as:
                        // face 0, top level (mip 0)
                        // face 0, mip 1
                        // face 0, mip 2
                        // face 1, top level (mip 0)
                        // face 1, mip 1
                        // face 1, mip 2
                        // etc
                        if (iMipMap > ((this)._nMipMaps)) {
 {
                                akra.logger.setSourceLocation("resources/Img.ts", 484);
                                akra.logger.warning("Mipmap index out of range", iMipMap, ((this)._nMipMaps));
                            }
                            ;
                            return null;
                        }
                        if (iFace >= /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.numFaces) {
 {
                                akra.logger.setSourceLocation("resources/Img.ts", 489);
                                akra.logger.warning("Face index out of range", iFace, /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.numFaces);
                            }
                            ;
                            return null;
                        }
                        // Calculate mipmap offset and size
                        var pData = this.getData();
                        // Base offset is number of full faces
                        var iWidth = this._iWidth;
                        var iHeight = this._iHeight;
                        var iDepth = this._iDepth;
                        // Figure out the offsets
                        var iFullFaceSize = 0;
                        var iFinalFaceSize = 0;
                        var iFinalWidth = 0;
                        var iFinalHeight = 0;
                        var iFinalDepth = 0;
                        var iMipSize = 0;
                        var iOffset = 0;
                        for(var iMip = 0; iMip <= ((this)._nMipMaps); ++iMip) {
                            if (iMip == iMipMap) {
                                iFinalFaceSize = iFullFaceSize;
                                iFinalWidth = iWidth;
                                iFinalHeight = iHeight;
                                iFinalDepth = iDepth;
                                iMipSize = akra.pixelUtil.getMemorySize(iWidth, iHeight, iDepth, ((this)._eFormat));
                            }
                            iFullFaceSize += akra.pixelUtil.getMemorySize(iWidth, iHeight, iDepth, ((this)._eFormat));
                            /// Half size in each dimension
                            if (iWidth != 1) {
                                iWidth /= 2;
                            }
                            if (iHeight != 1) {
                                iHeight /= 2;
                            }
                            if (iDepth != 1) {
                                iDepth /= 2;
                            }
                        }
                        // Advance pointer by number of full faces, plus mip offset into
                        iOffset += iFace * iFullFaceSize;
                        iOffset += iFinalFaceSize;
                        // Return subface as pixelbox
                        var pSrc = new akra.pixelUtil.PixelBox(iFinalWidth, iFinalHeight, iFinalDepth, ((this)._eFormat), pData.subarray(iOffset, iOffset + iMipSize));
                        return pSrc;
                    };
                    Img.prototype.scale = function (pDest, eFilter) {
                        return null;
                    };
                    Img.prototype.resize = function (iWidth, iHeight, eFilter) {
                        return null;
                    };
                    Img.prototype.generatePerlinNoise = function (fScale, iOctaves, fFalloff) {
                    };
                    Img.prototype.randomChannelNoise = function (iChannel, iMinRange, iMaxRange) {
                    };
                    Img.calculateSize = function calculateSize(nMipMaps, nFaces, iWidth, iHeight, iDepth, eFormat) {
                        var iSize = 0;
                        var iMip = 0;
                        for(iMip = 0; iMip <= nMipMaps; iMip++) {
                            iSize += akra.pixelUtil.getMemorySize(iWidth, iHeight, iDepth, eFormat) * nFaces;
                            if (iWidth != 1) {
                                iWidth = Math.floor(iWidth / 2);
                            }
                            if (iHeight != 1) {
                                iHeight = Math.floor(iHeight / 2);
                            }
                            if (iDepth != 1) {
                                iDepth = Math.floor(iDepth / 2);
                            }
                        }
                        return iSize;
                    };
                    Img.getMaxMipmaps = function getMaxMipmaps(iWidth, iHeight, iDepth, eFormat) {
                        var iCount = 0;
                        if ((iWidth > 0) && (iHeight > 0)) {
                            do {
                                if (iWidth > 1) {
                                    iWidth = iWidth >>> 1;
                                }
                                if (iHeight > 1) {
                                    iHeight = iHeight >>> 1;
                                }
                                if (iDepth > 1) {
                                    iDepth = iDepth >>> 1;
                                }
                                /*
                                NOT needed, compressed formats will have mipmaps up to 1x1
                                if(PixelUtil::isValidExtent(width, height, depth, format))
                                count ++;
                                else
                                break;
                                */
                                iCount++;
                            } while(!(iWidth === 1 && iHeight === 1 && iDepth === 1));
                        }
                        return iCount;
                    };
                    return Img;
                })(pool.ResourcePoolItem);
                resources.Img = Img;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var Component = (function (_super) {
                    __extends(Component, _super);
                    function Component() {
                                        _super.call(this);
                        this._pTechnique = null;
                        this._pComposer = null;
                    }
                    Component.prototype.create = function () {
                        this._pComposer = (((((((this)).pResourcePool)).pManager))).getEngine().getComposer();
                    };
                    Component.prototype.getTechnique = /** @inline */function () {
                        return this._pTechnique;
                    };
                    Component.prototype.setTechnique = /** @inline */function (pTechnique) {
                        this._pTechnique = pTechnique;
                    };
                    Component.prototype.getName = /** @inline */function () {
                        return this._pTechnique.getName();
                    };
                    Component.prototype.getTotalPasses = /** @inline */function () {
                        return this._pTechnique.totalOwnPasses();
                    };
                    Component.prototype.getHash = /** @inline */function (iShift, iPass) {
                        return ((this)._iGuid) + ">" + iShift.toString() + ">" + (iPass === 0xffffff ? "A" : iPass.toString());
                    };
                    return Component;
                })(pool.ResourcePoolItem);
                resources.Component = Component;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    (function (ERenderDataTypes) {
        ERenderDataTypes._map = [];
        /*<! положить данные в текстуру, и больше ничего не делать.*/
        ERenderDataTypes.ISOLATED = 0;
        ERenderDataTypes._map[1] = "INDEXED";
        /*<! обычные даннае из текстуры, доступные по индексу.*/
        ERenderDataTypes.INDEXED = 1;
        ERenderDataTypes._map[2] = "I2I";
        /*<! данные по 2йному индексу.*/
        ERenderDataTypes.I2I = 2;
        ERenderDataTypes._map[3] = "DIRECT";
        /*<! непосредственно данные для атрибута.*/
        ERenderDataTypes.DIRECT = 3;
    })(akra.ERenderDataTypes || (akra.ERenderDataTypes = {}));
    var ERenderDataTypes = akra.ERenderDataTypes;
    ;
    (function (ERenderDataOptions) {
        ERenderDataOptions._map = [];
        /*<! использовать индекс на индекс упаковку данных*/
        ERenderDataOptions.ADVANCED_INDEX = (1 << (0x10));
        ERenderDataOptions.SINGLE_INDEX = (1 << (0x11));
        /*<! создать RenderData как классические данные, с данными только в аттрибутах, без использования видео буфферов.*/
        /*<! определяет, будет ли объект редерится*/
        ERenderDataOptions.RENDERABLE = (1 << (0x12));
    })(akra.ERenderDataOptions || (akra.ERenderDataOptions = {}));
    var ERenderDataOptions = akra.ERenderDataOptions;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    (function (EMeshOptions) {
        EMeshOptions._map = [];
        EMeshOptions.HB_READABLE = akra.EHardwareBufferFlags.READABLE;
        EMeshOptions.RD_ADVANCED_INDEX = akra.ERenderDataOptions.ADVANCED_INDEX;
    })(akra.EMeshOptions || (akra.EMeshOptions = {}));
    var EMeshOptions = akra.EMeshOptions;
    ;
    (function (EMeshCloneOptions) {
        EMeshCloneOptions._map = [];
        /*<! copy only geometry*/
        EMeshCloneOptions.GEOMETRY_ONLY = 0x00;
        /*<! use shared geometry*/
        EMeshCloneOptions.SHARED_GEOMETRY = 0x01;
    })(akra.EMeshCloneOptions || (akra.EMeshCloneOptions = {}));
    var EMeshCloneOptions = akra.EMeshCloneOptions;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    ;
    (function (ERenderDataBufferOptions) {
        ERenderDataBufferOptions._map = [];
        ERenderDataBufferOptions.VB_READABLE = akra.EHardwareBufferFlags.READABLE;
        ERenderDataBufferOptions.RD_ADVANCED_INDEX = akra.ERenderDataOptions.ADVANCED_INDEX;
        ERenderDataBufferOptions.RD_SINGLE_INDEX = akra.ERenderDataOptions.SINGLE_INDEX;
        ERenderDataBufferOptions.RD_RENDERABLE = akra.ERenderDataOptions.RENDERABLE;
    })(akra.ERenderDataBufferOptions || (akra.ERenderDataBufferOptions = {}));
    var ERenderDataBufferOptions = akra.ERenderDataBufferOptions;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    (function (EEntityTypes) {
        EEntityTypes._map = [];
        EEntityTypes._map[0] = "UNKNOWN";
        EEntityTypes.UNKNOWN = 0;
        EEntityTypes._map[1] = "NODE";
        EEntityTypes.NODE = 1;
        EEntityTypes._map[2] = "JOINT";
        EEntityTypes.JOINT = 2;
        EEntityTypes._map[3] = "SCENE_NODE";
        EEntityTypes.SCENE_NODE = 3;
        EEntityTypes._map[4] = "CAMERA";
        EEntityTypes.CAMERA = 4;
        EEntityTypes._map[5] = "SHADOW_CASTER";
        EEntityTypes.SHADOW_CASTER = 5;
        EEntityTypes._map[6] = "MODEL_ENTRY";
        EEntityTypes.MODEL_ENTRY = 6;
        EEntityTypes.LIGHT = 37;
        EEntityTypes.SCENE_OBJECT = 64;
        EEntityTypes._map[65] = "MODEL";
        EEntityTypes.MODEL = 65;
        EEntityTypes._map[66] = "TERRAIN";
        EEntityTypes.TERRAIN = 66;
        EEntityTypes._map[67] = "TERRAIN_ROAM";
        EEntityTypes.TERRAIN_ROAM = 67;
        EEntityTypes._map[68] = "TERRAIN_SECTION";
        EEntityTypes.TERRAIN_SECTION = 68;
        EEntityTypes._map[69] = "TERRAIN_SECTION_ROAM";
        EEntityTypes.TERRAIN_SECTION_ROAM = 69;
        EEntityTypes._map[70] = "TEXT3D";
        EEntityTypes.TEXT3D = 70;
        EEntityTypes._map[71] = "SPRITE";
        EEntityTypes.SPRITE = 71;
        EEntityTypes._map[72] = "EMITTER";
        EEntityTypes.EMITTER = 72;
        EEntityTypes.UI_NODE = 100;
        // UI_HTMLNODE,
        // UI_DNDNODE,
        // UI_COMPONENT,
        // UI_BUTTON,
        // UI_LABEL,
        // UI_TREE,
        EEntityTypes.OBJECTS_LIMIT = 128;
    })(akra.EEntityTypes || (akra.EEntityTypes = {}));
    var EEntityTypes = akra.EEntityTypes;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    (function (ENodeInheritance) {
        ENodeInheritance._map = [];
        //inheritance only position
        ENodeInheritance.POSITION = 0;
        ENodeInheritance._map[1] = "ROTSCALE";
        //inheritance rotation and scale only
        ENodeInheritance.ROTSCALE = 1;
        ENodeInheritance._map[2] = "ALL";
        //inheritance all
        ENodeInheritance.ALL = 2;
    })(akra.ENodeInheritance || (akra.ENodeInheritance = {}));
    var ENodeInheritance = akra.ENodeInheritance;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        (function (EEntityStates) {
            EEntityStates._map = [];
            //обновился ли сам узел?
            EEntityStates.k_Updated = 0x01;
            //есть ли среди потомков обновленные узлы
            EEntityStates.k_DescendantsUpdtated = 0x02;
            //если ли обновленные узлы среди братьев или их потомках
            EEntityStates.k_SiblingsUpdated = 0x04;
        })(util.EEntityStates || (util.EEntityStates = {}));
        var EEntityStates = util.EEntityStates;
        var Entity = (function (_super) {
            __extends(Entity, _super);
            function Entity(eType) {
                        _super.call(this);
                /**@protected*/ this._sName = null;
                /**@protected*/ this._pParent = null;
                /**@protected*/ this._pSibling = null;
                /**@protected*/ this._pChild = null;
                /**@protected*/ this._eType = akra.EEntityTypes.UNKNOWN;
                /**@protected*/ this._iStateFlags = 0;
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
                this._eType = eType;
            }
            Object.defineProperty(Entity.prototype, "name", {
                get: /** @inline */function () {
                    return this._sName;
                },
                set: /** @inline */function (sName) {
                    this._sName = sName;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Entity.prototype, "parent", {
                get: /** @inline */function () {
                    return this._pParent;
                },
                set: /** @inline */function (pParent) {
                    this.attachToParent(pParent);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Entity.prototype, "sibling", {
                get: /** @inline */function () {
                    return this._pSibling;
                },
                set: /** @inline */function (pSibling) {
                    this._pSibling = pSibling;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Entity.prototype, "child", {
                get: /** @inline */function () {
                    return this._pChild;
                },
                set: /** @inline */function (pChild) {
                    this._pChild = pChild;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Entity.prototype, "type", {
                get: /** @inline */function () {
                    return this._eType;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Entity.prototype, "rightSibling", {
                get: function () {
                    var pSibling = ((this)._pSibling);
                    if (pSibling) {
                        while(pSibling.sibling) {
                            pSibling = pSibling.sibling;
                        }
                        return pSibling;
                    }
                    return this;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Entity.prototype, "depth", {
                get: function () {
                    var iDepth = -1;
                    for(var pEntity = this; pEntity; pEntity = pEntity.parent, ++iDepth) {
                    }
                    ;
                    return iDepth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Entity.prototype, "root", {
                get: function () {
                    for(var pEntity = this, iDepth = -1; pEntity.parent; pEntity = pEntity.parent, ++iDepth) {
                    }
                    ;
                    return pEntity;
                },
                enumerable: true,
                configurable: true
            });
            Entity.prototype.destroy = function (bRecursive, bPromoteChildren) {
                if (typeof bRecursive === "undefined") { bRecursive = false; }
                if (typeof bPromoteChildren === "undefined") { bPromoteChildren = true; }
                if (bRecursive) {
                    if (this._pSibling) {
                        this._pSibling.destroy(true);
                    }
                    if (this._pChild) {
                        this._pChild.destroy(true);
                    }
                }
                // destroy anything attached to this node
                //	destroySceneObject();
                // promote any children up to our parent
                if (bPromoteChildren && !bRecursive) {
                    this.promoteChildren();
                }
                // now remove ourselves from our parent
                this.detachFromParent();
                // we should now be removed from the tree, and have no dependants
                 {
                    util.logger.setSourceLocation("util/Entity.ts", 93);
                    util.logger.assert(this.referenceCount() == 0, "Attempting to delete a scene node which is still in use");
                }
                ;
 {
                    util.logger.setSourceLocation("util/Entity.ts", 94);
                    util.logger.assert(this._pSibling == null, "Failure Destroying Node");
                }
                ;
 {
                    util.logger.setSourceLocation("util/Entity.ts", 95);
                    util.logger.assert(this._pChild == null, "Failure Destroying Node");
                }
                ;
            };
            Entity.prototype.findEntity = function (sName) {
                var pEntity = null;
                if (this._sName === sName) {
                    return this;
                }
                if (this._pSibling) {
                    pEntity = this._pSibling.findEntity(sName);
                }
                if (pEntity == null && this._pChild) {
                    pEntity = this._pChild.findEntity(sName);
                }
                return pEntity;
            };
            Entity.prototype.explore = function (fn) {
                if (fn(this) === false) {
                    return;
                }
                if (this._pSibling) {
                    this._pSibling.explore(fn);
                }
                if (this._pChild) {
                    this._pChild.explore(fn);
                }
            };
            Entity.prototype.childOf = function (pParent) {
                for(var pEntity = this; pEntity; pEntity = pEntity.parent) {
                    if (pEntity.parent === pParent) {
                        return true;
                    }
                }
                return false;
            };
            Entity.prototype.children = function () {
                var pChildren = [];
                var pChild = ((this)._pChild);
                while(!((pChild) === null)) {
                    pChildren.push(pChild);
                    pChild = pChild.sibling;
                }
                return pChildren;
            };
            Entity.prototype.childAt = function (i) {
                var pChild = ((this)._pChild);
                var n = 0;
                while(!((pChild) === null)) {
                    if (n == i) {
                        return pChild;
                    }
                    n++;
                    pChild = pChild.sibling;
                }
                return pChild;
            };
            Entity.prototype.siblingCount = /**
            * Returns the current number of siblings of this object.
            */
            function () {
                var iCount = 0;
                if (this._pParent) {
                    var pNextSibling = this._pParent.child;
                    if (pNextSibling) {
                        while(pNextSibling) {
                            pNextSibling = pNextSibling.sibling;
                            ++iCount;
                        }
                    }
                }
                return iCount;
            };
            Entity.prototype.descCount = function () {
                var n = this.childCount();
                var pChild = ((this)._pChild);
                while(!((pChild) === null)) {
                    n += pChild.descCount();
                    pChild = pChild.sibling;
                }
                return n;
            };
            Entity.prototype.childCount = /**
            * Returns the current number of children of this object
            */
            function () {
                var iCount = 0;
                var pChild = ((this)._pChild);
                while(!((pChild) === null)) {
                    iCount++;
                    pChild = pChild.sibling;
                }
                // var pNextChild: IEntity = this.child;
                // if (pNextChild) {
                //     ++ iCount;
                //     while (pNextChild) {
                //         pNextChild = pNextChild.sibling;
                //         ++ iCount;
                //     }
                // }
                return iCount;
            };
            Entity.prototype.isUpdated = /** @inline */function () {
                return (((this._iStateFlags) & (EEntityStates.k_Updated)) == (EEntityStates.k_Updated));
            };
            Entity.prototype.hasUpdatedSubNodes = /** @inline */function () {
                return (((this._iStateFlags) & (EEntityStates.k_DescendantsUpdtated)) == (EEntityStates.k_DescendantsUpdtated));
            };
            Entity.prototype.recursiveUpdate = function () {
                // var bUpdated: bool = false;
                // update myself
                if (this.update()) {
                    ((this._iStateFlags) |= (EEntityStates.k_Updated));
                    // bUpdated = true;
                                    }
                // update my sibling
                if (this._pSibling && this._pSibling.recursiveUpdate()) {
                    ((this._iStateFlags) |= (EEntityStates.k_SiblingsUpdated));
                    // bUpdated = true;
                                    }
                // update my child
                if (this._pChild && this._pChild.recursiveUpdate()) {
                    ((this._iStateFlags) |= (EEntityStates.k_DescendantsUpdtated));
                    // bUpdated = true;
                                    }
                /*bUpdated */
                return (this._iStateFlags != 0);
            };
            Entity.prototype.recursivePreUpdate = function () {
                // clear the flags from the previous update
                this.prepareForUpdate();
                // update my sibling
                if (this._pSibling) {
                    this._pSibling.recursivePreUpdate();
                }
                // update my child
                if (this._pChild) {
                    this._pChild.recursivePreUpdate();
                }
            };
            Entity.prototype.prepareForUpdate = function () {
                this._iStateFlags = 0;
            };
            Entity.prototype.hasParent = /** Parent is not undef */
            /** @inline */function () {
                return ((this._pParent) != null);
            };
            Entity.prototype.hasChild = /** Child is not undef*/
            /** @inline */function () {
                return ((this._pChild) != null);
            };
            Entity.prototype.hasSibling = /** Sibling is not undef */
            /** @inline */function () {
                return ((this._pSibling) != null);
            };
            Entity.prototype.isASibling = /**
            * Checks to see if the provided item is a sibling of this object
            */
            function (pSibling) {
                if (!pSibling) {
                    return false;
                }
                // if the sibling we are looking for is me, or my FirstSibling, return true
                if (this == pSibling || this._pSibling == pSibling) {
                    return true;
                }
                // if we have a sibling, continue searching
                if (this._pSibling) {
                    return this._pSibling.isASibling(pSibling);
                }
                // it's not us, and we have no sibling to check. This is not a sibling of ours.
                return false;
            };
            Entity.prototype.isAChild = /** Checks to see if the provided item is a child of this object. (one branch depth only) */
            function (pChild) {
                if (!pChild) {
                    return (false);
                }
                // if the sibling we are looking for is my FirstChild return true
                if (this._pChild == pChild) {
                    return (true);
                }
                // if we have a child, continue searching
                if (this._pChild) {
                    return (this._pChild.isASibling(pChild));
                }
                // it's not us, and we have no child to check. This is not a sibling of ours.
                return (false);
            };
            Entity.prototype.isInFamily = /**
            * Checks to see if the provided item is a child or sibling of this object. If SearchEntireTree
            * is TRUE, the check is done recursivly through all siblings and children. SearchEntireTree
            * is FALSE by default.
            */
            function (pEntity, bSearchEntireTree) {
                if (!pEntity) {
                    return (false);
                }
                // if the model we are looking for is me or my immediate family, return true
                if (this == pEntity || this._pChild == pEntity || this._pSibling == pEntity) {
                    return (true);
                }
                // if not set to seach entire tree, just check my siblings and kids
                if (!bSearchEntireTree) {
                    if (this.isASibling(pEntity)) {
                        return (true);
                    }
                    if (this._pChild && this._pChild.isASibling(pEntity)) {
                        return (true);
                    }
                } else// seach entire Tree!!!
                 {
                    if (this._pSibling && this._pSibling.isInFamily(pEntity, bSearchEntireTree)) {
                        return (true);
                    }
                    if (this._pChild && this._pChild.isInFamily(pEntity, bSearchEntireTree)) {
                        return (true);
                    }
                }
                return (false);
            };
            Entity.prototype.addSibling = /**
            * Adds the provided ModelSpace object to the descendant list of this object. The provided
            * ModelSpace object is removed from any parent it may already belong to.
            */
            function (pSibling) {
                if (pSibling) {
                    // replace objects current sibling pointer with this new one
                    pSibling.sibling = this._pSibling;
                    ((this)._pSibling = (pSibling));
                }
                return pSibling;
            };
            Entity.prototype.addChild = /**
            * Adds the provided ModelSpace object to the descendant list of this object. The provided
            * ModelSpace object is removed from any parent it may already belong to.
            */
            function (pChild) {
                if (pChild) {
                    // Replace the new child's sibling pointer with our old first child.
                    pChild.sibling = this._pChild;
                    // the new child becomes our first child pointer.
                    this._pChild = pChild;
                    this.childAdded(pChild);
                }
                return pChild;
            };
            Entity.prototype.removeChild = /**
            * Removes a specified child object from this parent object. If the child is not the
            * FirstChild of this object, all of the Children are searched to find the object to remove.
            */
            function (pChild) {
                if (this._pChild && pChild) {
                    if (this._pChild == pChild) {
                        this._pChild = pChild.sibling;
                        pChild.sibling = null;
                    } else {
                        var pTempNode = this._pChild;
                        // keep searching until we find the node who's sibling is our target
                        // or we reach the end of the sibling chain
                        while(pTempNode && (pTempNode.sibling != pChild)) {
                            pTempNode = pTempNode.sibling;
                        }
                        // if we found the proper item, set it's FirstSibling to be the FirstSibling of the child
                        // we are removing
                        if (pTempNode) {
                            pTempNode.sibling = pChild.sibling;
                            pChild.sibling = null;
                        }
                    }
                    this.childRemoved(pChild);
                }
                return pChild;
            };
            Entity.prototype.removeAllChildren = /** Removes all Children from this parent object */
            function () {
                // keep removing children until end of chain is reached
                while(!((this._pChild) === null)) {
                    var pNextSibling = this._pChild.sibling;
                    this._pChild.detachFromParent();
                    this._pChild = pNextSibling;
                }
            };
            Entity.prototype.attachToParent = /** Attaches this object ot a new parent. Same as calling the parent's addChild() routine. */
            function (pParent) {
                var pParentPrev = ((this)._pParent);
                if (pParent != this._pParent) {
                    this.detachFromParent();
                    if (pParent) {
                        if (pParent.addChild(this)) {
                            this._pParent = pParent;
                            this._pParent.addRef();
                            this.attached();
                            return true;
                        }
                        return this.attachToParent(pParentPrev);
                    }
                }
                return false;
            };
            Entity.prototype.detachFromParent = function () {
                // tell our current parent to release us
                if (this._pParent) {
                    this._pParent.removeChild(this);
                    //TODO: разобраться что за херня!!!!
                    if (this._pParent) {
                        this._pParent.release();
                    }
                    this._pParent = null;
                    // my world matrix is now my local matrix
                    this.detached();
                    return true;
                }
                return false;
            };
            Entity.prototype.promoteChildren = /**
            * Attaches this object's children to it's parent, promoting them up the tree
            */
            function () {
                // Do I have any children to promote?
                while(!((this._pChild) === null)) {
                    var pNextSibling = this._pChild.sibling;
                    this._pChild.attachToParent(this._pParent);
                    this._pChild = pNextSibling;
                }
            };
            Entity.prototype.relocateChildren = function (pParent) {
                if (pParent != this) {
                    // Do I have any children to relocate?
                    while(!((this._pChild) === null)) {
                        var pNextSibling = this._pChild.sibling;
                        this._pChild.attachToParent(pParent);
                        this._pChild = pNextSibling;
                    }
                }
            };
            Entity.prototype.update = function () {
                return false;
            };
            Entity.prototype.toString = function (isRecursive, iDepth) {
                if (typeof isRecursive === "undefined") { isRecursive = false; }
                if (typeof iDepth === "undefined") { iDepth = 0; }
                if (!isRecursive) {
                    return '<entity' + (this._sName ? ' ' + this._sName : "") + '>';
                }
                var pSibling = this.sibling;
                var pChild = ((this)._pChild);
                var s = "";
                for(var i = 0; i < iDepth; ++i) {
                    s += ':  ';
                }
                s += '+----[depth: ' + this.depth + ']' + this.toString() + '\n';
                if (pChild) {
                    s += pChild.toString(true, iDepth + 1);
                }
                if (pSibling) {
                    s += pSibling.toString(true, iDepth);
                }
                return s;
            };
            Entity.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            Entity._pEventTable = new akra.events.EventTable();
            Entity.prototype.getEventTable = /** @inline */function () {
                return Entity._pEventTable;
            };
            Entity.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Entity.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Entity.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (Entity._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Entity.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (Entity._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Entity.prototype._syncTable = /** @inline */function (pFrom) {
                (Entity._pEventTable)._sync(this, pFrom);
            };
            Entity.prototype.attached = function () {
                var _recivier = this;
                this._pUnicastSlotMap = this._pUnicastSlotMap || ((Entity._pEventTable)).findUnicastList(this._iGuid);
                var _unicast = (this._pUnicastSlotMap).attached;
                if (((_unicast) !== undefined)) {
                    _unicast.target ? _unicast.target[_unicast.callback](_recivier) : _unicast.listener(_recivier);
                }
            };
            Entity.prototype.detached = function () {
                var _recivier = this;
                this._pUnicastSlotMap = this._pUnicastSlotMap || ((Entity._pEventTable)).findUnicastList(this._iGuid);
                var _unicast = (this._pUnicastSlotMap).detached;
                if (((_unicast) !== undefined)) {
                    _unicast.target ? _unicast.target[_unicast.callback](_recivier) : _unicast.listener(_recivier);
                }
            };
            Entity.prototype.childAdded = function (child) {
                var _recivier = this;
                this._pUnicastSlotMap = this._pUnicastSlotMap || ((Entity._pEventTable)).findUnicastList(this._iGuid);
                var _unicast = (this._pUnicastSlotMap).childAdded;
                if (((_unicast) !== undefined)) {
                    _unicast.target ? _unicast.target[_unicast.callback](_recivier, child) : _unicast.listener(_recivier, child);
                }
            };
            Entity.prototype.childRemoved = function (child) {
                var _recivier = this;
                this._pUnicastSlotMap = this._pUnicastSlotMap || ((Entity._pEventTable)).findUnicastList(this._iGuid);
                var _unicast = (this._pUnicastSlotMap).childRemoved;
                if (((_unicast) !== undefined)) {
                    _unicast.target ? _unicast.target[_unicast.callback](_recivier, child) : _unicast.listener(_recivier, child);
                }
            };
            return Entity;
        })(util.ReferenceCounter);
        util.Entity = Entity;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        (function (ENodeUpdateFlags) {
            ENodeUpdateFlags._map = [];
            ENodeUpdateFlags.k_SetForDestruction = 0;
            ENodeUpdateFlags._map[1] = "k_NewOrientation";
            //if changed scale, otation or position
            ENodeUpdateFlags.k_NewOrientation = 1;
            ENodeUpdateFlags._map[2] = "k_NewWorldMatrix";
            // k_NewTranslation,
            // k_NewScale,
            ENodeUpdateFlags.k_NewWorldMatrix = 2;
            ENodeUpdateFlags._map[3] = "k_NewLocalMatrix";
            ENodeUpdateFlags.k_NewLocalMatrix = 3;
            ENodeUpdateFlags._map[4] = "k_RebuildInverseWorldMatrix";
            ENodeUpdateFlags.k_RebuildInverseWorldMatrix = 4;
            ENodeUpdateFlags._map[5] = "k_RebuildNormalMatrix";
            ENodeUpdateFlags.k_RebuildNormalMatrix = 5;
        })(scene.ENodeUpdateFlags || (scene.ENodeUpdateFlags = {}));
        var ENodeUpdateFlags = scene.ENodeUpdateFlags;
        ;
        var Node = (function (_super) {
            __extends(Node, _super);
            function Node() {
                _super.apply(this, arguments);

                /**@protected*/ this._m4fLocalMatrix = null;
                /**@protected*/ this._m4fWorldMatrix = null;
                /**@protected*/ this._m4fInverseWorldMatrix = null;
                /**@protected*/ this._m3fNormalMatrix = null;
                /**@protected*/ this._v3fWorldPosition = null;
                /**@protected*/ this._qRotation = null;
                /**@protected*/ this._v3fTranslation = null;
                /**@protected*/ this._v3fScale = null;
                /**@protected*/ this._iUpdateFlags = 0;
                /**@protected*/ this._eInheritance = akra.ENodeInheritance.POSITION;
            }
            Node.prototype.create = function () {
                return true;
            };
            Object.defineProperty(Node.prototype, "localOrientation", {
                get: /** @inline */function () {
                    return this._qRotation;
                },
                set: /** @inline */function (qOrient) {
                    ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_NewOrientation)));
                    this._qRotation.set(qOrient);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "localPosition", {
                get: /** @inline */function () {
                    return this._v3fTranslation;
                },
                set: /** @inline */function (v3fPosition) {
                    ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_NewOrientation)));
                    this._v3fTranslation.set(v3fPosition);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "localScale", {
                get: /** @inline */function () {
                    return this._v3fScale;
                },
                set: /** @inline */function (v3fScale) {
                    ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_NewOrientation)));
                    this._v3fScale.set(v3fScale);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "localMatrix", {
                get: /** @inline */function () {
                    return this._m4fLocalMatrix;
                },
                set: /** @inline */function (m4fLocalMatrix) {
                    ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_NewLocalMatrix)));
                    this._m4fLocalMatrix.set(m4fLocalMatrix);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "worldMatrix", {
                get: /** @inline */function () {
                    return this._m4fWorldMatrix;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "worldPosition", {
                get: /** @inline */function () {
                    return this._v3fWorldPosition;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "inverseWorldMatrix", {
                get: function () {
                    if (((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_RebuildInverseWorldMatrix))) != 0)) {
                        this._m4fWorldMatrix.inverse(this._m4fInverseWorldMatrix);
                        ((this._iUpdateFlags) &= ~(1 << (ENodeUpdateFlags.k_RebuildInverseWorldMatrix)));
                    }
                    return this._m4fInverseWorldMatrix;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "normalMatrix", {
                get: function () {
                    if (((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_RebuildNormalMatrix))) != 0)) {
                        this._m4fWorldMatrix.toMat3(this._m3fNormalMatrix).inverse().transpose();
                        ((this._iUpdateFlags) &= ~(1 << (ENodeUpdateFlags.k_RebuildNormalMatrix)));
                    }
                    return this._m3fNormalMatrix;
                },
                enumerable: true,
                configurable: true
            });
            Node.prototype.update = function () {
                // derived classes update the local matrix
                // then call this base function to complete
                // the update
                return this.recalcWorldMatrix();
            };
            Node.prototype.prepareForUpdate = function () {
                _super.prototype.prepareForUpdate.call(this);
                // clear the temporary flags
                ((this._iUpdateFlags) &= ~((1 << (ENodeUpdateFlags.k_NewLocalMatrix)) | (1 << (ENodeUpdateFlags.k_NewOrientation)) | (1 << (ENodeUpdateFlags.k_NewWorldMatrix))));
            };
            Node.prototype.setInheritance = /** @inline */function (eInheritance) {
                this._eInheritance = eInheritance;
            };
            Node.prototype.getInheritance = /** @inline */function () {
                return this._eInheritance;
            };
            Node.prototype.isWorldMatrixNew = /** @inline */function () {
                return ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_NewWorldMatrix))) != 0);
            };
            Node.prototype.isLocalMatrixNew = /** @inline */function () {
                return ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_NewLocalMatrix))) != 0);
            };
            Node.prototype.recalcWorldMatrix = function () {
                var isParentMoved = this._pParent && (((((this._pParent))._iUpdateFlags & (1 << (ENodeUpdateFlags.k_NewWorldMatrix))) != 0));
                var isOrientModified = ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_NewOrientation))) != 0);
                var isLocalModified = ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_NewLocalMatrix))) != 0);
                if (isOrientModified || isParentMoved || isLocalModified) {
                    var m4fLocal = this._m4fLocalMatrix;
                    var m4fWorld = this._m4fWorldMatrix;
                    var m4fOrient = Node._m4fTemp;
                    var v3fTemp = Node._v3fTemp;
                    var pWorldData = m4fWorld.data;
                    var pOrientData = m4fOrient.data;
                    this._qRotation.toMat4(m4fOrient);
                    m4fOrient.setTranslation(this._v3fTranslation);
                    m4fOrient.scaleRight(this._v3fScale);
                    m4fOrient.multiply(m4fLocal);
                    //console.error(m4fOrient.toString());
                    if (this._pParent) {
                        var m4fParent = (((this._pParent))._m4fWorldMatrix);
                        var pParentData = m4fParent.data;
                        if (this._eInheritance === akra.ENodeInheritance.ALL) {
                            m4fParent.multiply(m4fOrient, m4fWorld);
                        } else if (this._eInheritance === akra.ENodeInheritance.POSITION) {
                            m4fWorld.set(m4fOrient);
                            pWorldData[12] = pParentData[12] + pOrientData[12];
                            pWorldData[13] = pParentData[13] + pOrientData[13];
                            pWorldData[14] = pParentData[14] + pOrientData[14];
                        } else if (this._eInheritance === akra.ENodeInheritance.ROTSCALE) {
                            var p11 = pParentData[0], p12 = pParentData[4], p13 = pParentData[8];
                            var p21 = pParentData[1], p22 = pParentData[5], p23 = pParentData[9];
                            var p31 = pParentData[2], p32 = pParentData[6], p33 = pParentData[10];
                            var l11 = pOrientData[0], l12 = pOrientData[4], l13 = pOrientData[8];
                            var l21 = pOrientData[1], l22 = pOrientData[5], l23 = pOrientData[9];
                            var l31 = pOrientData[2], l32 = pOrientData[6], l33 = pOrientData[10];
                            pWorldData[0] = p11 * l11 + p12 * l21 + p13 * l31;
                            pWorldData[4] = p11 * l12 + p12 * l22 + p13 * l32;
                            pWorldData[8] = p11 * l13 + p12 * l23 + p13 * l33;
                            pWorldData[12] = pOrientData[12];
                            pWorldData[1] = p21 * l11 + p22 * l21 + p23 * l31;
                            pWorldData[5] = p21 * l12 + p22 * l22 + p23 * l32;
                            pWorldData[9] = p21 * l13 + p22 * l23 + p23 * l33;
                            pWorldData[13] = pOrientData[13];
                            pWorldData[2] = p31 * l11 + p32 * l21 + p33 * l31;
                            pWorldData[6] = p31 * l12 + p32 * l22 + p33 * l32;
                            pWorldData[10] = p31 * l13 + p32 * l23 + p33 * l33;
                            pWorldData[14] = pOrientData[14];
                            pWorldData[3] = pOrientData[3];
                            pWorldData[7] = pOrientData[7];
                            pWorldData[11] = pOrientData[11];
                            pWorldData[15] = pOrientData[15];
                        }
                    } else {
                        m4fWorld.set(m4fOrient);
                    }
                    this._v3fWorldPosition.x = pWorldData[12];
                    this._v3fWorldPosition.y = pWorldData[13];
                    this._v3fWorldPosition.z = pWorldData[14];
                    // set the flag that our world matrix has changed
                    ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_NewWorldMatrix)));
                    // and it's inverse & vectors are out of date
                    ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_RebuildInverseWorldMatrix)));
                    ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_RebuildNormalMatrix)));
                    return true;
                }
                return false;
            };
            Node.prototype.setPosition = function (fX, fY, fZ) {
                var pPos = arguments.length === 1 ? arguments[0] : akra.Vec3.stackCeil.set(fX, fY, fZ);
                var v3fTranslation = this._v3fTranslation;
                v3fTranslation.set(pPos);
                ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_NewOrientation)));
            };
            Node.prototype.setRelPosition = function (fX, fY, fZ) {
                var pPos = arguments.length === 1 ? arguments[0] : akra.Vec3.stackCeil.set(fX, fY, fZ);
                var v3fTranslation = this._v3fTranslation;
                this._qRotation.multiplyVec3(pPos);
                v3fTranslation.set(pPos);
                ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_NewOrientation)));
            };
            Node.prototype.addPosition = function (fX, fY, fZ) {
                var pPos = arguments.length === 1 ? arguments[0] : akra.Vec3.stackCeil.set(fX, fY, fZ);
                var v3fTranslation = this._v3fTranslation;
                v3fTranslation.add(pPos);
                ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_NewOrientation)));
            };
            Node.prototype.addRelPosition = function (fX, fY, fZ) {
                var pPos = arguments.length === 1 ? arguments[0] : akra.Vec3.stackCeil.set(fX, fY, fZ);
                var v3fTranslation = this._v3fTranslation;
                this._qRotation.multiplyVec3(pPos);
                v3fTranslation.add(pPos);
                ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_NewOrientation)));
            };
            Node.prototype.setRotationByMatrix = function (matrix) {
                matrix.toQuat4(this._qRotation);
                ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_NewOrientation)));
            };
            Node.prototype.setRotationByAxisAngle = function (v3fAxis, fAngle) {
                akra.Quat4.fromAxisAngle(v3fAxis, fAngle, this._qRotation);
                ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_NewOrientation)));
            };
            Node.prototype.setRotationByForwardUp = function (v3fForward, v3fUp) {
                akra.Quat4.fromForwardUp(v3fForward, v3fUp, this._qRotation);
                ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_NewOrientation)));
            };
            Node.prototype.setRotationByEulerAngles = function (fYaw, fPitch, fRoll) {
                akra.Quat4.fromYawPitchRoll(fYaw, fPitch, fRoll, this._qRotation);
                ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_NewOrientation)));
            };
            Node.prototype.setRotationByXYZAxis = function (fX, fY, fZ) {
                akra.Quat4.fromYawPitchRoll(fY, fX, fZ, this._qRotation);
                ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_NewOrientation)));
            };
            Node.prototype.setRotation = function (q4fRotation) {
                this._qRotation.set(q4fRotation);
                ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_NewOrientation)));
            };
            Node.prototype.addRelRotationByMatrix = function (matrix) {
                this.addRelRotation(arguments[0].toQuat4(Node._q4fTemp));
            };
            Node.prototype.addRelRotationByAxisAngle = /** @inline */function (v3fAxis, fAngle) {
                this.addRelRotation(akra.Quat4.fromAxisAngle(v3fAxis, fAngle, Node._q4fTemp));
            };
            Node.prototype.addRelRotationByForwardUp = /** @inline */function (v3fForward, v3fUp) {
                this.addRelRotation(akra.Quat4.fromForwardUp(v3fForward, v3fUp, Node._q4fTemp));
            };
            Node.prototype.addRelRotationByEulerAngles = /** @inline */function (fYaw, fPitch, fRoll) {
                this.addRelRotation(akra.Quat4.fromYawPitchRoll(fYaw, fPitch, fRoll, Node._q4fTemp));
            };
            Node.prototype.addRelRotationByXYZAxis = /** @inline */function (fX, fY, fZ) {
                this.addRelRotation(akra.Quat4.fromYawPitchRoll(fY, fX, fZ, Node._q4fTemp));
            };
            Node.prototype.addRelRotation = function (q4fRotation) {
                this._qRotation.multiply(q4fRotation);
                ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_NewOrientation)));
            };
            Node.prototype.addRotationByMatrix = /** @inline */function (matrix) {
                this.addRotation(arguments[0].toQuat4(Node._q4fTemp));
            };
            Node.prototype.addRotationByAxisAngle = /** @inline */function (v3fAxis, fAngle) {
                this.addRotation(akra.Quat4.fromAxisAngle(v3fAxis, fAngle, Node._q4fTemp));
            };
            Node.prototype.addRotationByForwardUp = /** @inline */function (v3fForward, v3fUp) {
                this.addRotation(akra.Quat4.fromForwardUp(v3fForward, v3fUp, Node._q4fTemp));
            };
            Node.prototype.addRotationByEulerAngles = /** @inline */function (fYaw, fPitch, fRoll) {
                this.addRotation(akra.Quat4.fromYawPitchRoll(fYaw, fPitch, fRoll, Node._q4fTemp));
            };
            Node.prototype.addRotationByXYZAxis = /** @inline */function (fX, fY, fZ) {
                this.addRotation(akra.Quat4.fromYawPitchRoll(fY, fX, fZ, Node._q4fTemp));
            };
            Node.prototype.addRotation = function (q4fRotation) {
                q4fRotation.multiplyVec3(this._v3fTranslation);
                q4fRotation.multiply(this._qRotation, this._qRotation);
                ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_NewOrientation)));
            };
            Node.prototype.scale = function (fX, fY, fZ) {
                var pScale = arguments.length === 1 ? ((typeof (arguments[0]) === "number") ? akra.Vec3.stackCeil.set(fX) : arguments[0]) : akra.Vec3.stackCeil.set(fX, fY, fZ);
                var v3fScale = this._v3fScale;
                v3fScale.scale(pScale);
                ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_NewOrientation)));
            };
            Node.prototype.lookAt = function (v3f) {
                var v3fFrom, v3fCenter, v3fUp;
                this.update();
                if (arguments.length < 3) {
                    v3fFrom = ((this)._v3fWorldPosition);
                    v3fCenter = arguments[0];
                    v3fUp = arguments[1];
                } else {
                    v3fFrom = arguments[0];
                    v3fCenter = arguments[1];
                    v3fUp = arguments[2];
                }
                v3fUp = v3fUp || akra.Vec3.stackCeil.set(0., 1., 0.);
                var v3fParentPos = (((((this)._pParent)))._v3fWorldPosition);
                var m4fTemp = akra.Mat4.lookAt(v3fFrom, v3fCenter, v3fUp, akra.Mat4.stackCeil.set()).inverse();
                var pData = m4fTemp.data;
                switch(this._eInheritance) {
                    case akra.ENodeInheritance.ALL:
                        (this._pParent).inverseWorldMatrix.multiply(m4fTemp, m4fTemp);
                        m4fTemp.toQuat4(this._qRotation);
                        this.setPosition(pData[12], pData[13], pData[14]);
                        break;
                    case akra.ENodeInheritance.ROTSCALE:
                        var m3fTemp = m4fTemp.toMat3();
                        m3fTemp = (this._pParent).inverseWorldMatrix.toMat3().multiply(m3fTemp, akra.Mat3.stackCeil.set());
                        m3fTemp.toQuat4(this._qRotation);
                        this.setPosition(pData[12], pData[13], pData[14]);
                        break;
                    default:
                        m4fTemp.toQuat4(this._qRotation);
                        this.setPosition(pData[12] - v3fParentPos.x, pData[13] - v3fParentPos.y, pData[14] - v3fParentPos.z);
                }
                this.update();
            };
            Node.prototype.attachToParent = function (pParent) {
                if (_super.prototype.attachToParent.call(this, pParent)) {
                    // adjust my local matrix to be relative to this new parent
                    var m4fInvertedParentMatrix = akra.Mat4.stackCeil.set();
                    (this._pParent)._m4fWorldMatrix.inverse(m4fInvertedParentMatrix);
                    ((this._iUpdateFlags) |= (1 << (ENodeUpdateFlags.k_NewWorldMatrix)));
                    return true;
                }
                return false;
            };
            Node.prototype.detachFromParent = function () {
                if (_super.prototype.detachFromParent.call(this)) {
                    this._m4fWorldMatrix.identity();
                    return true;
                }
                return false;
            };
            Node.prototype.toString = function (isRecursive, iDepth) {
                if (typeof isRecursive === "undefined") { isRecursive = false; }
                if (typeof iDepth === "undefined") { iDepth = 0; }
                if (!isRecursive) {
                    return '<node' + (((this)._sName) ? " " + ((this)._sName) : "") + '>';
                }
                var pSibling = this.sibling;
                var pChild = ((this)._pChild);
                var s = "";
                for(var i = 0; i < iDepth; ++i) {
                    s += ':  ';
                }
                s += '+----[depth: ' + this.depth + ']' + this.toString() + '\n';
                /*"[updated: " + this.isUpdated() + ", childs updated: " + this.hasUpdatedSubNodes() + ", new wm: " + this.isWorldMatrixNew() + "]" +*/
                if (pChild) {
                    s += pChild.toString(true, iDepth + 1);
                }
                if (pSibling) {
                    s += pSibling.toString(true, iDepth);
                }
                return s;
            };
            Node._v3fTemp = new akra.Vec3();
            Node._v4fTemp = new akra.Vec4();
            Node._m3fTemp = new akra.Mat3();
            Node._m4fTemp = new akra.Mat4();
            Node._q4fTemp = new akra.Quat4();
            return Node;
        })(akra.util.Entity);
        scene.Node = Node;        
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        var SceneNode = (function (_super) {
            __extends(SceneNode, _super);
            function SceneNode(pScene, eType) {
                if (typeof eType === "undefined") { eType = akra.EEntityTypes.SCENE_NODE; }
                        _super.call(this, eType);
                /**@protected*/ this._pScene = null;
                /**@protected*/ this._pAnimationControllers = null;
                ((this)._pScene = (pScene));
            }
            Object.defineProperty(SceneNode.prototype, "scene", {
                get: /** @inline */function () {
                    return this._pScene;
                },
                set: /** @inline */function (pScene) {
                    this._pScene = pScene;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SceneNode.prototype, "totalControllers", {
                get: /** @inline */function () {
                    return this._pAnimationControllers ? this._pAnimationControllers.length : 0;
                },
                enumerable: true,
                configurable: true
            });
            SceneNode.prototype.getController = /** @inline */function (i) {
                if (typeof i === "undefined") { i = 0; }
                return ((this._pAnimationControllers) === null) || this._pAnimationControllers.length <= i ? null : this._pAnimationControllers[i];
            };
            SceneNode.prototype.addController = /** @inline */function (pController) {
                if (((this._pAnimationControllers) === null)) {
                    this._pAnimationControllers = [];
                }
                if (this._pAnimationControllers.indexOf(pController) != -1) {
                    return;
                }
                pController.attach(this);
                this._pAnimationControllers.push(pController);
            };
            SceneNode.prototype.create = function () {
                _super.prototype.create.call(this);
                this._m4fLocalMatrix = new akra.Mat4(1);
                this._m4fWorldMatrix = new akra.Mat4(1);
                this._m4fInverseWorldMatrix = new akra.Mat4(1);
                this._m3fNormalMatrix = new akra.Mat3(1);
                this._v3fWorldPosition = new akra.Vec3();
                this._v3fTranslation = new akra.Vec3(0);
                this._v3fScale = new akra.Vec3(1);
                this._qRotation = new akra.Quat4(0, 1);
                return true;
            };
            SceneNode.prototype.update = function () {
                var isOk = _super.prototype.update.call(this);
                if (!((this._pAnimationControllers) === null)) {
                    for(var i = 0; i < this._pAnimationControllers.length; ++i) {
                        this._pAnimationControllers[i].update();
                    }
                }
                return isOk;
            };
            SceneNode.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
            };
            SceneNode.prototype.attachToParent = function (pParent) {
                if ((pParent).scene !== this._pScene) {
 {
                        akra.logger.setSourceLocation("SceneNode.ts", 81);
                        akra.logger.warning("transfer of the scene node between trees scene - forbidden");
                    }
                    ;
                    return false;
                }
                return _super.prototype.attachToParent.call(this, pParent);
            };
            SceneNode.prototype.toString = function (isRecursive, iDepth) {
                if (typeof isRecursive === "undefined") { isRecursive = false; }
                if (typeof iDepth === "undefined") { iDepth = 0; }
                if (!isRecursive) {
                    return "<scene_node" + (((this)._sName) ? " " + ((this)._sName) : "") + ">";
                }
                return _super.prototype.toString.call(this, isRecursive, iDepth);
            };
            return SceneNode;
        })(scene.Node);
        scene.SceneNode = SceneNode;        
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        var Joint = (function (_super) {
            __extends(Joint, _super);
            // private _iUpdated: int = 0;
            // private _pEngine: IEngine = null;
            function Joint(pScene) {
                        _super.call(this, pScene, akra.EEntityTypes.JOINT);
                this._sBone = null;
            }
            Object.defineProperty(Joint.prototype, "boneName", {
                get: /** @inline */function () {
                    return this._sBone;
                },
                set: /** @inline */function (sBone) {
                    this._sBone = sBone;
                },
                enumerable: true,
                configurable: true
            });
            Joint.prototype.create = // getEngine(): IEngine {
            // 	return this._pEngine;
            // }
            function () {
                this._m4fLocalMatrix = new akra.Mat4(1);
                this._m4fWorldMatrix = new akra.Mat4(1);
                this._v3fWorldPosition = new akra.Vec3();
                this._v3fTranslation = new akra.Vec3(0, 0, 0);
                this._v3fScale = new akra.Vec3(1);
                this._qRotation = new akra.Quat4(0, 1);
                //maybe custom
                ((this)._eInheritance = (/*checked (origin: akra)>>*/akra.ENodeInheritance.ALL));
                return true;
            };
            Joint.prototype.toString = function (isRecursive, iDepth) {
                if (typeof isRecursive === "undefined") { isRecursive = false; }
                if (typeof iDepth === "undefined") { iDepth = 0; }
                isRecursive = isRecursive || false;
                if (!isRecursive) {
                    return "<joint" + (this._sName ? (' ' + this._sName) : "") + ">";
                }
                return scene.Node.prototype.toString.call(this, isRecursive, iDepth);
            };
            return Joint;
        })(scene.SceneNode);
        scene.Joint = Joint;        
        /** @inline */function isJoint(pEntity) {
            return pEntity.type == akra.EEntityTypes.JOINT;
        }
        scene.isJoint = isJoint;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (model) {
        var Skeleton = (function () {
            function Skeleton(sName) {
                if (typeof sName === "undefined") { sName = null; }
                this._pRootJoints = [];
                this._pJointMap = null;
                this._pNodeList = null;
                this._pMeshNode = null;
                this._iFlags = false;
                this._sName = sName;
            }
            Object.defineProperty(Skeleton.prototype, "totalBones", {
                get: /** @inline */function () {
                    return Object.keys(this._pJointMap).length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Skeleton.prototype, "totalNodes", {
                get: /** @inline */function () {
                    return this._pNodeList.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Skeleton.prototype, "name", {
                get: /** @inline */function () {
                    return this._sName;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Skeleton.prototype, "root", {
                get: /** @inline */function () {
                    return this._pRootJoints[0] || null;
                },
                enumerable: true,
                configurable: true
            });
            Skeleton.prototype.getRootJoint = /** @inline */function () {
                return ((this)._pRootJoints)[0];
            };
            Skeleton.prototype.getRootJoints = /** @inline */function () {
                return this._pRootJoints;
            };
            Skeleton.prototype.getJointMap = /** @inline */function () {
                return this._pJointMap;
            };
            Skeleton.prototype.getNodeList = /** @inline */function () {
                return this._pNodeList;
            };
            Skeleton.prototype.addRootJoint = function (pJoint) {
 {
                    akra.logger.setSourceLocation("model/Skeleton.ts", 56);
                    akra.logger.assert(pJoint instanceof akra.scene.Joint, 'node must be joint');
                }
                ;
                var pRootJoints = this._pRootJoints;
                for(var i = 0; i < pRootJoints.length; i++) {
                    if (pJoint.childOf(pRootJoints[i])) {
                        return false;
                    } else if (pRootJoints[i].childOf(pJoint)) {
                        pRootJoints.splice(i, 1);
                    }
                }
                ;
                this._pRootJoints.push(pJoint);
                return this.update();
            };
            Skeleton.prototype.update = function () {
                var pRootJoints = ((this)._pRootJoints);
                var pJointMap = this._pJointMap = {};
                var pNodeList = this._pNodeList = [];
                //var pNotificationJoints = this._pNotificationJoints = [];
                function findNodes(pNode) {
                    var sJoint = null;
                    if (!((pNode) === null)) {
                        if (((pNode).type == /*checked (origin: akra)>>*/akra.EEntityTypes.JOINT)) {
                            sJoint = (pNode).boneName;
                        }
                        if (!((sJoint) === null)) {
 {
                                akra.logger.setSourceLocation("model/Skeleton.ts", 90);
                                akra.logger.assert(!pJointMap[sJoint], 'joint with name<' + sJoint + '> already exists in skeleton <' + this._sName + '>');
                            }
                            ;
                            pJointMap[sJoint] = pNode;
                        }
                        pNodeList.push(pNode);
                        findNodes(pNode.sibling);
                        findNodes(pNode.child);
                    }
                }
                for(var i = 0; i < pRootJoints.length; i++) {
                    findNodes(pRootJoints[i]);
                }
                ;
                // for (var sJoint in pJointMap) {
                // 	var pJoint = pJointMap[sJoint];
                //    	if (pJoint.sibling() == null && pJoint.child() == null) {
                //    		pNotificationJoints.push(pJoint);
                //    	}
                //    };
                return true;
            };
            Skeleton.prototype.findJoint = function (sName) {
                return this._pJointMap[sName];
            };
            Skeleton.prototype.findJointByName = function (sName) {
                for(var s in this._pJointMap) {
                    if (this._pJointMap[s].name === sName) {
                        return this._pJointMap[s];
                    }
                }
                return null;
            };
            Skeleton.prototype.attachMesh = function (pMesh) {
                if (((((this)._pRootJoints[0] || null)) === null)) {
                    return false;
                }
                if (this._pMeshNode == null) {
                    this._pMeshNode = ((this)._pRootJoints[0] || null).scene.createModel();
                    this._pMeshNode.setInheritance(akra.ENodeInheritance.ALL);
                    this._pMeshNode.attachToParent(((this)._pRootJoints[0] || null));
                }
                this._pMeshNode.name = ((this)._sName) + "[mesh-container]";
                this._pMeshNode.mesh = (pMesh);
                return true;
            };
            Skeleton.prototype.detachMesh = function () {
                //TODO: write detach method.
                            };
            return Skeleton;
        })();        
        function createSkeleton(sName) {
            if (typeof sName === "undefined") { sName = null; }
            return new Skeleton(sName);
        }
        model.createSkeleton = createSkeleton;
    })(akra.model || (akra.model = {}));
    var model = akra.model;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    (function (EAnimationInterpolations) {
        EAnimationInterpolations._map = [];
        EAnimationInterpolations._map[0] = "MATRIX_LINEAR";
        EAnimationInterpolations.MATRIX_LINEAR = 0;
        EAnimationInterpolations._map[1] = "LINEAR";
        EAnimationInterpolations.LINEAR = 1;
    })(akra.EAnimationInterpolations || (akra.EAnimationInterpolations = {}));
    var EAnimationInterpolations = akra.EAnimationInterpolations;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (animation) {
        var Frame = (function () {
            function Frame(fTime, pMatrix, fWeight) {
                this.time = 0.0;
                this.weight = 1.0;
                this.matrix = null;
                this.rotation = new akra.Quat4();
                this.scale = new akra.Vec3();
                this.translation = new akra.Vec3();
                switch(arguments.length) {
                    case 0:
                        this.matrix = new akra.Mat4();
                        return;
                    case 3:
                        this.weight = fWeight;
                    case 2:
                        this.matrix = pMatrix;
                    case 1:
                        this.time = fTime;
                }
                ;
                this.matrix.decompose(this.rotation, this.scale, this.translation);
            }
            Frame.prototype.toMatrix = function () {
                return this.rotation.toMat4(this.matrix).setTranslation(this.translation).scaleRight(this.scale);
            };
            Frame.prototype.toMatrixFromMatrix = function () {
                return this.matrix;
            };
            Frame.prototype.reset = function () {
                this.weight = 0.0;
                this.time = 0.0;
                var pData = this.matrix.data;
                pData[0] = pData[4] = pData[8] = pData[12] = pData[1] = pData[5] = pData[9] = pData[13] = pData[2] = pData[6] = pData[10] = pData[14] = pData[3] = pData[7] = pData[11] = pData[15] = 0;
                this.rotation.x = this.rotation.y = this.rotation.z = 0;
                this.rotation.w = 1.0;
                this.translation.x = this.translation.y = this.translation.z = 0;
                this.scale.x = this.scale.y = this.scale.z = 0;
                return this;
            };
            Frame.prototype.set = function (pFrame) {
                //FIXME: расписать побыстрее
                this.matrix.set(pFrame.matrix);
                this.rotation.set(pFrame.rotation);
                this.scale.set(pFrame.scale);
                this.translation.set(pFrame.translation);
                this.time = pFrame.time;
                this.weight = pFrame.weight;
            };
            Frame.prototype.add = /**
            * Добавить данные к фрейму с их весом.
            * После данного метода фрейму потребуется нормализация!!!!
            */
            function (pFrame, isFirst) {
                var fWeight = pFrame.weight;
                this.scale.x += pFrame.scale.x * fWeight;
                this.scale.y += pFrame.scale.y * fWeight;
                this.scale.z += pFrame.scale.z * fWeight;
                this.translation.x += pFrame.translation.x * fWeight;
                this.translation.y += pFrame.translation.y * fWeight;
                this.translation.z += pFrame.translation.z * fWeight;
                this.weight += fWeight;
                if (!isFirst) {
                    this.rotation.smix(pFrame.rotation, fWeight / this.weight);
                } else {
                    this.rotation.set(pFrame.rotation);
                }
                return this;
            };
            Frame.prototype.addMatrix = function (pFrame) {
                var pMatData = pFrame.matrix.data;
                var fWeight = pFrame.weight;
                var pResData = this.matrix.data;
                for(var i = 0; i < 16; ++i) {
                    pResData[i] += pMatData[i] * fWeight;
                }
                this.weight += fWeight;
                return this;
            };
            Frame.prototype.mult = function (fScalar) {
                this.weight *= fScalar;
                return this;
            };
            Frame.prototype.normilize = function () {
                var fScalar = 1.0 / this.weight;
                this.scale.x *= fScalar;
                this.scale.y *= fScalar;
                this.scale.z *= fScalar;
                this.translation.x *= fScalar;
                this.translation.y *= fScalar;
                this.translation.z *= fScalar;
                return this;
            };
            Frame.prototype.normilizeMatrix = function () {
                var fScalar = 1.0 / this.weight;
                var pData = this.matrix.data;
                pData[0] *= fScalar;
                pData[4] *= fScalar;
                pData[8] *= fScalar;
                pData[12] *= fScalar;
                pData[1] *= fScalar;
                pData[5] *= fScalar;
                pData[9] *= fScalar;
                pData[13] *= fScalar;
                pData[2] *= fScalar;
                pData[6] *= fScalar;
                pData[10] *= fScalar;
                pData[14] *= fScalar;
                pData[3] *= fScalar;
                pData[7] *= fScalar;
                pData[11] *= fScalar;
                pData[15] *= fScalar;
                return this;
            };
            Frame.prototype.interpolate = function (pStartFrame, pEndFrame, fBlend) {
                // var pResultData = this.matrix.data;
                // var pStartData = pStartFrame.matrix.data;
                // var pEndData = pEndFrame.matrix.data;
                // var fBlendInv = 1. - fBlend;
                // for (var i = 0; i < 16; i++) {
                // 	pResultData[i] = pEndData[i] * fBlend + pStartData[i] * fBlendInv;
                // };
                pStartFrame.translation.mix(pEndFrame.translation, fBlend, this.translation);
                pStartFrame.scale.mix(pEndFrame.scale, fBlend, this.scale);
                pStartFrame.rotation.smix(pEndFrame.rotation, fBlend, this.rotation);
            };
            Frame.prototype.interpolateMatrix = function (pStartFrame, pEndFrame, fBlend) {
                var pResultData = this.matrix.data;
                var pStartData = pStartFrame.matrix.data;
                var pEndData = pEndFrame.matrix.data;
                var fBlendInv = 1. - fBlend;
                for(var i = 0; i < 16; i++) {
                    pResultData[i] = pEndData[i] * fBlend + pStartData[i] * fBlendInv;
                }
                ;
            };
            Object.defineProperty(Frame, "stackCeil", {
                get: function () {
                    Frame.stackPosition = Frame.stackPosition === Frame.stackSize - 1 ? 0 : Frame.stackPosition;
                    return Frame.stack[Frame.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            Frame.stackSize = 4 * 4096;
            Frame.stackPosition = 0;
            Frame.stack = (function () {
                var pStack = new Array(Frame.stackSize);
                for(var i = 0; i < Frame.stackSize; i++) {
                    pStack[i] = new Frame();
                }
                return pStack;
            })();
            return Frame;
        })();
        animation.Frame = Frame;        
        /** @inline */function animationFrame() {
            return Frame.stackCeil;
        }
        animation.animationFrame = animationFrame;
        function createFrame(fTime, pMatrix, fWeight) {
            if (typeof fTime === "undefined") { fTime = 0.0; }
            if (typeof pMatrix === "undefined") { pMatrix = null; }
            if (typeof fWeight === "undefined") { fWeight = 1.0; }
            return new Frame(fTime, pMatrix, fWeight);
        }
        animation.createFrame = createFrame;
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (animation) {
        var Track = (function () {
            function Track(sTarget) {
                if (typeof sTarget === "undefined") { sTarget = null; }
                this._sTarget = null;
                this._pTarget = null;
                this._pKeyFrames = [];
                this._eInterpolationType = akra.EAnimationInterpolations.MATRIX_LINEAR;
                this._sTarget = sTarget;
            }
            Object.defineProperty(Track.prototype, "totalFrames", {
                get: /** @inline */function () {
                    return this._pKeyFrames.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Track.prototype, "target", {
                get: /** @inline */function () {
                    return this._pTarget;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Track.prototype, "targetName", {
                get: /** @inline */function () {
                    return this._sTarget;
                },
                set: /** @inline */function (sValue) {
                    this._sTarget = sValue;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Track.prototype, "duration", {
                get: /** @inline */function () {
                    return ((this._pKeyFrames.last)).time;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Track.prototype, "first", {
                get: /** @inline */function () {
                    return ((this._pKeyFrames.first)).time;
                },
                enumerable: true,
                configurable: true
            });
            Track.prototype.keyFrame = function (fTime, pMatrix) {
                var pFrame;
                var iFrame;
                var pKeyFrames = this._pKeyFrames;
                var nTotalFrames = pKeyFrames.length;
                if (arguments.length > 1) {
                    pFrame = animation.createFrame(fTime, pMatrix);
                } else {
                    pFrame = arguments[0];
                }
                if (nTotalFrames && (iFrame = this.findKeyFrame(pFrame.time)) >= 0) {
                    pKeyFrames.splice(iFrame, 0, pFrame);
                } else {
                    pKeyFrames.push(pFrame);
                }
                return true;
            };
            Track.prototype.getKeyFrame = function (iFrame) {
 {
                    akra.logger.setSourceLocation("animation/Track.ts", 76);
                    akra.logger.assert(iFrame < ((this)._pKeyFrames.length), 'iFrame must be less then number of total jey frames.');
                }
                ;
                return this._pKeyFrames[iFrame];
            };
            Track.prototype.findKeyFrame = function (fTime) {
                var pKeyFrames = this._pKeyFrames;
                var nTotalFrames = pKeyFrames.length;
                if (pKeyFrames[nTotalFrames - 1].time == fTime) {
                    return nTotalFrames - 1;
                } else {
                    for(var i = nTotalFrames - 1; i >= 0; i--) {
                        if (pKeyFrames[i].time > fTime && pKeyFrames[i - 1].time <= fTime) {
                            return i - 1;
                        }
                    }
                }
                return -1;
            };
            Track.prototype.bind = function (pJoint, pSkeleton) {
                var pNode = null, pRootNode;
                var sJoint;
                switch(arguments.length) {
                    case 2:
                        //bind by pair <String joint, Skeleton skeleton>
                        sJoint = pJoint;
                        this._sTarget = sJoint;
                        pNode = (pSkeleton).findJoint(sJoint);
                        break;
                    default:
                        //bind by <Skeleton skeleton>
                        if (!((arguments[0].type) !== undefined)) {
                            if (this._sTarget == null) {
                                return false;
                            }
                            pSkeleton = arguments[0];
                            pNode = (pSkeleton).findJoint(this._sTarget);
                        } else//bind by <Node node>
                         {
                            pRootNode = arguments[0];
                            pNode = pRootNode.findEntity(((this)._sTarget));
                        }
                }
                this._pTarget = pNode;
                return ((pNode) != null);
            };
            Track.prototype.frame = function (fTime) {
                var iKey1 = 0, iKey2 = 0;
                var fScalar;
                var fTimeDiff;
                var pKeys = this._pKeyFrames;
                var nKeys = pKeys.length;
                var pFrame = (/*checked (origin: animation)>>*/akra.animation.Frame.stackCeil);
 {
                    akra.logger.setSourceLocation("animation/Track.ts", 148);
                    akra.logger.assert(nKeys > 0, 'no frames :(');
                }
                ;
                if (nKeys === 1) {
                    pFrame.set(pKeys[0]);
                } else {
                    //TODO: реализовать существенно более эффективный поиск кадра.
                    for(var i = 0; i < nKeys; i++) {
                        if (fTime >= this._pKeyFrames[i].time) {
                            iKey1 = i;
                        }
                    }
                    iKey2 = (iKey1 >= (nKeys - 1)) ? iKey1 : iKey1 + 1;
                    fTimeDiff = pKeys[iKey2].time - pKeys[iKey1].time;
                    if (!fTimeDiff) {
                        fTimeDiff = 1;
                    }
                    fScalar = (fTime - pKeys[iKey1].time) / fTimeDiff;
                    pFrame.interpolate(this._pKeyFrames[iKey1], this._pKeyFrames[iKey2], fScalar);
                }
                pFrame.time = fTime;
                pFrame.weight = 1.0;
                return pFrame;
            };
            Track.prototype.toString = function () {
                var s = "target: " + ((this)._sTarget) + ", from: " + this._pKeyFrames[0].time + "sec. , duration: " + ((((this)._pKeyFrames.last)).time) + " sec. , frames: " + ((this)._pKeyFrames.length);
                return s;
            };
            return Track;
        })();        
        function createTrack(sTarget) {
            if (typeof sTarget === "undefined") { sTarget = null; }
            return new Track(sTarget);
        }
        animation.createTrack = createTrack;
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    (function (EAnimationTypes) {
        EAnimationTypes._map = [];
        EAnimationTypes._map[0] = "ANIMATION";
        EAnimationTypes.ANIMATION = 0;
        EAnimationTypes._map[1] = "LIST";
        EAnimationTypes.LIST = 1;
        EAnimationTypes._map[2] = "CLIP";
        EAnimationTypes.CLIP = 2;
        EAnimationTypes._map[3] = "CONTAINER";
        EAnimationTypes.CONTAINER = 3;
        EAnimationTypes._map[4] = "BLEND";
        EAnimationTypes.BLEND = 4;
    })(akra.EAnimationTypes || (akra.EAnimationTypes = {}));
    var EAnimationTypes = akra.EAnimationTypes;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (animation) {
        var Base = (function () {
            function Base(eType, sName) {
                if (typeof sName === "undefined") { sName = null; }
                /**@protected*/ this._pTargetMap = {};
                /**@protected*/ this._pTargetList = [];
                /**@protected*/ this._fDuration = 0.0;
                //first ever frame time of all targets
                /**@protected*/ this._fFirst = akra.MAX_UINT32;
                this.extra = null;
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
                this._sName = sName || ("animation-" + "-" + ((this)._iGuid));
                this._eType = eType;
            }
            Object.defineProperty(Base.prototype, "type", {
                get: /** @inline */function () {
                    return this._eType;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Base.prototype, "duration", {
                get: /** @inline */function () {
                    return this._fDuration;
                },
                set: /** @inline */function (fValue) {
                    // LOG("new duration(", this.name, ") > " + fValue);
                    this._fDuration = fValue;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Base.prototype, "first", {
                get: /** @inline */function () {
                    return this._fFirst;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Base.prototype, "name", {
                get: /** @inline */function () {
                    return this._sName;
                },
                set: /** @inline */function (sName) {
                    if (sName == this._sName) {
                        return;
                    }
                    this._sName = sName;
                    this.renamed(sName);
                },
                enumerable: true,
                configurable: true
            });
            Base.prototype.play = /** @inline */function (fRealTime) {
                this.played(fRealTime);
            };
            Base.prototype.stop = /** @inline */function (fRealTime) {
                this.stoped(fRealTime);
            };
            Base.prototype.isAttached = /** @inline */function () {
                if (this._pTargetList.length) {
                    return ((this._pTargetList[0].target) != null);
                }
                return false;
            };
            Base.prototype.attach = function (pTarget) {
 {
                    akra.logger.setSourceLocation("Base.ts", 83);
                    akra.logger.error("method AnimationBase::attach() must be overwritten.");
                }
                ;
            };
            Base.prototype.frame = function (sName, fRealTime) {
                return null;
            };
            Base.prototype.apply = function (fRealTime) {
                var pTargetList = this._pTargetList;
                var pTarget = null;
                var pFrame = null;
                var pTransform = null;
                var bAffected = false;
                for(var i = 0; i < pTargetList.length; ++i) {
                    pFrame = this.frame(pTargetList[i].name, fRealTime);
                    pTarget = pTargetList[i].target;
                    if (!pFrame || !pTarget) {
                        continue;
                    }
                    pTransform = pFrame.toMatrix();
                    pTarget.localMatrix = pTransform;
                    bAffected = true;
                }
                // console.log(bAffected);
                return bAffected;
            };
            Base.prototype.addTarget = function (sName, pTarget) {
                if (typeof pTarget === "undefined") { pTarget = null; }
                //pTarget = pTarget || null;
                var pPointer = this._pTargetMap[sName];
                if (pPointer) {
                    pPointer.target = pTarget || pPointer.target || null;
                    return pPointer;
                }
                pPointer = {
                    target: pTarget,
                    index: this._pTargetList.length,
                    name: sName
                };
                this._pTargetList.push(pPointer);
                this._pTargetMap[sName] = pPointer;
                return pPointer;
            };
            Base.prototype.setTarget = function (sName, pTarget) {
                var pPointer = this._pTargetMap[sName];
                pPointer.target = pTarget;
                return pPointer;
            };
            Base.prototype.getTarget = function (sTargetName) {
                return this._pTargetMap[sTargetName];
            };
            Base.prototype.getTargetList = /** @inline */function () {
                return this._pTargetList;
            };
            Base.prototype.getTargetByName = /** @inline */function (sName) {
                return this._pTargetMap[sName];
            };
            Base.prototype.targetNames = function () {
                var pTargets = this._pTargetList;
                var pTargetNames = [];
                for(var i = 0; i < pTargets.length; ++i) {
                    pTargetNames.push(pTargets[i].name);
                }
                return pTargetNames;
            };
            Base.prototype.targetList = function () {
                var pTargets = this._pTargetList;
                var pTargetList = [];
                for(var i = 0; i < pTargets.length; ++i) {
                    pTargetList.push(pTargets[i].target);
                }
                return pTargetList;
            };
            Base.prototype.jointList = function () {
                var pTargets = this._pTargetList;
                var pJointList = [];
                for(var i = 0; i < pTargets.length; ++i) {
                    if (((pTargets[i].target).type == /*checked (origin: akra)>>*/akra.EEntityTypes.JOINT)) {
                        pJointList.push(pTargets[i].target);
                    }
                }
                return pJointList;
            };
            Base.prototype.grab = function (pAnimationBase, bRewrite) {
                if (typeof bRewrite === "undefined") { bRewrite = true; }
                var pAdoptTargets = pAnimationBase.getTargetList();
                for(var i = 0; i < pAdoptTargets.length; ++i) {
                    if (!pAdoptTargets[i].target) {
                        //warning('cannot grab target <' + pAdoptTargets[i].name + '>, becaus "target" is null');
                        continue;
                    }
                    if (bRewrite || !this.getTarget(pAdoptTargets[i].name)) {
                        this.addTarget(pAdoptTargets[i].name, pAdoptTargets[i].target);
                    }
                }
                this._fFirst = akra.math.min(((this)._fFirst), pAnimationBase.first);
            };
            Base.prototype.createAnimationMask = function () {
                var pTargets = this.targetNames();
                var pMask = {};
                for(var i = 0; i < pTargets.length; ++i) {
                    pMask[pTargets[i]] = 1.0;
                }
                return pMask;
            };
            Base.prototype.toString = function () {
                var s = "\n";
                s += "name         : " + ((this)._sName) + "\n";
                s += "duration     : " + ((this)._fDuration) + " sec\n";
                s += "total targets: " + this.targetList().length.toString() + "\n";
                return s;
            };
            Base.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            Base._pEventTable = new akra.events.EventTable();
            Base.prototype.getEventTable = /** @inline */function () {
                return Base._pEventTable;
            };
            Base.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Base.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Base.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (Base._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Base.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (Base._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Base.prototype._syncTable = /** @inline */function (pFrom) {
                (Base._pEventTable)._sync(this, pFrom);
            };
            Base.prototype.played = function (fRealTime) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Base._pEventTable))).broadcast[(this._iGuid)] = (((Base._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).played;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, fRealTime) : _broadcast[i].listener(_recivier, fRealTime);
                    }
                }
            };
            Base.prototype.stoped = function (fRealTime) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Base._pEventTable))).broadcast[(this._iGuid)] = (((Base._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).stoped;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, fRealTime) : _broadcast[i].listener(_recivier, fRealTime);
                    }
                }
            };
            Base.prototype.renamed = function (sName) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Base._pEventTable))).broadcast[(this._iGuid)] = (((Base._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).renamed;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, sName) : _broadcast[i].listener(_recivier, sName);
                    }
                }
            };
            return Base;
        })();
        animation.Base = Base;        
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (animation) {
        var Animation = (function (_super) {
            __extends(Animation, _super);
            function Animation(sName) {
                        _super.call(this, akra.EAnimationTypes.ANIMATION, sName);
                this._pTracks = [];
            }
            Object.defineProperty(Animation.prototype, "totalTracks", {
                get: /** @inline */function () {
                    return this._pTracks.length;
                },
                enumerable: true,
                configurable: true
            });
            Animation.prototype.push = function (pTrack) {
                this._pTracks.push(pTrack);
                this._fDuration = akra.math.max(this._fDuration, pTrack.duration);
                this._fFirst = akra.math.min(((this)._fFirst), pTrack.first);
                this.addTarget(pTrack.targetName);
            };
            Animation.prototype.attach = function (pTarget) {
                var pPointer;
                var pTracks = this._pTracks;
                for(var i = 0; i < pTracks.length; ++i) {
                    if (!pTracks[i].bind(pTarget)) {
 {
                            akra.logger.setSourceLocation("animation/Animation.ts", 36);
                            akra.logger.log("cannot bind animation track [", i, "] to joint <", pTracks[i].target, ">");
                        }
                        ;
                    } else {
                        pPointer = this.setTarget(pTracks[i].targetName, pTracks[i].target);
                        pPointer.track = pTracks[i];
                    }
                }
            };
            Animation.prototype.getTracks = /** @inline */function () {
                return this._pTracks;
            };
            Animation.prototype.getTrack = /** @inline */function (i) {
                return this._pTracks[i];
            };
            Animation.prototype.frame = function (sName, fTime) {
                var pPointer = ((this)._pTargetMap[(sName)]);
                if (!pPointer || !pPointer.track) {
                    return null;
                }
                return pPointer.track.frame((/*checked (origin: math)>>*/akra.math.max((0), /*checked (origin: math)>>*/akra.math.min((fTime), (this._fDuration)))));
            };
            Animation.prototype.extend = function (pAnimation) {
                var pTracks = pAnimation.getTracks();
                for(var i = 0; i < pTracks.length; ++i) {
                    if (!this.getTarget(pTracks[i].targetName)) {
                        this.push(pTracks[i]);
                    }
                }
            };
            Animation.prototype.toString = function () {
                var s = _super.prototype.toString.call(this);
                s += "total tracks : " + ((this)._pTracks.length) + "\n";
                for(var i = 0; i < ((this)._pTracks.length); ++i) {
                    s += "\t" + i + ". " + ((this)._pTracks[(i)]) + "\n";
                }
                return s;
            };
            return Animation;
        })(animation.Base);        
        /** @inline */function isAnimation(pAnimation) {
            return pAnimation.type === akra.EAnimationTypes.ANIMATION;
        }
        animation.isAnimation = isAnimation;
        function createAnimation(sName) {
            return new Animation(sName);
        }
        animation.createAnimation = createAnimation;
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (animation) {
        var Container = (function (_super) {
            __extends(Container, _super);
            function Container(pAnimation, sName) {
                        _super.call(this, akra.EAnimationTypes.CONTAINER, sName);
                this._bEnable = true;
                this._fStartTime = 0;
                this._fSpeed = 1.0;
                this._bLoop = false;
                this._pAnimation = null;
                this._bReverse = false;
                //Время учитывающее циклы и прочее.
                this._fTrueTime = 0;
                //реальное время на сцене
                this._fRealTime = 0;
                //время с учетом ускорений
                this._fTime = 0;
                this._bPause = false;
                //определена ли анимация до первого и после последнего кадров
                this._bLeftInfinity = true;
                this._bRightInfinity = true;
                if (pAnimation) {
                    this.setAnimation(pAnimation);
                }
            }
            Object.defineProperty(Container.prototype, "animationName", {
                get: /** @inline */function () {
                    return this._pAnimation.name;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Container.prototype, "speed", {
                get: /** @inline */function () {
                    return this._fSpeed;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Container.prototype, "animationTime", {
                get: /** @inline */function () {
                    return this._fTrueTime;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Container.prototype, "time", {
                get: /** @inline */function () {
                    return this._fTime;
                },
                enumerable: true,
                configurable: true
            });
            Container.prototype.play = function (fRealTime) {
                this._fRealTime = fRealTime;
                this._fTime = 0;
                this.played(this._fTime);
            };
            Container.prototype.stop = /** @inline */function () {
                this.stoped(this._fTime);
            };
            Container.prototype.attach = function (pTarget) {
                if (!((this._pAnimation) === null)) {
                    this._pAnimation.attach(pTarget);
                    this.grab(this._pAnimation, true);
                }
            };
            Container.prototype.setAnimation = function (pAnimation) {
 {
                    akra.logger.setSourceLocation("Container.ts", 75);
                    akra.logger.assert(!this._pAnimation, "anim. already exists");
                }
                ;
                this._pAnimation = pAnimation;
                this.setSpeed(((this)._fSpeed));
                ((pAnimation).getEventTable().addDestination(((((pAnimation)))._iGuid), ("durationUpdated"), (this), ("_onDurationUpdate"), (undefined)));
                this.grab(pAnimation);
            };
            Container.prototype._onDurationUpdate = function (pAnimation, fDuration) {
                this.setSpeed(((this)._fSpeed));
            };
            Container.prototype.getAnimation = function () {
                return this._pAnimation;
            };
            Container.prototype.enable = /** @inline */function () {
                this._bEnable = true;
            };
            Container.prototype.disable = /** @inline */function () {
                this._bEnable = false;
            };
            Container.prototype.isEnabled = /** @inline */function () {
                return this._bEnable;
            };
            Container.prototype.leftInfinity = /** @inline */function (bValue) {
                this._bLeftInfinity = bValue;
            };
            Container.prototype.inLeftInfinity = /** @inline */function () {
                return this._bLeftInfinity;
            };
            Container.prototype.inRightInfinity = /** @inline */function () {
                return this._bRightInfinity;
            };
            Container.prototype.rightInfinity = /** @inline */function (bValue) {
                this._bRightInfinity = bValue;
            };
            Container.prototype.setStartTime = /** @inline */function (fRealTime) {
                this._fStartTime = fRealTime;
            };
            Container.prototype.getStartTime = /** @inline */function () {
                return this._fStartTime;
            };
            Container.prototype.setSpeed = function (fSpeed) {
                this._fSpeed = fSpeed;
                (// LOG("new duration(", this.name, ") > " + fValue);
(this)._fDuration = (this._pAnimation.duration / fSpeed));
                this.durationUpdated(this.duration);
            };
            Container.prototype.getSpeed = /** @inline */function () {
                return this._fSpeed;
            };
            Container.prototype.useLoop = /** @inline */function (bValue) {
                this._bLoop = bValue;
            };
            Container.prototype.inLoop = /** @inline */function () {
                return this._bLoop;
            };
            Container.prototype.reverse = /** @inline */function (bValue) {
                this._bReverse = bValue;
            };
            Container.prototype.isReversed = /** @inline */function () {
                return this._bReverse;
            };
            Container.prototype.pause = function (bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                this._fRealTime = -1;
                this._bPause = bValue;
            };
            Container.prototype.rewind = /** @inline */function (fRealTime) {
                this._fTime = fRealTime;
            };
            Container.prototype.isPaused = /** @inline */function () {
                return this._bPause;
            };
            Container.prototype.calcTime = /**@protected*/ function (fRealTime) {
                if (this._bPause) {
                    return;
                }
                if (this._fRealTime < 0) {
                    this._fRealTime = fRealTime;
                }
                this._fTime = this._fTime + (fRealTime - this._fRealTime) * this._fSpeed;
                this._fRealTime = fRealTime;
                var fTime = this._fTime;
                if (this._bLoop) {
                    fTime = (((fTime) - /*checked (origin: math)>>*/akra.math.floor((fTime) / ((this._pAnimation.duration))) * ((this._pAnimation.duration))));
                    if (this._bReverse) {
                        fTime = this._pAnimation.duration - fTime;
                    }
                }
                this._fTrueTime = fTime;
            };
            Container.prototype.frame = function (sName, fRealTime) {
                if (!this._bEnable) {
                    return null;
                }
                if (this._fRealTime !== fRealTime) {
                    //only for first bone in list
                    this.calcTime(fRealTime);
                    this.enterFrame(fRealTime, this._fTrueTime);
                }
                if (!this._bLeftInfinity && this._fTrueTime < ((this)._fFirst)) {
                    return null;
                }
                if (!this._bRightInfinity && this._fTrueTime > this.duration) {
                    return null;
                }
                return this._pAnimation.frame(sName, this._fTrueTime);
            };
            Container.prototype.durationUpdated = function (fDuration) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((/*checked (origin: animation)>>*/akra.animation.Base._pEventTable))).broadcast[(this._iGuid)] = (((/*checked (origin: animation)>>*/akra.animation.Base._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).durationUpdated;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, fDuration) : _broadcast[i].listener(_recivier, fDuration);
                    }
                }
            };
            Container.prototype.enterFrame = function (fRealTime, fTime) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((/*checked (origin: animation)>>*/akra.animation.Base._pEventTable))).broadcast[(this._iGuid)] = (((/*checked (origin: animation)>>*/akra.animation.Base._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).enterFrame;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, fRealTime, fTime) : _broadcast[i].listener(_recivier, fRealTime, fTime);
                    }
                }
            };
            return Container;
        })(animation.Base);
        animation.Container = Container;        
        /** @inline */function isContainer(pAnimation) {
            return pAnimation.type === akra.EAnimationTypes.CONTAINER;
        }
        animation.isContainer = isContainer;
        function createContainer(pAnimation, sName) {
            return new Container(pAnimation, sName);
        }
        animation.createContainer = createContainer;
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (animation) {
        var Blend = (function (_super) {
            __extends(Blend, _super);
            function Blend(sName) {
                        _super.call(this, akra.EAnimationTypes.BLEND, sName);
                this.duration = 0;
                this._pAnimationList = [];
            }
            Object.defineProperty(Blend.prototype, "totalAnimations", {
                get: /** @inline */function () {
                    return this._pAnimationList.length;
                },
                enumerable: true,
                configurable: true
            });
            Blend.prototype.play = function (fRealTime) {
                var pAnimationList = this._pAnimationList;
                var n = pAnimationList.length;
                for(var i = 0; i < n; ++i) {
                    pAnimationList[i].realTime = fRealTime;
                    pAnimationList[i].time = fRealTime * pAnimationList[i].acceleration;
                }
                this.played(fRealTime);
            };
            Blend.prototype.stop = function () {
                this.stoped(0.);
            };
            Blend.prototype.attach = function (pTarget) {
                var pAnimationList = this._pAnimationList;
                for(var i = 0; i < pAnimationList.length; ++i) {
                    var pAnim = pAnimationList[i].animation;
                    pAnim.attach(pTarget);
                    this.grab(pAnim, true);
                }
            };
            Blend.prototype.addAnimation = function (pAnimation, fWeight, pMask) {
 {
                    akra.logger.setSourceLocation("Blend.ts", 51);
                    akra.logger.assert(((pAnimation) !== undefined), 'animation must be setted.');
                }
                ;
                this._pAnimationList.push(null);
                return this.setAnimation(this._pAnimationList.length - 1, pAnimation, fWeight, pMask);
            };
            Blend.prototype.setAnimation = function (iAnimation, pAnimation, fWeight, pMask) {
                if (typeof fWeight === "undefined") { fWeight = 1.0; }
                if (typeof pMask === "undefined") { pMask = null; }
 {
                    akra.logger.setSourceLocation("Blend.ts", 59);
                    akra.logger.assert(iAnimation <= this._pAnimationList.length, 'invalid animation slot: ' + iAnimation + '/' + this._pAnimationList.length);
                }
                ;
                var pPointer = this._pAnimationList[iAnimation];
                var pAnimationList = this._pAnimationList;
                if (!pAnimation) {
                    pAnimationList[iAnimation] = null;
                    return iAnimation;
                }
                if (!pPointer) {
                    pPointer = {
                        animation: pAnimation,
                        weight: fWeight,
                        mask: pMask,
                        acceleration: 1.0,
                        time: 0.0,
                        realTime: 0.0
                    };
                    ((pAnimation).getEventTable().addDestination(((((pAnimation)))._iGuid), ("durationUpdated"), (this), ("_onDurationUpdate"), (undefined)));
                    if (iAnimation == this._pAnimationList.length) {
                        pAnimationList.push(pPointer);
                    } else {
                        pAnimationList[iAnimation] = pPointer;
                    }
                }
                this.grab(pAnimation);
                this.updateDuration();
                return iAnimation;
            };
            Blend.prototype._onDurationUpdate = function (pAnimation, fDuration) {
                this.updateDuration();
            };
            Blend.prototype.updateDuration = /**@protected*/ function () {
                var fWeight = 0;
                var fSumm = 0;
                var pAnimationList = this._pAnimationList;
                var n = pAnimationList.length;
                for(var i = 0; i < n; ++i) {
                    if (pAnimationList[i] === null) {
                        continue;
                    }
                    fSumm += pAnimationList[i].weight * pAnimationList[i].animation.duration;
                    fWeight += pAnimationList[i].weight;
                }
                if (fWeight === 0) {
                    this.duration = 0;
                } else {
                    this.duration = fSumm / fWeight;
                    for(var i = 0; i < n; ++i) {
                        if (pAnimationList[i] === null) {
                            continue;
                        }
                        pAnimationList[i].acceleration = pAnimationList[i].animation.duration / this.duration;
                        //trace(pAnimationList[i].animation.name, '> acceleration > ', pAnimationList[i].acceleration);
                                            }
                }
                this.durationUpdated(this.duration);
            };
            Blend.prototype.getAnimationIndex = function (sName) {
                var pAnimationList = this._pAnimationList;
                for(var i = 0; i < pAnimationList.length; i++) {
                    if (pAnimationList[i].animation.name === sName) {
                        return i;
                    }
                }
                ;
                return -1;
            };
            Blend.prototype.getAnimation = function (animation) {
                var iAnimation = (typeof (animation) === "string") ? this.getAnimationIndex(animation) : animation;
                return this._pAnimationList[iAnimation].animation;
            };
            Blend.prototype.getAnimationWeight = function (animation) {
                var iAnimation = animation;
                if ((typeof (animation) === "string")) {
                    iAnimation = this.getAnimationIndex(animation);
                }
                return this._pAnimationList[iAnimation].weight;
            };
            Blend.prototype.setWeights = function () {
                var pWeight = [];
                for (var _i = 0; _i < (arguments.length - 0); _i++) {
                    pWeight[_i] = arguments[_i + 0];
                }
                var fWeight;
                var isModified = false;
                var pAnimationList = this._pAnimationList;
                for(var i = 0; i < arguments.length; ++i) {
                    fWeight = arguments[i];
                    if (fWeight < 0 || fWeight === null || !pAnimationList[i]) {
                        continue;
                    }
                    if (pAnimationList[i].weight !== fWeight) {
                        pAnimationList[i].weight = fWeight;
                        isModified = true;
                    }
                }
                if (isModified) {
                    this.updateDuration();
                }
                return true;
            };
            Blend.prototype.setWeightSwitching = function (fWeight, iAnimationFrom, iAnimationTo) {
                var pAnimationList = this._pAnimationList;
                var isModified = false;
                var fWeightInv = 1. - fWeight;
                if (!pAnimationList[iAnimationFrom] || !pAnimationList[iAnimationTo]) {
                    return false;
                }
                if (pAnimationList[iAnimationFrom].weight !== fWeightInv) {
                    pAnimationList[iAnimationFrom].weight = fWeightInv;
                    isModified = true;
                }
                if (pAnimationList[iAnimationTo].weight !== fWeight) {
                    pAnimationList[iAnimationTo].weight = fWeight;
                    isModified = true;
                }
                if (isModified) {
                    this.updateDuration();
                }
                return true;
            };
            Blend.prototype.setAnimationWeight = function (animation, fWeight) {
                var pAnimationList = this._pAnimationList;
                if (arguments.length === 1) {
                    fWeight = arguments[0];
                    for(var i = 0; i < pAnimationList.length; i++) {
                        pAnimationList[i].weight = fWeight;
                        this.weightUpdated(i, fWeight);
                    }
                    this.updateDuration();
                } else {
                    var iAnimation = (typeof (animation) === "string") ? this.getAnimationIndex(animation) : animation;
                    //trace('set weight for animation: ', iAnimation, 'to ', fWeight);
                    if (pAnimationList[iAnimation].weight !== fWeight) {
                        pAnimationList[iAnimation].weight = fWeight;
                        this.updateDuration();
                        this.weightUpdated(iAnimation, fWeight);
                    }
                }
                return true;
            };
            Blend.prototype.setAnimationMask = function (animation, pMask) {
                var iAnimation = (typeof (animation) === "string") ? this.getAnimationIndex(animation) : animation;
                this._pAnimationList[iAnimation].mask = pMask;
                return true;
            };
            Blend.prototype.getAnimationMask = function (animation) {
                var iAnimation = (typeof (animation) === "string") ? this.getAnimationIndex(animation) : animation;
                return this._pAnimationList[iAnimation].mask;
            };
            Blend.prototype.getAnimationAcceleration = function (animation) {
                var iAnimation = (typeof (animation) === "string") ? this.getAnimationIndex(animation) : animation;
                return this._pAnimationList[iAnimation].acceleration;
            };
            Blend.prototype.createAnimationMask = function (iAnimation) {
                if (arguments.length === 0) {
                    return _super.prototype.createAnimationMask.call(this);
                }
                if (typeof arguments[0] === 'string') {
                    iAnimation = this.getAnimationIndex(arguments[0]);
                }
                var pAnimation = this._pAnimationList[iAnimation].animation;
                return pAnimation.createAnimationMask();
            };
            Blend.prototype.frame = function (sName, fRealTime) {
                var pAnimationList = this._pAnimationList;
                var pResultFrame = (/*checked (origin: animation)>>*/akra.animation.Frame.stackCeil).reset();
                var pFrame;
                var pMask;
                var pPointer;
                var fAcceleration;
                var fBoneWeight;
                var fWeight;
                var iAnim = 0;
                for(var i = 0; i < pAnimationList.length; i++) {
                    pPointer = pAnimationList[i];
                    if (!pPointer) {
                        continue;
                    }
                    fAcceleration = pPointer.acceleration;
                    pMask = pPointer.mask;
                    fBoneWeight = 1.0;
                    pPointer.time = pPointer.time + (fRealTime - pPointer.realTime) * fAcceleration;
                    pPointer.realTime = fRealTime;
                    if (pMask) {
                        fBoneWeight = ((pMask[sName]) !== undefined) ? pMask[sName] : 1.0;
                    }
                    fWeight = fBoneWeight * pPointer.weight;
                    if (fWeight > 0.0) {
                        pFrame = pPointer.animation.frame(sName, pPointer.time);
                        if (pFrame) {
                            iAnim++;
                            //first, if 1
                            pResultFrame.add(pFrame.mult(fWeight), iAnim === 1);
                            // if (iAnim === 1) {
                            // 	console.log((<any>pPointer.animation).name);
                            // }
                                                    }
                    }
                }
                if (pResultFrame.weight === 0.0) {
                    return null;
                }
                return pResultFrame.normilize();
            };
            Blend.prototype.weightUpdated = function (iAnim, fWeight) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((/*checked (origin: animation)>>*/akra.animation.Base._pEventTable))).broadcast[(this._iGuid)] = (((/*checked (origin: animation)>>*/akra.animation.Base._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).weightUpdated;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, iAnim, fWeight) : _broadcast[i].listener(_recivier, iAnim, fWeight);
                    }
                }
            };
            Blend.prototype.durationUpdated = function (fDuration) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((/*checked (origin: animation)>>*/akra.animation.Base._pEventTable))).broadcast[(this._iGuid)] = (((/*checked (origin: animation)>>*/akra.animation.Base._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).durationUpdated;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, fDuration) : _broadcast[i].listener(_recivier, fDuration);
                    }
                }
            };
            return Blend;
        })(animation.Base);        
        /** @inline */function isBlend(pAnimation) {
            return pAnimation.type === akra.EAnimationTypes.BLEND;
        }
        animation.isBlend = isBlend;
        function createBlend(sName) {
            return new Blend(sName);
        }
        animation.createBlend = createBlend;
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (animation) {
        var Controller = (function () {
            function Controller(pEngine, sName, iOptions) {
                if (typeof sName === "undefined") { sName = null; }
                if (typeof iOptions === "undefined") { iOptions = 0; }
                this.name = null;
                this._pAnimations = [];
                this._iOptions = 0;
                this._pActiveAnimation = null;
                this._pTarget = null;
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
                this._pEngine = pEngine;
                this.setOptions(iOptions);
                this.name = sName;
            }
            Object.defineProperty(Controller.prototype, "totalAnimations", {
                get: /** @inline */function () {
                    return this._pAnimations.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Controller.prototype, "active", {
                get: /** @inline */function () {
                    return this._pActiveAnimation;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Controller.prototype, "target", {
                get: /** @inline */function () {
                    return this._pTarget;
                },
                enumerable: true,
                configurable: true
            });
            Controller.prototype.getEngine = /** @inline */function () {
                return this._pEngine;
            };
            Controller.prototype.setOptions = function (iOptions) {
            };
            Controller.prototype.addAnimation = function (pAnimation) {
                if (this.findAnimation(pAnimation.name)) {
 {
                        akra.logger.setSourceLocation("animation/Controller.ts", 52);
                        akra.logger.warning("Animation with name <" + pAnimation.name + "> already exists in this controller");
                    }
                    ;
                    return false;
                }
                //LOG('animation controller :: add animation >> ', pAnimation.name);
                this._pAnimations.push(pAnimation);
                this._pActiveAnimation = pAnimation;
                /*!pAnimation.isAttached() && */
                if (!((((this)._pTarget)) === null)) {
                    pAnimation.attach(((this)._pTarget));
                } else {
                    //TODO: detach animation
                                    }
                this.animationAdded(pAnimation);
            };
            Controller.prototype.removeAnimation = function (pAnimation) {
                var pAnimation = this.findAnimation(arguments[0]);
                var pAnimations = this._pAnimations;
                for(var i = 0; i < pAnimations.length; ++i) {
                    if (pAnimations[i] === pAnimation) {
                        pAnimations.splice(i, 1);
 {
                            akra.logger.setSourceLocation("animation/Controller.ts", 80);
                            akra.logger.log("animation controller :: remove animation >> ", pAnimation.name);
                        }
                        ;
                        return true;
                    }
                }
                return false;
            };
            Controller.prototype.findAnimation = function (pAnimation) {
                var pAnimations = this._pAnimations;
                var iAnimation;
                var sAnimation;
                if ((typeof (arguments[0]) === "string")) {
                    sAnimation = arguments[0];
                    for(var i = 0; i < pAnimations.length; ++i) {
                        if (pAnimations[i].name === sAnimation) {
                            return pAnimations[i];
                        }
                    }
                    return null;
                }
                if (typeof arguments[0] === 'number') {
                    iAnimation = arguments[0];
                    return pAnimations[iAnimation] || null;
                }
                return arguments[0];
            };
            Controller.prototype.getAnimation = /** @inline */function (iAnim) {
                return this._pAnimations[iAnim];
            };
            Controller.prototype.setAnimation = function (iAnimation, pAnimation) {
 {
                    akra.logger.setSourceLocation("animation/Controller.ts", 121);
                    akra.logger.assert(iAnimation < this._pAnimations.length, 'invalid animation slot');
                }
                ;
                this._pAnimations[iAnimation] = pAnimation;
            };
            Controller.prototype.attach = function (pTarget) {
                var pAnimations = this._pAnimations;
                for(var i = 0; i < pAnimations.length; ++i) {
                    if (!pAnimations[i].isAttached() || ((this)._pTarget) !== pTarget) {
                        pAnimations[i].attach(pTarget);
                    }
                }
                if (((this)._pTarget)) {
                    ((((this)._pTarget).scene).getEventTable().removeDestination(((((((this)._pTarget).scene)))._iGuid), ("postUpdate"), (this), ("update"), (undefined)));
                }
                this._pTarget = pTarget;
                ((((this)._pTarget).scene).getEventTable().addDestination(((((((this)._pTarget).scene)))._iGuid), ("postUpdate"), (this), ("update"), (undefined)));
            };
            Controller.prototype.play = function (pAnimation) {
                var pAnimationNext = this.findAnimation(arguments[0]);
                var pAnimationPrev = this._pActiveAnimation;
                var fRealTime = this._pEngine.time;
                if (pAnimationNext && pAnimationNext !== pAnimationPrev) {
                    if (pAnimationPrev) {
                        pAnimationPrev.stop(fRealTime);
                    }
                    pAnimationNext.play(fRealTime);
                    this._pActiveAnimation = pAnimationNext;
                    this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Controller._pEventTable))).broadcast[(this._iGuid)] = (((Controller._pEventTable))).broadcast[(this._iGuid)] || {}));
                    var _broadcast = (this._pBroadcastSlotList).play;
                    var _recivier = this;
                    if (((_broadcast) !== undefined)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pAnimationNext, fRealTime) : _broadcast[i].listener(_recivier, pAnimationNext, fRealTime);
                        }
                    }
                    ;
                    return true;
                }
                return false;
            };
            Controller.prototype.stop = function () {
                if (this._pActiveAnimation) {
                    this._pActiveAnimation.stop(this._pEngine.time);
                }
                this._pActiveAnimation = null;
            };
            Controller.prototype.update = function () {
                var pAnim = this._pActiveAnimation;
                if (!((pAnim) === null)) {
                    if (!pAnim.apply(this._pEngine.time)) {
                        this._pActiveAnimation = null;
                        pAnim.stop(this._pEngine.time);
                    }
                }
            };
            Controller.prototype.toString = function (bFullInfo) {
                if (typeof bFullInfo === "undefined") { bFullInfo = false; }
                var s = "\n";
                s += "ANIMATION CONTROLLER (total: " + ((this)._pAnimations.length) + " animations)\n";
                s += "-----------------------------------------------------\n";
                for(var i = 0; i < ((this)._pAnimations.length); ++i) {
                    s += ((this)._pAnimations[(i)]).toString();
                }
                return s;
            };
            Controller.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            Controller._pEventTable = new akra.events.EventTable();
            Controller.prototype.getEventTable = /** @inline */function () {
                return Controller._pEventTable;
            };
            Controller.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Controller.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Controller.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (Controller._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Controller.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (Controller._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Controller.prototype._syncTable = /** @inline */function (pFrom) {
                (Controller._pEventTable)._sync(this, pFrom);
            };
            Controller.prototype.animationAdded = function (pAnimation) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Controller._pEventTable))).broadcast[(this._iGuid)] = (((Controller._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).animationAdded;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pAnimation) : _broadcast[i].listener(_recivier, pAnimation);
                    }
                }
            };
            return Controller;
        })();
        animation.Controller = Controller;        
        //BROADCAST(play, CALL(pAnimation));
        function createController(pEngine, sName, iOptions) {
            return new Controller(pEngine, sName, iOptions);
        }
        animation.createController = createController;
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                                                                                                                                                                                                                                                                                // globals
                var pSupportedVertexFormat;
                var pSupportedTextureFormat;
                var pSupportedColorFormat;
                var pSupportedWeightFormat;
                var pSupportedJointFormat;
                var pSupportedInvBindMatrixFormat;
                var pSupportedInterpolationFormat;
                var pSupportedInputFormat;
                var pSupportedOutputFormat;
                var pSupportedTangentFormat;
                var pFormatStrideTable;
                var pConvFormats;
                var Collada = (function (_super) {
                    __extends(Collada, _super);
                    function Collada() {
                                        _super.call(this);
                        this.modelFormat = akra.EModelFormats.COLLADA;
                        //=======================================================================================
                        this._pModel = null;
                        this._pOptions = null;
                        this._pLinks = {};
                        this._pLib = {};
                        this._pCache = {
                            meshMap: {},
                            sharedBuffer: null
                        };
                        this._pAsset = null;
                        this._pVisualScene = null;
                        this._pAnimations = [];
                        this._sFilename = null;
                        this._pXMLRoot = null;
                        this._iByteLength = 0;
                    }
                    Collada.DEFAULT_OPTIONS = {
                        drawJoints: false,
                        wireframe: false,
                        sharedBuffer: false,
                        animation: {
                            pose: true
                        },
                        scene: true,
                        extractPoses: true,
                        skeletons: [],
                        images: {
                            flipY: false
                        }
                    };
                    Collada.SCENE_TEMPLATE = [
                        {
                            lib: 'library_images',
                            element: 'image',
                            loader: "COLLADAImage"
                        }, 
                        {
                            lib: 'library_effects',
                            element: 'effect',
                            loader: "COLLADAEffect"
                        }, 
                        {
                            lib: 'library_materials',
                            element: 'material',
                            loader: "COLLADAMaterial"
                        }, 
                        {
                            lib: 'library_geometries',
                            element: 'geometry',
                            loader: "COLLADAGeometrie"
                        }, 
                        {
                            lib: 'library_controllers',
                            element: 'controller',
                            loader: "COLLADAController"
                        }, 
                        {
                            lib: 'library_cameras',
                            element: 'camera',
                            loader: "COLLADACamera"
                        }, 
                        {
                            lib: 'library_lights',
                            element: 'light',
                            loader: "COLLADALight"
                        }, 
                        {
                            lib: 'library_visual_scenes',
                            element: 'visual_scene',
                            loader: "COLLADAVisualScene"
                        }
                    ];
                    Collada.ANIMATION_TEMPLATE = [
                        {
                            lib: 'library_animations',
                            element: 'animation',
                            loader: "COLLADAAnimation"
                        }
                    ];
                    Collada.COLLADA_MATERIAL_NAMES = [
                        "emission", 
                        "ambient", 
                        "diffuse", 
                        "shininess", 
                        "reflective", 
                        "reflectivity", 
                        "transparent", 
                        "transparency", 
                        "specular"
                    ];
                    Collada.prototype.trifanToTriangles = // polygon index convertion
                    function (pXML, iStride) {
                        var pFans2Tri = [
                            0, 
                            0, 
                            0
                        ];
                        var pData = [];
                        var tmp = new Array(iStride), n;
                        var pIndexes = [];
                        this.eachByTag(pXML, "p", function (pXMLData) {
                            n = string2IntArray(stringData(pXMLData), pData);
                            for(var i = 0; i < 3; i++) {
                                retrieve(pData, tmp, iStride, i, 1);
                                for(var j = 0; j < iStride; ++j) {
                                    pIndexes.push(tmp[j]);
                                }
                            }
                            for(var i = 3, m = n / iStride; i < m; i++) {
                                pFans2Tri[1] = i - 1;
                                pFans2Tri[2] = i;
                                for(var j = 0; j < pFans2Tri.length; ++j) {
                                    for(var k = 0; k < iStride; ++k) {
                                        pIndexes.push(pData[pFans2Tri[j] * iStride + k]);
                                    }
                                }
                            }
                        });
                        return pIndexes;
                    };
                    Collada.prototype.polygonToTriangles = /** @inline */function (pXML, iStride) {
                        //TODO для невыпуклых многоугольников с самоперечечениями работать будет не верно
                        return this.trifanToTriangles(pXML, iStride);
                    };
                    Collada.prototype.tristripToTriangles = function (pXML, iStride) {
                        var pStrip2Tri = [
                            0, 
                            0, 
                            0
                        ];
                        var pData = [];
                        var tmp = new Array(iStride), n;
                        var pIndexes = [];
                        this.eachByTag(pXML, "p", function (pXMLData) {
                            n = string2IntArray(stringData(pXMLData), pData);
                            for(var i = 0; i < 3; i++) {
                                retrieve(pData, tmp, iStride, i, 1);
                                for(var j = 0; j < iStride; ++j) {
                                    pIndexes.push(tmp[j]);
                                }
                            }
                            for(var i = 3, m = n / iStride; i < m; i++) {
                                pStrip2Tri[0] = i - 1;
                                pStrip2Tri[1] = i - 2;
                                pStrip2Tri[2] = i;
                                for(var j = 0; j < pStrip2Tri.length; ++j) {
                                    for(var k = 0; k < iStride; ++k) {
                                        pIndexes.push(pData[pStrip2Tri[j] * iStride + k]);
                                    }
                                }
                            }
                        });
                        return pIndexes;
                    };
                    Collada.prototype.polylistToTriangles = function (pXML, iStride) {
                        var pXMLvcount = firstChild(pXML, "vcount");
                        var pXMLp = firstChild(pXML, "p");
                        var pVcount = new Array(parseInt(attr(pXML, "count")));
                        var pData, pIndexes;
                        var n, h = 0;
                        var tmp = new Array(128);
                        var buf = new Array(256);
                        var pPoly2Tri = [
                            0, 
                            0, 
                            0
                        ];
                        string2IntArray(stringData(pXMLvcount), pVcount);
                        var nElements = 0, nTotalElement = 0;
                        for(var i = 0; i < pVcount.length; i++) {
                            nElements += pVcount[i];
                            nTotalElement += (pVcount[i] - 2) * 3;
                        }
                        pIndexes = new Array(iStride * nTotalElement);
                        pData = new Array(iStride * nElements);
                        string2IntArray(stringData(pXMLp), pData);
                        for(var i = 0, m = 0; i < pVcount.length; i++) {
                            n = retrieve(pData, tmp, iStride, m, pVcount[i]);
                            for(var j = 0; j < 3; j++) {
                                retrieve(tmp, buf, iStride, j, 1);
                                for(var k = 0; k < iStride; ++k) {
                                    pIndexes[h++] = buf[k];
                                }
                            }
                            for(var x = 3, t = n / iStride; x < t; x++) {
                                pPoly2Tri[1] = x - 1;
                                pPoly2Tri[2] = x;
                                for(var j = 0; j < pPoly2Tri.length; ++j) {
                                    for(var k = 0; k < iStride; ++k) {
                                        pIndexes[h++] = pData[(m + pPoly2Tri[j]) * iStride + k];
                                    }
                                }
                            }
                            m += pVcount[i];
                        }
                        return pIndexes;
                    };
                    Collada.prototype.eachNode = //xml
                    function (pXMLList, fnCallback, nMax) {
                        var n = pXMLList.length, i;
                        nMax = ((typeof (nMax) === "number") ? (nMax < n ? nMax : n) : n);
                        n = 0;
                        i = 0;
                        while(n < pXMLList.length) {
                            //skip text nodes
                            if (pXMLList[n++].nodeType === Node.TEXT_NODE) {
                                continue;
                            }
                            var pXMLData = pXMLList[n - 1];
                            fnCallback.call(this, pXMLData, pXMLData.nodeName);
                            i++;
                            if (nMax === i) {
                                break;
                            }
                        }
                        //        for (var i = 0; i < nMax; i++) {
                        //            var pXMLData = pXMLList.item(i);
                        //            var sName = pXMLData.getNodeName();
                        //            fnCallback(pXMLData, sName);
                        //        }
                                            };
                    Collada.prototype.eachChild = function (pXML, fnCallback) {
                        this.eachNode(pXML.childNodes, fnCallback);
                    };
                    Collada.prototype.eachByTag = /** @inline */function (pXML, sTag, fnCallback, nMax) {
                        this.eachNode(pXML.getElementsByTagName(sTag), fnCallback, nMax);
                    };
                    Collada.prototype.findNode = // akra additional functions
                    function (pNodes, sNode, fnNodeCallback) {
                        if (typeof sNode === "undefined") { sNode = null; }
                        if (typeof fnNodeCallback === "undefined") { fnNodeCallback = null; }
                        var pNode = null;
                        var pRootJoint = null;
                        for(var i = pNodes.length - 1; i >= 0; i--) {
                            pNode = pNodes[i];
                            if (pNode === null) {
                                continue;
                            }
                            if (sNode && "#" + pNode.id === sNode) {
                                return pNode;
                            }
                            if (!((fnNodeCallback) === null)) {
                                fnNodeCallback.call(this, pNode);
                            }
                            if (pNode.childNodes) {
                                pRootJoint = this.findNode(pNode.childNodes, sNode, fnNodeCallback);
                                if (!((pRootJoint) === null)) {
                                    return pRootJoint;
                                }
                            }
                        }
                        return null;
                    };
                    Collada.prototype.COLLADATranslateMatrix = // helper functions
                    function (pXML) {
                        var pData = new Array(3);
                        string2FloatArray(stringData(pXML), pData);
                        return (akra.Vec3.stackCeil.set(pData)).toTranslationMatrix();
                    };
                    Collada.prototype.COLLADARotateMatrix = function (pXML) {
                        var pData = new Array(4);
                        string2FloatArray(stringData(pXML), pData);
                        return (new akra.Mat4(1)).rotateLeft(pData[3] * akra.math.RADIAN_RATIO, akra.Vec3.stackCeil.set(pData[0], pData[1], pData[2]));
                    };
                    Collada.prototype.COLLADAScaleMatrix = function (pXML) {
                        var pData = new Array(3);
                        string2FloatArray(stringData(pXML), pData);
                        return new akra.Mat4(pData[0], pData[1], pData[2], 1.0);
                    };
                    Collada.prototype.COLLADAData = function (pXML) {
                        var sName = pXML.nodeName;
                        var sData = stringData(pXML);
                        switch(sName) {
                            case "bool":
                                return string2Any(sData, 1, "bool");
                            case "int":
                                return string2Any(sData, 1, "int");
                            case "float":
                                return string2Any(sData, 1, "float");
                            case "float2":
                                return string2Any(sData, 2, "float");
                            case "float3":
                                return string2Any(sData, 3, "float");
                            case "float4":
                            case "color":
                                return string2Any(sData, 4, "float");
                            case "rotate":
                                return this.COLLADARotateMatrix(pXML);
                            case "translate":
                                return this.COLLADATranslateMatrix(pXML);
                            case "scale":
                                return this.COLLADAScaleMatrix(pXML);
                            case "bind_shape_matrix":
                            case "matrix":
                                return (new akra.Mat4(string2Any(sData, 16, "float"), true)).transpose();
                            case "float_array":
                                return string2Any(sData, parseInt(attr(pXML, "count")), "float", true);
                            case "int_array":
                                return string2Any(sData, parseInt(attr(pXML, "count")), "int", true);
                            case "bool_array":
                                return string2Any(sData, parseInt(attr(pXML, "count")), "bool", true);
                            case "Name_array":
                            case "name_array":
                            case "IDREF_array":
                                return string2Any(sData, parseInt(attr(pXML, "count")), "string", true);
                            case "sampler2D":
                                return this.COLLADASampler2D(pXML);
                            case "surface":
                                return this.COLLADASurface(pXML);
                            default:
 {
                                    akra.logger.setSourceLocation("resources/Collada.ts", 612);
                                    akra.logger.error("unsupported COLLADA data type <" + sName + " />");
                                }
                                ;
                        }
                        //return null;
                                            };
                    Collada.prototype.COLLADAGetSourceData = function (pSource, pFormat) {
 {
                            akra.logger.setSourceLocation("resources/Collada.ts", 620);
                            akra.logger.assert(((pSource) != null), "<source /> with expected format ", pFormat, " not founded");
                        }
                        ;
                        var nStride = calcFormatStride(pFormat);
                        var pTech = pSource.techniqueCommon;
 {
                            akra.logger.setSourceLocation("resources/Collada.ts", 625);
                            akra.logger.assert(((pTech) != null), "<source /> with id <" + pSource.id + "> has no <technique_common />");
                        }
                        ;
                        var pAccess = pTech.accessor;
                        var isFormatSupported;
                        if (!(pAccess.stride <= nStride)) {
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 632);
                                akra.logger.log(pAccess.stride, "/", nStride);
                            }
                            ;
                        }
 {
                            akra.logger.setSourceLocation("resources/Collada.ts", 637);
                            akra.logger.assert(pAccess.stride <= nStride, "<source /> width id" + pSource.id + " has unsupported stride: " + pAccess.stride);
                        }
                        ;
                        var fnUnsupportedFormatError = function () {
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 640);
                                akra.logger.log("expected format: ", pFormat);
                            }
                            ;
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 641);
                                akra.logger.log("given format: ", pAccess.params);
                            }
                            ;
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 642);
                                akra.logger.error("accessor of <" + pSource.id + "> has unsupported format");
                            }
                            ;
                        };
                        for(var i = 0; i < pAccess.params.length; ++i) {
                            isFormatSupported = false;
                            //finding name in format names..
                            for(var f = 0; f < pFormat[i].name.length; ++f) {
                                if ((pAccess.params[i].name || "").toLowerCase() == (pFormat[i].name[f] || "").toLowerCase()) {
                                    isFormatSupported = true;
                                }
                            }
                            if (!isFormatSupported) {
                                fnUnsupportedFormatError();
                            }
                            isFormatSupported = false;
                            for(var f = 0; f < pFormat[i].type.length; ++f) {
                                if (pAccess.params[i].type.toLowerCase() == pFormat[i].type[f].toLowerCase()) {
                                    isFormatSupported = true;
                                }
                            }
                            if (!isFormatSupported) {
                                fnUnsupportedFormatError();
                            }
                        }
                        return pAccess.data;
                    };
                    Collada.prototype.COLLADATransform = // common
                    // -----------------------------------------------------------
                    function (pXML, id) {
                        var pTransform = {
                            sid: attr(pXML, "sid"),
                            transform: String(pXML.nodeName),
                            value: null
                        };
                        if ((typeof (id) === "string") && ((pTransform.sid) != null)) {
                            this.link(id + "/" + pTransform.sid, pTransform);
                        } else {
                            this.link(id + "/" + pTransform.transform, pTransform);
                        }
                        var v4f, m4f;
                        var pData;
                        switch(pTransform.transform) {
                            case "rotate":
                                pData = new Array(4);
                                string2FloatArray(stringData(pXML), pData);
                                v4f = new akra.Vec4(pData);
                                /* to radians. */
                                v4f.w *= akra.math.RADIAN_RATIO;
                                pTransform.value = v4f;
                                break;
                            case "translate":
                            case "scale":
                                pData = new Array(3);
                                string2FloatArray(stringData(pXML), pData);
                                pTransform.value = new akra.Vec3(pData);
                                break;
                            case "matrix":
                                m4f = new akra.Mat4();
                                string2FloatArray(stringData(pXML), m4f.data);
                                m4f.transpose();
                                pTransform.value = m4f;
                                break;
                            default:
 {
                                    akra.logger.setSourceLocation("resources/Collada.ts", 729);
                                    akra.logger.error("unsupported transform detected: " + pTransform.transform);
                                }
                                ;
                        }
                        return pTransform;
                    };
                    Collada.prototype.COLLADANewParam = function (pXML) {
                        var _this = this;
                        var pParam = {
                            sid: attr(pXML, "sid"),
                            annotate: null,
                            semantics: null,
                            modifier: null,
                            value: null,
                            type: null
                        };
                        this.eachChild(pXML, function (pXMLData, sName) {
                            switch(sName) {
                                case "semantic":
                                    pParam.semantics = stringData(pXMLData);
                                    break;
                                case "modifier":
                                    pParam.modifier = stringData(pXMLData);
                                case "annotate":
                                    pParam.annotate = {
                                        name: attr(pXMLData, "name"),
                                        value: stringData(pXMLData)
                                    };
                                case "float":
                                case "float2":
                                case "float3":
                                case "float4":
                                case "surface":
                                case "sampler2D":
                                    pParam.type = sName;
                                    pParam.value = _this.COLLADAData(pXMLData);
                                    break;
                                default:
                                    pParam.value = _this.COLLADAData(pXMLData);
                            }
                        });
                        this.link(pParam.sid, pParam);
                        return pParam;
                    };
                    Collada.prototype.COLLADAAsset = function (pXML) {
                        if (typeof pXML === "undefined") { pXML = firstChild(this.getXMLRoot(), "asset"); }
                        var pAsset = {
                            unit: {
                                meter: 1.0,
                                name: "meter"
                            },
                            upAxis: "Y_UP",
                            title: null,
                            created: null,
                            modified: null,
                            contributor: {
                                author: null,
                                authoringTool: null,
                                comments: null,
                                copyright: null,
                                sourceData: null
                            }
                        };
                        this.eachChild(pXML, function (pXMLNode, sName) {
                            var sValue = stringData(pXMLNode);
                            switch(sName) {
                                case "up_axis":
                                    pAsset.upAxis = sValue;
                                    break;
                                case "created":
                                    pAsset.created = sValue;
                                    break;
                                case "modified":
                                    pAsset.modified = sValue;
                                    break;
                                case "title":
                                    pAsset.title = sValue;
                                    break;
                                case "contributor":
                                    //TODO contributor
                                    break;
                                case "unit":
                                    pAsset.unit.meter = parseFloat(attr(pXMLNode, "meter"));
                                    pAsset.unit.name = attr(pXMLNode, "name");
                                    break;
                            }
                        });
                        return this._pAsset = pAsset;
                    };
                    Collada.prototype.COLLADALibrary = function (pXML, pTemplate) {
                        var _this = this;
                        if (!((pXML) != null)) {
                            return null;
                        }
                        var pLib = {};
                        var pData;
                        var sTag = pTemplate.element;
                        var iAutoId = 0;
                        pLib[sTag] = {};
                        this.eachChild(pXML, function (pXMLData, sName) {
                            if (sTag !== sName) {
                                return;
                            }
                            pData = (((_this)[pTemplate.loader]))(pXMLData);
                            if (((pData) === null)) {
                                return;
                            }
                            pLib[sTag][attr(pXMLData, 'id') || (sTag + "_" + (iAutoId++))] = pData;
                        });
                        return pLib;
                    };
                    Collada.prototype.COLLADAAccessor = // geometry
                    function (pXML) {
                        var pAccessor = {
                            data: this.source(attr(pXML, "source")),
                            count: parseInt(attr(pXML, "count")),
                            stride: parseInt(attr(pXML, "stride") || 1),
                            params: []
                        };
                        this.eachChild(pXML, function (pXMLData, sName) {
                            pAccessor.params.push({
                                name: attr(pXMLData, "name"),
                                type: attr(pXMLData, "type")
                            });
                        });
                        return pAccessor;
                    };
                    Collada.prototype.COLLADAInput = //dangerous: the default offset is 0, but collada required this attribute
                    function (pXML, iOffset) {
                        if (typeof iOffset === "undefined") { iOffset = 0; }
                        var pInput = {
                            semantics: attr(pXML, "semantic"),
                            source: this.source(attr(pXML, "source")),
                            offset: -1,
                            set: attr(pXML, "set")
                        };
                        //pInput.set = (pInput.set ? parseInt(pInput.set) : 0);
                        if (!((attr(pXML, "offset")) === null)) {
                            pInput.offset = parseInt(attr(pXML, "offset"));
                        }
                        if ((typeof (iOffset) === "number") && pInput.offset === -1) {
                            pInput.offset = iOffset;
                        }
 {
                            akra.logger.setSourceLocation("resources/Collada.ts", 906);
                            akra.logger.assert((typeof (pInput.offset) === "number") && pInput.offset >= 0, "invalid offset detected");
                        }
                        ;
                        return pInput;
                    };
                    Collada.prototype.COLLADATechniqueCommon = function (pXML) {
                        var _this = this;
                        var pTechniqueCommon = {
                            accessor: null,
                            perspective: null
                        };
                        this.eachChild(pXML, function (pXMLData, sName) {
                            switch(sName) {
                                case "accessor":
                                    pTechniqueCommon.accessor = _this.COLLADAAccessor(pXMLData);
                                    break;
                                case "perspective":
                                    pTechniqueCommon.perspective = _this.COLLADAPerspective(pXMLData);
                                    break;
                            }
                        });
                        return pTechniqueCommon;
                    };
                    Collada.prototype.COLLADASource = function (pXML) {
                        var _this = this;
                        var pSource = {
                            id: attr(pXML, "id"),
                            name: attr(pXML, "name"),
                            array: {},
                            techniqueCommon: null
                        };
                        this.link(pSource);
                        this.eachChild(pXML, function (pXMLData, sName) {
                            var pColladaArray;
                            var id;
                            switch(sName.toLowerCase()) {
                                case "int_array":
                                case "bool_array":
                                case "float_array":
                                case "idref_array":
                                case "name_array":
                                    pColladaArray = _this.COLLADAData(pXMLData);
                                    id = attr(pXMLData, "id");
                                    pSource.array[id] = pColladaArray;
                                    _this.link(id, pColladaArray);
                                    break;
                                case "technique_common":
                                    pSource.techniqueCommon = _this.COLLADATechniqueCommon(pXMLData);
                                    break;
                            }
                        });
                        return pSource;
                    };
                    Collada.prototype.COLLADAVertices = function (pXML) {
                        var pVertices = {
                            id: attr(pXML, "id"),
                            inputs: {}
                        };
                        this.eachByTag(pXML, "input", function (pXMLData) {
                            var sSemantic = attr(pXMLData, "semantic");
                            pVertices.inputs[sSemantic] = this.COLLADAInput(pXMLData);
                        });
 {
                            akra.logger.setSourceLocation("resources/Collada.ts", 982);
                            akra.logger.assert(((pVertices.inputs["POSITION"]) != null), "semantics POSITION must be in the <vertices /> tag");
                        }
                        ;
                        this.link(pVertices);
                        return pVertices;
                    };
                    Collada.prototype.COLLADAJoints = function (pXML) {
                        var _this = this;
                        var pJoints = {
                            inputs: {}
                        };
                        var pMatrixArray;
                        var iCount;
                        var pInvMatrixArray;
                        this.eachByTag(pXML, "input", function (pXMLData) {
                            switch(attr(pXMLData, "semantic")) {
                                case "JOINT":
                                    pJoints.inputs["JOINT"] = _this.COLLADAInput(pXMLData);
                                    break;
                                case "INV_BIND_MATRIX":
                                    pJoints.inputs["INV_BIND_MATRIX"] = _this.COLLADAInput(pXMLData);
                                    break;
                                default:
 {
                                        akra.logger.setSourceLocation("resources/Collada.ts", 1009);
                                        akra.logger.error("semantics are different from JOINT/INV_BIND_MATRIX is not supported in the <joints /> tag");
                                    }
                                    ;
                            }
                        });
                        for(var sInput in pJoints.inputs) {
                            this.prepareInput(pJoints.inputs[sInput]);
                            if (sInput === "INV_BIND_MATRIX") {
                                pInvMatrixArray = new Float32Array(pJoints.inputs[sInput].array);
                                iCount = pInvMatrixArray.length / 16;
                                pMatrixArray = new Array(iCount);
                                for(var j = 0, n = 0; j < pInvMatrixArray.length; j += 16) {
                                    pMatrixArray[n++] = (new akra.Mat4(new Float32Array(pInvMatrixArray.buffer, j * Float32Array.BYTES_PER_ELEMENT, 16), true)).transpose();
                                }
                                pJoints.inputs[sInput].array = pMatrixArray;
                            }
                        }
                        return pJoints;
                    };
                    Collada.prototype.COLLADAPolygons = function (pXML, sType) {
                        var _this = this;
                        var pPolygons = {
                            inputs: /*потоки данных*/
                            [],
                            p: /*индексы*/
                            null,
                            material: /*идентификатор материала*/
                            attr(pXML, "material"),
                            name: /*имя (встречается редко, не используется)*/
                            null,
                            count: /*полное число индексов*/
                            parseInt(attr(pXML, "count"))
                        };
                        var iOffset = 0, n = 0;
                        var iCount = parseInt(attr(pXML, "count"));
                        var iStride = 0;
                        this.eachByTag(pXML, "input", function (pXMLData) {
                            pPolygons.inputs.push(_this.COLLADAInput(pXMLData, iOffset));
                            iOffset++;
                        });
                        sortArrayByProperty(pPolygons.inputs, "iOffset");
                        for(var i = 0; i < pPolygons.inputs.length; ++i) {
                            iStride = akra.math.max((pPolygons.inputs[i]).offset + 1, iStride);
                        }
 {
                            akra.logger.setSourceLocation("resources/Collada.ts", 1061);
                            akra.logger.assert(iStride > 0, "Invalid offset detected.");
                        }
                        ;
                        switch(sType) {
                            case "polylist":
                                pPolygons.p = this.polylistToTriangles(pXML, iStride);
                                break;
                            case "polygons":
                                pPolygons.p = this.polygonToTriangles(pXML, iStride);
                                this.eachByTag(pXML, "ph", function (pXMLData) {
 {
                                        akra.logger.setSourceLocation("resources/Collada.ts", 1072);
                                        akra.logger.error("unsupported polygon[polygon] subtype founded: <ph>");
                                    }
                                    ;
                                });
                                break;
                            case "triangles":
                                pPolygons.p = new Array(3 * iCount * iStride);
                                this.eachByTag(pXML, "p", function (pXMLData) {
                                    n += string2IntArray(stringData(pXMLData), pPolygons.p, n);
                                });
                                break;
                            case "trifans":
                                pPolygons.p = this.trifanToTriangles(pXML, iStride);
                                break;
                            case "tristrips":
                                pPolygons.p = this.tristripToTriangles(pXML, iStride);
                                break;
                            default:
 {
                                    akra.logger.setSourceLocation("resources/Collada.ts", 1094);
                                    akra.logger.error("unsupported polygon[" + sType + "] type founded");
                                }
                                ;
                        }
                        if (!((pPolygons.type) !== undefined)) {
                            pPolygons.type = akra.EPrimitiveTypes.TRIANGLELIST;
                        }
                        return pPolygons;
                    };
                    Collada.prototype.COLLADAVertexWeights = function (pXML) {
                        var _this = this;
                        var pVertexWeights = {
                            count: parseInt(attr(pXML, "count")),
                            inputs: [],
                            weightInput: null,
                            vcount: null,
                            v: null
                        };
                        var iOffset = 0;
                        var pInput;
                        this.eachByTag(pXML, "input", function (pXMLData) {
                            pInput = _this.COLLADAInput(pXMLData, iOffset);
                            if (pInput.semantics === "WEIGHT") {
                                pVertexWeights.weightInput = pInput;
                            }
                            pVertexWeights.inputs.push(pInput);
                            iOffset++;
                        });
                        var pVcountData, pVData;
                        pVcountData = new Array(pVertexWeights.count);
                        string2IntArray(stringData(firstChild(pXML, "vcount")), pVcountData);
                        pVertexWeights.vcount = pVcountData;
                        var n = 0;
                        for(var i = 0; i < pVcountData.length; ++i) {
                            n += pVcountData[i];
                        }
                        n *= pVertexWeights.inputs.length;
 {
                            akra.logger.setSourceLocation("resources/Collada.ts", 1144);
                            akra.logger.assert(pVertexWeights.inputs.length === 2, "more than 2 inputs in <vertex_weights/> not supported currently");
                        }
                        ;
                        pVData = new Array(n);
                        string2IntArray(stringData(firstChild(pXML, "v")), pVData);
                        pVertexWeights.v = pVData;
                        return pVertexWeights;
                    };
                    Collada.prototype.COLLADAMesh = function (pXML) {
                        var _this = this;
                        var pMesh = {
                            sources: [],
                            polygons: []
                        };
                        var id;
                        var pPolygons, pVertices, pPos;
                        this.eachChild(pXML, function (pXMLData, sName) {
                            switch(sName) {
                                case "source":
                                    pMesh.sources.push(_this.COLLADASource(pXMLData));
                                    break;
                                case "vertices":
                                    pVertices = _this.COLLADAVertices(pXMLData);
                                    break;
                                case "lines":
                                case "linestrips":
                                case "tristrips":
                                case "trifans":
                                case "triangles":
                                case "polygons":
                                case "polylist":
                                    pPolygons = _this.COLLADAPolygons(pXMLData, sName);
                                    for(var i = 0; i < pPolygons.inputs.length; ++i) {
                                        pPos = null;
                                        if (pPolygons.inputs[i].semantics == "VERTEX") {
                                            if (pPolygons.inputs[i].source.id == pVertices.id) {
                                                pPos = pVertices.inputs["POSITION"];
                                                pPolygons.inputs[i].source = pPos.source;
                                                pPolygons.inputs[i].semantics = pPos.semantics;
                                            } else {
 {
                                                    akra.logger.setSourceLocation("resources/Collada.ts", 1194);
                                                    akra.logger.error("<input /> with semantic VERTEX must refer to <vertices /> tag in same mesh.");
                                                }
                                                ;
                                            }
                                        }
                                        _this.prepareInput(pPolygons.inputs[i]);
                                    }
                                    pMesh.polygons.push(pPolygons);
                                    break;
                            }
                        });
                        return pMesh;
                    };
                    Collada.prototype.COLLADAGeometrie = function (pXML) {
                        var pGeometrie = {
                            id: attr(pXML, "id"),
                            name: attr(pXML, "name"),
                            mesh: null,
                            convexMesh: null,
                            spline: null
                        };
                        var pXMLData = firstChild(pXML);
                        var sName = pXMLData.nodeName;
                        if (sName == "mesh") {
                            pGeometrie.mesh = this.COLLADAMesh(pXMLData);
                        }
                        this.link(pGeometrie);
                        return pGeometrie;
                    };
                    Collada.prototype.COLLADASkin = function (pXML) {
                        var _this = this;
                        var pSkin = {
                            shapeMatrix: this.COLLADAData(firstChild(pXML, "bind_shape_matrix")),
                            sources: [],
                            geometry: this.source(attr(pXML, "source")),
                            joints: null,
                            vertexWeights: null
                        };
                        //TODO:  add other parameters to skin section
                                                var pVertexWeights, pInput;
                        this.eachChild(pXML, function (pXMLData, sName) {
                            switch(sName) {
                                case "source":
                                    pSkin.sources.push(_this.COLLADASource(pXMLData));
                                    break;
                                case "joints":
                                    pSkin.joints = _this.COLLADAJoints(pXMLData);
                                    break;
                                case "vertex_weights":
                                    pVertexWeights = _this.COLLADAVertexWeights(pXMLData);
                                    for(var i = 0; i < pVertexWeights.inputs.length; ++i) {
                                        pInput = _this.prepareInput(pVertexWeights.inputs[i]);
                                    }
                                    pSkin.vertexWeights = pVertexWeights;
                                    break;
                            }
                        });
                        return pSkin;
                    };
                    Collada.prototype.COLLADAController = function (pXML) {
                        var pController = {
                            name: attr(pXML, "name"),
                            id: attr(pXML, "id"),
                            skin: null,
                            morph: null
                        };
                        var pXMLData = firstChild(pXML, "skin");
                        if (!((pXMLData) === null)) {
                            pController.skin = this.COLLADASkin(pXMLData);
                        } else {
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 1283);
                                akra.logger.warning("Founded controller without skin element!");
                            }
                            ;
                            return null;
                        }
                        this.link(pController);
                        return pController;
                    };
                    Collada.prototype.COLLADAImage = // images
                    function (pXML) {
                        var pImage = {
                            id: attr(pXML, "id"),
                            name: attr(pXML, "name"),
                            format: attr(pXML, "format"),
                            height: /*-1 == auto detection*/
                            parseInt(attr(pXML, "height") || -1),
                            width: parseInt(attr(pXML, "width") || -1),
                            depth: /*only 2D images supported*/
                            1,
                            data: null,
                            path: null
                        };
                        var sFilename = this.getFilename();
                        var sPath = null;
                        var pXMLInitData = firstChild(pXML, "init_from"), pXMLData;
                        if (((pXMLInitData) != null)) {
                            sPath = stringData(pXMLInitData);
                            //modify path to the textures relative to a given file
                            if (!((sFilename) === null)) {
                                if (!akra.util.pathinfo(sPath).isAbsolute()) {
                                    sPath = akra.util.pathinfo(sFilename).dirname + "/" + sPath;
                                }
                            }
                            pImage.path = sPath;
                        } else if (((pXMLData = firstChild(pXML, "data")) != null)) {
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 1326);
                                akra.logger.error("image loading from <data /> tag unsupported yet.");
                            }
                            ;
                        } else {
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 1329);
                                akra.logger.error("image with id: " + pImage.id + " has no data.");
                            }
                            ;
                        }
                        this.link(pImage);
                        return pImage;
                    };
                    Collada.prototype.COLLADASurface = // effects
                    function (pXML) {
                        var pSurface = {
                            initFrom: stringData(firstChild(pXML, "init_from"))
                        };
                        //, format: stringData(firstChild(pXML, "format"))
                        return pSurface;
                    };
                    Collada.prototype.COLLADATexture = function (pXML) {
                        if (!((pXML) != null)) {
                            return null;
                        }
                        var pTexture = {
                            texcoord: attr(pXML, "texcoord"),
                            sampler: this.source(attr(pXML, "texture")),
                            surface: null,
                            image: null
                        };
                        if (!((pTexture.sampler) === null) && ((pTexture.sampler.value) != null)) {
                            pTexture.surface = this.source((pTexture.sampler.value).source);
                        }
                        if (!((pTexture.surface) === null)) {
                            var pImage = this.source((pTexture.surface.value).initFrom);
                            pTexture.image = pImage;
                            var pTex = (((((this).pResourcePool)).pManager)).texturePool.loadResource(pImage.path);
                            this.sync(pTex, akra.EResourceItemEvents.LOADED);
                            // LOG("is texture valid?? - ", pTex.isValid());
                            //FIX THIS
                            pTex.setFilter(akra.ETextureParameters.MAG_FILTER, akra.ETextureFilters.LINEAR);
                            pTex.setFilter(akra.ETextureParameters.MIN_FILTER, akra.ETextureFilters.LINEAR_MIPMAP_LINEAR);
                            pTex.setWrapMode(akra.ETextureParameters.WRAP_S, akra.ETextureWrapModes.REPEAT);
                            pTex.setWrapMode(akra.ETextureParameters.WRAP_T, akra.ETextureWrapModes.REPEAT);
                        }
                        return pTexture;
                    };
                    Collada.prototype.COLLADASampler2D = function (pXML) {
                        var pSampler = {
                            source: stringData(firstChild(pXML, "source")),
                            wrapS: stringData(firstChild(pXML, "wrap_s")),
                            wrapT: stringData(firstChild(pXML, "wrap_t")),
                            minFilter: stringData(firstChild(pXML, "minfilter")),
                            mipFilter: stringData(firstChild(pXML, "mipfilter")),
                            magFilter: stringData(firstChild(pXML, "magfilter"))
                        };
                        return pSampler;
                    };
                    Collada.prototype.COLLADAPhong = function (pXML) {
                        var _this = this;
                        var pMat = {
                            diffuse: new akra.Color(0.),
                            specular: new akra.Color(0.),
                            ambient: new akra.Color(0.),
                            emissive: new akra.Color(0.),
                            shininess: 0.0,
                            reflective: new akra.Color(0.),
                            reflectivity: 0.0,
                            transparent: new akra.Color(0.),
                            transparency: 0.0,
                            indexOfRefraction: 0.0,
                            textures: {
                                diffuse: null,
                                specular: null,
                                ambient: null,
                                emissive: null,
                                normal: null
                            }
                        };
                        var pXMLData;
                        var pList = Collada.COLLADA_MATERIAL_NAMES;
                        for(var i = 0; i < pList.length; i++) {
                            var csComponent = pList[i];
                            pXMLData = firstChild(pXML, csComponent);
                            //emission --> emissive
                            //emission does not exists in akra engine materials
                            if (csComponent === "emission") {
                                csComponent = "emissive";
                            }
                            if (pXMLData) {
                                this.eachChild(pXMLData, function (pXMLData, sName) {
                                    switch(sName) {
                                        case "float":
                                            pMat[csComponent] = _this.COLLADAData(pXMLData);
                                            break;
                                        case "color":
                                            pMat[csComponent].set(_this.COLLADAData(pXMLData));
                                            break;
                                        case "texture":
                                            pMat.textures[csComponent] = _this.COLLADATexture(pXMLData);
                                    }
                                });
                            }
                        }
                        // correct shininess
                        pMat.shininess *= 10.0;
                        return pMat;
                    };
                    Collada.prototype.COLLADAEffectTechnique = function (pXML) {
                        var pTech = {
                            sid: attr(pXML, "sid"),
                            type: null,
                            value: null
                        };
                        var pValue = firstChild(pXML);
                        pTech.type = pValue.nodeName;
                        switch(pTech.type) {
                            case //FIXME: at now, all materials draws similar..
                            "blinn":
                            case "lambert":
 {
                                    akra.logger.setSourceLocation("resources/Collada.ts", 1476);
                                    akra.logger.warning("<blinn /> or <lambert /> material interprated as phong");
                                }
                                ;
                            case "phong":
                                pTech.value = this.COLLADAPhong(pValue);
                                break;
                            default:
 {
                                    akra.logger.setSourceLocation("resources/Collada.ts", 1482);
                                    akra.logger.error("unsupported technique <" + pTech.type + " /> founded");
                                }
                                ;
                        }
                        //finding normal maps like this
                        /*
                        <technique profile=​"OpenCOLLADA3dsMax">​
                        <bump bumptype=​"HEIGHTFIELD">​
                        <texture texture=​"Default_Material_normals2_png-sampler" texcoord=​"CHANNEL1">​</texture>​
                        </bump>​
                        </technique>​
                        */
                        var pXMLExtra = firstChild(pXML, "extra");
                        if (((pXMLExtra) != null)) {
                            var pXMLTech = firstChild(pXMLExtra, "technique");
                            if (((pXMLTech) != null)) {
                                var pXMLBump = firstChild(pXMLTech, "bump");
                                if (((pXMLBump) != null) && attr(pXMLBump, "bumptype") === "HEIGHTFIELD") {
                                    (pTech.value).textures.normal = this.COLLADATexture(firstChild(pXMLBump, "texture"));
                                    // LOG(pTech.value);
                                                                    }
                            }
                        }
                        this.link(pTech.sid, pTech);
                        return pTech;
                    };
                    Collada.prototype.COLLADAProfileCommon = function (pXML) {
                        var _this = this;
                        var pProfile = {
                            technique: null,
                            newParam: {}
                        };
                        this.eachByTag(pXML, "newparam", function (pXMLData) {
                            pProfile.newParam[attr(pXMLData, "sid")] = _this.COLLADANewParam(pXMLData);
                        });
                        pProfile.technique = this.COLLADAEffectTechnique(firstChild(pXML, "technique"));
                        return pProfile;
                    };
                    Collada.prototype.COLLADAEffect = function (pXML) {
                        var _this = this;
                        var pEffect = {
                            id: attr(pXML, "id"),
                            profileCommon: null
                        };
                        this.eachChild(pXML, function (pXMLData, sName) {
                            switch(sName) {
                                case "profile_COMMON":
                                    pEffect.profileCommon = _this.COLLADAProfileCommon(pXMLData);
                                    pEffect.profileCommon.technique.value.name = pEffect.id;
                                    break;
                                default:
 {
                                        akra.logger.setSourceLocation("resources/Collada.ts", 1540);
                                        akra.logger.warning("<" + sName + " /> unsupported in effect section");
                                    }
                                    ;
                            }
                        });
                        this.link(pEffect);
                        return pEffect;
                    };
                    Collada.prototype.COLLADAMaterial = //materials
                    function (pXML) {
                        var pMaterial = {
                            id: attr(pXML, "id"),
                            name: attr(pXML, "name"),
                            instanceEffect: this.COLLADAInstanceEffect(firstChild(pXML, "instance_effect"))
                        };
                        this.link(pMaterial);
                        return pMaterial;
                    };
                    Collada.prototype.COLLADANode = // scene
                    function (pXML, iDepth) {
                        if (typeof iDepth === "undefined") { iDepth = 0; }
                        var _this = this;
                        var pNode = {
                            id: attr(pXML, "id"),
                            sid: attr(pXML, "sid"),
                            name: attr(pXML, "name") || "unknown",
                            type: attr(pXML, "type"),
                            layer: attr(pXML, "layer"),
                            transform: new akra.Mat4(1),
                            geometry: [],
                            controller: [],
                            childNodes: [],
                            camera: [],
                            depth: iDepth,
                            transforms: [],
                            constructedNode: /*<! узел, в котором будет хранится ссылка на реальный игровой нод, построенный по нему*/
                            null
                        };
                        var m4fMatrix;
                        var sType;
                        var id, sid;
                        this.link(pNode);
                        this.eachChild(pXML, function (pXMLData, sName) {
                            switch(sName) {
                                case "rotate":
                                case "matrix":
                                case "translate":
                                case "scale":
                                    pNode.transforms.push(_this.COLLADATransform(pXMLData, pNode.id));
                                    pNode.transform.multiply(_this.COLLADAData(pXMLData));
                                    break;
                                case "instance_geometry":
                                    pNode.geometry.push(_this.COLLADAInstanceGeometry(pXMLData));
                                    break;
                                case "instance_controller":
                                    pNode.controller.push(_this.COLLADAInstanceController(pXMLData));
                                    break;
                                case "instance_camera":
                                    pNode.camera.push(_this.COLLADAInstanceCamera(pXMLData));
                                    break;
                                case "node":
                                    pNode.childNodes.push(_this.COLLADANode(pXMLData, iDepth + 1));
                                    break;
                            }
                        });
                        //TODO: do not load empty nodes..
                        // if (!pNode.pGeometry.length &&
                        //     !pNode.pController.length &&
                        //     !pNode.pChildNodes.length) {
                        //     return null;
                        // }
                        return pNode;
                    };
                    Collada.prototype.COLLADAVisualScene = function (pXML) {
                        var _this = this;
                        var pNode;
                        var pScene = {
                            id: attr(pXML, "id"),
                            name: attr(pXML, "name"),
                            nodes: []
                        };
                        this.link(pScene);
                        this.eachChild(pXML, function (pXMLData, sName) {
                            switch(sName) {
                                case "node":
                                    pNode = _this.COLLADANode(pXMLData);
                                    if (((pNode) != null)) {
                                        pScene.nodes.push(pNode);
                                    }
                                    break;
                            }
                        });
                        return pScene;
                    };
                    Collada.prototype.COLLADABindMaterial = function (pXML) {
                        var _this = this;
                        if (!((pXML) != null)) {
                            return null;
                        }
                        var pMaterials = {};
                        var pMat = null;
                        var pSourceMat = null;
                        var pTech = firstChild(pXML, "technique_common");
                        this.eachByTag(pTech, "instance_material", function (pInstMat) {
                            pSourceMat = _this.source(attr(pInstMat, "target"));
                            pMat = {
                                target: // url         : pSourceMat.instanceEffect.url,
                                attr(pInstMat, "target"),
                                symbol: attr(pInstMat, "symbol"),
                                material: pSourceMat,
                                vertexInput: {}
                            };
                            _this.eachByTag(pInstMat, "bind_vertex_input", function (pXMLVertexInput) {
                                var sInputSemantic = attr(pXMLVertexInput, "input_semantic");
                                if (sInputSemantic !== "TEXCOORD") {
 {
                                        akra.logger.setSourceLocation("resources/Collada.ts", 1679);
                                        akra.logger.error("unsupported vertex input semantics founded: " + sInputSemantic);
                                    }
                                    ;
                                }
                                var sSemantic = attr(pXMLVertexInput, "semantic");
                                var iInputSet = parseInt(attr(pXMLVertexInput, "input_set"));
                                pMat.vertexInput[sSemantic] = {
                                    semantics: sSemantic,
                                    inputSet: iInputSet,
                                    inputSemantic: sInputSemantic
                                };
                            });
                            pMaterials[pMat.symbol] = pMat;
                        });
                        return pMaterials;
                    };
                    Collada.prototype.COLLADAInstanceEffect = function (pXML) {
                        var _this = this;
                        var pInstance = {
                            parameters: {},
                            techniqueHint: {},
                            effect: null
                        };
                        /*
                        Exmaple for <instance_effect /> :
                        
                        <instance_effect url="CarPaint">
                        <technique_hint profile="CG" platform="PS3" ref="precalc_texture"/>
                        <setparam ref="diffuse_color">
                        <float3> 0.3 0.25 0.85 </float3>
                        </setparam>
                        </instance_effect>
                        */
                        pInstance.effect = this.source(attr(pXML, "url"));
                        this.eachByTag(pXML, "technique_hint", function (pXMLData) {
                            pInstance.techniqueHint[attr(pXMLData, "platform")] = attr(pXMLData, "ref");
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 1721);
                                akra.logger.warning("<technique_hint /> used, but will be ignored!");
                            }
                            ;
                        });
                        this.eachByTag(pXML, "setparam", function (pXMLData) {
                            //can be any type
                            pInstance.parameters[attr(pXMLData, "ref")] = _this.COLLADAData(pXMLData);
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 1727);
                                akra.logger.warning("<setparam /> used, but will be ignored!");
                            }
                            ;
                        });
                        return pInstance;
                    };
                    Collada.prototype.COLLADAInstanceController = function (pXML) {
                        var pInst = {
                            controller: this.source(attr(pXML, "url")),
                            material: this.COLLADABindMaterial(firstChild(pXML, "bind_material")),
                            skeletons: []
                        };
                        this.eachByTag(pXML, "skeleton", function (pXMLData) {
                            //cut # symbol from skeleton name
                            pInst.skeletons.push(stringData(pXMLData).substr(1));
                        });
                        return pInst;
                    };
                    Collada.prototype.COLLADAInstanceGeometry = function (pXML) {
                        var pInst = {
                            geometry: this.source(attr(pXML, "url")),
                            material: this.COLLADABindMaterial(firstChild(pXML, "bind_material"))
                        };
                        return pInst;
                    };
                    Collada.prototype.COLLADAInstanceCamera = function (pXML) {
                        var pInst = {
                            camera: this.source(attr(pXML, "url"))
                        };
                        return pInst;
                    };
                    Collada.prototype.COLLADAInstanceLight = function (pXML) {
                        var pInst = {
                            light: this.source(attr(pXML, "url"))
                        };
                        return pInst;
                    };
                    Collada.prototype.COLLADAScene = // directly load <visual_scene> from <instance_visual_scene> from <scene>.
                    function (pXML) {
                        if (typeof pXML === "undefined") { pXML = firstChild(this.getXMLRoot(), "scene"); }
                        var pXMLData = firstChild(pXML, "instance_visual_scene");
                        var pScene = this.source(attr(pXMLData, "url"));
                        if (((pXMLData) === null) || ((pScene) === null)) {
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 1779);
                                akra.logger.warning("collada model: <" + this.getBasename() + "> has no visual scenes.");
                            }
                            ;
                        }
                        return this._pVisualScene = pScene;
                    };
                    Collada.prototype.COLLADAPerspective = //camera
                    function (pXML) {
                        var pPerspective = {
                            xfov: parseFloat(stringData(firstChild(pXML, "xfov")) || 60.) * akra.math.RADIAN_RATIO,
                            yfov: parseFloat(stringData(firstChild(pXML, "yfov")) || 60.) * akra.math.RADIAN_RATIO,
                            aspect: parseFloat(stringData(firstChild(pXML, "aspect")) || 4. / 3.),
                            znear: parseFloat(stringData(firstChild(pXML, "znear")) || .1),
                            zfar: parseFloat(stringData(firstChild(pXML, "zfar")) || 500.)
                        };
                        return pPerspective;
                    };
                    Collada.prototype.COLLADAOptics = function (pXML) {
                        var pOptics = {
                            techniqueCommon: this.COLLADATechniqueCommon(firstChild(pXML, "technique_common"))
                        };
                        return pOptics;
                    };
                    Collada.prototype.COLLADACamera = function (pXML) {
                        var pCamera = {
                            optics: null,
                            id: attr(pXML, "id")
                        };
                        pCamera.optics = this.COLLADAOptics(firstChild(pXML, "optics"));
                        this.link(pCamera);
                        return pCamera;
                    };
                    Collada.prototype.COLLADALight = //light
                    function (pXML) {
                        return null;
                    };
                    Collada.prototype.COLLADAAnimationSampler = // animation
                    function (pXML) {
                        var _this = this;
                        var pSampler = {
                            inputs: {},
                            id: attr(pXML, "id")
                        };
                        var pInput;
                        var sSemantic;
                        this.link(pSampler);
                        this.eachByTag(pXML, "input", function (pXMLData) {
                            sSemantic = attr(pXMLData, "semantic");
                            switch(sSemantic) {
                                case "INPUT":
                                case "OUTPUT":
                                case "INTERPOLATION":
                                case "IN_TANGENT":
                                case "OUT_TANGENT":
                                    pInput = _this.prepareInput(_this.COLLADAInput(pXMLData));
                                    pSampler.inputs[sSemantic] = pInput;
                                    break;
                                default:
 {
                                        akra.logger.setSourceLocation("resources/Collada.ts", 1854);
                                        akra.logger.error("semantics are different from OUTPUT/INTERPOLATION/IN_TANGENT/OUT_TANGENT is not supported in the <sampler /> tag");
                                    }
                                    ;
                            }
                        });
                        return pSampler;
                    };
                    Collada.prototype.COLLADAAnimationChannel = function (pXML) {
                        var pChannel = {
                            sampler: this.source(attr(pXML, "source")),
                            target: this.target(attr(pXML, "target"))
                        };
                        if (((pChannel.target) === null) || ((pChannel.target.object) === null)) {
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 1869);
                                akra.logger.warning("cound not setup animation channel for <" + attr(pXML, "target") + ">");
                            }
                            ;
                            return null;
                        }
                        return pChannel;
                    };
                    Collada.prototype.COLLADAAnimation = function (pXML) {
                        var _this = this;
                        var pAnimation = {
                            id: attr(pXML, "id"),
                            name: attr(pXML, "name"),
                            sources: [],
                            samplers: [],
                            channels: [],
                            animations: []
                        };
                        var pChannel;
                        var pSubAnimation;
                        this.link(pAnimation);
                        this.eachChild(pXML, function (pXMLData, sName) {
                            switch(sName) {
                                case "source":
                                    pAnimation.sources.push(_this.COLLADASource(pXMLData));
                                    break;
                                case "sampler":
                                    pAnimation.samplers.push(_this.COLLADAAnimationSampler(pXMLData));
                                    break;
                                case "channel":
                                    pChannel = _this.COLLADAAnimationChannel(pXMLData);
                                    if (((pChannel) != null)) {
                                        //this guard for skipping channels with unknown targets
                                        pAnimation.channels.push(pChannel);
                                    }
                                    break;
                                case "animation":
                                    pSubAnimation = _this.COLLADAAnimation(pXMLData);
                                    if (((pSubAnimation) != null)) {
                                        pAnimation.animations.push(pSubAnimation);
                                    }
                            }
                        });
                        if (pAnimation.channels.length == 0 && pAnimation.animations.length == 0) {
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 1921);
                                akra.logger.warning("animation with id \"" + pAnimation.id + "\" skipped, because channels/sub animation are empty");
                            }
                            ;
                            return null;
                        }
 {
                            akra.logger.setSourceLocation("resources/Collada.ts", 1926);
                            akra.logger.assert(pXML.parentNode === firstChild(this.getXMLRoot(), "library_animations"), "sub animations not supported");
                        }
                        ;
                        this._pAnimations.push(pAnimation);
                        return pAnimation;
                    };
                    Collada.prototype.source = // collada mapping
                    function (sUrl) {
                        if (sUrl.charAt(0) !== "#") {
                            sUrl = "#" + sUrl;
                        }
                        var pElement = this._pLinks[sUrl];
                        if (!((pElement) != null)) {
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 1943);
                                akra.logger.warning("cannot find element with id: " + sUrl + ("\n" + (new Error()).stack.split("\n").slice(1).join("\n")));
                            }
                            ;
                        }
                        return pElement || null;
                    };
                    Collada.prototype.link = function (el, pTarget) {
                        var sId;
                        if (!(typeof (arguments[0]) === "string")) {
                            pTarget = arguments[0];
                            sId = pTarget.id;
                        } else {
                            sId = arguments[0];
                        }
                        this._pLinks["#" + sId] = pTarget;
                    };
                    Collada.prototype.target = //astroBoy_newSkeleton_root/rotateY.ANGLE
                    //pObject.source: IColladaEntry = astroBoy_newSkeleton_root
                    //pSource: IColladaTransform = source(astroBoy_newSkeleton_root/rotateY)
                    //pSource: IColladaTransform = {
                    //    sid: string;  //rotateY
                    //    value: IVec4; //<0 1 0 -4.56752>
                    //    name: string; //rotate
                    //  }
                    //
                    //sValue: string = "ANGLE"
                    //pObject.object: IColladaTransform = pSource;
                    //
                    function (sPath) {
                        var pObject = {
                            value: null
                        };
                        var pSource;
                        var pMatches;
                        var sValue;
                        var iPos;
                        var jPos = 0;
                        iPos = sPath.lastIndexOf("/");
                        if (iPos >= 0) {
                            pObject.source = this.source(sPath.substr(0, iPos));
                        }
                        iPos = sPath.lastIndexOf(".");
                        if (iPos < 0) {
                            iPos = sPath.indexOf("(");
                            jPos = -1;
                        }
                        if (iPos < 0) {
                            pObject.object = this.source(sPath);
                            return pObject;
                        }
                        pSource = this.source(sPath.substr(0, iPos));
                        sValue = sPath.substr(iPos + jPos + 1);
                        pObject.object = pSource;
                        if (!pSource) {
                            return null;
                        }
                        switch(sValue) {
                            case "X":
                                pObject.value = (pSource.value).x;
                                break;
                            case "Y":
                                pObject.value = (pSource.value).y;
                                break;
                            case "Z":
                                pObject.value = (pSource.value).z;
                                break;
                            case "W":
                                pObject.value = (pSource.value).w;
                                break;
                            case "ANGLE":
                                pObject.value = (pSource.value).w;
                                //<rotate sid="rotateY">0 1 0 -4.56752</rotate>
                                break;
                        }
                        if (((pObject.value) != null)) {
                            return pObject;
                        }
                        pMatches = sValue.match(/^\((\d+)\)$/);
                        if (pMatches) {
                            pObject.value = Number(pMatches[1]);
                        }
                        pMatches = sValue.match(/^\((\d+)\)\((\d+)\)$/);
                        if (pMatches) {
                            //trace(pMatches, '--->',  Number(pMatches[2]) * 4 + Number(pMatches[1]));
                            //pObject.value = Number(pMatches[2]) * 4 + Number(pMatches[1]);
                            pObject.value = Number(pMatches[1]) * 4 + Number(pMatches[2]);
                        }
 {
                            akra.logger.setSourceLocation("resources/Collada.ts", 2049);
                            akra.logger.assert(((pObject.value) != null), "unsupported target value founded: " + sValue);
                        }
                        ;
                        return pObject;
                    };
                    Collada.prototype.buildAnimationTrack = // //animation
                    function (pChannel) {
                        var sNodeId = pChannel.target.source.id;
                        var sJoint = this.source(sNodeId).sid || null;
                        var pTrack = null;
                        var pSampler = pChannel.sampler;
 {
                            akra.logger.setSourceLocation("resources/Collada.ts", 2062);
                            akra.logger.assert(((pSampler) != null), "could not find sampler for animation channel");
                        }
                        ;
                        var pInput = pSampler.inputs["INPUT"];
                        var pOutput = pSampler.inputs["OUTPUT"];
                        var pInterpolation = pSampler.inputs["INTERPOLATION"];
                        var pTimeMarks = pInput.array;
                        var pOutputValues = pOutput.array;
                        var pFloatArray;
                        var pTransform = pChannel.target.object;
                        var sTransform = pTransform.transform;
                        var v4f;
                        var pValue;
                        var nMatrices;
                        // if (sJoint == null) {
                        //     warning('node\'s <' + pChannel.pTarget.pSource.id + '> "sid" attribute is null');
                        // }
                        switch(sTransform) {
                            case "translate":
                                // pTrack = new a.AnimationTranslation(sJoint);
                                // for (var i = 0, v3f = new Array(3), n; i < pTimeMarks.length; ++ i) {
                                //     n = i * 3;
                                //     v3f.X = pOutputValues[i * 3];
                                //     v3f.Y = pOutputValues[i * 3 + 1];
                                //     v3f.Z = pOutputValues[i * 3 + 2];
                                //     pTrack.keyFrame(pTimeMarks[i], [v3f.X, v3f.Y, v3f.Z]);
                                // };
                                 {
                                    akra.logger.setSourceLocation("resources/Collada.ts", 2093);
                                    akra.logger.criticalError("TODO: implement animation translation");
                                }
                                ;
                                //TODO: implement animation translation
                                break;
                            case "rotate":
                                // v4f = pTransform.pValue;
                                // pTrack = new a.AnimationRotation(sJoint, [v4f[1], v4f[2], v4f[3]]);
                                // debug_assert(pOutput.pAccessor.iStride === 1,
                                //     "matrix modification supported only for one parameter modification");
                                // for (var i = 0; i < pTimeMarks.length; ++ i) {
                                //     pTrack.keyFrame(pTimeMarks[i], pOutputValues[i] / 180.0 * math.PI);
                                // };
                                 {
                                    akra.logger.setSourceLocation("resources/Collada.ts", 2106);
                                    akra.logger.criticalError("TODO: implement animation rotation");
                                }
                                ;
                                //TODO: implement animation rotation
                                break;
                            case "matrix":
                                pValue = pChannel.target.value;
                                if (((pValue) === null)) {
                                    pTrack = akra.animation.createTrack(sJoint);
                                    nMatrices = pOutputValues.length / 16;
                                    pFloatArray = new Float32Array(pOutputValues);
 {
                                        akra.logger.setSourceLocation("resources/Collada.ts", 2117);
                                        akra.logger.assert(nMatrices % 1 === 0.0, "incorrect output length of transformation data (" + pFloatArray.length + ")");
                                    }
                                    ;
                                    for(var i = 0; i < nMatrices; i++) {
                                        pTrack.keyFrame(pTimeMarks[i], (new akra.Mat4(pFloatArray.subarray(i * 16, i * 16 + 16), true)).transpose());
                                    }
                                    // i=0;
                                    // var m = (new Mat4(pFloatArray.subarray(i * 16, i * 16 + 16), true));
                                    // trace(sFilename,sNodeId,m.toString());
                                                                    } else {
                                    // pTrack = new a.AnimationMatrixModification(sJoint, pValue);
                                    // for (var i = 0; i < pTimeMarks.length; ++i) {
                                    //     pTrack.keyFrame(pTimeMarks[i], pOutputValues[i]);
                                    // }
                                     {
                                        akra.logger.setSourceLocation("resources/Collada.ts", 2135);
                                        akra.logger.criticalError("TODO: implement animation matrix modification");
                                    }
                                    ;
                                }
                                break;
                            default:
 {
                                    akra.logger.setSourceLocation("resources/Collada.ts", 2139);
                                    akra.logger.error("unsupported animation typed founeed: " + sTransform);
                                }
                                ;
                        }
                        if (!((pTrack) === null)) {
                            pTrack.targetName = sNodeId;
                        }
                        return pTrack;
                    };
                    Collada.prototype.buildAnimationTrackList = function (pAnimationData) {
                        var pSubAnimations = pAnimationData.animations;
                        var pSubTracks;
                        var pTrackList = [];
                        var pTrack;
                        var pChannels = pAnimationData.channels;
                        for(var i = 0; i < pChannels.length; ++i) {
                            pTrack = this.buildAnimationTrack(pChannels[i]);
                            pTrackList.push(pTrack);
                        }
                        if (((pSubAnimations) != null)) {
                            for(var i = 0; i < pSubAnimations.length; ++i) {
                                pSubTracks = this.buildAnimationTrackList(pSubAnimations[i]);
                                pTrackList = pTrackList.concat(pSubTracks);
                            }
                        }
                        return pTrackList;
                    };
                    Collada.prototype.buildAnimation = function (pAnimationData) {
                        var pTracks = this.buildAnimationTrackList(pAnimationData);
                        var sAnimation = pAnimationData.name || pAnimationData.id || null;
                        var pAnimation = akra.animation.createAnimation(sAnimation || this.getBasename());
                        for(var i = 0; i < pTracks.length; i++) {
                            pAnimation.push(pTracks[i]);
                        }
                        return pAnimation;
                    };
                    Collada.prototype.buildAnimations = function (pAnimationsList) {
                        if (typeof pAnimationsList === "undefined") { pAnimationsList = []; }
                        var pAnimations = this.getAnimations();
                        if (((pAnimations) === null)) {
                            return null;
                        }
                        for(var i = 0; i < pAnimations.length; ++i) {
                            var pAnimation = this.buildAnimation(pAnimations[i]);
                            pAnimationsList.push(pAnimation);
                        }
                        return pAnimationsList;
                    };
                    Collada.prototype.buildAssetTransform = // common
                    function (pNode, pAsset) {
                        if (typeof pAsset === "undefined") { pAsset = null; }
                        pAsset = pAsset || this.getAsset();
                        if (((pAsset) != null)) {
                            var fUnit = pAsset.unit.meter;
                            var sUPaxis = pAsset.upAxis;
                            pNode.localScale = akra.Vec3.stackCeil.set(fUnit);
                            if (sUPaxis.toUpperCase() == "Z_UP") {
                                //pNode.addRelRotation([1, 0, 0], -.5 * math.PI);
                                pNode.addRelRotationByEulerAngles(0, -.5 * akra.math.PI, 0);
                            }
                        }
                        return pNode;
                    };
                    Collada.prototype.buildDeclarationFromAccessor = function (sSemantic, pAccessor) {
                        var pDecl = [];
                        for(var i = 0; i < pAccessor.params.length; ++i) {
                            var sUsage = pAccessor.params[i].name;
                            var sType = pAccessor.params[i].type;
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 2228);
                                akra.logger.assert(sType === "float", "Only float type supported for construction declaration from accessor");
                            }
                            ;
                            pDecl.push((({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((sUsage)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
})));
                        }
                        pDecl.push(({
count: (pAccessor.params.length),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (sSemantic),
offset: (0)
}));
 {
                            akra.logger.setSourceLocation("resources/Collada.ts", 2235);
                            akra.logger.log("Automatically constructed declaration: ", akra.createVertexDeclaration(pDecl).toString());
                        }
                        ;
                        return pDecl;
                    };
                    Collada.prototype.buildDefaultMaterials = // materials & meshes
                    function (pMesh) {
                        var pDefaultMaterial = akra.material.create("default");
                        for(var j = 0; j < pMesh.length; ++j) {
                            var pSubMesh = pMesh.getSubset(j);
                            pSubMesh.material.set(pDefaultMaterial);
                            // pSubMesh.renderMethod.effect.addComponent("akra.system.mesh_geometry", 0);
                            // pSubMesh.renderMethod.effect.addComponent("akra.system.mesh_geometry", 1);
                            pSubMesh.renderMethod.effect.addComponent("akra.system.mesh_texture");
                        }
                        return pMesh;
                    };
                    Collada.prototype.buildMaterials = function (pMesh, pGeometryInstance) {
                        var pMaterials = pGeometryInstance.material;
                        var pEffects = this.getLibrary("library_effects");
                        if (((pEffects) === null) || ((pMaterials) === null)) {
                            return this.buildDefaultMaterials(pMesh);
                        }
                        for(var sMaterial in pMaterials) {
                            var pMaterialInst = pMaterials[sMaterial];
                            var pInputMap = pMaterialInst.vertexInput;
                            // URL --> ID (#somebody ==> somebody)
                            var sEffectId = pMaterialInst.material.instanceEffect.effect.id;
                            var pEffect = pEffects.effect[sEffectId];
                            var pPhongMaterial = pEffect.profileCommon.technique.value;
                            var pMaterial = akra.material.create(sEffectId);
                            pMaterial.set(pPhongMaterial);
                            for(var j = 0; j < pMesh.length; ++j) {
                                var pSubMesh = pMesh.getSubset(j);
                                //if (pSubMesh.surfaceMaterial.findResourceName() === sMaterial) {
                                if (pSubMesh.material.name === sMaterial) {
                                    //setup materials
                                    pSubMesh.material.set(pMaterial);
                                    //FIXME: remove flex material setup(needs only demo with flexmats..)
                                    // pSubMesh.applyFlexMaterial(sMaterial, pMaterial);
                                    // pSubMesh.renderMethod.effect.addComponent("akra.system.mesh_geometry", 0);
                                    // pSubMesh.renderMethod.effect.addComponent("akra.system.mesh_geometry", 1);
                                    pSubMesh.renderMethod.effect.addComponent("akra.system.mesh_texture");
                                    // pSubMesh.renderMethod.effect.addComponent("akra.system.prepareForDeferredShading");
                                    //setup textures
                                    for(var sTextureType in pPhongMaterial.textures) {
                                        var pColladaTexture = pPhongMaterial.textures[sTextureType];
                                        if (((pColladaTexture) === null)) {
                                            continue;
                                        }
                                        var pInput = pInputMap[pColladaTexture.texcoord];
                                        if (!((pInput) != null)) {
                                            continue;
                                        }
                                        var sInputSemantics = pInputMap[pColladaTexture.texcoord].inputSemantic;
                                        var pColladaImage = pColladaTexture.image;
                                        var pSurfaceMaterial = pSubMesh.surfaceMaterial;
                                        var pTexture = (((((this).pResourcePool)).pManager)).texturePool.findResource(pColladaImage.path);
                                        if (this.getImageOptions().flipY === true) {
 {
                                                akra.logger.setSourceLocation("resources/Collada.ts", 2313);
                                                akra.logger.error("TODO: flipY for image unsupported!");
                                            }
                                            ;
                                        }
                                        var pMatches = sInputSemantics.match(/^(.*?\w)(\d+)$/i);
                                        var iTexCoord = (pMatches ? parseInt(pMatches[2]) : 0);
                                        var iTexture = akra.ESurfaceMaterialTextures[sTextureType.toUpperCase()];
                                        if (!((iTexture) !== undefined)) {
                                            continue;
                                        }
                                        // LOG(iTexture, sTextureType)
                                        pSurfaceMaterial.setTexture(iTexture, pTexture, iTexCoord);
                                        // LOG(pSurfaceMaterial);
                                                                            }
                                }
                            }
                            //trace('try to apply mat:', pMaterial);
                                                    }
                        return pMesh;
                    };
                    Collada.prototype.buildSkeleton = function (pSkeletonsList) {
                        var pSkeleton = null;
                        pSkeleton = akra.model.createSkeleton(pSkeletonsList[0]);
                        for(var i = 0; i < pSkeletonsList.length; ++i) {
                            var pJoint = (this.source(pSkeletonsList[i])).constructedNode;
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 2347);
                                akra.logger.assert(((pJoint).type == /*checked (origin: akra)>>*/akra.EEntityTypes.JOINT), "skeleton node must be joint");
                            }
                            ;
                            pSkeleton.addRootJoint(pJoint);
                        }
                        ((this)._pOptions.skeletons.push((pSkeleton)));
                        return pSkeleton;
                    };
                    Collada.prototype.buildMesh = function (pGeometryInstance) {
                        var pMesh = null;
                        var pGeometry = pGeometryInstance.geometry;
                        var pNodeData = pGeometry.mesh;
                        var sMeshName = pGeometry.id;
                        if (((pNodeData) === null)) {
                            return null;
                        }
                        if ((pMesh = this.findMesh(sMeshName))) {
                            //mesh with same geometry data
                            return this.buildMaterials(pMesh.clone(akra.EMeshCloneOptions.GEOMETRY_ONLY | akra.EMeshCloneOptions.SHARED_GEOMETRY), pGeometryInstance);
                        }
                        var iBegin = (Date.now());
                        pMesh = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.getEngine().createMesh(sMeshName, /*|EMeshOptions.RD_ADVANCED_INDEX,  0,*/
                        (akra.EMeshOptions.HB_READABLE), /*shared buffer, if supported*/
                        this.sharedBuffer());
                        var pPolyGroup = pNodeData.polygons;
                        var pMeshData = pMesh.data;
                        //creating subsets
                        for(var i = 0; i < pPolyGroup.length; ++i) {
                            pMesh.createSubset("submesh-" + i, this.isWireframeEnabled() ? akra.EPrimitiveTypes.LINELIST : pPolyGroup[i].type);
                        }
                        //filling data
                        for(var i = 0, pUsedSemantics = {}; i < pPolyGroup.length; ++i) {
                            var pPolygons = pPolyGroup[i];
                            for(var j = 0; j < pPolygons.inputs.length; ++j) {
                                var pInput = pPolygons.inputs[j];
                                var sSemantic = pInput.semantics;
                                var pData = pInput.array;
                                var pDecl;
                                var pDataExt;
                                //if (pMesh.buffer.getDataLocation(sSemantic) < 0) {
                                if (!pUsedSemantics[sSemantic]) {
                                    pUsedSemantics[sSemantic] = true;
                                    switch(sSemantic) {
                                        case akra.DeclUsages.POSITION:
                                        case akra.DeclUsages.NORMAL:
                                            /*
                                            Extend POSITION and NORMAL from {x,y,z} --> {x,y,z,w};
                                            */
                                            pDataExt = new Float32Array((pData).length / 3 * 4);
                                            for(var y = 0, n = 0, m = 0, l = (pData).length / 3; y < l; y++, n++) {
                                                pDataExt[n++] = pData[m++];
                                                pDataExt[n++] = pData[m++];
                                                pDataExt[n++] = pData[m++];
                                            }
                                            pData = pDataExt;
                                            pDecl = [
                                                (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((sSemantic)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
})), 
                                                (({
count: (0),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.UNSIGNED_BYTE),
usage: (/*checked (origin: akra)>>*/akra.DeclUsages.END),
offset: ((16))
}))
                                            ];
                                            break;
                                        case akra.DeclUsages.TEXCOORD:
                                        case akra.DeclUsages.TEXCOORD1:
                                        case akra.DeclUsages.TEXCOORD2:
                                        case akra.DeclUsages.TEXCOORD3:
                                        case akra.DeclUsages.TEXCOORD4:
                                        case akra.DeclUsages.TEXCOORD5:
                                            //avoiding semantics collisions
                                            if (sSemantic === "TEXCOORD") {
                                                sSemantic = "TEXCOORD0";
                                            }
                                            pDecl = [
                                                ({
count: (pInput.accessor.stride),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (sSemantic),
offset: (/*checked (origin: akra)>>*/akra.MAX_INT32)
})
                                            ];
                                            break;
                                        default:
                                            pDecl = this.buildDeclarationFromAccessor(sSemantic, pInput.accessor);
 {
                                                akra.logger.setSourceLocation("resources/Collada.ts", 2439);
                                                akra.logger.warning("unsupported semantics used: " + sSemantic);
                                            }
                                            ;
                                    }
                                    pMeshData.allocateData(pDecl, pData);
                                }
                            }
                        }
                        //add indices to data
                        for(var i = 0; i < pPolyGroup.length; ++i) {
                            var pPolygons = pPolyGroup[i];
                            var pSubMesh = pMesh.getSubset(i);
                            var pSubMeshData = pSubMesh.data;
                            var pIndexDecl = akra.createVertexDeclaration();
                            var pSurfaceMaterial = null;
                            var pSurfacePool = null;
                            for(var j = 0; j < pPolygons.inputs.length; ++j) {
                                var iOffset = pPolygons.inputs[j].offset;
                                var sIndexSemantic = akra.DeclUsages.INDEX + iOffset;
                                //total number of offsets can be less then number of inputs
                                if (!pIndexDecl.hasSemantics(sIndexSemantic)) {
                                    pIndexDecl.append((({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((sIndexSemantic)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
})));
                                }
                            }
                            pSubMeshData.allocateIndex(pIndexDecl, new Float32Array(pPolygons.p));
                            for(var j = 0; j < pPolygons.inputs.length; ++j) {
                                var sSemantic = pPolygons.inputs[j].semantics;
                                var sIndexSemantics = akra.DeclUsages.INDEX + pPolygons.inputs[j].offset;
                                pSubMeshData.index(sSemantic, sIndexSemantics);
                            }
                            // if (!pSubMesh.material) {
                            //     pSurfacePool = pEngine.getResourceManager().surfaceMaterialPool;
                            //     pSurfaceMaterial = pSurfacePool.findResource(pPolygons.material);
                            //     if (!pSurfaceMaterial) {
                            //         pSurfaceMaterial = pSurfacePool.createResource(pPolygons.material);
                            //     }
                            //     pSubMesh.surfaceMaterial = pSurfaceMaterial;
                            // }
                            pSubMesh.material.name = pPolygons.material;
                        }
 {
                            akra.logger.setSourceLocation("resources/Collada.ts", 2488);
                            akra.logger.assert(pMesh.addFlexMaterial("default"), "Could not add flex material to mesh <" + pMesh.name + ">");
                        }
                        ;
 {
                            akra.logger.setSourceLocation("resources/Collada.ts", 2489);
                            akra.logger.assert(pMesh.setFlexMaterial("default"), "Could not set flex material to mesh <" + pMesh.name + ">");
                        }
                        ;
                        //adding all data to cahce data
                        this.addMesh(pMesh);
                        return this.buildMaterials(pMesh, pGeometryInstance);
                    };
                    Collada.prototype.buildSkinMesh = function (pControllerInstance) {
                        var pController = pControllerInstance.controller;
                        var pMaterials = pControllerInstance.material;
                        var pSkinData = pController.skin;
                        //skin data
                        var pBoneList = pSkinData.joints.inputs["JOINT"].array;
                        var pBoneOffsetMatrices = pSkinData.joints.inputs["INV_BIND_MATRIX"].array;
                        var m4fBindMatrix = pSkinData.shapeMatrix;
                        var pVertexWeights = pSkinData.vertexWeights;
                        var pGeometry = pSkinData.geometry;
                        var pMesh;
                        var pSkeleton;
                        var pSkin;
                        pSkeleton = this.buildSkeleton(pControllerInstance.skeletons);
                        pMesh = this.buildMesh({
                            geometry: pGeometry,
                            material: pMaterials
                        });
                        pSkin = pMesh.createSkin();
                        pSkin.setBindMatrix(m4fBindMatrix);
                        pSkin.setBoneNames(pBoneList);
                        pSkin.setBoneOffsetMatrices(pBoneOffsetMatrices);
 {
                            akra.logger.setSourceLocation("resources/Collada.ts", 2525);
                            akra.logger.assert(pSkin.setSkeleton(pSkeleton), "Could not set skeleton to skin.");
                        }
                        ;
                        if (!pSkin.setVertexWeights(pVertexWeights.vcount, new Float32Array(pVertexWeights.v), new Float32Array(pVertexWeights.weightInput.array))) {
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 2531);
                                akra.logger.error("cannot set vertex weight info to skin");
                            }
                            ;
                        }
                        pMesh.setSkin(pSkin);
                        pMesh.setSkeleton(pSkeleton);
                        pSkeleton.attachMesh(pMesh);
                        return pMesh;
                    };
                    Collada.prototype.buildSkinMeshInstance = function (pControllers, pSceneNode) {
                        if (typeof pSceneNode === "undefined") { pSceneNode = null; }
                        var pMesh = null;
                        var pMeshList = [];
                        for(var m = 0; m < pControllers.length; ++m) {
                            pMesh = this.buildSkinMesh(pControllers[m]);
                            pMeshList.push(pMesh);
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 2550);
                                akra.logger.assert(((pMesh) != null), "cannot find instance <" + pControllers[m].url + ">\"s data");
                            }
                            ;
                            if (!((pSceneNode) === null)) {
                                pSceneNode.mesh = pMesh;
                            }
                        }
                        return pMeshList;
                    };
                    Collada.prototype.buildMeshInstance = function (pGeometries, pSceneNode) {
                        if (typeof pSceneNode === "undefined") { pSceneNode = null; }
                        var pMesh = null;
                        var pMeshList = [];
                        for(var m = 0; m < pGeometries.length; ++m) {
                            pMesh = this.buildMesh(pGeometries[m]);
                            pMeshList.push(pMesh);
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 2568);
                                akra.logger.assert(((pMesh) != null), "cannot find instance <" + pGeometries[m].url + ">\"s data");
                            }
                            ;
                            if (!((pSceneNode) === null)) {
                                pSceneNode.mesh = pMesh;
                            }
                        }
                        return pMeshList;
                    };
                    Collada.prototype.buildMeshes = function () {
                        var pScene = this.getVisualScene();
                        var pMeshes = [];
                        this.findNode(pScene.nodes, null, function (pNode) {
                            var pModelNode = pNode.constructedNode;
                            if (((pModelNode) === null)) {
 {
                                    akra.logger.setSourceLocation("resources/Collada.ts", 2586);
                                    akra.logger.error("you must call buildScene() before call buildMeshes() or file corrupt");
                                }
                                ;
                                return;
                            }
                            if (pNode.controller.length == 0 && pNode.geometry.length == 0) {
                                return;
                            }
                            if (!((pModelNode).type === /*checked (origin: akra)>>*/akra.EEntityTypes.MODEL) && pNode.geometry.length > 0) {
                                pModelNode = pModelNode.scene.createModel(".joint-to-model-link-" + akra.sid());
                                pModelNode.attachToParent(pNode.constructedNode);
                            }
                            pMeshes.insert(this.buildSkinMeshInstance(pNode.controller));
                            pMeshes.insert(this.buildMeshInstance(pNode.geometry, pModelNode));
                        });
                        return pMeshes;
                    };
                    Collada.prototype.buildSceneNode = // scene
                    function (pNode, pParentNode) {
                        var pSceneNode = pNode.constructedNode;
                        var pScene = pParentNode.scene;
                        if (((pSceneNode) != null)) {
                            return pSceneNode;
                        }
                        //FIXME: предпологаем, что мы никогда не аттачим контроллеры к узлам,
                        // где они найдены, а аттачим  их к руту скелета, на который они ссылаются
                        /*pNode.pController.length ||*/
                        if (pNode.geometry.length > 0) {
                            pSceneNode = pScene.createModel();
                        } else {
                            pSceneNode = pScene.createNode();
                        }
 {
                            akra.logger.setSourceLocation("resources/Collada.ts", 2625);
                            akra.logger.assert(pSceneNode.create(), "Can not initialize scene node!");
                        }
                        ;
                        pSceneNode.attachToParent(pParentNode);
                        return pSceneNode;
                    };
                    Collada.prototype.buildJointNode = function (pNode, pParentNode) {
                        var pJointNode = pNode.constructedNode;
                        var sJointSid = pNode.sid;
                        var sJointName = pNode.id;
                        var pSkeleton;
 {
                            akra.logger.setSourceLocation("resources/Collada.ts", 2638);
                            akra.logger.assert(((pParentNode) != null), "parent node is null");
                        }
                        ;
                        if (((pJointNode) != null)) {
                            return pJointNode;
                        }
                        if (((pParentNode) === null)) {
                            return null;
                        }
                        pJointNode = pParentNode.scene.createJoint();
 {
                            akra.logger.setSourceLocation("resources/Collada.ts", 2650);
                            akra.logger.assert(pJointNode.create(), "Can not initialize joint node!");
                        }
                        ;
                        pJointNode.boneName = sJointSid;
                        pJointNode.attachToParent(pParentNode);
                        if (this.isJointsVisualizationNeeded()) {
                            //draw joints
                            // var pSceneNode: ISceneModel = pEngine.appendMesh(
                            //     pEngine.pCubeMesh.clone(a.Mesh.GEOMETRY_ONLY | a.Mesh.SHARED_GEOMETRY),
                            //     pJointNode);
                            // pSceneNode.name = sJointName + '[joint]';
                            // pSceneNode.setScale(0.02);
                             {
                                akra.logger.setSourceLocation("resources/Collada.ts", 2663);
                                akra.logger.criticalError("TODO: visualize joints...");
                            }
                            ;
                        }
                        return pJointNode;
                    };
                    Collada.prototype.buildCamera = function (pColladaInstanceCamera, pParent) {
                        var pColladaCamera = pColladaInstanceCamera.camera;
                        var pCamera = pParent.scene.createCamera(pColladaCamera.name || pColladaCamera.id || null);
                        pCamera.setInheritance(akra.ENodeInheritance.ALL);
                        pCamera.attachToParent(pParent);
                        var pPerspective = pColladaCamera.optics.techniqueCommon.perspective;
                        if (!((pPerspective) === null)) {
                            pCamera.setProjParams(pPerspective.xfov, pPerspective.aspect, pPerspective.znear, //FIX far plane distance
                            pPerspective.zfar * (1 / this.getAsset().unit.meter));
                        }
                        return pCamera;
                    };
                    Collada.prototype.buildNodes = function (pNodes, pParentNode) {
                        if (typeof pParentNode === "undefined") { pParentNode = null; }
                        if (((pNodes) === null)) {
                            return null;
                        }
                        var pNode = null;
                        var pHierarchyNode = null;
                        var m4fLocalMatrix = null;
                        for(var i = pNodes.length - 1; i >= 0; i--) {
                            pNode = pNodes[i];
                            if (!((pNode) != null)) {
                                continue;
                            }
                            if (pNode.type === "JOINT") {
                                pHierarchyNode = this.buildJointNode(pNode, pParentNode);
                            } else {
                                pHierarchyNode = this.buildSceneNode(pNode, pParentNode);
                            }
                            pHierarchyNode.name = (pNode.id || pNode.name);
                            pHierarchyNode.setInheritance(akra.ENodeInheritance.ALL);
                            //cache already constructed nodes
                            pNode.constructedNode = pHierarchyNode;
                            pHierarchyNode.localMatrix = pNode.transform;
                            this.buildNodes(pNode.childNodes, pHierarchyNode);
                            if (pNode.camera.length > 0) {
                                for(var c = 0; c < pNode.camera.length; ++c) {
                                    var pColladaCamera = pNode.camera[c];
                                    var pCamera = this.buildCamera(pColladaCamera, pHierarchyNode);
                                }
                            }
                        }
                        return pHierarchyNode;
                    };
                    Collada.prototype.buildScene = function (pRootNode) {
                        var pScene = this.getVisualScene();
                        var pAsset = this.getAsset();
                        var pNodes = [];
                        var pNode = null;
                        for(var i = 0; i < pScene.nodes.length; i++) {
                            pNode = pScene.nodes[i];
                            pNodes.push(this.buildNodes([
                                pNode
                            ], pRootNode));
                        }
                        for(var i = 0; i < pNodes.length; i++) {
                            pNodes[i] = this.buildAssetTransform(pNodes[i]);
                        }
                        return pNodes;
                    };
                    Collada.prototype.buildInititalPose = function (pNodes, pSkeleton) {
                        var sPose = "Pose-" + this.getBasename() + "-" + pSkeleton.name;
                        var pPose = akra.animation.createAnimation(sPose);
                        var pNodeList = pSkeleton.getNodeList();
                        var pNodeMap = {};
                        var pTrack;
                        for(var i = 0; i < pNodeList.length; ++i) {
                            pNodeMap[pNodeList[i].name] = pNodeList[i];
                        }
                        this.findNode(pNodes, null, function (pNode) {
                            var sJoint = pNode.sid;
                            var sNodeId = pNode.id;
                            if (!((pNodeMap[sNodeId]) != null)) {
                                return;
                            }
                            pTrack = akra.animation.createTrack(sJoint);
                            pTrack.targetName = sNodeId;
                            pTrack.keyFrame(0.0, pNode.transform);
                            pPose.push(pTrack);
                        });
                        return pPose;
                    };
                    Collada.prototype.buildInitialPoses = function (pPoseSkeletons) {
                        if (typeof pPoseSkeletons === "undefined") { pPoseSkeletons = null; }
                        if (!this.isVisualSceneLoaded()) {
                            this.COLLADAScene();
                        }
                        pPoseSkeletons = pPoseSkeletons || this.getSkeletonsOutput();
                        if (((pPoseSkeletons) === null)) {
                            return null;
                        }
                        var pScene = this.getVisualScene();
                        var pSkeleton;
                        var pPoses = [];
                        for(var i = 0; i < pPoseSkeletons.length; ++i) {
                            pSkeleton = pPoseSkeletons[i];
                            // if (pSkeleton.name === "node-Bip001_Pelvis" || pSkeleton.name === "node-Bip001") {
                            //     trace('skipping <node-Bip001_Pelvis> skeleto, ...', '[' + sBasename + ']');
                            //     trace(pSkeleton.getNodeList()[0].localMatrix().toQuat4().toYawPitchRoll(Vec3()).toString());
                            //     continue;
                            // }
                            pPoses.push(this.buildInititalPose(pScene.nodes, pSkeleton));
                        }
                        // LOG(pPoses);
                        return pPoses;
                    };
                    Collada.prototype.buildComplete = // additional
                    function () {
                        var pScene = this.getVisualScene();
                        if (((pScene) === null)) {
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 2818);
                                akra.logger.warning("build complete, but visual scene not parsed correctly!");
                            }
                            ;
                            return;
                        }
                        //release all links to constructed nodes
                        this.findNode(pScene.nodes, null, function (pNode) {
                            pNode.constructedNode = null;
                        });
                    };
                    Collada.prototype.setOptions = function (pOptions) {
                        if (((pOptions) === null)) {
                            pOptions = Collada.DEFAULT_OPTIONS;
                        }
                        for(var i in Collada.DEFAULT_OPTIONS) {
                            if (((pOptions[i]) !== undefined)) {
                                continue;
                            }
                            pOptions[i] = Collada.DEFAULT_OPTIONS[i];
                        }
                        this._pOptions = pOptions;
                    };
                    Collada.prototype.setXMLRoot = function (pXML) {
                        this._pXMLRoot = pXML;
                    };
                    Collada.prototype.getXMLRoot = function () {
                        return this._pXMLRoot;
                    };
                    Collada.prototype.findMesh = function (sName) {
                        return this._pCache.meshMap[sName] || null;
                    };
                    Collada.prototype.addMesh = function (pMesh) {
                        this._pCache.meshMap[pMesh.name] = pMesh;
                        this.sharedBuffer(pMesh.data);
                    };
                    Collada.prototype.sharedBuffer = function (pBuffer) {
                        if (((pBuffer) != null)) {
                            this._pCache.sharedBuffer = pBuffer;
                        }
                        return null;
                        // return this._pOptions.sharedBuffer ? pCache.sharedBuffer : null;
                                            };
                    Collada.prototype.prepareInput = function (pInput) {
                        var pSupportedFormat = getSupportedFormat(pInput.semantics);
 {
                            akra.logger.setSourceLocation("resources/Collada.ts", 2872);
                            akra.logger.assert(((pSupportedFormat) != null), "unsupported semantic used <" + pInput.semantics + ">");
                        }
                        ;
                        pInput.array = this.COLLADAGetSourceData(pInput.source, pSupportedFormat);
                        pInput.accessor = pInput.source.techniqueCommon.accessor;
                        return pInput;
                    };
                    Collada.prototype.isJointsVisualizationNeeded = /** @inline */function () {
                        return this._pOptions.drawJoints === true;
                    };
                    Collada.prototype.isVisualSceneLoaded = /** @inline */function () {
                        return ((this._pVisualScene) != null);
                    };
                    Collada.prototype.isAnimationLoaded = /** @inline */function () {
                        return this._pAnimations.length > 0;
                    };
                    Collada.prototype.isSceneNeeded = /** @inline */function () {
                        return this._pOptions.scene === true;
                    };
                    Collada.prototype.isAnimationNeeded = /** @inline */function () {
                        return ((this._pOptions.animation) != null) && this._pOptions.animation !== false;
                    };
                    Collada.prototype.isPoseExtractionNeeded = /** @inline */function () {
                        return this._pOptions.extractPoses === true;
                    };
                    Collada.prototype.isWireframeEnabled = /** @inline */function () {
                        return this._pOptions.wireframe === true;
                    };
                    Collada.prototype.getSkeletonsOutput = /** @inline */function () {
                        return this._pOptions.skeletons || null;
                    };
                    Collada.prototype.addSkeleton = /** @inline */function (pSkeleton) {
                        this._pOptions.skeletons.push(pSkeleton);
                    };
                    Collada.prototype.getImageOptions = /** @inline */function () {
                        return this._pOptions.images;
                    };
                    Collada.prototype.getVisualScene = /** @inline */function () {
                        return this._pVisualScene;
                    };
                    Collada.prototype.getAnimations = /** @inline */function () {
                        return this._pAnimations;
                    };
                    Collada.prototype.getAnimation = /** @inline */function (i) {
                        return this._pAnimations[i] || null;
                    };
                    Collada.prototype.getAsset = /** @inline */function () {
                        return this._pAsset;
                    };
                    Collada.prototype.isLibraryLoaded = /** @inline */function (sLib) {
                        return ((this._pLib[sLib]) != null);
                    };
                    Collada.prototype.isLibraryExists = /** @inline */function (sLib) {
                        return !((firstChild(this.getXMLRoot(), "library_animations")) === null);
                    };
                    Collada.prototype.getLibrary = /** @inline */function (sLib) {
                        return this._pLib[sLib] || null;
                    };
                    Collada.prototype.getBasename = /** @inline */function () {
                        return akra.util.pathinfo(this._pOptions.name || this._sFilename || "unknown").basename;
                    };
                    Collada.prototype.getFilename = /** @inline */function () {
                        return this._sFilename;
                    };
                    Collada.prototype.setFilename = /** @inline */function (sName) {
                        this._sFilename = sName;
                    };
                    Collada.prototype.readLibraries = function (pXML, pTemplates) {
                        var pLibraries = this._pLib;
                        for(var i = 0; i < pTemplates.length; i++) {
                            var sLib = pTemplates[i].lib;
                            pLibraries[sLib] = this.COLLADALibrary(firstChild(pXML, sLib), pTemplates[i]);
                        }
                    };
                    Collada.prototype.checkLibraries = function (pXML, pTemplates) {
                        var pLibraries = this._pLib;
                        for(var i = 0; i < pTemplates.length; i++) {
                            var sLib = pTemplates[i].lib;
                            if (((firstChild(pXML, sLib)) != null)) {
                                pLibraries[sLib] = null;
                            }
                        }
                    };
                    Object.defineProperty(Collada.prototype, "byteLength", {
                        get: /** @inline */function () {
                            return this._iByteLength;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Collada.prototype.parse = function (sXMLData, pOptions) {
                        if (typeof pOptions === "undefined") { pOptions = null; }
                        if (((sXMLData) === null)) {
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 2987);
                                akra.logger.error("must be specified collada content.");
                            }
                            ;
                            return false;
                        }
                        // console.log("before dom parser creation...");
                        var pParser = new DOMParser();
                        // LOG(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                        var pXMLDocument = pParser.parseFromString(sXMLData, "application/xml");
                        // LOG("<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
                        var pXMLRoot = pXMLDocument.getElementsByTagName("COLLADA")[0];
                        this.setOptions(pOptions);
                        this.setXMLRoot(pXMLRoot);
                        this.checkLibraries(pXMLRoot, Collada.SCENE_TEMPLATE);
                        this.checkLibraries(pXMLRoot, Collada.ANIMATION_TEMPLATE);
                        this.readLibraries(pXMLRoot, Collada.SCENE_TEMPLATE);
                        this.COLLADAAsset();
                        this.COLLADAScene();
                        if (this.isAnimationNeeded()) {
                            this.readLibraries(pXMLRoot, Collada.ANIMATION_TEMPLATE);
                        }
                        return true;
                    };
                    Collada.prototype.loadResource = function (sFilename, pOptions) {
                        if (typeof sFilename === "undefined") { sFilename = null; }
                        if (typeof pOptions === "undefined") { pOptions = null; }
                        if (((sFilename) === null)) {
                            sFilename = this.findResourceName();
                        }
                        if (((((((this).iResourceFlags) & ((1 << ((/*checked (origin: akra)>>*/akra.EResourceItemEvents.LOADED))))) != 0)))) {
 {
                                akra.logger.setSourceLocation("resources/Collada.ts", 3022);
                                akra.logger.warning("collada model already loaded");
                            }
                            ;
                            return false;
                        }
                        var pModel = this;
                        this.setFilename(sFilename);
                        /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyDisabled();
                        /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyUnloaded();
                        var pFile = akra.io.fopen(sFilename);
                        pFile.open(function (err, meta) {
                            (pModel)["_iByteLength"] = meta.size || 0;
                        });
                        pFile.read(function (pErr, sXML) {
                            if (!((pErr) === null)) {
 {
                                    akra.logger.setSourceLocation("resources/Collada.ts", 3041);
                                    akra.logger.error(pErr);
                                }
                                ;
                            }
                            /*not inlined, because first statement is not return/call/dot(cur st.: If)*/pModel.notifyRestored();
                            if (pModel.parse(sXML, pOptions)) {
                                // pModel.notifyLoaded();
                                pModel.setResourceFlag(akra.EResourceItemEvents.LOADED, true);
                                // LOG(pModel.findResourceName(), pModel.isResourceLoaded());
                                 {
                                    akra.logger.setSourceLocation("resources/Collada.ts", 3051);
                                    akra.logger.log(pModel.findResourceName(), "[snced to: ", pModel.isSyncedTo(akra.EResourceItemEvents.LOADED), "]");
                                }
                                ;
                                if (pModel.isSyncedTo(akra.EResourceItemEvents.LOADED)) {
                                    pModel.setChangesNotifyRoutine(function (eFlag, iResourceFlags, isSet) {
                                        if (eFlag === akra.EResourceItemEvents.LOADED && isSet) {
                                            // LOG("!!!!!!!!!!!!!!!!!!", pModel.findResourceName(), "LOADED!!!");
                                            pModel.loaded();
                                        }
                                    });
                                } else {
                                    // LOG("!!!!!!!!!!!!!!!!!!", pModel.findResourceName(), "LOADED!!!");
                                    pModel.loaded();
                                }
                            }
                        });
                        return true;
                    };
                    Collada.prototype.attachToScene = function (parent) {
                        var pScene;
                        var pNode;
                        var pRoot;
                        var pSceneOutput = null;
                        // var pAnimationOutput: IAnimation[] = null;
                        var pMeshOutput = null;
                        // var pInitialPosesOutput: IAnimation[] = null;
                        if (((parent) === null)) {
                            return null;
                        }
                        if (parent instanceof akra.scene.Node) {
                            //attach collada scene to give node
                            pNode = parent;
                            pScene = pNode.scene;
                        } else {
                            //attaching collada scene to new node, that is child of scene root
                            pScene = parent;
                            pNode = pScene.getRootNode();
                        }
                        pRoot = pScene._createModelEntry(this);
                        pRoot.create();
                        pRoot.name = this.getBasename();
                        pRoot.setInheritance(akra.ENodeInheritance.ALL);
                        if (!pRoot.attachToParent(pNode)) {
                            return null;
                        }
                        if (this.isVisualSceneLoaded() && this.isSceneNeeded()) {
                            pSceneOutput = this.buildScene(pRoot);
                            pMeshOutput = this.buildMeshes();
                        }
                        // if (this.isPoseExtractionNeeded()) {
                        //     pInitialPosesOutput = this.buildInitialPoses();
                        // }
                        //pAnimationOutput = this.extractAnimations();
                        // if (isNull(pController)) {
                        //     pController = this.getEngine().createAnimationController();
                        // }
                        // if (!isNull(pController) && !isNull(pAnimationOutput)) {
                        //     for (var i: int = 0; i < pAnimationOutput.length; ++ i) {
                        //         pController.addAnimation(pAnimationOutput[i]);
                        //     }
                        //     pController.attach(pRoot);
                        // }
                        //clear all links from collada nodes to scene nodes
                        this.buildComplete();
                        return pRoot;
                    };
                    Collada.prototype.extractAnimation = function (i) {
                        var pPoses;
                        var pSkeletons, pSkeleton;
                        var pAnimation = null;
                        var pData = this.getAnimation(i);
                        if (!((pData) === null) && this.isAnimationNeeded() && this.isLibraryExists("library_animations")) {
                            pAnimation = this.buildAnimation(pData);
                            //дополним анимации начальными позициями костей
                            if (this.isPoseExtractionNeeded()) {
                                pSkeletons = this.getSkeletonsOutput() || [];
                                pPoses = this.buildInitialPoses(pSkeletons);
                                for(var j = 0; j < pPoses.length; ++j) {
                                    pAnimation.extend(pPoses[j]);
                                }
                            }
                        }
                        return pAnimation;
                    };
                    Collada.prototype.extractAnimations = function () {
                        var pPoses;
                        var pSkeletons, pSkeleton;
                        var pAnimationOutput = null;
                        if (this.isAnimationNeeded() && this.isLibraryExists("library_animations")) {
                            pAnimationOutput = this.buildAnimations();
                            //дополним анимации начальными позициями костей
                            if (this.isPoseExtractionNeeded()) {
                                pSkeletons = this.getSkeletonsOutput() || [];
                                /*
                                
                                // добавим к начальным позам, те, в которых находятся меши
                                // в момент выгрузки
                                if (!isNull(pMeshOutput)) {
                                for (var i = 0; i < pMeshOutput.length; ++ i) {
                                pSkeletons.push(pMeshOutput[i].skeleton);
                                }
                                }
                                else {
                                //необхоимо для посчета ссылочной информации
                                if (isNull(pSceneOutput)) {
                                this.buildScene();
                                }
                                
                                this.eachByTag(pXMLRoot, "skeleton", function (pXML: Node) {
                                pSkeletons.push(this.buildSkeleton([stringData(pXML)]));
                                });
                                }
                                
                                */
                                pPoses = this.buildInitialPoses(pSkeletons);
                                for(var i = 0; i < pAnimationOutput.length; ++i) {
                                    for(var j = 0; j < pPoses.length; ++j) {
                                        pAnimationOutput[i].extend(pPoses[j]);
                                    }
                                }
                            }
                        }
                        return pAnimationOutput;
                    };
                    return Collada;
                })(pool.ResourcePoolItem);
                resources.Collada = Collada;                
                pSupportedVertexFormat = [
                    {
                        name: [
                            "X"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "Y"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "Z"
                        ],
                        type: [
                            "float"
                        ]
                    }
                ];
                pSupportedTextureFormat = [
                    {
                        name: [
                            "S"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "T"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "P"
                        ],
                        type: [
                            "float"
                        ]
                    }
                ];
                pSupportedColorFormat = [
                    {
                        name: [
                            "R"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "G"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "B"
                        ],
                        type: [
                            "float"
                        ]
                    }
                ];
                pSupportedWeightFormat = [
                    {
                        name: [
                            "WEIGHT"
                        ],
                        type: [
                            "float"
                        ]
                    }
                ];
                pSupportedJointFormat = [
                    {
                        name: [
                            "JOINT"
                        ],
                        type: [
                            "Name", 
                            "IDREF"
                        ]
                    }
                ];
                pSupportedInvBindMatrixFormat = [
                    {
                        name: [
                            "TRANSFORM"
                        ],
                        type: [
                            "float4x4"
                        ]
                    }
                ];
                pSupportedInterpolationFormat = [
                    {
                        name: [
                            "INTERPOLATION"
                        ],
                        type: [
                            "Name"
                        ]
                    }
                ];
                pSupportedInputFormat = [
                    {
                        name: [
                            "TIME"
                        ],
                        type: [
                            "float"
                        ]
                    }
                ];
                pSupportedOutputFormat = [
                    {
                        name: [
                            "TRANSFORM", 
                            "X", 
                            "ANGLE", 
                            null
                        ],
                        type: [
                            "float4x4", 
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "Y"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "Z"
                        ],
                        type: [
                            "float"
                        ]
                    }
                ];
                pSupportedTangentFormat = [
                    {
                        name: [
                            "X"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "Y"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "X"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "Y"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "X"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "Y"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "X"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "Y"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "X"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "Y"
                        ],
                        type: [
                            "float"
                        ]
                    }
                ];
                pFormatStrideTable = {
                    "float": 1,
                    "float2": 2,
                    "float3": 3,
                    "float4": 4,
                    "float3x3": 9,
                    "float4x4": 16,
                    "int": 1,
                    "name": 1,
                    "Name": 1,
                    "IDREF": 1
                };
                pConvFormats = {
                    "int": {
                        type: Int32Array,
                        converter: string2IntArray
                    },
                    "float": {
                        type: Float32Array,
                        converter: string2FloatArray
                    },
                    "bool": {
                        type: Array,
                        converter: string2BoolArray
                    },
                    "string": {
                        type: Array,
                        converter: string2StringArray
                    }
                };
                /* COMMON FUNCTIONS
                ------------------------------------------------------
                */
                function getSupportedFormat(sSemantics) {
                    switch(sSemantics) {
                        case "TEXTANGENT":
                        case "TEXBINORMAL":
                        case "VERTEX":
                        case "NORMAL":
                        case "TANGENT":
                        case "BINORMAL":
                        case "POSITION":
                            return pSupportedVertexFormat;
                        case "TEXCOORD":
                            return pSupportedTextureFormat;
                        case "WEIGHT":
                            return pSupportedWeightFormat;
                        case "JOINT":
                            return pSupportedJointFormat;
                        case "INV_BIND_MATRIX":
                            return pSupportedInvBindMatrixFormat;
                        case "INTERPOLATION":
                            return pSupportedInterpolationFormat;
                        case "IN_TANGENT":
                            return pSupportedTangentFormat;
                        case "INPUT":
                            return pSupportedInputFormat;
                        case "OUT_TANGENT":
                            return pSupportedTangentFormat;
                        case "OUTPUT":
                            return pSupportedOutputFormat;
                        case "COLOR":
                            return pSupportedColorFormat;
                        case "UV":
                        case "MORPH_WEIGHT":
                        case "MORPH_TARGET":
                        case "LINEAR_STEPS":
                        case "IMAGE":
                        case "CONTINUITY":
                            return null;
                    }
 {
                        akra.logger.setSourceLocation("resources/Collada.ts", 3343);
                        akra.logger.error("unknown semantics founded: " + sSemantics);
                    }
                    ;
                    return null;
                }
                function calcFormatStride(pFormat) {
                    var iStride = 0;
                    var s = null;
                    for(var i = 0; i < pFormat.length; ++i) {
                        s = pFormat[i].type[0];
                        iStride += pFormatStrideTable[s];
                    }
                    return iStride;
                }
                // data convertion
                /** @inline */function parseBool(sValue) {
                    return (sValue === "true");
                }
                /** @inline */function parseString(sValue) {
                    return String(sValue);
                }
                /**
                * Получить часть данных массива
                * @param pSrc
                * @param pDst
                * @param iStride шаг (количество элементов в шаге)
                * @param iFrom номер элемента с которого начинать
                * @param iCount сколько элементов надо получить
                * @param iOffset смещение внутри шага (в элементах)
                * @param iLen количество элементов в шаге.
                */
                function retrieve(pSrc, pDst, iStride, iFrom, iCount, iOffset, iLen) {
                    if (typeof iStride === "undefined") { iStride = 1; }
                    if (typeof iFrom === "undefined") { iFrom = 0; }
                    if (typeof iOffset === "undefined") { iOffset = 0; }
                    if (typeof iLen === "undefined") { iLen = iStride - iOffset; }
                    if (!((iCount) !== undefined)) {
                        iCount = (pSrc.length / iStride - iFrom);
                    }
                    if (iOffset + iLen > iStride) {
                        iLen = iStride - iOffset;
                    }
                    var iBegin = iFrom * iStride;
                    var n = 0;
                    for(var i = 0; i < iCount; ++i) {
                        for(var j = 0; j < iLen; ++j) {
                            pDst[n++] = (pSrc[iBegin + i * iStride + iOffset + j]);
                        }
                    }
                    return n;
                }
                function string2Array(sData, ppData, fnConv, iFrom) {
                    if (typeof fnConv === "undefined") { fnConv = parseFloat; }
                    if (typeof iFrom === "undefined") { iFrom = 0; }
                    var pData = sData.split(/[\s]+/g);
                    for(var i = 0, n = pData.length, j = 0; i < n; ++i) {
                        if (pData[i] != "") {
                            ppData[iFrom + j] = fnConv(pData[i]);
                            j++;
                        }
                    }
                    return j;
                }
                /** @inline */function string2IntArray(sData, ppData, iFrom) {
                    return string2Array(sData, ppData, parseInt, iFrom);
                }
                /** @inline */function string2FloatArray(sData, ppData, iFrom) {
                    return string2Array(sData, ppData, parseFloat, iFrom);
                }
                /** @inline */function string2BoolArray(sData, ppData, iFrom) {
                    return string2Array(sData, ppData, parseBool, iFrom);
                }
                /** @inline */function string2StringArray(sData, ppData, iFrom) {
                    return string2Array(sData, ppData, parseString, iFrom);
                }
                function string2Any(sData, n, sType, isArray) {
                    if (typeof isArray === "undefined") { isArray = false; }
                    var ppData = new (pConvFormats[sType].type)(n);
                    pConvFormats[sType].converter(sData, ppData);
                    if (n == 1 && !isArray) {
                        return ppData[0];
                    }
                    return ppData;
                }
                ;
                // additional
                function printArray(pArr, nRow, nCol) {
                    var s = "\n";
                    for(var i = 0; i < pArr.length; ++i) {
                        if (i % nCol == 0) {
                            s += "  ";
                        }
                        s += pArr[i] + ", ";
                        if ((i + 1) % nRow == 0) {
                            s += '\n';
                        }
                    }
                    return s;
                }
                function sortArrayByProperty(pData, sProperty) {
                    var tmp;
                    for(var i = pData.length - 1; i > 0; i--) {
                        for(var j = 0; j < i; j++) {
                            if (pData[j][sProperty] > pData[j + 1][sProperty]) {
                                tmp = pData[j];
                                pData[j] = pData[j + 1];
                                pData[j + 1] = tmp;
                            }
                        }
                    }
                    return pData;
                }
                /** @inline */function stringData(pXML) {
                    return (((pXML) != null) ? pXML.textContent : null);
                }
                /** @inline */function attr(pXML, sName) {
                    return pXML.getAttribute(sName);
                }
                function firstChild(pXML, sTag) {
                    if ((typeof (sTag) === "string")) {
                        return pXML.getElementsByTagName(sTag)[0];
                    }
                    for(var i = 0; i < pXML.childNodes.length; i++) {
                        if (pXML.childNodes[i].nodeType === Node.ELEMENT_NODE) {
                            return pXML.childNodes[i];
                        }
                    }
                    return null;
                }
                /** @inline */function isModelResource(pItem) {
                    return (!(((pItem)) === null) && (pItem).resourceCode.family === /*checked (origin: akra)>>*/akra.EResourceFamilies.VIDEO_RESOURCE) && pItem.resourceCode.type === akra.EVideoResources.MODEL_RESOURCE;
                }
                resources.isModelResource = isModelResource;
                /** @inline */function isColladaResource(pItem) {
                    return ((!((((pItem))) === null) && ((pItem)).resourceCode.family === /*checked (origin: akra)>>*/akra.EResourceFamilies.VIDEO_RESOURCE) && (pItem).resourceCode.type === /*checked (origin: akra)>>*/akra.EVideoResources.MODEL_RESOURCE) && (pItem).modelFormat === akra.EModelFormats.COLLADA;
                }
                resources.isColladaResource = isColladaResource;
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        akra.logger.registerCode(2001, "Grammar not LALR(1)! Cannot to generate syntax table. Add operation error.\n" + "Conflict in state with index: {stateIndex}. With grammar symbol: \"{grammarSymbol}\"\n" + "Old operation: {oldOperation}\n" + "New operation: {newOperation}\n" + "For more info init parser in debug-mode and see syntax table and list of states.");
        akra.logger.registerCode(2002, "Grammar not LALR(1)! Cannot to generate syntax table. Add state link error.\n" + "Conflict in state with index: {stateIndex}. With grammar symbol: \"{grammarSymbol}\"\n" + "Old next state: {oldNextStateIndex}\n" + "New next state: {newNextStateIndex}\n" + "For more info init parser in debug-mode and see syntax table and list of states.");
        akra.logger.registerCode(2003, "Grammar error. Can`t generate rules from grammar\n" + "Unexpected symbol: {unexpectedSymbol}\n" + "Expected: {expectedSymbol}");
        akra.logger.registerCode(2004, "Grammar error. Empty additional function name.");
        akra.logger.registerCode(2005, "Grammar error. Bad keyword: {badKeyword}\n" + "All keyword must be define in lexer rule block.");
        akra.logger.registerCode(2051, "Syntax error during parsing. Token: {tokenValue}\n" + "Line: {line}. Column: {column}.");
        akra.logger.registerCode(2101, "Unknown token: {tokenValue}");
        akra.logger.registerCode(2102, "Bad token: {tokenValue}");
        function sourceLocationToString(pLocation) {
            var sLocation = "[" + pLocation.file + ":" + pLocation.line.toString() + "]: ";
            return sLocation;
        }
        function syntaxErrorLogRoutine(pLogEntity) {
            var sPosition = sourceLocationToString(pLogEntity.location);
            var sError = "Code: " + pLogEntity.code.toString() + ". ";
            var pParseMessage = pLogEntity.message.split(/\{(\w+)\}/);
            var pInfo = pLogEntity.info;
            for(var i = 0; i < pParseMessage.length; i++) {
                if (((pInfo[pParseMessage[i]]) !== undefined)) {
                    pParseMessage[i] = pInfo[pParseMessage[i]];
                }
            }
            var sMessage = sPosition + sError + pParseMessage.join("");
            console["error"].call(console, sMessage);
        }
        akra.logger.setCodeFamilyRoutine("ParserSyntaxErrors", syntaxErrorLogRoutine, akra.ELogLevel.ERROR);
        var Item = (function () {
            function Item(pRule, iPos, pExpected) {
                this._pRule = pRule;
                this._iPos = iPos;
                this._iIndex = 0;
                this._pState = null;
                this._isNewExpected = true;
                this._iLength = 0;
                this._pExpected = {};
                if (arguments.length === 3) {
                    var i = null;
                    for(i in arguments[2]) {
                        this.addExpected(i);
                    }
                }
            }
            Object.defineProperty(Item.prototype, "rule", {
                get: /** @inline */function () {
                    return this._pRule;
                },
                set: /** @inline */function (pRule) {
                    this._pRule = pRule;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Item.prototype, "position", {
                get: /** @inline */function () {
                    return this._iPos;
                },
                set: /** @inline */function (iPos) {
                    this._iPos = iPos;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Item.prototype, "state", {
                get: /** @inline */function () {
                    return this._pState;
                },
                set: /** @inline */function (pState) {
                    this._pState = pState;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Item.prototype, "index", {
                get: /** @inline */function () {
                    return this._iIndex;
                },
                set: /** @inline */function (iIndex) {
                    this._iIndex = iIndex;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Item.prototype, "expectedSymbols", {
                get: /** @inline */function () {
                    return this._pExpected;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Item.prototype, "length", {
                get: /** @inline */function () {
                    return this._iLength;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Item.prototype, "isNewExpected", {
                get: /** @inline */function () {
                    return this._isNewExpected;
                },
                set: /** @inline */function (_isNewExpected) {
                    this._isNewExpected = _isNewExpected;
                },
                enumerable: true,
                configurable: true
            });
            Item.prototype.isEqual = function (pItem, eType) {
                if (typeof eType === "undefined") { eType = akra.EParserType.k_LR0; }
                if (eType === akra.EParserType.k_LR0) {
                    return (this._pRule === pItem.rule && this._iPos === pItem.position);
                } else if (eType === akra.EParserType.k_LR1) {
                    if (!(this._pRule === pItem.rule && this._iPos === pItem.position && this._iLength === (pItem).length)) {
                        return false;
                    }
                    var i = null;
                    for(i in this._pExpected) {
                        if (!(pItem).isExpected(i)) {
                            return false;
                        }
                    }
                    return true;
                }
            };
            Item.prototype.isParentItem = function (pItem) {
                return (this._pRule === pItem.rule && this._iPos === pItem.position + 1);
            };
            Item.prototype.isChildItem = function (pItem) {
                return (this._pRule === pItem.rule && this._iPos === pItem.position - 1);
            };
            Item.prototype.mark = function () {
                var pRight = this._pRule.right;
                if (this._iPos === pRight.length) {
                    return "END";
                }
                return pRight[this._iPos];
            };
            Item.prototype.end = /** @inline */function () {
                return this._pRule.right[this._pRule.right.length - 1] || "EMPTY";
            };
            Item.prototype.nextMarked = /** @inline */function () {
                return this._pRule.right[this._iPos + 1] || "END";
            };
            Item.prototype.isExpected = /** @inline */function (sSymbol) {
                return !!(this._pExpected[sSymbol]);
            };
            Item.prototype.addExpected = function (sSymbol) {
                if (this._pExpected[sSymbol]) {
                    return false;
                }
                this._pExpected[sSymbol] = true;
                this._isNewExpected = true;
                this._iLength++;
                return true;
            };
            Item.prototype.toString = function () {
                var sMsg = this._pRule.left + " -> ";
                var sExpected = "";
                var pRight = this._pRule.right;
                for(var k = 0; k < pRight.length; k++) {
                    if (k === this._iPos) {
                        sMsg += ". ";
                    }
                    sMsg += pRight[k] + " ";
                }
                if (this._iPos === pRight.length) {
                    sMsg += ". ";
                }
                if (((this._pExpected) !== undefined)) {
                    sExpected = ", ";
                    for(var l in this._pExpected) {
                        sExpected += l + "/";
                    }
                    if (sExpected !== ", ") {
                        sMsg += sExpected;
                    }
                }
                sMsg = sMsg.slice(0, sMsg.length - 1);
                return sMsg;
            };
            return Item;
        })();        
        var State = (function () {
            function State() {
                this._pItemList = [];
                this._pNextStates = {};
                this._iIndex = 0;
                this._nBaseItems = 0;
            }
            Object.defineProperty(State.prototype, "items", {
                get: /** @inline */function () {
                    return this._pItemList;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(State.prototype, "numBaseItems", {
                get: /** @inline */function () {
                    return this._nBaseItems;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(State.prototype, "index", {
                get: /** @inline */function () {
                    return this._iIndex;
                },
                set: /** @inline */function (iIndex) {
                    this._iIndex = iIndex;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(State.prototype, "nextStates", {
                get: /** @inline */function () {
                    return this._pNextStates;
                },
                enumerable: true,
                configurable: true
            });
            State.prototype.hasItem = function (pItem, eType) {
                var i;
                var pItems = this._pItemList;
                for(i = 0; i < pItems.length; i++) {
                    if (pItems[i].isEqual(pItem, eType)) {
                        return pItems[i];
                    }
                }
                return null;
            };
            State.prototype.hasParentItem = function (pItem) {
                var i;
                var pItems = this._pItemList;
                for(i = 0; i < pItems.length; i++) {
                    if (pItems[i].isParentItem(pItem)) {
                        return pItems[i];
                    }
                }
                return null;
            };
            State.prototype.hasChildItem = function (pItem) {
                var i;
                var pItems = this._pItemList;
                for(i = 0; i < pItems.length; i++) {
                    if (pItems[i].isChildItem(pItem)) {
                        return pItems[i];
                    }
                }
                return null;
            };
            State.prototype.hasRule = function (pRule, iPos) {
                var i = 0;
                var pItemList = this._pItemList;
                var pItem;
                for(i = 0; i < this._nBaseItems; i++) {
                    pItem = pItemList[i];
                    if (pItem.rule === pRule && pItem.position === iPos) {
                        return true;
                    }
                }
                return false;
            };
            State.prototype.isEmpty = /** @inline */function () {
                return !(this._pItemList.length);
            };
            State.prototype.isEqual = function (pState, eType) {
                var pItemsA = this._pItemList;
                var pItemsB = pState.items;
                if (this._nBaseItems !== pState.numBaseItems) {
                    return false;
                }
                var nItems = this._nBaseItems;
                var i, j;
                var isEqual;
                for(i = 0; i < nItems; i++) {
                    isEqual = false;
                    for(j = 0; j < nItems; j++) {
                        if (pItemsA[i].isEqual(pItemsB[j], eType)) {
                            isEqual = true;
                            break;
                        }
                    }
                    if (!isEqual) {
                        return false;
                    }
                }
                return true;
            };
            State.prototype.push = function (pItem) {
                if (this._pItemList.length === 0 || pItem.position > 0) {
                    this._nBaseItems += 1;
                }
                pItem.state = this;
                this._pItemList.push(pItem);
            };
            State.prototype.tryPush_LR0 = function (pRule, iPos) {
                var i;
                var pItems = this._pItemList;
                for(i = 0; i < pItems.length; i++) {
                    if (pItems[i].rule === pRule && pItems[i].position === iPos) {
                        return false;
                    }
                }
                var pItem = new Item(pRule, iPos);
                this.push(pItem);
                return true;
            };
            State.prototype.tryPush_LR = function (pRule, iPos, sExpectedSymbol) {
                var i;
                var pItems = (this._pItemList);
                for(i = 0; i < pItems.length; i++) {
                    if (pItems[i].rule === pRule && pItems[i].position === iPos) {
                        return pItems[i].addExpected(sExpectedSymbol);
                    }
                }
                var pExpected = {};
                pExpected[sExpectedSymbol] = true;
                var pItem = new Item(pRule, iPos, pExpected);
                this.push(pItem);
                return true;
            };
            State.prototype.getNextStateBySymbol = function (sSymbol) {
                if (((this._pNextStates[sSymbol]) !== undefined)) {
                    return this._pNextStates[sSymbol];
                } else {
                    return null;
                }
            };
            State.prototype.addNextState = function (sSymbol, pState) {
                if (((this._pNextStates[sSymbol]) !== undefined)) {
                    return false;
                } else {
                    this._pNextStates[sSymbol] = pState;
                    return true;
                }
            };
            State.prototype.deleteNotBase = /** @inline */function () {
                this._pItemList.length = this._nBaseItems;
            };
            State.prototype.toString = function (isBase) {
                var len = 0;
                var sMsg;
                var pItemList = this._pItemList;
                sMsg = "State " + this._iIndex + ":\n";
                len = isBase ? this._nBaseItems : pItemList.length;
                for(var j = 0; j < len; j++) {
                    sMsg += "\t\t";
                    sMsg += pItemList[j].toString();
                    sMsg += "\n";
                }
                return sMsg;
            };
            return State;
        })();        
        var ParseTree = (function () {
            function ParseTree() {
                this._pRoot = null;
                this._pNodes = [];
                this._pNodesCountStack = [];
                this._isOptimizeMode = false;
            }
            Object.defineProperty(ParseTree.prototype, "root", {
                get: /** @inline */function () {
                    return this._pRoot;
                },
                set: /** @inline */function (pRoot) {
                    this._pRoot = pRoot;
                },
                enumerable: true,
                configurable: true
            });
            ParseTree.prototype.setRoot = function () {
                this._pRoot = this._pNodes.pop();
            };
            ParseTree.prototype.setOptimizeMode = function (isOptimize) {
                this._isOptimizeMode = isOptimize;
            };
            ParseTree.prototype.addNode = function (pNode) {
                this._pNodes.push(pNode);
                this._pNodesCountStack.push(1);
            };
            ParseTree.prototype.reduceByRule = function (pRule, eCreate) {
                if (typeof eCreate === "undefined") { eCreate = akra.ENodeCreateMode.k_Default; }
                var iReduceCount = 0;
                var pNodesCountStack = this._pNodesCountStack;
                var pNode;
                var iRuleLength = pRule.right.length;
                var pNodes = this._pNodes;
                var nOptimize = this._isOptimizeMode ? 1 : 0;
                while(iRuleLength) {
                    iReduceCount += pNodesCountStack.pop();
                    iRuleLength--;
                }
                if ((eCreate === akra.ENodeCreateMode.k_Default && iReduceCount > nOptimize) || (eCreate === akra.ENodeCreateMode.k_Necessary)) {
                    pNode = {
                        name: pRule.left,
                        children: null,
                        parent: null,
                        value: "",
                        isAnalyzed: false,
                        position: this._pNodes.length
                    };
                    while(iReduceCount) {
                        this.addLink(pNode, pNodes.pop());
                        iReduceCount -= 1;
                    }
                    pNodes.push(pNode);
                    pNodesCountStack.push(1);
                } else {
                    pNodesCountStack.push(iReduceCount);
                }
            };
            ParseTree.prototype.toString = function () {
                if (this._pRoot) {
                    return this.toStringNode(this._pRoot);
                } else {
                    return "";
                }
            };
            ParseTree.prototype.clone = function () {
                var pTree = new ParseTree();
                (pTree._pRoot = (this.cloneNode(this._pRoot)));
                return pTree;
            };
            ParseTree.prototype.getNodes = /** @inline */function () {
                return this._pNodes;
            };
            ParseTree.prototype.getLastNode = /** @inline */function () {
                return this._pNodes[this._pNodes.length - 1];
            };
            ParseTree.prototype.addLink = function (pParent, pNode) {
                if (!pParent.children) {
                    pParent.children = [];
                }
                pParent.children.push(pNode);
                pNode.parent = pParent;
            };
            ParseTree.prototype.cloneNode = function (pNode) {
                var pNewNode;
                pNewNode = {
                    name: pNode.name,
                    value: pNode.value,
                    children: null,
                    parent: null,
                    isAnalyzed: pNode.isAnalyzed,
                    position: pNode.position
                };
                var pChildren = pNode.children;
                for(var i = 0; pChildren && i < pChildren.length; i++) {
                    this.addLink(pNewNode, this.cloneNode(pChildren[i]));
                }
                return pNewNode;
            };
            ParseTree.prototype.toStringNode = function (pNode, sPadding) {
                if (typeof sPadding === "undefined") { sPadding = ""; }
                var sRes = sPadding + "{\n";
                var sOldPadding = sPadding;
                var sDefaultPadding = "  ";
                sPadding += sDefaultPadding;
                if (pNode.value) {
                    sRes += sPadding + "name : \"" + pNode.name + "\"" + ",\n";
                    sRes += sPadding + "value : \"" + pNode.value + "\"" + "\n";
                } else {
                    sRes += sPadding + "name : \"" + pNode.name + "\"" + "\n";
                    sRes += sPadding + "children : [";
                    var pChildren = pNode.children;
                    if (pChildren) {
                        sRes += "\n";
                        sPadding += sDefaultPadding;
                        for(var i = pChildren.length - 1; i >= 0; i--) {
                            sRes += this.toStringNode(pChildren[i], sPadding);
                            sRes += ",\n";
                        }
                        sRes = sRes.slice(0, sRes.length - 2);
                        sRes += "\n";
                        sRes += sOldPadding + sDefaultPadding + "]\n";
                    } else {
                        sRes += " ]\n";
                    }
                }
                sRes += sOldPadding + "}";
                return sRes;
            };
            return ParseTree;
        })();
        util.ParseTree = ParseTree;        
        var Lexer = (function () {
            function Lexer(pParser) {
                this._iLineNumber = 0;
                this._iColumnNumber = 0;
                this._sSource = "";
                this._iIndex = 0;
                this._pParser = pParser;
                this._pPunctuatorsMap = {};
                this._pKeywordsMap = {};
                this._pPunctuatorsFirstSymbols = {};
            }
            Lexer.prototype.addPunctuator = function (sValue, sName) {
                if (sName === undefined && sValue.length === 1) {
                    sName = "T_PUNCTUATOR_" + sValue.charCodeAt(0);
                }
                this._pPunctuatorsMap[sValue] = sName;
                this._pPunctuatorsFirstSymbols[sValue[0]] = true;
                return sName;
            };
            Lexer.prototype.addKeyword = function (sValue, sName) {
                this._pKeywordsMap[sValue] = sName;
                return sName;
            };
            Lexer.prototype.getTerminalValueByName = function (sName) {
                var sValue = null;
                for(sValue in this._pPunctuatorsMap) {
                    if (this._pPunctuatorsMap[sValue] === sName) {
                        return sValue;
                    }
                }
                for(sValue in this._pKeywordsMap) {
                    if (this._pKeywordsMap[sValue] === sName) {
                        return sValue;
                    }
                }
                return sName;
            };
            Lexer.prototype.init = function (sSource) {
                this._sSource = sSource;
                this._iLineNumber = 0;
                this._iColumnNumber = 0;
                this._iIndex = 0;
            };
            Lexer.prototype.getNextToken = function () {
                var ch = ((this)._sSource[(this)._iIndex]);
                if (!ch) {
                    return {
                        name: "$",
                        value: "$",
                        start: this._iColumnNumber,
                        end: this._iColumnNumber,
                        line: this._iLineNumber
                    };
                }
                var eType = this.identityTokenType();
                var pToken;
                switch(eType) {
                    case akra.ETokenType.k_NumericLiteral:
                        pToken = this.scanNumber();
                        break;
                    case akra.ETokenType.k_CommentLiteral:
                        this.scanComment();
                        pToken = this.getNextToken();
                        break;
                    case akra.ETokenType.k_StringLiteral:
                        pToken = this.scanString();
                        break;
                    case akra.ETokenType.k_PunctuatorLiteral:
                        pToken = this.scanPunctuator();
                        break;
                    case akra.ETokenType.k_IdentifierLiteral:
                        pToken = this.scanIdentifier();
                        break;
                    case akra.ETokenType.k_WhitespaceLiteral:
                        this.scanWhiteSpace();
                        pToken = this.getNextToken();
                        break;
                    default:
                        this._error(2101, {
                            name: "UNNOWN",
                            value: ch + this._sSource[this._iIndex + 1],
                            start: this._iColumnNumber,
                            end: this._iColumnNumber + 1,
                            line: this._iLineNumber
                        });
                }
                return pToken;
            };
            Lexer.prototype._getIndex = /** @inline */function () {
                return this._iIndex;
            };
            Lexer.prototype._setSource = /** @inline */function (sSource) {
                this._sSource = sSource;
            };
            Lexer.prototype._setIndex = /** @inline */function (iIndex) {
                this._iIndex = iIndex;
            };
            Lexer.prototype._error = function (eCode, pToken) {
                var pLocation = {
                    file: this._pParser.getParseFileName(),
                    line: this._iLineNumber
                };
                var pInfo = {
                    tokenValue: pToken.value,
                    tokenType: pToken.type
                };
                var pLogEntity = {
                    code: eCode,
                    info: pInfo,
                    location: pLocation
                };
                akra.logger["error"](pLogEntity);
                throw new Error(eCode.toString());
            };
            Lexer.prototype.identityTokenType = function () {
                if (this.isIdentifierStart()) {
                    return akra.ETokenType.k_IdentifierLiteral;
                }
                if (this.isWhiteSpaceStart()) {
                    return akra.ETokenType.k_WhitespaceLiteral;
                }
                if (this.isStringStart()) {
                    return akra.ETokenType.k_StringLiteral;
                }
                if (this.isCommentStart()) {
                    return akra.ETokenType.k_CommentLiteral;
                }
                if (this.isNumberStart()) {
                    return akra.ETokenType.k_NumericLiteral;
                }
                if (this.isPunctuatorStart()) {
                    return akra.ETokenType.k_PunctuatorLiteral;
                }
                return akra.ETokenType.k_Unknown;
            };
            Lexer.prototype.isNumberStart = function () {
                var ch = ((this)._sSource[(this)._iIndex]);
                if ((ch >= '0') && (ch <= '9')) {
                    return true;
                }
                var ch1 = ((this)._sSource[(this)._iIndex + 1]);
                if (ch === "." && (ch1 >= '0') && (ch1 <= '9')) {
                    return true;
                }
                return false;
            };
            Lexer.prototype.isCommentStart = function () {
                var ch = ((this)._sSource[(this)._iIndex]);
                var ch1 = ((this)._sSource[(this)._iIndex + 1]);
                if (ch === "/" && (ch1 === "/" || ch1 === "*")) {
                    return true;
                }
                return false;
            };
            Lexer.prototype.isStringStart = function () {
                var ch = ((this)._sSource[(this)._iIndex]);
                if (ch === "\"" || ch === "'") {
                    return true;
                }
                return false;
            };
            Lexer.prototype.isPunctuatorStart = function () {
                var ch = ((this)._sSource[(this)._iIndex]);
                if (this._pPunctuatorsFirstSymbols[ch]) {
                    return true;
                }
                return false;
            };
            Lexer.prototype.isWhiteSpaceStart = function () {
                var ch = ((this)._sSource[(this)._iIndex]);
                if (ch === ' ' || ch === '\n' || ch === '\r' || ch === '\t') {
                    return true;
                }
                return false;
            };
            Lexer.prototype.isIdentifierStart = function () {
                var ch = ((this)._sSource[(this)._iIndex]);
                if ((ch === '_') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
                    return true;
                }
                return false;
            };
            Lexer.prototype.isLineTerminator = function (sSymbol) {
                return (sSymbol === '\n' || sSymbol === '\r' || sSymbol === '\u2028' || sSymbol === '\u2029');
            };
            Lexer.prototype.isWhiteSpace = function (sSymbol) {
                return (sSymbol === ' ') || (sSymbol === '\t');
            };
            Lexer.prototype.isKeyword = /** @inline */function (sValue) {
                return !!(this._pKeywordsMap[sValue]);
            };
            Lexer.prototype.isPunctuator = /** @inline */function (sValue) {
                return !!(this._pPunctuatorsMap[sValue]);
            };
            Lexer.prototype.nextChar = /** @inline */function () {
                return this._sSource[this._iIndex + 1];
            };
            Lexer.prototype.currentChar = /** @inline */function () {
                return this._sSource[this._iIndex];
            };
            Lexer.prototype.readNextChar = /** @inline */function () {
                this._iIndex++;
                this._iColumnNumber++;
                return this._sSource[this._iIndex];
            };
            Lexer.prototype.scanString = function () {
                var chFirst = ((this)._sSource[(this)._iIndex]);
                var sValue = chFirst;
                var ch = null;
                var chPrevious = chFirst;
                var isGoodFinish = false;
                var iStart = this._iColumnNumber;
                while(true) {
                    ch = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.readNextChar();
                    if (!ch) {
                        break;
                    }
                    sValue += ch;
                    if (ch === chFirst && chPrevious !== '\\') {
                        isGoodFinish = true;
                        /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.readNextChar();
                        break;
                    }
                    chPrevious = ch;
                }
                if (isGoodFinish) {
                    return {
                        name: "T_STRING",
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber - 1,
                        line: this._iLineNumber
                    };
                } else {
                    if (!ch) {
                        ch = "EOF";
                    }
                    sValue += ch;
                    this._error(2102, {
                        type: akra.ETokenType.k_StringLiteral,
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber,
                        line: this._iLineNumber
                    });
                    return null;
                }
            };
            Lexer.prototype.scanPunctuator = function () {
                var sValue = ((this)._sSource[(this)._iIndex]);
                var ch;
                var iStart = this._iColumnNumber;
                while(true) {
                    ch = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.readNextChar();
                    if (ch) {
                        sValue += ch;
                        this._iColumnNumber++;
                        if (!(!!((this)._pPunctuatorsMap[(sValue)]))) {
                            sValue = sValue.slice(0, sValue.length - 1);
                            break;
                        }
                    } else {
                        break;
                    }
                }
                return {
                    name: this._pPunctuatorsMap[sValue],
                    value: sValue,
                    start: iStart,
                    end: this._iColumnNumber - 1,
                    line: this._iLineNumber
                };
            };
            Lexer.prototype.scanNumber = function () {
                var ch = ((this)._sSource[(this)._iIndex]);
                var sValue = "";
                var isFloat = false;
                var chPrevious = ch;
                var isGoodFinish = false;
                var iStart = this._iColumnNumber;
                var isE = false;
                if (ch === '.') {
                    sValue += 0;
                    isFloat = true;
                }
                sValue += ch;
                while(true) {
                    ch = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.readNextChar();
                    if (ch === '.') {
                        if (isFloat) {
                            break;
                        } else {
                            isFloat = true;
                        }
                    } else if (ch === 'e') {
                        if (isE) {
                            break;
                        } else {
                            isE = true;
                        }
                    } else if (((ch === '+' || ch === '-') && chPrevious === 'e')) {
                        sValue += ch;
                        chPrevious = ch;
                        continue;
                    } else if (ch === 'f' && isFloat) {
                        ch = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.readNextChar();
                        if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
                            break;
                        }
                        isGoodFinish = true;
                        break;
                    } else if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
                        break;
                    } else if (!((ch >= '0') && (ch <= '9')) || !ch) {
                        if ((isE && chPrevious !== '+' && chPrevious !== '-' && chPrevious !== 'e') || !isE) {
                            isGoodFinish = true;
                        }
                        break;
                    }
                    sValue += ch;
                    chPrevious = ch;
                }
                if (isGoodFinish) {
                    var sName = isFloat ? "T_FLOAT" : "T_UINT";
                    return {
                        name: sName,
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber - 1,
                        line: this._iLineNumber
                    };
                } else {
                    if (!ch) {
                        ch = "EOF";
                    }
                    sValue += ch;
                    this._error(2102, {
                        type: akra.ETokenType.k_NumericLiteral,
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber,
                        line: this._iLineNumber
                    });
                    return null;
                }
            };
            Lexer.prototype.scanIdentifier = function () {
                var ch = ((this)._sSource[(this)._iIndex]);
                var sValue = ch;
                var iStart = this._iColumnNumber;
                var isGoodFinish = false;
                while(true) {
                    ch = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.readNextChar();
                    if (!ch) {
                        isGoodFinish = true;
                        break;
                    }
                    if (!((ch === '_') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9'))) {
                        isGoodFinish = true;
                        break;
                    }
                    sValue += ch;
                }
                if (isGoodFinish) {
                    if ((!!((this)._pKeywordsMap[(sValue)]))) {
                        return {
                            name: this._pKeywordsMap[sValue],
                            value: sValue,
                            start: iStart,
                            end: this._iColumnNumber - 1,
                            line: this._iLineNumber
                        };
                    } else {
                        var sName = this._pParser.isTypeId(sValue) ? "T_TYPE_ID" : "T_NON_TYPE_ID";
                        return {
                            name: sName,
                            value: sValue,
                            start: iStart,
                            end: this._iColumnNumber - 1,
                            line: this._iLineNumber
                        };
                    }
                } else {
                    if (!ch) {
                        ch = "EOF";
                    }
                    sValue += ch;
                    this._error(2102, {
                        type: akra.ETokenType.k_IdentifierLiteral,
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber,
                        line: this._iLineNumber
                    });
                    return null;
                }
            };
            Lexer.prototype.scanWhiteSpace = function () {
                var ch = ((this)._sSource[(this)._iIndex]);
                while(true) {
                    if (!ch) {
                        break;
                    }
                    if (this.isLineTerminator(ch)) {
                        if (ch === "\r" && ((this)._sSource[(this)._iIndex + 1]) === "\n") {
                            this._iLineNumber--;
                        }
                        this._iLineNumber++;
                        ch = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.readNextChar();
                        this._iColumnNumber = 0;
                        continue;
                    } else if (ch === '\t') {
                        this._iColumnNumber += 3;
                    } else if (ch !== ' ') {
                        break;
                    }
                    ch = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.readNextChar();
                }
                return true;
            };
            Lexer.prototype.scanComment = function () {
                var sValue = ((this)._sSource[(this)._iIndex]);
                var ch = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.readNextChar();
                sValue += ch;
                if (ch === '/') {
                    //Line Comment
                    while(true) {
                        ch = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.readNextChar();
                        if (!ch) {
                            break;
                        }
                        if (this.isLineTerminator(ch)) {
                            if (ch === "\r" && ((this)._sSource[(this)._iIndex + 1]) === "\n") {
                                this._iLineNumber--;
                            }
                            this._iLineNumber++;
                            /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.readNextChar();
                            this._iColumnNumber = 0;
                            break;
                        }
                        sValue += ch;
                    }
                    return true;
                } else {
                    //Multiline Comment
                    var chPrevious = ch;
                    var isGoodFinish = false;
                    var iStart = this._iColumnNumber;
                    while(true) {
                        ch = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.readNextChar();
                        if (!ch) {
                            break;
                        }
                        sValue += ch;
                        if (ch === '/' && chPrevious === '*') {
                            isGoodFinish = true;
                            /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.readNextChar();
                            break;
                        }
                        if (this.isLineTerminator(ch)) {
                            if (ch === "\r" && ((this)._sSource[(this)._iIndex + 1]) === "\n") {
                                this._iLineNumber--;
                            }
                            this._iLineNumber++;
                            this._iColumnNumber = -1;
                        }
                        chPrevious = ch;
                    }
                    if (isGoodFinish) {
                        return true;
                    } else {
                        if (!ch) {
                            ch = "EOF";
                        }
                        sValue += ch;
                        this._error(2102, {
                            type: akra.ETokenType.k_CommentLiteral,
                            value: sValue,
                            start: iStart,
                            end: this._iColumnNumber,
                            line: this._iLineNumber
                        });
                    }
                }
            };
            return Lexer;
        })();        
        var Parser = (function () {
            function Parser() {
                this._sSource = "";
                this._iIndex = 0;
                this._pSyntaxTree = null;
                this._pTypeIdMap = null;
                this._pLexer = null;
                this._pStack = [];
                this._pToken = null;
                this._fnFinishCallback = null;
                this._pCaller = null;
                this._pSymbolMap = {
                    "$": true
                };
                this._pSyntaxTable = null;
                this._pReduceOperationsMap = null;
                this._pShiftOperationsMap = null;
                this._pSuccessOperation = null;
                this._pFirstTerminalsDMap = null;
                this._pFollowTerminalsDMap = null;
                this._pRulesDMap = null;
                this._pStateList = null;
                this._nRules = 0;
                this._pAdditionalFuncInfoList = null;
                this._pAdditionalFunctionsMap = null;
                this._pAdidtionalFunctByStateDMap = null;
                this._eType = akra.EParserType.k_LR0;
                this._pRuleCreationModeMap = null;
                this._eParseMode = akra.EParseMode.k_AllNode;
                // this._isSync = false;
                this._pStatesTempMap = null;
                this._pBaseItemList = null;
                this._pExpectedExtensionDMap = null;
                this._sFileName = "stdin";
                ;
            }
            Parser.prototype.isTypeId = function (sValue) {
                return !!(this._pTypeIdMap[sValue]);
            };
            Parser.prototype.returnCode = function (pNode) {
                if (pNode) {
                    if (pNode.value) {
                        return pNode.value + " ";
                    } else if (pNode.children) {
                        var sCode = "";
                        var i = 0;
                        for(i = pNode.children.length - 1; i >= 0; i--) {
                            sCode += this.returnCode(pNode.children[i]);
                        }
                        return sCode;
                    }
                }
                return "";
            };
            Parser.prototype.init = function (sGrammar, eMode, eType) {
                if (typeof eMode === "undefined") { eMode = akra.EParseMode.k_AllNode; }
                if (typeof eType === "undefined") { eType = akra.EParserType.k_LALR; }
                try  {
                    this._eType = eType;
                    this._pLexer = new Lexer(this);
                    this._eParseMode = eMode;
                    this.generateRules(sGrammar);
                    this.buildSyntaxTable();
                    this.generateFunctionByStateMap();
                    if (!((((eMode) & (/*checked (origin: akra)>>*/akra.EParseMode.k_DebugMode)) == (/*checked (origin: akra)>>*/akra.EParseMode.k_DebugMode)))) {
                        this.clearMem();
                    }
                    return true;
                } catch (e) {
 {
                        util.logger.setSourceLocation("util/Parser.ts", 1397);
                        util.logger.log(e.stack);
                    }
                    ;
                    // error("Could`not initialize parser. Error with code has occurred: " + e.message + ". See log for more info.");
                    return false;
                }
            };
            Parser.prototype.parse = function (sSource, fnFinishCallback, pCaller) {
                if (typeof fnFinishCallback === "undefined") { fnFinishCallback = null; }
                if (typeof pCaller === "undefined") { pCaller = null; }
                try  {
                    this.defaultInit();
                    this._sSource = sSource;
                    this._pLexer.init(sSource);
                    //this._isSync = isSync;
                    this._fnFinishCallback = fnFinishCallback;
                    this._pCaller = pCaller;
                    var pTree = this._pSyntaxTree;
                    var pStack = this._pStack;
                    var pSyntaxTable = this._pSyntaxTable;
                    var isStop = false;
                    var isError = false;
                    var isPause = false;
                    var pToken = this.readToken();
                    var pOperation;
                    var iRuleLength;
                    var eAdditionalOperationCode;
                    var iStateIndex = 0;
                    while(!isStop) {
                        pOperation = pSyntaxTable[pStack[pStack.length - 1]][pToken.name];
                        if (((pOperation) !== undefined)) {
                            switch(pOperation.type) {
                                case akra.EOperationType.k_Success:
                                    isStop = true;
                                    break;
                                case akra.EOperationType.k_Shift:
                                    iStateIndex = pOperation.index;
                                    pStack.push(iStateIndex);
                                    pTree.addNode(pToken);
                                    eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pToken.name);
                                    if (eAdditionalOperationCode === akra.EOperationType.k_Error) {
                                        isError = true;
                                        isStop = true;
                                    } else if (eAdditionalOperationCode === akra.EOperationType.k_Pause) {
                                        this._pToken = null;
                                        isStop = true;
                                        isPause = true;
                                    } else if (eAdditionalOperationCode === akra.EOperationType.k_Ok) {
                                        pToken = this.readToken();
                                    }
                                    break;
                                case akra.EOperationType.k_Reduce:
                                    iRuleLength = pOperation.rule.right.length;
                                    pStack.length -= iRuleLength;
                                    iStateIndex = pSyntaxTable[pStack[pStack.length - 1]][pOperation.rule.left].index;
                                    pStack.push(iStateIndex);
                                    pTree.reduceByRule(pOperation.rule, this._pRuleCreationModeMap[pOperation.rule.left]);
                                    eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pOperation.rule.left);
                                    if (eAdditionalOperationCode === akra.EOperationType.k_Error) {
                                        isError = true;
                                        isStop = true;
                                    } else if (eAdditionalOperationCode === akra.EOperationType.k_Pause) {
                                        this._pToken = pToken;
                                        isStop = true;
                                        isPause = true;
                                    }
                                    break;
                            }
                        } else {
                            isError = true;
                            isStop = true;
                        }
                    }
                } catch (e) {
                    // debug_print(e.stack);
                    this._sFileName = "stdin";
                    return akra.EParserCode.k_Error;
                }
                if (isPause) {
                    return akra.EParserCode.k_Pause;
                }
                if (!isError) {
                    pTree.setRoot();
                    if (!((this._fnFinishCallback) === null)) {
                        this._fnFinishCallback.call(this._pCaller, akra.EParserCode.k_Ok, this.getParseFileName());
                    }
                    this._sFileName = "stdin";
                    return akra.EParserCode.k_Ok;
                } else {
                    this._error(2051, pToken);
                    if (!((this._fnFinishCallback) === null)) {
                        this._fnFinishCallback.call(this._pCaller, akra.EParserCode.k_Error, this.getParseFileName());
                    }
                    this._sFileName = "stdin";
                    return akra.EParserCode.k_Error;
                }
            };
            Parser.prototype.setParseFileName = function (sFileName) {
                this._sFileName = sFileName;
            };
            Parser.prototype.getParseFileName = function () {
                return this._sFileName;
            };
            Parser.prototype.pause = function () {
                return akra.EParserCode.k_Pause;
            };
            Parser.prototype.resume = function () {
                return this.resumeParse();
            };
            Parser.prototype.printStates = function (isBaseOnly) {
                if (typeof isBaseOnly === "undefined") { isBaseOnly = true; }
                if (!((this._pStateList) !== undefined)) {
 {
                        util.logger.setSourceLocation("util/Parser.ts", 1535);
                        util.logger.log("It`s impossible to print states. You must init parser in debug-mode");
                    }
                    ;
                    return;
                }
                var sMsg = "\n" + this.statesToString(isBaseOnly);
 {
                    util.logger.setSourceLocation("util/Parser.ts", 1539);
                    util.logger.log(sMsg);
                }
                ;
            };
            Parser.prototype.printState = function (iStateIndex, isBaseOnly) {
                if (typeof isBaseOnly === "undefined") { isBaseOnly = true; }
                if (!((this._pStateList) !== undefined)) {
 {
                        util.logger.setSourceLocation("util/Parser.ts", 1544);
                        util.logger.log("It`s impossible to print states. You must init parser in debug-mode");
                    }
                    ;
                    return;
                }
                var pState = this._pStateList[iStateIndex];
                if (!((pState) !== undefined)) {
 {
                        util.logger.setSourceLocation("util/Parser.ts", 1550);
                        util.logger.log("Can not print stete with index: " + iStateIndex.toString());
                    }
                    ;
                    return;
                }
                var sMsg = "\n" + pState.toString(isBaseOnly);
 {
                    util.logger.setSourceLocation("util/Parser.ts", 1555);
                    util.logger.log(sMsg);
                }
                ;
            };
            Parser.prototype.getGrammarSymbols = function () {
                return this._pGrammarSymbols;
            };
            Parser.prototype.getSyntaxTree = /** @inline */function () {
                return this._pSyntaxTree;
            };
            Parser.prototype._saveState = function () {
                return {
                    source: this._sSource,
                    index: this._pLexer._getIndex(),
                    fileName: this._sFileName,
                    tree: this._pSyntaxTree,
                    types: this._pTypeIdMap,
                    stack: this._pStack,
                    token: this._pToken,
                    fnCallback: this._fnFinishCallback,
                    caller: this._pCaller
                };
            };
            Parser.prototype._loadState = function (pState) {
                this._sSource = pState.source;
                this._iIndex = pState.index;
                this._sFileName = pState.fileName;
                this._pSyntaxTree = pState.tree;
                this._pTypeIdMap = pState.types;
                this._pStack = pState.stack;
                this._pToken = pState.token;
                this._fnFinishCallback = pState.fnCallback;
                this._pCaller = pState.caller;
                this._pLexer._setSource(pState.source);
                this._pLexer._setIndex(pState.index);
            };
            Parser.prototype.addAdditionalFunction = /**@protected*/ function (sFuncName, fnRuleFunction) {
                if (((this._pAdditionalFunctionsMap) === null)) {
                    this._pAdditionalFunctionsMap = {};
                }
                this._pAdditionalFunctionsMap[sFuncName] = fnRuleFunction;
            };
            Parser.prototype.addTypeId = /**@protected*/ function (sIdentifier) {
                if (((this._pTypeIdMap) === null)) {
                    this._pTypeIdMap = {};
                }
                this._pTypeIdMap[sIdentifier] = true;
            };
            Parser.prototype.defaultInit = /**@protected*/ function () {
                this._iIndex = 0;
                this._pStack = [
                    0
                ];
                this._pSyntaxTree = new ParseTree();
                this._pTypeIdMap = {};
                this._pSyntaxTree.setOptimizeMode(((((this._eParseMode) & (/*checked (origin: akra)>>*/akra.EParseMode.k_Optimize)) == (/*checked (origin: akra)>>*/akra.EParseMode.k_Optimize))));
            };
            Parser.prototype._error = function (eCode, pErrorInfo) {
                var pLocation = {};
                var pInfo = {
                    tokenValue: null,
                    line: null,
                    column: null,
                    stateIndex: null,
                    oldNextStateIndex: null,
                    newNextStateIndex: null,
                    grammarSymbol: null,
                    newOperation: null,
                    oldOperation: null,
                    expectedSymbol: null,
                    unexpectedSymbol: null,
                    badKeyword: null
                };
                var pLogEntity = {
                    code: eCode,
                    info: pInfo,
                    location: pLocation
                };
                if (eCode === 2051) {
                    var pToken = pErrorInfo;
                    var iLine = pToken.line;
                    var iColumn = pToken.start;
                    pInfo.tokenValue = pToken.value;
                    pInfo.line = iLine;
                    pInfo.column = iColumn;
                    pLocation.file = this.getParseFileName();
                    pLocation.line = iLine;
                } else if (eCode === 2001) {
                    var iStateIndex = pErrorInfo.stateIndex;
                    var sSymbol = pErrorInfo.grammarSymbol;
                    var pOldOperation = pErrorInfo.oldOperation;
                    var pNewOperation = pErrorInfo.newOperation;
                    pInfo.stateIndex = iStateIndex;
                    pInfo.grammarSymbol = sSymbol;
                    pInfo.oldOperation = this.operationToString(pOldOperation);
                    pInfo.newOperation = this.operationToString(pNewOperation);
                    pLocation.file = "GRAMMAR";
                    pLocation.line = 0;
                } else if (eCode === 2002) {
                    var iStateIndex = pErrorInfo.stateIndex;
                    var sSymbol = pErrorInfo.grammarSymbol;
                    var iOldNextStateIndex = pErrorInfo.oldNextStateIndex;
                    var iNewNextStateIndex = pErrorInfo.newNextStateIndex;
                    pInfo.stateIndex = iStateIndex;
                    pInfo.grammarSymbol = sSymbol;
                    pInfo.oldNextStateIndex = iOldNextStateIndex;
                    pInfo.newNextStateIndex = iNewNextStateIndex;
                    pLocation.file = "GRAMMAR";
                    pLocation.line = 0;
                } else if (eCode === 2003) {
                    var iLine = pErrorInfo.grammarLine;
                    var sExpectedSymbol = pErrorInfo.expectedSymbol;
                    var sUnexpectedSymbol = pErrorInfo.unexpectedSymbol;
                    pInfo.expectedSymbol = sExpectedSymbol;
                    pInfo.unexpectedSymbol = sExpectedSymbol;
                    pLocation.file = "GRAMMAR";
                    pLocation.line = iLine || 0;
                } else if (eCode === 2004) {
                    var iLine = pErrorInfo.grammarLine;
                    pLocation.file = "GRAMMAR";
                    pLocation.line = iLine || 0;
                } else if (eCode === 2005) {
                    var iLine = pErrorInfo.grammarLine;
                    var sBadKeyword = pErrorInfo.badKeyword;
                    pInfo.badKeyword = sBadKeyword;
                    pLocation.file = "GRAMMAR";
                    pLocation.line = iLine || 0;
                }
                akra.logger["error"](pLogEntity);
                throw new Error(eCode.toString());
            };
            Parser.prototype.clearMem = function () {
                delete this._pFirstTerminalsDMap;
                delete this._pFollowTerminalsDMap;
                delete this._pRulesDMap;
                delete this._pStateList;
                delete this._pReduceOperationsMap;
                delete this._pShiftOperationsMap;
                delete this._pSuccessOperation;
                delete this._pStatesTempMap;
                delete this._pBaseItemList;
                delete this._pExpectedExtensionDMap;
            };
            Parser.prototype.hasState = function (pState, eType) {
                var pStateList = this._pStateList;
                var i = 0;
                for(i = 0; i < pStateList.length; i++) {
                    if (pStateList[i].isEqual(pState, eType)) {
                        return pStateList[i];
                    }
                }
                return null;
            };
            Parser.prototype.isTerminal = function (sSymbol) {
                return !(this._pRulesDMap[sSymbol]);
            };
            Parser.prototype.pushState = function (pState) {
                pState.index = this._pStateList.length;
                this._pStateList.push(pState);
            };
            Parser.prototype.pushBaseItem = function (pItem) {
                pItem.index = this._pBaseItemList.length;
                this._pBaseItemList.push(pItem);
            };
            Parser.prototype.tryAddState = function (pState, eType) {
                var pRes = this.hasState(pState, eType);
                if (((pRes) === null)) {
                    if (eType === akra.EParserType.k_LR0) {
                        var pItems = pState.items;
                        for(var i = 0; i < pItems.length; i++) {
                            this.pushBaseItem(pItems[i]);
                        }
                    }
                    this.pushState(pState);
                    this.closure(pState, eType);
                    return pState;
                }
                return pRes;
            };
            Parser.prototype.hasEmptyRule = function (sSymbol) {
                if (this.isTerminal(sSymbol)) {
                    return false;
                }
                var pRulesDMap = this._pRulesDMap;
                for(var i in pRulesDMap[sSymbol]) {
                    if (pRulesDMap[sSymbol][i].right.length === 0) {
                        return true;
                    }
                }
                return false;
            };
            Parser.prototype.pushInSyntaxTable = function (iIndex, sSymbol, pOperation) {
                var pSyntaxTable = this._pSyntaxTable;
                if (!pSyntaxTable[iIndex]) {
                    pSyntaxTable[iIndex] = {};
                }
                if (((pSyntaxTable[iIndex][sSymbol]) !== undefined)) {
                    this._error(2001, {
                        stateIndex: iIndex,
                        grammarSymbol: this.convertGrammarSymbol(sSymbol),
                        oldOperation: this._pSyntaxTable[iIndex][sSymbol],
                        newOperation: pOperation
                    });
                }
                pSyntaxTable[iIndex][sSymbol] = pOperation;
            };
            Parser.prototype.addStateLink = function (pState, pNextState, sSymbol) {
                var isAddState = pState.addNextState(sSymbol, pNextState);
                if (!isAddState) {
                    this._error(2002, {
                        stateIndex: pState.index,
                        oldNextStateIndex: pState.getNextStateBySymbol(sSymbol),
                        newNextStateIndex: pNextState.index,
                        grammarSymbol: this.convertGrammarSymbol(sSymbol)
                    });
                }
            };
            Parser.prototype.firstTerminal = function (sSymbol) {
                if (this.isTerminal(sSymbol)) {
                    return null;
                }
                if (((this._pFirstTerminalsDMap[sSymbol]) !== undefined)) {
                    return this._pFirstTerminalsDMap[sSymbol];
                }
                var i = null, j = 0, k = null;
                var pRulesMap = this._pRulesDMap[sSymbol];
                var pTempRes = {};
                var pRes;
                var pRight;
                var isFinish;
                pRes = this._pFirstTerminalsDMap[sSymbol] = {};
                if (this.hasEmptyRule(sSymbol)) {
                    pRes["EMPTY"] = true;
                }
                for(i in pRulesMap) {
                    isFinish = false;
                    pRight = pRulesMap[i].right;
                    for(j = 0; j < pRight.length; j++) {
                        if (pRight[j] === sSymbol) {
                            if (pRes["EMPTY"]) {
                                continue;
                            }
                            isFinish = true;
                            break;
                        }
                        pTempRes = this.firstTerminal(pRight[j]);
                        if (((pTempRes) === null)) {
                            pRes[pRight[j]] = true;
                        } else {
                            for(k in pTempRes) {
                                pRes[k] = true;
                            }
                        }
                        if (!this.hasEmptyRule(pRight[j])) {
                            isFinish = true;
                            break;
                        }
                    }
                    if (!isFinish) {
                        pRes["EMPTY"] = true;
                    }
                }
                return pRes;
            };
            Parser.prototype.followTerminal = function (sSymbol) {
                if (((this._pFollowTerminalsDMap[sSymbol]) !== undefined)) {
                    return this._pFollowTerminalsDMap[sSymbol];
                }
                var i = null, j = null, k = 0, l = 0, m = null;
                var pRulesDMap = this._pRulesDMap;
                var pTempRes;
                var pRes;
                var pRight;
                var isFinish;
                pRes = this._pFollowTerminalsDMap[sSymbol] = {};
                for(i in pRulesDMap) {
                    for(j in pRulesDMap[i]) {
                        pRight = pRulesDMap[i][j].right;
                        for(k = 0; k < pRight.length; k++) {
                            if (pRight[k] === sSymbol) {
                                if (k === pRight.length - 1) {
                                    pTempRes = this.followTerminal(pRulesDMap[i][j].left);
                                    for(m in pTempRes) {
                                        pRes[m] = true;
                                    }
                                } else {
                                    isFinish = false;
                                    for(l = k + 1; l < pRight.length; l++) {
                                        pTempRes = this.firstTerminal(pRight[l]);
                                        if (((pTempRes) === null)) {
                                            pRes[pRight[l]] = true;
                                            isFinish = true;
                                            break;
                                        } else {
                                            for(m in pTempRes) {
                                                pRes[m] = true;
                                            }
                                        }
                                        if (!pTempRes["EMPTY"]) {
                                            isFinish = true;
                                            break;
                                        }
                                    }
                                    if (!isFinish) {
                                        pTempRes = this.followTerminal(pRulesDMap[i][j].left);
                                        for(m in pTempRes) {
                                            pRes[m] = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return pRes;
            };
            Parser.prototype.firstTerminalForSet = function (pSet, pExpected) {
                var i = 0, j = null;
                var pTempRes;
                var pRes = {};
                var isEmpty;
                for(i = 0; i < pSet.length; i++) {
                    pTempRes = this.firstTerminal(pSet[i]);
                    if (((pTempRes) === null)) {
                        pRes[pSet[i]] = true;
                    }
                    isEmpty = false;
                    for(j in pTempRes) {
                        if (j === "EMPTY") {
                            isEmpty = true;
                            continue;
                        }
                        pRes[j] = true;
                    }
                    if (!isEmpty) {
                        return pRes;
                    }
                }
                for(j in pExpected) {
                    pRes[j] = true;
                }
                return pRes;
            };
            Parser.prototype.generateRules = function (sGrammarSource) {
                var pAllRuleList = sGrammarSource.split(/\r?\n/);
                var pTempRule;
                var pRule;
                var isLexerBlock = false;
                this._pRulesDMap = {};
                this._pAdditionalFuncInfoList = [];
                this._pRuleCreationModeMap = {};
                this._pGrammarSymbols = {};
                var i = 0, j = 0;
                var isAllNodeMode = ((((this._eParseMode) & (/*checked (origin: akra)>>*/akra.EParseMode.k_AllNode)) == (/*checked (origin: akra)>>*/akra.EParseMode.k_AllNode)));
                var isNegateMode = ((((this._eParseMode) & (/*checked (origin: akra)>>*/akra.EParseMode.k_Negate)) == (/*checked (origin: akra)>>*/akra.EParseMode.k_Negate)));
                var isAddMode = ((((this._eParseMode) & (/*checked (origin: akra)>>*/akra.EParseMode.k_Add)) == (/*checked (origin: akra)>>*/akra.EParseMode.k_Add)));
                var pSymbolsWithNodeMap = this._pRuleCreationModeMap;
                for(i = 0; i < pAllRuleList.length; i++) {
                    if (pAllRuleList[i] === "" || pAllRuleList[i] === "\r") {
                        continue;
                    }
                    pTempRule = pAllRuleList[i].split(/\s* \s*/);
                    if (isLexerBlock) {
                        if ((pTempRule.length === 3 || (pTempRule.length === 4 && pTempRule[3] === "")) && ((pTempRule[2][0] === "\"" || pTempRule[2][0] === "'") && pTempRule[2].length > 3)) {
                            //TERMINALS
                            if (pTempRule[2][0] !== pTempRule[2][pTempRule[2].length - 1]) {
                                this._error(2003, {
                                    unexpectedSymbol: pTempRule[2][pTempRule[2].length - 1],
                                    expectedSymbol: pTempRule[2][0],
                                    grammarLine: i
                                });
                            }
                            pTempRule[2] = pTempRule[2].slice(1, pTempRule[2].length - 1);
                            var ch = pTempRule[2][0];
                            var sName;
                            if ((ch === "_") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
                                sName = this._pLexer.addKeyword(pTempRule[2], pTempRule[0]);
                            } else {
                                sName = this._pLexer.addPunctuator(pTempRule[2], pTempRule[0]);
                            }
                            this._pGrammarSymbols[sName] = pTempRule[2];
                        }
                        continue;
                    }
                    if (pTempRule[0] === "--LEXER--") {
                        isLexerBlock = true;
                        continue;
                    }
                    //NON TERMNINAL RULES
                    if (((this._pRulesDMap[pTempRule[0]]) !== undefined) === false) {
                        this._pRulesDMap[pTempRule[0]] = {};
                    }
                    pRule = {
                        left: pTempRule[0],
                        right: [],
                        index: 0
                    };
                    this._pSymbolMap[pTempRule[0]] = true;
                    this._pGrammarSymbols[pTempRule[0]] = pTempRule[0];
                    if (isAllNodeMode) {
                        pSymbolsWithNodeMap[pTempRule[0]] = akra.ENodeCreateMode.k_Default;
                    } else if (isNegateMode && !((pSymbolsWithNodeMap[pTempRule[0]]) !== undefined)) {
                        pSymbolsWithNodeMap[pTempRule[0]] = akra.ENodeCreateMode.k_Default;
                    } else if (isAddMode && !((pSymbolsWithNodeMap[pTempRule[0]]) !== undefined)) {
                        pSymbolsWithNodeMap[pTempRule[0]] = akra.ENodeCreateMode.k_Not;
                    }
                    for(j = 2; j < pTempRule.length; j++) {
                        if (pTempRule[j] === "") {
                            continue;
                        }
                        if (pTempRule[j] === "--AN") {
                            if (isAddMode) {
                                pSymbolsWithNodeMap[pTempRule[0]] = akra.ENodeCreateMode.k_Necessary;
                            }
                            continue;
                        }
                        if (pTempRule[j] === "--NN") {
                            if (isNegateMode && !isAllNodeMode) {
                                pSymbolsWithNodeMap[pTempRule[0]] = akra.ENodeCreateMode.k_Not;
                            }
                            continue;
                        }
                        if (pTempRule[j] === "--F") {
                            if ((!pTempRule[j + 1] || pTempRule[j + 1].length === 0)) {
                                this._error(2004, {
                                    grammarLine: i
                                });
                            }
                            var pFuncInfo = {
                                name: pTempRule[j + 1],
                                position: pRule.right.length,
                                rule: pRule
                            };
                            this._pAdditionalFuncInfoList.push(pFuncInfo);
                            j++;
                            continue;
                        }
                        if (pTempRule[j][0] === "'" || pTempRule[j][0] === "\"") {
                            if (pTempRule[j].length !== 3) {
                                this._error(2005, {
                                    badKeyword: pTempRule[j],
                                    grammarLine: i
                                });
                            }
                            if (pTempRule[j][0] !== pTempRule[j][2]) {
                                this._error(2003, {
                                    unexpectedSymbol: pTempRule[j][2],
                                    expectedSymbol: pTempRule[j][0],
                                    grammarLine: i
                                });
                                //this._error("Can`t generate rules from grammar! Unexpected symbol! Must be");
                                                            }
                            var sName = this._pLexer.addPunctuator(pTempRule[j][1]);
                            pRule.right.push(sName);
                            this._pSymbolMap[sName] = true;
                        } else {
                            pRule.right.push(pTempRule[j]);
                            this._pSymbolMap[pTempRule[j]] = true;
                        }
                    }
                    pRule.index = this._nRules;
                    this._pRulesDMap[pTempRule[0]][pRule.index] = pRule;
                    this._nRules += 1;
                }
            };
            Parser.prototype.generateFunctionByStateMap = function () {
                if (((this._pAdditionalFunctionsMap) === null)) {
                    return;
                }
                var pStateList = this._pStateList;
                var pFuncInfoList = this._pAdditionalFuncInfoList;
                var pFuncInfo;
                var pRule;
                var iPos = 0;
                var pFunc;
                var sGrammarSymbol;
                var i = 0, j = 0;
                var pFuncByStateDMap = {};
                pFuncByStateDMap = this._pAdidtionalFunctByStateDMap = {};
                for(i = 0; i < pFuncInfoList.length; i++) {
                    pFuncInfo = pFuncInfoList[i];
                    pFunc = this._pAdditionalFunctionsMap[pFuncInfo.name];
                    if (!((pFunc) !== undefined)) {
                        continue;
                    }
                    pRule = pFuncInfo.rule;
                    iPos = pFuncInfo.position;
                    sGrammarSymbol = pRule.right[iPos - 1];
                    for(j = 0; j < pStateList.length; j++) {
                        if (pStateList[j].hasRule(pRule, iPos)) {
                            if (!((pFuncByStateDMap[pStateList[j].index]) !== undefined)) {
                                pFuncByStateDMap[pStateList[j].index] = {};
                            }
                            pFuncByStateDMap[pStateList[j].index][sGrammarSymbol] = pFunc;
                        }
                    }
                }
            };
            Parser.prototype.generateFirstState = function (eType) {
                if (eType === akra.EParserType.k_LR0) {
                    this.generateFirstState_LR0();
                } else {
                    this.generateFirstState_LR();
                }
            };
            Parser.prototype.generateFirstState_LR0 = function () {
                var pState = new State();
                var pItem = new Item(this._pRulesDMap["S"][0], 0);
                this.pushBaseItem(pItem);
                pState.push(pItem);
                this.closure_LR0(pState);
                this.pushState(pState);
            };
            Parser.prototype.generateFirstState_LR = function () {
                var pState = new State();
                var pExpected = {};
                pExpected["$"] = true;
                pState.push(new Item(this._pRulesDMap["S"][0], 0, pExpected));
                this.closure_LR(pState);
                this.pushState(pState);
            };
            Parser.prototype.closure = function (pState, eType) {
                if (eType === akra.EParserType.k_LR0) {
                    return this.closure_LR0(pState);
                } else {
                    this.closure_LR(pState);
                }
            };
            Parser.prototype.closure_LR0 = function (pState) {
                var pItemList = pState.items;
                var i = 0, j = null;
                var sSymbol;
                for(i = 0; i < pItemList.length; i++) {
                    sSymbol = pItemList[i].mark();
                    if (sSymbol !== "END" && (!this.isTerminal(sSymbol))) {
                        for(j in this._pRulesDMap[sSymbol]) {
                            pState.tryPush_LR0(this._pRulesDMap[sSymbol][j], 0);
                        }
                    }
                }
                return pState;
            };
            Parser.prototype.closure_LR = function (pState) {
                var pItemList = (pState.items);
                var i = 0, j = null, k = null;
                var sSymbol;
                var pSymbols;
                var pTempSet;
                var isNewExpected = false;
                while(true) {
                    if (i === pItemList.length) {
                        if (!isNewExpected) {
                            break;
                        }
                        i = 0;
                        isNewExpected = false;
                    }
                    sSymbol = pItemList[i].mark();
                    if (sSymbol !== "END" && (!this.isTerminal(sSymbol))) {
                        pTempSet = pItemList[i].rule.right.slice(pItemList[i].position + 1);
                        pSymbols = this.firstTerminalForSet(pTempSet, pItemList[i].expectedSymbols);
                        for(j in this._pRulesDMap[sSymbol]) {
                            for(k in pSymbols) {
                                if (pState.tryPush_LR(this._pRulesDMap[sSymbol][j], 0, k)) {
                                    isNewExpected = true;
                                }
                            }
                        }
                    }
                    i++;
                }
                return pState;
            };
            Parser.prototype.nexeState = function (pState, sSymbol, eType) {
                if (eType === akra.EParserType.k_LR0) {
                    return this.nextState_LR0(pState, sSymbol);
                } else {
                    return this.nextState_LR(pState, sSymbol);
                }
            };
            Parser.prototype.nextState_LR0 = function (pState, sSymbol) {
                var pItemList = pState.items;
                var i = 0;
                var pNewState = new State();
                for(i = 0; i < pItemList.length; i++) {
                    if (sSymbol === pItemList[i].mark()) {
                        pNewState.push(new Item(pItemList[i].rule, pItemList[i].position + 1));
                    }
                }
                return pNewState;
            };
            Parser.prototype.nextState_LR = function (pState, sSymbol) {
                var pItemList = pState.items;
                var i = 0;
                var pNewState = new State();
                for(i = 0; i < pItemList.length; i++) {
                    if (sSymbol === pItemList[i].mark()) {
                        pNewState.push(new Item(pItemList[i].rule, pItemList[i].position + 1, pItemList[i].expectedSymbols));
                    }
                }
                return pNewState;
            };
            Parser.prototype.deleteNotBaseItems = function () {
                var i = 0;
                for(i = 0; i < this._pStateList.length; i++) {
                    this._pStateList[i].deleteNotBase();
                }
            };
            Parser.prototype.closureForItem = function (pRule, iPos) {
                var sIndex = "";
                sIndex += pRule.index + "_" + iPos;
                var pState = this._pStatesTempMap[sIndex];
                if (((pState) !== undefined)) {
                    return pState;
                } else {
                    var pExpected = {};
                    pExpected["##"] = true;
                    pState = new State();
                    pState.push(new Item(pRule, iPos, pExpected));
                    this.closure_LR(pState);
                    this._pStatesTempMap[sIndex] = pState;
                    return pState;
                }
            };
            Parser.prototype.addLinkExpected = function (pItem, pItemX) {
                var pTable = this._pExpectedExtensionDMap;
                var iIndex = pItem.index;
                if (!((pTable[iIndex]) !== undefined)) {
                    pTable[iIndex] = {};
                }
                pTable[iIndex][pItemX.index] = true;
            };
            Parser.prototype.determineExpected = function (pTestState, sSymbol) {
                var pStateX = pTestState.getNextStateBySymbol(sSymbol);
                if (((pStateX) === null)) {
                    return;
                }
                var pItemListX = pStateX.items;
                var pItemList = pTestState.items;
                var pState;
                var pItem;
                var i = 0, j = 0, k = null;
                var nBaseItemTest = pTestState.numBaseItems;
                var nBaseItemX = pStateX.numBaseItems;
                for(i = 0; i < nBaseItemTest; i++) {
                    pState = this.closureForItem(pItemList[i].rule, pItemList[i].position);
                    for(j = 0; j < nBaseItemX; j++) {
                        pItem = pState.hasChildItem(pItemListX[j]);
                        if (pItem) {
                            var pExpected = pItem.expectedSymbols;
                            for(k in pExpected) {
                                if (k === "##") {
                                    this.addLinkExpected(pItemList[i], pItemListX[j]);
                                } else {
                                    pItemListX[j].addExpected(k);
                                }
                            }
                        }
                    }
                }
            };
            Parser.prototype.generateLinksExpected = function () {
                var i = 0, j = null;
                var pStates = this._pStateList;
                for(i = 0; i < pStates.length; i++) {
                    for(j in this._pSymbolMap) {
                        this.determineExpected(pStates[i], j);
                    }
                }
            };
            Parser.prototype.expandExpected = function () {
                var pItemList = this._pBaseItemList;
                var pTable = this._pExpectedExtensionDMap;
                var i = 0, j = null;
                var sSymbol = null;
                var isNewExpected = false;
                pItemList[0].addExpected("$");
                pItemList[0].isNewExpected = true;
                while(true) {
                    if (i === pItemList.length) {
                        if (!isNewExpected) {
                            break;
                        }
                        isNewExpected = false;
                        i = 0;
                    }
                    if (pItemList[i].isNewExpected) {
                        var pExpected = pItemList[i].expectedSymbols;
                        for(sSymbol in pExpected) {
                            for(j in pTable[i]) {
                                if (pItemList[j].addExpected(sSymbol)) {
                                    isNewExpected = true;
                                }
                            }
                        }
                    }
                    pItemList[i].isNewExpected = false;
                    i++;
                }
            };
            Parser.prototype.generateStates = function (eType) {
                if (eType === akra.EParserType.k_LR0) {
                    this.generateStates_LR0();
                } else if (eType === akra.EParserType.k_LR1) {
                    this.generateStates_LR();
                } else if (eType === akra.EParserType.k_LALR) {
                    this.generateStates_LALR();
                }
            };
            Parser.prototype.generateStates_LR0 = function () {
                this.generateFirstState_LR0();
                var i = 0;
                var pStateList = this._pStateList;
                var sSymbol = null;
                var pState;
                for(i = 0; i < pStateList.length; i++) {
                    for(sSymbol in this._pSymbolMap) {
                        pState = this.nextState_LR0(pStateList[i], sSymbol);
                        if (!pState.isEmpty()) {
                            pState = this.tryAddState(pState, akra.EParserType.k_LR0);
                            this.addStateLink(pStateList[i], pState, sSymbol);
                        }
                    }
                }
            };
            Parser.prototype.generateStates_LR = function () {
                this._pFirstTerminalsDMap = {};
                this.generateFirstState_LR();
                var i = 0;
                var pStateList = this._pStateList;
                var sSymbol = null;
                var pState;
                for(i = 0; i < pStateList.length; i++) {
                    for(sSymbol in this._pSymbolMap) {
                        pState = this.nextState_LR(pStateList[i], sSymbol);
                        if (!pState.isEmpty()) {
                            pState = this.tryAddState(pState, akra.EParserType.k_LR1);
                            this.addStateLink(pStateList[i], pState, sSymbol);
                        }
                    }
                }
            };
            Parser.prototype.generateStates_LALR = function () {
                this._pStatesTempMap = {};
                this._pBaseItemList = [];
                this._pExpectedExtensionDMap = {};
                this._pFirstTerminalsDMap = {};
                this.generateStates_LR0();
                this.deleteNotBaseItems();
                this.generateLinksExpected();
                this.expandExpected();
                var i = 0;
                var pStateList = this._pStateList;
                for(i = 0; i < pStateList.length; i++) {
                    this.closure_LR(pStateList[i]);
                }
            };
            Parser.prototype.calcBaseItem = function () {
                var num = 0;
                var i = 0;
                for(i = 0; i < this._pStateList.length; i++) {
                    num += this._pStateList[i].numBaseItems;
                }
                return num;
            };
            Parser.prototype.printExpectedTable = function () {
                var i = null, j = null;
                var sMsg = "";
                for(i in this._pExpectedExtensionDMap) {
                    sMsg += "State " + this._pBaseItemList[i].state.index + ":   ";
                    sMsg += this._pBaseItemList[i].toString() + "  |----->\n";
                    for(j in this._pExpectedExtensionDMap[i]) {
                        sMsg += "\t\t\t\t\t" + "State " + this._pBaseItemList[j].state.index + ":   ";
                        sMsg += this._pBaseItemList[j].toString() + "\n";
                    }
                    sMsg += "\n";
                }
                return sMsg;
            };
            Parser.prototype.addReducing = function (pState) {
                var i = 0, j = null;
                var pItemList = pState.items;
                for(i = 0; i < pItemList.length; i++) {
                    if (pItemList[i].mark() === "END") {
                        if (pItemList[i].rule.left === "S") {
                            this.pushInSyntaxTable(pState.index, "$", this._pSuccessOperation);
                        } else {
                            var pExpected = pItemList[i].expectedSymbols;
                            for(j in pExpected) {
                                this.pushInSyntaxTable(pState.index, j, this._pReduceOperationsMap[pItemList[i].rule.index]);
                            }
                        }
                    }
                }
            };
            Parser.prototype.addShift = function (pState) {
                var i = null;
                var pStateMap = pState.nextStates;
                for(i in pStateMap) {
                    this.pushInSyntaxTable(pState.index, i, this._pShiftOperationsMap[pStateMap[i].index]);
                }
            };
            Parser.prototype.buildSyntaxTable = function () {
                this._pStateList = [];
                var pStateList = this._pStateList;
                var pState;
                //Generate states
                this.generateStates(this._eType);
                //Init necessary properties
                this._pSyntaxTable = {};
                this._pReduceOperationsMap = {};
                this._pShiftOperationsMap = {};
                this._pSuccessOperation = {
                    type: akra.EOperationType.k_Success
                };
                var i = 0, j = null, k = null;
                for(i = 0; i < pStateList.length; i++) {
                    this._pShiftOperationsMap[pStateList[i].index] = {
                        type: akra.EOperationType.k_Shift,
                        index: pStateList[i].index
                    };
                }
                for(j in this._pRulesDMap) {
                    for(k in this._pRulesDMap[j]) {
                        this._pReduceOperationsMap[k] = {
                            type: akra.EOperationType.k_Reduce,
                            rule: this._pRulesDMap[j][k]
                        };
                    }
                }
                //Build syntax table
                for(var i = 0; i < pStateList.length; i++) {
                    pState = pStateList[i];
                    this.addReducing(pState);
                    this.addShift(pState);
                }
            };
            Parser.prototype.readToken = function () {
                return this._pLexer.getNextToken();
            };
            Parser.prototype.operationAdditionalAction = function (iStateIndex, sGrammarSymbol) {
                var pFuncDMap = this._pAdidtionalFunctByStateDMap;
                if (!((this._pAdidtionalFunctByStateDMap) === null) && ((pFuncDMap[iStateIndex]) !== undefined) && ((pFuncDMap[iStateIndex][sGrammarSymbol]) !== undefined)) {
                    return pFuncDMap[iStateIndex][sGrammarSymbol].call(this);
                }
                return akra.EOperationType.k_Ok;
            };
            Parser.prototype.resumeParse = function () {
                try  {
                    var pTree = this._pSyntaxTree;
                    var pStack = this._pStack;
                    var pSyntaxTable = this._pSyntaxTable;
                    var isStop = false;
                    var isError = false;
                    var isPause = false;
                    var pToken = ((this._pToken) === null) ? this.readToken() : this._pToken;
                    var pOperation;
                    var iRuleLength;
                    var eAdditionalOperationCode;
                    var iStateIndex = 0;
                    while(!isStop) {
                        pOperation = pSyntaxTable[pStack[pStack.length - 1]][pToken.name];
                        if (((pOperation) !== undefined)) {
                            switch(pOperation.type) {
                                case akra.EOperationType.k_Success:
                                    isStop = true;
                                    break;
                                case akra.EOperationType.k_Shift:
                                    iStateIndex = pOperation.index;
                                    pStack.push(iStateIndex);
                                    pTree.addNode(pToken);
                                    eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pToken.name);
                                    if (eAdditionalOperationCode === akra.EOperationType.k_Error) {
                                        isError = true;
                                        isStop = true;
                                    } else if (eAdditionalOperationCode === akra.EOperationType.k_Pause) {
                                        this._pToken = null;
                                        isStop = true;
                                        isPause = true;
                                    } else if (eAdditionalOperationCode === akra.EOperationType.k_Ok) {
                                        pToken = this.readToken();
                                    }
                                    break;
                                case akra.EOperationType.k_Reduce:
                                    iRuleLength = pOperation.rule.right.length;
                                    pStack.length -= iRuleLength;
                                    iStateIndex = pSyntaxTable[pStack[pStack.length - 1]][pOperation.rule.left].index;
                                    pStack.push(iStateIndex);
                                    pTree.reduceByRule(pOperation.rule, this._pRuleCreationModeMap[pOperation.rule.left]);
                                    eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pOperation.rule.left);
                                    if (eAdditionalOperationCode === akra.EOperationType.k_Error) {
                                        isError = true;
                                        isStop = true;
                                    } else if (eAdditionalOperationCode === akra.EOperationType.k_Pause) {
                                        this._pToken = pToken;
                                        isStop = true;
                                        isPause = true;
                                    }
                                    break;
                            }
                        } else {
                            isError = true;
                            isStop = true;
                        }
                    }
                } catch (e) {
                    this._sFileName = "stdin";
                    return akra.EParserCode.k_Error;
                }
                if (isPause) {
                    return akra.EParserCode.k_Pause;
                }
                if (!isError) {
                    pTree.setRoot();
                    if (((this._fnFinishCallback) !== undefined)) {
                        this._fnFinishCallback.call(this._pCaller, akra.EParserCode.k_Ok, this.getParseFileName());
                    }
                    this._sFileName = "stdin";
                    return akra.EParserCode.k_Ok;
                } else {
                    this._error(2051, pToken);
                    if (((this._fnFinishCallback) !== undefined)) {
                        this._fnFinishCallback.call(this._pCaller, akra.EParserCode.k_Error, this.getParseFileName());
                    }
                    this._sFileName = "stdin";
                    return akra.EParserCode.k_Error;
                }
            };
            Parser.prototype.statesToString = function (isBaseOnly) {
                if (typeof isBaseOnly === "undefined") { isBaseOnly = true; }
                if (!((this._pStateList) !== undefined)) {
                    return null;
                }
                var sMsg = "";
                var i = 0;
                for(i = 0; i < this._pStateList.length; i++) {
                    sMsg += this._pStateList[i].toString(isBaseOnly);
                    sMsg += " ";
                }
                return sMsg;
            };
            Parser.prototype.operationToString = function (pOperation) {
                var sOperation = null;
                switch(pOperation.type) {
                    case akra.EOperationType.k_Shift:
                        sOperation = "SHIFT to state " + pOperation.index.toString();
                        break;
                    case akra.EOperationType.k_Reduce:
                        sOperation = "REDUCE by rule { " + this.ruleToString(pOperation.rule) + " }";
                        break;
                    case akra.EOperationType.k_Success:
                        sOperation = "SUCCESS";
                        break;
                }
                return sOperation;
            };
            Parser.prototype.ruleToString = function (pRule) {
                var sRule;
                sRule = pRule.left + " : " + pRule.right.join(" ");
                return sRule;
            };
            Parser.prototype.convertGrammarSymbol = function (sSymbol) {
                if (!this.isTerminal(sSymbol)) {
                    return sSymbol;
                } else {
                    return this._pLexer.getTerminalValueByName(sSymbol);
                }
            };
            return Parser;
        })();
        util.Parser = Parser;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var EffectParser = (function (_super) {
            __extends(EffectParser, _super);
            function EffectParser() {
                        _super.call(this);
                this._pIncludedFilesMap = null;
                this.addAdditionalFunction("addType", this._addType);
                this.addAdditionalFunction("includeCode", this._includeCode);
            }
            EffectParser.prototype.defaultInit = /**@protected*/ function () {
                _super.prototype.defaultInit.call(this);
                this.addTypeId("float2");
                this.addTypeId("float3");
                this.addTypeId("float4");
                this.addTypeId("float2x2");
                this.addTypeId("float3x3");
                this.addTypeId("float4x4");
                this.addTypeId("int2");
                this.addTypeId("int3");
                this.addTypeId("int4");
                this.addTypeId("bool2");
                this.addTypeId("bool3");
                this.addTypeId("bool4");
                this._pIncludedFilesMap = {};
                this._pIncludedFilesMap[this.getParseFileName()] = true;
            };
            EffectParser.prototype._addIncludedFile = function (sFileName) {
                this._pIncludedFilesMap[sFileName] = true;
            };
            EffectParser.prototype._addType = function () {
                var pTree = ((this)._pSyntaxTree);
                var pNode = pTree.getLastNode();
                var sTypeId;
                sTypeId = pNode.children[pNode.children.length - 2].value;
                this.addTypeId(sTypeId);
                return akra.EOperationType.k_Ok;
            };
            EffectParser.prototype.normalizeIncludePath = function (sFile) {
                return akra.util.URI.resolve(sFile, this.getParseFileName());
            };
            EffectParser.prototype._includeCode = function () {
                var pTree = ((this)._pSyntaxTree);
                var pNode = pTree.getLastNode();
                var sFile = pNode.value;
                //cuttin qoutes
                sFile = this.normalizeIncludePath(sFile.substr(1, sFile.length - 2));
                if (this._pIncludedFilesMap[sFile]) {
                    return akra.EOperationType.k_Ok;
                } else {
                    var pParserState = this._saveState();
                    var me = this;
                    var pFile = akra.io.fopen(sFile, "r+t");
                    pFile.read(function (err, sData) {
                        if (err) {
 {
                                util.logger.setSourceLocation("util/EffectParser.ts", 84);
                                util.logger.error("Can not read file");
                            }
                            ;
                        } else {
                            pParserState.source = pParserState.source.substr(0, pParserState.index) + sData + pParserState.source.substr(pParserState.index);
                            me._loadState(pParserState);
                            me._addIncludedFile(sFile);
                            me.resume();
                        }
                    });
                    return akra.EOperationType.k_Pause;
                }
            };
            EffectParser.prototype._saveState = function () {
                var pState = _super.prototype._saveState.call(this);
                pState["includeFiles"] = this._pIncludedFilesMap;
                return pState;
            };
            EffectParser.prototype._loadState = function (pState) {
                _super.prototype._loadState.call(this, pState);
                this._pIncludedFilesMap = pState["includeFiles"];
            };
            return EffectParser;
        })(util.Parser);
        util.EffectParser = EffectParser;        
        util.parser = new EffectParser();
        function initAFXParser(sGrammar) {
            util.parser.init(sGrammar, akra.EParseMode.k_Add | akra.EParseMode.k_Negate | akra.EParseMode.k_Optimize | akra.EParseMode.k_DebugMode);
        }
        util.initAFXParser = initAFXParser;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var EffectData = (function (_super) {
                    __extends(EffectData, _super);
                    function EffectData() {
                        _super.apply(this, arguments);

                        this._pFile = null;
                        this._pSyntaxTree = null;
                    }
                    Object.defineProperty(EffectData.prototype, "byteLength", {
                        get: /** @inline */function () {
                            return this._pFile ? this._pFile.byteLength : 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    EffectData.prototype.loadResource = function (sFileName) {
                        var reExt = /^(.+)(\.afx|\.abf|\.fx)$/;
                        var pRes = reExt.exec(sFileName);
                        if (((pRes) === null)) {
 {
                                akra.logger.setSourceLocation("resources/EffectData.ts", 28);
                                akra.logger.error("Bad effect file extension. Only .afx, .fx, .abf are available");
                            }
                            ;
                            return;
                        }
                        var isBinary = pRes[pRes.length - 1] === ".abf";
                        var pComposer = (((((((((this).pResourcePool)).pManager))).pEngine))._pComposer);
                        var me = this;
                        if (isBinary) {
                            var pFile = this._pFile = akra.io.fopen(sFileName, "r+b");
                            pFile.read(function (err, pData) {
                                if (err) {
 {
                                        akra.logger.setSourceLocation("resources/EffectData.ts", 46);
                                        akra.logger.error("Can not read file");
                                    }
                                    ;
                                } else {
                                    me._initFromBinaryData(pData, sFileName);
                                }
                            });
                            return true;
                        }
                        var pFile = this._pFile = akra.io.fopen(sFileName, "r+t");
                        pFile.read(function (pErr, sData) {
                            if (!((pErr) === null)) {
 {
                                    akra.logger.setSourceLocation("resources/EffectData.ts", 59);
                                    akra.logger.error("Can not load .afx file: '" + sFileName + "'");
                                }
                                ;
                            } else {
                                akra.util.parser.setParseFileName(sFileName);
                                akra.util.parser.parse(sData, me._initFromParsedEffect, me);
                            }
                        });
                        return true;
                    };
                    EffectData.prototype._initFromParsedEffect = function (eCode, sFileName) {
                        if (eCode === akra.EParserCode.k_Error) {
                            return;
                        }
                        this._pSyntaxTree = ((/*checked (origin: akra)>>*/akra.util.parser)._pSyntaxTree);
                        var pComposer = (((((((((this).pResourcePool)).pManager))).pEngine))._pComposer);
                        if (pComposer._loadEffectFromSyntaxTree(this._pSyntaxTree, sFileName)) {
                            /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.notifyLoaded();
                        }
                    };
                    EffectData.prototype._initFromBinaryData = function (pData, sFileName) {
                        // var pComposer: IAFXComposer = this.getManager().getEngine().getComposer();
                        // pComposer._loadEffectFromBinary(this._pSyntaxTree, sFileName);
                                            };
                    return EffectData;
                })(pool.ResourcePoolItem);
                resources.EffectData = EffectData;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var HardwareBuffer = (function (_super) {
                    __extends(HardwareBuffer, _super);
                    // byteLength: uint = 0;
                    // length: uint = 0;
                    function HardwareBuffer() {
                                        _super.call(this);
                        /**@protected*/ this._iFlags = 0;
                        /**@protected*/ this._isLocked = false;
                        /**@protected*/ this._pBackupCopy = null;
                        /**@protected*/ this._pBackupUpdated = false;
                        /**@protected*/ this._bIgnoreHardwareUpdate = false;
                    }
                    Object.defineProperty(HardwareBuffer.prototype, "byteLength", {
                        get: function () {
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(HardwareBuffer.prototype, "length", {
                        get: function () {
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    HardwareBuffer.prototype.isValid = /** @inline */function () {
                        return false;
                    };
                    HardwareBuffer.prototype.isDynamic = /** @inline */function () {
                        return (((this._iFlags) & (akra.EHardwareBufferFlags.DYNAMIC)) != 0);
                    };
                    HardwareBuffer.prototype.isStatic = /** @inline */function () {
                        return (((this._iFlags) & (akra.EHardwareBufferFlags.STATIC)) != 0);
                    };
                    HardwareBuffer.prototype.isStream = /** @inline */function () {
                        return (((this._iFlags) & (akra.EHardwareBufferFlags.STREAM)) != 0);
                    };
                    HardwareBuffer.prototype.isReadable = /** @inline */function () {
                        return (((this._iFlags) & (akra.EHardwareBufferFlags.READABLE)) != 0);
                    };
                    HardwareBuffer.prototype.isBackupPresent = /** @inline */function () {
                        return this._pBackupCopy != null;
                    };
                    HardwareBuffer.prototype.isSoftware = /** @inline */function () {
                        return (((this._iFlags) & (akra.EHardwareBufferFlags.SOFTWARE)) != 0);
                    };
                    HardwareBuffer.prototype.isAligned = /** @inline */function () {
                        return (((this._iFlags) & (akra.EHardwareBufferFlags.ALIGNMENT)) != 0);
                    };
                    HardwareBuffer.prototype.isLocked = /** @inline */function () {
                        return this._isLocked;
                    };
                    HardwareBuffer.prototype.clone = function (pSrc) {
                        return false;
                    };
                    HardwareBuffer.prototype.getFlags = /** @inline */function () {
                        return this._iFlags;
                    };
                    HardwareBuffer.prototype.readData = function (iOffset, iSize, ppDest) {
                        return false;
                    };
                    HardwareBuffer.prototype.writeData = function (pData, iOffset, iSize, bDiscardWholeBuffer) {
                        if (typeof bDiscardWholeBuffer === "undefined") { bDiscardWholeBuffer = false; }
                        return false;
                    };
                    HardwareBuffer.prototype.copyData = function (pSrcBuffer, iSrcOffset, iDstOffset, iSize, bDiscardWholeBuffer) {
                        if (typeof bDiscardWholeBuffer === "undefined") { bDiscardWholeBuffer = false; }
                        var pData = pSrcBuffer.lock(iSrcOffset, iSize);
                        this.writeData(pData, iDstOffset, iSize, bDiscardWholeBuffer);
                        pSrcBuffer.unlock();
                        return true;
                    };
                    HardwareBuffer.prototype.create = function (iSize, iFlags) {
                        if (typeof iFlags === "undefined") { iFlags = 0; }
                        iFlags |= akra.EHardwareBufferFlags.STATIC;
                        if ((((iFlags) & (akra.EHardwareBufferFlags.DYNAMIC)) != 0)) {
                            ((iFlags) &= ~(akra.EHardwareBufferFlags.STATIC));
                            if ((((iFlags) & (akra.EHardwareBufferFlags.BACKUP_COPY)) != 0)) {
                                ((iFlags) &= ~(akra.EHardwareBufferFlags.READABLE));
                            }
                        }
                        this._iFlags = iFlags;
                        /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyCreated();
                        /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyRestored();
                        return true;
                    };
                    HardwareBuffer.prototype.destroy = function () {
                        this._iFlags = 0;
                        /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyDestroyed();
                        /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyUnloaded();
                    };
                    HardwareBuffer.prototype.resize = function (iSize) {
                        return false;
                    };
                    HardwareBuffer.prototype.lock = function (iOffset, iSize, iLockFlags) {
                        if (typeof iLockFlags === "undefined") { iLockFlags = akra.EHardwareBufferFlags.READABLE; }
 {
                            akra.logger.setSourceLocation("core/pool/resources/HardwareBuffer.ts", 123);
                            akra.logger.assert(!((this)._isLocked), "Cannot lock this buffer, it is already locked!");
                        }
                        ;
                        if (arguments.length == 1) {
                            iLockFlags = arguments[0];
                            iOffset = 0;
                            iSize = this.byteLength;
                        }
                        var pResult = null;
                        if ((iOffset + iSize) > this.byteLength) {
 {
                                akra.logger.setSourceLocation("core/pool/resources/HardwareBuffer.ts", 134);
                                akra.logger.error("Lock request out of bounds.", "HardwareBuffer::lock");
                            }
                            ;
                        } else if (((this)._pBackupCopy != null)) {
                            if (!(((iLockFlags) & (akra.ELockFlags.WRITE)) != 0)) {
                                // we have to assume a read / write lock so we use the shadow buffer
                                // and tag for sync on unlock()
                                this._pBackupUpdated = true;
                            }
                            pResult = this._pBackupCopy.lock(iOffset, iSize, iLockFlags);
                        } else {
                            // Lock the real buffer if there is no shadow buffer
                            pResult = this.lockImpl(iOffset, iSize, iLockFlags);
                            this._isLocked = true;
                        }
                        this._iLockStart = iOffset;
                        this._iLockSize = iSize;
                        return pResult;
                    };
                    HardwareBuffer.prototype.unlock = function () {
 {
                            akra.logger.setSourceLocation("core/pool/resources/HardwareBuffer.ts", 158);
                            akra.logger.assert(((this)._isLocked), "Cannot unlock this buffer, it is not locked!");
                        }
                        ;
                        // If we used the shadow buffer this time...
                        if (this._pBackupCopy && ((this._pBackupCopy)._isLocked)) {
                            this._pBackupCopy.unlock();
                            // Potentially update the 'real' buffer from the shadow buffer
                            this.restoreFromBackup();
                        } else {
                            // Otherwise, unlock the real one
                            this.unlockImpl();
                            this._isLocked = false;
                        }
                    };
                    HardwareBuffer.prototype.restoreFromBackup = function () {
                        if (this._pBackupCopy && this._pBackupUpdated && !this._bIgnoreHardwareUpdate) {
                            // Do this manually to avoid locking problems
                            var pBackupData = this._pBackupCopy.lockImpl(this._iLockStart, this._iLockSize, akra.ELockFlags.READ);
                            // Lock with discard if the whole buffer was locked, otherwise normal
                            var iLockFlags;
                            if (this._iLockStart == 0 && this._iLockSize == this.byteLength) {
                                iLockFlags = akra.ELockFlags.DISCARD;
                            } else {
                                iLockFlags = akra.ELockFlags.NORMAL;
                            }
                            var pRealData = this.lockImpl(this._iLockStart, this._iLockSize, iLockFlags);
                            // Copy backup to real
                            this.copyBackupToRealImpl(pRealData, pBackupData, iLockFlags);
                            this.unlockImpl();
                            this._pBackupCopy.unlockImpl();
                            this._pBackupUpdated = false;
                            return true;
                        }
                        return false;
                    };
                    HardwareBuffer.prototype.createResource = function () {
                        // innitialize the resource (called once)
                         {
                            akra.logger.setSourceLocation("core/pool/resources/HardwareBuffer.ts", 206);
                            akra.logger.assert(!((((((this).iResourceFlags) & ((1 << ((/*checked (origin: akra)>>*/akra.EResourceItemEvents.CREATED))))) != 0))), "The resource has already been created.");
                        }
                        ;
                        // signal that the resource is now created,
                        // but has not been enabled
                        //this.notifyCreated();
                        /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyDisabled();
                        return true;
                    };
                    HardwareBuffer.prototype.destroyResource = function () {
                        // destroy the resource
                        //
                        // we permit redundant calls to destroy, so there are no asserts here
                        //
                        if (((((((this).iResourceFlags) & ((1 << ((/*checked (origin: akra)>>*/akra.EResourceItemEvents.CREATED))))) != 0)))) {
                            // disable the resource
                            this.disableResource();
                            this.destroy();
                            return true;
                        }
                        return false;
                    };
                    HardwareBuffer.prototype.restoreResource = function () {
 {
                            akra.logger.setSourceLocation("core/pool/resources/HardwareBuffer.ts", 232);
                            akra.logger.assert(((((((this).iResourceFlags) & ((1 << ((/*checked (origin: akra)>>*/akra.EResourceItemEvents.CREATED))))) != 0))), "The resource has not been created.");
                        }
                        ;
                        /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyRestored();
                        return true;
                    };
                    HardwareBuffer.prototype.disableResource = function () {
 {
                            akra.logger.setSourceLocation("core/pool/resources/HardwareBuffer.ts", 239);
                            akra.logger.assert(((((((this).iResourceFlags) & ((1 << ((/*checked (origin: akra)>>*/akra.EResourceItemEvents.CREATED))))) != 0))), "The resource has not been created.");
                        }
                        ;
                        /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyDisabled();
                        return true;
                    };
                    HardwareBuffer.prototype.lockImpl = /**@protected*/ function (iOffset, iSize, iLockFlags) {
                        return null;
                    };
                    HardwareBuffer.prototype.unlockImpl = /**@protected*/ function () {
                    };
                    HardwareBuffer.prototype.copyBackupToRealImpl = /**@protected*/ function (pRealData, pBackupData, iLockFlags) {
                    };
                    return HardwareBuffer;
                })(pool.ResourcePoolItem);
                resources.HardwareBuffer = HardwareBuffer;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLPixelBuffer = (function (_super) {
            __extends(WebGLPixelBuffer, _super);
            function WebGLPixelBuffer() {
                        _super.call(this);
                /**@protected*/ this._iWidth = 0;
                /**@protected*/ this._iHeight = 0;
                /**@protected*/ this._iDepth = 0;
                // Pitches (offsets between rows and slices)
                /**@protected*/ this._iRowPitch = 0;
                /**@protected*/ this._iSlicePitch = 0;
                /**@protected*/ this._eFormat = akra.EPixelFormats.UNKNOWN;
                //webgl specific
                /**@protected*/ this._pCurrentLock = null;
                /**@protected*/ this._pLockedBox = null;
                /**@protected*/ this._iCurrentLockFlags = 0;
                /**@protected*/ this._pBuffer = null;
                /**@protected*/ this._iWebGLInternalFormat = 0;
            }
            Object.defineProperty(WebGLPixelBuffer.prototype, "byteLength", {
                get: /** @inline */function () {
                    return this._iByteSize;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLPixelBuffer.prototype, "width", {
                get: /** @inline */function () {
                    return this._iWidth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLPixelBuffer.prototype, "height", {
                get: /** @inline */function () {
                    return this._iHeight;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLPixelBuffer.prototype, "depth", {
                get: /** @inline */function () {
                    return this._iDepth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLPixelBuffer.prototype, "format", {
                get: /** @inline */function () {
                    return this._eFormat;
                },
                enumerable: true,
                configurable: true
            });
            WebGLPixelBuffer.prototype.upload = //upload(download) data to(from) videocard.
            /**@protected*/ function (pData, pDestBox) {
 {
                    akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 51);
                    akra.logger.criticalError("Upload not possible for this pixelbuffer type");
                }
                ;
            };
            WebGLPixelBuffer.prototype.download = /**@protected*/ function (pData) {
 {
                    akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 55);
                    akra.logger.criticalError("Download not possible for this pixelbuffer type");
                }
                ;
            };
            WebGLPixelBuffer.prototype._bindToFramebuffer = function (pAttachment, iZOffset) {
 {
                    akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 59);
                    akra.logger.criticalError("Framebuffer bind not possible for this pixelbuffer type");
                }
                ;
            };
            WebGLPixelBuffer.prototype._getWebGLFormat = function () {
                return this._iWebGLInternalFormat;
            };
            WebGLPixelBuffer.prototype._clearRTT = function (iZOffset) {
            };
            WebGLPixelBuffer.prototype.reset = function (iWidth, iHeight) {
                if (typeof iWidth === "undefined") { iWidth = this._iWidth; }
                if (typeof iHeight === "undefined") { iHeight = iWidth; }
                this._iWidth = iWidth;
                this._iHeight = iHeight;
            };
            WebGLPixelBuffer.prototype.create = function () {
                if (arguments.length === 1) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 81);
                        akra.logger.criticalError("Invalid number of arguments. For PixelBuffer it must be six");
                    }
                    ;
                }
                var iWidth = arguments[0];
                var iHeight = arguments[1];
                var iDepth = arguments[2];
                var eFormat = arguments[3];
                var iFlags = arguments[4];
                _super.prototype.create.call(this, iFlags);
                this._iWidth = iWidth;
                this._iHeight = iHeight;
                this._iDepth = iDepth;
                this._eFormat = eFormat;
                this._iRowPitch = iWidth;
                this._iSlicePitch = iHeight * iWidth;
                this._iByteSize = iHeight * iWidth * (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor((eFormat)).elemBytes);
                this._pBuffer = new akra.pixelUtil.PixelBox(iWidth, iHeight, iDepth, eFormat);
                this._iWebGLInternalFormat = 0;
                return true;
            };
            WebGLPixelBuffer.prototype.destroy = function () {
                this._pBuffer = null;
                _super.prototype.destroy.call(this);
            };
            WebGLPixelBuffer.prototype.destroyResource = function () {
                this.destroy();
                /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyDestroyed();
                return true;
            };
            WebGLPixelBuffer.prototype.readData = function () {
 {
                    akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 121);
                    akra.logger.criticalError("Reading a byte range is not implemented. Use blitToMemory.");
                }
                ;
                return false;
            };
            WebGLPixelBuffer.prototype.writeData = function () {
 {
                    akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 128);
                    akra.logger.criticalError("Writing a byte range is not implemented. Use blitFromMemory.");
                }
                ;
                return false;
            };
            WebGLPixelBuffer.prototype.readPixels = function (pDestBox) {
                this.download(pDestBox);
                return true;
            };
            WebGLPixelBuffer.prototype.blit = function (pSource, pSrcBox, pDestBox) {
                if (arguments.length == 1) {
                    return this.blit(pSource, new akra.geometry.Box(0, 0, 0, pSource.width, pSource.height, pSource.depth), new akra.geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth));
                } else {
                    if (pSource === this) {
 {
                            akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 150);
                            akra.logger.criticalError("Source must not be the same object");
                        }
                        ;
                    }
                    /**@const*/ var pSrclock = pSource.lock(pSrcBox, akra.ELockFlags.READ);
                    var eLockMethod = akra.ELockFlags.NORMAL;
                    if (pDestBox.left === 0 && pDestBox.top === 0 && pDestBox.front === 0 && pDestBox.right === this._iWidth && pDestBox.bottom === this._iHeight && pDestBox.back === this._iDepth) {
                        // Entire buffer -- we can discard the previous contents
                        eLockMethod = akra.ELockFlags.DISCARD;
                    }
                    /**@const*/ var pDstlock = this.lock(pDestBox, eLockMethod);
                    if (pDstlock.width != pSrclock.width || pDstlock.height != pSrclock.height || pDstlock.depth != pSrclock.depth) {
                        // Scaling desired
                        pSrclock.scale(pDstlock);
                    } else {
                        // No scaling needed
                        akra.pixelUtil.bulkPixelConversion(pSrclock, pDstlock);
                    }
                    this.unlock();
                    pSource.unlock();
                    return true;
                }
            };
            WebGLPixelBuffer.prototype.blitFromMemory = function () {
                var pSource;
                var pDestBox;
                pSource = arguments[0];
                if (arguments.length === 1) {
                    pDestBox = new akra.geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
                    return this.blitFromMemory(pSource, pDestBox);
                } else {
                    pDestBox = arguments[1];
                }
                if (!this._pBuffer.contains(pDestBox)) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 200);
                        akra.logger.criticalError("Destination box out of range");
                    }
                    ;
                }
                var pScaledBox;
                if (pSource.width != pDestBox.width || pSource.height != pDestBox.height || pSource.depth != pDestBox.depth) {
                    // Scale to destination size.
                    // This also does pixel format conversion if needed
                    this.allocateBuffer();
                    pScaledBox = this._pBuffer.getSubBox(pDestBox);
                    pScaledBox.setConsecutive();
                    pSource.scale(pScaledBox, akra.EFilters.BILINEAR);
                } else if ((pSource.format !== this._eFormat) || (webgl.getWebGLFormat(pSource.format) === 0)) {
                    // Extents match, but format is not accepted as valid source format for GL
                    // do conversion in temporary buffer
                    this.allocateBuffer();
                    pScaledBox = this._pBuffer.getSubBox(pDestBox);
                    pScaledBox.setConsecutive();
                    akra.pixelUtil.bulkPixelConversion(pSource, pScaledBox);
                    // if(this._eFormat === EPixelFormats.A4R4G4B4)
                    // {
                    //     // ARGB->BGRA
                    //     convertToWebGLformat(pScaledBox, pScaledBox);
                    // }
                                    } else {
                    this.allocateBuffer();
                    pScaledBox = pSource;
                }
                this.upload(pScaledBox, pDestBox);
                this.freeBuffer();
                return true;
            };
            WebGLPixelBuffer.prototype.blitToMemory = function () {
                var pSrcBox;
                var pDest;
                if (arguments.length === 1) {
                    pDest = arguments[0];
                    pSrcBox = new akra.geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
                    return this.blitToMemory(pSrcBox, pDest);
                } else {
                    pSrcBox = arguments[0];
                    pDest = arguments[1];
                }
                if (!this._pBuffer.contains(pSrcBox)) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 260);
                        akra.logger.criticalError("source box out of range");
                    }
                    ;
                }
                if (pSrcBox.left == 0 && pSrcBox.right == this._iWidth && pSrcBox.top == 0 && pSrcBox.bottom == this._iHeight && pSrcBox.front == 0 && pSrcBox.back == this._iDepth && pDest.width == this._iWidth && pDest.height == this._iHeight && pDest.depth == this._iDepth && webgl.getWebGLFormat(pDest.format) != 0) {
                    // The direct case: the user wants the entire texture in a format supported by GL
                    // so we don't need an intermediate buffer
                    this.download(pDest);
                } else {
                    // Use buffer for intermediate copy
                    this.allocateBuffer();
                    // Download entire buffer
                    this.download(this._pBuffer);
                    if (pSrcBox.width != pDest.width || pSrcBox.height != pDest.height || pSrcBox.depth != pDest.depth) {
                        // We need scaling
                        this._pBuffer.getSubBox(pSrcBox).scale(pDest, akra.EFilters.BILINEAR);
                    } else {
                        // Just copy the bit that we need
                        akra.pixelUtil.bulkPixelConversion(this._pBuffer.getSubBox(pSrcBox), pDest);
                    }
                    this.freeBuffer();
                }
                return true;
            };
            WebGLPixelBuffer.prototype.getRenderTarget = function () {
                return null;
            };
            WebGLPixelBuffer.prototype.lock = function () {
                var pLockBox = null;
                var iLockFlags = 0;
                if ((typeof (arguments[0]) === "number")) {
                    var iOffset;
                    var iSize;
                    if (arguments.length === 1) {
                        iLockFlags = arguments[0];
                        iOffset = 0;
                        iSize = ((this)._iByteSize);
                    } else {
                        iOffset = arguments[0];
                        iSize = arguments[1];
                        iLockFlags = (arguments.length === 3) ? arguments[2] : akra.EHardwareBufferFlags.READABLE;
                    }
 {
                        akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 323);
                        akra.logger.assert(!((this)._isLocked), "Cannot lock this buffer, it is already locked!");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 325);
                        akra.logger.assert(iOffset === 0 && iSize === ((this)._iByteSize), "Cannot lock memory region, most lock box or entire buffer");
                    }
                    ;
                    pLockBox = new akra.geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
                } else {
                    pLockBox = arguments[0];
                }
                if (((this)._pBackupCopy != null)) {
                    if (!(((iLockFlags) & (akra.ELockFlags.WRITE)) != 0)) {
                        // we have to assume a read / write lock so we use the shadow buffer
                        // and tag for sync on unlock()
                        this._pBackupUpdated = true;
                    }
                    this._pCurrentLock = ((this._pBackupCopy)).lock(pLockBox, iLockFlags);
                } else {
                    this._pCurrentLock = this.lockImpl(pLockBox, iLockFlags);
                    this._isLocked = true;
                }
                return this._pCurrentLock;
            };
            WebGLPixelBuffer.prototype.allocateBuffer = /**@protected*/ function () {
                if (!((this._pBuffer.data) === null)) {
                    return;
                }
                this._pBuffer.data = new Uint8Array(((this)._iByteSize));
            };
            WebGLPixelBuffer.prototype.freeBuffer = /**@protected*/ function () {
                if ((((this._iFlags) & (akra.EHardwareBufferFlags.STATIC)) != 0)) {
                    this._pBuffer.data = null;
                }
            };
            WebGLPixelBuffer.prototype.lockImpl = /**@protected*/ function () {
                if (arguments.length === 3) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 368);
                        akra.logger.criticalError("lockImpl(offset,length) is not valid for PixelBuffers and should never be called");
                    }
                    ;
                }
                var pLockBox = arguments[0];
                var iLockFlags = arguments[1];
                this.allocateBuffer();
                if (!(((iLockFlags) & (akra.ELockFlags.DISCARD)) != 0) && (((this._iFlags) & (akra.EHardwareBufferFlags.READABLE)) != 0)) {
                    this.download(this._pBuffer);
                }
                this._iCurrentLockFlags = iLockFlags;
                this._pLockedBox = pLockBox;
                return this._pBuffer.getSubBox(pLockBox);
            };
            WebGLPixelBuffer.prototype.unlockImpl = /**@protected*/ function () {
                if ((((this._iCurrentLockFlags) & (akra.ELockFlags.WRITE)) != 0)) {
                    // From buffer to card, only upload if was locked for writing
                    this.upload(this._pCurrentLock, this._pLockedBox);
                }
                this.freeBuffer();
            };
            return WebGLPixelBuffer;
        })(akra.core.pool.resources.HardwareBuffer);
        webgl.WebGLPixelBuffer = WebGLPixelBuffer;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                (function (ETextureForcedFormatFlags) {
                    ETextureForcedFormatFlags._map = [];
                    ETextureForcedFormatFlags.FORCEMIPLEVELS = 0;
                    ETextureForcedFormatFlags._map[1] = "FORCEFORMAT";
                    ETextureForcedFormatFlags.FORCEFORMAT = 1;
                    ETextureForcedFormatFlags._map[2] = "FORCESIZE";
                    ETextureForcedFormatFlags.FORCESIZE = 2;
                })(resources.ETextureForcedFormatFlags || (resources.ETextureForcedFormatFlags = {}));
                var ETextureForcedFormatFlags = resources.ETextureForcedFormatFlags;
                var Texture = (function (_super) {
                    __extends(Texture, _super);
                    function Texture() {
                                        _super.call(this);
                        /**@protected*/ this._iFlags = akra.ETextureFlags.DEFAULT;
                        /**@protected*/ this._iWidth = 512;
                        /**@protected*/ this._iHeight = 512;
                        /**@protected*/ this._iDepth = 1;
                        /**@protected*/ this._eFormat = akra.EPixelFormats.UNKNOWN;
                        /**@protected*/ this._nMipLevels = 0;
                        /**@protected*/ this._nRequestedMipLevels = 0;
                        /**@protected*/ this._eTextureType = akra.ETextureTypes.TEXTURE_2D;
                        /**@protected*/ this._pParams = {};
                        /**@protected*/ this._isInternalResourceCreated = false;
                        /**@protected*/ this._isMipmapsHardwareGenerated = false;
                        this._pParams[akra.ETextureParameters.MIN_FILTER] = akra.ETextureFilters.NEAREST;
                        this._pParams[akra.ETextureParameters.MAG_FILTER] = akra.ETextureFilters.NEAREST;
                        this._pParams[akra.ETextureParameters.WRAP_S] = akra.ETextureWrapModes.CLAMP_TO_EDGE;
                        this._pParams[akra.ETextureParameters.WRAP_T] = akra.ETextureWrapModes.CLAMP_TO_EDGE;
                    }
                    Object.defineProperty(Texture.prototype, "width", {
                        get: /** @inline */function () {
                            return this._iWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Texture.prototype, "height", {
                        get: //inline set width(iWidth: uint) {
                        //    this._iWidth = this._iSrcWidth = iWidth;
                        //}
                        /** @inline */function () {
                            return this._iHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Texture.prototype, "depth", {
                        get: //inline set height(iHeight: uint) {
                        //    this._iHeight = this._iSrcHeight = iHeight;
                        //}
                        /** @inline */function () {
                            return this._iDepth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Texture.prototype, "format", {
                        get: //inline set depth(iDepth: uint) {
                        //    this._iDepth = this._iSrcDepth = iDepth;
                        //}
                        /** @inline */function () {
                            return this._eFormat;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Texture.prototype, "textureType", {
                        get: //inline set format(eFormat: EPixelFormats) {
                        //    this._eFormat = eFormat;
                        //    this._eDesiredFormat = eFormat;
                        //    this._eSrcFormat = eFormat;
                        //}
                        /** @inline */function () {
                            return this._eTextureType;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Texture.prototype, "mipLevels", {
                        get: //inline set textureType(eTextureType: ETextureTypes) {
                        //    this._eTextureType = eTextureType;
                        //}
                        /** @inline */function () {
                            return this._nMipLevels;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Texture.prototype, "byteLength", {
                        get: //inline set mipLevels(nMipLevels: uint) {
                        //    this._nMipLevels = nMipLevels;
                        //}
                        /*inline get desiredIntegerBitDepth(): uint {
                        return this._iDesiredIntegerBitDepth;
                        }
                        
                        inline set desiredIntegerBitDepth(iDesiredIntegerBitDepth: uint) {
                        this._iDesiredIntegerBitDepth = iDesiredIntegerBitDepth;
                        }
                        
                        inline get desiredFloatBitDepth(): uint {
                        return this._iDesiredFloatBitDepth;
                        }
                        
                        inline set desiredFloatBitDepth(iDesiredFloatBitDepth: uint) {
                        this._iDesiredFloatBitDepth = iDesiredFloatBitDepth;
                        }*/
                        /** @inline */function () {
                            return ((((this))._eTextureType === /*checked (origin: akra)>>*/akra.ETextureTypes.TEXTURE_CUBE_MAP ? 6 : 1) * /*checked (origin: akra)>>*/akra.pixelUtil.getMemorySize((this)._iWidth, (this)._iHeight, (this)._iDepth, (this)._eFormat));
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Texture.prototype.getFlags = /** @inline */function () {
                        return this._iFlags;
                    };
                    Texture.prototype.setFlags = /** @inline */function (iFlags) {
                        this._iFlags = iFlags;
                    };
                    Texture.prototype.isTexture2D = /** @inline */function () {
                        return this._eTextureType === akra.ETextureTypes.TEXTURE_2D;
                    };
                    Texture.prototype.isTextureCube = /** @inline */function () {
                        return this._eTextureType === akra.ETextureTypes.TEXTURE_CUBE_MAP;
                    };
                    Texture.prototype.isCompressed = /** @inline */function () {
                        return (this._eFormat >= akra.EPixelFormats.DXT1 && this._eFormat <= akra.EPixelFormats.DXT5) || (this._eFormat >= akra.EPixelFormats.PVRTC_RGB2 && this._eFormat <= akra.EPixelFormats.PVRTC_RGBA4);
                    };
                    Texture.prototype.isValid = /** @inline */function () {
                        return this._isInternalResourceCreated;
                    };
                    Texture.prototype.getNumFaces = // inline calculateSize(): uint {
                    //     return this.getNumFaces() * pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
                    // }
                    /** @inline */function () {
                        return this._eTextureType === akra.ETextureTypes.TEXTURE_CUBE_MAP ? 6 : 1;
                    };
                    Texture.prototype.getSize = /** @inline */function () {
                        //FIXME: necessary consider the number of texture MIP levels
                        return ((this)._eTextureType === /*checked (origin: akra)>>*/akra.ETextureTypes.TEXTURE_CUBE_MAP ? 6 : 1) * akra.pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
                    };
                    Texture.prototype.reset = function (iWidth, iHeight) {
                        if (typeof iWidth === "undefined") { iWidth = this._iWidth; }
                        if (typeof iHeight === "undefined") { iHeight = iWidth; }
                        this._iWidth = iWidth;
                        this._iHeight = iHeight;
                    };
                    Texture.prototype.getBuffer = function (iFace, iMipmap) {
                        return null;
                    };
                    Texture.prototype.create = function (iWidth, iHeight, iDepth, pPixels, eFlags, nMipLevels, nFaces, eTextureType, eFormat) {
                        if (typeof iDepth === "undefined") { iDepth = 1; }
                        if (typeof pPixels === "undefined") { pPixels = null; }
                        if (typeof eFlags === "undefined") { eFlags = akra.ETextureFlags.DEFAULT; }
                        if (typeof nMipLevels === "undefined") { nMipLevels = 0; }
                        if (typeof nFaces === "undefined") { nFaces = 0; }
                        if (typeof eTextureType === "undefined") { eTextureType = akra.ETextureTypes.TEXTURE_2D; }
                        if (typeof eFormat === "undefined") { eFormat = akra.EPixelFormats.B8G8R8; }
                        if (eTextureType != akra.ETextureTypes.TEXTURE_2D && eTextureType != akra.ETextureTypes.TEXTURE_CUBE_MAP) {
 {
                                akra.logger.setSourceLocation("core/pool/resources/Texture.ts", 183);
                                akra.logger.criticalError("Заданный тип текстуры не поддреживается");
                            }
                            ;
                            return false;
                        }
                        this._eTextureType = eTextureType;
                        this._iWidth = iWidth;
                        this._iHeight = iHeight;
                        this._iDepth = iDepth;
                        this._iFlags = eFlags;
                        this._nMipLevels = nMipLevels;
                        this._eFormat = eFormat;
                        if (akra.isArray(pPixels)) {
                            pPixels = new Uint8Array(pPixels);
                            return this.loadRawData(pPixels, iWidth, iHeight, iDepth, eFormat, nFaces, nMipLevels);
                        } else if (((pPixels) !== null && typeof (pPixels) === "object" && typeof (pPixels).byteOffset === "number")) {
                            return this.loadRawData(pPixels, iWidth, iHeight, iDepth, eFormat, nFaces, nMipLevels);
                        } else {
                            return this.createInternalTexture(pPixels);
                        }
                    };
                    Texture.prototype.loadResource = function (sFilename) {
                        if (arguments.length == 0) {
                            return;
                        }
                        var pImage = (((((this).pResourcePool)).pManager)).loadImage(sFilename);
                        if (pImage.isResourceLoaded()) {
                            return this.loadImage(pImage);
                        }
                        // LOG("Texture::loadResource(" + sFilename + ")", pImage);
                        ((pImage).getEventTable().addDestination(((((pImage)))._iGuid), ("loaded"), (this), ("_onImageLoad"), (undefined)));
                        return true;
                    };
                    Texture.prototype._onImageLoad = function (pImage) {
                        ((pImage).getEventTable().removeDestination(((((pImage)))._iGuid), ("loaded"), (this), ("_onImageLoad"), (undefined)));
                        this.loadImage(pImage);
                        // debug_print("texture/image loaded: ", pImage.findResourceName());
                                            };
                    Texture.prototype.destroyResource = function () {
                        this.freeInternalTexture();
                        /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyDestroyed();
                        return true;
                    };
                    Texture.prototype.setFilter = function (eParam, eValue) {
                        this._pParams[eParam] = eValue;
                        return this._setFilterInternalTexture(eParam, eValue);
                    };
                    Texture.prototype.setWrapMode = function (eParam, eValue) {
                        this._pParams[eParam] = eValue;
                        return this._setWrapModeInternalTexture(eParam, eValue);
                    };
                    Texture.prototype.getFilter = /** @inline */function (eParam) {
                        // if(!isDefAndNotNull(this._pParams[eParam])) {
                        //     this._pParams[eParam] = this._getFilterInternalTexture(eParam);
                        // }
                        return this._pParams[eParam];
                    };
                    Texture.prototype.getWrapMode = /** @inline */function (eParam) {
                        // if(!isDefAndNotNull(this._pParams[eParam])) {
                        //     this._pParams[eParam] = this._getWrapModeInternalTexture(eParam);
                        // }
                        return this._pParams[eParam];
                    };
                    Texture.prototype._setFilterInternalTexture = /**@protected*/ function (eParam, eValue) {
 {
                            akra.logger.setSourceLocation("core/pool/resources/Texture.ts", 269);
                            akra.logger.criticalError("virual");
                        }
                        ;
                        return false;
                    };
                    Texture.prototype._setWrapModeInternalTexture = /**@protected*/ function (eParam, eValue) {
 {
                            akra.logger.setSourceLocation("core/pool/resources/Texture.ts", 273);
                            akra.logger.criticalError("virual");
                        }
                        ;
                        return false;
                    };
                    Texture.prototype._getFilterInternalTexture = /**@protected*/ function (eParam) {
 {
                            akra.logger.setSourceLocation("core/pool/resources/Texture.ts", 278);
                            akra.logger.criticalError("virual");
                        }
                        ;
                        return 0;
                    };
                    Texture.prototype._getWrapModeInternalTexture = /**@protected*/ function (eParam) {
 {
                            akra.logger.setSourceLocation("core/pool/resources/Texture.ts", 282);
                            akra.logger.criticalError("virual");
                        }
                        ;
                        return 0;
                    };
                    Texture.prototype.loadRawData = function (pData, iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps) {
                        if (typeof iDepth === "undefined") { iDepth = 1; }
                        if (typeof eFormat === "undefined") { eFormat = akra.EPixelFormats.BYTE_RGB; }
                        if (typeof nFaces === "undefined") { nFaces = 1; }
                        if (typeof nMipMaps === "undefined") { nMipMaps = 0; }
                        var pTempImg = (((((this).pResourcePool)).pManager)).imagePool.findResource(".texture.temp_image");
                        if (((pTempImg) === null)) {
                            pTempImg = (((((this).pResourcePool)).pManager)).imagePool.createResource(".texture.temp_image");
                        }
                        pTempImg.loadRawData(pData, iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps);
                        var isLoaded = this.loadImage(pTempImg);
                        (((((this).pResourcePool)).pManager)).imagePool.destroyResource(pTempImg);
                        return isLoaded;
                    };
                    Texture.prototype.loadImage = function (pImage) {
                        var isLoaded = this._loadImages(pImage);
                        if (isLoaded) {
                            /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.notifyLoaded();
                            return true;
                        } else {
                            return false;
                        }
                    };
                    Texture.prototype.loadImages = function (pImages) {
                        var isLoaded = this._loadImages(pImages);
                        if (isLoaded) {
                            /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.notifyLoaded();
                            return true;
                        } else {
                            return false;
                        }
                    };
                    Texture.prototype._loadImages = function (pImage) {
                        if (((((((this).iResourceFlags) & ((1 << ((/*checked (origin: akra)>>*/akra.EResourceItemEvents.LOADED))))) != 0)))) {
 {
                                akra.logger.setSourceLocation("core/pool/resources/Texture.ts", 340);
                                akra.logger.warning("Yoy try to load texture when it already have been loaded. All texture data was destoyed.");
                            }
                            ;
                            this.freeInternalTexture();
                        }
                        var pMainImage = null;
                        var pImageList = null;
                        if (!akra.isArray(pImage)) {
                            pMainImage = pImage;
                            pImageList = new Array(0);
                            pImageList[0] = pMainImage;
                        } else {
                            pImageList = arguments[0];
                            if (pImageList.length === 0) {
 {
                                    akra.logger.setSourceLocation("core/pool/resources/Texture.ts", 357);
                                    akra.logger.criticalError("Cannot load empty list of images");
                                }
                                ;
                                return false;
                            }
                            pMainImage = pImageList[0];
                        }
                        this._iWidth = pMainImage.width;
                        this._iHeight = pMainImage.height;
                        this._iDepth = pMainImage.depth;
                        // Get source image format and adjust if required
                        if (akra.webgl.isWebGLFormatSupport(pMainImage.format)) {
                            this._eFormat = pMainImage.format;
                        } else {
 {
                                akra.logger.setSourceLocation("core/pool/resources/Texture.ts", 377);
                                akra.logger.warning("Format not support(" + (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor((pMainImage.format)).name) + ")");
                            }
                            ;
                            if (pMainImage.convert(akra.EPixelFormats.B8G8R8A8)) {
                                this._eFormat = pMainImage.format;
                            } else {
 {
                                    akra.logger.setSourceLocation("core/pool/resources/Texture.ts", 384);
                                    akra.logger.criticalError("Format not convert");
                                }
                                ;
                            }
                        }
                        for(i = 1; i < pImageList.length; i++) {
                            if (!pImageList[i].convert(pMainImage.format)) {
 {
                                    akra.logger.setSourceLocation("core/pool/resources/Texture.ts", 392);
                                    akra.logger.criticalError("Format not support and not convert");
                                }
                                ;
                            }
                        }
                        // The custom mipmaps in the image have priority over everything
                        var iImageMips = pMainImage.numMipMaps;
                        if (iImageMips == resources.Img.getMaxMipmaps(this._iWidth, this._iHeight, this._iDepth, this._eFormat)) {
                            this._nMipLevels = iImageMips;
                            // Disable flag for auto mip generation
                            ((this._iFlags) &= ~(akra.ETextureFlags.AUTOMIPMAP));
                        } else {
                            this._nMipLevels = 0;
                        }
                        // Check if we're loading one image with multiple faces
                        // or a vector of images representing the faces
                        var iFaces = 0;
                        var isMultiImage = false;
                        if (pImageList.length == 6) {
                            iFaces = 6;
                            isMultiImage = true;
                            this._eTextureType = akra.ETextureTypes.TEXTURE_CUBE_MAP;
                        } else if (pMainImage.numFaces == 6) {
                            iFaces = 6;
                            isMultiImage = false;
                            this._eTextureType = akra.ETextureTypes.TEXTURE_CUBE_MAP;
                        } else {
                            iFaces = 1;
                            isMultiImage = false;
                            this._eTextureType = akra.ETextureTypes.TEXTURE_2D;
                        }
                        // Check wether number of faces in images exceeds number of faces
                        // in this texture. If so, clamp it.
                        if (iFaces > ((this)._eTextureType === /*checked (origin: akra)>>*/akra.ETextureTypes.TEXTURE_CUBE_MAP ? 6 : 1)) {
                            iFaces = ((this)._eTextureType === /*checked (origin: akra)>>*/akra.ETextureTypes.TEXTURE_CUBE_MAP ? 6 : 1);
                        }
                        // Create the texture
                        this.createInternalTexture(null);
                        // Main loading loop
                        // imageMips == 0 if the image has no custom mipmaps, otherwise contains the number of custom mips
                        var mip = 0;
                        var i = 0;
                        for(mip = 0; mip <= this._nMipLevels; ++mip) {
                            for(i = 0; i < iFaces; ++i) {
                                var pSrc;
                                if (isMultiImage) {
                                    // Load from multiple images
                                    pSrc = pImageList[i].getPixels(0, mip);
                                    //console.log(mip,i);
                                                                    } else {
                                    // Load from faces of images[0] or main Image
                                    //console.log(mip,i);
                                    pSrc = pMainImage.getPixels(i, mip);
                                }
                                // Destination: entire texture. blitFromMemory does the scaling to
                                // a power of two for us when needed
                                //console.log(pSrc);
                                //console.log(this.getBuffer(i, mip));
                                this.getBuffer(i, mip).blitFromMemory(pSrc);
                            }
                        }
                        return true;
                    };
                    Texture.prototype.convertToImage = function (pDestImage, bIncludeMipMaps) {
                        // CRITICAL("!!!нехуй")
                        var iNumMips = bIncludeMipMaps ? this._nMipLevels + 1 : 1;
                        var iDataSize = akra.pixelUtil.calculateSizeForImage(iNumMips, ((this)._eTextureType === /*checked (origin: akra)>>*/akra.ETextureTypes.TEXTURE_CUBE_MAP ? 6 : 1), this._iWidth, this._iHeight, this._iDepth, this._eFormat);
                        var pPixData = new Uint8Array(iDataSize);
                        // if there are multiple faces and mipmaps we must pack them into the data
                        // faces, then mips
                        var pCurrentPixData = pPixData;
                        var iFace = 0;
                        var mip = 0;
                        for(iFace = 0; iFace < ((this)._eTextureType === /*checked (origin: akra)>>*/akra.ETextureTypes.TEXTURE_CUBE_MAP ? 6 : 1); ++iFace) {
                            for(mip = 0; mip < iNumMips; ++mip) {
                                var iMipDataSize = akra.pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
                                var pPixBox = new akra.pixelUtil.PixelBox(this._iWidth, this._iHeight, this._iDepth, this._eFormat, pCurrentPixData);
                                this.getBuffer(iFace, mip).blitToMemory(pPixBox);
                                pCurrentPixData = pCurrentPixData.subarray(iMipDataSize);
                            }
                        }
                        // load, and tell Image to delete the memory when it's done.
                        pDestImage.loadDynamicImage(pPixData, this._iWidth, this._iHeight, this._iDepth, this._eFormat, ((this)._eTextureType === /*checked (origin: akra)>>*/akra.ETextureTypes.TEXTURE_CUBE_MAP ? 6 : 1), iNumMips - 1);
                    };
                    Texture.prototype.copyToTexture = function (pTarget) {
                        if (pTarget.getNumFaces() !== ((this)._eTextureType === /*checked (origin: akra)>>*/akra.ETextureTypes.TEXTURE_CUBE_MAP ? 6 : 1)) {
 {
                                akra.logger.setSourceLocation("core/pool/resources/Texture.ts", 514);
                                akra.logger.criticalError("Texture types must match");
                            }
                            ;
                        }
                        var nMipLevels = Math.min(this._nMipLevels, pTarget.mipLevels);
                        if ((((this._iFlags) & (akra.ETextureFlags.AUTOMIPMAP)) != 0) || (((((this)._iFlags)) & (akra.ETextureFlags.AUTOMIPMAP)) != 0)) {
                            nMipLevels = 0;
                        }
                        var iFace = 0, mip = 0;
                        for(iFace = 0; iFace < ((this)._eTextureType === /*checked (origin: akra)>>*/akra.ETextureTypes.TEXTURE_CUBE_MAP ? 6 : 1); iFace++) {
                            for(mip = 0; mip <= nMipLevels; mip++) {
                                pTarget.getBuffer(iFace, mip).blit(this.getBuffer(iFace, mip));
                            }
                        }
                    };
                    Texture.prototype.createInternalTexture = function (cFillColor) {
                        if (typeof cFillColor === "undefined") { cFillColor = null; }
                        if (!this._isInternalResourceCreated) {
                            this._createInternalTextureImpl(cFillColor);
                            this._isInternalResourceCreated = true;
                            /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyCreated();
                            return true;
                        }
                        return false;
                    };
                    Texture.prototype.freeInternalTexture = function () {
                        if (this._isInternalResourceCreated) {
                            this.freeInternalTextureImpl();
                            this._isInternalResourceCreated = false;
                            /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyDestroyed();
                            return true;
                        }
                        return false;
                    };
                    Texture.prototype._createInternalTextureImpl = /**@protected*/ function (cFillColor) {
                        if (typeof cFillColor === "undefined") { cFillColor = null; }
                        return false;
                    };
                    Texture.prototype.freeInternalTextureImpl = /**@protected*/ function () {
                        return false;
                    };
                    Texture.prototype.setPixelRGBA = function (i1, i2, iTextureWidth, iTextureHeight, pBuffer) {
                        return;
                    };
                    return Texture;
                })(pool.ResourcePoolItem);
                resources.Texture = Texture;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    (function (ECameraParameters) {
        ECameraParameters._map = [];
        ECameraParameters.CONST_ASPECT = 1;
    })(akra.ECameraParameters || (akra.ECameraParameters = {}));
    var ECameraParameters = akra.ECameraParameters;
    (function (ECameraTypes) {
        ECameraTypes._map = [];
        ECameraTypes._map[0] = "PERSPECTIVE";
        ECameraTypes.PERSPECTIVE = 0;
        ECameraTypes._map[1] = "ORTHO";
        ECameraTypes.ORTHO = 1;
        ECameraTypes._map[2] = "OFFSET_ORTHO";
        ECameraTypes.OFFSET_ORTHO = 2;
    })(akra.ECameraTypes || (akra.ECameraTypes = {}));
    var ECameraTypes = akra.ECameraTypes;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    (function (EFramebuffer) {
        EFramebuffer._map = [];
        EFramebuffer._map[0] = "FRONT";
        EFramebuffer.FRONT = 0;
        EFramebuffer._map[1] = "BACK";
        EFramebuffer.BACK = 1;
        EFramebuffer._map[2] = "AUTO";
        EFramebuffer.AUTO = 2;
    })(akra.EFramebuffer || (akra.EFramebuffer = {}));
    var EFramebuffer = akra.EFramebuffer;
    ;
    (function (EStatFlags) {
        EStatFlags._map = [];
        EStatFlags.NONE = 0;
        EStatFlags.FPS = 1;
        EStatFlags.AVG_FPS = 2;
        EStatFlags.BEST_FPS = 4;
        EStatFlags.WORST_FPS = 8;
        EStatFlags.TRIANGLE_COUNT = 16;
        EStatFlags.ALL = 0xFFFF;
    })(akra.EStatFlags || (akra.EStatFlags = {}));
    var EStatFlags = akra.EStatFlags;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        var VariableBlendContainer = (function () {
            function VariableBlendContainer() {
                /**@protected*/ this._pVarListMap = null;
                /**@protected*/ this._pVarKeys = null;
                /**@protected*/ this._pKeyToIndexMap = null;
                /**@protected*/ this._pVarBlendTypeMap = null;
                this._pVarListMap = {};
                this._pVarKeys = [];
                this._pKeyToIndexMap = {};
                this._pVarBlendTypeMap = {};
            }
            Object.defineProperty(VariableBlendContainer.prototype, "keys", {
                get: /** @inline */function () {
                    return this._pVarKeys;
                },
                enumerable: true,
                configurable: true
            });
            VariableBlendContainer.prototype.getVarList = /** @inline */function (sKey) {
                return this._pVarListMap[sKey];
            };
            VariableBlendContainer.prototype.getBlendType = /** @inline */function (sKey) {
                return this._pVarBlendTypeMap[sKey];
            };
            VariableBlendContainer.prototype.getKeyIndex = /** @inline */function (sKey) {
                return this._pKeyToIndexMap[sKey];
            };
            VariableBlendContainer.prototype.addVariable = function (pVariable, eBlendMode) {
                var sName = pVariable.getRealName();
                if (!((this._pVarListMap[sName]) !== undefined)) {
                    this._pVarListMap[sName] = [
                        pVariable
                    ];
                    this._pVarKeys.push(sName);
                    this._pKeyToIndexMap[sName] = this._pVarKeys.length - 1;
                    this._pVarBlendTypeMap[sName] = pVariable.getType();
                    return true;
                }
                var pBlendType = this._pVarBlendTypeMap[sName].blend(pVariable.getType(), eBlendMode);
                if (pBlendType === this._pVarBlendTypeMap[sName]) {
                    return true;
                }
                if (((pBlendType) === null)) {
 {
                        akra.logger.setSourceLocation("fx/BlendContainers.ts", 62);
                        akra.logger.error("Could not blend type for variable '" + sName + "'");
                    }
                    ;
                    return false;
                }
                this._pVarListMap[sName].push(pVariable);
                this._pVarBlendTypeMap[sName] = pBlendType;
                return true;
            };
            VariableBlendContainer.prototype.hasVariableWithName = function (sName) {
                if (!((this._pVarBlendTypeMap[sName]) != null)) {
                    this._pVarBlendTypeMap[sName] = null;
                    return false;
                }
                return true;
            };
            VariableBlendContainer.prototype.hasVariable = /** @inline */function (pVar) {
                return this.hasVariableWithName(pVar.getRealName());
            };
            VariableBlendContainer.prototype.getVariableByName = /** @inline */function (sName) {
                return this.hasVariableWithName(sName) ? this._pVarListMap[sName][0] : null;
            };
            VariableBlendContainer.prototype.getDeclCodeForVar = /** @inline */function (sName, bWithInitializer) {
                var pType = ((this)._pVarBlendTypeMap[(sName)]);
                var sCode = pType.toFinalCode() + " ";
                var pVar = ((this).hasVariableWithName((sName)) ? (this)._pVarListMap[(sName)][0] : null);
                sCode += pVar.getRealName();
                if (pVar.getType().isNotBaseArray()) {
                    var iLength = pVar.getType().getLength();
                    if (akra.webgl.isANGLE && iLength === 1 && pVar.getType().isComplex()) {
                        sCode += "[" + 2 + "]";
                    } else {
                        sCode += "[" + iLength + "]";
                    }
                }
                if (bWithInitializer && pVar.hasInitializer()) {
                    sCode += "=" + pVar.getInitializeExpr().toFinalCode();
                }
                return sCode;
            };
            VariableBlendContainer.prototype.forEach = function (sKey, fnModifier) {
                if (this.hasVariableWithName(sKey)) {
                    var pVarList = ((this)._pVarListMap[(sKey)]);
                    for(var i = 0; i < pVarList.length; i++) {
                        fnModifier.call(null, pVarList[i]);
                    }
                }
            };
            VariableBlendContainer.prototype.setNameForEach = function (sKey, sNewRealName) {
                if (this.hasVariableWithName(sKey)) {
                    var pVarList = ((this)._pVarListMap[(sKey)]);
                    for(var i = 0; i < pVarList.length; i++) {
                        pVarList[i].setRealName(sNewRealName);
                    }
                }
            };
            return VariableBlendContainer;
        })();
        fx.VariableBlendContainer = VariableBlendContainer;        
        var ComplexTypeBlendContainer = (function () {
            function ComplexTypeBlendContainer() {
                this._pTypeListMap = null;
                this._pTypeKeys = null;
                this._pTypeListMap = {};
                this._pTypeKeys = [];
            }
            Object.defineProperty(ComplexTypeBlendContainer.prototype, "keys", {
                get: /** @inline */function () {
                    return this._pTypeKeys;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ComplexTypeBlendContainer.prototype, "types", {
                get: /** @inline */function () {
                    return this._pTypeListMap;
                },
                enumerable: true,
                configurable: true
            });
            ComplexTypeBlendContainer.prototype.addComplexType = function (pComplexType) {
                var pFieldList = (pComplexType)._getFieldDeclList();
                for(var i = 0; i < pFieldList.length; i++) {
                    if (pFieldList[i].getType().isComplex()) {
                        if (!this.addComplexType(pFieldList[i].getType().getBaseType())) {
                            return false;
                        }
                    }
                }
                var sName = pComplexType.getRealName();
                if (!((this._pTypeListMap[sName]) !== undefined)) {
                    this._pTypeListMap[sName] = pComplexType;
                    this._pTypeKeys.push(sName);
                    return true;
                }
                var pBlendType = this._pTypeListMap[sName].blend(pComplexType, akra.EAFXBlendMode.k_TypeDecl);
                if (((pBlendType) === null)) {
 {
                        akra.logger.setSourceLocation("fx/BlendContainers.ts", 173);
                        akra.logger.error("Could not blend type declaration '" + sName + "'");
                    }
                    ;
                    return false;
                }
                this._pTypeListMap[sName] = pBlendType;
                return true;
            };
            ComplexTypeBlendContainer.prototype.addFromVarConatiner = function (pContainer) {
                if (((pContainer) === null)) {
                    return true;
                }
                var pKeys = (pContainer._pVarKeys);
                for(var i = 0; i < pKeys.length; i++) {
                    var pType = (pContainer._pVarBlendTypeMap[(pKeys[i])]).getBaseType();
                    if (pType.isComplex()) {
                        if (!this.addComplexType(pType)) {
                            return false;
                        }
                    }
                }
                return true;
            };
            return ComplexTypeBlendContainer;
        })();
        fx.ComplexTypeBlendContainer = ComplexTypeBlendContainer;        
        var ExtSystemDataContainer = (function () {
            function ExtSystemDataContainer() {
                /**@protected*/ this._pExtSystemMacrosList = null;
                /**@protected*/ this._pExtSystemTypeList = null;
                /**@protected*/ this._pExtSystemFunctionList = null;
                this._pExtSystemMacrosList = [];
                this._pExtSystemTypeList = [];
                this._pExtSystemFunctionList = [];
            }
            Object.defineProperty(ExtSystemDataContainer.prototype, "macroses", {
                get: /** @inline */function () {
                    return this._pExtSystemMacrosList;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ExtSystemDataContainer.prototype, "types", {
                get: /** @inline */function () {
                    return this._pExtSystemTypeList;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ExtSystemDataContainer.prototype, "functions", {
                get: /** @inline */function () {
                    return this._pExtSystemFunctionList;
                },
                enumerable: true,
                configurable: true
            });
            ExtSystemDataContainer.prototype.addFromFunction = function (pFunction) {
                var pTypes = pFunction._getExtSystemTypeList();
                var pMacroses = pFunction._getExtSystemMacrosList();
                var pFunctions = pFunction._getExtSystemFunctionList();
                if (!((pTypes) === null)) {
                    for(var j = 0; j < pTypes.length; j++) {
                        if (this._pExtSystemTypeList.indexOf(pTypes[j]) === -1) {
                            this._pExtSystemTypeList.push(pTypes[j]);
                        }
                    }
                }
                if (!((pMacroses) === null)) {
                    for(var j = 0; j < pMacroses.length; j++) {
                        if (this._pExtSystemMacrosList.indexOf(pMacroses[j]) === -1) {
                            this._pExtSystemMacrosList.push(pMacroses[j]);
                        }
                    }
                }
                if (!((pFunctions) === null)) {
                    for(var j = 0; j < pFunctions.length; j++) {
                        if (this._pExtSystemFunctionList.indexOf(pFunctions[j]) === -1) {
                            this._pExtSystemFunctionList.push(pFunctions[j]);
                        }
                    }
                }
            };
            return ExtSystemDataContainer;
        })();
        fx.ExtSystemDataContainer = ExtSystemDataContainer;        
        var AttributeBlendContainer = (function (_super) {
            __extends(AttributeBlendContainer, _super);
            function AttributeBlendContainer() {
                        _super.call(this);
                this._pSlotBySemanticIndex = null;
                this._pTypeInfoBySemanticIndex = null;
                this._pFlowBySlots = null;
                this._pSlotByFlows = null;
                this._pIsPointerBySlot = null;
                this._pVBByBufferSlots = null;
                this._pBufferSlotBySlots = null;
                this._pHashPartList = null;
                this._pOffsetVarsBySemanticMap = null;
                this._pOffsetDefaultMap = null;
                this._nSemantics = 0;
                this._nSlots = 0;
                this._nBufferSlots = 0;
                /**@protected*/ this._sHash = "";
                this._pSlotBySemanticIndex = null;
                //this._pFlowBySemanticIndex = null;
                var iMaxSlots = 16;
                var iMaxVertexSamplers = 4;
                iMaxSlots = akra.webgl.maxVertexAttributes;
                iMaxVertexSamplers = akra.webgl.maxVertexTextureImageUnits;
                this._pFlowBySlots = new Array(iMaxSlots);
                this._pSlotByFlows = new Array(iMaxSlots);
                this._pIsPointerBySlot = new Array(iMaxSlots);
                this._pVBByBufferSlots = new Array(iMaxVertexSamplers);
                this._pBufferSlotBySlots = new Array(iMaxSlots);
                this._pHashPartList = null;
            }
            Object.defineProperty(AttributeBlendContainer.prototype, "semantics", {
                get: /** @inline */function () {
                    return ((this)._pVarKeys);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AttributeBlendContainer.prototype, "totalSlots", {
                get: /** @inline */function () {
                    return this._nSlots;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AttributeBlendContainer.prototype, "totalBufferSlots", {
                get: /** @inline */function () {
                    return this._nBufferSlots;
                },
                enumerable: true,
                configurable: true
            });
            AttributeBlendContainer.prototype.getOffsetVarsBySemantic = /** @inline */function (sName) {
                return this._pOffsetVarsBySemanticMap[sName];
            };
            AttributeBlendContainer.prototype.getOffsetDefault = /** @inline */function (sName) {
                return this._pOffsetDefaultMap[sName];
            };
            AttributeBlendContainer.prototype.getSlotBySemantic = /** @inline */function (sSemantic) {
                return this._pSlotBySemanticIndex[((this)._pKeyToIndexMap[(sSemantic)])];
            };
            AttributeBlendContainer.prototype.getBufferSlotBySemantic = /** @inline */function (sSemantic) {
                return this._pBufferSlotBySlots[((this)._pSlotBySemanticIndex[(((this))._pKeyToIndexMap[((sSemantic))])])];
            };
            AttributeBlendContainer.prototype.getAttributeList = /** @inline */function (sSemantic) {
                return ((this)._pVarListMap[(sSemantic)]);
            };
            AttributeBlendContainer.prototype.getTypeForShaderAttribute = /** @inline */function (sSemantic) {
                return this._pIsPointerBySlot[((this)._pSlotBySemanticIndex[(((this))._pKeyToIndexMap[((sSemantic))])])] ? fx.Effect.getSystemType("ptr") : ((((this))._pVarBlendTypeMap[((sSemantic))])).getBaseType();
            };
            AttributeBlendContainer.prototype.getType = /** @inline */function (sSemantic) {
                return ((this)._pVarBlendTypeMap[(sSemantic)]);
            };
            AttributeBlendContainer.prototype.addAttribute = /** @inline */function (pVariable) {
                return this.addVariable(pVariable, akra.EAFXBlendMode.k_Attribute);
            };
            AttributeBlendContainer.prototype.hasAttrWithSemantic = /** @inline */function (sSemantic) {
                return this.hasVariableWithName(sSemantic);
            };
            AttributeBlendContainer.prototype.getAttribute = /** @inline */function (sSemantic) {
                return ((this).hasVariableWithName((sSemantic)) ? (this)._pVarListMap[(sSemantic)][0] : null);
            };
            AttributeBlendContainer.prototype.hasTexcoord = /** @inline */function (iSlot) {
                return ((this).hasVariableWithName((/*checked (origin: akra)>>*/akra.DeclUsages.TEXCOORD + iSlot.toString())));
            };
            AttributeBlendContainer.prototype.getTexcoordVar = /** @inline */function (iSlot) {
                return ((this).hasVariableWithName((/*checked (origin: akra)>>*/akra.DeclUsages.TEXCOORD + iSlot.toString())) ? (this)._pVarListMap[(/*checked (origin: akra)>>*/akra.DeclUsages.TEXCOORD + iSlot.toString())][0] : null);
            };
            AttributeBlendContainer.prototype.finalize = function () {
                this._nSemantics = ((((this))._pVarKeys)).length;
                this._pSlotBySemanticIndex = new Array(this._nSemantics);
                this._pTypeInfoBySemanticIndex = new Array(this._nSemantics);
                for(var i = 0; i < this._nSemantics; i++) {
                    this._pSlotBySemanticIndex[i] = -1;
                    this._pTypeInfoBySemanticIndex[i] = this.createTypeInfo(((((this))._pVarKeys))[i]);
                }
                for(var i = 0; i < this._pFlowBySlots.length; i++) {
                    this._pFlowBySlots[i] = -1;
                    this._pSlotByFlows[i] = -1;
                    this._pIsPointerBySlot[i] = false;
                    this._pBufferSlotBySlots[i] = -1;
                }
                for(var i = 0; i < this._pVBByBufferSlots.length; i++) {
                    this._pVBByBufferSlots[i] = 0;
                }
            };
            AttributeBlendContainer.prototype.clear = function () {
                this._nSlots = 0;
                this._nBufferSlots = 0;
                this._sHash = "";
            };
            AttributeBlendContainer.prototype.generateOffsetMap = function () {
                this._pOffsetVarsBySemanticMap = {};
                this._pOffsetDefaultMap = {};
                var pSemantics = ((((this))._pVarKeys));
                for(var i = 0; i < pSemantics.length; i++) {
                    var sSemantic = pSemantics[i];
                    var pAttr = ((((this)).hasVariableWithName(((sSemantic))) ? ((this))._pVarListMap[((sSemantic))][0] : null));
                    if (pAttr.isPointer()) {
                        this._pOffsetVarsBySemanticMap[sSemantic] = [];
                        if (pAttr.getType().isComplex()) {
                            var pAttrSubDecls = pAttr.getSubVarDecls();
                            for(var j = 0; j < pAttrSubDecls.length; j++) {
                                var pSubDecl = pAttrSubDecls[j];
                                if (pSubDecl.getName() === "offset") {
                                    var sOffsetName = pSubDecl.getRealName();
                                    this._pOffsetVarsBySemanticMap[sSemantic].push(pSubDecl);
                                    this._pOffsetDefaultMap[sOffsetName] = (pSubDecl.getParent()).getType().getPadding();
                                }
                            }
                        } else {
                            var pOffsetVar = pAttr.getType()._getAttrOffset();
                            var sOffsetName = pOffsetVar.getRealName();
                            this._pOffsetVarsBySemanticMap[sSemantic].push(pOffsetVar);
                            this._pOffsetDefaultMap[sOffsetName] = 0;
                        }
                    } else {
                        this._pOffsetVarsBySemanticMap[sSemantic] = null;
                    }
                }
            };
            AttributeBlendContainer.prototype.initFromBufferMap = function (pMap) {
                this.clear();
                if (((pMap) === null)) {
 {
                        akra.logger.setSourceLocation("fx/BlendContainers.ts", 455);
                        akra.logger.criticalError("Yoy don`t set any buffermap for render");
                    }
                    ;
                    return;
                }
                var pSemanticList = ((((this))._pVarKeys));
                var iHash = 0;
                for(var i = 0; i < pSemanticList.length; i++) {
                    var sSemantic = pSemanticList[i];
                    var pTypeInfo = this._pTypeInfoBySemanticIndex[i];
                    var pFindFlow = null;
                    if (pTypeInfo.isComplex) {
                        // pFindFlow = pMap.findFlow(sSemantic) || pMap.getFlow(sSemantic, true);
                        pFindFlow = pMap.findFlow(sSemantic) || pMap.getFlowBySemantic(sSemantic);
                    } else {
                        // pFindFlow = pMap.getFlow(sSemantic, true);
                        pFindFlow = pMap.getFlowBySemantic(sSemantic);
                    }
                    if (!((pFindFlow) === null)) {
                        var iBufferSlot = -1;
                        var iFlow = pFindFlow.flow;
                        var iSlot = this._pSlotByFlows[iFlow];
                        if (iSlot >= 0 && iSlot < this._nSlots && this._pFlowBySlots[iSlot] === iFlow) {
                            this._pSlotBySemanticIndex[i] = iSlot;
                            iHash += ((iSlot + 1) << 5 + (this._pBufferSlotBySlots[iSlot] + 1)) << iSlot;
                            // continue;
                                                    } else {
                            iSlot = this._nSlots;
                            if (pFindFlow.type === akra.EDataFlowTypes.MAPPABLE) {
                                if (!pTypeInfo.isPointer) {
 {
                                        akra.logger.setSourceLocation("fx/BlendContainers.ts", 492);
                                        akra.logger.criticalError("You try to put pointer data into non-pointer attribute with semantic '" + sSemantic + "'");
                                    }
                                    ;
                                }
                                // iSlot = this._pSlotByFlows[iFlow];
                                // if(iSlot >= 0 && this._pFlowBySlots[iSlot] === iFlow){
                                // 	this._pSlotBySemanticIndex[i] = iSlot;
                                // 	iHash += ((iSlot + 1) << 5 + (this._pBufferSlotBySlots[iSlot] + 1)) << iSlot;
                                // 	continue;
                                // }
                                // iSlot = this._nSlots;
                                var iBuffer = (pFindFlow.data.buffer).getGuid();
                                for(var j = 0; j < this._nBufferSlots; j++) {
                                    if (this._pVBByBufferSlots[j] === iBuffer) {
                                        iBufferSlot = j;
                                        break;
                                    }
                                }
                                if (iBufferSlot === -1) {
                                    iBufferSlot = this._nBufferSlots;
                                    this._pVBByBufferSlots[iBufferSlot] = iBuffer;
                                    this._nBufferSlots++;
                                }
                                this._pIsPointerBySlot[iSlot] = true;
                            } else {
                                if (pTypeInfo.isStrictPointer) {
 {
                                        akra.logger.setSourceLocation("fx/BlendContainers.ts", 523);
                                        akra.logger.criticalError("You try to put non-pointer data into pointer attribute with semantic '" + sSemantic + "'");
                                    }
                                    ;
                                }
                                this._pIsPointerBySlot[iSlot] = false;
                            }
                            //new slot
                            this._pSlotBySemanticIndex[i] = iSlot;
                            this._pFlowBySlots[iSlot] = iFlow;
                            this._pSlotByFlows[iFlow] = iSlot;
                            this._pBufferSlotBySlots[iSlot] = iBufferSlot;
                            iHash += ((iSlot + 1) << 5 + (iBufferSlot + 1)) << iSlot;
                            this._nSlots++;
                        }
                    } else {
                        this._pSlotBySemanticIndex[i] = -1;
                    }
                }
                this._sHash = iHash.toString();
            };
            AttributeBlendContainer.prototype.getHash = /** @inline */function () {
                return this._sHash;
            };
            AttributeBlendContainer.prototype.createTypeInfo = function (sSemantic) {
                return {
                    isComplex: ((((this))._pVarBlendTypeMap[((sSemantic))])).isComplex(),
                    isPointer: ((((this))._pVarBlendTypeMap[((sSemantic))])).isPointer(),
                    isStrictPointer: ((((this))._pVarBlendTypeMap[((sSemantic))])).isStrictPointer()
                };
            };
            return AttributeBlendContainer;
        })(VariableBlendContainer);
        fx.AttributeBlendContainer = AttributeBlendContainer;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        //TODO: CHECK SAMPLER TYPE
        var SamplerBlender = (function () {
            function SamplerBlender() {
                /**@protected*/ this._pSlotList = null;
                /**@protected*/ this._nActiveSlots = 0;
                /**@protected*/ this._pIdToSlotMap = null;
                /**@protected*/ this._pIdList = null;
                this._pSlotList = new Array(32);
                for(var i = 0; i < this._pSlotList.length; i++) {
                    this._pSlotList[i] = new akra.util.ObjectArray();
                }
                this._nActiveSlots = 1;
                this._pIdToSlotMap = {
                    0: 0
                };
                this._pIdList = new Array(32);
            }
            Object.defineProperty(SamplerBlender.prototype, "slots", {
                get: /** @inline */function () {
                    return this._pSlotList;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SamplerBlender.prototype, "totalActiveSlots", {
                get: /** @inline */function () {
                    return this._nActiveSlots;
                },
                enumerable: true,
                configurable: true
            });
            SamplerBlender.prototype.getSamplersBySlot = /** @inline */function (iSlot) {
                return ((this)._pSlotList)[iSlot];
            };
            SamplerBlender.prototype.clear = function () {
                for(var i = 0; i < this._nActiveSlots; i++) {
                    this._pSlotList[i].clear(false);
                }
                for(var i = 0; i < this._nActiveSlots - 1; i++) {
                    this._pIdToSlotMap[this._pIdList[i]] = -1;
                }
                this._nActiveSlots = 1;
            };
            SamplerBlender.prototype.clearSamplerNames = function () {
                for(var i = 0; i < this._nActiveSlots; i++) {
                    for(var j = 0; j < ((this._pSlotList[i])._iLength); j++) {
                        var pSampler = ((this._pSlotList[i])._pData[(j)]);
                        pSampler.setRealName(pSampler.getSemantic() || pSampler.getName());
                        pSampler.defineByZero(false);
                    }
                }
            };
            SamplerBlender.prototype.addTextureSlot = function (id) {
                if (this._pIdToSlotMap[id] > 0) {
                    return;
                }
                // if(this._pSlotList.length === this._nActiveSlots){
                // 	this._pSlotList.push(new util.ObjectArray());
                // }
                this._pIdToSlotMap[id] = this._nActiveSlots;
                this._pIdList[this._nActiveSlots - 1] = id;
                this._nActiveSlots++;
            };
            SamplerBlender.prototype.addObjectToSlotById = /** @inline */function (pObject, id) {
                /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this._pSlotList[this._pIdToSlotMap[id]].push(pObject);
            };
            SamplerBlender.prototype.addObjectToSlotIdAuto = function (pObject, id) {
                this.addTextureSlot(id);
                (/*not inlined, because supportes only single statement functions(cur. st. count: 4)*/(this)._pSlotList[(this)._pIdToSlotMap[(id)]].push((pObject)));
            };
            SamplerBlender.prototype.getHash = function () {
                var sHash = "";
                for(var i = 0; i < this._nActiveSlots; i++) {
                    var pBlend = this._pSlotList[i];
                    if ((pBlend._iLength) > 0) {
                        if (i === 0) {
                            sHash += "Z";
                        }
                        for(var j = 0; j < (pBlend._iLength); j++) {
                            sHash += (pBlend._pData[(j)]).getGuid() + ".";
                        }
                        sHash += ".";
                    }
                }
                return sHash;
            };
            return SamplerBlender;
        })();
        fx.SamplerBlender = SamplerBlender;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    ;
    ;
    (function (EViewportTypes) {
        EViewportTypes._map = [];
        EViewportTypes.DEFAULT = -1;
        EViewportTypes.DSVIEWPORT = 1;
        EViewportTypes.SHADOWVIEWPORT = 2;
        EViewportTypes._map[3] = "COLORVIEWPORT";
        EViewportTypes.COLORVIEWPORT = 3;
    })(akra.EViewportTypes || (akra.EViewportTypes = {}));
    var EViewportTypes = akra.EViewportTypes;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (ERenderDataTypes) {
        ERenderDataTypes._map = [];
        ERenderDataTypes._map[0] = "UNKNOWN";
        ERenderDataTypes.UNKNOWN = 0;
        ERenderDataTypes._map[1] = "MESH_SUBSET";
        ERenderDataTypes.MESH_SUBSET = 1;
        ERenderDataTypes._map[2] = "SCREEN";
        ERenderDataTypes.SCREEN = 2;
    })(akra.ERenderDataTypes || (akra.ERenderDataTypes = {}));
    var ERenderDataTypes = akra.ERenderDataTypes;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    (function (EVertexBufferTypes) {
        EVertexBufferTypes._map = [];
        EVertexBufferTypes._map[0] = "UNKNOWN";
        EVertexBufferTypes.UNKNOWN = 0;
        EVertexBufferTypes._map[1] = "VBO";
        EVertexBufferTypes.VBO = 1;
        EVertexBufferTypes._map[2] = "TBO";
        EVertexBufferTypes.TBO = 2;
    })(akra.EVertexBufferTypes || (akra.EVertexBufferTypes = {}));
    var EVertexBufferTypes = akra.EVertexBufferTypes;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (ECanvasTypes) {
        ECanvasTypes._map = [];
        ECanvasTypes.TYPE_UNKNOWN = -1;
        ECanvasTypes.TYPE_2D = 1;
        ECanvasTypes._map[2] = "TYPE_3D";
        ECanvasTypes.TYPE_3D = 2;
    })(akra.ECanvasTypes || (akra.ECanvasTypes = {}));
    var ECanvasTypes = akra.ECanvasTypes;
    ;
})(akra || (akra = {}));
;
;
var akra;
(function (akra) {
    (function (geometry) {
        var Circle = (function () {
            function Circle(fCenterX, fCenterY, fRadius) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        var pCircle = arguments[0];
                        this.center = new akra.Vec2(pCircle.center);
                        this.radius = pCircle.radius;
                        break;
                    case 2:
                        var v2fCenter = arguments[0];
                        var fRadius = arguments[1];
                        this.center = new akra.Vec2(v2fCenter);
                        this.radius = fRadius;
                        break;
                    case 3:
                        this.center = new akra.Vec2(arguments[0], arguments[1]);
                        this.radius = arguments[2];
                        break;
                    default:
                        this.center = new akra.Vec2();
                        this.radius = 0.;
                        break;
                }
            }
            Circle.prototype.set = function (fCenterX, fCenterY, fRadius) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        var pCircle = arguments[0];
                        this.center.set(pCircle.center);
                        this.radius = pCircle.radius;
                        break;
                    case 2:
                        var v2fCenter = arguments[0];
                        var fRadius = arguments[1];
                        this.center.set(v2fCenter);
                        this.radius = fRadius;
                        break;
                    case 3:
                        this.center.set(arguments[0], arguments[1]);
                        this.radius = arguments[2];
                        break;
                    default:
                        this.center.set(0.);
                        this.radius = 0.;
                }
                return this;
            };
            Circle.prototype.clear = /** @inline */function () {
                this.center.clear();
                this.radius = 0.;
                return this;
            };
            Circle.prototype.isEqual = /** @inline */function (pCircle) {
                return this.center.isEqual(pCircle.center) && (this.radius == pCircle.radius);
            };
            Circle.prototype.isClear = /** @inline */function () {
                return this.center.isClear() && (this.radius === 0.);
            };
            Circle.prototype.isValid = /** @inline */function () {
                return (this.radius >= 0.);
            };
            Circle.prototype.offset = /** @inline */function (v2fOffset) {
                this.center.add(v2fOffset);
                return this;
            };
            Circle.prototype.expand = /** @inline */function (fInc) {
                this.radius += fInc;
                return this;
            };
            Circle.prototype.normalize = /** @inline */function () {
                this.radius = akra.math.abs(this.radius);
                return this;
            };
            return Circle;
        })();
        geometry.Circle = Circle;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
;
var akra;
(function (akra) {
    (function (geometry) {
        var Rect2d = (function () {
            function Rect2d(fX0, fX1, fY0, fY1) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 2:
                        this.set(arguments[0], arguments[1]);
                        break;
                    case 4:
                        this.set(arguments[0], arguments[1], arguments[2], arguments[3]);
                        break;
                    default:
                        this.x0 = this.x1 = this.y0 = this.y1 = 0.;
                        break;
                }
            }
            Object.defineProperty(Rect2d.prototype, "left", {
                get: /** @inline */function () {
                    return this.x0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rect2d.prototype, "top", {
                get: /** @inline */function () {
                    return this.y0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rect2d.prototype, "width", {
                get: /** @inline */function () {
                    return this.x1 - this.x0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rect2d.prototype, "height", {
                get: /** @inline */function () {
                    return this.y1 - this.y0;
                },
                enumerable: true,
                configurable: true
            });
            Rect2d.prototype.set = function (fX0, fX1, fY0, fY1) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        if (arguments[0] instanceof Rect2d) {
                            var pRect = arguments[0];
                            this.x0 = pRect.x0;
                            this.x1 = pRect.x1;
                            this.y0 = pRect.y0;
                            this.y1 = pRect.y1;
                        } else {
                            var v2fSizes = arguments[0];
                            this.x1 = v2fSizes.x * 0.5;
                            this.x0 = -this.x1;
                            this.y1 = v2fSizes.y * 0.5;
                            this.y0 = -this.y1;
                        }
                        break;
                    case 2:
                        if ((typeof (arguments[0]) === "number")) {
                            var fSizeX = arguments[0];
                            var fSizeY = arguments[1];
                            this.x1 = fSizeX * 0.5;
                            this.x0 = -this.x1;
                            this.y1 = fSizeY * 0.5;
                            this.y0 = -this.y1;
                        } else {
                            this.x0 = arguments[0].x;
                            this.y0 = arguments[0].y;
                            this.x1 = arguments[1].x;
                            this.y1 = arguments[1].y;
                        }
                        break;
                    case 4:
                        this.x0 = arguments[0];
                        this.x1 = arguments[1];
                        this.y0 = arguments[2];
                        this.y1 = arguments[3];
                        break;
                    default:
                        this.x0 = this.x1 = this.y0 = this.y1 = 0.;
                        break;
                }
                return this;
            };
            Rect2d.prototype.setFloor = function (pRect) {
                this.x0 = akra.math.floor(pRect.x0);
                this.x1 = akra.math.floor(pRect.x1);
                this.y0 = akra.math.floor(pRect.y0);
                this.y1 = akra.math.floor(pRect.y1);
                return this;
            };
            Rect2d.prototype.setCeil = function (pRect) {
                this.x0 = akra.math.ceil(pRect.x0);
                this.x1 = akra.math.ceil(pRect.x1);
                this.y0 = akra.math.ceil(pRect.y0);
                this.y1 = akra.math.ceil(pRect.y1);
                return this;
            };
            Rect2d.prototype.clear = /** @inline */function () {
                this.x0 = this.x1 = this.y0 = this.y1 = 0.;
                return this;
            };
            Rect2d.prototype.addSelf = function (v2fVec) {
                if ((typeof (arguments[0]) === "number")) {
                    var fValue = arguments[0];
                    this.x0 += fValue;
                    this.x1 += fValue;
                    this.y0 += fValue;
                    this.y1 += fValue;
                } else {
                    var v2fVec = arguments[0];
                    this.x0 += v2fVec.x;
                    this.x1 += v2fVec.x;
                    this.y0 += v2fVec.y;
                    this.y1 += v2fVec.y;
                }
                return this;
            };
            Rect2d.prototype.subSelf = function (v2fVec) {
                if ((typeof (arguments[0]) === "number")) {
                    var fValue = arguments[0];
                    this.x0 -= fValue;
                    this.x1 -= fValue;
                    this.y0 -= fValue;
                    this.y1 -= fValue;
                } else {
                    var v2fVec = arguments[0];
                    this.x0 -= v2fVec.x;
                    this.x1 -= v2fVec.x;
                    this.y0 -= v2fVec.y;
                    this.y1 -= v2fVec.y;
                }
                return this;
            };
            Rect2d.prototype.multSelf = function (v2fVec) {
                if ((typeof (arguments[0]) === "number")) {
                    var fValue = arguments[0];
                    this.x0 *= fValue;
                    this.x1 *= fValue;
                    this.y0 *= fValue;
                    this.y1 *= fValue;
                } else {
                    var v2fVec = arguments[0];
                    this.x0 *= v2fVec.x;
                    this.x1 *= v2fVec.x;
                    this.y0 *= v2fVec.y;
                    this.y1 *= v2fVec.y;
                }
                return this;
            };
            Rect2d.prototype.divSelf = function (v2fVec) {
                if ((typeof (arguments[0]) === "number")) {
                    var fValue = arguments[0];
 {
                        akra.logger.setSourceLocation("geometry/Rect2d.ts", 206);
                        akra.logger.assert(fValue != 0., "divide by zero error");
                    }
                    ;
                    var fInvValue = 1. / fValue;
                    this.x0 *= fInvValue;
                    this.x1 *= fInvValue;
                    this.y0 *= fInvValue;
                    this.y1 *= fInvValue;
                } else {
                    var v2fVec = arguments[0];
 {
                        akra.logger.setSourceLocation("geometry/Rect2d.ts", 218);
                        akra.logger.assert(v2fVec.x != 0., "divide by zero error");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("geometry/Rect2d.ts", 219);
                        akra.logger.assert(v2fVec.y != 0., "divide by zero error");
                    }
                    ;
                    var fInvX = 1. / v2fVec.x;
                    var fInvY = 1. / v2fVec.y;
                    this.x0 *= fInvX;
                    this.x1 *= fInvX;
                    this.y0 *= fInvY;
                    this.y1 *= fInvY;
                }
                return this;
            };
            Rect2d.prototype.offset = function (fOffsetX, fOffsetY) {
                if (arguments.length === 1) {
                    var v2fOffset = arguments[0];
                    this.x0 += v2fOffset.x;
                    this.x1 += v2fOffset.x;
                    this.y0 += v2fOffset.y;
                    this.y1 += v2fOffset.y;
                } else {
                    this.x0 += arguments[0];
                    this.x1 += arguments[0];
                    this.y0 += arguments[1];
                    this.y1 += arguments[1];
                }
                return this;
            };
            Rect2d.prototype.expand = function (fValueX, fValueY) {
                if (arguments.length == 1) {
                    if ((typeof (arguments[0]) === "number")) {
                        var fValue = arguments[0];
                        this.x0 -= fValue;
                        this.x1 += fValue;
                        this.y0 -= fValue;
                        this.y1 += fValue;
                    } else {
                        var v2fValue = arguments[0];
                        this.x0 -= v2fValue.x;
                        this.x1 += v2fValue.x;
                        this.y0 -= v2fValue.y;
                        this.y1 += v2fValue.y;
                    }
                } else {
                    //arguments.length == 2
                    this.x0 -= arguments[0];
                    this.x1 += arguments[0];
                    this.y0 -= arguments[1];
                    this.y1 += arguments[1];
                }
                return this;
            };
            Rect2d.prototype.expandX = function (fValue) {
                this.x0 -= fValue;
                this.x1 += fValue;
                return this;
            };
            Rect2d.prototype.expandY = function (fValue) {
                this.y0 -= fValue;
                this.y1 += fValue;
                return this;
            };
            Rect2d.prototype.resize = function (fSizeX, fSizeY) {
                var fSizeX, fSizeY;
                if (arguments.length == 1) {
                    var v2fSize = arguments[0];
                    fSizeX = v2fSize.x;
                    fSizeY = v2fSize.y;
                } else {
                    fSizeX = arguments[0];
                    fSizeY = arguments[1];
                }
                this.x1 = (this.x0 + this.x1 + fSizeX) * 0.5;
                this.x0 = this.x1 - fSizeX;
                this.y1 = (this.y0 + this.y1 + fSizeY) * 0.5;
                this.y0 = this.y1 - fSizeY;
                return this;
            };
            Rect2d.prototype.resizeX = /** @inline */function (fSize) {
                this.x1 = (this.x0 + this.x1 + fSize) * 0.5;
                this.x0 = this.x1 - fSize;
                return this;
            };
            Rect2d.prototype.resizeY = /** @inline */function (fSize) {
                this.y1 = (this.y0 + this.y1 + fSize) * 0.5;
                this.y0 = this.y1 - fSize;
                return this;
            };
            Rect2d.prototype.resizeMax = function (fSpanX, fSpanY) {
                if (arguments.length == 1) {
                    var v2fSpan = arguments[0];
                    this.x1 = this.x0 + v2fSpan.x;
                    this.y1 = this.y0 + v2fSpan.y;
                } else {
                    this.x1 = this.x0 + arguments[0];
                    this.y1 = this.y0 + arguments[1];
                }
                return this;
            };
            Rect2d.prototype.resizeMaxX = /** @inline */function (fSpan) {
                this.x1 = this.x0 + fSpan;
                return this;
            };
            Rect2d.prototype.resizeMaxY = /** @inline */function (fSpan) {
                this.y1 = this.y0 + fSpan;
                return this;
            };
            Rect2d.prototype.resizeMin = function (fSpanX, fSpanY) {
                if (arguments.length == 1) {
                    var v2fSpan = arguments[0];
                    this.x0 = this.x1 - v2fSpan.x;
                    this.y0 = this.y1 - v2fSpan.y;
                } else {
                    this.x0 = this.x1 - arguments[0];
                    this.y0 = this.y1 - arguments[1];
                }
                return this;
            };
            Rect2d.prototype.resizeMinX = /** @inline */function (fSpan) {
                this.x0 = this.x1 - fSpan;
                return this;
            };
            Rect2d.prototype.resizeMinY = /** @inline */function (fSpan) {
                this.y0 = this.y1 - fSpan;
                return this;
            };
            Rect2d.prototype.unionPoint = function (fX, fY) {
                if (arguments.length == 1) {
                    var v2fPoint = arguments[0];
                    this.x0 = akra.math.min(this.x0, v2fPoint.x);
                    this.x1 = akra.math.max(this.x1, v2fPoint.x);
                    this.y0 = akra.math.min(this.y0, v2fPoint.y);
                    this.y1 = akra.math.max(this.y1, v2fPoint.y);
                } else {
                    var fX = arguments[0];
                    var fY = arguments[1];
                    this.x0 = akra.math.min(this.x0, fX);
                    this.x1 = akra.math.max(this.x1, fX);
                    this.y0 = akra.math.min(this.y0, fY);
                    this.y1 = akra.math.max(this.y1, fY);
                }
                return this;
            };
            Rect2d.prototype.unionRect = function (pRect) {
                this.normalize();
                pRect.normalize();
                this.x0 = akra.math.min(this.x0, pRect.x0);
                this.x1 = akra.math.max(this.x1, pRect.x1);
                this.y0 = akra.math.min(this.y0, pRect.y0);
                this.y1 = akra.math.max(this.y1, pRect.y1);
                return this;
            };
            Rect2d.prototype.negate = function (pDestination) {
                if (!((pDestination) !== undefined)) {
                    pDestination = this;
                }
                return pDestination.set(-this.x1, -this.x0, -this.y1, -this.y0);
            };
            Rect2d.prototype.normalize = function () {
                var fTmp;
                if (this.x0 > this.x1) {
                    fTmp = this.x0;
                    this.x0 = this.x1;
                    this.x1 = fTmp;
                }
                if (this.y0 > this.y1) {
                    fTmp = this.y0;
                    this.y0 = this.y1;
                    this.y1 = fTmp;
                }
                return this;
            };
            Rect2d.prototype.isEqual = /** @inline */function (pRect) {
                return this.x0 == pRect.x0 && this.x1 == pRect.x1 && this.y0 == pRect.y0 && this.y1 == pRect.y1;
            };
            Rect2d.prototype.isClear = /** @inline */function () {
                return this.x0 == 0. && this.x1 == 0. && this.y0 == 0. && this.y1 == 0.;
            };
            Rect2d.prototype.isValid = /** @inline */function () {
                return this.x0 <= this.x1 && this.y0 <= this.y1;
            };
            Rect2d.prototype.isPointInRect = /** @inline */function (v2fPoint) {
                var x = v2fPoint.x;
                var y = v2fPoint.y;
                return (this.x0 <= x && x <= this.x1) && (this.y0 <= y && y <= this.y1);
            };
            Rect2d.prototype.midPoint = function (v2fDestination) {
                if (!((v2fDestination) !== undefined)) {
                    v2fDestination = new akra.Vec2();
                }
                v2fDestination.x = (this.x0 + this.x1) * 0.5;
                v2fDestination.y = (this.y0 + this.y1) * 0.5;
                return v2fDestination;
            };
            Rect2d.prototype.midX = /** @inline */function () {
                return (this.x0 + this.x1) * 0.5;
            };
            Rect2d.prototype.midY = /** @inline */function () {
                return (this.y0 + this.y1) * 0.5;
            };
            Rect2d.prototype.size = function (v2fDestination) {
                if (!((v2fDestination) !== undefined)) {
                    v2fDestination = new akra.Vec2();
                }
                v2fDestination.x = this.x1 - this.x0;
                v2fDestination.y = this.y1 - this.y0;
                return v2fDestination;
            };
            Rect2d.prototype.sizeX = /** @inline */function () {
                return this.x1 - this.x0;
            };
            Rect2d.prototype.sizeY = /** @inline */function () {
                return this.y1 - this.y0;
            };
            Rect2d.prototype.minPoint = function (v2fDestination) {
                if (!((v2fDestination) !== undefined)) {
                    v2fDestination = new akra.Vec2();
                }
                v2fDestination.x = this.x0;
                v2fDestination.y = this.y0;
                return v2fDestination;
            };
            Rect2d.prototype.maxPoint = function (v2fDestination) {
                if (!((v2fDestination) !== undefined)) {
                    v2fDestination = new akra.Vec2();
                }
                v2fDestination.x = this.x1;
                v2fDestination.y = this.y1;
                return v2fDestination;
            };
            Rect2d.prototype.area = /** @inline */function () {
                return (this.x1 - this.x0) * (this.y1 - this.y0);
            };
            Rect2d.prototype.corner = /**
            * counter-clockwise
            * x0,y0 -> x1,y0 -> x1,y1 -> x0,y1;
            */
            function (iIndex, v2fDestination) {
                if (!((v2fDestination) !== undefined)) {
                    v2fDestination = new akra.Vec2();
                }
 {
                    akra.logger.setSourceLocation("geometry/Rect2d.ts", 557);
                    akra.logger.assert(0 <= iIndex && iIndex < 4, "invalid index");
                }
                ;
                switch(iIndex) {
                    case 0:
                        v2fDestination.set(this.x0, this.y0);
                        break;
                    case 1:
                        v2fDestination.set(this.x1, this.y0);
                        break;
                    case 2:
                        v2fDestination.set(this.x1, this.y1);
                        break;
                    case 3:
                        v2fDestination.set(this.x0, this.y1);
                        break;
                }
                ;
                return v2fDestination;
            };
            Rect2d.prototype.createBoundingCircle = function (pCircle) {
                if (!((pCircle) !== undefined)) {
                    pCircle = new geometry.Circle();
                }
                var fX0 = this.x0, fX1 = this.x1;
                var fY0 = this.y0, fY1 = this.y1;
                var fHalfSizeX = (fX1 - fX0) * 0.5;
                var fHalfSizeY = (fY1 - fY0) * 0.5;
                pCircle.set((fX0 + fX1) * 0.5, (fY0 + fY1) * 0.5, akra.math.sqrt(fHalfSizeX * fHalfSizeX + fHalfSizeY * fHalfSizeY));
                return pCircle;
            };
            Rect2d.prototype.toString = function () {
                return "(" + this.x0 + ", " + this.y0 + ") --> (" + this.x1 + ", " + this.y1 + ")";
            };
            return Rect2d;
        })();
        geometry.Rect2d = Rect2d;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var ObjectArray = (function () {
            // set length(n: uint) {
            // 	if (this._bLock) {
            // 		return;
            // 	}
            // 	this.extend(n);
            // 	this._iLength = n;
            // }
            function ObjectArray(pElements) {
                /**@protected*/ this._pData = [];
                /**@protected*/ this._bLock = false;
                /**@protected*/ this._iLength = 0;
                if (arguments.length) {
                    this.fromArray(pElements);
                }
            }
            Object.defineProperty(ObjectArray.prototype, "length", {
                get: /** @inline */function () {
                    return this._iLength;
                },
                enumerable: true,
                configurable: true
            });
            ObjectArray.prototype.lock = /** @inline */function () {
                this._bLock = true;
            };
            ObjectArray.prototype.unlock = /** @inline */function () {
                this._bLock = false;
            };
            ObjectArray.prototype.isLocked = /** @inline */function () {
                return this._bLock;
            };
            ObjectArray.prototype.clear = function (bRemoveLinks) {
                if (typeof bRemoveLinks === "undefined") { bRemoveLinks = false; }
 {
                    util.logger.setSourceLocation("util/ObjectArray.ts", 47);
                    util.logger.assert(!this._bLock, "cannot clear. array is locked.");
                }
                ;
                this._iLength = 0;
                if (bRemoveLinks) {
                    for(var i = 0; i < this._pData.length; ++i) {
                        this._pData[i] = null;
                    }
                }
                return this;
            };
            ObjectArray.prototype.release = function () {
                this.clear(true);
                this._pData.clear();
                return this;
            };
            ObjectArray.prototype.value = /** @inline */function (n) {
                return this._pData[n];
            };
            ObjectArray.prototype.extend = function (n) {
                if (this._pData.length < n) {
                    //LOG("extending object array to > " + n);
                    for(var i = this._pData.length; i < n; ++i) {
                        this._pData[i] = null;
                    }
                }
            };
            ObjectArray.prototype.set = function (n, pData) {
 {
                    util.logger.setSourceLocation("util/ObjectArray.ts", 80);
                    util.logger.assert(!this._bLock, "cannot clear. array is locked.");
                }
                ;
                var N = n + 1;
                this.extend(N);
                if (this._iLength < N) {
                    this._iLength = N;
                }
                this._pData[n] = pData;
                return this;
            };
            ObjectArray.prototype.fromArray = function (pElements, iOffset, iSize) {
                if (typeof iOffset === "undefined") { iOffset = 0; }
                if (typeof iSize === "undefined") { iSize = 0; }
 {
                    util.logger.setSourceLocation("util/ObjectArray.ts", 96);
                    util.logger.assert(!this._bLock, "cannot clear. array is locked.");
                }
                ;
                iSize = iSize > 0 ? iSize < pElements.length ? iSize : pElements.length : pElements.length;
                this.extend(iSize);
                for(var i = iOffset, j = 0; i < iSize; ++i, ++j) {
                    this._pData[i] = pElements[j];
                }
                this._iLength = i;
                return this;
            };
            ObjectArray.prototype.push = /** @inline */function (pElement) {
 {
                    util.logger.setSourceLocation("util/ObjectArray.ts", 113);
                    util.logger.assert(!this._bLock, "cannot clear. array is locked.");
                }
                ;
                return this.set(this._iLength, pElement);
            };
            ObjectArray.prototype.pop = /** @inline */function () {
 {
                    util.logger.setSourceLocation("util/ObjectArray.ts", 119);
                    util.logger.assert(!this._bLock, "cannot clear. array is locked.");
                }
                ;
                return this._iLength > 0 ? this._pData[--this._iLength] : null;
            };
            ObjectArray.prototype.swap = /** @inline */function (i, j) {
 {
                    util.logger.setSourceLocation("util/ObjectArray.ts", 124);
                    util.logger.assert(!this._bLock, "cannot clear. array is locked.");
                }
                ;
 {
                    util.logger.setSourceLocation("util/ObjectArray.ts", 125);
                    util.logger.assert(i < this._iLength && j < this._iLength, "invalid swap index.");
                }
                ;
                this._pData.swap(i, j);
                return this;
            };
            ObjectArray.prototype.takeAt = function (iPos) {
                var pValue = ((this)._pData[(iPos)]);
                for(var i = iPos + 1, j = iPos; i < ((this)._iLength); ++i, ++j) {
                    this._pData[j] = this._pData[i];
                }
                this._iLength--;
                return pValue;
            };
            ObjectArray.prototype.indexOf = function (pObject) {
                for(var i = 0; i < this._iLength; i++) {
                    if (pObject === this._pData[i]) {
                        return i;
                    }
                }
                return -1;
            };
            return ObjectArray;
        })();
        util.ObjectArray = ObjectArray;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.ObjectArray = akra.util.ObjectArray;
})(akra || (akra = {}));
var akra;
(function (akra) {
    //#define DL_DEFAULT DEFAULT_NAME;
    (function (render) {
        var Viewport = (function () {
            function Viewport(pCamera, pTarget, csRenderMethod, fLeft, fTop, fWidth, fHeight, iZIndex) {
                if (typeof csRenderMethod === "undefined") { csRenderMethod = null; }
                if (typeof fLeft === "undefined") { fLeft = 0.; }
                if (typeof fTop === "undefined") { fTop = 0.; }
                if (typeof fWidth === "undefined") { fWidth = 1.; }
                if (typeof fHeight === "undefined") { fHeight = 1.; }
                if (typeof iZIndex === "undefined") { iZIndex = 0; }
                /**@protected*/ this._pCamera = null;
                /**@protected*/ this._pDepthRange = {
                    min: -1.,
                    max: 1.
                };
                /**@protected*/ this._pViewportState = {
                    cullingMode: akra.ECullingMode.NONE,
                    depthTest: true,
                    depthWrite: true,
                    depthFunction: akra.ECompareFunction.LESS,
                    clearColor: new akra.Color(0., 0., 0., 0.),
                    clearDepth: 1.,
                    clearBuffers: akra.EFrameBufferTypes.COLOR | akra.EFrameBufferTypes.DEPTH
                };
                // protected _cBackColor: IColor = new Color(Color.BLACK);
                // protected _fDepthClearValue: float = 1.;
                /**@protected*/ this._bClearEveryFrame = true;
                // protected _iClearBuffers: int = EFrameBufferTypes.COLOR | EFrameBufferTypes.DEPTH;
                /**@protected*/ this._bUpdated = false;
                // protected _bShowOverlays: bool = true;
                // protected _bShowSkies: bool = true;
                // protected _bShowShadows: bool = true;
                /**@protected*/ this._iVisibilityMask = 0xFFFFFFFF;
                // protected _sRQSequenceName: string;
                // protected mRQSequence: RenderQueueInvocationSequence;
                /**@protected*/ this.sMaterialSchemeName = akra.DEFAULT_MATERIAL_NAME;
                // static _eDefaultOrientationMode: EOrientationModes;
                /**@protected*/ this._isAutoUpdated = true;
                /**@protected*/ this._csDefaultRenderMethod = null;
                /**@protected*/ this._isDepthRangeUpdated = false;
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
                this._pTarget = pTarget;
                this._fRelLeft = fLeft;
                this._fRelTop = fTop;
                this._fRelWidth = fWidth;
                this._fRelHeight = fHeight;
                this._iZIndex = iZIndex;
                this._csDefaultRenderMethod = csRenderMethod;
                this._updateDimensions();
                this._setCamera(pCamera);
                ((pTarget).getEventTable().addDestination(((((pTarget)))._iGuid), ("resized"), (this), ("_updateDimensions"), (undefined)));
            }
            Object.defineProperty(Viewport.prototype, "zIndex", {
                get: /** @inline */function () {
                    return this._iZIndex;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "left", {
                get: /** @inline */function () {
                    return this._fRelLeft;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "top", {
                get: /** @inline */function () {
                    return this._fRelTop;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "width", {
                get: /** @inline */function () {
                    return this._fRelWidth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "height", {
                get: /** @inline */function () {
                    return this._fRelHeight;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "actualLeft", {
                get: /** @inline */function () {
                    return this._iActLeft;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "actualTop", {
                get: /** @inline */function () {
                    return this._iActTop;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "actualWidth", {
                get: /** @inline */function () {
                    return this._iActWidth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "actualHeight", {
                get: /** @inline */function () {
                    return this._iActHeight;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "backgroundColor", {
                get: /** @inline */function () {
                    return this._pViewportState.clearColor;
                },
                set: /** @inline */function (cColor) {
                    this._pViewportState.clearColor.set(cColor);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "depthClear", {
                get: /** @inline */function () {
                    return this._pViewportState.clearDepth;
                },
                set: /** @inline */function (fDepthClearValue) {
                    this._pViewportState.clearDepth = fDepthClearValue;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "type", {
                get: /** @inline */function () {
                    return akra.EViewportTypes.DEFAULT;
                },
                enumerable: true,
                configurable: true
            });
            Viewport.prototype.destroy = function () {
                var pRenderer = this._pTarget.getRenderer();
                if (pRenderer && pRenderer._getViewport() === this) {
                    pRenderer._setViewport(null);
                }
            };
            Viewport.prototype.clear = function (iBuffers, cColor, fDepth, iStencil) {
                if (typeof iBuffers === "undefined") { iBuffers = akra.EFrameBufferTypes.COLOR | akra.EFrameBufferTypes.DEPTH; }
                if (typeof cColor === "undefined") { cColor = akra.Color.BLACK; }
                if (typeof fDepth === "undefined") { fDepth = 1.; }
                if (typeof iStencil === "undefined") { iStencil = 0; }
                var pRenderer = this._pTarget.getRenderer();
                if (pRenderer) {
                    var pCurrentViewport = pRenderer._getViewport();
                    if (pCurrentViewport === this) {
                        pRenderer.clearFrameBuffer(iBuffers, cColor, fDepth, iStencil);
                    } else {
                        pRenderer._setViewport(this);
                        pRenderer.clearFrameBuffer(iBuffers, cColor, fDepth, iStencil);
                        pRenderer._setViewport(pCurrentViewport);
                    }
                }
            };
            Viewport.prototype.getTarget = /** @inline */function () {
                return this._pTarget;
            };
            Viewport.prototype.getCamera = /** @inline */function () {
                return this._pCamera;
            };
            Viewport.prototype.getDepth = function (x, y) {
                return 1.0;
            };
            Viewport.prototype.getDepthRange = function () {
                if (!this._isDepthRangeUpdated) {
                    this._isDepthRangeUpdated = true;
                    var pDepthRange = this._getDepthRangeImpl();
                    this._pDepthRange.min = pDepthRange.min;
                    this._pDepthRange.max = pDepthRange.max;
                }
                return this._pDepthRange;
            };
            Viewport.prototype._getDepthRangeImpl = /**@protected*/ function () {
                return {
                    min: -1,
                    max: 1
                };
            };
            Viewport.prototype.setCamera = function (pCamera) {
                if (((pCamera) != null)) {
                    if (this._pCamera._getLastViewport() == this) {
                        this._pCamera._keepLastViewport(null);
                    }
                }
                if (((pCamera) != null)) {
                    // update aspect ratio of new camera if needed.
                    if (!pCamera.isConstantAspect()) {
                        pCamera.aspect = (this._iActWidth / this._iActHeight);
                    }
                }
                this._setCamera(pCamera);
                this.viewportCameraChanged();
                return true;
            };
            Viewport.prototype._setCamera = /**@protected*/ function (pCamera) {
                this._pCamera = pCamera;
                if (((pCamera) != null)) {
                    pCamera._keepLastViewport(this);
                }
            };
            Viewport.prototype.setDimensions = function (fLeft, fTop, fWidth, fHeight) {
                var pRect;
                if ((typeof (arguments[0]) === "number")) {
                    this._fRelLeft = fLeft;
                    this._fRelTop = fTop;
                    this._fRelWidth = fWidth;
                    this._fRelHeight = fHeight;
                } else {
                    pRect = arguments[0];
                    this._fRelLeft = pRect.left;
                    this._fRelTop = pRect.top;
                    this._fRelWidth = pRect.width;
                    this._fRelHeight = pRect.height;
                }
                this._updateDimensions();
                return true;
            };
            Viewport.prototype.getActualDimensions = function () {
                return new akra.geometry.Rect2d(this._iActLeft, this._iActTop, this._iActWidth, this._iActHeight);
            };
            Viewport.prototype.setClearEveryFrame = function (isClear, iBuffers) {
                if (typeof iBuffers === "undefined") { iBuffers = akra.EFrameBufferTypes.COLOR | akra.EFrameBufferTypes.DEPTH; }
                this._bClearEveryFrame = isClear;
                this._pViewportState.clearBuffers = iBuffers;
            };
            Viewport.prototype.getClearEveryFrame = /** @inline */function () {
                return this._bClearEveryFrame;
            };
            Viewport.prototype.getClearBuffers = /** @inline */function () {
                return this._pViewportState.clearBuffers;
            };
            Viewport.prototype.setDepthParams = function (bDepthTest, bDepthWrite, eDepthFunction) {
                this._pViewportState.depthTest = bDepthTest;
                this._pViewportState.depthWrite = bDepthWrite;
                this._pViewportState.depthFunction = eDepthFunction;
            };
            Viewport.prototype.setCullingMode = function (eCullingMode) {
                this._pViewportState.cullingMode = eCullingMode;
            };
            Viewport.prototype.setAutoUpdated = /** @inline */function (bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                this._isAutoUpdated = bValue;
            };
            Viewport.prototype.isAutoUpdated = /** @inline */function () {
                return this._isAutoUpdated;
            };
            Viewport.prototype._updateDimensions = function () {
                var fHeight = this._pTarget.height;
                var fWidth = this._pTarget.width;
                this._iActLeft = (this._fRelLeft * fWidth);
                this._iActTop = (this._fRelTop * fHeight);
                this._iActWidth = (this._fRelWidth * fWidth);
                this._iActHeight = (this._fRelHeight * fHeight);
                // This will check if the cameras getAutoAspectRatio() property is set.
                // If it's true its aspect ratio is fit to the current viewport
                // If it's false the camera remains unchanged.
                // This allows cameras to be used to render to many viewports,
                // which can have their own dimensions and aspect ratios.
                if (this._pCamera) {
                    if (!this._pCamera.isConstantAspect()) {
                        this._pCamera.aspect = (this._iActWidth / this._iActHeight);
                    }
                }
                this._bUpdated = true;
                this.viewportDimensionsChanged();
            };
            Viewport.prototype.update = function () {
                if (((this._pCamera) != null)) {
                    this._pCamera._keepLastViewport(this);
                }
                this.startFrame();
                this._isDepthRangeUpdated = false;
                this._updateImpl();
                this.endFrame();
            };
            Viewport.prototype._updateImpl = function () {
                if (this._pCamera) {
                    this.renderAsNormal(this._csDefaultRenderMethod, this._pCamera);
                }
            };
            Viewport.prototype.startFrame = function () {
                if (this._bClearEveryFrame) {
                    this.clear(this._pViewportState.clearBuffers, this._pViewportState.clearColor, this._pViewportState.clearDepth);
                }
            };
            Viewport.prototype.renderObject = /** @inline */function (pRenderable, csMethod) {
                if (typeof csMethod === "undefined") { csMethod = this._csDefaultRenderMethod; }
                pRenderable.render(this, csMethod, null);
            };
            Viewport.prototype.endFrame = function () {
                ((this)._pTarget).getRenderer().executeQueue();
            };
            Viewport.prototype.renderAsNormal = /**@protected*/ function (csMethod, pCamera) {
                var pVisibleObjects = pCamera.display();
                var pRenderable;
                for(var i = 0; i < pVisibleObjects.length; ++i) {
                    pVisibleObjects.value(i).prepareForRender(this);
                }
                for(var i = 0; i < pVisibleObjects.length; ++i) {
                    var pSceneObject = pVisibleObjects.value(i);
                    for(var j = 0; j < pSceneObject.totalRenderable; j++) {
                        pRenderable = pSceneObject.getRenderable(j);
                        if (!((pRenderable) === null)) {
                            pRenderable.render(this, csMethod, pSceneObject);
                        }
                    }
                }
            };
            Viewport.prototype.projectPoint = function (v3fPoint, v3fDestination) {
                var pCamera = ((this)._pCamera);
                var v3fResult = pCamera.projectPoint(v3fPoint, v3fDestination);
                if (((v3fResult) === null)) {
                    return null;
                }
                var fX = v3fResult.x;
                var fY = v3fResult.y;
                var fZ = v3fResult.z;
                fX = fX * 0.5 + 0.5;
                fY = fY * 0.5 + 0.5;
                fZ = fZ * 0.5 + 0.5;
                //from top left angle of element
                fX = ((this)._iActLeft) + ((this)._iActWidth) * fX;
                fY = ((this)._iActTop) + ((this)._iActHeight) * (1. - fY);
                return v3fResult.set(fX, fY, fZ);
            };
            Viewport.prototype.unprojectPoint = function (a0, a1, a2) {
                var x, y;
                var v3fDestination;
                if ((typeof (arguments[0]) === "number")) {
                    x = arguments[0];
                    y = arguments[1];
                    v3fDestination = arguments[2];
                } else {
                    x = arguments[0].x;
                    y = arguments[0].y;
                    v3fDestination = arguments[1];
                }
                if (!((v3fDestination) !== undefined)) {
                    v3fDestination = new akra.Vec3();
                }
                var pCamera = ((this)._pCamera);
                var m4fProjection = pCamera.projectionMatrix;
                var m4fWorld = pCamera.worldMatrix;
                var v4fIn = akra.Vec4.stackCeil.set(), v4fOut = akra.Vec4.stackCeil.set();
                //Transformation of normalized coordinates between -1 and 1
                v4fIn.x = (x - ((this)._iActLeft)) / ((this)._iActWidth) * 2.0 - 1.0;
                //Y-axis look down for viewport, but look UP in GL
                v4fIn.y = 1.0 - (y - ((this)._iActTop)) / ((this)._iActHeight) * 2.0;
                v4fIn.z = 2.0 * this.getDepth(x, y) - 1.0;
                v4fIn.w = 1.0;
                v3fDestination.set(m4fWorld.multiplyVec4(m4fProjection.unproj(v4fIn, v4fOut)).xyz);
                return v3fDestination;
            };
            Viewport.prototype.isUpdated = /** @inline */function () {
                return this._bUpdated;
            };
            Viewport.prototype._clearUpdatedFlag = /** @inline */function () {
                this._bUpdated = false;
            };
            Viewport.prototype._getNumRenderedPolygons = function () {
                return this._pCamera ? this._pCamera._getNumRenderedFaces() : 0;
            };
            Viewport.prototype._getViewportState = /** @inline */function () {
                return this._pViewportState;
            };
            Viewport.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            Viewport._pEventTable = new akra.events.EventTable();
            Viewport.prototype.getEventTable = /** @inline */function () {
                return Viewport._pEventTable;
            };
            Viewport.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Viewport.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Viewport.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (Viewport._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Viewport.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (Viewport._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Viewport.prototype._syncTable = /** @inline */function (pFrom) {
                (Viewport._pEventTable)._sync(this, pFrom);
            };
            Viewport.prototype.viewportDimensionsChanged = function () {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Viewport._pEventTable))).broadcast[(this._iGuid)] = (((Viewport._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).viewportDimensionsChanged;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            Viewport.prototype.viewportCameraChanged = function () {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Viewport._pEventTable))).broadcast[(this._iGuid)] = (((Viewport._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).viewportCameraChanged;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            Viewport.prototype.render = function (pTechnique, iPass, pRenderable, pSceneObject) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Viewport._pEventTable))).broadcast[(this._iGuid)] = (((Viewport._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).render;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pTechnique, iPass, pRenderable, pSceneObject) : _broadcast[i].listener(_recivier, pTechnique, iPass, pRenderable, pSceneObject);
                    }
                }
            };
            return Viewport;
        })();
        render.Viewport = Viewport;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        /** @inline */function createSamplerState() {
            return {
                textureName: "",
                texture: null,
                wrap_s: akra.ETextureWrapModes.CLAMP_TO_EDGE,
                wrap_t: akra.ETextureWrapModes.CLAMP_TO_EDGE,
                mag_filter: akra.ETextureFilters.LINEAR,
                min_filter: akra.ETextureFilters.LINEAR
            };
        }
        fx.createSamplerState = createSamplerState;
        var PassInputBlend = (function () {
            function PassInputBlend(pCreator) {
                this._isFirstInit = true;
                this._pCreator = null;
                this._pUniformTypeMap = null;
                this._isUniformArrayMap = null;
                this._pForeignTypeMap = null;
                this._pTextureTypeMap = null;
                this._bNeedToCalcBlend = true;
                this._bNeedToCalcShader = true;
                this._iLastPassBlendId = 0;
                this._iLastShaderId = 0;
                this._pMaterialContainer = {
                    "DIFFUSE": new akra.Vec4(),
                    "AMBIENT": new akra.Vec4(),
                    "SPECULAR": new akra.Vec4(),
                    "EMISSIVE": new akra.Vec4(),
                    "SHININESS": 1.
                };
                this.samplers = null;
                this.samplerArrays = null;
                this.samplerArrayLength = null;
                this.uniforms = null;
                this.foreigns = null;
                this.textures = null;
                this.samplerKeys = null;
                this.samplerArrayKeys = null;
                this.uniformKeys = null;
                this.foreignKeys = null;
                this.textureKeys = null;
                this._pCreator = pCreator;
                this.init();
            }
            PassInputBlend.prototype.hasTexture = function (sName) {
                if (!this._pTextureTypeMap[sName]) {
                    this._pTextureTypeMap[sName] = akra.EAFXShaderVariableType.k_NotVar;
                    return false;
                }
                return true;
            };
            PassInputBlend.prototype.hasUniform = function (sName) {
                if (!this._pUniformTypeMap[sName]) {
                    this._pUniformTypeMap[sName] = akra.EAFXShaderVariableType.k_NotVar;
                    return false;
                } else {
                    return true;
                }
            };
            PassInputBlend.prototype.setUniform = function (sName, pValue) {
                var eType = this._pUniformTypeMap[sName];
                if (!eType) {
                    this._pUniformTypeMap[sName] = akra.EAFXShaderVariableType.k_NotVar;
                    return;
                }
                if (eType === akra.EAFXShaderVariableType.k_Sampler2D || eType === akra.EAFXShaderVariableType.k_SamplerCUBE) {
                    var isArray = this._isUniformArrayMap[sName];
                    if (isArray) {
                        this.setSamplerArray(sName, pValue);
                    } else {
                        (PassInputBlend.copySamplerState((pValue), (this).samplers[(sName)]));
                    }
                    return;
                }
                //Check type
                this.uniforms[sName] = pValue;
            };
            PassInputBlend.prototype.setForeign = function (sName, pValue) {
                if (!this._pForeignTypeMap[sName]) {
                    this._pForeignTypeMap[sName] = akra.EAFXShaderVariableType.k_NotVar;
                    return;
                }
                //Check type
                var pOldValue = this.foreigns[sName];
                if (pOldValue !== pValue) {
                    this._bNeedToCalcBlend = true;
                    this._bNeedToCalcShader = true;
                }
                this.foreigns[sName] = pValue;
            };
            PassInputBlend.prototype.setSampler = /** @inline */function (sName, pValue) {
                PassInputBlend.copySamplerState(pValue, this.samplers[sName]);
            };
            PassInputBlend.prototype.setSamplerTexture = function (sName, pTexture) {
                if (this.hasUniform(sName)) {
                    if ((typeof (pTexture) === "string")) {
                        this.samplers[sName].textureName = pTexture;
                    } else {
                        var pState = this.samplers[sName];
                        pState.texture = pTexture;
                        if (!((pTexture) === null)) {
                            pState.min_filter = pTexture.getFilter(akra.ETextureParameters.MIN_FILTER);
                            pState.mag_filter = pTexture.getFilter(akra.ETextureParameters.MAG_FILTER);
                            pState.wrap_s = pTexture.getWrapMode(akra.ETextureParameters.WRAP_S);
                            pState.wrap_t = pTexture.getWrapMode(akra.ETextureParameters.WRAP_T);
                        }
                    }
                }
            };
            PassInputBlend.prototype._setSamplerTextureObject = function (sName, pTexture) {
                if (this.hasUniform(sName)) {
                    var pState = this.samplers[sName];
                    pState.texture = pTexture;
                    if (!((pTexture) === null)) {
                        pState.min_filter = pTexture.getFilter(akra.ETextureParameters.MIN_FILTER);
                        pState.mag_filter = pTexture.getFilter(akra.ETextureParameters.MAG_FILTER);
                        pState.wrap_s = pTexture.getWrapMode(akra.ETextureParameters.WRAP_S);
                        pState.wrap_t = pTexture.getWrapMode(akra.ETextureParameters.WRAP_T);
                    }
                }
            };
            PassInputBlend.prototype.setSamplerArray = function (sName, pValue) {
                for(var i = 0; i < pValue.length; i++) {
                    PassInputBlend.copySamplerState(pValue[i], this.samplerArrays[sName][i]);
                }
                this.samplerArrayLength[sName] = pValue.length;
            };
            PassInputBlend.prototype.setStruct = /** @inline */function (sName, pValue) {
                this.setUniform(sName, pValue);
            };
            PassInputBlend.copySamplerState = function copySamplerState(pFrom, pTo) {
                pTo.textureName = pFrom.textureName;
                pTo.texture = pFrom.texture;
                pTo.wrap_s = pFrom.wrap_s;
                pTo.wrap_t = pFrom.wrap_t;
                pTo.mag_filter = pFrom.mag_filter;
                pTo.min_filter = pFrom.min_filter;
            };
            PassInputBlend.prototype.setTexture = //complete
            function (sName, pValue) {
                if (!this._pTextureTypeMap[sName]) {
                    this._pTextureTypeMap[sName] = akra.EAFXShaderVariableType.k_NotVar;
                    return;
                }
                //Check type
                this.textures[sName] = pValue;
            };
            PassInputBlend.prototype.setSurfaceMaterial = function (pSurfaceMaterial) {
                if (((pSurfaceMaterial) === null)) {
                    return;
                }
                // var pSurfaceMaterial: core.pool.resources.SurfaceMaterial = pSurfaceMaterial;
                var iTotalTextures = pSurfaceMaterial.totalTextures;
                for(var i = 0; i < iTotalTextures; i++) {
                    // var iTexcord: int = pSurfaceMaterial[i].texcoord(i);
                    this.setTexture("TEXTURE" + i.toString(), pSurfaceMaterial.texture(i) || null);
                }
                var pMaterial = pSurfaceMaterial.material;
                var pMatContainer = this._pMaterialContainer;
                pMatContainer.DIFFUSE.set(pMaterial.diffuse.r, pMaterial.diffuse.g, pMaterial.diffuse.b, pMaterial.diffuse.a);
                pMatContainer.AMBIENT.set(pMaterial.ambient.r, pMaterial.ambient.g, pMaterial.ambient.b, pMaterial.ambient.a);
                pMatContainer.SPECULAR.set(pMaterial.specular.r, pMaterial.specular.g, pMaterial.specular.b, pMaterial.specular.a);
                pMatContainer.EMISSIVE.set(pMaterial.emissive.r, pMaterial.emissive.g, pMaterial.emissive.b, pMaterial.emissive.a);
                pMatContainer.SHININESS = pMaterial.shininess;
                if (this.hasUniform("MATERIAL")) {
                    this.uniforms["MATERIAL"] = pMatContainer;
                }
                ;
                // FAST_SET_SAMPLER_TEXTURE("S_DIFFUSE", pSurfaceMaterial.texture(ESurfaceMaterialTextures.DIFFUSE) || null);
                // FAST_SET_SAMPLER_TEXTURE("S_AMBIENT", pSurfaceMaterial.texture(ESurfaceMaterialTextures.AMBIENT) || null);
                // FAST_SET_SAMPLER_TEXTURE("S_SPECULAR", pSurfaceMaterial.texture(ESurfaceMaterialTextures.SPECULAR) || null);
                // FAST_SET_SAMPLER_TEXTURE("S_EMISSIVE", pSurfaceMaterial.texture(ESurfaceMaterialTextures.EMISSIVE) || null);
                // FAST_SET_SAMPLER_TEXTURE("S_NORMAL", pSurfaceMaterial.texture(ESurfaceMaterialTextures.NORMAL) || null);
                this._setSamplerTextureObject("S_DIFFUSE", pSurfaceMaterial.texture(akra.ESurfaceMaterialTextures.DIFFUSE) || null);
                this._setSamplerTextureObject("S_AMBIENT", pSurfaceMaterial.texture(akra.ESurfaceMaterialTextures.AMBIENT) || null);
                this._setSamplerTextureObject("S_SPECULAR", pSurfaceMaterial.texture(akra.ESurfaceMaterialTextures.SPECULAR) || null);
                this._setSamplerTextureObject("S_EMISSIVE", pSurfaceMaterial.texture(akra.ESurfaceMaterialTextures.EMISSIVE) || null);
                this._setSamplerTextureObject("S_NORMAL", pSurfaceMaterial.texture(akra.ESurfaceMaterialTextures.NORMAL) || null);
                // if(this.hasUniform("MATERIAL.DIFFUSE")) this.uniforms["MATERIAL.DIFFUSE"] = pMatContainer.DIFFUSE;
                // if(this.hasUniform("MATERIAL.AMBIENT")) this.uniforms["MATERIAL.AMBIENT"] = pMatContainer.AMBIENT;
                // if(this.hasUniform("MATERIAL.SPECULAR")) this.uniforms["MATERIAL.SPECULAR"] = pMatContainer.SPECULAR;
                // if(this.hasUniform("MATERIAL.EMISSIVE")) this.uniforms["MATERIAL.EMISSIVE"] = pMatContainer.EMISSIVE;
                // if(this.hasUniform("MATERIAL.SHININESS")) this.uniforms["MATERIAL.SHININESS"] = pMatContainer.SHININESS;
                // this.setUniform("MATERIAL.DIFFUSE", util.colorToVec4(pMaterial.diffuse));
                // this.setUniform("MATERIAL.AMBIENT", util.colorToVec4(pMaterial.ambient));
                // this.setUniform("MATERIAL.SPECULAR", util.colorToVec4(pMaterial.specular));
                // this.setUniform("MATERIAL.EMISSIVE", util.colorToVec4(pMaterial.emissive));
                // this.setUniform("MATERIAL.SHININESS", pMaterial.shininess);
                            };
            PassInputBlend.prototype._getUnifromLength = /** @inline */function (sName) {
                return this._pCreator.uniformByRealName[sName].getType().getLength();
            };
            PassInputBlend.prototype._getUniformType = /** @inline */function (sName) {
                return this._pUniformTypeMap[sName];
            };
            PassInputBlend.prototype._getSamplerState = /** @inline */function (sName) {
                return this.samplers[sName];
            };
            PassInputBlend.prototype._getSamplerTexture = /** @inline */function (sName) {
                return this._getTextureForSamplerState(((this).samplers[(sName)]));
            };
            PassInputBlend.prototype._getTextureForSamplerState = function (pSamplerState) {
                var pTexture = null;
                if (!((pSamplerState.texture) === null)) {
                    pTexture = pSamplerState.texture;
                } else if (pSamplerState.textureName !== "") {
                    if (this.hasTexture(pSamplerState.textureName)) {
                        pTexture = this.textures[pSamplerState.textureName];
                    }
                }
                return pTexture;
            };
            PassInputBlend.prototype._release = function () {
                for(var i = 0; i < this.uniformKeys.length; i++) {
                    this.uniforms[this.uniformKeys[i]] = null;
                }
                for(var i = 0; i < this.foreignKeys.length; i++) {
                    this.foreigns[this.foreignKeys[i]] = null;
                }
                for(var i = 0; i < this.textureKeys.length; i++) {
                    this.textures[this.textureKeys[i]] = null;
                }
                for(var i = 0; i < this.samplerKeys.length; i++) {
                    this.clearSamplerState(this.samplers[this.samplerKeys[i]]);
                }
                for(var i = 0; i < this.samplerArrayKeys.length; i++) {
                    var pStateList = this.samplerArrays[this.samplerArrayKeys[i]];
                    for(var j = 0; j < pStateList.length; j++) {
                        this.clearSamplerState(pStateList[j]);
                    }
                    this.samplerArrayLength[this.samplerArrayKeys[i]] = 0;
                }
                this._pCreator.releasePassInput(this);
                this._bNeedToCalcShader = true;
                this._bNeedToCalcBlend = true;
            };
            PassInputBlend.prototype._isNeedToCalcBlend = /** @inline */function () {
                return this._bNeedToCalcBlend;
            };
            PassInputBlend.prototype._isNeedToCalcShader = /** @inline */function () {
                return this._bNeedToCalcBlend || this._bNeedToCalcShader;
            };
            PassInputBlend.prototype._getLastPassBlendId = /** @inline */function () {
                return this._iLastPassBlendId;
            };
            PassInputBlend.prototype._getLastShaderId = /** @inline */function () {
                return this._iLastShaderId;
            };
            PassInputBlend.prototype._setPassBlendId = /** @inline */function (id) {
                this._iLastPassBlendId = id;
            };
            PassInputBlend.prototype._setShaderId = /** @inline */function (id) {
                this._iLastShaderId = id;
            };
            PassInputBlend.prototype._getAFXUniformVar = /** @inline */function (sName) {
                return this._pCreator.uniformByRealName[sName];
            };
            PassInputBlend.prototype.init = function () {
                this._pUniformTypeMap = {};
                this._isUniformArrayMap = {};
                this._pForeignTypeMap = {};
                this._pTextureTypeMap = {};
                this.samplers = {};
                this.samplerArrays = {};
                this.samplerArrayLength = {};
                this.uniforms = {};
                this.foreigns = {};
                this.textures = {};
                var pUniformKeys = this._pCreator.uniformRealNameList;
                var pForeignKeys = this._pCreator.foreignNameList;
                var pTextureKeys = this._pCreator.textureRealNameList;
                var pUniformMap = this._pCreator.uniformByRealName;
                var pForeignMap = this._pCreator.foreignByName;
                var pTextureMap = this._pCreator.textureByRealName;
                var pUniformDafaultValues = this._pCreator.uniformDefaultValue;
                var eType = 0;
                var sName = "";
                var isArray = false;
                for(var i = 0; i < pUniformKeys.length; i++) {
                    sName = pUniformKeys[i];
                    eType = PassInputBlend.getVariableType(pUniformMap[sName]);
                    isArray = ((pUniformMap[sName]).getType().isNotBaseArray());
                    this._pUniformTypeMap[sName] = eType;
                    this._isUniformArrayMap[sName] = isArray;
                    if (eType === akra.EAFXShaderVariableType.k_Sampler2D || eType === akra.EAFXShaderVariableType.k_SamplerCUBE) {
                        var hasDefaultValue = !((pUniformDafaultValues[sName]) === null);
                        if (isArray) {
                            if (hasDefaultValue) {
                                this.samplerArrays[sName] = new Array(pUniformDafaultValues[sName].length);
                                this.samplerArrayLength[sName] = this.samplerArrays[sName].length;
                            } else {
                                this.samplerArrays[sName] = new Array(16);
                                this.samplerArrayLength[sName] = 0;
                            }
                            for(var j = 0; j < this.samplerArrays[sName].length; j++) {
                                var pNewState = ({
textureName: "",
texture: null,
wrap_s: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
wrap_t: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
mag_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR,
min_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR
});
                                if (hasDefaultValue) {
                                    var pDefaultState = pUniformDafaultValues[sName][j];
                                    pNewState.textureName = pDefaultState.textureName;
                                    pNewState.wrap_s = pDefaultState.wrap_s || pNewState.wrap_s;
                                    pNewState.wrap_t = pDefaultState.wrap_t || pNewState.wrap_t;
                                    pNewState.mag_filter = pDefaultState.mag_filter || pNewState.mag_filter;
                                    pNewState.min_filter = pDefaultState.min_filter || pNewState.min_filter;
                                }
                                this.samplerArrays[sName][j] = pNewState;
                            }
                        } else {
                            var pNewState = ({
textureName: "",
texture: null,
wrap_s: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
wrap_t: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
mag_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR,
min_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR
});
                            if (hasDefaultValue) {
                                var pDefaultState = pUniformDafaultValues[sName];
                                pNewState.textureName = pDefaultState.textureName;
                                pNewState.wrap_s = pDefaultState.wrap_s || pNewState.wrap_s;
                                pNewState.wrap_t = pDefaultState.wrap_t || pNewState.wrap_t;
                                pNewState.mag_filter = pDefaultState.mag_filter || pNewState.mag_filter;
                                pNewState.min_filter = pDefaultState.min_filter || pNewState.min_filter;
                            }
                            this.samplers[sName] = pNewState;
                        }
                    } else {
                        this.uniforms[sName] = pUniformDafaultValues[sName];
                    }
                }
                for(var i = 0; i < pForeignKeys.length; i++) {
                    sName = pForeignKeys[i];
                    eType = PassInputBlend.getVariableType(pForeignMap[sName]);
                    this._pForeignTypeMap[sName] = eType;
                    this.foreigns[sName] = null;
                }
                for(var i = 0; i < pTextureKeys.length; i++) {
                    sName = pTextureKeys[i];
                    eType = akra.EAFXShaderVariableType.k_Texture;
                    this._pTextureTypeMap[sName] = eType;
                    this.textures[sName] = null;
                }
                this.samplerKeys = Object.keys(this.samplers);
                this.samplerArrayKeys = Object.keys(this.samplerArrays);
                this.uniformKeys = Object.keys(this.uniforms);
                this.foreignKeys = Object.keys(this.foreigns);
                this.textureKeys = Object.keys(this.textures);
            };
            PassInputBlend.getVariableType = function getVariableType(pVar) {
                var sBaseType = pVar.getType().getBaseType().getName();
                switch(sBaseType) {
                    case "texture":
                        return akra.EAFXShaderVariableType.k_Texture;
                    case "float":
                        return akra.EAFXShaderVariableType.k_Float;
                    case "int":
                        return akra.EAFXShaderVariableType.k_Int;
                    case "bool":
                        return akra.EAFXShaderVariableType.k_Bool;
                    case "float2":
                        return akra.EAFXShaderVariableType.k_Float2;
                    case "int2":
                        return akra.EAFXShaderVariableType.k_Int2;
                    case "bool2":
                        return akra.EAFXShaderVariableType.k_Bool2;
                    case "float3":
                        return akra.EAFXShaderVariableType.k_Float3;
                    case "int3":
                        return akra.EAFXShaderVariableType.k_Int3;
                    case "bool3":
                        return akra.EAFXShaderVariableType.k_Bool3;
                    case "float4":
                        return akra.EAFXShaderVariableType.k_Float4;
                    case "int4":
                        return akra.EAFXShaderVariableType.k_Int4;
                    case "bool4":
                        return akra.EAFXShaderVariableType.k_Bool4;
                    case "float2x2":
                        return akra.EAFXShaderVariableType.k_Float2x2;
                    case "float3x3":
                        return akra.EAFXShaderVariableType.k_Float3x3;
                    case "float4x4":
                        return akra.EAFXShaderVariableType.k_Float4x4;
                    case "sampler":
                    case "sampler2D":
                        return akra.EAFXShaderVariableType.k_Sampler2D;
                    case "samplerCUBE":
                        return akra.EAFXShaderVariableType.k_SamplerCUBE;
                    default:
                        if (pVar.getType().isComplex()) {
                            return akra.EAFXShaderVariableType.k_Complex;
                        } else {
                            return akra.EAFXShaderVariableType.k_NotVar;
                        }
                }
            };
            PassInputBlend.prototype.isVarArray = /** @inline */function (pVar) {
                return pVar.getType().isNotBaseArray();
            };
            PassInputBlend.prototype.clearSamplerState = function (pState) {
                pState.textureName = "";
                pState.texture = null;
                pState.wrap_s = akra.ETextureWrapModes.CLAMP_TO_EDGE;
                pState.wrap_t = akra.ETextureWrapModes.CLAMP_TO_EDGE;
                pState.mag_filter = akra.ETextureFilters.LINEAR;
                pState.min_filter = akra.ETextureFilters.LINEAR;
            };
            return PassInputBlend;
        })();
        fx.PassInputBlend = PassInputBlend;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        var LightData = (function () {
            function LightData() {
                this.DIFFUSE = new akra.Vec4();
                this.AMBIENT = new akra.Vec4();
                this.SPECULAR = new akra.Vec4();
                this.POSITION = new akra.Vec3();
                this.ATTENUATION = new akra.Vec3();
            }
            LightData.prototype.set = function (pLightParam, v3fPosition) {
                this.DIFFUSE.set(pLightParam.diffuse);
                this.AMBIENT.set(pLightParam.ambient);
                this.SPECULAR.set(pLightParam.specular);
                this.ATTENUATION.set(pLightParam.attenuation);
                this.POSITION.set(v3fPosition);
                return this;
            };
            return LightData;
        })();
        render.LightData = LightData;        
        ;
        var UniformOmni = (function () {
            function UniformOmni() {
                this.LIGHT_DATA = new LightData();
            }
            UniformOmni.prototype.setLightData = function (pLightParam, v3fPosition) {
                this.LIGHT_DATA.set(pLightParam, v3fPosition);
                return this;
            };
            Object.defineProperty(UniformOmni, "stackCeil", {
                get: function () {
                    UniformOmni.stackPosition = UniformOmni.stackPosition === UniformOmni.stackSize - 1 ? 0 : UniformOmni.stackPosition;
                    return UniformOmni.stack[UniformOmni.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            UniformOmni.stackSize = 200;
            UniformOmni.stackPosition = 0;
            UniformOmni.stack = (function () {
                var pStack = new Array(UniformOmni.stackSize);
                for(var i = 0; i < UniformOmni.stackSize; i++) {
                    pStack[i] = new UniformOmni();
                }
                return pStack;
            })();
            return UniformOmni;
        })();
        render.UniformOmni = UniformOmni;        
        ;
        var UniformProject = (function () {
            function UniformProject() {
                this.LIGHT_DATA = new LightData();
                this.SHADOW_MATRIX = new akra.Mat4();
            }
            UniformProject.prototype.setLightData = function (pLightParam, v3fPosition) {
                this.LIGHT_DATA.set(pLightParam, v3fPosition);
                return this;
            };
            UniformProject.prototype.setMatrix = function (m4fMatrix) {
                this.SHADOW_MATRIX.set(m4fMatrix);
                return this;
            };
            Object.defineProperty(UniformProject, "stackCeil", {
                get: function () {
                    UniformProject.stackPosition = UniformProject.stackPosition === UniformProject.stackSize - 1 ? 0 : UniformProject.stackPosition;
                    return UniformProject.stack[UniformProject.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            UniformProject.stackSize = 200;
            UniformProject.stackPosition = 0;
            UniformProject.stack = (function () {
                var pStack = new Array(UniformProject.stackSize);
                for(var i = 0; i < UniformProject.stackSize; i++) {
                    pStack[i] = new UniformProject();
                }
                return pStack;
            })();
            return UniformProject;
        })();
        render.UniformProject = UniformProject;        
        ;
        var UniformProjectShadow = (function () {
            function UniformProjectShadow() {
                this.LIGHT_DATA = new LightData();
                this.TO_LIGHT_SPACE = new akra.Mat4();
                this.REAL_PROJECTION_MATRIX = new akra.Mat4();
                this.OPTIMIZED_PROJECTION_MATRIX = new akra.Mat4();
                this.SHADOW_SAMPLER = ({
textureName: "",
texture: null,
wrap_s: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
wrap_t: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
mag_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR,
min_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR
});
            }
            UniformProjectShadow.prototype.setLightData = function (pLightParam, v3fPosition) {
                this.LIGHT_DATA.set(pLightParam, v3fPosition);
                return this;
            };
            UniformProjectShadow.prototype.setMatrix = function (m4fToLightSpace, m4fRealProj, m4fOptimizedProj) {
                this.TO_LIGHT_SPACE.set(m4fToLightSpace);
                this.REAL_PROJECTION_MATRIX.set(m4fRealProj);
                this.OPTIMIZED_PROJECTION_MATRIX.set(m4fOptimizedProj);
                return this;
            };
            UniformProjectShadow.prototype.setSampler = function (sTexture) {
                this.SHADOW_SAMPLER.textureName = sTexture;
                return this;
            };
            Object.defineProperty(UniformProjectShadow, "stackCeil", {
                get: function () {
                    UniformProjectShadow.stackPosition = UniformProjectShadow.stackPosition === UniformProjectShadow.stackSize - 1 ? 0 : UniformProjectShadow.stackPosition;
                    return UniformProjectShadow.stack[UniformProjectShadow.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            UniformProjectShadow.stackSize = 20;
            UniformProjectShadow.stackPosition = 0;
            UniformProjectShadow.stack = (function () {
                var pStack = new Array(UniformProjectShadow.stackSize);
                for(var i = 0; i < UniformProjectShadow.stackSize; i++) {
                    pStack[i] = new UniformProjectShadow();
                }
                return pStack;
            })();
            return UniformProjectShadow;
        })();
        render.UniformProjectShadow = UniformProjectShadow;        
        var UniformOmniShadow = (function () {
            function UniformOmniShadow() {
                this.LIGHT_DATA = new LightData();
                this.TO_LIGHT_SPACE = [
                    new akra.Mat4(), 
                    new akra.Mat4(), 
                    new akra.Mat4(), 
                    new akra.Mat4(), 
                    new akra.Mat4(), 
                    new akra.Mat4()
                ];
                this.OPTIMIZED_PROJECTION_MATRIX = [
                    new akra.Mat4(), 
                    new akra.Mat4(), 
                    new akra.Mat4(), 
                    new akra.Mat4(), 
                    new akra.Mat4(), 
                    new akra.Mat4()
                ];
                this.SHADOW_SAMPLER = [
                    ({
textureName: "",
texture: null,
wrap_s: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
wrap_t: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
mag_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR,
min_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR
}), 
                    ({
textureName: "",
texture: null,
wrap_s: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
wrap_t: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
mag_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR,
min_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR
}), 
                    ({
textureName: "",
texture: null,
wrap_s: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
wrap_t: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
mag_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR,
min_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR
}), 
                    ({
textureName: "",
texture: null,
wrap_s: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
wrap_t: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
mag_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR,
min_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR
}), 
                    ({
textureName: "",
texture: null,
wrap_s: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
wrap_t: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
mag_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR,
min_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR
}), 
                    ({
textureName: "",
texture: null,
wrap_s: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
wrap_t: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
mag_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR,
min_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR
})
                ];
            }
            UniformOmniShadow.prototype.setLightData = function (pLightParam, v3fPosition) {
                this.LIGHT_DATA.set(pLightParam, v3fPosition);
                return this;
            };
            UniformOmniShadow.prototype.setMatrix = function (m4fToLightSpace, m4fOptimizedProj, index) {
                this.TO_LIGHT_SPACE[index].set(m4fToLightSpace);
                this.OPTIMIZED_PROJECTION_MATRIX[index].set(m4fOptimizedProj);
                return this;
            };
            UniformOmniShadow.prototype.setSampler = function (sTexture, index) {
                this.SHADOW_SAMPLER[index].textureName = sTexture;
                return this;
            };
            Object.defineProperty(UniformOmniShadow, "stackCeil", {
                get: function () {
                    UniformOmniShadow.stackPosition = UniformOmniShadow.stackPosition === UniformOmniShadow.stackSize - 1 ? 0 : UniformOmniShadow.stackPosition;
                    return UniformOmniShadow.stack[UniformOmniShadow.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            UniformOmniShadow.stackSize = 3;
            UniformOmniShadow.stackPosition = 0;
            UniformOmniShadow.stack = (function () {
                var pStack = new Array(UniformOmniShadow.stackSize);
                for(var i = 0; i < UniformOmniShadow.stackSize; i++) {
                    pStack[i] = new UniformOmniShadow();
                }
                return pStack;
            })();
            return UniformOmniShadow;
        })();
        render.UniformOmniShadow = UniformOmniShadow;        
        var UniformSun = (function () {
            function UniformSun() {
                this.SUN_DIRECTION = new akra.Vec3();
                this.EYE_POSITION = new akra.Vec3();
                this.GROUNDC0 = new akra.Vec3();
                this.GROUNDC1 = new akra.Vec3();
                this.HG = new akra.Vec3();
                this.SKY_DOME_ID = 0;
            }
            UniformSun.prototype.setLightData = function (pSunParam, iSunDomeId) {
                this.SUN_DIRECTION.set(pSunParam.sunDir);
                this.EYE_POSITION.set(pSunParam.eyePosition);
                this.GROUNDC0.set(pSunParam.groundC0);
                this.GROUNDC1.set(pSunParam.groundC1);
                this.HG.set(pSunParam.hg);
                this.SKY_DOME_ID = iSunDomeId;
                return this;
            };
            Object.defineProperty(UniformSun, "stackCeil", {
                get: function () {
                    UniformSun.stackPosition = UniformSun.stackPosition === UniformSun.stackSize - 1 ? 0 : UniformSun.stackPosition;
                    return UniformSun.stack[UniformSun.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            UniformSun.stackSize = 3;
            UniformSun.stackPosition = 0;
            UniformSun.stack = (function () {
                var pStack = new Array(UniformSun.stackSize);
                for(var i = 0; i < UniformSun.stackSize; i++) {
                    pStack[i] = new UniformSun();
                }
                return pStack;
            })();
            return UniformSun;
        })();
        render.UniformSun = UniformSun;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        var RenderPass = (function () {
            function RenderPass(pTechnique, iPass) {
                /**@protected*/ this._iGuid = akra.sid();
                this._pTechnique = null;
                this._pRenderTarget = null;
                this._iPassNumber = 0;
                this._pInput = null;
                this._isActive = true;
                this._pTechnique = pTechnique;
                this._iPassNumber = iPass;
            }
            RenderPass.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            RenderPass.prototype.setForeign = /** @inline */function (sName, fValue) {
                this._pInput.setForeign(sName, fValue);
            };
            RenderPass.prototype.setTexture = /** @inline */function (sName, pTexture) {
                this._pInput.setTexture(sName, pTexture);
            };
            RenderPass.prototype.setUniform = /** @inline */function (sName, pValue) {
                this._pInput.setUniform(sName, pValue);
            };
            RenderPass.prototype.setStruct = /** @inline */function (sName, pValue) {
                this._pInput.setStruct(sName, pValue);
            };
            RenderPass.prototype.setSamplerTexture = /** @inline */function (sName, pTexture) {
                this._pInput.setSamplerTexture(sName, pTexture);
            };
            RenderPass.prototype.getRenderTarget = // inline setSamplerState(sName: string, pState: IAFXSamplerState): void {
            // 	this._pInput.setSamplerState(sName, pState);
            // }
            function () {
                return this._pRenderTarget;
            };
            RenderPass.prototype.setRenderTarget = function (pTarget) {
                this._pRenderTarget = pTarget;
            };
            RenderPass.prototype.getPassInput = function () {
                return this._pInput;
            };
            RenderPass.prototype.setPassInput = function (pInput, isNeedRelocate) {
                if (isNeedRelocate) {
                    this.relocateOldInput(pInput);
                }
                if (!((this._pInput) === null)) {
                    this._pInput._release();
                }
                this._pInput = pInput;
            };
            RenderPass.prototype.blend = function (sComponentName, iPass) {
                return this._pTechnique.addComponent(sComponentName, this._iPassNumber, iPass);
            };
            RenderPass.prototype.activate = /** @inline */function () {
                this._isActive = true;
            };
            RenderPass.prototype.deactivate = /** @inline */function () {
                this._isActive = false;
            };
            RenderPass.prototype.isActive = /** @inline */function () {
                return this._isActive;
            };
            RenderPass.prototype.relocateOldInput = function (pNewInput) {
                //TODO: copy old uniforms to new
                            };
            return RenderPass;
        })();
        render.RenderPass = RenderPass;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        var RenderTechnique = (function () {
            function RenderTechnique(pMethod) {
                if (typeof pMethod === "undefined") { pMethod = null; }
                this._pMethod = null;
                this._isFreeze = false;
                this._pComposer = null;
                this._pPassList = null;
                this._pPassBlackList = null;
                this._iCurrentPass = 0;
                this._pCurrentPass = null;
                this._iGlobalPostEffectsStart = 0;
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
                this._pPassList = [];
                this._pPassBlackList = [];
                if (!((pMethod) === null)) {
                    this.setMethod(pMethod);
                }
            }
            Object.defineProperty(RenderTechnique.prototype, "modified", {
                get: /** @inline */function () {
                    return ((this)._iGuid);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderTechnique.prototype, "totalPasses", {
                get: function () {
                    return this._pComposer.getTotalPassesForTechnique(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderTechnique.prototype, "data", {
                get: function () {
                    return null;
                },
                enumerable: true,
                configurable: true
            });
            RenderTechnique.prototype.destroy = function () {
            };
            RenderTechnique.prototype.getPass = /** @inline */function (iPass) {
                this._pComposer.prepareTechniqueBlend(this);
                return this._pPassList[iPass];
            };
            RenderTechnique.prototype.getMethod = function () {
                return this._pMethod;
            };
            RenderTechnique.prototype.setMethod = function (pMethod) {
                if (!((this._pMethod) === null)) {
                    ((this._pMethod).getEventTable().removeDestination(((((this._pMethod)))._iGuid), ("altered"), (this), ("_updateMethod"), (/*checked (origin: akra)>>*/akra.EEventTypes.BROADCAST)));
                }
                this._pMethod = pMethod;
                if (!((pMethod) === null)) {
                    var pComposer = pMethod.manager.getEngine().getComposer();
                    ((this)._pComposer = (pComposer));
                    ((pMethod).getEventTable().addDestination(((((pMethod)))._iGuid), ("altered"), (this), ("_updateMethod"), (/*checked (origin: akra)>>*/akra.EEventTypes.BROADCAST)));
                }
                this.informComposer();
            };
            RenderTechnique.prototype.setState = function (sName, pValue) {
            };
            RenderTechnique.prototype.setForeign = function (sName, pValue) {
            };
            RenderTechnique.prototype.setStruct = function (sName, pValue) {
                //skip
                            };
            RenderTechnique.prototype.setTextureBySemantics = function (sName, pValue) {
            };
            RenderTechnique.prototype.setShadowSamplerArray = function (sName, pValue) {
            };
            RenderTechnique.prototype.setVec2BySemantic = function (sName, pValue) {
            };
            RenderTechnique.prototype.isReady = function () {
                return this._pMethod.isResourceLoaded() && !this._pMethod.isResourceDisabled();
            };
            RenderTechnique.prototype.addComponent = function (pComponent, iShift, iPass, isSet) {
                if (typeof iShift === "undefined") { iShift = 0; }
                if (typeof iPass === "undefined") { iPass = 0xffffff; }
                if (typeof isSet === "undefined") { isSet = true; }
                if (((this._pComposer) === null)) {
                    return false;
                }
                var pComponentPool = this._pComposer.getEngine().getResourceManager().componentPool;
                if ((typeof (pComponent) === "number")) {
                    pComponent = pComponentPool.getResource(pComponent);
                } else if ((typeof (pComponent) === "string")) {
                    pComponent = pComponentPool.findResource(pComponent);
                }
                if (!((pComponent) !== undefined) || ((pComponent) === null)) {
 {
                        akra.logger.setSourceLocation("RenderTechnique.ts", 120);
                        akra.logger.error("Bad component for add/delete.");
                    }
                    ;
                    return false;
                }
                if (isSet) {
                    if (!this._pComposer.addOwnComponentToTechnique(this, pComponent, iShift, iPass)) {
 {
                            akra.logger.setSourceLocation("RenderTechnique.ts", 126);
                            akra.logger.error("Can not add component '" + pComponent.findResourceName() + "'");
                        }
                        ;
                        return false;
                    }
                } else {
                    if (!this._pComposer.removeOwnComponentToTechnique(this, pComponent, iShift, iPass)) {
 {
                            akra.logger.setSourceLocation("RenderTechnique.ts", 132);
                            akra.logger.error("Can not delete component '" + pComponent.findResourceName() + "'");
                        }
                        ;
                        return false;
                    }
                }
                return true;
            };
            RenderTechnique.prototype.delComponent = function (pComponent, iShift, iPass) {
                if (typeof iShift === "undefined") { iShift = 0; }
                if (typeof iPass === "undefined") { iPass = 0xffffff; }
                return this.addComponent(pComponent, iShift, iPass, false);
            };
            RenderTechnique.prototype.hasComponent = function (sComponent, iShift, iPass) {
                if (typeof iShift === "undefined") { iShift = 0xfffffe; }
                if (typeof iPass === "undefined") { iPass = 0xfffffe; }
                return this._pMethod.effect.hasComponent(sComponent, iShift, iPass) || this.hasOwnComponent(sComponent, iShift, iPass);
            };
            RenderTechnique.prototype.hasOwnComponent = function (sComponent, iShift, iPass) {
                if (typeof iShift === "undefined") { iShift = 0xfffffe; }
                if (typeof iPass === "undefined") { iPass = 0xfffffe; }
                if (((this._pComposer) === null)) {
                    return false;
                }
                var pComponentPool = this._pComposer.getEngine().getResourceManager().componentPool;
                var pComponent = null;
                pComponent = pComponentPool.findResource(sComponent);
                if (((pComponent) === null)) {
                    return false;
                }
                return this._pComposer.hasOwnComponentInTechnique(this, pComponent, iShift, iPass);
            };
            RenderTechnique.prototype.hasGlobalPostEffect = function () {
                return this._iGlobalPostEffectsStart > 0;
            };
            RenderTechnique.prototype.isPostEffectPass = function (iPass) {
                return this._iGlobalPostEffectsStart <= iPass;
            };
            RenderTechnique.prototype.isLastPass = function (iPass) {
                var iMaxPass = this.totalPasses - 1;
                if (iMaxPass === iPass) {
                    return true;
                }
                if (!this._pPassBlackList[iMaxPass]) {
                    return false;
                }
                for(var i = this._pPassBlackList.length - 2; i >= 0; i--) {
                    if (!this._pPassBlackList[i]) {
                        if (i !== iPass) {
                            return false;
                        } else {
                            return true;
                        }
                    }
                }
                return false;
            };
            RenderTechnique.prototype.isFirstPass = function (iPass) {
                if (iPass === 0) {
                    return true;
                }
                if (!this._pPassBlackList[0]) {
                    return false;
                }
                for(var i = 1; i < this._pPassBlackList.length; i++) {
                    if (!this._pPassBlackList[i]) {
                        if (i !== iPass) {
                            return false;
                        } else {
                            return true;
                        }
                    }
                }
                return false;
            };
            RenderTechnique.prototype.isFreeze = function () {
                return this._isFreeze;
            };
            RenderTechnique.prototype.updatePasses = function (bSaveOldUniformValue) {
                this._isFreeze = true;
                var iTotalPasses = this.totalPasses;
                for(var i = this._pPassList.length; i < iTotalPasses; i++) {
                    if (!((this._pPassBlackList[i]) !== undefined) || this._pPassBlackList[i] === false) {
                        this._pPassList[i] = new render.RenderPass(this, i);
                        this._pPassBlackList[i] = false;
                    }
                }
                for(var i = 0; i < iTotalPasses; i++) {
                    if (!this._pPassBlackList[i]) {
                        var pInput = this._pComposer.getPassInputBlend(this, i);
                        if (!((pInput) === null)) {
                            this._pPassList[i].setPassInput(pInput, bSaveOldUniformValue);
                            this._pPassList[i].activate();
                        } else {
                            this._pPassList[i].deactivate();
                        }
                    }
                }
                this._isFreeze = false;
            };
            RenderTechnique.prototype._setComposer = /** @inline */function (pComposer) {
                this._pComposer = pComposer;
            };
            RenderTechnique.prototype._getComposer = /** @inline */function () {
                return this._pComposer;
            };
            RenderTechnique.prototype._renderTechnique = function (pViewport, pRenderable, pSceneObject) {
                if (((this._pComposer) === null)) {
                    return;
                }
                var pComposer = this._pComposer;
                pComposer.prepareTechniqueBlend(this);
                pComposer._setCurrentViewport(pViewport);
                pComposer._setCurrentSceneObject(pSceneObject);
                pComposer._setCurrentRenderableObject(pRenderable);
                pComposer.applySurfaceMaterial(this._pMethod.surfaceMaterial);
                this._isFreeze = true;
                for(var i = 0; i < this.totalPasses; i++) {
                    if (this._pPassBlackList[i] === false && this._pPassList[i].isActive()) {
                        this.activatePass(i);
                        this.render(i, pRenderable, pSceneObject, pViewport);
                        pViewport.render(this, i, pRenderable, pSceneObject);
                        pComposer.renderTechniquePass(this, i);
                    }
                }
                this._isFreeze = false;
                pComposer._setDefaultCurrentState();
            };
            RenderTechnique.prototype._updateMethod = function (pMethod) {
                this.informComposer();
            };
            RenderTechnique.prototype._blockPass = function (iPass) {
                this._pPassBlackList[iPass] = true;
                this._pComposer.prepareTechniqueBlend(this);
                // this._pPassList[iPass] = null;
                            };
            RenderTechnique.prototype._setGlobalPostEffectsFrom = function (iPass) {
                this._iGlobalPostEffectsStart = iPass;
            };
            RenderTechnique.prototype.informComposer = function () {
                if (!((this._pComposer) === null)) {
                    this._pComposer.markTechniqueAsNeedUpdate(this);
                }
            };
            RenderTechnique.prototype.activatePass = function (iPass) {
                this._iCurrentPass = iPass;
                this._pCurrentPass = this._pPassList[iPass];
            };
            RenderTechnique.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            RenderTechnique._pEventTable = new akra.events.EventTable();
            RenderTechnique.prototype.getEventTable = /** @inline */function () {
                return RenderTechnique._pEventTable;
            };
            RenderTechnique.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            RenderTechnique.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            RenderTechnique.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (RenderTechnique._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            RenderTechnique.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (RenderTechnique._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            RenderTechnique.prototype._syncTable = /** @inline */function (pFrom) {
                (RenderTechnique._pEventTable)._sync(this, pFrom);
            };
            RenderTechnique.prototype.render = function (iPass, pRenderable, pSceneObject, pViewport) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((RenderTechnique._pEventTable))).broadcast[(this._iGuid)] = (((RenderTechnique._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).render;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, iPass, pRenderable, pSceneObject, pViewport) : _broadcast[i].listener(_recivier, iPass, pRenderable, pSceneObject, pViewport);
                    }
                }
            };
            return RenderTechnique;
        })();
        render.RenderTechnique = RenderTechnique;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
;
var akra;
(function (akra) {
    (function (geometry) {
        var Sphere = (function () {
            function Sphere(fCenterX, fCenterY, fCenterZ, fRadius) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        var pSphere = arguments[0];
                        this.center = new akra.Vec3(pSphere.v3fCenter);
                        this.radius = pSphere.fRadius;
                        break;
                    case 2:
                        var v3fCenter = arguments[0];
                        var fRadius = arguments[1];
                        this.center = new akra.Vec3(v3fCenter);
                        this.radius = fRadius;
                        break;
                    case 4:
                        this.center = new akra.Vec3(arguments[0], arguments[1], arguments[2]);
                        this.radius = arguments[3];
                        break;
                    default:
                        this.center = new akra.Vec3();
                        this.radius = 0.;
                        break;
                }
            }
            Object.defineProperty(Sphere.prototype, "circle", {
                get: function () {
                    var v3fCenter = this.center;
                    return new geometry.Circle(v3fCenter.x, v3fCenter.y, this.radius);
                },
                set: function (pCircle) {
                    var v3fCenter = this.center;
                    var v2fCircleCenter = pCircle.center;
                    v3fCenter.x = v2fCircleCenter.x;
                    v3fCenter.y = v2fCircleCenter.y;
                    this.radius = pCircle.radius;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Sphere.prototype, "z", {
                get: function () {
                    return this.center.z;
                },
                set: function (fZ) {
                    this.center.z = fZ;
                },
                enumerable: true,
                configurable: true
            });
            Sphere.prototype.set = function (fCenterX, fCenterY, fCenterZ, fRadius) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        var pSphere = arguments[0];
                        this.center.set(pSphere.center);
                        this.radius = pSphere.radius;
                        break;
                    case 2:
                        var v3fCenter = arguments[0];
                        var fRadius = arguments[1];
                        this.center.set(v3fCenter);
                        this.radius = fRadius;
                        break;
                    case 4:
                        this.center.set(arguments[0], arguments[1], arguments[2]);
                        this.radius = arguments[3];
                        break;
                    default:
                        this.center.set(0.);
                        this.radius = 0.;
                        break;
                }
                return this;
            };
            Sphere.prototype.clear = /** @inline */function () {
                this.center.clear();
                this.radius = 0.;
                return this;
            };
            Sphere.prototype.isEqual = /** @inline */function (pSphere) {
                return this.center.isEqual(pSphere.center) && (this.radius == pSphere.radius);
            };
            Sphere.prototype.isClear = /** @inline */function () {
                return this.center.isClear() && (this.radius === 0.);
            };
            Sphere.prototype.isValid = /** @inline */function () {
                return (this.radius >= 0.);
            };
            Sphere.prototype.offset = /** @inline */function (v3fOffset) {
                this.center.add(v3fOffset);
                return this;
            };
            Sphere.prototype.expand = /** @inline */function (fInc) {
                this.radius += fInc;
                return this;
            };
            Sphere.prototype.normalize = /** @inline */function () {
                this.radius = akra.math.abs(this.radius);
                return this;
            };
            Sphere.prototype.transform = function (m4fMatrix) {
                var v4fTmp = akra.Vec4.stackCeil.set(this.center, 1.);
                v4fTmp = m4fMatrix.multiplyVec4(v4fTmp);
                this.center.set(v4fTmp.xyz);
                var m3fTmp = m4fMatrix.toMat3(akra.Mat3.stackCeil.set());
                var v3fScale = akra.Vec3.stackCeil.set();
                m3fTmp.decompose(akra.Quat4.stackCeil.set(), v3fScale);
                var fScaleX = akra.math.abs(v3fScale.x);
                var fScaleY = akra.math.abs(v3fScale.y);
                var fScaleZ = akra.math.abs(v3fScale.z);
                var fMaxScale;
                if (fScaleX >= fScaleY && fScaleX >= fScaleZ) {
                    fMaxScale = fScaleX;
                } else if (fScaleY >= fScaleX && fScaleY >= fScaleZ) {
                    fMaxScale = fScaleY;
                } else {
                    fMaxScale = fScaleZ;
                }
                this.radius *= fMaxScale;
                return this;
            };
            return Sphere;
        })();
        geometry.Sphere = Sphere;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (geometry) {
        var Rect3d = (function () {
            function Rect3d(fX0, fX1, fY0, fY1, fZ0, fZ1) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 2:
                        this.set(arguments[0], arguments[1]);
                        break;
                    case 3:
                        this.set(arguments[0], arguments[1], arguments[2]);
                        break;
                    case 6:
                        this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                        break;
                    default:
                        this.x0 = this.x1 = this.y0 = this.y1 = this.z0 = this.z1 = 0.;
                        break;
                }
            }
            Object.defineProperty(Rect3d.prototype, "rect2d", {
                get: function () {
                    return new geometry.Rect2d(this.x0, this.x1, this.y0, this.y1);
                },
                set: function (pRect) {
                    this.x0 = pRect.x0;
                    this.x1 = pRect.x1;
                    this.y0 = pRect.y0;
                    this.y1 = pRect.y1;
                },
                enumerable: true,
                configurable: true
            });
            Rect3d.prototype.set = function (fX0, fX1, fY0, fY1, fZ0, fZ1) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        if (arguments[0] instanceof Rect3d) {
                            var pRect = arguments[0];
                            this.x0 = pRect.x0;
                            this.x1 = pRect.x1;
                            this.y0 = pRect.y0;
                            this.y1 = pRect.y1;
                            this.z0 = pRect.z0;
                            this.z1 = pRect.z1;
                        } else {
                            var v3fSize = arguments[0];
                            this.x1 = v3fSize.x * 0.5;
                            this.x0 = -this.x1;
                            this.y1 = v3fSize.y * 0.5;
                            this.y0 = -this.y1;
                            this.z1 = v3fSize.z * 0.5;
                            this.z0 = -this.z1;
                        }
                        break;
                    case 2:
                        var v3fMinPoint = arguments[0];
                        var v3fMaxPoint = arguments[1];
                        this.x0 = v3fMinPoint.x;
                        this.y0 = v3fMinPoint.y;
                        this.z0 = v3fMinPoint.z;
                        this.x1 = v3fMaxPoint.x;
                        this.y1 = v3fMaxPoint.y;
                        this.z1 = v3fMaxPoint.z;
                        break;
                    case 3:
                        var fSizeX = arguments[0];
                        var fSizeY = arguments[1];
                        var fSizeZ = arguments[2];
                        this.x1 = fSizeX * 0.5;
                        this.x0 = -this.x1;
                        this.y1 = fSizeY * 0.5;
                        this.y0 = -this.y1;
                        this.z1 = fSizeZ * 0.5;
                        this.z0 = -this.z1;
                        break;
                    case 6:
                        this.x0 = arguments[0];
                        this.x1 = arguments[1];
                        this.y0 = arguments[2];
                        this.y1 = arguments[3];
                        this.z0 = arguments[4];
                        this.z1 = arguments[5];
                        break;
                    default:
                        this.x0 = this.x1 = this.y0 = this.y1 = this.z0 = this.z1 = 0.;
                        break;
                }
                return this;
            };
            Rect3d.prototype.setFloor = function (pRect) {
                this.x0 = akra.math.floor(pRect.x0);
                this.x1 = akra.math.floor(pRect.x1);
                this.y0 = akra.math.floor(pRect.y0);
                this.y1 = akra.math.floor(pRect.y1);
                this.z0 = akra.math.floor(pRect.z0);
                this.z1 = akra.math.floor(pRect.z1);
                return this;
            };
            Rect3d.prototype.setCeil = function (pRect) {
                this.x0 = akra.math.ceil(pRect.x0);
                this.x1 = akra.math.ceil(pRect.x1);
                this.y0 = akra.math.ceil(pRect.y0);
                this.y1 = akra.math.ceil(pRect.y1);
                this.z0 = akra.math.ceil(pRect.z0);
                this.z1 = akra.math.ceil(pRect.z1);
                return this;
            };
            Rect3d.prototype.clear = /** @inline */function () {
                this.x0 = this.x1 = this.y0 = this.y1 = this.z0 = this.z1 = 0.;
                return this;
            };
            Rect3d.prototype.addSelf = function (v3fVec) {
                if ((typeof (arguments[0]) === "number")) {
                    var fValue = arguments[0];
                    this.x0 += fValue;
                    this.x1 += fValue;
                    this.y0 += fValue;
                    this.y1 += fValue;
                    this.z0 += fValue;
                    this.z1 += fValue;
                } else {
                    var v3fVec = arguments[0];
                    this.x0 += v3fVec.x;
                    this.x1 += v3fVec.x;
                    this.y0 += v3fVec.y;
                    this.y1 += v3fVec.y;
                    this.z0 += v3fVec.z;
                    this.z1 += v3fVec.z;
                }
                return this;
            };
            Rect3d.prototype.subSelf = function (v3fVec) {
                if ((typeof (arguments[0]) === "number")) {
                    var fValue = arguments[0];
                    this.x0 -= fValue;
                    this.x1 -= fValue;
                    this.y0 -= fValue;
                    this.y1 -= fValue;
                    this.z0 -= fValue;
                    this.z1 -= fValue;
                } else {
                    var v3fVec = arguments[0];
                    this.x0 -= v3fVec.x;
                    this.x1 -= v3fVec.x;
                    this.y0 -= v3fVec.y;
                    this.y1 -= v3fVec.y;
                    this.z0 -= v3fVec.z;
                    this.z1 -= v3fVec.z;
                }
                return this;
            };
            Rect3d.prototype.multSelf = function (v3fVec) {
                if ((typeof (arguments[0]) === "number")) {
                    var fValue = arguments[0];
                    this.x0 *= fValue;
                    this.x1 *= fValue;
                    this.y0 *= fValue;
                    this.y1 *= fValue;
                    this.z0 *= fValue;
                    this.z1 *= fValue;
                } else {
                    var v3fVec = arguments[0];
                    this.x0 *= v3fVec.x;
                    this.x1 *= v3fVec.x;
                    this.y0 *= v3fVec.y;
                    this.y1 *= v3fVec.y;
                    this.z0 *= v3fVec.z;
                    this.z1 *= v3fVec.z;
                }
                return this;
            };
            Rect3d.prototype.divSelf = function (v3fVec) {
                if ((typeof (arguments[0]) === "number")) {
                    var fValue = arguments[0];
 {
                        akra.logger.setSourceLocation("geometry/Rect3d.ts", 261);
                        akra.logger.assert(fValue != 0.0, "divide by zero error");
                    }
                    ;
                    var fInvValue = 1. / fValue;
                    this.x0 *= fInvValue;
                    this.x1 *= fInvValue;
                    this.y0 *= fInvValue;
                    this.y1 *= fInvValue;
                    this.z0 *= fInvValue;
                    this.z1 *= fInvValue;
                } else {
                    var v3fVec = arguments[0];
 {
                        akra.logger.setSourceLocation("geometry/Rect3d.ts", 275);
                        akra.logger.assert(v3fVec.x != 0.0, "divide by zero error");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("geometry/Rect3d.ts", 276);
                        akra.logger.assert(v3fVec.y != 0.0, "divide by zero error");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("geometry/Rect3d.ts", 277);
                        akra.logger.assert(v3fVec.z != 0.0, "divide by zero error");
                    }
                    ;
                    var fInvX = 1. / v3fVec.x;
                    var fInvY = 1. / v3fVec.y;
                    var fInvZ = 1. / v3fVec.z;
                    this.x0 *= fInvX;
                    this.x1 *= fInvX;
                    this.y0 *= fInvY;
                    this.y1 *= fInvY;
                    this.z0 *= fInvZ;
                    this.z1 *= fInvZ;
                }
                return this;
            };
            Rect3d.prototype.offset = function (fOffsetX, fOffsetY, fOffsetZ) {
                if (arguments.length === 1) {
                    var v3fOffset = arguments[0];
                    this.x0 += v3fOffset.x;
                    this.x1 += v3fOffset.x;
                    this.y0 += v3fOffset.y;
                    this.y1 += v3fOffset.y;
                    this.z0 += v3fOffset.z;
                    this.z1 += v3fOffset.z;
                } else {
                    this.x0 += arguments[0];
                    this.x1 += arguments[0];
                    this.y0 += arguments[1];
                    this.y1 += arguments[1];
                    this.z0 += arguments[2];
                    this.z1 += arguments[2];
                }
                return this;
            };
            Rect3d.prototype.expand = function (fValueX, fValueY, fValueZ) {
                if (arguments.length === 1) {
                    if ((typeof (arguments[0]) === "number")) {
                        var fValue = arguments[0];
                        this.x0 -= fValue;
                        this.x1 += fValue;
                        this.y0 -= fValue;
                        this.y1 += fValue;
                        this.z0 -= fValue;
                        this.z1 += fValue;
                    } else {
                        var v3fVec = arguments[0];
                        this.x0 -= v3fVec.x;
                        this.x1 += v3fVec.x;
                        this.y0 -= v3fVec.y;
                        this.y1 += v3fVec.y;
                        this.z0 -= v3fVec.z;
                        this.z1 += v3fVec.z;
                    }
                } else {
                    //arguments.length === 3
                    this.x0 -= arguments[0];
                    this.x1 += arguments[0];
                    this.y0 -= arguments[1];
                    this.y1 += arguments[1];
                    this.z0 -= arguments[2];
                    this.z1 += arguments[2];
                }
                return this;
            };
            Rect3d.prototype.expandX = /** @inline */function (fValue) {
                this.x0 -= fValue;
                this.x1 += fValue;
                return this;
            };
            Rect3d.prototype.expandY = /** @inline */function (fValue) {
                this.y0 -= fValue;
                this.y1 += fValue;
                return this;
            };
            Rect3d.prototype.expandZ = /** @inline */function (fValue) {
                this.z0 -= fValue;
                this.z1 += fValue;
                return this;
            };
            Rect3d.prototype.resize = function (fSizeX, fSizeY, fSizeZ) {
                var fSizeX, fSizeY, fSizeZ;
                if (arguments.length === 1) {
                    var v3fSize = arguments[0];
                    fSizeX = v3fSize.x;
                    fSizeY = v3fSize.y;
                    fSizeZ = v3fSize.z;
                } else {
                    fSizeX = arguments[0];
                    fSizeY = arguments[1];
                    fSizeZ = arguments[2];
                }
                this.x1 = (this.x0 + this.x1 + fSizeX) * 0.5;
                this.x0 = this.x1 - fSizeX;
                this.y1 = (this.y0 + this.y1 + fSizeY) * 0.5;
                this.y0 = this.y1 - fSizeY;
                this.z1 = (this.z0 + this.z1 + fSizeZ) * 0.5;
                this.z0 = this.z1 - fSizeZ;
                return this;
            };
            Rect3d.prototype.resizeX = /** @inline */function (fSize) {
                this.x1 = (this.x0 + this.x1 + fSize) * 0.5;
                this.x0 = this.x1 - fSize;
                return this;
            };
            Rect3d.prototype.resizeY = /** @inline */function (fSize) {
                this.y1 = (this.y0 + this.y1 + fSize) * 0.5;
                this.y0 = this.y1 - fSize;
                return this;
            };
            Rect3d.prototype.resizeZ = /** @inline */function (fSize) {
                this.z1 = (this.z0 + this.z1 + fSize) * 0.5;
                this.z0 = this.z1 - fSize;
                return this;
            };
            Rect3d.prototype.resizeMax = function (fSpanX, fSpanY, fSpanZ) {
                if (arguments.length === 1) {
                    var v3fSpan = arguments[0];
                    this.x1 = this.x0 + v3fSpan.x;
                    this.y1 = this.y0 + v3fSpan.y;
                    this.z1 = this.z0 + v3fSpan.z;
                } else {
                    //arguments.length === 3
                    this.x1 = this.x0 + arguments[0];
                    this.y1 = this.y0 + arguments[1];
                    this.z1 = this.z0 + arguments[2];
                }
                return this;
            };
            Rect3d.prototype.resizeMaxX = /** @inline */function (fSpan) {
                this.x1 = this.x0 + fSpan;
                return this;
            };
            Rect3d.prototype.resizeMaxY = /** @inline */function (fSpan) {
                this.y1 = this.y0 + fSpan;
                return this;
            };
            Rect3d.prototype.resizeMaxZ = /** @inline */function (fSpan) {
                this.z1 = this.z0 + fSpan;
                return this;
            };
            Rect3d.prototype.resizeMin = function (fSpanX, fSpanY, fSpanZ) {
                if (arguments.length === 1) {
                    var v3fSpan = arguments[0];
                    this.x0 = this.x1 - v3fSpan.x;
                    this.y0 = this.y1 - v3fSpan.y;
                    this.z0 = this.z1 - v3fSpan.z;
                } else {
                    //arguments.length === 3
                    this.x0 = this.x1 - arguments[0];
                    this.y0 = this.y1 - arguments[1];
                    this.z0 = this.z1 - arguments[2];
                }
                return this;
            };
            Rect3d.prototype.resizeMinX = /** @inline */function (fSpan) {
                this.x0 = this.x1 - fSpan;
                return this;
            };
            Rect3d.prototype.resizeMinY = /** @inline */function (fSpan) {
                this.y0 = this.y1 - fSpan;
                return this;
            };
            Rect3d.prototype.resizeMinZ = /** @inline */function (fSpan) {
                this.z0 = this.z1 - fSpan;
                return this;
            };
            Rect3d.prototype.unionPoint = function (fX, fY, fZ) {
                if (arguments.length === 1) {
                    var v3fPoint = arguments[0];
                    this.x0 = akra.math.min(this.x0, v3fPoint.x);
                    this.x1 = akra.math.max(this.x1, v3fPoint.x);
                    this.y0 = akra.math.min(this.y0, v3fPoint.y);
                    this.y1 = akra.math.max(this.y1, v3fPoint.y);
                    this.z0 = akra.math.min(this.z0, v3fPoint.z);
                    this.z1 = akra.math.max(this.z1, v3fPoint.z);
                } else {
                    //arguments.length === 3
                    this.x0 = akra.math.min(this.x0, arguments[0]);
                    this.x1 = akra.math.max(this.x1, arguments[0]);
                    this.y0 = akra.math.min(this.y0, arguments[1]);
                    this.y1 = akra.math.max(this.y1, arguments[1]);
                    this.z0 = akra.math.min(this.z0, arguments[2]);
                    this.z1 = akra.math.max(this.z1, arguments[2]);
                }
                return this;
            };
            Rect3d.prototype.unionRect = function (pRect) {
                this.normalize();
                pRect.normalize();
                this.x0 = akra.math.min(this.x0, pRect.x0);
                this.x1 = akra.math.max(this.x1, pRect.x1);
                this.y0 = akra.math.min(this.y0, pRect.y0);
                this.y1 = akra.math.max(this.y1, pRect.y1);
                this.z0 = akra.math.min(this.z0, pRect.z0);
                this.z1 = akra.math.max(this.z1, pRect.z1);
                return this;
            };
            Rect3d.prototype.negate = function (pDestination) {
                if (!((pDestination) !== undefined)) {
                    pDestination = this;
                }
                return pDestination.set(-this.x1, -this.x0, -this.y1, -this.y0, -this.z1, -this.z0);
            };
            Rect3d.prototype.normalize = function () {
                var fTmp;
                if (this.x0 > this.x1) {
                    fTmp = this.x0;
                    this.x0 = this.x1;
                    this.x1 = fTmp;
                }
                if (this.y0 > this.y1) {
                    fTmp = this.y0;
                    this.y0 = this.y1;
                    this.y1 = fTmp;
                }
                if (this.z0 > this.z1) {
                    fTmp = this.z0;
                    this.z0 = this.z1;
                    this.z1 = fTmp;
                }
                return this;
            };
            Rect3d.prototype.transform = function (m4fMatrix) {
                var pData = m4fMatrix.data;
                var a11 = pData[0], a12 = pData[4], a13 = pData[8], a14 = pData[12];
                var a21 = pData[1], a22 = pData[5], a23 = pData[9], a24 = pData[13];
                var a31 = pData[2], a32 = pData[6], a33 = pData[10], a34 = pData[14];
                var fX0 = this.x0, fX1 = this.x1;
                var fY0 = this.y0, fY1 = this.y1;
                var fZ0 = this.z0, fZ1 = this.z1;
                //base point
                var fBaseX = a11 * fX0 + a12 * fY0 + a13 * fZ0 + a14;
                var fBaseY = a21 * fX0 + a22 * fY0 + a23 * fZ0 + a24;
                var fBaseZ = a31 * fX0 + a32 * fY0 + a33 * fZ0 + a34;
                //new x vector
                var fXNewX = a11 * (fX1 - fX0);
                var fXNewY = a21 * (fX1 - fX0);
                var fXNewZ = a31 * (fX1 - fX0);
                //new y vector
                var fYNewX = a12 * (fY1 - fY0);
                var fYNewY = a22 * (fY1 - fY0);
                var fYNewZ = a32 * (fY1 - fY0);
                //new z vector
                var fZNewX = a13 * (fZ1 - fZ0);
                var fZNewY = a23 * (fZ1 - fZ0);
                var fZNewZ = a33 * (fZ1 - fZ0);
                var fXMultX = (fXNewX > 0.) ? 1. : 0.;
                var fYMultX = (fYNewX > 0.) ? 1. : 0.;
                var fZMultX = (fZNewX > 0.) ? 1. : 0.;
                var fXMultY = (fXNewY > 0.) ? 1. : 0.;
                var fYMultY = (fYNewY > 0.) ? 1. : 0.;
                var fZMultY = (fZNewY > 0.) ? 1. : 0.;
                var fXMultZ = (fXNewZ > 0.) ? 1. : 0.;
                var fYMultZ = (fYNewZ > 0.) ? 1. : 0.;
                var fZMultZ = (fZNewZ > 0.) ? 1. : 0.;
                this.x1 = fBaseX + fXMultX * fXNewX + fYMultX * fYNewX + fZMultX * fZNewX;
                this.y1 = fBaseY + fXMultY * fXNewY + fYMultY * fYNewY + fZMultY * fZNewY;
                this.z1 = fBaseZ + fXMultZ * fXNewZ + fYMultZ * fYNewZ + fZMultZ * fZNewZ;
                this.x0 = fBaseX + (1. - fXMultX) * fXNewX + (1. - fYMultX) * fYNewX + (1. - fZMultX) * fZNewX;
                this.y0 = fBaseY + (1. - fXMultY) * fXNewY + (1. - fYMultY) * fYNewY + (1. - fZMultY) * fZNewY;
                this.z0 = fBaseZ + (1. - fXMultZ) * fXNewZ + (1. - fYMultZ) * fYNewZ + (1. - fZMultZ) * fZNewZ;
                return this;
            };
            Rect3d.prototype.isEqual = /** @inline */function (pRect) {
                return this.x0 == pRect.x0 && this.x1 == pRect.x1 && this.y0 == pRect.y0 && this.y1 == pRect.y1 && this.z0 == pRect.z0 && this.z1 == pRect.z1;
            };
            Rect3d.prototype.isClear = /** @inline */function () {
                return this.x0 == 0. && this.x1 == 0. && this.y0 == 0. && this.y1 == 0. && this.z0 == 0. && this.z1 == 0.;
            };
            Rect3d.prototype.isValid = /** @inline */function () {
                return this.x0 <= this.x1 && this.y0 <= this.y1 && this.z0 <= this.z1;
            };
            Rect3d.prototype.isPointInRect = /** @inline */function (v3fPoint) {
                var x = v3fPoint.x;
                var y = v3fPoint.y;
                var z = v3fPoint.z;
                return (this.x0 <= x && x <= this.x1) && (this.y0 <= y && y <= this.y1) && (this.z0 <= z && z <= this.z1);
            };
            Rect3d.prototype.midPoint = function (v3fDestination) {
                if (!((v3fDestination) !== undefined)) {
                    v3fDestination = new akra.Vec3();
                }
                return v3fDestination.set((this.x0 + this.x1) * 0.5, (this.y0 + this.y1) * 0.5, (this.z0 + this.z1) * 0.5);
            };
            Rect3d.prototype.midX = /** @inline */function () {
                return (this.x0 + this.x1) * 0.5;
            };
            Rect3d.prototype.midY = /** @inline */function () {
                return (this.y0 + this.y1) * 0.5;
            };
            Rect3d.prototype.midZ = /** @inline */function () {
                return (this.z0 + this.z1) * 0.5;
            };
            Rect3d.prototype.size = function (v3fDestination) {
                if (!((v3fDestination) !== undefined)) {
                    v3fDestination = new akra.Vec3();
                }
                return v3fDestination.set(this.x1 - this.x0, this.y1 - this.y0, this.z1 - this.z0);
            };
            Rect3d.prototype.sizeX = /** @inline */function () {
                return this.x1 - this.x0;
            };
            Rect3d.prototype.sizeY = /** @inline */function () {
                return this.y1 - this.y0;
            };
            Rect3d.prototype.sizeZ = /** @inline */function () {
                return this.z1 - this.z0;
            };
            Rect3d.prototype.minPoint = function (v3fDestination) {
                if (!((v3fDestination) !== undefined)) {
                    v3fDestination = new akra.Vec3();
                }
                return v3fDestination.set(this.x0, this.y0, this.z0);
            };
            Rect3d.prototype.maxPoint = function (v3fDestination) {
                if (!((v3fDestination) !== undefined)) {
                    v3fDestination = new akra.Vec3();
                }
                return v3fDestination.set(this.x1, this.y1, this.z1);
            };
            Rect3d.prototype.volume = /** @inline */function () {
                return (this.x1 - this.x0) * (this.y1 - this.y0) * (this.z1 - this.z0);
            };
            Rect3d.prototype.corner = /**
            * counter-clockwise and from bottom
            * x0,y0,z0 -> x1,y0,z0 -> x1,y1,z0 -> x0,y1,z0 ->
            * x0,y0,z1 -> x1,y0,z1 -> x1,y1,z1 -> x0,y1,z1
            */
            function (iIndex, v3fDestination) {
                if (!((v3fDestination) !== undefined)) {
                    v3fDestination = new akra.Vec3();
                }
 {
                    akra.logger.setSourceLocation("geometry/Rect3d.ts", 752);
                    akra.logger.assert(0 <= iIndex && iIndex < 8, "invalid index");
                }
                ;
                switch(iIndex) {
                    case 0:
                        v3fDestination.set(this.x0, this.y0, this.z0);
                        break;
                    case 1:
                        v3fDestination.set(this.x1, this.y0, this.z0);
                        break;
                    case 2:
                        v3fDestination.set(this.x1, this.y1, this.z0);
                        break;
                    case 3:
                        v3fDestination.set(this.x0, this.y1, this.z0);
                        break;
                    case 4:
                        v3fDestination.set(this.x0, this.y0, this.z1);
                        break;
                    case 5:
                        v3fDestination.set(this.x1, this.y0, this.z1);
                        break;
                    case 6:
                        v3fDestination.set(this.x1, this.y1, this.z1);
                        break;
                    case 7:
                        v3fDestination.set(this.x0, this.y1, this.z1);
                        break;
                }
                return v3fDestination;
            };
            Rect3d.prototype.createBoundingSphere = function (pSphere) {
                if (!((pSphere) !== undefined)) {
                    pSphere = new geometry.Sphere();
                }
                var fX0 = this.x0, fX1 = this.x1;
                var fY0 = this.y0, fY1 = this.y1;
                var fZ0 = this.z0, fZ1 = this.z1;
                var fHalfSizeX = (fX1 - fX0) * 0.5;
                var fHalfSizeY = (fY1 - fY0) * 0.5;
                var fHalfSizeZ = (fZ1 - fZ0) * 0.5;
                pSphere.set((fX0 + fX1) * 0.5, (fY0 + fY1) * 0.5, (fZ0 + fZ1) * 0.5, akra.math.sqrt(fHalfSizeX * fHalfSizeX + fHalfSizeY * fHalfSizeY + fHalfSizeZ * fHalfSizeZ));
                return pSphere;
            };
            Rect3d.prototype.toString = function () {
                return "(" + this.x0 + ", " + this.y0 + ", " + this.z0 + ") --> (" + this.x1 + ", " + this.y1 + ", " + this.z1 + ")";
            };
            Object.defineProperty(Rect3d, "stackCeil", {
                get: function () {
                    Rect3d.stackPosition = Rect3d.stackPosition === Rect3d.stackSize - 1 ? 0 : Rect3d.stackPosition;
                    return Rect3d.stack[Rect3d.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            Rect3d.stackSize = 128;
            Rect3d.stackPosition = 0;
            Rect3d.stack = (function () {
                var pStack = new Array(Rect3d.stackSize);
                for(var i = 0; i < Rect3d.stackSize; i++) {
                    pStack[i] = new Rect3d();
                }
                return pStack;
            })();
            return Rect3d;
        })();
        geometry.Rect3d = Rect3d;        
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        (function (ESceneObjectFlags) {
            ESceneObjectFlags._map = [];
            ESceneObjectFlags.k_NewLocalBounds = 0;
            ESceneObjectFlags._map[1] = "k_NewWorldBounds";
            ESceneObjectFlags.k_NewWorldBounds = 1;
        })(scene.ESceneObjectFlags || (scene.ESceneObjectFlags = {}));
        var ESceneObjectFlags = scene.ESceneObjectFlags;
        ;
        var SceneObject = (function (_super) {
            __extends(SceneObject, _super);
            function SceneObject(pScene, eType) {
                if (typeof eType === "undefined") { eType = akra.EEntityTypes.SCENE_OBJECT; }
                        _super.call(this, pScene, eType);
                /**@protected*/ this._iObjectFlags = 0;
                /**@protected*/ this._pLocalBounds = new akra.geometry.Rect3d();
                /**@protected*/ this._pWorldBounds = new akra.geometry.Rect3d();
                /**@protected*/ this._hasShadow = false;
            }
            Object.defineProperty(SceneObject.prototype, "totalRenderable", {
                get: /** @inline */function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SceneObject.prototype, "worldBounds", {
                get: /** @inline */function () {
                    return this._pWorldBounds;
                },
                set: /** @inline */function (pBox) {
                    this._pWorldBounds = pBox;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SceneObject.prototype, "localBounds", {
                get: /** @inline */function () {
                    return this._pLocalBounds;
                },
                enumerable: true,
                configurable: true
            });
            SceneObject.prototype.getRenderable = function (i) {
                return null;
            };
            SceneObject.prototype.accessLocalBounds = function () {
                ((this._iObjectFlags) |= (1 << (ESceneObjectFlags.k_NewLocalBounds)));
                return this._pLocalBounds;
            };
            SceneObject.prototype.isWorldBoundsNew = /** @inline */function () {
                return ((this._iObjectFlags & (1 << (ESceneObjectFlags.k_NewLocalBounds))) != 0);
            };
            SceneObject.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
            };
            SceneObject.prototype.prepareForUpdate = function () {
                _super.prototype.prepareForUpdate.call(this);
                ((this._iObjectFlags) &= ~((1 << (ESceneObjectFlags.k_NewLocalBounds)) | (1 << (ESceneObjectFlags.k_NewWorldBounds))));
            };
            SceneObject.prototype.update = function () {
                //если, обновится мировая матрица узла, то и AABB обновится
                _super.prototype.update.call(this);
                // do we need to update our local matrix?
                // derived classes update the local matrix
                // then call this base function to complete
                // the update
                return this.recalcWorldBounds();
            };
            SceneObject.prototype.recalcWorldBounds = function () {
                // nodes only get their bounds updated
                // as nessesary
                if ((((this._iObjectFlags & (1 << (ESceneObjectFlags.k_NewLocalBounds))) != 0) || ((((this)._iUpdateFlags & (1 << (/*checked (origin: scene)>>*/akra.scene.ENodeUpdateFlags.k_NewWorldMatrix))) != 0)))) {
                    // transform our local rectangle
                    // by the current world matrix
                    this._pWorldBounds.set(this._pLocalBounds);
                    // make sure we have some degree of thickness
                    if (true) {
                        this._pWorldBounds.x1 = Math.max(this._pWorldBounds.x1, this._pWorldBounds.x0 + 0.01);
                        this._pWorldBounds.y1 = Math.max(this._pWorldBounds.y1, this._pWorldBounds.y0 + 0.01);
                        this._pWorldBounds.z1 = Math.max(this._pWorldBounds.z1, this._pWorldBounds.z0 + 0.01);
                    }
                    this._pWorldBounds.transform(((this)._m4fWorldMatrix));
                    // set the flag that our bounding box has changed
                    ((this._iObjectFlags) |= (1 << (ESceneObjectFlags.k_NewWorldBounds)));
                    this.worldBoundsUpdated();
                    return true;
                }
                return false;
            };
            Object.defineProperty(SceneObject.prototype, "hasShadow", {
                get: /** @inline */function () {
                    return this._hasShadow;
                },
                set: /** @inline */function (bValue) {
                    this._hasShadow = bValue;
                    for(var i = 0; i < (0); i++) {
                        (this.getRenderable(i)).hasShadow = bValue;
                    }
                },
                enumerable: true,
                configurable: true
            });
            SceneObject.prototype.getObjectFlags = function () {
                return this._iObjectFlags;
            };
            SceneObject.prototype.prepareForRender = /** @inline */function (pViewport) {
            };
            SceneObject.prototype.toString = function (isRecursive, iDepth) {
                if (typeof isRecursive === "undefined") { isRecursive = false; }
                if (typeof iDepth === "undefined") { iDepth = 0; }
                if (!isRecursive) {
                    return "<scene_object" + (this._sName ? " " + this._sName : "") + ">";
                }
                return _super.prototype.toString.call(this, isRecursive, iDepth);
            };
            SceneObject.prototype.worldBoundsUpdated = function () {
                var _recivier = this;
                this._pUnicastSlotMap = this._pUnicastSlotMap || ((/*checked (origin: util)>>*/akra.util.Entity._pEventTable)).findUnicastList(this._iGuid);
                var _unicast = (this._pUnicastSlotMap).worldBoundsUpdated;
                if (((_unicast) !== undefined)) {
                    _unicast.target ? _unicast.target[_unicast.callback](_recivier) : _unicast.listener(_recivier);
                }
            };
            return SceneObject;
        })(scene.SceneNode);
        scene.SceneObject = SceneObject;        
        /** @inline */function isSceneObject(pEntity) {
            return pEntity.type >= akra.EEntityTypes.SCENE_OBJECT && pEntity.type < akra.EEntityTypes.OBJECTS_LIMIT;
        }
        scene.isSceneObject = isSceneObject;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (geometry) {
        var Plane3d = (function () {
            function Plane3d(v3fPoint1, v3fPoint2, v3fPoint3) {
                this.normal = new akra.Vec3();
                this.distance = 0.;
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 2:
                        this.set(arguments[0], arguments[1]);
                        break;
                    case 3:
                        this.set(arguments[0], arguments[1], arguments[2]);
                        break;
                    default:
                        break;
                }
            }
            Plane3d.prototype.set = function () {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        var pPlane = arguments[0];
                        this.normal.set(pPlane.normal);
                        this.distance = pPlane.distance;
                        break;
                    case 2:
                        this.normal.set(arguments[0]);
                        this.distance = arguments[1];
                        break;
                    case 3:
                        var v3fPoint1 = arguments[0];
                        var v3fPoint2 = arguments[1];
                        var v3fPoint3 = arguments[2];
                        var x1 = v3fPoint2.x - v3fPoint1.x;
                        var y1 = v3fPoint2.y - v3fPoint1.y;
                        var z1 = v3fPoint2.z - v3fPoint1.z;
                        var x2 = v3fPoint3.x - v3fPoint1.x;
                        var y2 = v3fPoint3.y - v3fPoint1.y;
                        var z2 = v3fPoint3.z - v3fPoint1.z;
                        var x = y1 * z2 - y2 * z1;
                        var y = z1 * x2 - z2 * x1;
                        var z = x1 * y2 - x2 * y1;
                        this.distance = -(x * v3fPoint1.x + y * v3fPoint1.y + z * v3fPoint1.z);
                        this.normal.set(x, y, z);
                        break;
                    default:
                        this.normal.clear();
                        this.distance = 0.;
                        break;
                }
                return this.normalize();
            };
            Plane3d.prototype.clear = /** @inline */function () {
                this.normal.clear();
                this.distance = 0.;
                return this;
            };
            Plane3d.prototype.negate = /** @inline */function () {
                this.normal.negate();
                this.distance = -this.distance;
                return this;
            };
            Plane3d.prototype.normalize = function () {
                var v3fNormal = this.normal;
                var x = v3fNormal.x, y = v3fNormal.y, z = v3fNormal.z;
                var fLength = akra.math.sqrt(x * x + y * y + z * z);
                if (fLength !== 0.) {
                    var fInvLength = 1. / fLength;
                    v3fNormal.x = x * fInvLength;
                    v3fNormal.y = y * fInvLength;
                    v3fNormal.z = z * fInvLength;
                    this.distance *= fInvLength;
                }
                return this;
            };
            Plane3d.prototype.isEqual = function (pPlane) {
                return this.normal.isEqual(pPlane.normal) && (this.distance == pPlane.distance);
            };
            Plane3d.prototype.projectPointToPlane = /*предполагается работа только с нормализованной плоскостью*/
            function (v3fPoint, v3fDestination) {
                if (!((v3fDestination) !== undefined)) {
                    v3fDestination = new akra.Vec3();
                }
                var v3fNormal = this.normal;
                var fDistance = this.distance + v3fNormal.dot(v3fPoint);
                v3fDestination.x = v3fPoint.x - fDistance * v3fNormal.x;
                v3fDestination.y = v3fPoint.y - fDistance * v3fNormal.y;
                v3fDestination.z = v3fPoint.z - fDistance * v3fNormal.z;
                return v3fDestination;
            };
            Plane3d.prototype.solveForX = function (fY, fZ) {
                /*Ax+By+Cz+D=0;
                x = -(D+By+Cz)/A;*/
                var v3fNormal = this.normal;
                if (v3fNormal.x !== 0.) {
                    return -(this.distance + v3fNormal.y * fY + v3fNormal.z * fZ) / v3fNormal.x;
                }
                return 0.;
            };
            Plane3d.prototype.solveForY = function (fX, fZ) {
                /*Ax+By+Cz+D=0;
                y = -(D+Ax+Cz)/B;*/
                var v3fNormal = this.normal;
                if (v3fNormal.y !== 0.) {
                    return -(this.distance + v3fNormal.x * fX + v3fNormal.z * fZ) / v3fNormal.y;
                }
                return 0.;
            };
            Plane3d.prototype.solveForZ = function (fX, fY) {
                /*Ax+By+Cz+D=0;
                z = -(D+Ax+By)/C;*/
                var v3fNormal = this.normal;
                if (v3fNormal.z !== 0.) {
                    return -(this.distance + v3fNormal.x * fX + v3fNormal.y * fY) / v3fNormal.z;
                }
                return 0.;
            };
            Plane3d.prototype.signedDistance = function (v3fPoint) {
                return this.distance + this.normal.dot(v3fPoint);
            };
            Plane3d.prototype.toString = function () {
                return "normal: " + this.normal.toString() + "; distance: " + this.distance;
            };
            return Plane3d;
        })();
        geometry.Plane3d = Plane3d;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
;
var akra;
(function (akra) {
    (function (geometry) {
        var Plane2d = (function () {
            function Plane2d(v2fPoint1, v2fPoint2) {
                this.normal = new akra.Vec2();
                this.distance = 0.;
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 2:
                        this.set(arguments[0], arguments[1]);
                        break;
                    default:
                        break;
                }
            }
            Plane2d.prototype.set = function (v2fPoint1, v2fPoint2) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        var pPlane = arguments[0];
                        this.normal.set(pPlane.normal);
                        this.distance = pPlane.distance;
                        break;
                    case 2:
                        if ((typeof (arguments[1]) === "number")) {
                            this.normal.set(arguments[0]);
                            this.distance = arguments[1];
                        } else {
                            var v2fLine = akra.Vec2.stackCeil.set(arguments[1]).subtract(arguments[0]);
                            var v2fNormal = this.normal;
                            v2fNormal.set(-v2fLine.y, v2fLine.x);
                            this.distance = -v2fNormal.dot(arguments[0]);
                        }
                        break;
                    default:
                        this.normal.clear();
                        this.distance = 0.;
                        break;
                }
                return this.normalize();
            };
            Plane2d.prototype.clear = /** @inline */function () {
                this.normal.clear();
                this.distance = 0.;
                return this;
            };
            Plane2d.prototype.negate = /** @inline */function () {
                this.normal.negate();
                this.distance = -this.distance;
                return this;
            };
            Plane2d.prototype.normalize = function () {
                var v2fNormal = this.normal;
                var x = v2fNormal.x;
                var y = v2fNormal.y;
                var fLength = akra.math.sqrt(x * x + y * y);
                if (fLength !== 0.) {
                    var fInvLength = 1. / fLength;
                    v2fNormal.x = x * fInvLength;
                    v2fNormal.y = y * fInvLength;
                    this.distance = this.distance * fInvLength;
                }
                return this;
            };
            Plane2d.prototype.isEqual = /** @inline */function (pPlane) {
                return this.normal.isEqual(pPlane.normal) && (this.distance == pPlane.distance);
            };
            Plane2d.prototype.projectPointToPlane = /*предполагается работа только с нормализованной плоскостью*/
            function (v2fPoint, v2fDestination) {
                if (!((v2fDestination) !== undefined)) {
                    v2fDestination = new akra.Vec2();
                }
                var v2fNormal = this.normal;
                var fDistance = this.distance + v2fNormal.dot(v2fPoint);
                v2fDestination.x = v2fPoint.x - fDistance * v2fNormal.x;
                v2fDestination.y = v2fPoint.y - fDistance * v2fNormal.y;
                return v2fDestination;
            };
            Plane2d.prototype.solveForX = function (fY) {
                /*Ax+By+d=0;
                x=-(d+By)/A;*/
                var v2fNormal = this.normal;
                if (v2fNormal.x !== 0.) {
                    return -(this.distance + v2fNormal.y * fY) / v2fNormal.x;
                }
                return 0.;
            };
            Plane2d.prototype.solveForY = function (fX) {
                /*Ax+By+d=0;
                y=-(d+Ax)/B;*/
                var v2fNormal = this.normal;
                if (v2fNormal.y !== 0.) {
                    return -(this.distance + v2fNormal.x * fX) / v2fNormal.y;
                }
                return 0.;
            };
            Plane2d.prototype.signedDistance = /*предполагается работа только с нормализованной плоскостью*/
            /** @inline */function (v2fPoint) {
                return this.distance + this.normal.dot(v2fPoint);
            };
            Plane2d.prototype.toString = function () {
                return "normal: " + this.normal.toString() + "; distance: " + this.distance;
            };
            return Plane2d;
        })();
        geometry.Plane2d = Plane2d;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EVolumeClassifications) {
        EVolumeClassifications._map = [];
        EVolumeClassifications.NO_RELATION = 0;
        EVolumeClassifications._map[1] = "EQUAL";
        EVolumeClassifications.EQUAL = 1;
        EVolumeClassifications._map[2] = "A_CONTAINS_B";
        EVolumeClassifications.A_CONTAINS_B = 2;
        EVolumeClassifications._map[3] = "B_CONTAINS_A";
        EVolumeClassifications.B_CONTAINS_A = 3;
        EVolumeClassifications._map[4] = "INTERSECTING";
        EVolumeClassifications.INTERSECTING = 4;
    })(akra.EVolumeClassifications || (akra.EVolumeClassifications = {}));
    var EVolumeClassifications = akra.EVolumeClassifications;
    ;
    (function (EPlaneClassifications) {
        EPlaneClassifications._map = [];
        /**
        * ax+by+cz+d=0
        * PLANE_FRONT - объект находится перед плоскостью, то есть по направлению нормали
        * PLANE_BACK - объект находится за плостостью, то есть против направления нормали
        */
        EPlaneClassifications.PLANE_FRONT = 0;
        EPlaneClassifications._map[1] = "PLANE_BACK";
        EPlaneClassifications.PLANE_BACK = 1;
        EPlaneClassifications._map[2] = "PLANE_INTERSECT";
        EPlaneClassifications.PLANE_INTERSECT = 2;
    })(akra.EPlaneClassifications || (akra.EPlaneClassifications = {}));
    var EPlaneClassifications = akra.EPlaneClassifications;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (geometry) {
        function planeClassifyCircle(pPlane, pCircle) {
            var fDistance = pPlane.signedDistance(pCircle.center);
            var fRadius = pCircle.radius;
            if (fDistance > fRadius) {
                return akra.EPlaneClassifications.PLANE_FRONT;
            } else if (fDistance < -fRadius) {
                return akra.EPlaneClassifications.PLANE_BACK;
            } else {
                return akra.EPlaneClassifications.PLANE_INTERSECT;
            }
        }
        geometry.planeClassifyCircle = planeClassifyCircle;
        ;
        function planeClassifySphere(pPlane, pSphere) {
            var fDistance = pPlane.signedDistance(pSphere.center);
            var fRadius = pSphere.radius;
            if (fDistance > fRadius) {
                return akra.EPlaneClassifications.PLANE_FRONT;
            } else if (fDistance < -fRadius) {
                return akra.EPlaneClassifications.PLANE_BACK;
            } else {
                return akra.EPlaneClassifications.PLANE_INTERSECT;
            }
        }
        geometry.planeClassifySphere = planeClassifySphere;
        ;
        function planeClassifyRect2d(pPlane, pRect) {
            var v2fMinPoint = akra.Vec2.stackCeil.set();
            var v2fMaxPoint = akra.Vec2.stackCeil.set();
            var v2fNormal = pPlane.normal;
            if (v2fNormal.x > 0.) {
                v2fMinPoint.x = pRect.x0;
                v2fMaxPoint.x = pRect.x1;
            } else {
                v2fMinPoint.x = pRect.x1;
                v2fMaxPoint.x = pRect.x0;
            }
            if (v2fNormal.y > 0.) {
                v2fMinPoint.y = pRect.y0;
                v2fMaxPoint.y = pRect.y1;
            } else {
                v2fMinPoint.y = pRect.y1;
                v2fMaxPoint.y = pRect.y0;
            }
            var fMinDistance = pPlane.signedDistance(v2fMinPoint);
            var fMaxDistance = pPlane.signedDistance(v2fMaxPoint);
            if (fMinDistance * fMaxDistance <= 0.) {
                return akra.EPlaneClassifications.PLANE_INTERSECT;
            } else if (fMaxDistance < 0.) {
                return akra.EPlaneClassifications.PLANE_BACK;
            } else {
                return akra.EPlaneClassifications.PLANE_FRONT;
            }
        }
        geometry.planeClassifyRect2d = planeClassifyRect2d;
        ;
        function planeClassifyRect3d(pPlane, pRect) {
            var v3fMinPoint = akra.Vec3.stackCeil.set();
            var v3fMaxPoint = akra.Vec3.stackCeil.set();
            var v3fNormal = pPlane.normal;
            if (v3fNormal.x > 0.) {
                v3fMinPoint.x = pRect.x0;
                v3fMaxPoint.x = pRect.x1;
            } else {
                v3fMinPoint.x = pRect.x1;
                v3fMaxPoint.x = pRect.x0;
            }
            if (v3fNormal.y > 0.) {
                v3fMinPoint.y = pRect.y0;
                v3fMaxPoint.y = pRect.y1;
            } else {
                v3fMinPoint.y = pRect.y1;
                v3fMaxPoint.y = pRect.y0;
            }
            if (v3fNormal.z > 0.) {
                v3fMinPoint.z = pRect.z0;
                v3fMaxPoint.z = pRect.z1;
            } else {
                v3fMinPoint.z = pRect.z1;
                v3fMaxPoint.z = pRect.z0;
            }
            var fMinDistance = pPlane.signedDistance(v3fMinPoint);
            var fMaxDistance = pPlane.signedDistance(v3fMaxPoint);
            if (fMinDistance * fMaxDistance <= 0.) {
                return akra.EPlaneClassifications.PLANE_INTERSECT;
            } else if (fMaxDistance <= 0.) {
                return akra.EPlaneClassifications.PLANE_BACK;
            } else {
                return akra.EPlaneClassifications.PLANE_FRONT;
            }
        }
        geometry.planeClassifyRect3d = planeClassifyRect3d;
        ;
                                        function planeClassify(pPlane, pRect) {
            var pArg0 = arguments[0];
            var pArg1 = arguments[1];
            if (pArg0 instanceof geometry.Plane2d) {
                if (pArg1 instanceof geometry.Circle) {
                    return planeClassifyCircle(pArg0, pArg1);
                } else {
                    return planeClassifyRect2d(pArg0, pArg1);
                }
            } else {
                if (pArg1 instanceof geometry.Sphere) {
                    return planeClassifySphere(pArg0, pArg1);
                } else {
                    return planeClassifyRect3d(pArg0, pArg1);
                }
            }
        }
        geometry.planeClassify = planeClassify;
        ;
        function classifyRect2d(pRectA, pRectB) {
            var fRectAX0 = pRectA.x0, fRectAX1 = pRectA.x1;
            var fRectAY0 = pRectA.y0, fRectAY1 = pRectA.y1;
            var fRectBX0 = pRectB.x0, fRectBX1 = pRectB.x1;
            var fRectBY0 = pRectB.y0, fRectBY1 = pRectB.y1;
            if ((fRectAX1 < fRectBX0 || fRectBX1 < fRectAX0) || (fRectAY1 < fRectBY0 || fRectAY1 < fRectBY0)) {
                return akra.EVolumeClassifications.NO_RELATION;
            }
            if ((fRectAX0 == fRectBX0 && fRectAX1 == fRectBX1) && (fRectAY0 == fRectBY0 && fRectAY1 == fRectBY1)) {
                return akra.EVolumeClassifications.EQUAL;
            }
            if ((fRectAX0 <= fRectBX0 && fRectBX1 <= fRectAX1) && (fRectAY0 <= fRectBY0 && fRectBY1 <= fRectAY1)) {
                return akra.EVolumeClassifications.A_CONTAINS_B;
            }
            if ((fRectBX0 <= fRectAX0 && fRectAX1 <= fRectBX1) && (fRectBY0 <= fRectAY0 && fRectAY1 <= fRectBY1)) {
                return akra.EVolumeClassifications.B_CONTAINS_A;
            }
            return akra.EVolumeClassifications.INTERSECTING;
        }
        geometry.classifyRect2d = classifyRect2d;
        ;
        function classifyRect3d(pRectA, pRectB) {
            var fRectAX0 = pRectA.x0, fRectAX1 = pRectA.x1;
            var fRectAY0 = pRectA.y0, fRectAY1 = pRectA.y1;
            var fRectAZ0 = pRectA.z0, fRectAZ1 = pRectA.z1;
            var fRectBX0 = pRectB.x0, fRectBX1 = pRectB.x1;
            var fRectBY0 = pRectB.y0, fRectBY1 = pRectB.y1;
            var fRectBZ0 = pRectB.z0, fRectBZ1 = pRectB.z1;
            if ((fRectAX1 < fRectBX0 || fRectBX1 < fRectAX0) || (fRectAY1 < fRectBY0 || fRectAY1 < fRectBY0) || (fRectAZ1 < fRectBZ0 || fRectAZ1 < fRectBZ0)) {
                return akra.EVolumeClassifications.NO_RELATION;
            }
            if ((fRectAX0 == fRectBX0 && fRectAX1 == fRectBX1) && (fRectAY0 == fRectBY0 && fRectAY1 == fRectBY1) && (fRectAZ0 == fRectBZ0 && fRectAZ1 == fRectBZ1)) {
                return akra.EVolumeClassifications.EQUAL;
            }
            if ((fRectAX0 <= fRectBX0 && fRectBX1 <= fRectAX1) && (fRectAY0 <= fRectBY0 && fRectBY1 <= fRectAY1) && (fRectAZ0 <= fRectBZ0 && fRectBZ1 <= fRectAZ1)) {
                return akra.EVolumeClassifications.A_CONTAINS_B;
            }
            if ((fRectBX0 <= fRectAX0 && fRectAX1 <= fRectBX1) && (fRectBY0 <= fRectAY0 && fRectAY1 <= fRectBY1) && (fRectBZ0 <= fRectAZ0 && fRectAZ1 <= fRectBZ1)) {
                return akra.EVolumeClassifications.B_CONTAINS_A;
            }
            return akra.EVolumeClassifications.INTERSECTING;
        }
        geometry.classifyRect3d = classifyRect3d;
        ;
        function classifyFrustumRect3d(pFrustum, pRect) {
            var kClassification;
            var isIntersect = false;
            kClassification = planeClassifyRect3d(pFrustum.leftPlane, pRect);
            if (kClassification == akra.EPlaneClassifications.PLANE_FRONT) {
                return akra.EVolumeClassifications.NO_RELATION;
            } else if (kClassification == akra.EPlaneClassifications.PLANE_INTERSECT) {
                isIntersect = true;
            }
            kClassification = planeClassifyRect3d(pFrustum.rightPlane, pRect);
            if (kClassification == akra.EPlaneClassifications.PLANE_FRONT) {
                return akra.EVolumeClassifications.NO_RELATION;
            } else if (kClassification == akra.EPlaneClassifications.PLANE_INTERSECT) {
                isIntersect = true;
            }
            kClassification = planeClassifyRect3d(pFrustum.topPlane, pRect);
            if (kClassification == akra.EPlaneClassifications.PLANE_FRONT) {
                return akra.EVolumeClassifications.NO_RELATION;
            } else if (kClassification == akra.EPlaneClassifications.PLANE_INTERSECT) {
                isIntersect = true;
            }
            kClassification = planeClassifyRect3d(pFrustum.bottomPlane, pRect);
            if (kClassification == akra.EPlaneClassifications.PLANE_FRONT) {
                return akra.EVolumeClassifications.NO_RELATION;
            } else if (kClassification == akra.EPlaneClassifications.PLANE_INTERSECT) {
                isIntersect = true;
            }
            kClassification = planeClassifyRect3d(pFrustum.nearPlane, pRect);
            if (kClassification == akra.EPlaneClassifications.PLANE_FRONT) {
                return akra.EVolumeClassifications.NO_RELATION;
            } else if (kClassification == akra.EPlaneClassifications.PLANE_INTERSECT) {
                isIntersect = true;
            }
            kClassification = planeClassifyRect3d(pFrustum.farPlane, pRect);
            if (kClassification == akra.EPlaneClassifications.PLANE_FRONT) {
                return akra.EVolumeClassifications.NO_RELATION;
            } else if (kClassification == akra.EPlaneClassifications.PLANE_INTERSECT) {
                isIntersect = true;
            }
            if (isIntersect) {
                return akra.EVolumeClassifications.INTERSECTING;
            } else {
                return akra.EVolumeClassifications.A_CONTAINS_B;
            }
        }
        geometry.classifyFrustumRect3d = classifyFrustumRect3d;
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
;
var akra;
(function (akra) {
    (function (geometry) {
        var Frustum = (function () {
            function Frustum(pLeftPlane, pRightPlane, pTopPlane, pBottomPlane, pNearPlane, pFarPlane) {
                this._pFrustumVertices = null;
                this.leftPlane = new geometry.Plane3d();
                this.rightPlane = new geometry.Plane3d();
                this.topPlane = new geometry.Plane3d();
                this.bottomPlane = new geometry.Plane3d();
                this.nearPlane = new geometry.Plane3d();
                this.farPlane = new geometry.Plane3d();
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 6:
                        this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                        break;
                    default:
                        break;
                }
            }
            Object.defineProperty(Frustum.prototype, "frustumVertices", {
                get: /** @inline */function () {
                    return this._pFrustumVertices;
                },
                enumerable: true,
                configurable: true
            });
            Frustum.prototype.set = function (pLeftPlane, pRightPlane, pTopPlane, pBottomPlane, pNearPlane, pFarPlane) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        var pFrustum = arguments[0];
                        this.leftPlane.set(pFrustum.leftPlane);
                        this.rightPlane.set(pFrustum.rightPlane);
                        this.topPlane.set(pFrustum.topPlane);
                        this.bottomPlane.set(pFrustum.bottomPlane);
                        this.nearPlane.set(pFrustum.nearPlane);
                        this.farPlane.set(pFrustum.farPlane);
                        break;
                    case 6:
                        this.leftPlane.set(arguments[0]);
                        this.rightPlane.set(arguments[1]);
                        this.topPlane.set(arguments[2]);
                        this.bottomPlane.set(arguments[3]);
                        this.nearPlane.set(arguments[4]);
                        this.farPlane.set(arguments[5]);
                        break;
                    default:
                        this.leftPlane.clear();
                        this.rightPlane.clear();
                        this.topPlane.clear();
                        this.bottomPlane.clear();
                        this.nearPlane.clear();
                        this.farPlane.clear();
                        break;
                }
                return this;
            };
            Frustum.prototype.calculateFrustumVertices = function () {
                if (this._pFrustumVertices == null) {
                    this._pFrustumVertices = new Array(8);
                    for(var i = 0; i < 8; i++) {
                        this._pFrustumVertices[i] = new akra.Vec3();
                    }
                }
                var v3fLeftNormal = this.leftPlane.normal;
                var v3fRightNormal = this.rightPlane.normal;
                var v3fTopNormal = this.topPlane.normal;
                var v3fBottomNormal = this.bottomPlane.normal;
                var v3fNearNormal = this.nearPlane.normal;
                var v3fFarNormal = this.farPlane.normal;
                var fLeft = -this.leftPlane.distance;
                var fRight = -this.rightPlane.distance;
                var fTop = -this.topPlane.distance;
                var fBottom = -this.bottomPlane.distance;
                var fNear = -this.nearPlane.distance;
                var fFar = -this.farPlane.distance;
                var m3fTemp = akra.Mat3.stackCeil.set();
                var pFrustumVertices = this._pFrustumVertices;
                //first left-bottom-near
                pFrustumVertices[0].set(fLeft, fBottom, fNear);
                /*first colomn, not row*/
                m3fTemp.set(v3fLeftNormal.x, v3fBottomNormal.x, v3fNearNormal.x, v3fLeftNormal.y, v3fBottomNormal.y, v3fNearNormal.y, v3fLeftNormal.z, v3fBottomNormal.z, v3fNearNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[0]);
                //second right-bottom-near
                pFrustumVertices[1].set(fRight, fBottom, fNear);
                /*first colomn, not row*/
                m3fTemp.set(v3fRightNormal.x, v3fBottomNormal.x, v3fNearNormal.x, v3fRightNormal.y, v3fBottomNormal.y, v3fNearNormal.y, v3fRightNormal.z, v3fBottomNormal.z, v3fNearNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[1]);
                //third left-top-near
                pFrustumVertices[2].set(fLeft, fTop, fNear);
                /*first colomn, not row*/
                m3fTemp.set(v3fLeftNormal.x, v3fTopNormal.x, v3fNearNormal.x, v3fLeftNormal.y, v3fTopNormal.y, v3fNearNormal.y, v3fLeftNormal.z, v3fTopNormal.z, v3fNearNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[2]);
                //forth right-top-near
                pFrustumVertices[3].set(fRight, fTop, fNear);
                /*first colomn, not row*/
                m3fTemp.set(v3fRightNormal.x, v3fTopNormal.x, v3fNearNormal.x, v3fRightNormal.y, v3fTopNormal.y, v3fNearNormal.y, v3fRightNormal.z, v3fTopNormal.z, v3fNearNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[3]);
                //fifth left-bottom-far
                pFrustumVertices[4].set(fLeft, fBottom, fFar);
                /*first colomn, not row*/
                m3fTemp.set(v3fLeftNormal.x, v3fBottomNormal.x, v3fFarNormal.x, v3fLeftNormal.y, v3fBottomNormal.y, v3fFarNormal.y, v3fLeftNormal.z, v3fBottomNormal.z, v3fFarNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[4]);
                //sixth right-bottom-far
                pFrustumVertices[5].set(fRight, fBottom, fFar);
                /*first colomn, not row*/
                m3fTemp.set(v3fRightNormal.x, v3fBottomNormal.x, v3fFarNormal.x, v3fRightNormal.y, v3fBottomNormal.y, v3fFarNormal.y, v3fRightNormal.z, v3fBottomNormal.z, v3fFarNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[5]);
                //seventh left-top-far
                pFrustumVertices[6].set(fLeft, fTop, fFar);
                /*first colomn, not row*/
                m3fTemp.set(v3fLeftNormal.x, v3fTopNormal.x, v3fFarNormal.x, v3fLeftNormal.y, v3fTopNormal.y, v3fFarNormal.y, v3fLeftNormal.z, v3fTopNormal.z, v3fFarNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[6]);
                //eighth right-top-far
                pFrustumVertices[7].set(fRight, fTop, fFar);
                /*first colomn, not row*/
                m3fTemp.set(v3fRightNormal.x, v3fTopNormal.x, v3fFarNormal.x, v3fRightNormal.y, v3fTopNormal.y, v3fFarNormal.y, v3fRightNormal.z, v3fTopNormal.z, v3fFarNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[7]);
                return pFrustumVertices;
            };
            Frustum.prototype.extractFromMatrix = function (m4fProjection, m4fWorld, pSearchRect) {
                if (this._pFrustumVertices == null) {
                    this._pFrustumVertices = new Array(8);
                    for(var i = 0; i < 8; i++) {
                        this._pFrustumVertices[i] = new akra.Vec3();
                    }
                }
                var pFrustumVertices = this._pFrustumVertices;
                var v4fLeftBottomNear = akra.Vec4.stackCeil.set();
                var v4fRightBottomNear = akra.Vec4.stackCeil.set();
                var v4fLeftTopNear = akra.Vec4.stackCeil.set();
                var v4fRightTopNear = akra.Vec4.stackCeil.set();
                var v4fLeftBottomFar = akra.Vec4.stackCeil.set();
                var v4fRightBottomFar = akra.Vec4.stackCeil.set();
                var v4fLeftTopFar = akra.Vec4.stackCeil.set();
                var v4fRightTopFar = akra.Vec4.stackCeil.set();
                m4fProjection.unproj(akra.Vec3.stackCeil.set(-1, -1, -1), v4fLeftBottomNear);
                m4fProjection.unproj(akra.Vec3.stackCeil.set(1, -1, -1), v4fRightBottomNear);
                m4fProjection.unproj(akra.Vec3.stackCeil.set(-1, 1, -1), v4fLeftTopNear);
                m4fProjection.unproj(akra.Vec3.stackCeil.set(1, 1, -1), v4fRightTopNear);
                m4fProjection.unproj(akra.Vec3.stackCeil.set(-1, -1, 1), v4fLeftBottomFar);
                m4fProjection.unproj(akra.Vec3.stackCeil.set(1, -1, 1), v4fRightBottomFar);
                m4fProjection.unproj(akra.Vec3.stackCeil.set(-1, 1, 1), v4fLeftTopFar);
                m4fProjection.unproj(akra.Vec3.stackCeil.set(1, 1, 1), v4fRightTopFar);
                if (((m4fWorld) !== undefined)) {
                    m4fWorld.multiplyVec4(v4fLeftBottomNear);
                    m4fWorld.multiplyVec4(v4fRightBottomNear);
                    m4fWorld.multiplyVec4(v4fLeftTopNear);
                    m4fWorld.multiplyVec4(v4fRightTopNear);
                    m4fWorld.multiplyVec4(v4fLeftBottomFar);
                    m4fWorld.multiplyVec4(v4fRightBottomFar);
                    m4fWorld.multiplyVec4(v4fLeftTopFar);
                    m4fWorld.multiplyVec4(v4fRightTopFar);
                }
                var v3fLeftBottomNear = pFrustumVertices[0].set(v4fLeftBottomNear.xyz);
                var v3fRightBottomNear = pFrustumVertices[1].set(v4fRightBottomNear.xyz);
                var v3fLeftTopNear = pFrustumVertices[2].set(v4fLeftTopNear.xyz);
                var v3fRightTopNear = pFrustumVertices[3].set(v4fRightTopNear.xyz);
                var v3fLeftBottomFar = pFrustumVertices[4].set(v4fLeftBottomFar.xyz);
                var v3fRightBottomFar = pFrustumVertices[5].set(v4fRightBottomFar.xyz);
                var v3fLeftTopFar = pFrustumVertices[6].set(v4fLeftTopFar.xyz);
                var v3fRightTopFar = pFrustumVertices[7].set(v4fRightTopFar.xyz);
                //filling search rectangle
                if (((pSearchRect) !== undefined)) {
                    pSearchRect.set(v3fLeftBottomNear, v3fLeftBottomNear);
                    pSearchRect.unionPoint(v3fRightBottomNear);
                    pSearchRect.unionPoint(v3fLeftTopNear);
                    pSearchRect.unionPoint(v3fRightTopNear);
                    pSearchRect.unionPoint(v3fLeftBottomFar);
                    pSearchRect.unionPoint(v3fRightBottomFar);
                    pSearchRect.unionPoint(v3fLeftTopFar);
                    pSearchRect.unionPoint(v3fRightTopFar);
                }
                //calculating planes
                this.leftPlane.set(v3fLeftTopNear, v3fLeftTopFar, v3fLeftBottomNear);
                this.rightPlane.set(v3fRightBottomFar, v3fRightTopFar, v3fRightBottomNear);
                this.topPlane.set(v3fLeftTopNear, v3fRightTopNear, v3fLeftTopFar);
                this.bottomPlane.set(v3fRightBottomFar, v3fRightBottomNear, v3fLeftBottomFar);
                this.nearPlane.set(v3fLeftTopNear, v3fLeftBottomNear, v3fRightTopNear);
                this.farPlane.set(v3fRightBottomFar, v3fLeftBottomFar, v3fRightTopFar);
                return this;
            };
            Frustum.prototype.isEqual = /** @inline */function (pFrustum) {
                return (this.leftPlane.isEqual(pFrustum.leftPlane) && this.rightPlane.isEqual(pFrustum.rightPlane) && this.topPlane.isEqual(pFrustum.topPlane) && this.bottomPlane.isEqual(pFrustum.bottomPlane) && this.nearPlane.isEqual(pFrustum.nearPlane) && this.farPlane.isEqual(pFrustum.farPlane));
            };
            Frustum.prototype.getPlanePoints = //output - array of vertices in counterclockwise order (around plane normal as axis)
            //if destination don't submitted returned array from temp vectors
            function (sPlaneKey, pDestination) {
                if (arguments.length == 1) {
                    pDestination = [
                        akra.Vec3.stackCeil.set(), 
                        akra.Vec3.stackCeil.set(), 
                        akra.Vec3.stackCeil.set(), 
                        akra.Vec3.stackCeil.set()
                    ];
                }
                var pFrustumVertices = ((this)._pFrustumVertices);
                if (pFrustumVertices === null) {
                    pFrustumVertices = this.calculateFrustumVertices();
                }
                switch(sPlaneKey) {
                    case "leftPlane":
                        pDestination[0].set(pFrustumVertices[6]);
                        pDestination[1].set(pFrustumVertices[4]);
                        pDestination[2].set(pFrustumVertices[0]);
                        pDestination[3].set(pFrustumVertices[2]);
                        break;
                    case "rightPlane":
                        pDestination[0].set(pFrustumVertices[7]);
                        pDestination[1].set(pFrustumVertices[3]);
                        pDestination[2].set(pFrustumVertices[1]);
                        pDestination[3].set(pFrustumVertices[5]);
                        break;
                    case "topPlane":
                        pDestination[0].set(pFrustumVertices[7]);
                        pDestination[1].set(pFrustumVertices[6]);
                        pDestination[2].set(pFrustumVertices[2]);
                        pDestination[3].set(pFrustumVertices[3]);
                        break;
                    case "bottomPlane":
                        pDestination[0].set(pFrustumVertices[5]);
                        pDestination[1].set(pFrustumVertices[1]);
                        pDestination[2].set(pFrustumVertices[0]);
                        pDestination[3].set(pFrustumVertices[4]);
                        break;
                    case "nearPlane":
                        pDestination[0].set(pFrustumVertices[3]);
                        pDestination[1].set(pFrustumVertices[2]);
                        pDestination[2].set(pFrustumVertices[0]);
                        pDestination[3].set(pFrustumVertices[1]);
                        break;
                    case "farPlane":
                        pDestination[0].set(pFrustumVertices[7]);
                        pDestination[1].set(pFrustumVertices[5]);
                        pDestination[2].set(pFrustumVertices[4]);
                        pDestination[3].set(pFrustumVertices[6]);
                        break;
                    default:
 {
                            akra.logger.setSourceLocation("geometry/Frustum.ts", 324);
                            akra.logger.assert(false, "invalid plane key");
                        }
                        ;
                        break;
                }
                return pDestination;
            };
            Frustum.prototype.testPoint = function (v3fPoint) {
                if (this.leftPlane.signedDistance(v3fPoint) > 0. || this.rightPlane.signedDistance(v3fPoint) > 0. || this.topPlane.signedDistance(v3fPoint) > 0. || this.bottomPlane.signedDistance(v3fPoint) > 0. || this.nearPlane.signedDistance(v3fPoint) > 0. || this.farPlane.signedDistance(v3fPoint) > 0.) {
                    return false;
                }
                return true;
            };
            Frustum.prototype.testRect = function (pRect) {
                if (geometry.planeClassifyRect3d(this.leftPlane, pRect) == akra.EPlaneClassifications.PLANE_FRONT || geometry.planeClassifyRect3d(this.rightPlane, pRect) == akra.EPlaneClassifications.PLANE_FRONT || geometry.planeClassifyRect3d(this.topPlane, pRect) == akra.EPlaneClassifications.PLANE_FRONT || geometry.planeClassifyRect3d(this.bottomPlane, pRect) == akra.EPlaneClassifications.PLANE_FRONT || geometry.planeClassifyRect3d(this.nearPlane, pRect) == akra.EPlaneClassifications.PLANE_FRONT || geometry.planeClassifyRect3d(this.farPlane, pRect) == akra.EPlaneClassifications.PLANE_FRONT) {
                    return false;
                }
                return true;
            };
            Frustum.prototype.testSphere = function (pSphere) {
                if (geometry.planeClassifySphere(this.leftPlane, pSphere) == akra.EPlaneClassifications.PLANE_FRONT || geometry.planeClassifySphere(this.rightPlane, pSphere) == akra.EPlaneClassifications.PLANE_FRONT || geometry.planeClassifySphere(this.topPlane, pSphere) == akra.EPlaneClassifications.PLANE_FRONT || geometry.planeClassifySphere(this.bottomPlane, pSphere) == akra.EPlaneClassifications.PLANE_FRONT || geometry.planeClassifySphere(this.nearPlane, pSphere) == akra.EPlaneClassifications.PLANE_FRONT || geometry.planeClassifySphere(this.farPlane, pSphere) == akra.EPlaneClassifications.PLANE_FRONT) {
                    return false;
                }
                return true;
            };
            Frustum.prototype.testFrustum = function (pFrustum) {
                var pFrustumVertices1 = ((this)._pFrustumVertices);
                var pFrustumVertices2 = pFrustum.frustumVertices;
                if (pFrustumVertices1 == null) {
                    pFrustumVertices1 = this.calculateFrustumVertices();
                }
                if (pFrustumVertices2 == null) {
                    pFrustumVertices2 = pFrustum.calculateFrustumVertices();
                }
                var pFrustumPlanes = Frustum.frustumPlanesKeys;
                var nTest;
                for(var i = 0; i < 6; i++) {
                    var pPlane = this[pFrustumPlanes[i]];
                    nTest = 0;
                    for(var j = 0; j < 8; j++) {
                        if (pPlane.signedDistance(pFrustumVertices2[j]) > 0) {
                            nTest++;
                        }
                    }
                    if (nTest == 8) {
                        //frustums don't intersecting
                        return false;
                    }
                }
                //second batch of test for minimizing possible error
                for(var i = 0; i < 6; i++) {
                    var pPlane = pFrustum[pFrustumPlanes[i]];
                    nTest = 0;
                    for(var j = 0; j < 8; j++) {
                        if (pPlane.signedDistance(pFrustumVertices1[j]) > 0) {
                            nTest++;
                        }
                    }
                    if (nTest == 8) {
                        //frustums don't intersecting
                        return false;
                    }
                }
                return true;
            };
            Frustum.prototype.toString = function () {
                var sStr = "";
                for(var i = 0; i < 6; i++) {
                    var sKey = Frustum.frustumPlanesKeys[i];
                    sStr += sKey + ":\n";
                    sStr += this[sKey].toString() + "\n";
                }
                return sStr;
            };
            Frustum.frustumPlanesKeys = [
                "leftPlane", 
                "rightPlane", 
                "topPlane", 
                "bottomPlane", 
                "nearPlane", 
                "farPlane"
            ];
            return Frustum;
        })();
        geometry.Frustum = Frustum;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        (function (objects) {
            (function (ECameraFlags) {
                ECameraFlags._map = [];
                ECameraFlags.k_NewProjectionMatrix = 0;
                ECameraFlags._map[1] = "k_NewProjectionParams";
                ECameraFlags.k_NewProjectionParams = 1;
            })(objects.ECameraFlags || (objects.ECameraFlags = {}));
            var ECameraFlags = objects.ECameraFlags;
            var DLTechnique = (function () {
                function DLTechnique(pList, pCamera) {
                    this._pPrevResult = null;
                    this.list = pList;
                    this.camera = pCamera;
                }
                DLTechnique.prototype.findObjects = /** @inline */function (pResultArray, bQuickSearch) {
                    if (typeof bQuickSearch === "undefined") { bQuickSearch = false; }
                    var pResult = this.list._findObjects(this.camera, pResultArray, bQuickSearch && ((this._pPrevResult) != null));
                    if (((this._pPrevResult) === null)) {
                        this._pPrevResult = pResult;
                    }
                    return this._pPrevResult;
                };
                return DLTechnique;
            })();
            objects.DLTechnique = DLTechnique;            
            var Camera = (function (_super) {
                __extends(Camera, _super);
                function Camera(pScene, eType) {
                    if (typeof eType === "undefined") { eType = akra.EEntityTypes.CAMERA; }
                                _super.call(this, pScene, eType);
                    /** camera type */
                    /**@protected*/ this._eCameraType = akra.ECameraTypes.PERSPECTIVE;
                    /** camera options */
                    /**@protected*/ this._iCameraOptions = 0;
                    /** update projection bit flag */
                    /**@protected*/ this._iUpdateProjectionFlags = 0;
                    /**
                    * View matrix
                    */
                    /**@protected*/ this._m4fView = new akra.Mat4();
                    /** internal, un-biased projection matrix */
                    /**@protected*/ this._m4fProj = new akra.Mat4();
                    /** internal, un-biased projection+view matrix */
                    /**@protected*/ this._m4fProjView = new akra.Mat4();
                    /**
                    * Biased for use during current render stage
                    * @deprecated
                    */
                    //protected _m4fRenderStageProj: IMat4 = new Mat4;
                    /**
                    * @deprecated
                    */
                    //protected _m4fRenderStageProjView: IMat4 = new Mat4;
                    /** Search rect for scene culling */
                    /**@protected*/ this._pSearchRect = new akra.geometry.Rect3d();
                    /** Position */
                    /**@protected*/ this._v3fTargetPos = new akra.Vec3();
                    /** Attributes for projection matrix */
                    /**@protected*/ this._fFOV = akra.math.PI / 5.;
                    /**@protected*/ this._fAspect = 4. / 3.;
                    /**@protected*/ this._fNearPlane = 0.1;
                    /**@protected*/ this._fFarPlane = 500.;
                    /**@protected*/ this._fWidth = 0.;
                    /**@protected*/ this._fHeight = 0.;
                    /**@protected*/ this._fMinX = 0.;
                    /**@protected*/ this._fMaxX = 0.;
                    /**@protected*/ this._fMinY = 0.;
                    /**@protected*/ this._fMaxY = 0.;
                    /**@protected*/ this._pFrustum = new akra.geometry.Frustum();
                    /**@protected*/ this._pLastViewport = null;
                    /**@protected*/ this._pDLTechniques = [];
                    /**@protected*/ this._pDLResultStorage = [];
                }
                Object.defineProperty(Camera.prototype, "viewMatrix", {
                    get: // protected _pPrevObjects: ISceneNode[] = null;
                    // protected _p
                    /** @inline */function () {
                        return this._m4fView;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "projectionMatrix", {
                    get: /** @inline */function () {
                        return this._m4fProj;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "projViewMatrix", {
                    get: /** @inline */function () {
                        return this._m4fProjView;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "targetPos", {
                    get: /** @inline */function () {
                        return this._v3fTargetPos;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "fov", {
                    get: /** @inline */function () {
                        return this._fFOV;
                    },
                    set: /** @inline */function (fFOV) {
                        this._fFOV = fFOV;
                        ((this._iUpdateProjectionFlags) |= (1 << (ECameraFlags.k_NewProjectionParams)));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "aspect", {
                    get: /** @inline */function () {
                        return this._fAspect;
                    },
                    set: /** @inline */function (fAspect) {
                        this._fAspect = fAspect;
                        ((this._iUpdateProjectionFlags) |= (1 << (ECameraFlags.k_NewProjectionParams)));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "nearPlane", {
                    get: /** @inline */function () {
                        return this._fNearPlane;
                    },
                    set: /** @inline */function (fNearPlane) {
                        this._fNearPlane = fNearPlane;
                        ((this._iUpdateProjectionFlags) |= (1 << (ECameraFlags.k_NewProjectionParams)));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "farPlane", {
                    get: /** @inline */function () {
                        return this._fFarPlane;
                    },
                    set: /** @inline */function (fFarPlane) {
                        this._fFarPlane = fFarPlane;
                        ((this._iUpdateProjectionFlags) |= (1 << (ECameraFlags.k_NewProjectionParams)));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "viewDistance", {
                    get: /** @inline */function () {
                        return this._fFarPlane - this._fNearPlane;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "searchRect", {
                    get: /** @inline */function () {
                        return this._pSearchRect;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "frustum", {
                    get: /** @inline */function () {
                        return this._pFrustum;
                    },
                    enumerable: true,
                    configurable: true
                });
                Camera.prototype.create = function () {
                    var isOK = _super.prototype.create.call(this);
                    if (isOK) {
                        this._v3fTargetPos.set(this._m4fLocalMatrix.data[8], this._m4fLocalMatrix.data[9], this._m4fLocalMatrix.data[10]);
                        this._v3fTargetPos.negate();
                        this.recalcProjMatrix();
                        this.recalcMatrices();
                        var pScene = this._pScene;
                        ((pScene).getEventTable().addDestination(((((pScene)))._iGuid), ("displayListAdded"), (this), ("_addDisplayList"), (undefined)));
                        ((pScene).getEventTable().addDestination(((((pScene)))._iGuid), ("displayListRemoved"), (this), ("_removeDisplayList"), (undefined)));
                        for(var i = 0; i < pScene.totalDL; ++i) {
                            var pList = pScene.getDisplayList(i);
                            if (!((pList) === null)) {
                                this._addDisplayList(pScene, pList, i);
                            }
                        }
                    }
                    return isOK;
                };
                Camera.prototype.isProjParamsNew = /** @inline */function () {
                    return ((this._iUpdateProjectionFlags & (1 << (ECameraFlags.k_NewProjectionParams))) != 0);
                };
                Camera.prototype.recalcProjMatrix = function () {
                    //TODO: check proj matrix type --> this._eCameraType
                    //now, temrary, supported on perspective proj
                    this.setProjParams(this._fFOV, this._fAspect, this._fNearPlane, this._fFarPlane);
                    ((this._iUpdateProjectionFlags) &= ~(1 << (ECameraFlags.k_NewProjectionParams)));
                };
                Camera.prototype.prepareForUpdate = function () {
                    _super.prototype.prepareForUpdate.call(this);
                    //reset culling cache for all display lists
                    // for (var i: int = 0; i < this._pDLTechniques.length; ++ i) {
                    // 	if (this._pDLTechniques[i] != null) {
                    // 		this._pDLTechniques.reset();
                    // 	}
                    // }
                                    };
                Camera.prototype.display = /*DL_DEFAULT*/
                function (iList) {
                    if (typeof iList === "undefined") { iList = 0; }
                    var pObjects = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this._pDLTechniques[iList].findObjects(this._pDLResultStorage[iList], !(((((this)._iStateFlags) & (/*checked (origin: util)>>*/akra.util.EEntityStates.k_Updated)) == (/*checked (origin: util)>>*/akra.util.EEntityStates.k_Updated))));
                    return pObjects;
                };
                Camera.prototype._getLastResults = /** @inline */function (iList) {
                    if (typeof iList === "undefined") { iList = 0; }
                    return this._pDLResultStorage[iList] || null;
                };
                Camera.prototype.setParameter = function (eParam, pValue) {
                    if (eParam === akra.ECameraParameters.CONST_ASPECT && pValue) {
                        ((this._iCameraOptions) |= (eParam));
                    }
                };
                Camera.prototype.isConstantAspect = function () {
                    return (((this._iCameraOptions) & (akra.ECameraParameters.CONST_ASPECT)) != 0);
                };
                Camera.prototype.setProjParams = function (fFOV, fAspect, fNearPlane, fFarPlane) {
                    // Set attributes for the projection matrix
                    this._fFOV = fFOV;
                    this._fAspect = fAspect;
                    this._fNearPlane = fNearPlane;
                    this._fFarPlane = fFarPlane;
                    this._eCameraType = akra.ECameraTypes.PERSPECTIVE;
                    // create the regular projection matrix
                    /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/akra.Mat4.perspective(fFOV, fAspect, fNearPlane, fFarPlane, this._m4fProj);
                    // create a unit-space matrix
                    // for sky box geometry.
                    // this ensures that the
                    // near and far plane enclose
                    // the unit space around the camera
                    // Mat4.perspective(fFOV, fAspect, 0.01, 2.0, this._m4fUnitProj);
                    ((this._iUpdateProjectionFlags) |= (1 << (ECameraFlags.k_NewProjectionMatrix)));
                };
                Camera.prototype.setOrthoParams = function (fWidth, fHeight, fNearPlane, fFarPlane) {
                    this._fWidth = fWidth;
                    this._fHeight = fHeight;
                    this._fNearPlane = fNearPlane;
                    this._fFarPlane = fFarPlane;
                    this._eCameraType = akra.ECameraTypes.ORTHO;
                    // create the regular projection matrix
                    /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/akra.Mat4.orthogonalProjection(fWidth, fHeight, fNearPlane, fFarPlane, this._m4fProj);
                    // create a unit-space matrix
                    // for sky box geometry.
                    // this ensures that the
                    // near and far plane enclose
                    // the unit space around the camera
                    // Mat4.matrixOrthoRH(fWidth, fHeight, 0.01, 2.0, this._m4fUnitProj);
                    ((this._iUpdateProjectionFlags) |= (1 << (ECameraFlags.k_NewProjectionMatrix)));
                };
                Camera.prototype.setOffsetOrthoParams = function (fMinX, fMaxX, fMinY, fMaxY, fNearPlane, fFarPlane) {
                    this._fMinX = fMinX;
                    this._fMaxX = fMaxX;
                    this._fMinY = fMinY;
                    this._fMaxY = fMaxY;
                    this._fNearPlane = fNearPlane;
                    this._fFarPlane = fFarPlane;
                    this._eCameraType = akra.ECameraTypes.OFFSET_ORTHO;
                    // create the regular projection matrix
                    akra.Mat4.orthogonalProjectionAsymmetric(fMinX, fMaxX, fMinY, fMaxY, fNearPlane, fFarPlane, this._m4fProj);
                    // create a unit-space matrix
                    // for sky box geometry.
                    // this ensures that the
                    // near and far plane enclose
                    // the unit space around the camera
                    // Mat4.orthogonalProjectionorthogonalProjectionAsymmetric(fMinX, fMaxX, fMinY, fMaxY,
                    //                             0.01, 2.0, this._m4fUnitProj);
                    ((this._iUpdateProjectionFlags) |= (1 << (ECameraFlags.k_NewProjectionMatrix)));
                };
                Camera.prototype.recalcMatrices = function () {
                    this._v3fTargetPos.set(this._m4fLocalMatrix.data[8], this._m4fLocalMatrix.data[9], this._m4fLocalMatrix.data[10]);
                    this._v3fTargetPos.negate();
                    // the camera view matrix is the
                    // inverse of the world matrix
                    this._m4fView.set(this.inverseWorldMatrix);
                    // sky boxes use the inverse
                    // world matrix of the camera (the
                    // camera view matrix) without
                    // any translation information.
                    //this.m4fSkyBox.set(this.m4fView);
                    // this.m4fSkyBox.data[__14] = 0.0;
                    // this.m4fSkyBox.data[__24] = 0.0;
                    // this.m4fSkyBox.data[__34] = 0.0;
                    // this is combined with the unit
                    // space projection matrix to form
                    // the sky box viewing matrix
                    //this.m4fSkyBox.multiply(this.m4fUnitProj, this.m4fSkyBox);
                    // billboard objects use our world matrix
                    // without translation
                    // this.m4fBillboard.set(this.worldMatrix());
                    // this.m4fBillboard.data[__14] = 0.0;
                    // this.m4fBillboard.data[__24] = 0.0;
                    // this.m4fBillboard.data[__34] = 0.0;
                                    };
                Camera.prototype.update = function () {
                    var isUpdated = _super.prototype.update.call(this);
                    if (((((this)._iUpdateProjectionFlags & (1 << (ECameraFlags.k_NewProjectionParams))) != 0))) {
                        this.recalcProjMatrix();
                    }
                    if (((((this)._iUpdateFlags & (1 << (/*checked (origin: scene)>>*/akra.scene.ENodeUpdateFlags.k_NewWorldMatrix))) != 0)) || ((this._iUpdateProjectionFlags & (1 << (ECameraFlags.k_NewProjectionMatrix))) != 0)) {
                        this._pFrustum.extractFromMatrix(this._m4fProj, this._m4fWorldMatrix, this._pSearchRect);
                        // this._m4fRenderStageProj.set(this._m4fProj);
                        if (((((this)._iUpdateFlags & (1 << (/*checked (origin: scene)>>*/akra.scene.ENodeUpdateFlags.k_NewWorldMatrix))) != 0))) {
                            this.recalcMatrices();
                        }
                        // our projView matrix is the projection
                        //matrix multiplied by the inverse of our world matrix
                        this._m4fProj.multiply(this._m4fView, this._m4fProjView);
                        isUpdated = true;
                        ((this._iUpdateProjectionFlags) &= ~(1 << (ECameraFlags.k_NewProjectionMatrix)));
                    }
                    return isUpdated;
                };
                Camera.prototype._renderScene = // applyRenderStageBias(iStage: int): void {
                //    	var fZ_bias = iStage > 1 ? 0.001 : 0.0;
                //     this._m4fRenderStageProj.set(this._m4fProj);
                //     this._m4fRenderStageProjView.set(this._m4fProjView);
                //     this._m4fRenderStageProj[__34] -= fZ_bias;
                //     this._m4fRenderStageProjView[__34] -= fZ_bias;
                //    }
                function (pViewport) {
                    //update the pixel display ratio
                    // if (this._eCameraType == ECameraTypes.PERSPECTIVE) {
                    // 	mPixelDisplayRatio = (2. * math.tan(this._fFOV * 0.5)) / pViewport.actualHeight;
                    // }
                    // else {
                    // 	mPixelDisplayRatio = (mTop - mBottom) / vp->getActualHeight();
                    // }
                    //notify prerender scene
                    this.preRenderScene();
                    pViewport.update();
                    //notify postrender scene
                    this.postRenderScene();
                };
                Camera.prototype._keepLastViewport = function (pViewport) {
                    this._pLastViewport = pViewport;
                };
                Camera.prototype._getLastViewport = function () {
                    return this._pLastViewport;
                };
                Camera.prototype._getNumRenderedFaces = function () {
                    return 0;
                };
                Camera.prototype._notifyRenderedFaces = function (nFaces) {
                };
                Camera.prototype.isActive = /** @inline */function () {
                    return this._pLastViewport && this._pLastViewport.getCamera() === this;
                };
                Camera.prototype.toString = function (isRecursive, iDepth) {
                    if (typeof isRecursive === "undefined") { isRecursive = false; }
                    if (typeof iDepth === "undefined") { iDepth = 0; }
                    if (!isRecursive) {
                        return "<camera" + (this._sName ? " " + this._sName : "") + ">";
                    }
                    return _super.prototype.toString.call(this, isRecursive, iDepth);
                };
                Camera.prototype.projectPoint = function (v3fPoint, v3fDestination) {
                    if (!((v3fDestination) !== undefined)) {
                        v3fDestination = v3fPoint;
                    }
                    var m4fView = ((this)._m4fView);
                    var m4fProj = ((this)._m4fProj);
                    var v4fTmp = akra.Vec4.stackCeil.set(v3fPoint, 1.);
                    v4fTmp = m4fProj.multiplyVec4(m4fView.multiplyVec4(v4fTmp));
                    if (v4fTmp.w <= 0.) {
                        return null;
                    }
                    v3fDestination.set((v4fTmp.scale(1. / v4fTmp.w)).xyz);
                    var fX = akra.math.abs(v3fDestination.x);
                    var fY = akra.math.abs(v3fDestination.y);
                    var fZ = akra.math.abs(v3fDestination.z);
                    if (fX > 1 || fY > 1 || fZ > 1) {
                        return null;
                    }
                    return v3fDestination;
                };
                Camera.prototype.getDepthRange = function () {
                    var pDepthRange = this._pLastViewport.getDepthRange();
                    var zNear = this._m4fProj.unprojZ(pDepthRange.min);
                    var zFar = this._m4fProj.unprojZ(pDepthRange.max);
                    return {
                        min: zNear,
                        max: zFar
                    };
                };
                Camera.prototype._addDisplayList = function (pScene, pList, index) {
                    this._pDLTechniques[index] = new DLTechnique(pList, this);
                    this._pDLResultStorage[index] = new akra.util.ObjectArray();
                };
                Camera.prototype._removeDisplayList = function (pScene, pList, index) {
                    this._pDLTechniques[index] = null;
                    this._pDLResultStorage[index] = null;
                };
                Camera.prototype.preRenderScene = function () {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || (((((/*checked (origin: util)>>*/akra.util.Entity._pEventTable))).broadcast[(this._iGuid)] = (((/*checked (origin: util)>>*/akra.util.Entity._pEventTable))).broadcast[(this._iGuid)] || {}));
                    var _broadcast = (this._pBroadcastSlotList).preRenderScene;
                    var _recivier = this;
                    if (((_broadcast) !== undefined)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                Camera.prototype.postRenderScene = function () {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || (((((/*checked (origin: util)>>*/akra.util.Entity._pEventTable))).broadcast[(this._iGuid)] = (((/*checked (origin: util)>>*/akra.util.Entity._pEventTable))).broadcast[(this._iGuid)] || {}));
                    var _broadcast = (this._pBroadcastSlotList).postRenderScene;
                    var _recivier = this;
                    if (((_broadcast) !== undefined)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                return Camera;
            })(scene.SceneNode);
            objects.Camera = Camera;            
            /** @inline */function isCamera(pNode) {
                return pNode.type >= akra.EEntityTypes.CAMERA && pNode.type <= akra.EEntityTypes.SHADOW_CASTER;
            }
            objects.isCamera = isCamera;
        })(scene.objects || (scene.objects = {}));
        var objects = scene.objects;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        (function (light) {
            var ShadowCaster = (function (_super) {
                __extends(ShadowCaster, _super);
                function ShadowCaster(pLightPoint, iFace) {
                    if (typeof iFace === "undefined") { iFace = akra.ECubeFace.POSITIVE_X; }
                                _super.call(this, pLightPoint.scene, akra.EEntityTypes.SHADOW_CASTER);
                    /**@protected*/ this._pLightPoint = null;
                    /**@protected*/ this._iFace = 0;
                    /**@protected*/ this._pAffectedObjects = new akra.util.ObjectArray();
                    /**@protected*/ this._m4fOptimizedProj = new akra.Mat4();
                    /**@protected*/ this._isShadowCasted = false;
                    this._pLightPoint = pLightPoint;
                    this._iFace = iFace;
                }
                Object.defineProperty(ShadowCaster.prototype, "lightPoint", {
                    get: /** @inline */function () {
                        return this._pLightPoint;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ShadowCaster.prototype, "face", {
                    get: /** @inline */function () {
                        return this._iFace;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ShadowCaster.prototype, "affectedObjects", {
                    get: /** @inline */function () {
                        return this._pAffectedObjects;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ShadowCaster.prototype, "optimizedProjection", {
                    get: /** @inline */function () {
                        return this._m4fOptimizedProj;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ShadowCaster.prototype, "isShadowCasted", {
                    get: /** @inline */function () {
                        return this._isShadowCasted;
                    },
                    set: /** @inline */function (isShadowCasted) {
                        this._isShadowCasted = isShadowCasted;
                    },
                    enumerable: true,
                    configurable: true
                });
                ShadowCaster.prototype._optimizeProjectionMatrix = function (pEffectiveCameraFrustum) {
                    if (this._pAffectedObjects.length == 0) {
                        this._m4fOptimizedProj.set(((this)._m4fProj));
                        return;
                    }
                    var m4fView = ((this)._m4fView);
                    var m4fProj = ((this)._m4fProj);
                    var m4fProjData = m4fProj.data;
                    var pBox = akra.geometry.Rect3d.stackCeil.set();
                    var pAffectedObjects = this._pAffectedObjects;
                    var fX0, fX1, fY0, fY1, fZ0, fZ1;
                    var fX, fY, fZ, fW;
                    var fX_Left, fY_Bottom;
                    var fX_Right, fY_Top;
                    var fZ_Near, fZ_Far;
                    //первый бокс должен быть, либо построен по первому элементу, что приводит к усложнению функции
                    //либо записан таким образом (то есть минимально (максимально) возможные значения), тогда можно просто все делать в цикле
                                        var fXRes_Left = 1., fXRes_Right = -1, fYRes_Bottom = 1, fYRes_Top = -1, fZRes_Near = 1, fZRes_Far = -1;
                    var fTmp;
                    for(var i = 0; i < pAffectedObjects.length; i++) {
                        var pObject = pAffectedObjects.value(i);
                        if (!pObject.hasShadow) {
                            continue;
                        }
                        pBox.set(pObject.worldBounds);
                        pBox.transform(m4fView);
                        fX0 = pBox.x0;
                        fX1 = pBox.x1;
                        fY0 = pBox.y0;
                        fY1 = pBox.y1;
                        fZ0 = pBox.z0;
                        fZ1 = pBox.z1;
                        //z - отрицательное => ближняя к камере грань fZ1, а fZ0 - дальняя
                        //left bottom near
                        fX = m4fProjData[0] * fX0 + m4fProjData[4] * fY0 + m4fProjData[8] * fZ1 + m4fProjData[12];
                        fY = m4fProjData[1] * fX0 + m4fProjData[5] * fY0 + m4fProjData[9] * fZ1 + m4fProjData[13];
                        fZ = m4fProjData[2] * fX0 + m4fProjData[6] * fY0 + m4fProjData[10] * fZ1 + m4fProjData[14];
                        fW = m4fProjData[3] * fX0 + m4fProjData[7] * fY0 + m4fProjData[11] * fZ1 + m4fProjData[15];
                        if (fW <= 0) {
                            //обходим особые случаи
                            fX = -1;
                            fY = -1;
                            fZ = -1;
                            fW = 1;
                        }
                        fX_Left = fX / fW;
                        fY_Bottom = fY / fW;
                        ////////////////////////////////
                        //z near
                        fZ_Near = fZ / fW;
                        ////////////////////////////////
                        //left bottom far
                        fX = m4fProjData[0] * fX0 + m4fProjData[4] * fY0 + m4fProjData[8] * fZ0 + m4fProjData[12];
                        fY = m4fProjData[1] * fX0 + m4fProjData[5] * fY0 + m4fProjData[9] * fZ0 + m4fProjData[13];
                        fZ = m4fProjData[2] * fX0 + m4fProjData[6] * fY0 + m4fProjData[10] * fZ0 + m4fProjData[14];
                        fW = m4fProjData[3] * fX0 + m4fProjData[7] * fY0 + m4fProjData[11] * fZ0 + m4fProjData[15];
                        //в этой части особенностей нет, так как w всегда больше нуля, иначе объект будет вне frustum-а
                        fTmp = fX / fW;
                        fX_Left = (fTmp < fX_Left) ? fTmp : fX_Left;
                        fTmp = fY / fW;
                        fY_Bottom = (fTmp < fY_Bottom) ? fTmp : fY_Bottom;
                        ////////////////////////////////
                        //z far
                        fZ_Far = fZ / fW;
                        ////////////////////////////////
                        //right top near
                        fX = m4fProjData[0] * fX1 + m4fProjData[4] * fY1 + m4fProjData[8] * fZ1 + m4fProjData[12];
                        fY = m4fProjData[1] * fX1 + m4fProjData[5] * fY1 + m4fProjData[9] * fZ1 + m4fProjData[13];
                        fW = m4fProjData[3] * fX1 + m4fProjData[7] * fY1 + m4fProjData[11] * fZ1 + m4fProjData[15];
                        if (fW <= 0) {
                            //обходим особые случаи
                            fX = 1;
                            fY = 1;
                            fW = 1;
                        }
                        fX_Right = fX / fW;
                        fY_Top = fY / fW;
                        //right top far
                        fX = m4fProjData[0] * fX1 + m4fProjData[4] * fY1 + m4fProjData[8] * fZ0 + m4fProjData[12];
                        fY = m4fProjData[1] * fX1 + m4fProjData[5] * fY1 + m4fProjData[9] * fZ0 + m4fProjData[13];
                        fW = m4fProjData[3] * fX1 + m4fProjData[7] * fY1 + m4fProjData[11] * fZ0 + m4fProjData[15];
                        //в этой части особенностей нет, так как w всегда больше нуля, иначе объект будет вне frustum-а
                        fTmp = fX / fW;
                        fX_Right = (fTmp > fX_Right) ? fTmp : fX_Right;
                        fTmp = fY / fW;
                        fY_Top = (fTmp > fY_Top) ? fTmp : fY_Top;
                        ////////////////////////////////
                        fXRes_Left = (fX_Left < fXRes_Left) ? fX_Left : fXRes_Left;
                        fXRes_Right = (fX_Right > fXRes_Right) ? fX_Right : fXRes_Right;
                        fYRes_Bottom = (fY_Bottom < fYRes_Bottom) ? fY_Bottom : fYRes_Bottom;
                        fYRes_Top = (fY_Top > fYRes_Top) ? fY_Top : fYRes_Top;
                        fZRes_Near = (fZ_Near < fZRes_Near) ? fZ_Near : fZRes_Near;
                        fZRes_Far = (fZ_Far > fZRes_Far) ? fZ_Far : fZRes_Far;
                    }
                    //test with camera frustum
                    var pCameraBox = this._getBoxForCameraFrustum(pEffectiveCameraFrustum, new akra.geometry.Rect2d());
                    var fCameraMinX = akra.math.max(pCameraBox.x0, -1);
                    var fCameraMaxX = akra.math.min(pCameraBox.x1, 1);
                    var fCameraMinY = akra.math.max(pCameraBox.y0, -1);
                    var fCameraMaxY = akra.math.min(pCameraBox.y1, 1);
                    fXRes_Left = akra.math.max((fXRes_Left < -1 || fXRes_Left == 1) ? -1 : fXRes_Left, fCameraMinX);
                    fXRes_Right = akra.math.min((fXRes_Right > 1 || fXRes_Right == -1) ? 1 : fXRes_Right, fCameraMaxX);
                    fYRes_Bottom = akra.math.max((fYRes_Bottom < -1 || fYRes_Bottom == 1) ? -1 : fYRes_Bottom, fCameraMinY);
                    fYRes_Top = akra.math.min((fYRes_Top > 1 || fYRes_Top == -1) ? 1 : fYRes_Top, fCameraMaxY);
                    fZRes_Near = (fZRes_Near < -1 || fZRes_Near == 1) ? -1 : fZRes_Near;
                    fZRes_Far = (fZRes_Far > 1 || fZRes_Far == -1) ? 1 : fZRes_Far;
                    //optimized parameters
                    var v4fTmp1 = m4fProj.unproj(akra.Vec3.stackCeil.set(fXRes_Left, fYRes_Bottom, fZRes_Near), akra.Vec4.stackCeil.set());
                    var v4fTmp2 = m4fProj.unproj(akra.Vec3.stackCeil.set(fXRes_Right, fYRes_Top, fZRes_Near), akra.Vec4.stackCeil.set());
                    //////////////////////////
                    fX_Left = v4fTmp1.x;
                    fX_Right = v4fTmp2.x;
                    fY_Bottom = v4fTmp1.y;
                    fY_Top = v4fTmp2.y;
                    fZ_Near = v4fTmp1.z;
                    fZ_Far = m4fProj.unprojZ(fZRes_Far);
                    if (m4fProj.isOrthogonalProjection()) {
                        //ortho-projection
                        akra.Mat4.orthogonalProjectionAsymmetric(fX_Left, fX_Right, fY_Bottom, fY_Top, -fZ_Near, -fZ_Far, this._m4fOptimizedProj);
                    } else {
                        //frustum
                        akra.Mat4.frustum(fX_Left, fX_Right, fY_Bottom, fY_Top, -fZ_Near, -fZ_Far, this._m4fOptimizedProj);
                    }
                };
                ShadowCaster.prototype._getBoxForCameraFrustum = /**@protected*/ function (pEffectiveCameraFrustum, pDestination) {
                    if (!((pDestination) !== undefined)) {
                        pDestination = new akra.geometry.Rect2d();
                    }
                    var m4fProjView = ((this)._m4fProjView);
                    var pFrusutumVertices = pEffectiveCameraFrustum.frustumVertices;
                    var v4fTmp = akra.Vec4.stackCeil.set();
                    var v2fTmp = akra.Vec2.stackCeil.set();
                    for(var i = 0; i < 8; i++) {
                        v4fTmp.set(pFrusutumVertices[i], 1.);
                        m4fProjView.multiplyVec4(v4fTmp);
                        v2fTmp.set(v4fTmp.x, v4fTmp.y).scale(akra.math.abs(1. / v4fTmp.w));
                        if (i == 0) {
                            pDestination.set(v2fTmp, v2fTmp);
                        } else {
                            pDestination.unionPoint(v2fTmp);
                        }
                    }
                    return pDestination;
                };
                return ShadowCaster;
            })(scene.objects.Camera);
            light.ShadowCaster = ShadowCaster;            
            function isShadowCaster(pEntity) {
                return !((pEntity) === null) && pEntity.type === akra.EEntityTypes.SHADOW_CASTER;
            }
            light.isShadowCaster = isShadowCaster;
        })(scene.light || (scene.light = {}));
        var light = scene.light;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        var ShadowViewport = (function (_super) {
            __extends(ShadowViewport, _super);
            function ShadowViewport(pCamera, pTarget, csRenderMethod, fLeft, fTop, fWidth, fHeight, iZIndex) {
                if (typeof csRenderMethod === "undefined") { csRenderMethod = null; }
                if (typeof fLeft === "undefined") { fLeft = 0.; }
                if (typeof fTop === "undefined") { fTop = 0.; }
                if (typeof fWidth === "undefined") { fWidth = 1.; }
                if (typeof fHeight === "undefined") { fHeight = 1.; }
                if (typeof iZIndex === "undefined") { iZIndex = 0; }
                        _super.call(this, pCamera, pTarget, ".prepare-shadows", fLeft, fTop, fWidth, fHeight, iZIndex);
                this.setClearEveryFrame(true, akra.EFrameBufferTypes.DEPTH);
                this.setDepthParams(true, true, akra.ECompareFunction.LESS);
                ((this)._pViewportState.clearDepth = (1.));
            }
            Object.defineProperty(ShadowViewport.prototype, "type", {
                get: /** @inline */function () {
                    return akra.EViewportTypes.SHADOWVIEWPORT;
                },
                enumerable: true,
                configurable: true
            });
            ShadowViewport.prototype._updateImpl = function () {
                // LOG("SAHDOW VIEWPORT #" + this.getGuid());
                var pShadowCaster = this._pCamera;
                var pAffectedObjects = pShadowCaster.affectedObjects;
                var pRenderable;
                var pSceneObject;
                var nShadowsCasted = 0;
                for(var i = 0; i < pAffectedObjects.length; i++) {
                    pSceneObject = pAffectedObjects.value(i);
                    if (pSceneObject.hasShadow) {
                        for(var j = 0; j < pSceneObject.totalRenderable; j++) {
                            pRenderable = pSceneObject.getRenderable(j);
                            if (!((pRenderable) === null) && pRenderable.hasShadow) {
                                this.prepareRenderableForShadows(pRenderable);
                                pRenderable.render(this, this._csDefaultRenderMethod, pSceneObject);
                                nShadowsCasted++;
                            }
                        }
                    }
                }
                pShadowCaster.isShadowCasted = (nShadowsCasted > 0) ? true : false;
            };
            ShadowViewport.prototype.prepareRenderableForShadows = function (pRenderable) {
                var pRenderTechnique = pRenderable.getTechnique(this._csDefaultRenderMethod);
                if (!((pRenderTechnique) === null)) {
                    return;
                }
                var pRmgr = ((this)._pTarget).getRenderer().getEngine().getResourceManager();
                var pMethodPool = pRmgr.renderMethodPool;
                var pMethod = pMethodPool.findResource(".method-prepare-shadows");
                if (((pMethod) === null)) {
                    pMethod = pRmgr.createRenderMethod(".method-prepare-shadows");
                    pMethod.effect = pRmgr.createEffect(".effect-prepare-shadows");
                    pMethod.effect.addComponent("akra.system.prepareShadows");
                }
                pRenderable.addRenderMethod(pMethod, this._csDefaultRenderMethod);
            };
            ShadowViewport.prototype._getDepthRangeImpl = /**@protected*/ function () {
                var pDepthTexture;
                var pShadowCaster = this._pCamera;
                var pLightPoint = pShadowCaster.lightPoint;
                switch(pLightPoint.type) {
                    case akra.ELightTypes.PROJECT:
                        pDepthTexture = (pLightPoint).getDepthTexture();
                        break;
                    case akra.ELightTypes.OMNI:
                        pDepthTexture = (pLightPoint).getDepthTextureCube()[pShadowCaster.face];
                        break;
                    default:
                        pDepthTexture = null;
                        break;
                }
                if (((pDepthTexture) != null)) {
                    var pRange = akra.util.getDepthRange(pDepthTexture);
                    console.log("shadow viewport min & max depth range > ", pRange.min, pRange.max);
                    //[0,1] -> [-1, 1]
                    pRange.min = pRange.min * 2. - 1.;
                    pRange.max = pRange.max * 2. - 1.;
                    return pRange;
                }
                return null;
            };
            return ShadowViewport;
        })(render.Viewport);
        render.ShadowViewport = ShadowViewport;        
        ;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        var RenderableObject = (function () {
            function RenderableObject(eType) {
                if (typeof eType === "undefined") { eType = akra.ERenderDataTypes.UNKNOWN; }
                /**@protected*/ this._pRenderData = null;
                /**@protected*/ this._pTechnique = null;
                /**@protected*/ this._pTechniqueMap = {};
                /**@protected*/ this._bShadow = true;
                /**@protected*/ this._bVisible = true;
                /**@protected*/ this._bFrozen = false;
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
                this._eRenderableType = eType;
            }
            Object.defineProperty(RenderableObject.prototype, "type", {
                get: /** @inline */function () {
                    return this._eRenderableType;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderableObject.prototype, "renderMethod", {
                get: /** @inline */function () {
                    return this._pTechnique.getMethod();
                },
                set: /** @inline */function (pMethod) {
                    this.switchRenderMethod(pMethod);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderableObject.prototype, "effect", {
                get: /** @inline */function () {
                    return this._pTechnique.getMethod().effect;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderableObject.prototype, "surfaceMaterial", {
                get: /** @inline */function () {
                    return this._pTechnique.getMethod().surfaceMaterial;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderableObject.prototype, "material", {
                get: /** @inline */function () {
                    return ((this)._pTechnique.getMethod().surfaceMaterial).material;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderableObject.prototype, "data", {
                get: /** @inline */function () {
                    return this._pRenderData;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderableObject.prototype, "hasShadow", {
                get: /** @inline */function () {
                    return this._bShadow;
                },
                set: /** @inline */function (bShadow) {
                    if (this._bShadow !== bShadow) {
                        this._bShadow = bShadow;
                        this.shadow(bShadow);
                    }
                },
                enumerable: true,
                configurable: true
            });
            RenderableObject.prototype._setRenderData = /** @inline */function (pData) {
                this._pRenderData = pData;
            };
            RenderableObject.prototype._setup = function (pRenderer, csDefaultMethod) {
                if (typeof csDefaultMethod === "undefined") { csDefaultMethod = null; }
                this._pRenderer = pRenderer;
                if (!this.addRenderMethod(csDefaultMethod) || this.switchRenderMethod(null) === false) {
 {
                        akra.logger.setSourceLocation("RenderableObject.ts", 70);
                        akra.logger.criticalError("cannot add & switch render method to default");
                    }
                    ;
                }
            };
            RenderableObject.prototype.getRenderer = /** @inline */function () {
                return this._pRenderer;
            };
            RenderableObject.prototype.destroy = function () {
                this._pRenderer = null;
                this._pTechnique = null;
                for(var i in this._pTechniqueMap) {
                    this._pTechniqueMap[i].destroy();
                }
                this._pTechniqueMap = null;
            };
            RenderableObject.prototype.addRenderMethod = function (csMethod, csName) {
                if (typeof csName === "undefined") { csName = "default"; }
                var pTechnique = new render.RenderTechnique();
                var pRmgr = ((this)._pRenderer).getEngine().getResourceManager();
                var pMethod = null;
                if (((csMethod) === null)) {
                    csMethod = "default";
                }
                if ((typeof (csMethod) === "string") || arguments.length === 0) {
                    pMethod = pRmgr.createRenderMethod((csMethod) + ((this)._iGuid));
                    if (!((pMethod) != null)) {
                        return false;
                    }
                    //adding empty, but NOT NULL effect & material
                    pMethod.surfaceMaterial = pRmgr.createSurfaceMaterial(csMethod + ".material." + ((this)._iGuid));
                    pMethod.effect = pRmgr.createEffect(csMethod + ".effect." + ((this)._iGuid));
                } else {
                    pMethod = arguments[0];
                }
 {
                    akra.logger.setSourceLocation("RenderableObject.ts", 117);
                    akra.logger.assert(pMethod.getManager().getEngine().getRenderer() === this._pRenderer, "Render method should belong to the same engine instance that the renderable object.");
                }
                ;
                pTechnique.setMethod(pMethod);
                //pTechnique.name = csName || DEFAULT_RT;
                this._pTechniqueMap[csName || "default"] = pTechnique;
                return true;
            };
            RenderableObject.prototype.switchRenderMethod = function (csName) {
                var pTechnique;
                var sName = null;
                if (((arguments[0]) === null)) {
                    sName = "default";
                } else if ((typeof (arguments[0]) === "string")) {
                    sName = csName;
                } else if (((arguments[0]) != null)) {
                    sName = (arguments[0]).findResourceName();
                    if (!((this._pTechniqueMap[sName]) != null)) {
                        if (!this.addRenderMethod(arguments[0], sName)) {
                            return false;
                        }
                    }
                }
                pTechnique = this._pTechniqueMap[sName];
                if (((pTechnique) != null)) {
                    this._pTechnique = pTechnique;
                    return true;
                }
                return false;
            };
            RenderableObject.prototype.removeRenderMethod = function (csName) {
                var pTechnique = this._pTechniqueMap[csName];
                if (((pTechnique) != null)) {
                    delete this._pTechniqueMap[csName || "default"];
                    return true;
                }
                return false;
            };
            RenderableObject.prototype.getRenderMethod = /** @inline */function (csName) {
                if (typeof csName === "undefined") { csName = null; }
                var pTechnique = this._pTechniqueMap[csName || "default"];
                return pTechnique ? pTechnique.getMethod() : null;
            };
            RenderableObject.prototype.getRenderMethodDefault = /** @inline */function () {
                return /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.getRenderMethod("default");
            };
            RenderableObject.prototype.isReadyForRender = /** @inline */function () {
                return this._bVisible && this._pTechnique.isReady();
            };
            RenderableObject.prototype.isAllMethodsLoaded = function () {
                for(var i in this._pTechniqueMap) {
                    var pMethod = this._pTechniqueMap[i].getMethod();
                    if (!((pMethod) != null) || !pMethod.isResourceLoaded()) {
                        return false;
                    }
                }
                return true;
            };
            RenderableObject.prototype.isFrozen = /** @inline */function () {
                return this._bFrozen;
            };
            RenderableObject.prototype.render = function (pViewport, csMethod, pSceneObject) {
                if (typeof csMethod === "undefined") { csMethod = null; }
                if (typeof pSceneObject === "undefined") { pSceneObject = null; }
                this.beforeRender(pViewport);
                if (!((this)._bVisible && (this)._pTechnique.isReady())) {
                    return;
                }
                if (!this.switchRenderMethod(csMethod)) {
 {
                        akra.logger.setSourceLocation("RenderableObject.ts", 210);
                        akra.logger.error("could not switch render method <" + csMethod + ">");
                    }
                    ;
                    return;
                }
                ((this)._pRenderData)._draw(this._pTechnique, pViewport, this, pSceneObject);
            };
            RenderableObject.prototype.getTechnique = /** @inline */function (sName) {
                if (typeof sName === "undefined") { sName = "default"; }
                return this._pTechniqueMap[sName] || null;
            };
            RenderableObject.prototype.getTechniqueDefault = /** @inline */function () {
                return ((this)._pTechniqueMap[("default")] || null);
            };
            RenderableObject.prototype._draw = function () {
 {
                    akra.logger.setSourceLocation("RenderableObject.ts", 226);
                    akra.logger.error("RenderableObject::_draw() pure virtual method() isn't callable!!");
                }
                ;
            };
            RenderableObject.prototype.isVisible = /** @inline */function () {
                return this._bVisible;
            };
            RenderableObject.prototype.setVisible = /** @inline */function (bVisible) {
                if (typeof bVisible === "undefined") { bVisible = true; }
                this._bVisible = bVisible;
            };
            RenderableObject.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            RenderableObject._pEventTable = new akra.events.EventTable();
            RenderableObject.prototype.getEventTable = /** @inline */function () {
                return RenderableObject._pEventTable;
            };
            RenderableObject.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            RenderableObject.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            RenderableObject.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (RenderableObject._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            RenderableObject.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (RenderableObject._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            RenderableObject.prototype._syncTable = /** @inline */function (pFrom) {
                (RenderableObject._pEventTable)._sync(this, pFrom);
            };
            RenderableObject.prototype.shadow = function (bValue) {
                var _recivier = this;
                this._pUnicastSlotMap = this._pUnicastSlotMap || ((RenderableObject._pEventTable)).findUnicastList(this._iGuid);
                var _unicast = (this._pUnicastSlotMap).shadow;
                if (((_unicast) !== undefined)) {
                    _unicast.target ? _unicast.target[_unicast.callback](_recivier, bValue) : _unicast.listener(_recivier, bValue);
                }
            };
            RenderableObject.prototype.beforeRender = function (pViewport) {
                var _recivier = this;
                this._pUnicastSlotMap = this._pUnicastSlotMap || ((RenderableObject._pEventTable)).findUnicastList(this._iGuid);
                var _unicast = (this._pUnicastSlotMap).beforeRender;
                if (((_unicast) !== undefined)) {
                    _unicast.target ? _unicast.target[_unicast.callback](_recivier, pViewport) : _unicast.listener(_recivier, pViewport);
                }
            };
            return RenderableObject;
        })();
        render.RenderableObject = RenderableObject;        
        /** @inline */function isMeshSubset(pObject) {
            return pObject.type === akra.ERenderDataTypes.MESH_SUBSET;
        }
        render.isMeshSubset = isMeshSubset;
        /** @inline */function isScreen(pObject) {
            return pObject.type === akra.ERenderDataTypes.SCREEN;
        }
        render.isScreen = isScreen;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        // #ifdef WEBGL
        // #define WEBGL_DEPTH_RANGE 1
        // #endif
        function getDepthRange(pDepthTexture) {
            return {
                min: 0.,
                max: 1.
            };
        }
        util.getDepthRange = getDepthRange;
        ;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        var Screen = (function (_super) {
            __extends(Screen, _super);
            function Screen(pRenderer) {
                        _super.call(this, akra.ERenderDataTypes.SCREEN);
                var pCollection = pRenderer.getEngine().createRenderDataCollection(0);
                var pData = pCollection.getEmptyRenderData(akra.EPrimitiveTypes.TRIANGLESTRIP);
                pData.allocateAttribute(akra.createVertexDeclaration([
                    (({
count: (2),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclUsages.POSITION)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                ]), new Float32Array([
                    -1, 
                    -1, 
                    -1, 
                    1, 
                    1, 
                    -1, 
                    1, 
                    1
                ]));
                this._pRenderData = pData;
                this._setup(pRenderer);
            }
            return Screen;
        })(render.RenderableObject);
        render.Screen = Screen;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        var pDepthPixel = new akra.pixelUtil.PixelBox(new akra.geometry.Box(0, 0, 1, 1), akra.EPixelFormats.FLOAT32_DEPTH, new Uint8Array(4 * 1));
        var pFloatColorPixel = new akra.pixelUtil.PixelBox(new akra.geometry.Box(0, 0, 1, 1), akra.EPixelFormats.FLOAT32_RGBA, new Uint8Array(4 * 4));
        var pColor = new akra.Color(0);
        var DSViewport = (function (_super) {
            __extends(DSViewport, _super);
            function DSViewport(pCamera, pTarget, csRenderMethod, fLeft, fTop, fWidth, fHeight, iZIndex) {
                if (typeof csRenderMethod === "undefined") { csRenderMethod = null; }
                if (typeof fLeft === "undefined") { fLeft = 0.; }
                if (typeof fTop === "undefined") { fTop = 0.; }
                if (typeof fWidth === "undefined") { fWidth = 1.; }
                if (typeof fHeight === "undefined") { fHeight = 1.; }
                if (typeof iZIndex === "undefined") { iZIndex = 0; }
                        _super.call(this, pCamera, pTarget, null, fLeft, fTop, fWidth, fHeight, iZIndex);
                this._pDeferredColorTextures = [];
                this._pDeferredDepthTexture = null;
                this._pDeferredView = null;
                this._pDeferredSkyTexture = null;
                this._pLightingUnifoms = {
                    omni: [],
                    project: [],
                    omniShadows: [],
                    projectShadows: [],
                    sun: [],
                    textures: [],
                    samplersOmni: [],
                    samplersProject: []
                };
                this._pLightPoints = null;
                var pEngine = ((this)._pTarget).getRenderer().getEngine();
                var pResMgr = pEngine.getResourceManager();
                var pDeferredData = new Array(2);
                var pDeferredTextures = new Array(2);
                var pDepthTexture;
                var pDefferedView = this._pDeferredView = new render.Screen(pEngine.getRenderer());
                var iGuid = akra.sid();
                var iWidth = akra.math.ceilingPowerOfTwo(((this)._iActWidth));
                var iHeight = akra.math.ceilingPowerOfTwo(((this)._iActHeight));
                if (akra.info.browser.name === "Firefox") {
                    iWidth = akra.math.min(iWidth, 1024);
                    iHeight = akra.math.min(iHeight, 1024);
                }
                pDepthTexture = this._pDeferredDepthTexture = pResMgr.createTexture("deferred-depth-texture-" + iGuid);
                pDepthTexture.create(iWidth, iHeight, 1, null, 0, 0, 0, akra.ETextureTypes.TEXTURE_2D, akra.EPixelFormats.DEPTH32);
                pDepthTexture.setFilter(akra.ETextureParameters.MAG_FILTER, akra.ETextureFilters.LINEAR);
                pDepthTexture.setFilter(akra.ETextureParameters.MIN_FILTER, akra.ETextureFilters.LINEAR);
                for(var i = 0; i < 2; ++i) {
                    pDeferredTextures[i] = this._pDeferredColorTextures[i] = pResMgr.createTexture("deferred-color-texture-" + i + "-" + iGuid);
                    pDeferredTextures[i].create(iWidth, iHeight, 1, null, akra.ETextureFlags.RENDERTARGET, 0, 0, akra.ETextureTypes.TEXTURE_2D, akra.EPixelFormats.FLOAT32_RGBA);
                    pDeferredData[i] = pDeferredTextures[i].getBuffer().getRenderTarget();
                    pDeferredData[i].setAutoUpdated(false);
                    var pViewport = pDeferredData[i].addViewport(((this)._pCamera), "deferred_shading_pass_" + i, 0, 0, 0, ((this)._iActWidth) / pDeferredTextures[i].width, ((this)._iActHeight) / pDeferredTextures[i].height);
                    pDeferredData[i].attachDepthTexture(pDepthTexture);
                    if (i === 1) {
                        pViewport.setDepthParams(true, false, akra.ECompareFunction.EQUAL);
                        pViewport.setClearEveryFrame(true, akra.EFrameBufferTypes.COLOR);
                    }
                }
                var pDSMethod = pResMgr.createRenderMethod(".deferred_shading");
                var pDSEffect = pResMgr.createEffect(".deferred_shading");
                pDSEffect.addComponent("akra.system.deferredShading");
                pDSEffect.addComponent("akra.system.omniLighting");
                pDSEffect.addComponent("akra.system.projectLighting");
                pDSEffect.addComponent("akra.system.omniShadowsLighting");
                pDSEffect.addComponent("akra.system.projectShadowsLighting");
                pDSEffect.addComponent("akra.system.sunLighting");
                // pDSEffect.addComponent("akra.system.color_maps");
                pDSEffect.addComponent("akra.system.skybox", 1, 0);
                pDSMethod.effect = pDSEffect;
                pDefferedView.getTechnique().setMethod(pDSMethod);
                pDefferedView.getTechnique()._setGlobalPostEffectsFrom(1);
                this.setClearEveryFrame(false);
                this.setDepthParams(false, false, 0);
                this.setFXAA(true);
            }
            Object.defineProperty(DSViewport.prototype, "type", {
                get: /** @inline */function () {
                    return akra.EViewportTypes.DSVIEWPORT;
                },
                enumerable: true,
                configurable: true
            });
            DSViewport.prototype.setCamera = function (pCamera) {
                var isOk = _super.prototype.setCamera.call(this, pCamera);
                this._pDeferredColorTextures[0].getBuffer().getRenderTarget().getViewport(0).setCamera(pCamera);
                this._pDeferredColorTextures[1].getBuffer().getRenderTarget().getViewport(0).setCamera(pCamera);
                return isOk;
            };
            DSViewport.prototype._updateDimensions = function () {
                _super.prototype._updateDimensions.call(this);
                var pDeferredTextures = this._pDeferredColorTextures;
                if (((this._pDeferredDepthTexture) != null)) {
                    this._pDeferredDepthTexture.reset(akra.math.ceilingPowerOfTwo(((this)._iActWidth)), akra.math.ceilingPowerOfTwo(((this)._iActHeight)));
                    for(var i = 0; i < 2; ++i) {
                        pDeferredTextures[i].reset(akra.math.ceilingPowerOfTwo(((this)._iActWidth)), akra.math.ceilingPowerOfTwo(((this)._iActHeight)));
                        pDeferredTextures[i].getBuffer().getRenderTarget().getViewport(0).setDimensions(0., 0., ((this)._iActWidth) / pDeferredTextures[i].width, ((this)._iActHeight) / pDeferredTextures[i].height);
                    }
                }
            };
            DSViewport.prototype._updateImpl = function () {
                this.prepareForDeferredShading();
                //prepare deferred textures
                // #ifndef OPTIMIZED_DEFFERED
                this._pDeferredColorTextures[0].getBuffer().getRenderTarget().update();
                this._pDeferredColorTextures[1].getBuffer().getRenderTarget().update();
                this._pCamera._keepLastViewport(this);
                var pLights = ((this)._pCamera).display(1);
                for(var i = 0; i < (pLights._iLength); i++) {
                    (pLights._pData[(i)])._calculateShadows();
                }
                this._pLightPoints = pLights;
                // #else
                // 			var pNodeList: IObjectArray = this.getCamera().display();
                // 			for (var i: int = 0; i < pNodeList.length; ++ i) {
                // 				var pRenderable: IRenderableObject = pNodeList.value(i).getRenderable();
                // 				pRenderable.render(this._pDeferredColorTextures[i].getBuffer().getRenderTarget().getViewport(0), null, pNodeList.value(i));
                // 			}
                // 			this.getTarget().getRenderer().executeQueue();
                // #endif
                //render deferred
                this._pDeferredView.render(this);
            };
            DSViewport.prototype.prepareForDeferredShading = function () {
                var pNodeList = ((this)._pCamera).display();
                for(var i = 0; i < pNodeList.length; ++i) {
                    var pSceneObject = pNodeList.value(i);
                    for(var k = 0; k < pSceneObject.totalRenderable; k++) {
                        var pRenderable = pSceneObject.getRenderable(k);
                        var pTechCurr = pRenderable.getTechniqueDefault();
                        for(var j = 0; j < 2; j++) {
                            var sMethod = "deferred_shading_pass_" + j;
                            var pTechnique = pRenderable.getTechnique(sMethod);
                            if (((pTechnique) === null) || pTechCurr.modified > pTechnique.modified) {
                                if (!pRenderable.addRenderMethod(pRenderable.getRenderMethod(), sMethod)) {
 {
                                        akra.logger.setSourceLocation("DSViewport.ts", 221);
                                        akra.logger.criticalError("cannot clone active render method");
                                    }
                                    ;
                                }
                                pTechnique = pRenderable.getTechnique(sMethod);
                                pTechnique._syncTable(pTechCurr);
                                if (j === 0) {
                                    pTechnique._blockPass(1);
                                } else {
                                    pTechnique._blockPass(0);
                                }
                                if (pTechnique.totalPasses > j) {
                                    var pPass = pTechnique.getPass(j);
                                    pPass.blend("akra.system.prepareForDeferredShading", j);
                                }
                            }
                        }
                    }
                    // for(var j: uint = 0; j < pTechCurr.totalPasses; j++){
                    // 	if(!pTechCurr.hasComponent("akra.system.prepareForDeferredShading", j, j)){
                    // 		pTechCurr.getPass(j).blend("akra.system.prepareForDeferredShading", j);
                    // 	}
                    // }
                    // pTechCurr.getPass(0).setRenderTarget(this._pDeferredColorTextures[0].getBuffer().getRenderTarget());
                    // pTechCurr.getPass(1).setRenderTarget(this._pDeferredColorTextures[1].getBuffer().getRenderTarget());
                                    }
                ;
            };
            DSViewport.prototype.getSkybox = /** @inline */function () {
                return this._pDeferredSkyTexture;
            };
            DSViewport.prototype.getDepth = function (x, y) {
 {
                    akra.logger.setSourceLocation("DSViewport.ts", 261);
                    akra.logger.assert(x < ((this)._iActWidth) && y < ((this)._iActHeight), "invalid pixel: {" + x + ", " + y + "}");
                }
                ;
                var pDepthTexture = this._pDeferredDepthTexture;
                //depth texture has POT sized, but viewport not;
                //depth texture attached to left bottom angle of viewport
                y = y + (pDepthTexture.height - ((this)._iActHeight));
                pDepthPixel.left = x;
                pDepthPixel.top = y;
                pDepthPixel.right = x + 1;
                pDepthPixel.bottom = y + 1;
                pDepthTexture.getBuffer(0, 0).readPixels(pDepthPixel);
                return pDepthPixel.getColorAt(pColor, 0, 0).r;
            };
            DSViewport.prototype._getDepthRangeImpl = /**@protected*/ function () {
                var pRange = akra.util.getDepthRange(this._pDeferredDepthTexture);
                //[0,1] -> [-1, 1]
                pRange.min = pRange.min * 2. - 1.;
                pRange.max = pRange.max * 2. - 1.;
                return pRange;
            };
            DSViewport.prototype.getRenderId = /** @inline */function (x, y) {
                return this._getDeferredTex1Value(x, y).a;
            };
            DSViewport.prototype._getDeferredTex1Value = function (x, y) {
 {
                    akra.logger.setSourceLocation("DSViewport.ts", 292);
                    akra.logger.assert(x < ((this)._iActWidth) && y < ((this)._iActHeight), "invalid pixel: {" + x + ", " + y + "}");
                }
                ;
                var pColorTexture = this._pDeferredColorTextures[0];
                //depth texture has POT sized, but viewport not;
                //depth texture attached to left bottom angle of viewport
                y = y + (pColorTexture.height - ((this)._iActHeight));
                pFloatColorPixel.left = x;
                pFloatColorPixel.top = y;
                pFloatColorPixel.right = x + 1;
                pFloatColorPixel.bottom = y + 1;
                pColorTexture.getBuffer(0, 0).readPixels(pFloatColorPixel);
                // LOG(pFloatColorPixel.data);
                return pFloatColorPixel.getColorAt(pColor, 0, 0);
            };
            DSViewport.prototype.setSkybox = function (pSkyTexture) {
                if (pSkyTexture.textureType !== akra.ETextureTypes.TEXTURE_CUBE_MAP) {
                    return null;
                }
                this._pDeferredSkyTexture = pSkyTexture;
                this.addedSkybox(pSkyTexture);
                return true;
            };
            DSViewport.prototype.setFXAA = function (bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                var pEffect = this._pDeferredView.getTechnique().getMethod().effect;
                if (bValue) {
                    pEffect.addComponent("akra.system.fxaa", 2, 0);
                    this._pDeferredView.getTechnique()._setGlobalPostEffectsFrom(2);
                } else {
                    pEffect.delComponent("akra.system.fxaa", 2, 0);
                    this._pDeferredView.getTechnique()._setGlobalPostEffectsFrom(1);
                }
            };
            DSViewport.prototype.setOutlining = function (bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                var pEffect = this._pDeferredView.getTechnique().getMethod().effect;
                if (bValue) {
                    pEffect.addComponent("akra.system.outline", 1, 0);
                } else {
                    pEffect.delComponent("akra.system.outline", 1, 0);
                }
            };
            DSViewport.prototype.isFXAA = function () {
                return false;
            };
            DSViewport.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
                this._pDeferredDepthTexture.destroyResource();
                this._pDeferredColorTextures[0].destroyResource();
                this._pDeferredColorTextures[1].destroyResource();
                this._pDeferredView.destroy();
                this._pDeferredView = null;
                this._pDeferredSkyTexture = null;
            };
            DSViewport.prototype.render = function (pTechnique, iPass, pRenderable, pSceneObject) {
                var pPass = pTechnique.getPass(iPass);
                var pDepthTexture = this._pDeferredDepthTexture;
                var pDeferredTextures = this._pDeferredColorTextures;
                switch(iPass) {
                    case 0:
                        var pLightUniforms = this._pLightingUnifoms;
                        var pLightPoints = this._pLightPoints;
                        var pCamera = ((this)._pCamera);
                        this.createLightingUniforms(pCamera, pLightPoints, pLightUniforms);
                        // LOG(pLightUniforms);
                        pPass.setForeign("nOmni", pLightUniforms.omni.length);
                        pPass.setForeign("nProject", pLightUniforms.project.length);
                        pPass.setForeign("nOmniShadows", pLightUniforms.omniShadows.length);
                        pPass.setForeign("nProjectShadows", pLightUniforms.projectShadows.length);
                        pPass.setForeign("nSun", pLightUniforms.sun.length);
                        pPass.setStruct("points_omni", pLightUniforms.omni);
                        pPass.setStruct("points_project", pLightUniforms.project);
                        pPass.setStruct("points_omni_shadows", pLightUniforms.omniShadows);
                        pPass.setStruct("points_project_shadows", pLightUniforms.projectShadows);
                        pPass.setStruct("points_sun", pLightUniforms.sun);
                        for(var i = 0; i < pLightUniforms.textures.length; i++) {
                            pPass.setTexture("TEXTURE" + i, pLightUniforms.textures[i]);
                        }
                        pPass.setUniform("PROJECT_SHADOW_SAMPLER", pLightUniforms.samplersProject);
                        pPass.setUniform("OMNI_SHADOW_SAMPLER", pLightUniforms.samplersOmni);
                        pPass.setUniform("MIN_SHADOW_VALUE", 0.5);
                        pPass.setUniform("SHADOW_CONSTANT", 5.e+2);
                        pPass.setUniform("SCREEN_TEXTURE_RATIO", akra.Vec2.stackCeil.set(((this)._iActWidth) / pDepthTexture.width, ((this)._iActHeight) / pDepthTexture.height));
                        pPass.setTexture("DEFERRED_TEXTURE0", pDeferredTextures[0]);
                        pPass.setTexture("DEFERRED_TEXTURE1", pDeferredTextures[1]);
                        pPass.setTexture("SCENE_DEPTH_TEXTURE", pDepthTexture);
                        //    pPass.setUniform("SAMPLER_TEXTURE0", <IAFXSamplerState>{
                        // 	textureName: "DEFERRED_TEXTURE0",
                        // 	texture: null,
                        // 	wrap_s: ETextureWrapModes.CLAMP_TO_EDGE,
                        // 	wrap_t: ETextureWrapModes.CLAMP_TO_EDGE,
                        // 	mag_filter: ETextureFilters.NEAREST,
                        // 	min_filter: ETextureFilters.NEAREST
                        // });
                        // pPass.setUniform("SAMPLER_TEXTURE1", <IAFXSamplerState>{
                        // 	textureName: "DEFERRED_TEXTURE1",
                        // 	texture: null,
                        // 	wrap_s: ETextureWrapModes.CLAMP_TO_EDGE,
                        // 	wrap_t: ETextureWrapModes.CLAMP_TO_EDGE,
                        // 	mag_filter: ETextureFilters.NEAREST,
                        // 	min_filter: ETextureFilters.NEAREST
                        // });
                        // pPass.setUniform("SAMPLER_SCENE_DEPTH", <IAFXSamplerState>{
                        // 	textureName: "SCENE_DEPTH_TEXTURE",
                        // 	texture: null,
                        // 	wrap_s: ETextureWrapModes.CLAMP_TO_EDGE,
                        // 	wrap_t: ETextureWrapModes.CLAMP_TO_EDGE,
                        // 	mag_filter: ETextureFilters.LINEAR,
                        // 	min_filter: ETextureFilters.LINEAR
                        // });
                        break;
                    case 1:
                        pPass.setTexture("DEFERRED_TEXTURE0", pDeferredTextures[0]);
                        pPass.setTexture("SKYBOX_TEXTURE", this._pDeferredSkyTexture);
                        pPass.setUniform("SCREEN_TEXTURE_RATIO", akra.Vec2.stackCeil.set(((this)._iActWidth) / pDepthTexture.width, ((this)._iActHeight) / pDepthTexture.height));
                        //    pPass.setUniform("SAMPLER_SKYBOX", <IAFXSamplerState>{
                        // 	textureName: "SKYBOX_TEXTURE",
                        // 	texture: null,
                        // 	wrap_s: ETextureWrapModes.CLAMP_TO_EDGE,
                        // 	wrap_t: ETextureWrapModes.CLAMP_TO_EDGE,
                        // 	mag_filter: ETextureFilters.LINEAR,
                        // 	min_filter: ETextureFilters.LINEAR
                        // });
                        // pPass.setUniform("SAMPLER_TEXTURE0", <IAFXSamplerState>{
                        // 	textureName: "DEFERRED_TEXTURE0",
                        // 	texture: null,
                        // 	wrap_s: ETextureWrapModes.CLAMP_TO_EDGE,
                        // 	wrap_t: ETextureWrapModes.CLAMP_TO_EDGE,
                        // 	mag_filter: ETextureFilters.NEAREST,
                        // 	min_filter: ETextureFilters.NEAREST
                        // });
                        break;
                }
                _super.prototype.render.call(this, pTechnique, iPass, pRenderable, pSceneObject);
            };
            DSViewport.prototype.resetUniforms = /** @inline */function () {
                var pUniforms = this._pLightingUnifoms;
                pUniforms.omni.clear();
                pUniforms.project.clear();
                pUniforms.omniShadows.clear();
                pUniforms.projectShadows.clear();
                pUniforms.textures.clear();
                pUniforms.samplersProject.clear();
                pUniforms.samplersOmni.clear();
                pUniforms.sun.clear();
            };
            DSViewport.prototype.createLightingUniforms = function (pCamera, pLightPoints, pUniforms) {
                var pLight;
                var pOmniLight;
                var pProjectLight;
                var i, j;
                var pUniformData;
                var pCameraView = pCamera.viewMatrix;
                var v4fLightPosition = akra.Vec4.stackCeil.set();
                var v3fLightTransformPosition = akra.Vec3.stackCeil.set();
                var v4fTemp = akra.Vec4.stackCeil.set();
                var pShadowCaster;
                var m4fShadow, m4fToLightSpace;
                var iLastTextureIndex = 0;
                var sTexture = "TEXTURE";
                var pEngine = ((this)._pTarget).getRenderer().getEngine();
                /*not inlined, because supportes only single statement functions(cur. st. count: 10)*/this.resetUniforms();
                for(i = 0; i < pLightPoints.length; i++) {
                    pLight = pLightPoints.value(i);
                    //all cameras in list already enabled
                    // if (!pLight.enabled) {
                    //     continue;
                    // }
                    v4fLightPosition.set(pLight.worldPosition, 1.);
                    pCameraView.multiplyVec4(v4fLightPosition, v4fTemp);
                    v3fLightTransformPosition.set(v4fTemp.x, v4fTemp.y, v4fTemp.z);
                    if (pLight.lightType === akra.ELightTypes.OMNI) {
                        pOmniLight = pLight;
                        if (pLight.isShadowCaster) {
                            pUniformData = render.UniformOmniShadow.stackCeil;
                            (pUniformData).setLightData(pLight.params, v3fLightTransformPosition);
                            var pDepthCube = pOmniLight.getDepthTextureCube();
                            var pShadowCasterCube = pOmniLight.getShadowCaster();
                            for(j = 0; j < 6; ++j) {
                                pShadowCaster = pShadowCasterCube[j];
                                m4fToLightSpace = pShadowCaster.viewMatrix.multiply(pCamera.worldMatrix, akra.Mat4.stackCeil.set());
                                pUniforms.textures.push(pDepthCube[j]);
                                sTexture = "TEXTURE" + (pUniforms.textures.length - 1);
                                (pUniformData).setSampler(sTexture, j);
                                pUniforms.samplersOmni.push((pUniformData).SHADOW_SAMPLER[j]);
                                (pUniformData).setMatrix(m4fToLightSpace, pShadowCaster.optimizedProjection, j);
                            }
                            pUniforms.omniShadows.push(pUniformData);
                        } else {
                            pUniformData = render.UniformOmni.stackCeil;
                            (pUniformData).setLightData(pLight.params, v3fLightTransformPosition);
                            pUniforms.omni.push(pUniformData);
                        }
                    } else if (pLight.lightType === akra.ELightTypes.PROJECT) {
                        pProjectLight = pLight;
                        pShadowCaster = pProjectLight.getShadowCaster();
                        if (pLight.isShadowCaster && pShadowCaster.isShadowCasted) {
                            pUniformData = render.UniformProjectShadow.stackCeil;
                            (pUniformData).setLightData(pLight.params, v3fLightTransformPosition);
                            m4fToLightSpace = pShadowCaster.viewMatrix.multiply(pCamera.worldMatrix, akra.Mat4.stackCeil.set());
                            pUniforms.textures.push(pProjectLight.getDepthTexture());
                            sTexture = "TEXTURE" + (pUniforms.textures.length - 1);
                            (pUniformData).setSampler(sTexture);
                            pUniforms.samplersProject.push((pUniformData).SHADOW_SAMPLER);
                            (pUniformData).setMatrix(m4fToLightSpace, pShadowCaster.projectionMatrix, pShadowCaster.optimizedProjection);
                            pUniforms.projectShadows.push(pUniformData);
                        } else {
                            pUniformData = render.UniformProject.stackCeil;
                            (pUniformData).setLightData(pLight.params, v3fLightTransformPosition);
                            m4fShadow = pShadowCaster.projViewMatrix.multiply(pCamera.worldMatrix, akra.Mat4.stackCeil.set());
                            (pUniformData).setMatrix(m4fShadow);
                            pUniforms.project.push(pUniformData);
                        }
                    } else if (pLight.lightType === akra.ELightTypes.SUN) {
                        pUniformData = render.UniformSun.stackCeil;
                        var pSkyDome = (pLight).skyDome;
                        var iSkyDomeId = pEngine.getComposer()._calcRenderID(pSkyDome, pSkyDome.getRenderable(0), false);
                        (pUniformData).setLightData(pLight.params, iSkyDomeId);
                        pUniforms.sun.push(pUniformData);
                    } else {
 {
                            akra.logger.setSourceLocation("DSViewport.ts", 583);
                            akra.logger.criticalError("Invalid light point type detected.");
                        }
                        ;
                    }
                }
            };
            DSViewport.prototype.addedSkybox = function (pSkyTexture) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((/*checked (origin: render)>>*/akra.render.Viewport._pEventTable))).broadcast[(this._iGuid)] = (((/*checked (origin: render)>>*/akra.render.Viewport._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).addedSkybox;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pSkyTexture) : _broadcast[i].listener(_recivier, pSkyTexture);
                    }
                }
            };
            return DSViewport;
        })(render.Viewport);
        render.DSViewport = DSViewport;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        var pPixel = new akra.pixelUtil.PixelBox(new akra.geometry.Box(0, 0, 1, 1), akra.EPixelFormats.BYTE_RGBA, new Uint8Array(4));
        var ColorViewport = (function (_super) {
            __extends(ColorViewport, _super);
            function ColorViewport(pCamera, pTarget, csRenderMethod, fLeft, fTop, fWidth, fHeight, iZIndex) {
                if (typeof csRenderMethod === "undefined") { csRenderMethod = null; }
                if (typeof fLeft === "undefined") { fLeft = 0.; }
                if (typeof fTop === "undefined") { fTop = 0.; }
                if (typeof fWidth === "undefined") { fWidth = 1.; }
                if (typeof fHeight === "undefined") { fHeight = 1.; }
                if (typeof iZIndex === "undefined") { iZIndex = 0; }
                        _super.call(this, pCamera, pTarget, ".color-picker", fLeft, fTop, fWidth, fHeight, iZIndex);
                /**@protected*/ this._pGuidToColorMap = {};
                /**@protected*/ this._pColorToSceneObjectMap = new Array(256);
                /**@protected*/ this._pColorToRenderableMap = new Array(256);
            }
            Object.defineProperty(ColorViewport.prototype, "type", {
                get: /** @inline */function () {
                    return akra.EViewportTypes.COLORVIEWPORT;
                },
                enumerable: true,
                configurable: true
            });
            ColorViewport.prototype._updateImpl = function () {
                var pVisibleObjects = ((this)._pCamera).display();
                var pRenderable;
                for(var i = 0; i < pVisibleObjects.length; ++i) {
                    pVisibleObjects.value(i).prepareForRender(this);
                }
                for(var i = 0; i < 256; ++i) {
                    this._pColorToSceneObjectMap[i] = null;
                    this._pColorToRenderableMap[i] = null;
                }
                for(var g in this._pGuidToColorMap) {
                    this._pGuidToColorMap[g] = 0;
                }
                // var pOldCamera = this._pCamera;
                // this._pCamera = ide.getCamera();
                var r = 1;
                var s = 1;
                for(var i = 0; i < pVisibleObjects.length; ++i) {
                    var pSceneObject = pVisibleObjects.value(i);
                    this._pGuidToColorMap[pSceneObject.getGuid()] = s;
                    this._pColorToSceneObjectMap[s] = pSceneObject;
                    s++;
                    for(var j = 0; j < pSceneObject.totalRenderable; j++) {
                        pRenderable = pSceneObject.getRenderable(j);
                        if (!((pRenderable) === null) && !pRenderable.isFrozen()) {
                            this._pGuidToColorMap[pRenderable.getGuid()] = r;
                            this._pColorToRenderableMap[r] = pRenderable;
                            r++;
                            this.prepareRenderableForPicking(pRenderable);
                            pRenderable.render(this, this._csDefaultRenderMethod, pSceneObject);
                        }
                    }
                }
                // this._pCamera = pOldCamera;
                            };
            ColorViewport.prototype.getObject = function (x, y) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                var pTarget = ((this)._pTarget);
                if (pTarget instanceof render.RenderTexture) {
                    var pPixelBuffer = (pTarget).getPixelBuffer();
                    x = akra.math.round(x);
                    y = akra.math.round(y);
                    pPixel.left = x;
                    pPixel.right = x + 1;
                    pPixel.top = y;
                    pPixel.bottom = y + 1;
                    if (pPixelBuffer.readPixels(pPixel)) {
                        console.log(pPixel.data[0], pPixel.data[1], pPixel.data[2], pPixel.data[3]);
                        return {
                            object: this._pColorToSceneObjectMap[pPixel.data[0]] || null,
                            renderable: this._pColorToRenderableMap[pPixel.data[1]] || null
                        };
                    }
                }
                return null;
            };
            ColorViewport.prototype.render = function (pTechnique, iPass, pRenderable, pSceneObject) {
                var pPass = pTechnique.getPass(iPass);
                pPass.setUniform("RENDERABLE_ID", this._pGuidToColorMap[pRenderable.getGuid()]);
                pPass.setUniform("OPTIMIZED_PROJ_MATRIX", ((this)._pCamera).projectionMatrix);
                pPass.setUniform("color", (/*checked (origin: akra)>>*/akra.Vec4.stackCeil.set((/*checked (origin: akra)>>*/akra.util.randomColor(true)).r, (/*checked (origin: akra)>>*/akra.util.randomColor(true)).g, (/*checked (origin: akra)>>*/akra.util.randomColor(true)).b, (/*checked (origin: akra)>>*/akra.util.randomColor(true)).a)));
                if (!((pSceneObject) === null)) {
                    pPass.setUniform("SCENE_OBJECT_ID", this._pGuidToColorMap[pSceneObject.getGuid()]);
                }
                _super.prototype.render.call(this, pTechnique, iPass, pRenderable, pSceneObject);
            };
            ColorViewport.prototype.prepareRenderableForPicking = function (pRenderable) {
                var pRenderTechnique = pRenderable.getTechnique(this._csDefaultRenderMethod);
                if (!((pRenderTechnique) === null)) {
                    return;
                }
                var pRmgr = ((this)._pTarget).getRenderer().getEngine().getResourceManager();
                var pMethodPool = pRmgr.renderMethodPool;
                var pMethod = pMethodPool.findResource(".method-color-picker");
                if (((pMethod) === null)) {
                    pMethod = pRmgr.createRenderMethod(".method-color-picker");
                    pMethod.effect = pRmgr.createEffect(".effect-color-picker");
                    pMethod.effect.addComponent("akra.system.colorPicker");
                }
                pRenderable.addRenderMethod(pMethod, this._csDefaultRenderMethod);
            };
            return ColorViewport;
        })(render.Viewport);
        render.ColorViewport = ColorViewport;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    /* Define the number of priority groups for the render system's render targets. */
    (function (render) {
        var RenderTarget = (function () {
            function RenderTarget(pRenderer) {
                /**@protected*/ this._iPriority = 4;
                /**@protected*/ this._pDepthBuffer = null;
                /**@protected*/ this._pDepthPixelBuffer = null;
                /**@protected*/ this._isActive = true;
                /**@protected*/ this._isAutoUpdate = true;
                /**@protected*/ this._bHwGamma = false;
                /**@protected*/ this._pViewportList = [];
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
                this._pRenderer = pRenderer;
                this._pTimer = pRenderer.getEngine().getTimer();
                this._pFrameStats = {
                    fps: {
                        last: 0.,
                        avg: 0.,
                        best: 0.,
                        worst: 0.
                    },
                    time: {
                        best: 0.,
                        worst: 0.
                    },
                    polygonsCount: 0
                };
                this.resetStatistics();
            }
            Object.defineProperty(RenderTarget.prototype, "name", {
                get: /** @inline */function () {
                    return this._sName;
                },
                set: /** @inline */function (sName) {
                    this._sName = sName;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderTarget.prototype, "width", {
                get: /** @inline */function () {
                    return this._iWidth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderTarget.prototype, "height", {
                get: /** @inline */function () {
                    return this._iHeight;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderTarget.prototype, "colorDepth", {
                get: /** @inline */function () {
                    return this._iColorDepth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderTarget.prototype, "totalViewports", {
                get: /** @inline */function () {
                    return this._pViewportList.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderTarget.prototype, "totalFrames", {
                get: /** @inline */function () {
                    return this._iFrameCount;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderTarget.prototype, "priority", {
                get: /** @inline */function () {
                    return this._iPriority;
                },
                enumerable: true,
                configurable: true
            });
            RenderTarget.prototype.getRenderer = /** @inline */function () {
                return this._pRenderer;
            };
            RenderTarget.prototype.destroy = function () {
                var pViewport;
                for(var i in this._pViewportList) {
                    pViewport = this._pViewportList[i];
                    this.viewportRemoved(pViewport);
                    pViewport.destroy();
                }
                this.detachDepthBuffer();
 {
                    akra.logger.setSourceLocation("render/RenderTarget.ts", 101);
                    akra.logger.log("RenderTarget '%s'\n Average FPS: %s\n Best FPS: %s\n Worst FPS: %s", this._sName, this._pFrameStats.fps.avg, this._pFrameStats.fps.best, this._pFrameStats.fps.worst);
                }
                ;
            };
            RenderTarget.prototype.getDepthBuffer = function () {
                return this._pDepthBuffer;
            };
            RenderTarget.prototype.attachDepthBuffer = function (pBuffer) {
                var isOk = false;
                if ((isOk = pBuffer.isCompatible(this))) {
                    this.detachDepthBuffer();
                    this._pDepthBuffer = pBuffer;
                    this._pDepthBuffer._notifyRenderTargetAttached(this);
                }
                return isOk;
            };
            RenderTarget.prototype.attachDepthPixelBuffer = function (pBuffer) {
                if (this._iWidth !== pBuffer.width || this._iHeight !== pBuffer.height) {
                    return false;
                }
                var eFormat = pBuffer.format;
                if (eFormat !== akra.EPixelFormats.FLOAT32_DEPTH || eFormat !== akra.EPixelFormats.DEPTH8) {
                    return false;
                }
                this.detachDepthPixelBuffer();
                this._pDepthPixelBuffer = pBuffer;
                return true;
            };
            RenderTarget.prototype.detachDepthPixelBuffer = function () {
                if (this._pDepthPixelBuffer) {
                    this._pDepthPixelBuffer = null;
                }
            };
            RenderTarget.prototype.detachDepthBuffer = function () {
                if (this._pDepthBuffer) {
                    this._pDepthBuffer._notifyRenderTargetDetached(this);
                    this._pDepthBuffer = null;
                }
            };
            RenderTarget.prototype.attachDepthTexture = function (pTexture) {
                return false;
            };
            RenderTarget.prototype.detachDepthTexture = function () {
            };
            RenderTarget.prototype._detachDepthBuffer = function () {
                this._pDepthBuffer = null;
            };
            RenderTarget.prototype._beginUpdate = function () {
                this.preUpdate();
                this._pFrameStats.polygonsCount = 0;
            };
            RenderTarget.prototype._updateAutoUpdatedViewports = function (bUpdateStatistics) {
                if (typeof bUpdateStatistics === "undefined") { bUpdateStatistics = true; }
                var pViewport;
                for(var i in this._pViewportList) {
                    pViewport = this._pViewportList[i];
                    if (pViewport.isAutoUpdated()) {
                        this._updateViewport(pViewport, bUpdateStatistics);
                    }
                }
            };
            RenderTarget.prototype._endUpdate = function () {
                this.postUpdate();
                this.updateStats();
            };
            RenderTarget.prototype._updateViewport = function (pViewportPtr, bUpdateStatistics) {
                if (typeof bUpdateStatistics === "undefined") { bUpdateStatistics = true; }
                var pViewport;
                var iZIndex;
                if ((typeof (arguments[0]) === "number")) {
                    iZIndex = arguments[0];
                    pViewport = this._pViewportList[iZIndex];
 {
                        akra.logger.setSourceLocation("render/RenderTarget.ts", 199);
                        akra.logger.assert(((pViewport) != null), "No viewport with given z-index : %s", iZIndex, "RenderTarget::_updateViewport");
                    }
                    ;
                } else {
                    pViewport = arguments[0];
                }
 {
                    akra.logger.setSourceLocation("render/RenderTarget.ts", 206);
                    akra.logger.assert(pViewport.getTarget() == this, "RenderTarget::_updateViewport the requested viewport is not bound to the rendertarget!");
                }
                ;
                this.viewportPreUpdate(pViewport);
                pViewport.update();
                if (bUpdateStatistics) {
                    this._pFrameStats.polygonsCount += pViewport._getNumRenderedPolygons();
                }
                this.viewportPostUpdate(pViewport);
            };
            RenderTarget.prototype.addViewport = function (pCamera, csRenderMethod, iZIndex, fLeft, fTop, fWidth, fHeight) {
                if (typeof csRenderMethod === "undefined") { csRenderMethod = null; }
                if (typeof iZIndex === "undefined") { iZIndex = 0; }
                if (typeof fLeft === "undefined") { fLeft = 0.; }
                if (typeof fTop === "undefined") { fTop = 0.; }
                if (typeof fWidth === "undefined") { fWidth = 1.; }
                if (typeof fHeight === "undefined") { fHeight = 1.; }
                var pViewport = this._pViewportList[iZIndex];
                if (((pViewport) != null)) {
 {
                        akra.logger.setSourceLocation("render/RenderTarget.ts", 226);
                        akra.logger.criticalError("Can't create another viewport for %s with Z-index %s 					because a viewport exists with this Z-Order already.", this._sName, iZIndex, "RenderTarget::addViewport");
                    }
                    ;
                }
                if ((typeof (arguments[1]) === "number")) {
                    switch(arguments[1]) {
                        case akra.EViewportTypes.DSVIEWPORT:
                            pViewport = new render.DSViewport(pCamera, this, null, fLeft, fTop, fWidth, fHeight, iZIndex);
                            break;
                        case akra.EViewportTypes.SHADOWVIEWPORT:
                            pViewport = new render.ShadowViewport(pCamera, this, null, fLeft, fTop, fWidth, fHeight, iZIndex);
                            break;
                        case akra.EViewportTypes.COLORVIEWPORT:
                            pViewport = new render.ColorViewport(pCamera, this, null, fLeft, fTop, fWidth, fHeight, iZIndex);
                            break;
                        default:
                            pViewport = new render.Viewport(pCamera, this, null, fLeft, fTop, fWidth, fHeight, iZIndex);
                            break;
                    }
                } else {
                    pViewport = new render.Viewport(pCamera, this, csRenderMethod, fLeft, fTop, fWidth, fHeight, iZIndex);
                }
                this._pViewportList[iZIndex] = pViewport;
                this.viewportAdded(pViewport);
                return pViewport;
            };
            RenderTarget.prototype.removeViewport = function (iZIndex) {
                var pViewport = this._pViewportList[iZIndex];
                if (((pViewport) != null)) {
                    this.viewportRemoved(pViewport);
                    this._pViewportList.splice(iZIndex, 1);
                    pViewport = null;
                    return true;
                }
                return false;
            };
            RenderTarget.prototype.removeAllViewports = function () {
                var pViewport;
                var iTotal;
                for(var i in this._pViewportList) {
                    pViewport = this._pViewportList[i];
                    this.viewportRemoved(pViewport);
                }
                iTotal = this._pViewportList.length;
                (this._pViewportList).clear();
                return iTotal;
            };
            RenderTarget.prototype.getStatistics = /** @inline */function () {
                return this._pFrameStats;
            };
            RenderTarget.prototype.getLastFPS = /** @inline */function () {
                return this._pFrameStats.fps.last;
            };
            RenderTarget.prototype.getAverageFPS = /** @inline */function () {
                return this._pFrameStats.fps.avg;
            };
            RenderTarget.prototype.getBestFPS = /** @inline */function () {
                return this._pFrameStats.fps.best;
            };
            RenderTarget.prototype.getWorstFPS = /** @inline */function () {
                return this._pFrameStats.fps.worst;
            };
            RenderTarget.prototype.getPolygonCount = /** @inline */function () {
                return this._pFrameStats.polygonsCount;
            };
            RenderTarget.prototype.getBestFrameTime = /** @inline */function () {
                return this._pFrameStats.time.best;
            };
            RenderTarget.prototype.getWorstFrameTime = /** @inline */function () {
                return this._pFrameStats.time.worst;
            };
            RenderTarget.prototype.resetStatistics = function () {
                var pStats = this._pFrameStats;
                pStats.fps.avg = 0.;
                pStats.fps.best = 0.;
                pStats.fps.last = 0.;
                pStats.fps.worst = 999.;
                pStats.polygonsCount = 0;
                pStats.time.best = 9999999;
                pStats.time.worst = 0;
                //FIXME: get right time!!!
                this._fLastTime = this._pTimer.appTime;
                this._fLastSecond = this._fLastTime;
                this._iFrameCount = 0;
            };
            RenderTarget.prototype.updateStats = function () {
                this._iFrameCount++;
                var fThisTime = this._pTimer.appTime;
                var fFrameTime = fThisTime - this._fLastTime;
                this._pFrameStats.time.best = akra.math.min(this._pFrameStats.time.best, fFrameTime);
                this._pFrameStats.time.worst = akra.math.min(this._pFrameStats.time.worst, fFrameTime);
                if (fThisTime - this._fLastTime > 1.) {
                    this._pFrameStats.fps.last = this._iFrameCount / (fThisTime - this._fLastSecond);
                    if (this._pFrameStats.fps.avg == 0.) {
                        this._pFrameStats.fps.avg = this._pFrameStats.fps.last;
                    } else {
                        this._pFrameStats.fps.avg = (this._pFrameStats.fps.avg + this._pFrameStats.fps.last) / 2.;
                        this._pFrameStats.fps.best = akra.math.max(this._pFrameStats.fps.best, this._pFrameStats.fps.last);
                        this._pFrameStats.fps.worst = akra.math.max(this._pFrameStats.fps.worst, this._pFrameStats.fps.last);
                        this._fLastSecond = fThisTime;
                        this._iFrameCount = 0;
                    }
                    this._fLastTime = fThisTime;
                }
            };
            RenderTarget.prototype.getCustomAttribute = function (sName) {
                return null;
            };
            RenderTarget.prototype.getViewport = function (iIndex) {
 {
                    akra.logger.setSourceLocation("render/RenderTarget.ts", 374);
                    akra.logger.assert(iIndex < this._pViewportList.length, "Index out of bounds");
                }
                ;
                for(var i in this._pViewportList) {
                    if (iIndex--) {
                        continue;
                    }
                    return this._pViewportList[i];
                }
                return null;
            };
            RenderTarget.prototype.getViewportByZIndex = function (iZIndex) {
                var pViewport = this._pViewportList[iZIndex];
 {
                    akra.logger.setSourceLocation("render/RenderTarget.ts", 391);
                    akra.logger.assert(((pViewport) != null), "No viewport with given z-index : " + String(iZIndex), "RenderTarget::getViewportByZIndex");
                }
                ;
                return pViewport;
            };
            RenderTarget.prototype.hasViewportByZIndex = /** @inline */function (iZIndex) {
                return ((this._pViewportList[iZIndex]) != null);
            };
            RenderTarget.prototype.isActive = /** @inline */function () {
                return this._isActive;
            };
            RenderTarget.prototype.setActive = function (bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                this._isActive = bValue;
            };
            RenderTarget.prototype.setAutoUpdated = /** @inline */function (isAutoUpdate) {
                if (typeof isAutoUpdate === "undefined") { isAutoUpdate = true; }
                this._isAutoUpdate = isAutoUpdate;
            };
            RenderTarget.prototype._notifyCameraRemoved = function (pCamera) {
                var isRemoved = false;
                for(var i in this._pViewportList) {
                    var pViewport = this._pViewportList[i];
                    if (pViewport.getCamera() === pCamera) {
                        pViewport.setCamera(null);
                        isRemoved = true;
                    }
                }
                if (isRemoved) {
                    this.cameraRemoved(pCamera);
                }
            };
            RenderTarget.prototype.isAutoUpdated = /** @inline */function () {
                return this._isAutoUpdate;
            };
            RenderTarget.prototype.isPrimary = /** @inline */function () {
                // RenderWindow will override and return true for the primary window
                return false;
            };
            RenderTarget.prototype.update = function () {
                this.updateImpl();
            };
            RenderTarget.prototype.readPixels = function (ppDest, eFramebuffer) {
                return null;
            };
            RenderTarget.prototype.updateImpl = /**@protected*/ function () {
                this._beginUpdate();
                this._updateAutoUpdatedViewports(true);
                this._endUpdate();
            };
            RenderTarget.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            RenderTarget._pEventTable = new akra.events.EventTable();
            RenderTarget.prototype.getEventTable = /** @inline */function () {
                return RenderTarget._pEventTable;
            };
            RenderTarget.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            RenderTarget.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            RenderTarget.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (RenderTarget._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            RenderTarget.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (RenderTarget._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            RenderTarget.prototype._syncTable = /** @inline */function (pFrom) {
                (RenderTarget._pEventTable)._sync(this, pFrom);
            };
            RenderTarget.prototype.preUpdate = function () {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((RenderTarget._pEventTable))).broadcast[(this._iGuid)] = (((RenderTarget._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).preUpdate;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            RenderTarget.prototype.viewportPreUpdate = function (pViewport) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((RenderTarget._pEventTable))).broadcast[(this._iGuid)] = (((RenderTarget._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).viewportPreUpdate;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pViewport) : _broadcast[i].listener(_recivier, pViewport);
                    }
                }
            };
            RenderTarget.prototype.viewportPostUpdate = function (pViewport) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((RenderTarget._pEventTable))).broadcast[(this._iGuid)] = (((RenderTarget._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).viewportPostUpdate;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pViewport) : _broadcast[i].listener(_recivier, pViewport);
                    }
                }
            };
            RenderTarget.prototype.viewportAdded = function (pViewport) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((RenderTarget._pEventTable))).broadcast[(this._iGuid)] = (((RenderTarget._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).viewportAdded;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pViewport) : _broadcast[i].listener(_recivier, pViewport);
                    }
                }
            };
            RenderTarget.prototype.viewportRemoved = function (pViewport) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((RenderTarget._pEventTable))).broadcast[(this._iGuid)] = (((RenderTarget._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).viewportRemoved;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pViewport) : _broadcast[i].listener(_recivier, pViewport);
                    }
                }
            };
            RenderTarget.prototype.postUpdate = function () {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((RenderTarget._pEventTable))).broadcast[(this._iGuid)] = (((RenderTarget._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).postUpdate;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            RenderTarget.prototype.resized = function () {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((RenderTarget._pEventTable))).broadcast[(this._iGuid)] = (((RenderTarget._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).resized;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            RenderTarget.prototype.cameraRemoved = function (pCamera) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((RenderTarget._pEventTable))).broadcast[(this._iGuid)] = (((RenderTarget._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).cameraRemoved;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pCamera) : _broadcast[i].listener(_recivier, pCamera);
                    }
                }
            };
            return RenderTarget;
        })();
        render.RenderTarget = RenderTarget;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        var RenderEntry = (function () {
            function RenderEntry() {
                //target of rendering
                this.viewport = null;
                this.renderTarget = null;
                //wraper for shader program
                this.maker = null;
                //complex info of native shader data
                // + buffers
                // + uniforms
                // + samplers
                this.input = null;
                //needed for call direct render with index
                this.bufferMap = null;
            }
            RenderEntry.prototype.clear = function () {
                this.maker._releaseShaderInput(this.input);
                this.viewport = null;
                this.renderTarget = null;
                this.bufferMap = null;
                this.input = null;
                this.maker = null;
            };
            return RenderEntry;
        })();
        render.RenderEntry = RenderEntry;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        var RenderQueue = (function () {
            function RenderQueue(pRenderer) {
                this._pRenderer = pRenderer;
                this._pEntryList = new akra.util.ObjectArray();
            }
            RenderQueue.prototype.execute = function () {
                this._pRenderer._beginRender();
                for(var i = 0; i < ((this._pEntryList)._iLength); i++) {
                    var pEntry = ((this._pEntryList)._pData[(i)]);
                    this._pRenderer._renderEntry(pEntry);
                    (RenderQueue.releaseEntry((pEntry)));
                }
                this._pEntryList.clear(false);
                this._pRenderer._endRender();
            };
            RenderQueue.prototype.push = function (pEntry) {
                /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this._pEntryList.push(pEntry);
            };
            RenderQueue.prototype.createEntry = /** @inline */function () {
                return RenderQueue.createEntry();
            };
            RenderQueue.prototype.releaseEntry = /** @inline */function (pEntry) {
                return RenderQueue.releaseEntry(pEntry);
            };
            RenderQueue.createEntry = function createEntry() {
                return ((RenderQueue.pool)._iLength) > 0 ? /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/RenderQueue.pool.pop() : new render.RenderEntry();
            };
            RenderQueue.releaseEntry = function releaseEntry(pEntry) {
                /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/RenderQueue.pool.push(pEntry);
                pEntry.clear();
            };
            RenderQueue.pool = new akra.util.ObjectArray();
            return RenderQueue;
        })();
        render.RenderQueue = RenderQueue;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        render.SShaderPrefixes = {
            k_Sampler: "A_s_",
            k_Header: "A_h_",
            k_Attribute: "A_a_",
            k_Offset: "A_o_",
            k_Texture: "TEXTURE",
            k_Texcoord: "TEXCOORD",
            k_Texmatrix: "TEXMATRIX",
            k_Temp: "TEMP_",
            k_BlendType: "AUTO_BLEND_TYPE_"
        };
        render.ZEROSAMPLER = 19;
        render.SSystemSemantics = {
            MODEL_MATRIX: "MODEL_MATRIX",
            VIEW_MATRIX: "VIEW_MATRIX",
            PROJ_MATRIX: "PROJ_MATRIX",
            NORMAL_MATRIX: "NORMAL_MATRIX",
            BIND_MATRIX: "BIND_SHAPE_MATRIX",
            RENDER_OBJECT_ID: "RENDER_OBJECT_ID"
        };
        var Renderer = (function () {
            function Renderer(pEngine) {
                /**@protected*/ this._isActive = false;
                /**@protected*/ this._pRenderTargets = [];
                /**@protected*/ this._pPrioritisedRenderTargets = {};
                /**@protected*/ this._pRenderQueue = null;
                /**@protected*/ this._pActiveViewport = null;
                /**@protected*/ this._pActiveRenderTarget = null;
                /** TODO: FIX RENDER TARGET LOCK*/
                /**@protected*/ this._bLockRenderTarget = false;
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
                this._pEngine = pEngine;
                ((pEngine).getEventTable().addDestination(((((pEngine)))._iGuid), ("active"), (this), ("active"), (undefined)));
                ((pEngine).getEventTable().addDestination(((((pEngine)))._iGuid), ("inactive"), (this), ("inactive"), (undefined)));
                this._pRenderQueue = new render.RenderQueue(this);
            }
            Renderer.prototype.getEngine = /** @inline */function () {
                return this._pEngine;
            };
            Renderer.prototype.hasCapability = function (eCapability) {
                return false;
            };
            Renderer.prototype.debug = function (bValue, useApiTrace) {
                return false;
            };
            Renderer.prototype.isDebug = function () {
                return false;
            };
            Renderer.prototype.isValid = function () {
                return true;
            };
            Renderer.prototype.getError = /** @inline */function () {
                return null;
            };
            Renderer.prototype._beginRender = function () {
            };
            Renderer.prototype._renderEntry = function (pEntry) {
            };
            Renderer.prototype._endRender = function () {
            };
            Renderer.prototype.clearFrameBuffer = function (iBuffer, cColor, fDepth, iStencil) {
            };
            Renderer.prototype.attachRenderTarget = function (pTarget) {
                if (this._pRenderTargets.indexOf(pTarget) != -1) {
                    return false;
                }
                var pList = this._pPrioritisedRenderTargets[pTarget.priority];
                if (!((pList) !== undefined)) {
                    pList = this._pPrioritisedRenderTargets[pTarget.priority] = [];
                }
                pList.push(pTarget);
                this._pRenderTargets.push(pTarget);
                return true;
            };
            Renderer.prototype.detachRenderTarget = function (pTarget) {
                var i = this._pRenderTargets.indexOf(pTarget);
                if (i == -1) {
                    return false;
                }
                this._pRenderTargets.splice(i, 1);
                i = this._pPrioritisedRenderTargets[pTarget.priority].indexOf(pTarget);
                this._pPrioritisedRenderTargets[pTarget.priority].splice(i, 1);
                return true;
            };
            Renderer.prototype.destroyRenderTarget = function (pTarget) {
                var hasTarget = this.detachRenderTarget(pTarget);
                if (hasTarget) {
                    pTarget.destroy();
                    pTarget = null;
                }
            };
            Renderer.prototype.getActiveProgram = function () {
 {
                    akra.logger.setSourceLocation("render/Renderer.ts", 157);
                    akra.logger.criticalError("Renderer::getActiveProgram() is uncompleted method!");
                }
                ;
                return null;
            };
            Renderer.prototype._disableAllTextureUnits = /** @inline */function () {
                /*not inlined, because first statement is not return/call/dot(cur st.: EndCode)*/this._disableTextureUnitsFrom(0);
            };
            Renderer.prototype._disableTextureUnitsFrom = /** @inline */function (iUnit) {
            };
            Renderer.prototype._initRenderTargets = function () {
                // Init stats
                for(var i = 0; i < this._pRenderTargets.length; ++i) {
                    this._pRenderTargets[i].resetStatistics();
                }
            };
            Renderer.prototype._updateAllRenderTargets = function () {
                var pTarget;
                for(var iPriority in this._pPrioritisedRenderTargets) {
                    var pTargetList = this._pPrioritisedRenderTargets[iPriority];
                    for(var j = 0; j < pTargetList.length; ++j) {
                        pTarget = pTargetList[j];
                        if (pTarget.isActive() && pTarget.isAutoUpdated()) {
                            pTarget.update();
                        }
                    }
                }
            };
            Renderer.prototype._setViewport = function (pViewport) {
            };
            Renderer.prototype._setViewportForRender = function (pViewport) {
                var isViewportUpdate = pViewport !== this._pActiveViewport || pViewport.isUpdated();
                var isRenderTargetUpdate = pViewport.getTarget() !== this._pActiveRenderTarget;
                if (isViewportUpdate || isRenderTargetUpdate) {
                    this._setViewport(pViewport);
                    if (isViewportUpdate) {
                        // pViewport._clearForFrame();
                        var pState = pViewport._getViewportState();
                        this._setCullingMode(pState.cullingMode);
                        this._setDepthBufferParams(pState.depthTest, pState.depthWrite, pState.depthFunction, pState.clearDepth);
                    }
                }
            };
            Renderer.prototype._getViewport = function () {
                return this._pActiveViewport;
            };
            Renderer.prototype._setRenderTarget = function (pTarget) {
            };
            Renderer.prototype._setCullingMode = function (eMode) {
            };
            Renderer.prototype._setDepthBufferParams = function (bDepthTest, bDepthWrite, eDepthFunction, fClearDepth) {
            };
            Renderer.prototype.getDefaultCanvas = function () {
                return null;
            };
            Renderer.prototype.createEntry = /** @inline */function () {
                return (/*checked (origin: render)>>*/akra.render.RenderQueue.createEntry());
            };
            Renderer.prototype.releaseEntry = /** @inline */function (pEntry) {
                (/*checked (origin: render)>>*/akra.render.RenderQueue.releaseEntry((pEntry)));
            };
            Renderer.prototype.pushEntry = /** @inline */function (pEntry) {
                this._pRenderQueue.push(pEntry);
            };
            Renderer.prototype.executeQueue = /** @inline */function () {
                this._pRenderQueue.execute();
            };
            Renderer.prototype.lockRenderTarget = /**@protected*/ /** @inline */function () {
                this._bLockRenderTarget = true;
            };
            Renderer.prototype.unlockRenderTarget = /**@protected*/ /** @inline */function () {
                this._bLockRenderTarget = false;
            };
            Renderer.prototype.isLockRenderTarget = /**@protected*/ /** @inline */function () {
                return this._bLockRenderTarget;
            };
            Renderer.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            Renderer._pEventTable = new akra.events.EventTable();
            Renderer.prototype.getEventTable = /** @inline */function () {
                return Renderer._pEventTable;
            };
            Renderer.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Renderer.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Renderer.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (Renderer._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Renderer.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (Renderer._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Renderer.prototype._syncTable = /** @inline */function (pFrom) {
                (Renderer._pEventTable)._sync(this, pFrom);
            };
            Renderer.prototype.active = function (pEngine) {
                this._isActive = true;
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Renderer._pEventTable))).broadcast[(this._iGuid)] = (((Renderer._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).active;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pEngine) : _broadcast[i].listener(_recivier, pEngine);
                    }
                }
                ;
            };
            Renderer.prototype.inactive = function (pEngine) {
                this._isActive = false;
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Renderer._pEventTable))).broadcast[(this._iGuid)] = (((Renderer._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).inactive;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pEngine) : _broadcast[i].listener(_recivier, pEngine);
                    }
                }
                ;
            };
            return Renderer;
        })();
        render.Renderer = Renderer;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
;
var akra;
(function (akra) {
    (function (util) {
        var UtilTimer = (function () {
            function UtilTimer() {
                this.isTimerInitialized = false;
                this.isTimerStopped = false;
                this.fTicksPerSec = 0.;
                this.iStopTime = 0;
                this.iLastElapsedTime = 0;
                this.iBaseTime = 0;
            }
            Object.defineProperty(UtilTimer.prototype, "absoluteTime", {
                get: /** @inline */function () {
                    return this.execCommand(akra.EUtilTimerCommands.TIMER_GET_ABSOLUTE_TIME);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UtilTimer.prototype, "appTime", {
                get: /** @inline */function () {
                    return this.execCommand(akra.EUtilTimerCommands.TIMER_GET_APP_TIME);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UtilTimer.prototype, "elapsedTime", {
                get: /** @inline */function () {
                    return this.execCommand(akra.EUtilTimerCommands.TIMER_GET_ELAPSED_TIME);
                },
                enumerable: true,
                configurable: true
            });
            UtilTimer.prototype.start = /** @inline */function () {
                return this.execCommand(akra.EUtilTimerCommands.TIMER_START) === 0;
            };
            UtilTimer.prototype.stop = /** @inline */function () {
                return this.execCommand(akra.EUtilTimerCommands.TIMER_STOP) === 0;
            };
            UtilTimer.prototype.reset = /** @inline */function () {
                return this.execCommand(akra.EUtilTimerCommands.TIMER_RESET) === 0;
            };
            UtilTimer.prototype.execCommand = function (eCommand) {
                var fTime = 0.;
                var fElapsedTime = 0.;
                var iTime;
                if (this.isTimerInitialized == false) {
                    this.isTimerInitialized = true;
                    this.fTicksPerSec = 1000;
                }
                // Get either the current time or the stop time, depending
                // on whether we're stopped and what command was sent
                if (this.iStopTime != 0 && eCommand != akra.EUtilTimerCommands.TIMER_START && eCommand != akra.EUtilTimerCommands.TIMER_GET_ABSOLUTE_TIME) {
                    iTime = this.iStopTime;
                } else {
                    iTime = (Date.now());
                }
                // Return the elapsed time
                if (eCommand == akra.EUtilTimerCommands.TIMER_GET_ELAPSED_TIME) {
                    fElapsedTime = (iTime - this.iLastElapsedTime) / this.fTicksPerSec;
                    // LOG(iTime - this.iLastElapsedTime,  this.fTicksPerSec, fElapsedTime);
                    this.iLastElapsedTime = iTime;
                    return fElapsedTime;
                }
                // Return the current time
                if (eCommand == akra.EUtilTimerCommands.TIMER_GET_APP_TIME) {
                    var fAppTime = (iTime - this.iBaseTime) / this.fTicksPerSec;
                    return fAppTime;
                }
                // Reset the timer
                if (eCommand == akra.EUtilTimerCommands.TIMER_RESET) {
                    this.iBaseTime = iTime;
                    this.iLastElapsedTime = iTime;
                    this.iStopTime = 0;
                    this.isTimerStopped = false;
                    return 0;
                }
                // Start the timer
                if (eCommand == akra.EUtilTimerCommands.TIMER_START) {
                    if (this.isTimerStopped) {
                        this.iBaseTime += iTime - this.iStopTime;
                    }
                    this.iStopTime = 0;
                    this.iLastElapsedTime = iTime;
                    this.isTimerStopped = false;
                    return 0;
                }
                // Stop the timer
                if (eCommand == akra.EUtilTimerCommands.TIMER_STOP) {
                    if (!this.isTimerStopped) {
                        this.iStopTime = iTime;
                        this.iLastElapsedTime = iTime;
                        this.isTimerStopped = true;
                    }
                    return 0;
                }
                // Advance the timer by 1/10th second
                if (eCommand == akra.EUtilTimerCommands.TIMER_ADVANCE) {
                    this.iStopTime += this.fTicksPerSec / 10;
                    return 0;
                }
                if (eCommand == akra.EUtilTimerCommands.TIMER_GET_ABSOLUTE_TIME) {
                    fTime = iTime / this.fTicksPerSec;
                    return fTime;
                }
                // Invalid command specified
                return -1;
            };
            UtilTimer.start = function start() {
                var pTimer = new UtilTimer();
                if ((pTimer.execCommand(/*checked (origin: akra)>>*/akra.EUtilTimerCommands.TIMER_START) === 0)) {
                    return pTimer;
                }
 {
                    util.logger.setSourceLocation("util/UtilTimer.ts", 124);
                    util.logger.error('cannot start util timer');
                }
                ;
                return null;
            };
            return UtilTimer;
        })();
        util.UtilTimer = UtilTimer;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        var Canvas3d = (function (_super) {
            __extends(Canvas3d, _super);
            function Canvas3d(pRenderer) {
                        _super.call(this, pRenderer);
                // private _useHarwareAntialiasing: bool = false;
                /**@protected*/ this._isFullscreen = false;
                /**@protected*/ this._isPrimary = false;
                /**@protected*/ this._bAutoDeactivatedOnFocusChange = false;
                this.left = 0;
                this.top = 0;
                this._pRenderer = pRenderer;
            }
            Object.defineProperty(Canvas3d.prototype, "type", {
                get: function () {
                    return akra.ECanvasTypes.TYPE_3D;
                },
                enumerable: true,
                configurable: true
            });
            Canvas3d.prototype.create = function (sName, iWidth, iHeight, isFullscreen) {
                if (typeof isFullscreen === "undefined") { isFullscreen = false; }
                return false;
            };
            Canvas3d.prototype.destroy = function () {
            };
            Canvas3d.prototype.setFullscreen = function (isFullscreen) {
            };
            Canvas3d.prototype.setVisible = function (bVisible) {
            };
            Canvas3d.prototype.setDeactivateOnFocusChange = function (bDeactivate) {
                this._bAutoDeactivatedOnFocusChange = bDeactivate;
            };
            Canvas3d.prototype.isFullscreen = /** @inline */function () {
                return this._isFullscreen;
            };
            Canvas3d.prototype.isVisible = function () {
                return true;
            };
            Canvas3d.prototype.isClosed = function () {
                return false;
            };
            Canvas3d.prototype.isPrimary = function () {
                return this._isPrimary;
            };
            Canvas3d.prototype.isDeactivatedOnFocusChange = function () {
                return this._bAutoDeactivatedOnFocusChange;
            };
            Canvas3d.prototype.resize = function (iWidth, iHeight) {
            };
            return Canvas3d;
        })(render.RenderTarget);
        render.Canvas3d = Canvas3d;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLCanvas = (function (_super) {
            __extends(WebGLCanvas, _super);
            function WebGLCanvas(pRenderer) {
                        _super.call(this, pRenderer);
                this._pCanvas = (pRenderer).getHTMLCanvas();
                this._pCanvasCreationInfo = akra.info.canvas(this._pCanvas);
            }
            Object.defineProperty(WebGLCanvas.prototype, "left", {
                get: function () {
                    var el = this._pCanvas;
                    for(var lx = 0; el != null; lx += el.offsetLeft, el = el.offsetParent) {
                        ;
                    }
                    return lx;
                },
                set: function (x) {
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLCanvas.prototype, "top", {
                get: function () {
                    var el = this._pCanvas;
                    for(var ly = 0; el != null; ly += el.offsetTop, el = el.offsetParent) {
                        ;
                    }
                    return ly;
                },
                set: function (x) {
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLCanvas.prototype, "el", {
                get: /** @inline */function () {
                    return this._pCanvas;
                },
                enumerable: true,
                configurable: true
            });
            WebGLCanvas.prototype.create = function (sName, iWidth, iHeight, isFullscreen) {
                if (typeof sName === "undefined") { sName = null; }
                if (typeof iWidth === "undefined") { iWidth = this._pCanvasCreationInfo.width; }
                if (typeof iHeight === "undefined") { iHeight = this._pCanvasCreationInfo.height; }
                if (typeof isFullscreen === "undefined") { isFullscreen = false; }
                ((this)._sName = (sName));
                this.resize(iWidth, iHeight);
                this.setFullscreen(isFullscreen);
                return true;
            };
            WebGLCanvas.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
                this._pCanvas = null;
                this._pCanvasCreationInfo = null;
            };
            WebGLCanvas.prototype.getCustomAttribute = function (sName) {
                // if(sName === "FBO") {
                // 	return null;
                // }
                return null;
            };
            WebGLCanvas.prototype.setFullscreen = function (isFullscreen) {
                if (typeof isFullscreen === "undefined") { isFullscreen = true; }
                var _this = this;
                var pCanvasElement = this._pCanvas;
                var pScreen;
                var pCanvasInfo;
                var iRealWidth = this._iRealWidth;
                var iRealHeight = this._iRealHeight;
                var pCanvas = this;
                if (this._isFullscreen === isFullscreen) {
                    return;
                }
                if (WebGLCanvas.fullscreenLock) {
 {
                        akra.logger.setSourceLocation("WebGLCanvas.ts", 84);
                        akra.logger.warning("fullscreen is changing, do not try change before process will be ended");
                    }
                    ;
                    return;
                }
                this._isFullscreen = isFullscreen;
                if (isFullscreen) {
                    iRealWidth = this._iRealWidth = this._iWidth;
                    iRealHeight = this._iRealHeight = this._iHeight;
                }
                var el = pCanvasElement, doc = document, rfs = el.requestFullScreen || el.webkitRequestFullScreen || el.mozRequestFullScreen;
                try  {
                    WebGLCanvas.fullscreenLock = true;
                    if (isFullscreen) {
                        rfs.call(el);
                    }
                    el.onfullscreenchange = el.onmozfullscreenchange = el.onwebkitfullscreenchange = el.onfullscreenchange || /** @inline */function (e) {
                        if (!!(doc.webkitFullscreenElement || doc.mozFullScreenElement || doc.fullscreenElement)) {
                            pCanvas.resize(akra.info.screen.width, akra.info.screen.height);
                        } else {
                            _this.setFullscreen(false);
                            pCanvas.resize(iRealWidth, iRealHeight);
                        }
                        WebGLCanvas.fullscreenLock = false;
                    };
                } catch (e) {
 {
                        akra.logger.setSourceLocation("WebGLCanvas.ts", 127);
                        akra.logger.error("Fullscreen API not supported", e);
                    }
                    ;
                    throw e;
                }
            };
            WebGLCanvas.prototype.isVisible = /** @inline */function () {
                return this._pCanvas.style.display !== "none";
            };
            WebGLCanvas.prototype.setVisible = function (bVisible) {
                if (typeof bVisible === "undefined") { bVisible = true; }
                this._pCanvas.style.display = bVisible ? "block" : "none";
            };
            WebGLCanvas.prototype.resize = function (iWidth, iHeight) {
                if (typeof iWidth === "undefined") { iWidth = this._iWidth; }
                if (typeof iHeight === "undefined") { iHeight = this._iHeight; }
                // LOG(__CALLSTACK__, iWidth, iHeight);
                var pCanvas = this._pCanvas;
                this._iWidth = iWidth;
                this._iHeight = iHeight;
                pCanvas.width = iWidth;
                pCanvas.height = iHeight;
                // var pRoot: ISceneNode = this.getScene().getRootNode();
                // //TODO: update textures, lighting etc!
                // pRoot.explore(function(pNode: INode) {
                // 	var pCamera: ICamera;
                // 	if (pNode.type === EEntityTypes.CAMERA) {
                // 		pCamera = (<ICamera>pNode);
                // 		if (!pCamera.isConstantAspect()) {
                // 			pCamera.setProjParams(
                // 				pCamera.fov(),
                // 				pCanvas.width / pCanvas.height,
                // 				pCamera.nearPlane(),
                // 				pCamera.farPlane());
                // 			pCamera.setUpdatedLocalMatrixFlag();
                // 		}
                // 	}
                // });
                this.resized();
            };
            WebGLCanvas.prototype.readPixels = function (ppDest, eFramebuffer) {
                if (typeof ppDest === "undefined") { ppDest = null; }
                if (typeof eFramebuffer === "undefined") { eFramebuffer = akra.EFramebuffer.AUTO; }
                if (((ppDest) === null)) {
                    var ePixelFormat = akra.EPixelFormats.BYTE_RGB;
                    ppDest = new akra.pixelUtil.PixelBox(this._iWidth, this._iHeight, 1, ePixelFormat, new Uint8Array(akra.pixelUtil.getMemorySize(this._iWidth, this._iHeight, 1, ePixelFormat)));
                }
                if ((ppDest.right > this._iWidth) || (ppDest.bottom > this._iHeight) || (ppDest.front != 0) || (ppDest.back != 1)) {
 {
                        akra.logger.setSourceLocation("WebGLCanvas.ts", 182);
                        akra.logger.criticalError("Invalid box.", "GLXWindow::copyContentsToMemory");
                    }
                    ;
                }
                if (eFramebuffer == akra.EFramebuffer.AUTO) {
                    eFramebuffer = this._isFullscreen ? akra.EFramebuffer.FRONT : akra.EFramebuffer.BACK;
                }
                var eFormat = webgl.getWebGLFormat(ppDest.format);
                var eType = webgl.getWebGLDataType(ppDest.format);
                if (eFormat == 0 || eType == 0) {
 {
                        akra.logger.setSourceLocation("WebGLCanvas.ts", 193);
                        akra.logger.criticalError("Unsupported format.", "WebGLCanvas::readPixels");
                    }
                    ;
                }
                var pWebGLRenderer = ((this)._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                pWebGLRenderer._setViewport(this.getViewport(0));
                (pWebGLRenderer._pWebGLContext.bindFramebuffer((0x8D40), (null)));
                // Must change the packing to ensure no overruns!
                pWebGLContext.pixelStorei(0x0D05, 1);
                //glReadBuffer((buffer == FB_FRONT)? GL_FRONT : GL_BACK);
                /*ppDest.data,*/
                 {
                    akra.logger.setSourceLocation("WebGLCanvas.ts", 206);
                    akra.logger.log("readPixels(", ppDest.left, ppDest.top, ppDest.width, ppDest.height, eFormat, eType, ")");
                }
                ;
                pWebGLContext.readPixels(ppDest.left, ppDest.top, ppDest.width, ppDest.height, eFormat, eType, ppDest.data);
                // restore default alignment
                pWebGLContext.pixelStorei(0x0D05, 4);
                //vertical flip
                // {
                // 	size_t rowSpan = dst.getWidth() * PixelUtil::getNumElemBytes(dst.format);
                // 	size_t height = dst.getHeight();
                // 	uchar *tmpData = new uchar[rowSpan * height];
                // 	uchar *srcRow = (uchar *)dst.data, *tmpRow = tmpData + (height - 1) * rowSpan;
                // 	while (tmpRow >= tmpData)
                // 	{
                // 		memcpy(tmpRow, srcRow, rowSpan);
                // 		srcRow += rowSpan;
                // 		tmpRow -= rowSpan;
                // 	}
                // 	memcpy(dst.data, tmpData, rowSpan * height);
                // 	delete [] tmpData;
                // }
                return ppDest;
            };
            WebGLCanvas.fullscreenLock = false;
            return WebGLCanvas;
        })(akra.render.Canvas3d);
        webgl.WebGLCanvas = WebGLCanvas;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLShaderProgram = (function (_super) {
            __extends(WebGLShaderProgram, _super);
            function WebGLShaderProgram() {
                _super.apply(this, arguments);

                /**@protected*/ this._iTotalAttributes = 0;
            }
            WebGLShaderProgram.prototype.create = function (csVertex, csPixel) {
                if (arguments.length > 0) {
                    return this.compile(csVertex || "void main(void){gl_Position = vec4(0., 0., 0., 1.);}", csPixel || "void main(void){}");
                }
                return false;
            };
            WebGLShaderProgram.prototype.destroy = function () {
                ((this._pWebGLRenderer)._pWebGLContext.deleteProgram((this._pWebGLProgram)));
                this._pWebGLUniformLocations = null;
                this._pWebGLAttributeLocations = null;
                this._pWebGLAttributesInfo = null;
                /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyDestroyed();
                /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyDisabled();
            };
            WebGLShaderProgram.prototype.compile = function (csVertex, csPixel) {
                if (typeof csVertex === "undefined") { csVertex = "void main(void){gl_Position = vec4(0., 0., 0., 1.);}"; }
                if (typeof csPixel === "undefined") { csPixel = "void main(void){}"; }
                var pWebGLRenderer = this._pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = this._pWebGLContext = (pWebGLRenderer._pWebGLContext);
                var pWebGLProgram = this._pWebGLProgram = (pWebGLRenderer._pWebGLContext.createProgram());
                var pWebGLVs = this.createWebGLShader(0x8B31, csVertex);
                var pWebGLFs = this.createWebGLShader(0x8B30, csPixel);
                // (<any>this)._debuginfo = {vs: csVertex, ps: csPixel};
                /** because, if not all units correctly activated, can obtained wronf link status */
                (/*not inlined, because first statement is not return/call/dot(cur st.: EndCode)*/pWebGLRenderer._disableTextureUnitsFrom(0));
                pWebGLContext.attachShader(pWebGLProgram, pWebGLVs);
                pWebGLContext.attachShader(pWebGLProgram, pWebGLFs);
                pWebGLContext.linkProgram(pWebGLProgram);
                // LOG("================================", this.findResourceName());
                // LOG(pWebGLContext.getShaderSource(pWebGLVs));
                // LOG(pWebGLContext.getShaderSource(pWebGLFs));
                if (!this.isLinked()) {
 {
                        akra.logger.setSourceLocation("WebGLShaderProgram.ts", 71);
                        akra.logger.error("cannot link GLSL program(guid: %d)", ((this)._iGuid));
                    }
                    ;
                    var sInfo = pWebGLContext.getProgramInfoLog(pWebGLProgram);
 {
                        akra.logger.setSourceLocation("WebGLShaderProgram.ts", 76);
                        akra.logger.log("shader program errors: \n" + sInfo);
                    }
                    ;
                    //+ "\n\nvertex code:\n"  + csVertex + "\n\n pixel code: " + csPixel);
                    if (webgl.loadExtension(pWebGLContext, "WEBGL_debug_shaders")) {
 {
                            akra.logger.setSourceLocation("WebGLShaderProgram.ts", 83);
                            akra.logger.log("translated(from GLSL) VS shader: \n" + pWebGLContext.getExtension("WEBGL_debug_shaders").getTranslatedShaderSource(pWebGLVs) + "\ntranslated(from GLSL) PS shader: \n" + pWebGLContext.getExtension("WEBGL_debug_shaders").getTranslatedShaderSource(pWebGLFs));
                        }
                        ;
                    }
                    return false;
                }
                pWebGLContext.validateProgram(pWebGLProgram);
                if (!this.isValid()) {
 {
                        akra.logger.setSourceLocation("WebGLShaderProgram.ts", 93);
                        akra.logger.warning("GLSL program not valid(guid: %d)", ((this)._iGuid));
                    }
                    ;
 {
                        akra.logger.setSourceLocation("WebGLShaderProgram.ts", 95);
                        akra.logger.log(pWebGLContext.getProgramInfoLog(pWebGLProgram));
                    }
                    ;
                }
                this.obtainWebGLUniforms();
                this.obtainWebGLAttributes();
                /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyCreated();
                /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyRestored();
                return true;
            };
            Object.defineProperty(WebGLShaderProgram.prototype, "totalAttributes", {
                get: /** @inline */function () {
                    return this._iTotalAttributes;
                },
                enumerable: true,
                configurable: true
            });
            WebGLShaderProgram.prototype._getActiveUniformNames = /** @inline */function () {
                return Object.keys(this._pWebGLUniformLocations);
            };
            WebGLShaderProgram.prototype._getActiveAttributeNames = /** @inline */function () {
                return Object.keys(this._pWebGLAttributeLocations);
            };
            WebGLShaderProgram.prototype._getActiveAttribLocations = /** @inline */function () {
                return this._pWebGLAttributeLocations;
            };
            WebGLShaderProgram.prototype.isLinked = function () {
                return ((this._pWebGLProgram) != null) && this._pWebGLContext.getProgramParameter(this._pWebGLProgram, 0x8B82);
            };
            WebGLShaderProgram.prototype.isValid = function () {
                return ((this._pWebGLProgram) != null) && this._pWebGLContext.getProgramParameter(this._pWebGLProgram, 0x8B83);
            };
            WebGLShaderProgram.prototype.isActive = function () {
                return (((this._pWebGLProgram) != null) && this._pWebGLContext.getParameter(0x8B8D) === this._pWebGLProgram);
            };
            WebGLShaderProgram.prototype.setFloat = /** @inline */function (sName, fValue) {
                this._pWebGLContext.uniform1f(this._pWebGLUniformLocations[sName], fValue);
            };
            WebGLShaderProgram.prototype.setInt = /** @inline */function (sName, iValue) {
                this._pWebGLContext.uniform1i(this._pWebGLUniformLocations[sName], iValue);
            };
            WebGLShaderProgram.prototype.setVec2 = // inline setBool(sName: string, bValue: bool): void {
            //     this.setInt(sName, bValue )
            // }
            function (sName, v2fValue) {
                this._pWebGLContext.uniform2f(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y);
            };
            WebGLShaderProgram.prototype.setVec2i = function (sName, v2iValue) {
                this._pWebGLContext.uniform2i(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y);
            };
            WebGLShaderProgram.prototype.setVec3 = function (sName, v3fValue) {
                this._pWebGLContext.uniform3f(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z);
            };
            WebGLShaderProgram.prototype.setVec3i = function (sName, v3iValue) {
                this._pWebGLContext.uniform3i(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z);
            };
            WebGLShaderProgram.prototype.setVec4 = function (sName, v4fValue) {
                this._pWebGLContext.uniform4f(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z, arguments[1].w);
            };
            WebGLShaderProgram.prototype.setVec4i = function (sName, v4iValue) {
                this._pWebGLContext.uniform4i(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z, arguments[1].w);
            };
            WebGLShaderProgram.prototype.setMat3 = // setVec2(sName: string, v2fValue: IVec2): void;
            // setVec2(sName: string, x: float, y: float): void;
            // inline setVec2(sName: string, x?, y?): void {
            // 	(arguments.length == 2)?
            // 	  this._pWebGLContext.uniform2f(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y):
            // 	  this._pWebGLContext.uniform2f(this._pWebGLUniformLocations[sName], arguments[1], arguments[2]);
            // }
            // setVec2i(sName: string, v2iValue: IVec2): void;
            // setVec2i(sName: string, x: int, y: int): void;
            // inline setVec2i(sName: string, x?, y?): void {
            // 	(arguments.length == 2)?
            // 	  this._pWebGLContext.uniform2i(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y):
            // 	  this._pWebGLContext.uniform2i(this._pWebGLUniformLocations[sName], arguments[1], arguments[2]);
            // }
            // setVec3(sName: string, v3fValue: IVec3): void;
            // setVec3(sName: string, x: float, y: float, z: float): void;
            // inline setVec3(sName: string, x?, y?, z?): void {
            // 	(arguments.length == 2)?
            // 	  this._pWebGLContext.uniform3f(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z):
            // 	  this._pWebGLContext.uniform3f(this._pWebGLUniformLocations[sName], arguments[1], arguments[2], arguments[3]);
            // }
            // setVec3i(sName: string, v3iValue: IVec3): void;
            // setVec3i(sName: string, x: int, y: int, z: int): void;
            // inline setVec3i(sName: string, x?, y?, z?): void {
            // 	(arguments.length == 2)?
            // 		this._pWebGLContext.uniform3i(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z):
            // 		this._pWebGLContext.uniform3i(this._pWebGLUniformLocations[sName], arguments[1], arguments[2], arguments[3]);
            // }
            // setVec4(sName: string, v4fValue: IVec4): void;
            // setVec4(sName: string, x: float, y: float, z: float, w: float): void;
            // inline setVec4(sName: string, x?, y?, z?, w?): void {
            // 	(arguments.length == 2) ?
            // 	  this._pWebGLContext.uniform4f(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z, arguments[1].w):
            // 	  this._pWebGLContext.uniform4f(this._pWebGLUniformLocations[sName], arguments[1], arguments[2], arguments[3], arguments[3]);
            // }
            // setVec4i(sName: string, v4iValue: IVec4): void;
            // setVec4i(sName: string, x: int, y: int, z: int, w: int): void;
            // inline setVec4i(sName: string, x?, y?, z?, w?): void {
            // 	(arguments.length == 2)?
            // 		this._pWebGLContext.uniform4i(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z, arguments[1].w):
            // 		this._pWebGLContext.uniform4i(this._pWebGLUniformLocations[sName], arguments[1], arguments[2], arguments[3], arguments[3])
            // }
            /** @inline */function (sName, m3fValue) {
                this._pWebGLContext.uniformMatrix3fv(this._pWebGLUniformLocations[sName], false, m3fValue.data);
            };
            WebGLShaderProgram.prototype.setMat4 = function (sName, m4fValue) {
                this._pWebGLContext.uniformMatrix4fv(this._pWebGLUniformLocations[sName], false, m4fValue.data);
            };
            WebGLShaderProgram.prototype.setFloat32Array = /** @inline */function (sName, pValue) {
                this._pWebGLContext.uniform1fv(this._pWebGLUniformLocations[sName], pValue);
            };
            WebGLShaderProgram.prototype.setInt32Array = /** @inline */function (sName, pValue) {
                this._pWebGLContext.uniform1iv(this._pWebGLUniformLocations[sName], pValue);
            };
            WebGLShaderProgram.uniformBuffer = new ArrayBuffer(4096 * 16);
            WebGLShaderProgram.prototype.setVec2Array = /** @inline */function (sName, pValue) {
                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 2);
                for(var i = 0, j = 0; j < pValue.length; i += 2, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                }
                this._pWebGLContext.uniform2fv(this._pWebGLUniformLocations[sName], pBuffer);
            };
            WebGLShaderProgram.prototype.setVec2iArray = /** @inline */function (sName, pValue) {
                var pBuffer = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 2);
                for(var i = 0, j = 0; j < pValue.length; i += 2, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                }
                this._pWebGLContext.uniform2iv(this._pWebGLUniformLocations[sName], pBuffer);
            };
            WebGLShaderProgram.prototype.setVec3Array = /** @inline */function (sName, pValue) {
                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 3);
                for(var i = 0, j = 0; j < pValue.length; i += 3, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                    pBuffer[i + 2] = pValue[j].z;
                }
                this._pWebGLContext.uniform3fv(this._pWebGLUniformLocations[sName], pBuffer);
            };
            WebGLShaderProgram.prototype.setVec3iArray = /** @inline */function (sName, pValue) {
                var pBuffer = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 3);
                for(var i = 0, j = 0; j < pValue.length; i += 3, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                    pBuffer[i + 2] = pValue[j].z;
                }
                this._pWebGLContext.uniform3iv(this._pWebGLUniformLocations[sName], pBuffer);
            };
            WebGLShaderProgram.prototype.setVec4Array = /** @inline */function (sName, pValue) {
                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 4);
                for(var i = 0, j = 0; j < pValue.length; i += 4, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                    pBuffer[i + 2] = pValue[j].z;
                    pBuffer[i + 3] = pValue[j].w;
                }
                this._pWebGLContext.uniform4fv(this._pWebGLUniformLocations[sName], pBuffer);
            };
            WebGLShaderProgram.prototype.setVec4iArray = /** @inline */function (sName, pValue) {
                var pBuffer = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 4);
                for(var i = 0, j = 0; j < pValue.length; i += 4, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                    pBuffer[i + 2] = pValue[j].z;
                    pBuffer[i + 3] = pValue[j].w;
                }
                this._pWebGLContext.uniform4iv(this._pWebGLUniformLocations[sName], pBuffer);
            };
            WebGLShaderProgram.prototype.setMat3Array = /** @inline */function (sName, pValue) {
                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 9);
                for(var i = 0; i < pValue.length; i++) {
                    pBuffer.set(pValue[i].data, 9 * i);
                }
                this._pWebGLContext.uniformMatrix3fv(this._pWebGLUniformLocations[sName], false, pBuffer);
            };
            WebGLShaderProgram.prototype.setMat4Array = /** @inline */function (sName, pValue) {
                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 16);
                for(var i = 0; i < pValue.length; i++) {
                    pBuffer.set(pValue[i].data, 16 * i);
                }
                this._pWebGLContext.uniformMatrix4fv(this._pWebGLUniformLocations[sName], false, pBuffer);
            };
            WebGLShaderProgram.prototype.setStruct = /** @inline */function (sName, pData) {
            };
            WebGLShaderProgram.prototype.setSampler = /** @inline */function (sName, pSampler) {
                var iSlot = this.applySamplerState(pSampler);
                ((this)._pWebGLContext.uniform1i((this)._pWebGLUniformLocations[(sName)], (iSlot)));
            };
            WebGLShaderProgram.prototype.setVertexBuffer = /** @inline */function (sName, pBuffer) {
                // var iSlot: uint = this._pWebGLRenderer.getNextTextureSlot();
                // this._pWebGLRenderer.activateWebGLTexture(iSlot + GL_TEXTURE0);
                // WARNING(iSlot);
                // var iSlot: uint = this._pWebGLRenderer.activateWebGLTextureInAutoSlot(GL_TEXTURE_2D, null);
                // this._pWebGLRenderer.bindWebGLTexture(GL_TEXTURE_2D, (<WebGLVertexTexture>pBuffer).getWebGLTexture());
                var iSlot = this._pWebGLRenderer.activateWebGLTextureInAutoSlot(0x0DE1, (((pBuffer))._pWebGLTexture));
                ((this)._pWebGLContext.uniform1i((this)._pWebGLUniformLocations[(sName)], (iSlot)));
            };
            WebGLShaderProgram.prototype.setSamplerArray = /** @inline */function (sName, pList) {
                var pBuffer = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pList.length);
                for(var i = 0; i < pList.length; ++i) {
                    pBuffer[i] = this.applySamplerState(pList[i]);
                }
                ((this)._pWebGLContext.uniform1iv((this)._pWebGLUniformLocations[(sName)], (pBuffer)));
            };
            WebGLShaderProgram.prototype.setTexture = /** @inline */function (sName, pData) {
            };
            WebGLShaderProgram.prototype.applySamplerState = function (pSampler) {
                var pTexture = pSampler.texture;
                if (((pTexture) === null)) {
                    return;
                }
                var iSlot = this._pWebGLRenderer.activateWebGLTextureInAutoSlot(pTexture._getWebGLTextureTarget(), (pTexture._pWebGLTexture));
                // var iSlot: int = this._pWebGLRenderer.getNextTextureSlot();
                // this._pWebGLRenderer.activateWebGLTexture(iSlot + GL_TEXTURE0);
                // this._pWebGLRenderer.bindWebGLTexture(pTexture._getWebGLTextureTarget(), null);
                // this._pWebGLRenderer.bindWebGLTexture(pTexture._getWebGLTextureTarget(), pTexture.getWebGLTexture());
                pTexture._setFilterInternalTexture(akra.ETextureParameters.MAG_FILTER, pSampler.mag_filter);
                pTexture._setFilterInternalTexture(akra.ETextureParameters.MIN_FILTER, pSampler.min_filter);
                pTexture._setWrapModeInternalTexture(akra.ETextureParameters.WRAP_S, pSampler.wrap_s);
                pTexture._setWrapModeInternalTexture(akra.ETextureParameters.WRAP_T, pSampler.wrap_t);
                return iSlot;
            };
            WebGLShaderProgram.prototype.applyVertexData = //applyVertexBuffer(sName: string, pBuffer: IVertexBuffer);
            function (sName, pData) {
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                ;
                var pVertexBuffer = pData.buffer;
                var iStride = pData.stride;
                if (pVertexBuffer.type !== akra.EVertexBufferTypes.VBO) {
                    return false;
                }
                var pVertexDecl = pData.getVertexDeclaration();
                var pVertexElement;
                var iLoc;
                for(var i = 0; i < pVertexDecl.length; ++i) {
                    pVertexElement = pVertexDecl[i];
                    iLoc = ((((this)._pWebGLAttributeLocations[(pVertexElement.usage)]) !== undefined) ? (this)._pWebGLAttributeLocations[(pVertexElement.usage)] : -1);
                    if (iLoc < 0) {
 {
                            akra.logger.setSourceLocation("WebGLShaderProgram.ts", 417);
                            akra.logger.warning("founded invalid GLSL attribute location(guid: %s): %s", ((this)._iGuid), pVertexElement.usage);
                        }
                        ;
                        continue;
                    }
                    (pWebGLRenderer._pWebGLContext.bindBuffer((0x8892), ((((pVertexBuffer))._pWebGLBuffer))));
                    pWebGLContext.vertexAttribPointer(iLoc, pVertexElement.count, pVertexElement.type, false, iStride, pVertexElement.offset);
                }
                return true;
            };
            WebGLShaderProgram.prototype._setFloat = /** @inline */function (pWebGLUniformLocation, fValue) {
                this._pWebGLContext.uniform1f(pWebGLUniformLocation, fValue);
            };
            WebGLShaderProgram.prototype._setInt = /** @inline */function (pWebGLUniformLocation, iValue) {
                this._pWebGLContext.uniform1i(pWebGLUniformLocation, iValue);
            };
            WebGLShaderProgram.prototype._setVec2 = function (pWebGLUniformLocation, v2fValue) {
                this._pWebGLContext.uniform2f(pWebGLUniformLocation, v2fValue.x, v2fValue.y);
            };
            WebGLShaderProgram.prototype._setVec2i = function (pWebGLUniformLocation, v2iValue) {
                this._pWebGLContext.uniform2i(pWebGLUniformLocation, v2iValue.x, v2iValue.y);
            };
            WebGLShaderProgram.prototype._setVec3 = function (pWebGLUniformLocation, v3fValue) {
                this._pWebGLContext.uniform3f(pWebGLUniformLocation, v3fValue.x, v3fValue.y, v3fValue.z);
            };
            WebGLShaderProgram.prototype._setVec3i = function (pWebGLUniformLocation, v3iValue) {
                this._pWebGLContext.uniform3i(pWebGLUniformLocation, v3iValue.x, v3iValue.y, v3iValue.z);
            };
            WebGLShaderProgram.prototype._setVec4 = function (pWebGLUniformLocation, v4fValue) {
                this._pWebGLContext.uniform4f(pWebGLUniformLocation, v4fValue.x, v4fValue.y, v4fValue.z, v4fValue.w);
            };
            WebGLShaderProgram.prototype._setVec4i = function (pWebGLUniformLocation, v4iValue) {
                this._pWebGLContext.uniform4i(pWebGLUniformLocation, v4iValue.x, v4iValue.y, v4iValue.z, v4iValue.w);
            };
            WebGLShaderProgram.prototype._setMat3 = /** @inline */function (pWebGLUniformLocation, m3fValue) {
                this._pWebGLContext.uniformMatrix3fv(pWebGLUniformLocation, false, m3fValue.data);
            };
            WebGLShaderProgram.prototype._setMat4 = function (pWebGLUniformLocation, m4fValue) {
                this._pWebGLContext.uniformMatrix4fv(pWebGLUniformLocation, false, m4fValue.data);
            };
            WebGLShaderProgram.prototype._setFloat32Array = /** @inline */function (pWebGLUniformLocation, pValue) {
                this._pWebGLContext.uniform1fv(pWebGLUniformLocation, pValue);
            };
            WebGLShaderProgram.prototype._setInt32Array = /** @inline */function (pWebGLUniformLocation, pValue) {
                !((pValue) === null) && this._pWebGLContext.uniform1iv(pWebGLUniformLocation, pValue);
            };
            WebGLShaderProgram.prototype._setVec2Array = /** @inline */function (pWebGLUniformLocation, pValue) {
                if (((pValue) === null)) {
                    return;
                }
                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 2);
                for(var i = 0, j = 0; j < pValue.length; i += 2, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                }
                this._pWebGLContext.uniform2fv(pWebGLUniformLocation, pBuffer);
            };
            WebGLShaderProgram.prototype._setVec2iArray = /** @inline */function (pWebGLUniformLocation, pValue) {
                var pBuffer = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 2);
                for(var i = 0, j = 0; j < pValue.length; i += 2, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                }
                this._pWebGLContext.uniform2iv(pWebGLUniformLocation, pBuffer);
            };
            WebGLShaderProgram.prototype._setVec3Array = /** @inline */function (pWebGLUniformLocation, pValue) {
                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 3);
                for(var i = 0, j = 0; i < pValue.length; i += 3, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                    pBuffer[i + 2] = pValue[j].z;
                }
                this._pWebGLContext.uniform3fv(pWebGLUniformLocation, pBuffer);
            };
            WebGLShaderProgram.prototype._setVec3iArray = /** @inline */function (pWebGLUniformLocation, pValue) {
                var pBuffer = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 3);
                for(var i = 0, j = 0; i < pValue.length; i += 3, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                    pBuffer[i + 2] = pValue[j].z;
                }
                this._pWebGLContext.uniform3iv(pWebGLUniformLocation, pBuffer);
            };
            WebGLShaderProgram.prototype._setVec4Array = /** @inline */function (pWebGLUniformLocation, pValue) {
                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 4);
                for(var i = 0, j = 0; i < pValue.length; i += 4, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                    pBuffer[i + 2] = pValue[j].z;
                    pBuffer[i + 3] = pValue[j].w;
                }
                this._pWebGLContext.uniform4fv(pWebGLUniformLocation, pBuffer);
            };
            WebGLShaderProgram.prototype._setVec4iArray = /** @inline */function (pWebGLUniformLocation, pValue) {
                var pBuffer = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 4);
                for(var i = 0, j = 0; i < pValue.length; i += 4, ++j) {
                    pBuffer[i] = pValue[j].x;
                    pBuffer[i + 1] = pValue[j].y;
                    pBuffer[i + 2] = pValue[j].z;
                    pBuffer[i + 3] = pValue[j].w;
                }
                this._pWebGLContext.uniform4iv(pWebGLUniformLocation, pBuffer);
            };
            WebGLShaderProgram.prototype._setMat3Array = /** @inline */function (pWebGLUniformLocation, pValue) {
                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 9);
                for(var i = 0; i < pValue.length; i++) {
                    pBuffer.set(pValue[i].data, 9 * i);
                }
                this._pWebGLContext.uniformMatrix3fv(pWebGLUniformLocation, false, pBuffer);
            };
            WebGLShaderProgram.prototype._setMat4Array = /** @inline */function (pWebGLUniformLocation, pValue) {
                var pBuffer = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 16);
                for(var i = 0; i < pValue.length; i++) {
                    pBuffer.set(pValue[i].data, 16 * i);
                }
                this._pWebGLContext.uniformMatrix4fv(pWebGLUniformLocation, false, pBuffer);
            };
            WebGLShaderProgram.prototype._setSampler = /** @inline */function (pWebGLUniformLocation, pSampler) {
                var iSlot = this.applySamplerState(pSampler);
                ((this)._pWebGLContext.uniform1i((pWebGLUniformLocation), (iSlot)));
            };
            WebGLShaderProgram.prototype._setVertexBuffer = /** @inline */function (pWebGLUniformLocation, pBuffer) {
                // var iSlot: uint = this._pWebGLRenderer.getNextTextureSlot();
                // this._pWebGLRenderer.activateWebGLTexture(iSlot + GL_TEXTURE0);
                // WARNING(iSlot);
                // var iSlot: uint = this._pWebGLRenderer.activateWebGLTextureInAutoSlot(GL_TEXTURE_2D, null);
                // this._pWebGLRenderer.bindWebGLTexture(GL_TEXTURE_2D, (<WebGLVertexTexture>pBuffer).getWebGLTexture());
                var iSlot = this._pWebGLRenderer.activateWebGLTextureInAutoSlot(0x0DE1, (((pBuffer))._pWebGLTexture));
                ((this)._pWebGLContext.uniform1i((pWebGLUniformLocation), (iSlot)));
            };
            WebGLShaderProgram.prototype._setSamplerArray = /** @inline */function (pWebGLUniformLocation, pList) {
                var pBuffer = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pList.length);
                for(var i = 0; i < pList.length; ++i) {
                    pBuffer[i] = this.applySamplerState(pList[i]);
                }
                /*not inlined, because first statement is not return/call/dot(cur st.: LogAnd)*/this._setInt32Array(pWebGLUniformLocation, pBuffer);
            };
            WebGLShaderProgram.prototype.applyBufferMap = /** @inline */function (pMap) {
 {
                    akra.logger.setSourceLocation("WebGLShaderProgram.ts", 609);
                    akra.logger.criticalError("WebGLShaderProgram::applyBufferMap() is uncompleted method!");
                }
                ;
            };
            WebGLShaderProgram.prototype.getWebGLAttributeLocation = /** @inline */function (sName) {
                return ((this._pWebGLAttributeLocations[sName]) !== undefined) ? this._pWebGLAttributeLocations[sName] : -1;
            };
            WebGLShaderProgram.prototype.getWebGLUniformLocations = /** @inline */function () {
                return this._pWebGLUniformLocations;
            };
            WebGLShaderProgram.prototype.getWebGLUniformLocation = /** @inline */function (sName) {
                var iLoc = this._pWebGLUniformLocations[sName];
                if (!((iLoc) !== undefined)) {
 {
                        akra.logger.setSourceLocation("WebGLShaderProgram.ts", 626);
                        akra.logger.warning("could not find location for GLSL attribute(guid: %s): %s", ((this)._iGuid), sName);
                    }
                    ;
                }
                return iLoc;
            };
            WebGLShaderProgram.prototype.getWebGLProgram = /** @inline */function () {
                return this._pWebGLProgram;
            };
            WebGLShaderProgram.prototype.getTranslatedShaderCode = function (eWebGLType) {
                var sReturn = "";
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                if (!webgl.loadExtension(pWebGLContext, "WEBGL_debug_shaders")) {
                    return null;
                }
                var pWebGLShaderList = pWebGLContext.getAttachedShaders(this._pWebGLProgram);
                for(var i = 0; i < pWebGLShaderList.length; i++) {
                    var eShaderType = pWebGLContext.getShaderParameter(pWebGLShaderList[i], 0x8B4F);
                    if (eShaderType === eWebGLType) {
                        sReturn = pWebGLContext.getExtension("WEBGL_debug_shaders").getTranslatedShaderSource(pWebGLShaderList[i]);
                        break;
                    }
                }
                return sReturn;
            };
            WebGLShaderProgram.prototype.printTranslatedShaderCode = function (eWebGLType) {
                if (typeof eWebGLType === "undefined") { eWebGLType = -1; }
                if (eWebGLType === -1) {
 {
                        akra.logger.setSourceLocation("WebGLShaderProgram.ts", 665);
                        akra.logger.log("translated(from GLSL) VS shader: \n" + this.getTranslatedShaderCode(0x8B31));
                    }
                    ;
 {
                        akra.logger.setSourceLocation("WebGLShaderProgram.ts", 666);
                        akra.logger.log("translated(from GLSL) PS shader: \n" + this.getTranslatedShaderCode(0x8B30));
                    }
                    ;
                } else {
 {
                        akra.logger.setSourceLocation("WebGLShaderProgram.ts", 670);
                        akra.logger.log("translated(from GLSL) " + (eWebGLType === 0x8B31 ? "VS" : "PS") + " shader: \n" + this.getTranslatedShaderCode(eWebGLType));
                    }
                    ;
                }
            };
            WebGLShaderProgram.prototype.createWebGLShader = /**@protected*/ function (eType, csCode) {
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                var pWebGLShader = pWebGLContext.createShader(eType);
                pWebGLContext.shaderSource(pWebGLShader, csCode);
                pWebGLContext.compileShader(pWebGLShader);
                if (!pWebGLContext.getShaderParameter(pWebGLShader, 0x8B81)) {
 {
                        akra.logger.setSourceLocation("WebGLShaderProgram.ts", 684);
                        akra.logger.error("cannot compile GLSL shader(guid: %d)", ((this)._iGuid));
                    }
                    ;
                    var sInfo = pWebGLContext.getShaderInfoLog(pWebGLShader);
                    var sCode = pWebGLContext.getShaderSource(pWebGLShader) || csCode;
 {
                        akra.logger.setSourceLocation("WebGLShaderProgram.ts", 689);
                        akra.logger.log("shader errors: \n %s \n----------\n %s", sInfo, sCode);
                    }
                    ;
                    if (webgl.loadExtension(pWebGLContext, "WEBGL_debug_shaders")) {
 {
                            akra.logger.setSourceLocation("WebGLShaderProgram.ts", 693);
                            akra.logger.log("translated(from GLSL) " + (eType == 0x8B31 ? "VS" : "PS") + " shader: \n" + pWebGLContext.getExtension("WEBGL_debug_shaders").getTranslatedShaderSource(pWebGLShader));
                        }
                        ;
                    }
                    return null;
                }
                return pWebGLShader;
            };
            WebGLShaderProgram.prototype.obtainWebGLUniforms = /**@protected*/ function () {
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                ;
                var nUniforms = pWebGLContext.getProgramParameter(this._pWebGLProgram, 0x8B86);
                var pUniformLocations = {};
                var iLoc;
                var pUniformInfo;
                for(var i = 0; i < nUniforms; ++i) {
                    pUniformInfo = pWebGLContext.getActiveUniform(this._pWebGLProgram, i);
                    iLoc = pWebGLContext.getUniformLocation(this._pWebGLProgram, pUniformInfo.name);
                    pUniformLocations[pUniformInfo.name] = iLoc;
                }
                this._pWebGLUniformLocations = pUniformLocations;
            };
            WebGLShaderProgram.prototype.obtainWebGLAttributes = /**@protected*/ function () {
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                ;
                var nAttributes = pWebGLContext.getProgramParameter(this._pWebGLProgram, 0x8B89);
                var pAttributeLocations = {};
                var pAttributesInfo = [];
                var iLoc;
                var pAttributeInfo;
                for(var i = 0; i < nAttributes; ++i) {
                    pAttributeInfo = pWebGLContext.getActiveAttrib(this._pWebGLProgram, i);
                    iLoc = pWebGLContext.getAttribLocation(this._pWebGLProgram, pAttributeInfo.name);
                    if (iLoc < 0 || !((iLoc) !== undefined)) {
 {
                            akra.logger.setSourceLocation("WebGLShaderProgram.ts", 733);
                            akra.logger.warning("could not get GLSL attribute location(guid: %s): %s", ((this)._iGuid), pAttributeInfo.name);
                        }
                        ;
                    }
                    pAttributeLocations[pAttributeInfo.name] = iLoc;
                    pAttributesInfo[iLoc] = pAttributeInfo;
                }
                this._pWebGLAttributeLocations = pAttributeLocations;
                this._pWebGLAttributesInfo = pAttributesInfo;
                this._iTotalAttributes = nAttributes;
            };
            return WebGLShaderProgram;
        })(akra.core.pool.ResourcePoolItem);
        webgl.WebGLShaderProgram = WebGLShaderProgram;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLRenderer = (function (_super) {
            __extends(WebGLRenderer, _super);
            function WebGLRenderer(pEngine, options) {
                        _super.call(this, pEngine);
                this._pCanvas = null;
                //real context, if debug context used
                this._pWebGLInternalContext = null;
                this._nActiveAttributes = 0;
                this._iSlot = 0;
                this._iCurrentTextureSlot = 0;
                this._iNextTextureSlot = 0;
                this._pTextureSlotList = null;
                /**
                * Need to impove speed
                */
                this._pContextState = {
                    depthMask: false,
                    framebuffer: null
                };
                this._time = [
                    0, 
                    0, 
                    0, 
                    0, 
                    0, 
                    0, 
                    0, 
                    0
                ];
                var pOptions = null;
                if (((arguments[1]) != null)) {
                    //get HTMLCanvasElement by id
                    if ((typeof (arguments[1]) === "string")) {
                        this._pCanvas = document.getElementById(arguments[1]);
                    } else if (arguments[1] instanceof HTMLCanvasElement) {
                        this._pCanvas = arguments[1];
                    } else {
                        pOptions = arguments[1];
                        if (pOptions.canvas instanceof HTMLCanvasElement) {
                            this._pCanvas = pOptions.canvas;
                        }
                    }
                }
                if (((this._pCanvas) === null)) {
                    this._pCanvas = document.createElement('canvas');
                }
                if (((pOptions) === null)) {
                    pOptions = WebGLRenderer.DEFAULT_OPTIONS;
                } else {
                    for(var i = 0, pOptList = Object.keys(WebGLRenderer.DEFAULT_OPTIONS); i < pOptList.length; ++i) {
                        var sOpt = pOptList[i];
                        if (!((pOptions[sOpt]) !== undefined)) {
                            pOptions[sOpt] = WebGLRenderer.DEFAULT_OPTIONS[sOpt];
                        }
                    }
                }
 {
                    akra.logger.setSourceLocation("WebGLRenderer.ts", 95);
                    akra.logger.log("webgl context attributes:", pOptions);
                }
                ;
                this._pWebGLContext = webgl.createContext(this._pCanvas, pOptions);
 {
                    akra.logger.setSourceLocation("WebGLRenderer.ts", 99);
                    akra.logger.assert(!((this._pWebGLContext) === null), "webgl context is NULL");
                }
                ;
                this._pWebGLFramebufferList = new Array(32);
                for(var i = 0; i < this._pWebGLFramebufferList.length; ++i) {
                    this._pWebGLFramebufferList[i] = this._pWebGLContext.createFramebuffer();
                }
                this._pDefaultCanvas = new webgl.WebGLCanvas(this);
                this.attachRenderTarget(this._pDefaultCanvas);
                this._pTextureSlotList = new Array(webgl.maxTextureImageUnits);
                for(var i = 0; i < this._pTextureSlotList.length; i++) {
                    this._pTextureSlotList[i] = null;
                }
            }
            WebGLRenderer.DEFAULT_OPTIONS = {
                depth: false,
                stencil: false,
                antialias: false,
                preserveDrawingBuffer: false
            };
            WebGLRenderer.prototype.debug = function (bValue, useApiTrace) {
                if (typeof bValue === "undefined") { bValue = true; }
                if (typeof useApiTrace === "undefined") { useApiTrace = false; }
                var pWebGLInternalContext = this._pWebGLContext;
                if (bValue) {
                    if ((((window).WebGLDebugUtils) !== undefined) && !((pWebGLInternalContext) === null)) {
                        this._pWebGLContext = WebGLDebugUtils.makeDebugContext(pWebGLInternalContext, function (err, funcName, args) {
                            throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName;
                        }, useApiTrace ? function (funcName, args) {
 {
                                akra.logger.setSourceLocation("WebGLRenderer.ts", 131);
                                akra.logger.log("gl." + funcName + "(" + WebGLDebugUtils.glFunctionArgsToString(funcName, args) + ")");
                            }
                            ;
                        } : null);
                        this._pWebGLInternalContext = pWebGLInternalContext;
                        return true;
                    }
                } else if (this.isDebug()) {
                    this._pWebGLContext = this._pWebGLInternalContext;
                    this._pWebGLInternalContext = null;
                    return true;
                }
                return false;
            };
            WebGLRenderer.prototype.getParameter = function (iWebGLParam) {
                switch(iWebGLParam) {
                    case 0x8CA6:
                        return this._pWebGLContext.getParameter(iWebGLParam);
                    case 0x0B72:
                        return this._pContextState.depthMask;
                }
            };
            WebGLRenderer.prototype._beginRender = function () {
                this._pWebGLContext.enable(0x0C11);
                this._pWebGLContext.disable(0x0BE2);
            };
            WebGLRenderer.prototype._printTime = function () {
                var _iTotalTime = 0;
                for(var i = 0; i < this._time.length; i++) {
                    _iTotalTime += this._time[i];
                }
                var _pPrinted = new Array(this._time.length);
                for(var i = 0; i < this._time.length; i++) {
                    _pPrinted[i] = (this._time[i] / _iTotalTime).toFixed(2);
                }
 {
                    akra.logger.setSourceLocation("WebGLRenderer.ts", 177);
                    akra.logger.log(_pPrinted.join("% "));
                }
                ;
 {
                    akra.logger.setSourceLocation("WebGLRenderer.ts", 178);
                    akra.logger.log(this._time.join("ms "));
                }
            };
            WebGLRenderer.prototype._renderEntry = function (pEntry) {
                var deltaTime = 0;
                // deltaTime = Date.now();
                var pViewport = pEntry.viewport;
                var pRenderTarget = (((pViewport))._pTarget);
                var pInput = pEntry.input;
                var pMaker = pEntry.maker;
                // deltaTime = Date.now() - deltaTime;
                // this._time[0] += deltaTime;
                //--------------------------
                // deltaTime = Date.now();
                if (!((pEntry.renderTarget) === null)) {
                    this._setRenderTarget(pEntry.renderTarget);
                    ((this)._bLockRenderTarget = true);
                    this._setViewportForRender(pViewport);
                    ((this)._bLockRenderTarget = false);
                } else {
                    this._setViewportForRender(pViewport);
                }
                // deltaTime = Date.now() - deltaTime;
                // this._time[1] += deltaTime;
                //-----------------------
                // deltaTime = Date.now();
                var pWebGLProgram = ((pMaker)._pShaderProgram);
                ((this)._pWebGLContext.useProgram(((pWebGLProgram._pWebGLProgram))));
                this.enableWebGLVertexAttribs((pWebGLProgram._iTotalAttributes));
                // deltaTime = Date.now() - deltaTime;
                // this._time[2] += deltaTime;
                //-----------------
                // deltaTime = Date.now();
                var pAttribLocations = (pWebGLProgram._pWebGLAttributeLocations);
                var pAttributeInfo = (pMaker._pShaderAttrInfoList);
                var pBufferMap = pEntry.bufferMap;
                // deltaTime = Date.now() - deltaTime;
                // this._time[3] += deltaTime;
                //-----------------
                // deltaTime = Date.now();
                if (!((pBufferMap.index) === null)) {
                    ((this)._pWebGLContext.bindBuffer((0x8893), ((((pBufferMap.index.buffer))._pWebGLBuffer))));
                }
                // deltaTime = Date.now() - deltaTime;
                // this._time[4] += deltaTime;
                //---------
                // deltaTime = Date.now();
                for(var i = 0; i < pAttributeInfo.length; i++) {
                    var sAttrName = pAttributeInfo[i].name;
                    var sAttrSemantic = pAttributeInfo[i].semantic;
                    // if(isNull(sAttrSemantic)){
                    // 	continue;
                    // }
                    var iLoc = pAttribLocations[sAttrName];
                    var pFlow = pInput.attrs[i];
                    var pData = null;
                    var sSemantics = null;
                    if (pFlow.type === akra.EDataFlowTypes.MAPPABLE) {
                        pData = pFlow.mapper.data;
                        sSemantics = pFlow.mapper.semantics;
                    } else {
                        pData = pFlow.data;
                        sSemantics = sAttrSemantic;
                    }
                    var pDecl = pData.getVertexDeclaration();
                    var pVertexElement = pDecl.findElement(sSemantics);
                    ((this)._pWebGLContext.bindBuffer((0x8892), (((((pData._pVertexBuffer)))._pWebGLBuffer))));
                    this._pWebGLContext.vertexAttribPointer(iLoc, pVertexElement.count, pVertexElement.type, false, (pData._iStride), pVertexElement.offset);
                }
                // deltaTime = Date.now() - deltaTime;
                // this._time[5] += deltaTime;
                //------------
                // deltaTime = Date.now();
                var pUniformNames = (pMaker._pRealUniformNameList);
                for(var i = 0; i < pUniformNames.length; i++) {
                    pMaker.setUniform(i, pInput.uniforms[i]);
                }
                // deltaTime = Date.now() - deltaTime;
                // this._time[6] += deltaTime;
                //---------
                // deltaTime = Date.now();
                pEntry.bufferMap._draw();
                // deltaTime = Date.now() - deltaTime;
                // this._time[7] += deltaTime;
                // LOG(pEntry.bufferMap.toString())
                            };
            WebGLRenderer.prototype._endRender = function () {
                this._pWebGLContext.disable(0x0C11);
            };
            WebGLRenderer.prototype._setViewport = function (pViewport) {
                // if(true){
                // 	return;
                // }
                if (((pViewport) === null)) {
                    this._pActiveViewport = null;
                    this._setRenderTarget(null);
                    return;
                }
                var isViewportUpdate = pViewport !== this._pActiveViewport || pViewport.isUpdated();
                var isRenderTargetUpdate = pViewport.getTarget() !== this._pActiveRenderTarget;
                if (isViewportUpdate || isRenderTargetUpdate) {
                    var pTarget = pViewport.getTarget();
                    this._setRenderTarget(pTarget);
                    if (isViewportUpdate) {
                        this._pActiveViewport = pViewport;
                        var x = pViewport.actualLeft, y = pViewport.actualTop, w = pViewport.actualWidth, h = pViewport.actualHeight;
                        this._pWebGLContext.viewport(x, y, w, h);
                        this._pWebGLContext.scissor(x, y, w, h);
                        pViewport._clearUpdatedFlag();
                    }
                }
            };
            WebGLRenderer.prototype._setRenderTarget = function (pTarget) {
                // if(true){
                // 	return;
                // }
                //May be unbind()
                if (((this)._bLockRenderTarget)) {
                    return;
                }
                this._pActiveRenderTarget = pTarget;
                if (!((pTarget) === null)) {
                    var pFrameBuffer = pTarget.getCustomAttribute("FBO");
                    if (!((pFrameBuffer) === null)) {
                        (((pFrameBuffer._pWebGLRenderer)._pWebGLContext.bindFramebuffer((0x8D40), (pFrameBuffer._pWebGLFramebuffer))));
                    } else {
                        ((this)._pWebGLContext.bindFramebuffer((0x8D40), (null)));
                    }
                }
            };
            WebGLRenderer.prototype._setCullingMode = function (eMode) {
                // if(true){
                // 	return;
                // }
                var iWebGLCullMode = 0;
                switch(eMode) {
                    case akra.ECullingMode.NONE:
                        this._pWebGLContext.disable(0x0B44);
                        return;
                    default:
                    case akra.ECullingMode.CLOCKWISE:
                        iWebGLCullMode = 0x0404;
                        break;
                    case akra.ECullingMode.ANTICLOCKWISE:
                        iWebGLCullMode = 0x0405;
                        break;
                }
                this._pWebGLContext.enable(0x0B44);
                this._pWebGLContext.cullFace(iWebGLCullMode);
            };
            WebGLRenderer.prototype._setDepthBufferParams = function (bDepthTest, bDepthWrite, eDepthFunction, fClearDepth) {
                if (typeof fClearDepth === "undefined") { fClearDepth = 1.; }
                // if(true){
                // 	return;
                // }
                if (bDepthTest) {
                    this._pWebGLContext.clearDepth(fClearDepth);
                    this._pWebGLContext.enable(0x0B71);
                } else {
                    this._pWebGLContext.disable(0x0B71);
                }
                this._pWebGLContext.depthMask(bDepthWrite);
                this._pContextState.depthMask = bDepthWrite;
                this._pWebGLContext.depthFunc(this.convertCompareFunction(eDepthFunction));
            };
            WebGLRenderer.prototype.isDebug = function () {
                return !((this._pWebGLInternalContext) === null);
            };
            WebGLRenderer.prototype.getHTMLCanvas = /** @inline */function () {
                return this._pCanvas;
            };
            WebGLRenderer.prototype.getWebGLContext = /** @inline */function () {
                return this._pWebGLContext;
            };
            WebGLRenderer.prototype.bindWebGLBuffer = /** Buffer Objects. */
            /** @inline */function (eTarget, pBuffer) {
                this._pWebGLContext.bindBuffer(eTarget, pBuffer);
            };
            WebGLRenderer.prototype.createWebGLBuffer = /** @inline */function () {
                return this._pWebGLContext.createBuffer();
            };
            WebGLRenderer.prototype.deleteWebGLBuffer = /** @inline */function (pBuffer) {
                this._pWebGLContext.deleteBuffer(pBuffer);
            };
            WebGLRenderer.prototype.bindWebGLTexture = /** Texture Objects. */
            /** @inline */function (eTarget, pTexture) {
                //if(this._pTextureSlotList[this._iCurrentTextureSlot] !== pTexture){
                this._pWebGLContext.bindTexture(eTarget, pTexture);
                this._pTextureSlotList[this._iCurrentTextureSlot] = pTexture;
                //}
                            };
            WebGLRenderer.prototype.activateWebGLTexture = /** @inline */function (iWebGLSlot) {
                this._pWebGLContext.activeTexture(iWebGLSlot);
                // this._iCurrentTextureSlot = iWebGLSlot - GL_TEXTURE0;
                            };
            WebGLRenderer.prototype.activateWebGLTextureInAutoSlot = function (eTarget, pTexture) {
                // var iSlot: uint = this._pTextureSlotList.indexOf(pTexture);
                // if(iSlot === -1) {
                var iSlot = this._iNextTextureSlot;
                this._iNextTextureSlot++;
                if (this._iNextTextureSlot === webgl.maxTextureImageUnits) {
                    this._iNextTextureSlot = 0;
                }
                ((this)._pWebGLContext.activeTexture((0x84C0 + iSlot)));
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.bindWebGLTexture(eTarget, pTexture);
                // }
                // else {
                // 	this.activateWebGLTexture(GL_TEXTURE0 + iSlot);
                // }
                return iSlot;
            };
            WebGLRenderer.prototype.createWebGLTexture = // inline getFreeWebGLTextureSlot(): int {
            // 	return this._getNextTextureSlot() + GL_TEXTURE0;
            // }
            // inline getNextTextureSlot(): int {
            // 	return this._iSlot === (maxTextureImageUnits - 1) ? (this._iSlot = 0) : (++this._iSlot);
            // }
            // inline getTextureSlot(): int {
            // 	return this._iSlot - 1;
            // }
            /** @inline */function () {
                return this._pWebGLContext.createTexture();
            };
            WebGLRenderer.prototype.deleteWebGLTexture = /** @inline */function (pTexture) {
                this._pWebGLContext.deleteTexture(pTexture);
            };
            WebGLRenderer.prototype.createWebGLFramebuffer = /** Framebuffer Objects */
            /** @inline */function () {
                if (this._pWebGLFramebufferList.length === 0) {
 {
                        akra.logger.setSourceLocation("WebGLRenderer.ts", 507);
                        akra.logger.criticalError("WebGL framebuffer limit exidit");
                    }
                    ;
                }
                return this._pWebGLFramebufferList.pop();
            };
            WebGLRenderer.prototype.bindWebGLFramebuffer = /** @inline */function (eTarget, pBuffer) {
                this._pWebGLContext.bindFramebuffer(eTarget, pBuffer);
                //this._pContextState.framebuffer = pBuffer;
                            };
            WebGLRenderer.prototype.bindWebGLFramebufferTexture2D = /** @inline */function (eTarget, eAttachment, eTexTarget, pTexture, iMipLevel) {
                if (typeof iMipLevel === "undefined") { iMipLevel = 0; }
                this._pWebGLContext.framebufferTexture2D(eTarget, eAttachment, eTexTarget, pTexture, iMipLevel);
            };
            WebGLRenderer.prototype.deleteWebGLFramebuffer = /** @inline */function (pBuffer) {
                this._pWebGLFramebufferList.push(pBuffer);
            };
            WebGLRenderer.prototype.createWebGLRenderbuffer = /** Renderbuffer Objects */
            /** @inline */function () {
                return this._pWebGLContext.createRenderbuffer();
            };
            WebGLRenderer.prototype.bindWebGLRenderbuffer = /** @inline */function (eTarget, pBuffer) {
                this._pWebGLContext.bindRenderbuffer(eTarget, pBuffer);
            };
            WebGLRenderer.prototype.deleteWebGLRenderbuffer = /** @inline */function (pBuffer) {
                this._pWebGLContext.deleteRenderbuffer(pBuffer);
            };
            WebGLRenderer.prototype.createWebGLProgram = /** @inline */function () {
                return this._pWebGLContext.createProgram();
            };
            WebGLRenderer.prototype.deleteWebGLProgram = /** @inline */function (pProgram) {
                this._pWebGLContext.deleteProgram(pProgram);
            };
            WebGLRenderer.prototype.useWebGLProgram = /** @inline */function (pProgram) {
                this._pWebGLContext.useProgram(pProgram);
            };
            WebGLRenderer.prototype.enableWebGLVertexAttribs = function (iTotal) {
                if (this._nActiveAttributes > iTotal) {
                    for(var i = iTotal; i < this._nActiveAttributes; i++) {
                        this._pWebGLContext.disableVertexAttribArray(i);
                    }
                } else {
                    for(var i = this._nActiveAttributes; i < iTotal; i++) {
                        this._pWebGLContext.enableVertexAttribArray(i);
                    }
                }
                this._nActiveAttributes = iTotal;
            };
            WebGLRenderer.prototype.disableAllWebGLVertexAttribs = function () {
                var i = 0;
                for(i = 0; i < this._nActiveAttributes; i++) {
                    this._pWebGLContext.disableVertexAttribArray(i);
                }
                this._nActiveAttributes = 0;
            };
            WebGLRenderer.prototype.getDefaultCanvas = function () {
                return this._pDefaultCanvas;
            };
            WebGLRenderer.prototype.clearFrameBuffer = function (iBuffers, cColor, fDepth, iStencil) {
                // if(true){
                // 	return;
                // }
                var iWebGLFlag = 0;
                var bOldDepthWrite = this.getParameter(0x0B72);
                if (iBuffers & akra.EFrameBufferTypes.COLOR) {
                    iWebGLFlag |= 0x00004000;
                    this._pWebGLContext.clearColor(cColor.r, cColor.g, cColor.b, cColor.a);
                }
                if (iBuffers & akra.EFrameBufferTypes.DEPTH) {
                    iWebGLFlag |= 0x00000100;
                    if (!bOldDepthWrite) {
                        this._pWebGLContext.depthMask(true);
                    }
                    this._pWebGLContext.clearDepth(fDepth);
                }
                if (iBuffers & akra.EFrameBufferTypes.STENCIL) {
                    iWebGLFlag |= 0x00000400;
                    this._pWebGLContext.stencilMask(0xFFFFFFFF);
                    this._pWebGLContext.clearStencil(iStencil);
                }
                this._pWebGLContext.clear(iWebGLFlag);
                if (!bOldDepthWrite && (iBuffers & akra.EFrameBufferTypes.DEPTH)) {
                    this._pWebGLContext.depthMask(false);
                }
            };
            WebGLRenderer.prototype._disableTextureUnitsFrom = /** @inline */function (iUnit) {
                for(var i = iUnit; i < this._pTextureSlotList.length; i++) {
                    this._pTextureSlotList[i] = null;
                }
            };
            WebGLRenderer.prototype.convertCompareFunction = function (eFunc) {
                switch(eFunc) {
                    case akra.ECompareFunction.ALWAYS_FAIL:
                        return 0x0200;
                    case akra.ECompareFunction.ALWAYS_PASS:
                        return 0x0207;
                    case akra.ECompareFunction.LESS:
                        return 0x0201;
                    case akra.ECompareFunction.LESS_EQUAL:
                        return 0x0203;
                    case akra.ECompareFunction.EQUAL:
                        return 0x0202;
                    case akra.ECompareFunction.NOT_EQUAL:
                        return 0x0205;
                    case akra.ECompareFunction.GREATER_EQUAL:
                        return 0x0206;
                    case akra.ECompareFunction.GREATER:
                        return 0x0204;
                }
                return 0x0207;
            };
            return WebGLRenderer;
        })(akra.render.Renderer);
        webgl.WebGLRenderer = WebGLRenderer;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var SQUARE_VERTICES = new Float32Array([
            -1.0, 
            -1.0, 
            1.0, 
            -1.0, 
            -1.0, 
            1.0, 
            1.0, 
            1.0
        ]);
        var TEXCOORDS = new Float32Array(12);
        function computeLog(iValue) {
            var i = 0;
            /* Error! */
            if (iValue === 0) {
                return -1;
            }
            for(; ; ) {
                if (iValue & 1) {
                    /* Error! */
                    if (iValue !== 1) {
                        return -1;
                    }
                    return i;
                }
                iValue = iValue >> 1;
                i++;
            }
        }
        webgl.computeLog = computeLog;
        var WebGLTextureBuffer = (function (_super) {
            __extends(WebGLTextureBuffer, _super);
            function WebGLTextureBuffer() {
                        _super.call(this);
                /**@protected*/ this._eTarget = null;
                /**@protected*/ this._eFaceTarget = null;
                /**@protected*/ this._pWebGLTexture = null;
                /**@protected*/ this._iFace = 0;
                /**@protected*/ this._iLevel = 0;
                /**@protected*/ this._bSoftwareMipmap = false;
                /**@protected*/ this._pRTTList = null;
            }
            WebGLTextureBuffer.prototype._clearRTT = function (iZOffset) {
                this._pRTTList[iZOffset] = null;
            };
            WebGLTextureBuffer.prototype.reset = function (iWidth, iHeight) {
                if (typeof iWidth === "undefined") { iWidth = this._iWidth; }
                if (typeof iHeight === "undefined") { iHeight = iWidth; }
                //TODO: check format
                iWidth = akra.math.ceilingPowerOfTwo(iWidth);
                iHeight = akra.math.ceilingPowerOfTwo(iHeight);
                this._iWidth = this._iLevel === 0 ? iWidth : iWidth / Math.pow(2.0, this._iLevel);
                this._iHeight = this._iLevel === 0 ? iHeight : iHeight / Math.pow(2.0, this._iLevel);
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                //pWebGLRenderer.debug(true, true);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);
                pWebGLContext.texImage2D(this._eFaceTarget, this._iLevel, webgl.getClosestWebGLInternalFormat(webgl.getSupportedAlternative(this._eFormat)), this._iWidth, this._iHeight, 0, webgl.getWebGLFormat(this._eFormat), webgl.getWebGLDataType(this._eFormat), null);
                this._iByteSize = akra.pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
                this._pBuffer.setPosition(0, 0, this._iWidth, this._iHeight, 0, this._iDepth);
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(this._eTarget, null);
                this.notifyResized();
                //pWebGLRenderer.debug(false, false);
                            };
            WebGLTextureBuffer.prototype.notifyResized = function () {
                if (!((this._pRTTList) === null)) {
                    for(var i = 0; i < this._pRTTList.length; ++i) {
                        this._pRTTList[i].resized();
                    }
                }
            };
            WebGLTextureBuffer.prototype.create = function () {
                if (arguments.length < 6) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 104);
                        akra.logger.criticalError("Invalid number of params. For WebGLTextureBuffer");
                    }
                    ;
                }
                var eTarget = arguments[0];
                var pTexture = arguments[1];
                var iWidth = arguments[2];
                var iHeight = arguments[3];
                var iInternalFormat = arguments[4];
                var iFormat = arguments[5];
                var iFace = arguments[6];
                var iLevel = arguments[7];
                var iFlags = arguments[8];
                var bSoftwareMipmap = arguments[9];
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(eTarget, pTexture);
                this._eTarget = eTarget;
                this._pWebGLTexture = pTexture;
                this._iFace = iFace;
                this._iLevel = iLevel;
                this._iFlags = iFlags;
                this._bSoftwareMipmap = bSoftwareMipmap;
                this._eFaceTarget = eTarget;
                if (eTarget === 0x8513) {
                    this._eFaceTarget = 0x8515 + iFace;
                }
                this._iWidth = iLevel === 0 ? iWidth : iWidth / Math.pow(2.0, iLevel);
                this._iHeight = iLevel === 0 ? iHeight : iHeight / Math.pow(2.0, iLevel);
                this._iDepth = 1;
                this._iWebGLInternalFormat = iInternalFormat;
                this._eFormat = webgl.getClosestAkraFormat(iInternalFormat, iFormat);
                this._iRowPitch = this._iWidth;
                this._iSlicePitch = this._iHeight * this._iWidth;
                this._iByteSize = akra.pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
                this._pBuffer = new akra.pixelUtil.PixelBox(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
                if (this._iWidth === 0 || this._iHeight === 0 || this._iDepth === 0) {
                    // We are invalid, do not allocate a buffer
                    return false;
                }
                // Is this a render target?
                if ((((this._iFlags) & (akra.ETextureFlags.RENDERTARGET)) != 0)) {
                    // Create render target for each slice
                    this._pRTTList = new Array();
                    for(var iZOffset = 0; iZOffset < this._iDepth; ++iZOffset) {
                        var pRenderTexture = new webgl.WebGLRenderTexture(pWebGLRenderer, this);
                        this._pRTTList.push(pRenderTexture);
                        pWebGLRenderer.attachRenderTarget(pRenderTexture);
                    }
                }
                var pProgram = (((((this).pResourcePool)).pManager)).shaderProgramPool.findResource("WEBGL_blit_texture_buffer");
                var sFloatToVec4Func = "	        	vec4 floatToVec4(float value){						\n					float data = value;								\n					vec4 result = vec4(0.);							\n																	\n					if(data == 0.){									\n						float signedZeroTest = 1./value;			\n						if(signedZeroTest < 0.){					\n							result.x = 128.;						\n						}											\n						return result/255.;							\n					}												\n																	\n					if(data < 0.){									\n						result.x=128.;								\n						data = -data;								\n					}												\n																	\n					float power = 0.;								\n					bool isFinish = false;							\n					for(int i=0;i<128;i++){							\n						if(isFinish){								\n							break;									\n						}											\n																	\n						if(data >= 2.) {							\n							if(!isFinish){							\n								data = data * 0.5;					\n								power += 1.;						\n								if (power == 127.) {				\n									isFinish = true;				\n								}									\n							}										\n						}											\n						else if(data < 1.) {						\n							if(!isFinish){							\n								data = data * 2.;					\n								power -= 1.;						\n								if (power == -126.) {				\n									isFinish = true;				\n								}									\n							}										\n						}											\n						else {										\n							isFinish = true;						\n						}											\n					}												\n																	\n					if(power == -126. && data < 1.){				\n						power = 0.;									\n					}												\n					else{											\n						power = power+127.;							\n						data = data - 1.;							\n					}												\n																	\n					result.x+=floor(power/2.);						\n					result.y = mod(power,2.)*128.;					\n																	\n					data *= 128.;									\n																	\n					result.y += floor(data);						\n																	\n					data -= floor(data);							\n					data *= 256.;									\n																	\n					result.z = floor(data);							\n																	\n					data -= floor(data);							\n					data *= 256.;									\n																	\n					result.w = floor(data);							\n																	\n					return result/255.;								\n				}													\n";
                if (((pProgram) === null)) {
                    pProgram = (((((this).pResourcePool)).pManager)).shaderProgramPool.createResource("WEBGL_blit_texture_buffer");
                    pProgram.create("																									\n	        	attribute vec2 POSITION;																			\n				attribute vec3 TEXCOORD;																			\n				                      																				\n				varying vec3 texcoord;																				\n				                   																					\n				void main(void){																					\n				    texcoord = TEXCOORD;																			\n				    gl_Position = vec4(POSITION, 0., 1.);															\n				}																									\n				", "													\n				#ifdef GL_ES                        				\n				    precision highp float;          				\n				#endif												\n				varying vec3 texcoord;              				\n				uniform sampler2D uSampler;        					\n																	\n				void main(void) {  									\n					vec4 color;										\n					color = texture2D(uSampler, texcoord.xy);      	\n				    gl_FragColor = color;           				\n				}                                   				\n				");
                }
                pProgram = (((((this).pResourcePool)).pManager)).shaderProgramPool.findResource("WEBGL_decode_depth32_texture");
                if (((pProgram) === null)) {
                    pProgram = (((((this).pResourcePool)).pManager)).shaderProgramPool.createResource("WEBGL_decode_depth32_texture");
                    pProgram.create("																									\n	        	attribute vec2 POSITION;																			\n				attribute vec3 TEXCOORD;																			\n				                      																				\n				varying vec3 texcoord;																				\n				                   																					\n				void main(void){																					\n				    texcoord = TEXCOORD;																			\n				    gl_Position = vec4(POSITION, 0., 1.);															\n				}																									\n				", "													\n				#ifdef GL_ES                        				\n				    precision highp float;          				\n				#endif												\n				varying vec3 texcoord;              				\n				uniform sampler2D uSampler;        					\n																	\n				" + sFloatToVec4Func + "																	\n				void main(void) {  									\n					vec4 color;										\n					color = texture2D(uSampler, vec2(texcoord.x, 1. - texcoord.y));      	\n					vec4 t = floatToVec4(color.r);					\n				    gl_FragColor = vec4(t.a, t.b, t.g, t.r);		\n				}                                   				\n				");
                }
                pProgram = (((((this).pResourcePool)).pManager)).shaderProgramPool.findResource("WEBGL_decode_float32_texture");
                if (((pProgram) === null)) {
                    pProgram = (((((this).pResourcePool)).pManager)).shaderProgramPool.createResource("WEBGL_decode_float32_texture");
                    pProgram.create("																									\n	        	attribute vec2 POSITION;																			\n				attribute vec3 TEXCOORD;																			\n				                      																				\n				varying vec3 texcoord;																				\n				varying vec2 dest_texcoord;																			\n				                   																					\n				void main(void){																					\n				    texcoord = TEXCOORD;																			\n				    gl_Position = vec4(POSITION, 0., 1.);															\n				    dest_texcoord.xy = (POSITION.xy + 1.  ) /2.;													\n				}																									\n				", "													\n				#ifdef GL_ES                        				\n				    precision highp float;          				\n				#endif												\n																	\n				varying vec3 texcoord;              				\n				uniform sampler2D uSampler;							\n				uniform int dst_width;        						\n				uniform int dst_height;        						\n				uniform int src_components_num;						\n				varying vec2 dest_texcoord;							\n				" + sFloatToVec4Func + "																	\n				void main(void) {  									\n																	\n					float pixel = dest_texcoord.x * float(dst_width);	\n					float value;									\n					int comp = int(mod(pixel, float(src_components_num)));	\n					vec4 color = texture2D(uSampler, vec2(texcoord.x, 1. - texcoord.y));\n																	\n					if (comp == 0)									\n						value = color.r;							\n					if (comp == 1)									\n						value = color.g;							\n					if (comp == 2)									\n						value = color.b;							\n					if (comp == 3)									\n						value = color.a;	 						\n																	\n					vec4 t = floatToVec4(value);					\n																	\n				    gl_FragColor = vec4(t.a, t.b, t.g, t.r);		\n				}				");
                }
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(eTarget, null);
                return true;
            };
            WebGLTextureBuffer.prototype.destroy = // destroyResource(): bool {
            // 	super.destroyResource();
            // 	this._pWebGLTexture = null;
            // 	this.destroy();
            // 	return true;
            // }
            function () {
                if ((((this._iFlags) & (akra.ETextureFlags.RENDERTARGET)) != 0)) {
                    // Delete all render targets that are not yet deleted via _clearSliceRTT because the rendertarget
                    // was deleted by the user.
                    var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                    for(var i = 0; i < this._pRTTList.length; i++) {
                        pWebGLRenderer.destroyRenderTarget(this._pRTTList[i]);
                    }
                }
            };
            WebGLTextureBuffer.prototype.upload = //upload(download) data to(from) videocard.
            /**@protected*/ function (pData, pDestBox) {
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);
                var pDataBox = null;
                if ((((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor(((pData.format))).flags) & /*checked (origin: akra)>>*/akra.EPixelFormatFlags.COMPRESSED) > 0)) {
                    if (pData.format !== this._eFormat || !pData.isConsecutive()) {
 {
                            akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 390);
                            akra.logger.criticalError("Compressed images must be consecutive, in the source format");
                        }
                        ;
                    }
                    var iWebGLFormat = akra.webgl.getClosestWebGLInternalFormat(this._eFormat);
                    // Data must be consecutive and at beginning of buffer as PixelStorei not allowed
                    // for compressed formats
                    if (pDestBox.left === 0 && pDestBox.top === 0) {
                        pWebGLContext.compressedTexImage2D(this._eFaceTarget, this._iLevel, iWebGLFormat, pDestBox.width, pDestBox.height, 0, pData.data);
                    } else {
                        pWebGLContext.compressedTexSubImage2D(this._eFaceTarget, this._iLevel, pDestBox.left, pDestBox.top, pDestBox.width, pDestBox.height, iWebGLFormat, pData.data);
                    }
                } else if (this._bSoftwareMipmap) {
                    if (pData.width !== pData.rowPitch || pData.height * pData.width !== pData.slicePitch) {
                        pDataBox = this._pBuffer.getSubBox(pDestBox, akra.pixelUtil.pixelBox());
                        pDataBox.setConsecutive();
                        akra.pixelUtil.bulkPixelConversion(pData, pDataBox);
                    } else {
                        pDataBox = pData;
                    }
                    pWebGLContext.pixelStorei(0x0CF5, 1);
                    this.buildMipmaps(pDataBox);
                } else {
                    if (pData.width !== pData.rowPitch || pData.height * pData.width !== pData.slicePitch) {
                        pDataBox = this._pBuffer.getSubBox(pDestBox, akra.pixelUtil.pixelBox());
                        pDataBox.setConsecutive();
                        akra.pixelUtil.bulkPixelConversion(pData, pDataBox);
                    } else {
                        pDataBox = pData;
                    }
                    if ((pData.width * (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor((pData.format)).elemBytes)) & 3) {
                        // Standard alignment of 4 is not right
                        pWebGLContext.pixelStorei(0x0CF5, 1);
                    }
                    if (pDestBox.left === 0 && pDestBox.top === 0 && pDestBox.width >= ((this)._iWidth) && pDestBox.height >= ((this)._iHeight)) {
                        pWebGLContext.texImage2D(this._eFaceTarget, this._iLevel, akra.webgl.getWebGLFormat(pData.format), pDestBox.width, pDestBox.height, 0, akra.webgl.getWebGLFormat(pData.format), akra.webgl.getWebGLDataType(pData.format), !(((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor(((pData.format))).flags) & /*checked (origin: akra)>>*/akra.EPixelFormatFlags.FLOAT) > 0) ? pDataBox.data : new Float32Array(pDataBox.data.buffer, pDataBox.data.byteOffset, pDataBox.data.byteLength / Float32Array.BYTES_PER_ELEMENT));
                    } else {
                        pWebGLContext.texSubImage2D(this._eFaceTarget, this._iLevel, pDestBox.left, pDestBox.top, pDestBox.width, pDestBox.height, akra.webgl.getWebGLFormat(pData.format), akra.webgl.getWebGLDataType(pData.format), pDataBox.data);
                    }
                }
                if ((((this._iFlags) & (akra.ETextureFlags.AUTOMIPMAP)) != 0) && !this._bSoftwareMipmap && (this._iLevel === 0)) {
                    pWebGLContext.generateMipmap(this._eFaceTarget);
                }
                pWebGLContext.pixelStorei(0x0CF5, 4);
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(this._eTarget, null);
                ((this).setAlteredFlag(true));
            };
            WebGLTextureBuffer.prototype.download = /**@protected*/ function (pData) {
 {
                    akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 487);
                    akra.logger.assert(!((pData.right > this._iWidth) || (pData.bottom > this._iHeight) || (pData.front != 0) || (pData.back != 1)), "Invalid box");
                }
                ;
                var pSrcBox = null;
                var pWebGLTexture = this._pWebGLTexture;
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                if (!webgl.checkFBOAttachmentFormat(((this)._eFormat))) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 495);
                        akra.logger.criticalError("Read from texture this format not support(" + ((this)._eFormat) + ")");
                    }
                    ;
                }
                if (!webgl.checkReadPixelFormat(((this)._eFormat))) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 502);
                        akra.logger.assert(((this)._eFormat) === akra.EPixelFormats.DEPTH32 || ((this)._eFormat) === akra.EPixelFormats.FLOAT32_RGB || ((this)._eFormat) === akra.EPixelFormats.FLOAT32_RGBA, "TODO: downloading for all formats");
                    }
                    ;
                    var eFormat = ((this)._eFormat);
                    var pDestBox = akra.geometry.box(0, 0, 0, pData.width * (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor((((this)._eFormat))).componentCount), pData.height, pData.depth);
                    if (((this)._eFormat) === akra.EPixelFormats.DEPTH32) {
                        eFormat = akra.EPixelFormats.FLOAT32_DEPTH;
                    }
                    // мы не можем читать из данного формата напрямую, поэтому необходимо перерендерить эту текстура в RGB/RGBA 8.
                    var pProgram = (((((this).pResourcePool)).pManager)).shaderProgramPool.findResource(((this)._eFormat) === akra.EPixelFormats.DEPTH32 ? "WEBGL_decode_depth32_texture" : "WEBGL_decode_float32_texture");
                    pWebGLTexture = WebGLTextureBuffer.copyTex2DImageByProgram(pProgram, pDestBox, akra.EPixelFormats.R8G8B8A8, this, pData);
                    if (pData.format === eFormat) {
                        pSrcBox = pData;
                    } else {
                        pSrcBox = new akra.pixelUtil.PixelBox(pData, eFormat, new Uint8Array(akra.pixelUtil.getMemorySize(pData.width * (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor((((this)._eFormat))).componentCount), pData.height, pData.depth, akra.EPixelFormats.R8G8B8A8)));
                    }
                    var pOldFramebuffer = pWebGLRenderer.getParameter(0x8CA6);
                    var pFrameBuffer = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.createWebGLFramebuffer();
                    (pWebGLRenderer._pWebGLContext.bindFramebuffer((0x8D40), (pFrameBuffer)));
                    pWebGLContext.framebufferTexture2D(0x8D40, 0x8CE0, 0x0DE1, pWebGLTexture, 0);
                    pWebGLContext.readPixels(0, 0, pDestBox.width, pDestBox.height, 0x1908, 0x1401, pSrcBox.data);
                    (pWebGLRenderer._pWebGLContext.bindFramebuffer((0x8D40), (pOldFramebuffer)));
                    (pWebGLRenderer._pWebGLFramebufferList.push((pFrameBuffer)));
                    (pWebGLRenderer._pWebGLContext.deleteTexture((pWebGLTexture)));
                    if (pSrcBox != pData) {
                        console.log("download. convertion....");
                        akra.pixelUtil.bulkPixelConversion(pSrcBox, pData);
                    }
                    return;
                }
                if (webgl.checkReadPixelFormat(pData.format)) {
                    pSrcBox = pData;
                } else {
                    pSrcBox = new akra.pixelUtil.PixelBox(pData, akra.EPixelFormats.BYTE_RGBA, new Uint8Array(akra.pixelUtil.getMemorySize(pData.width, pData.height, pData.depth, akra.EPixelFormats.BYTE_RGBA)));
                }
                var pOldFramebuffer = pWebGLRenderer.getParameter(0x8CA6);
                var pFrameBuffer = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.createWebGLFramebuffer();
                (pWebGLRenderer._pWebGLContext.bindFramebuffer((0x8D40), (pFrameBuffer)));
                var eFormat = webgl.getWebGLFormat(pSrcBox.format);
                var eType = webgl.getWebGLDataType(pSrcBox.format);
                pWebGLContext.framebufferTexture2D(0x8D40, 0x8CE0, this._eFaceTarget, pWebGLTexture, this._iLevel);
                pWebGLContext.readPixels(pSrcBox.left, pSrcBox.top, pSrcBox.width, pSrcBox.height, eFormat, eType, pSrcBox.data);
                if (!webgl.checkReadPixelFormat(pData.format)) {
                    console.log("download. convertion....");
                    akra.pixelUtil.bulkPixelConversion(pSrcBox, pData);
                }
                //дективировать его
                (pWebGLRenderer._pWebGLContext.bindFramebuffer((0x8D40), (pOldFramebuffer)));
                (pWebGLRenderer._pWebGLFramebufferList.push((pFrameBuffer)));
                // if(data.getWidth() != getWidth() ||
                //     data.getHeight() != getHeight() ||
                //     data.getDepth() != getDepth())
                //     OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, "only download of entire buffer is supported by GL",
                //         "GLTextureBuffer::download");
                // glBindTexture( mTarget, mTextureID );
                // if(PixelUtil::isCompressed(data.format))
                // {
                //     if(data.format != mFormat || !data.isConsecutive())
                //         OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS,
                //         "Compressed images must be consecutive, in the source format",
                //         "GLTextureBuffer::download");
                //     // Data must be consecutive and at beginning of buffer as PixelStorei not allowed
                //     // for compressed formate
                //     glGetCompressedTexImageNV(mFaceTarget, mLevel, data.data);
                // }
                // else
                // {
                //     if((data.getWidth()*PixelUtil::getNumElemBytes(data.format)) & 3) {
                //         // Standard alignment of 4 is not right
                //         glPixelStorei(GL_PACK_ALIGNMENT, 1);
                //     }
                //     // We can only get the entire texture
                //     glGetTexImageNV(mFaceTarget, mLevel,
                //         GLES2PixelUtil::getGLOriginFormat(data.format), GLES2PixelUtil::getGLOriginDataType(data.format),
                //         data.data);
                //     // Restore defaults
                //     glPixelStorei(GL_PACK_ALIGNMENT, 4);
                // }
                //CRITICAL("Downloading texture buffers is not supported by OpenGL ES");
                            };
            WebGLTextureBuffer.prototype.buildMipmaps = /**@protected*/ function (pData) {
                var iWidth = 0;
                var iHeight = 0;
                var iLogW = 0;
                var iLogH = 0;
                var iLevel = 0;
                var pScaled = new akra.pixelUtil.PixelBox();
                pScaled.data = pData.data;
                pScaled.left = pData.left;
                pScaled.right = pData.right;
                pScaled.top = pData.top;
                pScaled.bottom = pData.bottom;
                pScaled.front = pData.front;
                pScaled.back = pData.back;
                iWidth = pData.width;
                iHeight = pData.height;
                iLogW = computeLog(iWidth);
                iLogH = computeLog(iHeight);
                iLevel = (iLogW > iLogH ? iLogW : iLogH);
                var mip = 0;
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                for(mip = 0; mip <= iLevel; mip++) {
                    var iWebGLFormat = akra.webgl.getWebGLFormat(pScaled.format);
                    var iWebGLDataType = akra.webgl.getWebGLDataType(pScaled.format);
                    pWebGLContext.texImage2D(this._eFaceTarget, mip, iWebGLFormat, iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, pScaled.data);
                    if (mip !== 0) {
                        pScaled.data = null;
                    }
                    if (iWidth > 1) {
                        iWidth = iWidth / 2;
                    }
                    if (iHeight > 1) {
                        iHeight = iHeight / 2;
                    }
                    var iSizeInBytes = akra.pixelUtil.getMemorySize(iWidth, iHeight, 1, pData.format);
                    pScaled = new akra.pixelUtil.PixelBox(iWidth, iHeight, 1, pData.format);
                    pScaled.data = new Uint8Array(iSizeInBytes);
                    pData.scale(pScaled, akra.EFilters.LINEAR);
                }
                // Delete the scaled data for the last level
                if (iLevel > 0) {
                    pScaled.data = null;
                }
            };
            WebGLTextureBuffer.prototype._bindToFramebuffer = function (iAttachment, iZOffset) {
 {
                    akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 680);
                    akra.logger.assert(iZOffset < this._iDepth);
                }
                ;
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                pWebGLContext.framebufferTexture2D(0x8D40, iAttachment, this._eFaceTarget, this._pWebGLTexture, this._iLevel);
            };
            WebGLTextureBuffer.prototype._copyFromFramebuffer = function (iZOffset) {
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);
                pWebGLContext.copyTexSubImage2D(this._eFaceTarget, this._iLevel, 0, 0, 0, 0, this._iWidth, this._iHeight);
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(this._eTarget, null);
            };
            WebGLTextureBuffer.prototype._getTarget = /** @inline */function () {
                return this._eTarget;
            };
            WebGLTextureBuffer.prototype._getWebGLTexture = /** @inline */function () {
                return this._pWebGLTexture;
            };
            WebGLTextureBuffer.prototype._getFaceTarget = /** @inline */function () {
                return this._eFaceTarget;
            };
            WebGLTextureBuffer.prototype.blit = function (pSource, pSrcBox, pDestBox) {
                if (arguments.length === 1) {
                    return this.blit(pSource, new akra.geometry.Box(0, 0, 0, pSource.width, pSource.height, pSource.depth), new akra.geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth));
                } else {
                    var pSourceTexture = pSource;
                    // TODO: Check for FBO support first
                    // Destination texture must be 2D or Cube
                    // Source texture must be 2D
                    if (!((((pSourceTexture._iFlags)) & (akra.ETextureFlags.RENDERTARGET)) != 0) && (pSourceTexture._eTarget) === 0x0DE1) {
                        return this.blitFromTexture(pSourceTexture, pSrcBox, pDestBox);
                    } else {
                        return _super.prototype.blit.call(this, pSource, pSrcBox, pDestBox);
                    }
                }
            };
            WebGLTextureBuffer.copyTex2DImageByProgram = function copyTex2DImageByProgram(pProgram, pDestBox, eFormat, pSource, pSrcBox) {
                if (typeof pSrcBox === "undefined") { pSrcBox = null; }
                var pWebGLRenderer = ((((((((pSource.pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                /*not inlined, because first statement is not return/call/dot(cur st.: For)*/pWebGLRenderer._disableTextureUnitsFrom(0);
                (pWebGLRenderer._pWebGLContext.activeTexture((0x84C0)));
                // Disable alpha, depth and scissor testing, disable blending,
                // and disable culling
                pWebGLContext.disable(0x0B71);
                pWebGLContext.disable(0x0C11);
                pWebGLContext.disable(0x0BE2);
                pWebGLContext.disable(0x0B44);
                // Set up source texture
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture((pSource._eFaceTarget), (pSource._pWebGLTexture));
                if (((pSrcBox) === null)) {
                    pSrcBox = pDestBox;
                }
                // Set filtering modes depending on the dimensions and source
                if (pSrcBox.width === pDestBox.width && pSrcBox.height === pDestBox.height && pSrcBox.depth === pDestBox.depth) {
                    // Dimensions match -- use nearest filtering (fastest and pixel correct)
                    pWebGLContext.texParameteri((pSource._eFaceTarget), 0x2801, 0x2600);
                    pWebGLContext.texParameteri((pSource._eFaceTarget), 0x2800, 0x2600);
                } else {
                    pWebGLContext.texParameteri((pSource._eFaceTarget), 0x2801, 0x2601);
                    pWebGLContext.texParameteri((pSource._eFaceTarget), 0x2800, 0x2601);
                }
                // Clamp to edge (fastest)
                pWebGLContext.texParameteri((pSource._eFaceTarget), 0x2802, 0x812F);
                pWebGLContext.texParameteri((pSource._eFaceTarget), 0x2803, 0x812F);
                //Store old binding so it can be restored later
                var pOldFramebuffer = pWebGLRenderer.getParameter(0x8CA6);
                var pFramebuffer = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.createWebGLFramebuffer();
                (pWebGLRenderer._pWebGLContext.bindFramebuffer((0x8D40), (pFramebuffer)));
                var pTempWebGLTexture = null;
                // If target format not directly supported, create intermediate texture
                var iGLTempFormat = akra.webgl.getClosestWebGLInternalFormat(akra.webgl.getSupportedAlternative(eFormat));
                pTempWebGLTexture = (pWebGLRenderer._pWebGLContext.createTexture());
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(0x0DE1, pTempWebGLTexture);
                // Allocate temporary texture of the size of the destination area
                pWebGLContext.texImage2D(0x0DE1, 0, iGLTempFormat, /*math.ceilingPowerOfTwo*/
                (pDestBox.width), /*math.ceilingPowerOfTwo*/
                (pDestBox.height), 0, 0x1908, 0x1401, null);
                pWebGLContext.framebufferTexture2D(0x8D40, 0x8CE0, 0x0DE1, pTempWebGLTexture, 0);
                // Set viewport to size of destination slice
                pWebGLContext.viewport(0, 0, pDestBox.width, pDestBox.height);
                //Get WebGL program
                var pWebGLShaderProgram = pProgram;
                pWebGLRenderer.disableAllWebGLVertexAttribs();
                (pWebGLRenderer._pWebGLContext.useProgram(((pWebGLShaderProgram._pWebGLProgram))));
                var iPosAttrIndex = 0;
                var iTexAttrIndex = 0;
                iPosAttrIndex = (((pWebGLShaderProgram._pWebGLAttributeLocations[("POSITION")]) !== undefined) ? pWebGLShaderProgram._pWebGLAttributeLocations[("POSITION")] : -1);
                iTexAttrIndex = (((pWebGLShaderProgram._pWebGLAttributeLocations[("TEXCOORD")]) !== undefined) ? pWebGLShaderProgram._pWebGLAttributeLocations[("TEXCOORD")] : -1);
                pWebGLContext.enableVertexAttribArray(iPosAttrIndex);
                pWebGLContext.enableVertexAttribArray(iTexAttrIndex);
                var pSquareVertices = SQUARE_VERTICES;
                var pTexCoords = TEXCOORDS;
                var pPositionBuffer = (pWebGLRenderer._pWebGLContext.createBuffer());
                var pTexCoordsBuffer = (pWebGLRenderer._pWebGLContext.createBuffer());
                (pWebGLRenderer._pWebGLContext.bindBuffer((0x8892), (pPositionBuffer)));
                pWebGLContext.bufferData(0x8892, pSquareVertices, 0x88E0);
                pWebGLContext.vertexAttribPointer(iPosAttrIndex, 2, 0x1406, false, 0, 0);
                (pWebGLShaderProgram._pWebGLContext.uniform1i(pWebGLShaderProgram._pWebGLUniformLocations[("uSampler")], (0)));
                (pWebGLShaderProgram._pWebGLContext.uniform1i(pWebGLShaderProgram._pWebGLUniformLocations[("src_components_num")], ((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor(((pSource._eFormat))).componentCount))));
                (pWebGLShaderProgram._pWebGLContext.uniform1i(pWebGLShaderProgram._pWebGLUniformLocations[("dst_width")], (pDestBox.width)));
                (pWebGLShaderProgram._pWebGLContext.uniform1i(pWebGLShaderProgram._pWebGLUniformLocations[("dst_height")], (pDestBox.height)));
                // LOG("dest size: ", pDestBox.width, "x", pDestBox.height, "cn: ", pixelUtil.getComponentCount(pSource.format));
                // Process each destination slice
                var iSlice = 0;
                for(iSlice = pDestBox.front; iSlice < pDestBox.back; ++iSlice) {
                    /// Calculate source texture coordinates
                    var u1 = pSrcBox.left / (pSource._iWidth);
                    var v1 = pSrcBox.top / (pSource._iHeight);
                    var u2 = pSrcBox.right / (pSource._iWidth);
                    var v2 = pSrcBox.bottom / (pSource._iHeight);
                    /// Calculate source slice for this destination slice
                    var w = (iSlice - pDestBox.front) / pDestBox.depth;
                    /// Get slice # in source
                    w = w * pSrcBox.depth + pSrcBox.front;
                    /// Normalise to texture coordinate in 0.0 .. 1.0
                    w = (w + 0.5) / (pSource._iDepth);
                    pTexCoords[0] = u1;
                    pTexCoords[1] = v1;
                    pTexCoords[2] = w;
                    pTexCoords[3] = u2;
                    pTexCoords[4] = v1;
                    pTexCoords[5] = w;
                    pTexCoords[6] = u2;
                    pTexCoords[7] = v2;
                    pTexCoords[8] = w;
                    pTexCoords[9] = u1;
                    pTexCoords[10] = v2;
                    pTexCoords[11] = w;
                    /// Finally we're ready to rumble
                    /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture((pSource._eFaceTarget), (pSource._pWebGLTexture));
                    (pWebGLRenderer._pWebGLContext.bindBuffer((0x8892), (pTexCoordsBuffer)));
                    pWebGLContext.bufferData(0x8892, pTexCoords, 0x88E0);
                    pWebGLContext.vertexAttribPointer(iTexAttrIndex, 3, 0x1406, false, 0, 0);
                    pWebGLContext.drawArrays(0x0005, 0, 4);
                }
                pWebGLContext.disableVertexAttribArray(iPosAttrIndex);
                pWebGLContext.disableVertexAttribArray(iTexAttrIndex);
                (pWebGLRenderer._pWebGLContext.deleteBuffer((pPositionBuffer)));
                (pWebGLRenderer._pWebGLContext.deleteBuffer((pTexCoordsBuffer)));
                // Reset source texture to sane state
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture((pSource._eFaceTarget), null);
                // Detach texture from temporary framebuffer
                pWebGLContext.framebufferRenderbuffer(0x8D40, 0x8CE0, 0x8D41, null);
                // Restore old framebuffer
                (pWebGLRenderer._pWebGLContext.bindFramebuffer((0x8D40), (pOldFramebuffer)));
                (pWebGLRenderer._pWebGLFramebufferList.push((pFramebuffer)));
                return pTempWebGLTexture;
            };
            WebGLTextureBuffer.prototype.blitFromTexture = //-----------------------------------------------------------------------------
            // Very fast texture-to-texture blitter and hardware bi/trilinear scaling implementation using FBO
            // Destination texture must be 1D, 2D, 3D, or Cube
            // Source texture must be 1D, 2D or 3D
            // Supports compressed formats as both source and destination format, it will use the hardware DXT compressor
            // if available.
            function (pSource, pSrcBox, pDestBox) {
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                if (((this)._eFormat) === (pSource._eFormat) && webgl.checkCopyTexImage(((this)._eFormat)) && this._pBuffer.contains(pDestBox) && pSrcBox.width === pDestBox.width && pSrcBox.height === pDestBox.height && pSrcBox.depth === pDestBox.depth) {
                    var pOldFramebuffer = pWebGLRenderer.getParameter(0x8CA6);
                    var pFramebuffer = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.createWebGLFramebuffer();
                    (pWebGLRenderer._pWebGLContext.bindFramebuffer((0x8D40), (pFramebuffer)));
                    pWebGLContext.framebufferTexture2D(0x8D40, 0x8CE0, (pSource._eTarget), (pSource._pWebGLTexture), 0);
                    /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);
                    if (pDestBox.width === ((this)._iWidth) && pDestBox.height === ((this)._iHeight)) {
                        pWebGLContext.copyTexImage2D(this._eFaceTarget, this._iLevel, webgl.getWebGLFormat(this._eFormat), pSrcBox.left, pSrcBox.top, pSrcBox.width, pSrcBox.height, 0);
                    } else {
                        pWebGLContext.copyTexSubImage2D(this._eFaceTarget, this._iLevel, pDestBox.left, pDestBox.top, pSrcBox.left, pSrcBox.top, pSrcBox.width, pSrcBox.height);
                    }
                    (pWebGLRenderer._pWebGLContext.bindFramebuffer((0x8D40), (pOldFramebuffer)));
                    /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(this._eTarget, null);
                    (pWebGLRenderer._pWebGLFramebufferList.push((pFramebuffer)));
                    ((this).setAlteredFlag(true));
                    return true;
                }
                /*not inlined, because first statement is not return/call/dot(cur st.: For)*/pWebGLRenderer._disableTextureUnitsFrom(0);
                (pWebGLRenderer._pWebGLContext.activeTexture((0x84C0)));
                // Disable alpha, depth and scissor testing, disable blending,
                // and disable culling
                pWebGLContext.disable(0x0B71);
                pWebGLContext.disable(0x0C11);
                pWebGLContext.disable(0x0BE2);
                pWebGLContext.disable(0x0B44);
                // Set up source texture
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture((pSource._eTarget), (pSource._pWebGLTexture));
                // Set filtering modes depending on the dimensions and source
                if (pSrcBox.width === pDestBox.width && pSrcBox.height === pDestBox.height && pSrcBox.depth === pDestBox.depth) {
                    // Dimensions match -- use nearest filtering (fastest and pixel correct)
                    pWebGLContext.texParameteri((pSource._eTarget), 0x2801, 0x2600);
                    pWebGLContext.texParameteri((pSource._eTarget), 0x2800, 0x2600);
                } else {
                    // Dimensions don't match -- use bi or trilinear filtering depending on the
                    // source texture.
                    if (((((pSource._iFlags)) & (akra.ETextureFlags.AUTOMIPMAP)) != 0)) {
                        // Automatic mipmaps, we can safely use trilinear filter which
                        // brings greatly improved quality for minimisation.
                        pWebGLContext.texParameteri((pSource._eTarget), 0x2801, 0x2703);
                        pWebGLContext.texParameteri((pSource._eTarget), 0x2800, 0x2601);
                    } else {
                        // Manual mipmaps, stay safe with bilinear filtering so that no
                        // intermipmap leakage occurs.
                        pWebGLContext.texParameteri((pSource._eTarget), 0x2801, 0x2601);
                        pWebGLContext.texParameteri((pSource._eTarget), 0x2800, 0x2601);
                    }
                }
                // Clamp to edge (fastest)
                pWebGLContext.texParameteri((pSource._eTarget), 0x2802, 0x812F);
                pWebGLContext.texParameteri((pSource._eTarget), 0x2803, 0x812F);
                //Store old binding so it can be restored later
                var pOldFramebuffer = pWebGLRenderer.getParameter(0x8CA6);
                var pFramebuffer = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.createWebGLFramebuffer();
                (pWebGLRenderer._pWebGLContext.bindFramebuffer((0x8D40), (pFramebuffer)));
                var pTempWebGLTexture = null;
                if (!akra.webgl.checkFBOAttachmentFormat(this._eFormat) || (pSource._pWebGLTexture) === ((this)._pWebGLTexture)) {
                    // If target format not directly supported, create intermediate texture
                    var iGLTempFormat = akra.webgl.getClosestWebGLInternalFormat(akra.webgl.getSupportedAlternative(this._eFormat));
                    pTempWebGLTexture = (pWebGLRenderer._pWebGLContext.createTexture());
                    /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(0x0DE1, pTempWebGLTexture);
                    // Allocate temporary texture of the size of the destination area
                    pWebGLContext.texImage2D(0x0DE1, 0, iGLTempFormat, akra.math.ceilingPowerOfTwo(pDestBox.width), akra.math.ceilingPowerOfTwo(pDestBox.height), 0, 0x1908, 0x1401, null);
                    pWebGLContext.framebufferTexture2D(0x8D40, 0x8CE0, 0x0DE1, pTempWebGLTexture, 0);
                    // Set viewport to size of destination slice
                    pWebGLContext.viewport(0, 0, pDestBox.width, pDestBox.height);
                } else {
                    // We are going to bind directly, so set viewport to size and position of destination slice
                    pWebGLContext.viewport(pDestBox.left, pDestBox.top, pDestBox.width, pDestBox.height);
                }
                //Get WebGL program
                var pWebGLShaderProgram = (((((this).pResourcePool)).pManager)).shaderProgramPool.findResource("WEBGL_blit_texture_buffer");
                pWebGLRenderer.disableAllWebGLVertexAttribs();
                (pWebGLRenderer._pWebGLContext.useProgram(((pWebGLShaderProgram._pWebGLProgram))));
                var iPosAttrIndex = 0;
                var iTexAttrIndex = 0;
                iPosAttrIndex = (((pWebGLShaderProgram._pWebGLAttributeLocations[("POSITION")]) !== undefined) ? pWebGLShaderProgram._pWebGLAttributeLocations[("POSITION")] : -1);
                iTexAttrIndex = (((pWebGLShaderProgram._pWebGLAttributeLocations[("TEXCOORD")]) !== undefined) ? pWebGLShaderProgram._pWebGLAttributeLocations[("TEXCOORD")] : -1);
                pWebGLContext.enableVertexAttribArray(iPosAttrIndex);
                pWebGLContext.enableVertexAttribArray(iTexAttrIndex);
                var pSquareVertices = SQUARE_VERTICES;
                var pTexCoords = TEXCOORDS;
                var pPositionBuffer = (pWebGLRenderer._pWebGLContext.createBuffer());
                var pTexCoordsBuffer = (pWebGLRenderer._pWebGLContext.createBuffer());
                (pWebGLRenderer._pWebGLContext.bindBuffer((0x8892), (pPositionBuffer)));
                pWebGLContext.bufferData(0x8892, pSquareVertices, 0x88E0);
                pWebGLContext.vertexAttribPointer(iPosAttrIndex, 2, 0x1406, false, 0, 0);
                (pWebGLShaderProgram._pWebGLContext.uniform1i(pWebGLShaderProgram._pWebGLUniformLocations[("uSampler")], (0)));
                // Process each destination slice
                var iSlice = 0;
                for(iSlice = pDestBox.front; iSlice < pDestBox.back; ++iSlice) {
                    if (((pTempWebGLTexture) === null)) {
                        // Bind directly
                        this._bindToFramebuffer(0x8CE0, iSlice);
                    }
                    /// Calculate source texture coordinates
                    var u1 = pSrcBox.left / (pSource._iWidth);
                    var v1 = pSrcBox.top / (pSource._iHeight);
                    var u2 = pSrcBox.right / (pSource._iWidth);
                    var v2 = pSrcBox.bottom / (pSource._iHeight);
                    /// Calculate source slice for this destination slice
                    var w = (iSlice - pDestBox.front) / pDestBox.depth;
                    /// Get slice # in source
                    w = w * pSrcBox.depth + pSrcBox.front;
                    /// Normalise to texture coordinate in 0.0 .. 1.0
                    w = (w + 0.5) / (pSource._iDepth);
                    pTexCoords[0] = u1;
                    pTexCoords[1] = v1;
                    pTexCoords[2] = w;
                    pTexCoords[3] = u2;
                    pTexCoords[4] = v1;
                    pTexCoords[5] = w;
                    pTexCoords[6] = u2;
                    pTexCoords[7] = v2;
                    pTexCoords[8] = w;
                    pTexCoords[9] = u1;
                    pTexCoords[10] = v2;
                    pTexCoords[11] = w;
                    /// Finally we're ready to rumble
                    /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture((pSource._eTarget), (pSource._pWebGLTexture));
                    // pWebGLContext.enable(pSource._getTarget());
                    (pWebGLRenderer._pWebGLContext.bindBuffer((0x8892), (pTexCoordsBuffer)));
                    pWebGLContext.bufferData(0x8892, pTexCoords, 0x88E0);
                    pWebGLContext.vertexAttribPointer(iTexAttrIndex, 3, 0x1406, false, 0, 0);
                    pWebGLContext.drawArrays(0x0005, 0, 4);
                    // pWebGLContext.disable(pSource._getTarget());
                    if (!((pTempWebGLTexture) === null)) {
                        if (pSource === this) {
                            //set width, height and _pWebGLTexture
                            (pWebGLRenderer._pWebGLContext.deleteTexture((this._pWebGLTexture)));
                            this._pWebGLTexture = pTempWebGLTexture;
                            this._iWidth = akra.math.ceilingPowerOfTwo(pDestBox.width);
                            this._iHeight = akra.math.ceilingPowerOfTwo(pDestBox.height);
                        } else {
                            // Copy temporary texture
                            /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);
                            switch(this._eTarget) {
                                case 0x0DE1:
                                case 0x8513:
                                    pWebGLContext.copyTexSubImage2D(this._eFaceTarget, this._iLevel, pDestBox.left, pDestBox.top, 0, 0, pDestBox.width, pDestBox.height);
                                    break;
                            }
                        }
                    }
                }
                pWebGLContext.disableVertexAttribArray(iPosAttrIndex);
                pWebGLContext.disableVertexAttribArray(iTexAttrIndex);
                (pWebGLRenderer._pWebGLContext.deleteBuffer((pPositionBuffer)));
                (pWebGLRenderer._pWebGLContext.deleteBuffer((pTexCoordsBuffer)));
                // Finish up
                if (!((pTempWebGLTexture) === null)) {
                    // Generate mipmaps
                    if ((((this._iFlags) & (akra.ETextureFlags.AUTOMIPMAP)) != 0)) {
                        /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);
                        pWebGLContext.generateMipmap(this._eTarget);
                    }
                }
                // Reset source texture to sane state
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(this._eTarget, null);
                // Detach texture from temporary framebuffer
                pWebGLContext.framebufferRenderbuffer(0x8D40, 0x8CE0, 0x8D41, null);
                // Restore old framebuffer
                (pWebGLRenderer._pWebGLContext.bindFramebuffer((0x8D40), (pOldFramebuffer)));
                if (pSource !== this) {
                    (pWebGLRenderer._pWebGLContext.deleteTexture((pTempWebGLTexture)));
                }
                (pWebGLRenderer._pWebGLFramebufferList.push((pFramebuffer)));
                pTempWebGLTexture = null;
                ((this).setAlteredFlag(true));
                return true;
            };
            WebGLTextureBuffer.prototype.blitFromMemory = function () {
                if (arguments.length === 1) {
                    return _super.prototype.blitFromMemory.call(this, arguments[0]);
                }
                // Fall back to normal GLHardwarePixelBuffer::blitFromMemory in case
                // - FBO is not supported
                // - Either source or target is luminance due doesn't looks like supported by hardware
                // - the source dimensions match the destination ones, in which case no scaling is needed
                // TODO: Check that extension is NOT available
                var pSourceOrigin = arguments[0];
                var pDestBox = arguments[1];
                if ((((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor(((pSourceOrigin.format))).flags) & /*checked (origin: akra)>>*/akra.EPixelFormatFlags.LUMINANCE) > 0) || (((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor(((this._eFormat))).flags) & /*checked (origin: akra)>>*/akra.EPixelFormatFlags.LUMINANCE) > 0) || (pSourceOrigin.width === pDestBox.width && pSourceOrigin.height === pDestBox.height && pSourceOrigin.depth === pDestBox.depth)) {
                    return _super.prototype.blitFromMemory.call(this, pSourceOrigin, pDestBox);
                }
                if (!this._pBuffer.contains(pDestBox)) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 1164);
                        akra.logger.criticalError("Destination box out of range");
                    }
                    ;
                }
                var pSource;
                // First, convert the srcbox to a OpenGL compatible pixel format
                if (webgl.getWebGLFormat(pSourceOrigin.format) === 0) {
                    // Convert to buffer internal format
                    var iSizeInBytes = akra.pixelUtil.getMemorySize(pSourceOrigin.width, pSourceOrigin.height, pSourceOrigin.depth, this._eFormat);
                    pSource = new akra.pixelUtil.PixelBox(pSourceOrigin.width, pSourceOrigin.height, pSourceOrigin.depth, this._eFormat, new Uint8Array(iSizeInBytes));
                    akra.pixelUtil.bulkPixelConversion(pSourceOrigin, pSource);
                } else {
                    // No conversion needed
                    pSource = pSourceOrigin;
                }
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                // Create temporary texture to store source data
                var pTempWebGLTexture = null;
                var eTarget = 0x0DE1;
                var iWidth = akra.math.ceilingPowerOfTwo(pSource.width);
                var iHeight = akra.math.ceilingPowerOfTwo(pSource.height);
                var iWebGLFormat = webgl.getClosestWebGLInternalFormat(pSource.format);
                var iWebGLDataType = webgl.getWebGLDataType(pSource.format);
                pTempWebGLTexture = (pWebGLRenderer._pWebGLContext.createTexture());
                if (((pTempWebGLTexture) === null)) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 1197);
                        akra.logger.error("Can not create WebGL texture");
                    }
                    ;
                    return false;
                }
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(eTarget, pTempWebGLTexture);
                pWebGLContext.texImage2D(eTarget, 0, iWebGLFormat, iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, null);
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(eTarget, null);
                var pTextureBufferPool = (((((this).pResourcePool)).pManager)).textureBufferPool;
                var pTempTexBuffer = pTextureBufferPool.createResource(".temp");
                // var pTempTexBuffer: WebGLTextureBuffer = <WebGLTextureBuffer>pTextureBufferPool.findResource(".temp");
                // if(isNull(pTextureBufferPool)){
                // 	pTempTexBuffer = <WebGLTextureBuffer>pTextureBufferPool.createResource(".temp");
                // }
                pTempTexBuffer.create(eTarget, pTempWebGLTexture, iWidth, iHeight, iWebGLFormat, pSource.format, 0, 0, akra.ETextureFlags.AUTOMIPMAP | akra.EHardwareBufferFlags.STATIC, false);
                // Upload data to 0,0,0 in temporary texture
                var pTempBoxTarget = new akra.geometry.Box(0, 0, 0, pSource.width, pSource.height, pSource.depth);
                pTempTexBuffer.upload(pSource, pTempBoxTarget);
                //Blit
                this.blitFromTexture(pTempTexBuffer, pTempBoxTarget, pDestBox);
                //Delete temp data
                pTempTexBuffer.release();
                pTextureBufferPool.destroyResource(pTempTexBuffer);
                (pWebGLRenderer._pWebGLContext.deleteTexture((pTempWebGLTexture)));
                pTempWebGLTexture = null;
                pTempBoxTarget = null;
                return true;
            };
            WebGLTextureBuffer.prototype.getRenderTarget = function (iZOffest) {
                if (typeof iZOffest === "undefined") { iZOffest = 0; }
 {
                    akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 1239);
                    akra.logger.assert((((this._iFlags) & (akra.ETextureFlags.RENDERTARGET)) != 0));
                }
                ;
 {
                    akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 1240);
                    akra.logger.assert(iZOffest < this._iDepth, "iZOffest: " + iZOffest + ", iDepth: " + this._iDepth);
                }
                ;
                return this._pRTTList[iZOffest];
            };
            WebGLTextureBuffer.prototype.resize = function (iWidth, iHeight) {
                if (typeof iHeight === "undefined") { iHeight = iWidth; }
                if (arguments.length === 1) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 1247);
                        akra.logger.criticalError("resize with one parametr not available for WebGLTextureBuffer");
                    }
                    ;
                    return false;
                }
                var pSrcBox = akra.geometry.box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
                var pDestBox = akra.geometry.box(0, 0, 0, iWidth, iHeight, this._iDepth);
                return this.blitFromTexture(this, pSrcBox, pDestBox);
            };
            return WebGLTextureBuffer;
        })(webgl.WebGLPixelBuffer);
        webgl.WebGLTextureBuffer = WebGLTextureBuffer;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLInternalTexture = (function (_super) {
            __extends(WebGLInternalTexture, _super);
            function WebGLInternalTexture() {
                        _super.call(this);
                this._pSurfaceList = null;
                this._pWebGLTexture = null;
            }
            WebGLInternalTexture.prototype.getWebGLTexture = /** @inline */function () {
                return this._pWebGLTexture;
            };
            WebGLInternalTexture.prototype._getWebGLTextureTarget = function () {
                switch(this._eTextureType) {
                    case akra.ETextureTypes.TEXTURE_2D:
                        return 0x0DE1;
                    case akra.ETextureTypes.TEXTURE_CUBE_MAP:
                        return 0x8513;
                    default:
                        return 0;
                }
            };
            WebGLInternalTexture.prototype._getWebGLTextureParameter = function (eParam) {
                switch(eParam) {
                    case akra.ETextureParameters.MAG_FILTER:
                        return 0x2800;
                    case akra.ETextureParameters.MIN_FILTER:
                        return 0x2801;
                    case akra.ETextureParameters.WRAP_S:
                        return 0x2802;
                    case akra.ETextureParameters.WRAP_T:
                        return 0x2803;
                    default:
                        return 0;
                }
            };
            WebGLInternalTexture.prototype._getWebGLTextureParameterValue = function (eValue) {
                switch(eValue) {
                    case akra.ETextureFilters.NEAREST:
                        return 0x2600;
                    case akra.ETextureFilters.LINEAR:
                        return 0x2601;
                    case akra.ETextureFilters.NEAREST_MIPMAP_NEAREST:
                        return 0x2700;
                    case akra.ETextureFilters.LINEAR_MIPMAP_NEAREST:
                        return 0x2701;
                    case akra.ETextureFilters.NEAREST_MIPMAP_LINEAR:
                        return 0x2702;
                    case akra.ETextureFilters.LINEAR_MIPMAP_LINEAR:
                        return 0x2703;
                    case akra.ETextureWrapModes.REPEAT:
                        return 0x2901;
                    case akra.ETextureWrapModes.CLAMP_TO_EDGE:
                        return 0x812F;
                    case akra.ETextureWrapModes.MIRRORED_REPEAT:
                        return 0x8370;
                    default:
                        return 0;
                }
            };
            WebGLInternalTexture.prototype._getAkraTextureParameterValue = function (iWebGLValue) {
                switch(iWebGLValue) {
                    case 0x2600:
                        return akra.ETextureFilters.NEAREST;
                    case 0x2601:
                        return akra.ETextureFilters.LINEAR;
                    case 0x2700:
                        return akra.ETextureFilters.NEAREST_MIPMAP_NEAREST;
                    case 0x2701:
                        return akra.ETextureFilters.LINEAR_MIPMAP_NEAREST;
                    case 0x2702:
                        return akra.ETextureFilters.NEAREST_MIPMAP_LINEAR;
                    case 0x2703:
                        return akra.ETextureFilters.LINEAR_MIPMAP_LINEAR;
                    case 0x2901:
                        return akra.ETextureWrapModes.REPEAT;
                    case 0x812F:
                        return akra.ETextureWrapModes.CLAMP_TO_EDGE;
                    case 0x8370:
                        return akra.ETextureWrapModes.MIRRORED_REPEAT;
                    default:
                        return 0;
                }
            };
            WebGLInternalTexture.prototype.reset = function (iWidth, iHeight) {
                if (typeof iWidth === "undefined") { iWidth = this._iWidth; }
                if (typeof iHeight === "undefined") { iHeight = iWidth; }
                _super.prototype.reset.call(this, iWidth, iHeight);
                for(var i = 0; i < this._pSurfaceList.length; i++) {
                    this._pSurfaceList[i].reset(iWidth, iHeight);
                }
            };
            WebGLInternalTexture.prototype._setFilterInternalTexture = /**@protected*/ function (eParam, eValue) {
                if (!((this)._isInternalResourceCreated)) {
                    return false;
                }
                var iWebGLTarget = this._getWebGLTextureTarget();
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);
                pWebGLContext.texParameteri(iWebGLTarget, this._getWebGLTextureParameter(eParam), this._getWebGLTextureParameterValue(eValue));
                // var e = pWebGLContext.getError();if (e){LOG(this.findResourceName(), "filter: ", eParam, "value: ", eValue, "error: ", e)};
                return true;
            };
            WebGLInternalTexture.prototype._setWrapModeInternalTexture = /**@protected*/ function (eParam, eValue) {
                if (!((this)._isInternalResourceCreated)) {
                    return false;
                }
                var iWebGLTarget = this._getWebGLTextureTarget();
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);
                pWebGLContext.texParameteri(iWebGLTarget, this._getWebGLTextureParameter(eParam), this._getWebGLTextureParameterValue(eValue));
                return true;
            };
            WebGLInternalTexture.prototype._getFilterInternalTexture = /**@protected*/ function (eParam) {
                if (!((this)._isInternalResourceCreated)) {
                    return 0;
                }
                var iWebGLTarget = this._getWebGLTextureTarget();
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);
                return this._getAkraTextureParameterValue(pWebGLContext.getTexParameter(iWebGLTarget, this._getWebGLTextureParameter(eParam)));
            };
            WebGLInternalTexture.prototype._getWrapModeInternalTexture = /**@protected*/ function (eParam) {
                if (!((this)._isInternalResourceCreated)) {
                    return 0;
                }
                var iWebGLTarget = this._getWebGLTextureTarget();
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);
                return this._getAkraTextureParameterValue(pWebGLContext.getTexParameter(iWebGLTarget, this._getWebGLTextureParameter(eParam)));
            };
            WebGLInternalTexture.prototype._createInternalTextureImpl = /**@protected*/ function (cFillColor) {
                if (typeof cFillColor === "undefined") { cFillColor = null; }
                if (!((cFillColor) === null)) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 177);
                        akra.logger.warning("Texture can create with filled only by default(black) color");
                    }
                    ;
                    //TODO: must implement filling by color
                                    }
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                if (this._eTextureType == akra.ETextureTypes.TEXTURE_2D) {
                    if (this._iWidth > akra.webgl.maxTextureSize) {
 {
                            akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 191);
                            akra.logger.warning("Заданная ширина не поддерживается(" + this._iWidth + ")");
                        }
                        ;
                        this._iWidth = akra.webgl.maxTextureSize;
                    }
                    if (this._iHeight > akra.webgl.maxTextureSize) {
 {
                            akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 196);
                            akra.logger.warning("Заданная высота не поддерживается(" + this._iHeight + ")");
                        }
                        ;
                        this._iHeight = akra.webgl.maxTextureSize;
                    }
                } else if (this._eTextureType == akra.ETextureTypes.TEXTURE_CUBE_MAP) {
                    if (this._iWidth > akra.webgl.maxCubeMapTextureSize) {
 {
                            akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 205);
                            akra.logger.warning("Заданная ширина не поддерживается(" + this._iWidth + ")");
                        }
                        ;
                        this._iWidth = akra.webgl.maxCubeMapTextureSize;
                    }
                    if (this._iHeight > akra.webgl.maxCubeMapTextureSize) {
 {
                            akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 210);
                            akra.logger.warning("Заданная высота не поддерживается(" + this._iHeight + ")");
                        }
                        ;
                        this._iHeight = akra.webgl.maxCubeMapTextureSize;
                    }
                }
                if (this._iWidth == 0) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 218);
                        akra.logger.warning("Заданная ширина не поддерживается(" + this._iWidth + ")");
                    }
                    ;
                    this._iWidth = 1;
                }
                if (this._iHeight == 0) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 224);
                        akra.logger.warning("Заданная высота не поддерживается(" + this._iHeight + ")");
                    }
                    ;
                    this._iHeight = 1;
                }
                if (this._iDepth != 1) {
                    this._iDepth = 1;
 {
                        akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 230);
                        akra.logger.warning("Трехмерные текстуры не поддерживаются, сброс глубины в 1");
                    }
                    ;
                }
                if (this._nMipLevels != 0 && !akra.webgl.hasExtension("EXT_texture_npot_2D_mipmap") && (!(((this._iDepth) > 0 && (((this._iDepth)) == 0 ? (null) : (((this._iDepth)) < 0 ? 31 : ((/*checked (origin: math)>>*/akra.math.log(((this._iDepth))) / /*checked (origin: math)>>*/akra.math.LN2) << 0))) == /*checked (origin: math)>>*/akra.math.lowestBitSet((this._iDepth)))) || !(((this._iHeight) > 0 && (((this._iHeight)) == 0 ? (null) : (((this._iHeight)) < 0 ? 31 : ((/*checked (origin: math)>>*/akra.math.log(((this._iHeight))) / /*checked (origin: math)>>*/akra.math.LN2) << 0))) == /*checked (origin: math)>>*/akra.math.lowestBitSet((this._iHeight)))) || !(((this._iWidth) > 0 && (((this._iWidth)) == 0 ? (null) : (((this._iWidth)) < 0 ? 31 : ((/*checked (origin: math)>>*/akra.math.log(((this._iWidth))) / /*checked (origin: math)>>*/akra.math.LN2) << 0))) == /*checked (origin: math)>>*/akra.math.lowestBitSet((this._iWidth)))))) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 234);
                        akra.logger.warning("Мип мапы у текстуры не стпени двойки не поддерживаются, сброс мипмапов в 0");
                    }
                    ;
                    this._nMipLevels = 0;
                    ((this._iFlags) &= ~(akra.ETextureFlags.AUTOMIPMAP));
                }
                if (!akra.webgl.isWebGLFormatSupport(this._eFormat)) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 241);
                        akra.logger.warning("Данный тип текстуры не поддерживается: ", this._eFormat);
                    }
                    ;
                    this._eFormat = akra.EPixelFormats.A8B8G8R8;
                }
                if (this._nMipLevels != 0 && this._nMipLevels != akra.core.pool.resources.Img.getMaxMipmaps(this._iWidth, this._iHeight, this._iDepth, this._eFormat)) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 248);
                        akra.logger.warning("Нехватает мипмапов, сброс в 0");
                    }
                    ;
                    this._nMipLevels = 0;
                }
                // Convert to nearest power-of-two size if required
                //this._iWidth = math.ceilingPowerOfTwo(this._iWidth);
                //this._iHeight = math.ceilingPowerOfTwo(this._iHeight);
                //this._iDepth = math.ceilingPowerOfTwo(this._iDepth);
                var iWebGLTarget = this._getWebGLTextureTarget();
                this._pWebGLTexture = (pWebGLRenderer._pWebGLContext.createTexture());
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);
                this._isMipmapsHardwareGenerated = pWebGLRenderer.hasCapability(akra.ERenderCapabilities.AUTOMIPMAP);
                // Set some misc default parameters, these can of course be changed later
                var eMinFiler = ((this)._pParams[(/*checked (origin: akra)>>*/akra.ETextureParameters.MIN_FILTER)]);
                var eMagFiler = ((this)._pParams[(/*checked (origin: akra)>>*/akra.ETextureParameters.MAG_FILTER)]);
                if ((eMinFiler >= akra.ETextureFilters.NEAREST_MIPMAP_NEAREST && eMinFiler <= akra.ETextureFilters.LINEAR_MIPMAP_LINEAR) && this._nMipLevels < 2) {
                    eMinFiler = akra.ETextureFilters.LINEAR;
                }
                if ((eMagFiler >= akra.ETextureFilters.NEAREST_MIPMAP_NEAREST || eMagFiler <= akra.ETextureFilters.LINEAR_MIPMAP_LINEAR) && this._nMipLevels < 2) {
                    eMagFiler = akra.ETextureFilters.LINEAR;
                }
                // LOG("e: ", pWebGLContext.getError(), this.findResourceName(), "n mipmaps: ", this._nMipLevels, "size (x, y):", this._iWidth, this._iHeight, "min filer > ", "(0x", eMinFiler.toString(16), ")");
                this.setFilter(akra.ETextureParameters.MIN_FILTER, eMinFiler);
                this.setFilter(akra.ETextureParameters.MAG_FILTER, eMagFiler);
                this.setWrapMode(akra.ETextureParameters.WRAP_S, ((this)._pParams[(/*checked (origin: akra)>>*/akra.ETextureParameters.WRAP_S)]));
                this.setWrapMode(akra.ETextureParameters.WRAP_T, ((this)._pParams[(/*checked (origin: akra)>>*/akra.ETextureParameters.WRAP_T)]));
                var iWebGLFormat = akra.webgl.getWebGLFormat(this._eFormat);
                var iWebGLDataType = akra.webgl.getWebGLDataType(this._eFormat);
                var iWidth = this._iWidth;
                var iHeight = this._iHeight;
                var iDepth = this._iDepth;
                if ((((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor(((this._eFormat))).flags) & /*checked (origin: akra)>>*/akra.EPixelFormatFlags.COMPRESSED) > 0)) {
                    // Compressed formats
                    var iSize = akra.pixelUtil.getMemorySize(iWidth, iHeight, iDepth, this._eFormat);
                    // Provide temporary buffer filled with zeroes as glCompressedTexImageXD does not
                    // accept a 0 pointer like normal glTexImageXD
                    // Run through this process for every mipmap to pregenerate mipmap pyramid
                    var pTmpData = new Uint8Array(iSize);
                    var pEmptyData;
                    var mip = 0;
                    for(mip = 0; mip <= this._nMipLevels; mip++) {
                        iSize = akra.pixelUtil.getMemorySize(iWidth, iHeight, iDepth, this._eFormat);
                        //console.log(iSize,iWidth, iHeight, iDepth, this._eFormat);
                        pEmptyData = pTmpData.subarray(0, iSize);
                        switch(this._eTextureType) {
                            case akra.ETextureTypes.TEXTURE_2D:
                                pWebGLContext.compressedTexImage2D(0x0DE1, mip, iWebGLFormat, iWidth, iHeight, 0, pEmptyData);
                                break;
                            case akra.ETextureTypes.TEXTURE_CUBE_MAP:
                                var iFace = 0;
                                for(iFace = 0; iFace < 6; iFace++) {
                                    pWebGLContext.compressedTexImage2D(0x8515 + iFace, mip, iWebGLFormat, iWidth, iHeight, 0, pEmptyData);
                                }
                                break;
                            default:
                                break;
                        }
                        ;
                        if (iWidth > 1) {
                            iWidth = iWidth / 2;
                        }
                        if (iHeight > 1) {
                            iHeight = iHeight / 2;
                        }
                        if (iDepth > 1) {
                            iDepth = iDepth / 2;
                        }
                    }
                    pTmpData = null;
                    pEmptyData = null;
                } else {
                    var mip = 0;
                    // Run through this process to pregenerate mipmap pyramid
                    for(mip = 0; mip <= this._nMipLevels; mip++) {
                        // Normal formats
                        switch(this._eTextureType) {
                            case akra.ETextureTypes.TEXTURE_2D:
                                //console.log(mip,iWidth, iHeight);
                                pWebGLContext.texImage2D(0x0DE1, mip, iWebGLFormat, iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, null);
                                break;
                            case akra.ETextureTypes.TEXTURE_CUBE_MAP:
                                var iFace = 0;
                                for(iFace = 0; iFace < 6; iFace++) {
                                    pWebGLContext.texImage2D(0x8515 + iFace, mip, iWebGLFormat, iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, null);
                                }
                                break;
                            default:
                                break;
                        }
                        if (iWidth > 1) {
                            iWidth = iWidth >>> 1;
                        }
                        if (iHeight > 1) {
                            iHeight = iHeight >>> 1;
                        }
                        if (iDepth > 1) {
                            iDepth = iDepth >>> 1;
                        }
                    }
                }
                this._createSurfaceList();
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(iWebGLTarget, null);
                return true;
            };
            WebGLInternalTexture.prototype.freeInternalTextureImpl = /**@protected*/ function () {
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                (pWebGLRenderer._pWebGLContext.deleteTexture((this._pWebGLTexture)));
                this._pWebGLTexture = null;
                for(var i = 0; i < this._pSurfaceList.length; i++) {
                    this._pSurfaceList[i].release();
                }
                this._pSurfaceList = null;
                return true;
            };
            WebGLInternalTexture.prototype._createSurfaceList = function () {
                this._pSurfaceList = new Array();
                // For all faces and mipmaps, store surfaces as IPixelBuffer
                var bWantGeneratedMips = (((this._iFlags) & (akra.ETextureFlags.AUTOMIPMAP)) != 0);
                // Do mipmapping in software? (uses GLU) For some cards, this is still needed. Of course,
                // only when mipmap generation is desired.
                var bDoSoftware = bWantGeneratedMips && !this._isMipmapsHardwareGenerated && this._nMipLevels !== 0;
                var iFace = 0;
                var mip = 0;
                var pTextureBufferPool = (((((this).pResourcePool)).pManager)).textureBufferPool;
                var sResourceName = this.findResourceName();
                for(iFace = 0; iFace < ((this)._eTextureType === /*checked (origin: akra)>>*/akra.ETextureTypes.TEXTURE_CUBE_MAP ? 6 : 1); iFace++) {
                    var iWidth = this._iWidth;
                    var iHeight = this._iHeight;
                    for(mip = 0; mip <= this._nMipLevels; mip++) {
                        var pBuf = pTextureBufferPool.createResource(sResourceName + "_" + iFace + "_" + mip);
                        pBuf.create(this._getWebGLTextureTarget(), this._pWebGLTexture, iWidth, iHeight, akra.webgl.getClosestWebGLInternalFormat(this._eFormat), akra.webgl.getWebGLDataType(this._eFormat), iFace, mip, this._iFlags, bDoSoftware && mip === 0);
                        this._pSurfaceList.push(pBuf);
                        //check error
                        if ((pBuf._iWidth) === 0 || (pBuf._iHeight) === 0 || (pBuf._iDepth) === 0) {
 {
                                akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 435);
                                akra.logger.criticalError("Zero sized texture surface on texture " + sResourceName + " face " + iFace + " mipmap " + mip + ". The GL driver probably refused to create the texture.");
                            }
                            ;
                        }
                    }
                }
            };
            WebGLInternalTexture.prototype.getBuffer = function (iFace, iMipmap) {
                if (typeof iFace === "undefined") { iFace = 0; }
                if (typeof iMipmap === "undefined") { iMipmap = 0; }
                if (iFace >= ((this)._eTextureType === /*checked (origin: akra)>>*/akra.ETextureTypes.TEXTURE_CUBE_MAP ? 6 : 1)) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 444);
                        akra.logger.criticalError("Face index out of range", iFace, ((this)._eTextureType === /*checked (origin: akra)>>*/akra.ETextureTypes.TEXTURE_CUBE_MAP ? 6 : 1));
                    }
                    ;
                }
                if (iMipmap > this._nMipLevels) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 448);
                        akra.logger.criticalError("Mipmap index out of range", iMipmap, this._nMipLevels);
                    }
                    ;
                }
                var idx = iFace * (this._nMipLevels + 1) + iMipmap;
 {
                    akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 452);
                    akra.logger.assert(idx < this._pSurfaceList.length, "smth " + this._pSurfaceList.length + " , " + iFace + " , " + this._nMipLevels + " , " + iMipmap);
                }
                ;
                return this._pSurfaceList[idx];
            };
            WebGLInternalTexture.prototype.createRenderTexture = function () {
                // Create the GL texture
                // This already does everything necessary
                return this.createInternalTexture();
            };
            return WebGLInternalTexture;
        })(akra.core.pool.resources.Texture);
        webgl.WebGLInternalTexture = WebGLInternalTexture;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (data) {
        var EVertexDataLimits;
        (function (EVertexDataLimits) {
            EVertexDataLimits._map = [];
            EVertexDataLimits.k_MaxElementsSize = 256;
        })(EVertexDataLimits || (EVertexDataLimits = {}));
        ;
        var VertexData = (function () {
            function VertexData(pVertexBuffer, id, iOffset, iCount, pDecl) {
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
                this._pVertexBuffer = pVertexBuffer;
                this._iOffset = iOffset;
                this._iLength = iCount;
                this._iId = id;
                this._pVertexDeclaration = null;
                this._iStride = 0;
                if ((typeof (pDecl) === "number")) {
                    this._iStride = pDecl;
                } else {
                    this._iStride = pDecl.stride;
                    this.setVertexDeclaration(pDecl);
                }
 {
                    akra.logger.setSourceLocation("data/VertexData.ts", 59);
                    akra.logger.assert(pVertexBuffer.byteLength >= ((this)._iLength * (this)._iStride) + ((this)._iOffset), "vertex data out of array linits");
                }
                ;
            }
            Object.defineProperty(VertexData.prototype, "id", {
                get: /** @inline */function () {
                    return this._iId;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VertexData.prototype, "length", {
                get: /** @inline */function () {
                    return this._iLength;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VertexData.prototype, "byteOffset", {
                get: /** @inline */function () {
                    return this._iOffset;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VertexData.prototype, "byteLength", {
                get: /** @inline */function () {
                    return this._iLength * this._iStride;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VertexData.prototype, "buffer", {
                get: /** @inline */function () {
                    return this._pVertexBuffer;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VertexData.prototype, "stride", {
                get: /** @inline */function () {
                    return this._iStride;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VertexData.prototype, "startIndex", {
                get: /** @inline */function () {
                    var iIndex = ((this)._iOffset) / ((this)._iStride);
 {
                        akra.logger.setSourceLocation("data/VertexData.ts", 34);
                        akra.logger.assert(iIndex % 1 == 0, "cannot calc first element index");
                    }
                    ;
                    return iIndex;
                },
                enumerable: true,
                configurable: true
            });
            VertexData.prototype.getVertexDeclaration = function () {
                return this._pVertexDeclaration;
            };
            VertexData.prototype.setVertexDeclaration = function (pDecl) {
                if (this._pVertexDeclaration) {
 {
                        akra.logger.setSourceLocation("data/VertexData.ts", 69);
                        akra.logger.error("vertex declaration already exists");
                    }
                    ;
                    return false;
                }
                var iStride = pDecl.stride;
                this._pVertexDeclaration = pDecl.clone();
 {
                    akra.logger.setSourceLocation("data/VertexData.ts", 80);
                    akra.logger.assert(iStride < EVertexDataLimits.k_MaxElementsSize, "stride max is 255 bytes");
                }
                ;
 {
                    akra.logger.setSourceLocation("data/VertexData.ts", 82);
                    akra.logger.assert(iStride <= ((this)._iStride), "stride in VertexDeclaration grather than stride in construtor");
                }
                ;
                return true;
            };
            VertexData.prototype.getVertexElementCount = /** @inline */function () {
                return ((this._pVertexDeclaration)._pElements.length);
            };
            VertexData.prototype.hasSemantics = function (sUsage) {
                if (this._pVertexDeclaration != null) {
                    return ((this._pVertexDeclaration).findElement((sUsage)) !== null);
                }
                return false;
            };
            VertexData.prototype.destroy = function () {
                this._pVertexDeclaration = null;
                this._iLength = 0;
            };
            VertexData.prototype.extend = function (pDecl, pData) {
                if (typeof pData === "undefined") { pData = null; }
                pDecl = akra.createVertexDeclaration(pDecl);
                if (((pData) === null)) {
                    pData = new Uint8Array(((this)._iLength) * pDecl.stride);
                } else {
                    pData = new Uint8Array(pData.buffer);
                }
 {
                    akra.logger.setSourceLocation("data/VertexData.ts", 114);
                    akra.logger.assert(((this)._iLength) === pData.byteLength / pDecl.stride, 'invalid data size for extending');
                }
                ;
                var nCount = this._iLength;
                //strides modifications
                var nStrideNew = pDecl.stride;
                var nStridePrev = ((this)._iStride);
                var nStrideNext = nStridePrev + nStrideNew;
                //total bytes after extending
                var nTotalSize = nStrideNext * ((this)._iLength);
                var pDeclNew = this.getVertexDeclaration().clone();
                //data migration
                var pDataPrev = new Uint8Array(this.getData());
                var pDataNext = new Uint8Array(nTotalSize);
                for(var i = 0, iOffset; i < nCount; ++i) {
                    iOffset = i * nStrideNext;
                    pDataNext.set(pDataPrev.subarray(i * nStridePrev, (i + 1) * nStridePrev), iOffset);
                    pDataNext.set((pData).subarray(i * nStrideNew, (i + 1) * nStrideNew), iOffset + nStridePrev);
                }
                if (!pDeclNew.extend(pDecl)) {
                    return false;
                }
                if (!this.resize(nCount, pDeclNew)) {
                    return false;
                }
                return this.setData(pDataNext, 0, nStrideNext);
            };
            VertexData.prototype.resize = function (nCount, pDecl) {
                var iStride = 0;
                var iOldOffset = ((this)._iOffset);
                var pOldVertexBuffer;
                var pOldVertexDeclaration;
                var iOldStride;
                //debug_print("VertexData (offset: " + this.byteOffset + ") resized from " + this.byteLength + " to ", arguments);
                if (arguments.length == 2) {
                    if ((typeof (pDecl) === "number")) {
                        iStride = pDecl;
                    } else {
                        iStride = (pDecl).stride;
                    }
                    if (nCount * iStride <= ((this)._iLength * (this)._iStride)) {
                        this._iLength = nCount;
                        this._iStride = iStride;
                        this._pVertexDeclaration = null;
                        if (!(typeof (pDecl) === "number")) {
                            this.setVertexDeclaration(pDecl);
                        }
                        return true;
                    } else {
                        pOldVertexBuffer = ((this)._pVertexBuffer);
                        pOldVertexBuffer.freeVertexData(this);
                        if (pOldVertexBuffer.getEmptyVertexData(nCount, pDecl, this) !== this) {
                            return false;
                        }
                        if (((this)._iOffset) != iOldOffset) {
 {
                                akra.logger.setSourceLocation("data/VertexData.ts", 187);
                                akra.logger.warning("vertex data moved from " + iOldOffset + " ---> " + ((this)._iOffset));
                            }
                            ;
                            this.relocation(this, iOldOffset, ((this)._iOffset));
                        }
                        return true;
                    }
                } else if (arguments.length == 1) {
                    if (nCount <= ((this)._iLength)) {
                        this._iLength = nCount;
                        return true;
                    } else {
                        pOldVertexBuffer = ((this)._pVertexBuffer);
                        pOldVertexDeclaration = this.getVertexDeclaration();
                        iOldStride = ((this)._iStride);
                        pOldVertexBuffer.freeVertexData(this);
                        if (pOldVertexBuffer.getEmptyVertexData(nCount, iOldStride, this) == null) {
                            return false;
                        }
                        this.setVertexDeclaration(pOldVertexDeclaration);
                        if (((this)._iOffset) != iOldOffset) {
 {
                                akra.logger.setSourceLocation("data/VertexData.ts", 213);
                                akra.logger.warning("vertex data moved from " + iOldOffset + " ---> " + ((this)._iOffset));
                            }
                            ;
                            this.relocation(this, iOldOffset, ((this)._iOffset));
                        }
                        return true;
                    }
                }
                return false;
            };
            VertexData.prototype.applyModifier = function (sUsage, fnModifier) {
                var pData = this.getTypedData(sUsage);
                fnModifier(pData);
                return this.setData(pData, sUsage);
            };
            VertexData.prototype.setData = function (pData) {
                var iOffset;
                var iSize;
                var nCountStart;
                var nCount;
                var iStride;
                var pVertexBuffer = this._pVertexBuffer;
                var pBackupBuf;
                var pDataU8;
                var k;
                var iOffsetBuffer;
                var pDeclaration = this._pVertexDeclaration;
                var pElement;
                switch(arguments.length) {
                    case 5:
                        if ((typeof (arguments[1]) === "string")) {
                            iOffset = this._pVertexDeclaration.findElement(arguments[1]).offset;
                        } else {
                            iOffset = arguments[1];
                        }
                        iSize = arguments[2];
                        nCountStart = arguments[3];
                        nCount = arguments[4];
                        iStride = ((this)._iStride);
                        pDataU8 = new Uint8Array(pData.buffer);
                        if (iStride != iSize) {
                            //FIXME: очень тормознутое место, крайне медленно работает...
                            if (pVertexBuffer.isBackupPresent() && nCount > 1) {
                                // console.log(pVertexBuffer.byteLength);
                                pBackupBuf = new Uint8Array(pVertexBuffer.byteLength);
                                pVertexBuffer.readData(pBackupBuf);
                                iOffsetBuffer = ((this)._iOffset);
                                for(var i = nCountStart; i < nCount + nCountStart; i++) {
                                    for(k = 0; k < iSize; k++) {
                                        pBackupBuf[iStride * i + iOffset + iOffsetBuffer + k] = pDataU8[iSize * (i - nCountStart) + k];
                                    }
                                }
                                pVertexBuffer.writeData(pBackupBuf, 0, pVertexBuffer.byteLength);
                            } else {
                                for(var i = 0; i < nCount; i++) {
                                    var iCurrent = i + nCountStart;
                                    pVertexBuffer.writeData(/*pData.buffer.slice*/
                                    pDataU8.subarray(iSize * i, iSize * (i + 1)), iStride * iCurrent + iOffset + ((this)._iOffset), iSize);
                                }
                            }
                        } else {
                            pVertexBuffer.writeData(/*pData.buffer.slice*/
                            //stride == size => iOffset = 0;
                            pDataU8.subarray(0, iStride * nCount), /*iOffset + */
                            ((this)._iOffset) + iStride * nCountStart, iStride * nCount);
                        }
                        return true;
                    case 4:
                        pElement = null;
                        if ((typeof (arguments[1]) === "string")) {
                            pElement = pDeclaration.findElement(arguments[1]);
                            if (pElement) {
                                return this.setData(pData, pElement.offset, pElement.size, arguments[2], arguments[3]);
                            }
                            return false;
                        }
                        iOffset = arguments[1];
                        iSize = arguments[2];
                        nCountStart = arguments[3] || 0;
                        nCount = pData.byteLength / iSize;
                        return this.setData(pData, iOffset, iSize, nCountStart, nCount);
                    case 2:
                    case 3:
                        var pDeclaration = this._pVertexDeclaration, pElement = null;
                        if ((typeof (arguments[1]) === "string")) {
                            pElement = pDeclaration.findElement(arguments[1]);
                            if (pElement) {
                                //nCountStart = arguments[2] || 0
                                nCountStart = 0;
                                nCount = pData.buffer.byteLength / pElement.size;
                                return this.setData(pData, pElement.offset, pElement.size, nCountStart, nCount);
                            }
                            return false;
                        } else if (arguments.length === 3) {
                            iOffset = arguments[1];
                            iSize = arguments[2];
                            nCountStart = 0;
                            nCount = pData.byteLength / iSize;
                            return this.setData(pData, iOffset, iSize, nCountStart, nCount);
                        }
                        return false;
                    case 1:
                        return this.setData(pData, ((this._pVertexDeclaration)._pElements[(0)] || null).usage);
                    default:
                        return false;
                }
            };
            VertexData.prototype.getData = function () {
                switch(arguments.length) {
                    case 4:
                    case 2:
                        if ((typeof (arguments[0]) === "string")) {
                            return null;
                        }
                        var iOffset = arguments[0];
                        var iSize = arguments[1];
                        var iFrom = 0;
                        var iCount = this._iLength;
                        if (arguments.length === 4) {
                            iFrom = arguments[2] || 0;
                            iCount = arguments[3] || this._iLength;
                        }
                        iCount = akra.math.min(iCount, this._iLength);
                        var iStride = ((this)._iStride);
                        var pBufferData = new Uint8Array(iSize * iCount);
                        for(var i = 0; i < iCount; i++) {
                            var iCurrent = iFrom + i;
                            var isOk = this._pVertexBuffer.readData(iStride * iCurrent + iOffset + ((this)._iOffset), iSize, pBufferData.subarray(i * iSize, (i + 1) * iSize));
 {
                                akra.logger.setSourceLocation("data/VertexData.ts", 401);
                                akra.logger.assert(isOk, "cannot read buffer");
                            }
                            ;
                            //pBufferData.set(new Uint8Array(), i * iSize);
                                                    }
                        return pBufferData.buffer;
                    case 3:
                    case 1:
                        var pDeclaration = this._pVertexDeclaration, pElement = null;
                        if ((typeof ("string") === "string")) {
                            pElement = pDeclaration.findElement(arguments[0]);
                            if (((pElement) != null)) {
                                return this.getData(pElement.offset, pElement.size, arguments.length === 3 ? arguments[1] : 0, arguments.length === 3 ? arguments[2] : this._iLength);
                            }
                            return null;
                        }
                        return null;
                    case 0:
                        return this.getData(0, this._pVertexDeclaration.stride);
                    default:
                        return null;
                }
            };
            VertexData.prototype.getTypedData = function (sUsage, iFrom, iCount) {
                var pVertexElement = this._pVertexDeclaration.findElement(sUsage);
                if (pVertexElement) {
                    return akra.util.abtota(this.getData(sUsage, iFrom, iCount), pVertexElement.type);
                }
                return null;
            };
            VertexData.prototype.getBufferHandle = /** @inline */function () {
                return this._pVertexBuffer.resourceHandle;
            };
            VertexData.prototype.toString = function () {
                if (akra.DEBUG) {
                    var s = "";
                    s += "          VERTEX DATA  #" + ((this)._iId) + "\n";
                    s += "---------------+-----------------------\n";
                    s += "        BUFFER : " + ((this)._pVertexBuffer.resourceHandle) + "\n";
                    s += "          SIZE : " + ((this)._iLength * (this)._iStride) + " b.\n";
                    s += "        OFFSET : " + ((this)._iOffset) + " b.\n";
                    s += "---------------+-----------------------\n";
                    s += " MEMBERS COUNT : " + ((this)._iLength) + " \n";
                    s += "        STRIDE : " + ((this)._iStride) + " \n";
                    s += "---------------+-----------------------\n";
                    s += this.getVertexDeclaration().toString();
                    return s;
                }
                return null;
            };
            VertexData.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            VertexData._pEventTable = new akra.events.EventTable();
            VertexData.prototype.getEventTable = /** @inline */function () {
                return VertexData._pEventTable;
            };
            VertexData.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            VertexData.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            VertexData.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (VertexData._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            VertexData.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (VertexData._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            VertexData.prototype._syncTable = /** @inline */function (pFrom) {
                (VertexData._pEventTable)._sync(this, pFrom);
            };
            VertexData.prototype.relocation = function (pTarget, iFrom, iTo) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((VertexData._pEventTable))).broadcast[(this._iGuid)] = (((VertexData._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).relocation;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pTarget, iFrom, iTo) : _broadcast[i].listener(_recivier, pTarget, iFrom, iTo);
                    }
                }
            };
            return VertexData;
        })();
        data.VertexData = VertexData;        
    })(akra.data || (akra.data = {}));
    var data = akra.data;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var MemoryBuffer = (function (_super) {
                    __extends(MemoryBuffer, _super);
                    function MemoryBuffer() {
                        _super.apply(this, arguments);

                    }
                    Object.defineProperty(MemoryBuffer.prototype, "byteLength", {
                        get: /** @inline */function () {
                            return this._pData.byteLength;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(MemoryBuffer.prototype, "length", {
                        get: /** @inline */function () {
                            return ((this)._pData.byteLength);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    MemoryBuffer.prototype.create = function (iByteSize, iFlags) {
                        if (typeof iFlags === "undefined") { iFlags = akra.EHardwareBufferFlags.DYNAMIC; }
                        ((iFlags) &= ~(akra.EHardwareBufferFlags.BACKUP_COPY | akra.EHardwareBufferFlags.DISCARDABLE | akra.EHardwareBufferFlags.ALIGNMENT));
                        var isCreated = _super.prototype.create.call(this, 0, iFlags | akra.EHardwareBufferFlags.SOFTWARE);
                        this._pData = new Uint8Array(iByteSize);
                        return isCreated;
                    };
                    MemoryBuffer.prototype.destroy = function () {
                        _super.prototype.destroy.call(this);
                        this._pData = null;
                    };
                    MemoryBuffer.prototype.resize = function (iSize) {
                        var pData = new Uint8Array(iSize);
                        if (iSize >= ((this)._pData.byteLength)) {
                            pData.set(this._pData);
                        } else {
                            pData.set(this._pData.subarray(0, iSize));
                        }
                        this._pData = pData;
                        ((this).setAlteredFlag(true));
                        return true;
                    };
                    MemoryBuffer.prototype.lockImpl = function (iOffset, iLength, iLockFlags) {
                        return this._pData.subarray(iOffset, iOffset + iLength);
                    };
                    MemoryBuffer.prototype.readData = function () {
                        var ppDest;
                        var iOffset;
                        var iSize;
                        if (arguments.length < 3) {
                            ppDest = arguments[0];
                            iOffset = 0;
                            iSize = ppDest.byteLength;
                        } else {
                            iOffset = arguments[0];
                            iSize = arguments[1];
                            ppDest = arguments[2];
                        }
 {
                            akra.logger.setSourceLocation("MemoryBuffer.ts", 75);
                            akra.logger.assert((iOffset + iSize) <= ((this)._pData.byteLength));
                        }
                        ;
                        /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/akra.memcpy((ppDest).buffer, (ppDest).byteOffset, this._pData.buffer, iOffset, iSize);
                        return true;
                    };
                    MemoryBuffer.prototype.writeData = // writeData(pData: Uint8Array, iOffset?: uint, iSize?: uint, bDiscardWholeBuffer: bool = false): bool;
                    function (pData, iOffset, iSize, bDiscardWholeBuffer) {
                        if (typeof iOffset === "undefined") { iOffset = 0; }
                        if (typeof iSize === "undefined") { iSize = pData.byteLength; }
                        if (typeof bDiscardWholeBuffer === "undefined") { bDiscardWholeBuffer = false; }
                        // writeData(pData: any, iOffset?: uint, iSize?: uint, bDiscardWholeBuffer: bool = false): bool {
                         {
                            akra.logger.setSourceLocation("MemoryBuffer.ts", 85);
                            akra.logger.assert((iOffset + iSize) <= ((this)._pData.byteLength));
                        }
                        ;
                        if (((pData) != null)) {
                            /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/akra.memcpy(this._pData.buffer, iOffset, (pData).buffer, (pData).byteOffset, iSize);
                        }
                        ((this).setAlteredFlag(true));
                        return true;
                    };
                    return MemoryBuffer;
                })(resources.HardwareBuffer);
                resources.MemoryBuffer = MemoryBuffer;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var VertexBuffer = (function (_super) {
                    __extends(VertexBuffer, _super);
                    /*pManager: IResourcePoolManager*/
                    function VertexBuffer() {
                        /*pManager*/
                                        _super.call(this);
                        /**@protected*/ this._pVertexDataArray = [];
                        /**@protected*/ this._iDataCounter = 0;
                    }
                    Object.defineProperty(VertexBuffer.prototype, "type", {
                        get: /** @inline */function () {
                            return akra.EVertexBufferTypes.UNKNOWN;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(VertexBuffer.prototype, "length", {
                        get: /** @inline */function () {
                            return this._pVertexDataArray.length;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    VertexBuffer.prototype.create = // create(iByteSize: uint, iFlags?: uint, pData?: Uint8Array): bool;
                    function (iByteSize, iFlags, pData) {
                        // create(iByteSize: uint, iFlags?: uint, pData?: any): bool {
                        _super.prototype.create.call(this, 0, iFlags || 0);
                        if ((((iFlags) & (akra.EHardwareBufferFlags.BACKUP_COPY)) != 0)) {
                            this._pBackupCopy = new resources.MemoryBuffer();
                            this._pBackupCopy.create(iByteSize);
                            this._pBackupCopy.writeData(pData, 0, iByteSize);
                        }
                        return true;
                    };
                    VertexBuffer.prototype.destroy = function () {
                        _super.prototype.destroy.call(this);
                        this._pBackupCopy.destroy();
                        this.freeVertexData();
                        this._iDataCounter = 0;
                    };
                    VertexBuffer.prototype.getVertexData = function (iOffset, iCount, pData) {
                        if (arguments.length < 2) {
                            return this._pVertexDataArray[arguments[0]];
                        }
                        var pDecl = akra.createVertexDeclaration(pData);
                        var pVertexData = new akra.data.VertexData(this, this._iDataCounter++, iOffset, iCount, pDecl);
                        this._pVertexDataArray.push(pVertexData);
                        ((this).setAlteredFlag(true));
                        return pVertexData;
                    };
                    VertexBuffer.prototype.getEmptyVertexData = function (iCount, pDeclData, ppVertexDataIn) {
                        var pDecl = null;
                        var pHole = [];
                        var i;
                        var pVertexData;
                        var iTemp;
                        var iStride = 0;
                        var iAligStart;
                        var iNewSize = 0;
                        while(true) {
                            pHole[0] = {
                                start: 0,
                                end: this.byteLength
                            };
                            for(var k = 0; k < this._pVertexDataArray.length; ++k) {
                                pVertexData = this._pVertexDataArray[k];
                                for(i = 0; i < pHole.length; i++) {
                                    //Полностью попадает внутрь
                                    if (pVertexData.byteOffset > pHole[i].start && pVertexData.byteOffset + pVertexData.byteLength < pHole[i].end) {
                                        iTemp = pHole[i].end;
                                        pHole[i].end = pVertexData.byteOffset;
                                        pHole.splice(i + 1, 0, {
                                            start: pVertexData.byteOffset + pVertexData.byteLength,
                                            end: iTemp
                                        });
                                        i--;
                                    } else if (pVertexData.byteOffset == pHole[i].start && pVertexData.byteOffset + pVertexData.byteLength < pHole[i].end) {
                                        pHole[i].start = pVertexData.byteOffset + pVertexData.byteLength;
                                    } else if (pVertexData.byteOffset > pHole[i].start && pVertexData.byteOffset + pVertexData.byteLength == pHole[i].end) {
                                    } else if (pVertexData.byteOffset == pHole[i].start && pVertexData.byteLength == (pHole[i].end - pHole[i].start)) {
                                        pHole.splice(i, 1);
                                        i--;
                                    } else //Перекрывает снизу
                                    if (pVertexData.byteOffset < pHole[i].start && pVertexData.byteOffset + pVertexData.byteLength > pHole[i].start && pVertexData.byteOffset + pVertexData.byteLength < pHole[i].end) {
                                        pHole[i].start = pVertexData.byteOffset + pVertexData.byteLength;
                                    } else if (pVertexData.byteOffset < pHole[i].start && pVertexData.byteOffset + pVertexData.byteLength > pHole[i].start && pVertexData.byteOffset + pVertexData.byteLength == pHole[i].end) {
                                        pHole.splice(i, 1);
                                        i--;
                                    } else //Перекрывается сверху
                                    if (pVertexData.byteOffset + pVertexData.byteLength > pHole[i].end && pVertexData.byteOffset > pHole[i].start && pVertexData.byteOffset < pHole[i].end) {
                                        pHole[i].end = pVertexData.byteOffset;
                                    } else if (pVertexData.byteOffset + pVertexData.byteLength > pHole[i].end && pVertexData.byteOffset == pHole[i].start && pVertexData.byteOffset < pHole[i].end) {
                                        pHole.splice(i, 1);
                                        i--;
                                    } else //полнстью перекрывает
                                    if (pVertexData.byteOffset < pHole[i].start && pVertexData.byteOffset + pVertexData.byteLength > pHole[i].end) {
                                        i--;
                                    }
                                }
                            }
                            pHole.sort(/** @inline */function (a, b) {
                                return ((a.end - a.start) - (b.end - b.start));
                            });
                            if (!(typeof (pDeclData) === "number")) {
                                pDecl = akra.createVertexDeclaration(pDeclData);
                                iStride = pDecl.stride;
                            } else {
                                iStride = pDeclData;
                            }
                            // console.log(arguments[0], arguments[1].toString());
                            // console.log("Buffer size >", this.byteLength, iCount * iStride)
                            for(i = 0; i < pHole.length; i++) {
                                iAligStart = (((((this)._iFlags) & (/*checked (origin: akra)>>*/akra.EHardwareBufferFlags.ALIGNMENT)) != 0)) ? akra.math.alignUp(pHole[i].start, (/*checked (origin: math)>>*/akra.math.abs((iStride) * (4)) / /*checked (origin: math)>>*/akra.math.nod((iStride), (4)))) : akra.math.alignUp(pHole[i].start, iStride);
                                if ((pHole[i].end - iAligStart) >= iCount * iStride) {
                                    if (arguments.length == 2) {
                                        pVertexData = new akra.data.VertexData(this, this._iDataCounter++, iAligStart, iCount, pDeclData);
                                        this._pVertexDataArray.push(pVertexData);
                                        ((this).setAlteredFlag(true));
                                        return pVertexData;
                                    } else if (arguments.length == 3) {
                                        ((ppVertexDataIn).constructor).call(ppVertexDataIn, this, ppVertexDataIn.id, iAligStart, iCount, pDeclData);
                                        this._pVertexDataArray.push(ppVertexDataIn);
                                        ((this).setAlteredFlag(true));
                                        return ppVertexDataIn;
                                    }
                                    return null;
                                }
                            }
                            iNewSize = akra.math.max(this.byteLength * 2, this.byteLength + iCount * iStride);
                            if (this.resize(iNewSize) == false) {
 {
                                    akra.logger.setSourceLocation("core/pool/resources/VertexBuffer.ts", 182);
                                    akra.logger.warning("cannot resize buffer from " + this.byteLength + " bytes to " + iNewSize + " bytes ");
                                }
                                ;
                                break;
                            }
                        }
                        return null;
                    };
                    VertexBuffer.prototype.freeVertexData = function (pVertexData) {
                        if (arguments.length == 0) {
                            for(var i = 0; i < this._pVertexDataArray.length; i++) {
                                this._pVertexDataArray[Number(i)].destroy();
                            }
                            this._pVertexDataArray = null;
                        } else {
                            for(var i = 0; i < this._pVertexDataArray.length; i++) {
                                if (this._pVertexDataArray[i] == pVertexData) {
                                    pVertexData.destroy();
                                    this._pVertexDataArray.splice(i, 1);
                                    ((this).setAlteredFlag(true));
                                    return true;
                                }
                            }
                            return false;
                        }
                        ((this).setAlteredFlag(true));
                        return true;
                    };
                    VertexBuffer.prototype.allocateData = function (pDeclData, pData) {
                        var pDecl = akra.createVertexDeclaration(pDeclData);
                        var pVertexData;
                        var iCount = pData.byteLength / pDecl.stride;
 {
                            akra.logger.setSourceLocation("core/pool/resources/VertexBuffer.ts", 226);
                            akra.logger.assert(iCount === akra.math.floor(iCount), 'Data size should be a multiple of the vertex declaration.');
                        }
                        ;
                        pVertexData = this.getEmptyVertexData(iCount, pDecl);
 {
                            akra.logger.setSourceLocation("core/pool/resources/VertexBuffer.ts", 230);
                            akra.logger.assert(!((pVertexData) === null), "Could not allocate vertex data!");
                        }
                        ;
                        pVertexData.setData(pData, 0, pDecl.stride);
                        return pVertexData;
                    };
                    return VertexBuffer;
                })(resources.HardwareBuffer);
                resources.VertexBuffer = VertexBuffer;                
                /** @inline */function isVBO(pBuffer) {
                    return pBuffer.type === akra.EVertexBufferTypes.VBO;
                }
                resources.isVBO = isVBO;
                /** @inline */function isTBO(pBuffer) {
                    return pBuffer.type === akra.EVertexBufferTypes.TBO;
                }
                resources.isTBO = isTBO;
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLVertexBuffer = (function (_super) {
            __extends(WebGLVertexBuffer, _super);
            /*pManager: IResourcePoolManager*/
            function WebGLVertexBuffer() {
                /*pManager*/
                        _super.call(this);
                this._pLockData = null;
                /**@protected*/ this._sCS = null;
            }
            Object.defineProperty(WebGLVertexBuffer.prototype, "type", {
                get: /** @inline */function () {
                    return akra.EVertexBufferTypes.VBO;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLVertexBuffer.prototype, "byteLength", {
                get: /** @inline */function () {
                    return this._iByteSize;
                },
                enumerable: true,
                configurable: true
            });
            WebGLVertexBuffer.prototype.create = // create(iByteSize: uint, iFlags: uint = EHardwareBufferFlags.STATIC, pData: Uint8Array = null): bool;
            function (iByteSize, iFlags, pData) {
                if (typeof iFlags === "undefined") { iFlags = akra.EHardwareBufferFlags.STATIC; }
                if (typeof pData === "undefined") { pData = null; }
                // create(iByteSize: uint, iFlags: uint = EHardwareBufferFlags.STATIC, pData: any = null): bool {
                iByteSize = akra.math.max(iByteSize, 1024);
                if ((((iFlags) & (akra.EHardwareBufferFlags.READABLE)) != 0)) {
                    ((iFlags) |= (akra.EHardwareBufferFlags.BACKUP_COPY));
                }
                _super.prototype.create.call(this, iByteSize, iFlags, pData);
                var pWebGLRenderer = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.getEngine().getRenderer();
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                var i;
 {
                    akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 45);
                    akra.logger.assert(this._pWebGLBuffer == null, "webgl buffer already allocated");
                }
                ;
                this._iByteSize = iByteSize;
                this._iFlags = iFlags;
                pWebGLContext = (pWebGLRenderer._pWebGLContext);
 {
                    akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 51);
                    akra.logger.assert(pWebGLContext !== null, "cannot grab webgl context");
                }
                ;
                //Софтварного рендеринга буфера у нас нет
                 {
                    akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 54);
                    akra.logger.assert(!(((((this)._iFlags) & (/*checked (origin: akra)>>*/akra.EHardwareBufferFlags.SOFTWARE)) != 0)), "no sftware rendering");
                }
                ;
                //Если есть локальная копия то буфер можно читать
                if (((this)._pBackupCopy != null)) {
                    ((this._iFlags) |= (akra.EHardwareBufferFlags.READABLE));
                }
 {
                    akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 62);
                    akra.logger.assert(!pData || pData.byteLength <= iByteSize, "Размер переданного массива больше переданного размера буфера");
                }
                ;
                this._pWebGLBuffer = (pWebGLRenderer._pWebGLContext.createBuffer());
                if (!this._pWebGLBuffer) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 68);
                        akra.logger.criticalError("Не удалось создать буфер");
                    }
                    ;
                    this.destroy();
                    return false;
                }
                (pWebGLRenderer._pWebGLContext.bindBuffer((0x8892), (this._pWebGLBuffer)));
                pWebGLContext.bufferData(0x8892, this._iByteSize, webgl.getWebGLUsage(this._iFlags));
                if (((pData) != null)) {
                    /*pWebGLContext.bufferSubData(
                    GL_ARRAY_BUFFER, 0, isArrayBuffer(pData)? <ArrayBuffer>pData: (<Uint8Array>pData).buffer);*/
                    pWebGLContext.bufferSubData(0x8892, 0, pData.buffer);
                }
                return true;
            };
            WebGLVertexBuffer.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
                var pWebGLRenderer = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.getEngine().getRenderer();
                (pWebGLRenderer._pWebGLContext.deleteBuffer((this._pWebGLBuffer)));
                this._pWebGLBuffer = null;
                this._iByteSize = 0;
            };
            WebGLVertexBuffer.prototype.readData = function (iOffset, iSize, ppDest) {
 {
                    akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 102);
                    akra.logger.assert(!((this._pWebGLBuffer) === null), "Буффер еще не создан");
                }
                ;
                if (!((this)._pBackupCopy != null)) {
                    return false;
                }
                if (arguments.length === 1) {
                    this._pBackupCopy.readData(arguments[0]);
                } else {
                    this._pBackupCopy.readData(iOffset, iSize, ppDest);
                }
                return true;
            };
            WebGLVertexBuffer.prototype.writeData = function (pData, iOffset, iSize, bDiscardWholeBuffer) {
                if (typeof bDiscardWholeBuffer === "undefined") { bDiscardWholeBuffer = false; }
 {
                    akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 122);
                    akra.logger.assert(!((this._pWebGLBuffer) === null), "WebGL buffer not exists");
                }
                ;
                var pWebGLRenderer = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.getEngine().getRenderer();
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                (pWebGLRenderer._pWebGLContext.bindBuffer((0x8892), (this._pWebGLBuffer)));
 {
                    akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 129);
                    akra.logger.assert(pData.byteLength <= iSize, "Размер переданного массива больше переданного размера");
                }
                ;
 {
                    akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 130);
                    akra.logger.assert(((this)._iByteSize) >= iOffset + iSize, "Данные выйдут за предел буфера");
                }
                ;
                var pU8Data = null;
                if (((pData) instanceof ArrayBuffer)) {
                    pU8Data = new Uint8Array(pData);
                } else {
                    pU8Data = new Uint8Array(pData.buffer, pData.byteOffset, pData.byteLength);
                }
                pU8Data = pU8Data.subarray(0, iSize);
                pWebGLContext.bufferSubData(0x8892, iOffset, pU8Data);
                if (((this)._pBackupCopy != null)) {
                    this._pBackupCopy.writeData(pU8Data, iOffset);
                }
                ((this).setAlteredFlag(true));
                return true;
            };
            WebGLVertexBuffer.prototype.resize = function (iSize) {
                var eUsage;
                var pData;
                var iMax = 0;
                var pVertexData;
                var pWebGLRenderer = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.getEngine().getRenderer();
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                if (!((this)._pBackupCopy != null)) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 164);
                        akra.logger.log("Not resized, because backup not present!");
                    }
                    ;
                    return false;
                }
 {
                    akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 168);
                    akra.logger.log("WebGLVertexBuffer resized from " + ((this)._iByteSize) + " to " + iSize + "(" + ((this)._iGuid) + ")");
                }
                ;
                // debug_print(__CALLSTACK__);
                if (iSize < ((this)._iByteSize)) {
                    for(var k = 0; k < this._pVertexDataArray.length; ++k) {
                        pVertexData = this._pVertexDataArray[k];
                        if (pVertexData.byteOffset + pVertexData.byteLength > iMax) {
                            iMax = pVertexData.byteOffset + pVertexData.byteLength;
                        }
                    }
 {
                        akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 182);
                        akra.logger.assert(iMax <= iSize, "Уменьшение невозможно. Страая разметка не укладывается в новый размер");
                    }
                    ;
                }
                if (pWebGLContext.isBuffer(this._pWebGLBuffer)) {
                    (pWebGLRenderer._pWebGLContext.deleteBuffer((this._pWebGLBuffer)));
                }
                eUsage = webgl.getWebGLUsage(this._iFlags);
                this._pWebGLBuffer = (pWebGLRenderer._pWebGLContext.createBuffer());
                if (!this._pWebGLBuffer) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 194);
                        akra.logger.criticalError("Не удалось создать буфер");
                    }
                    ;
                    this.destroy();
                    return false;
                }
                (pWebGLRenderer._pWebGLContext.bindBuffer((0x8892), (this._pWebGLBuffer)));
                pWebGLContext.bufferData(0x8892, iSize, eUsage);
                pData = new Uint8Array(this._iByteSize);
                if (!this.readData(pData)) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 207);
                        akra.logger.warning("cannot read data from buffer");
                    }
                    ;
                    return false;
                }
                this.writeData(pData, 0, this._iByteSize);
                this._pBackupCopy.resize(iSize);
                this._iByteSize = iSize;
                ((this).setAlteredFlag(true));
                return true;
            };
            WebGLVertexBuffer.prototype.getWebGLBuffer = /** @inline */function () {
                return this._pWebGLBuffer;
            };
            WebGLVertexBuffer.prototype.lockImpl = /**@protected*/ function (iOffset, iSize, iLockFlags) {
                var pRetData = new Uint8Array(iSize);
                this.readData(iOffset, iSize, pRetData);
                this._pLockData = pRetData;
                return pRetData;
            };
            WebGLVertexBuffer.prototype.unlockImpl = /**@protected*/ function () {
                this.writeData(this._pLockData, this._iLockStart, this._iLockSize);
            };
            WebGLVertexBuffer.prototype.copyBackupToRealImpl = /**@protected*/ function (pRealData, pBackupData, iLockFlags) {
                pRealData.set(pBackupData);
            };
            return WebGLVertexBuffer;
        })(akra.core.pool.resources.VertexBuffer);
        webgl.WebGLVertexBuffer = WebGLVertexBuffer;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLVertexTexture = (function (_super) {
            __extends(WebGLVertexTexture, _super);
            /*pManager: IResourcePoolManager*/
            function WebGLVertexTexture() {
                /*pManager*/
                        _super.call(this);
                /**@protected*/ this._iWidth = 0;
                /**@protected*/ this._iHeight = 0;
                /**@protected*/ this._pWebGLTexture = null;
                /**@protected*/ this._ePixelFormat = akra.EPixelFormats.FLOAT32_RGBA;
                //переменная нужна, чтобы проигнорировать обновление копии, обычно, это не требуется
                /**@protected*/ this._bForceUpdateBackupCopy = true;
                /*vertex data for header updating*/
                /**@protected*/ this._pHeader = null;
                this._pLockData = null;
            }
            Object.defineProperty(WebGLVertexTexture.prototype, "type", {
                get: /** @inline */function () {
                    return akra.EVertexBufferTypes.TBO;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLVertexTexture.prototype, "byteLength", {
                get: /** @inline */function () {
                    return akra.pixelUtil.getMemorySize(this._iWidth, this._iHeight, 1, this._ePixelFormat);
                },
                enumerable: true,
                configurable: true
            });
            WebGLVertexTexture.prototype.getWebGLTexture = /** @inline */function () {
                return this._pWebGLTexture;
            };
            WebGLVertexTexture.prototype._getWidth = /** @inline */function () {
                return this._iWidth;
            };
            WebGLVertexTexture.prototype._getHeight = /** @inline */function () {
                return this._iHeight;
            };
            WebGLVertexTexture.prototype.create = function (iByteSize, iFlags, pData) {
                if (typeof iFlags === "undefined") { iFlags = akra.EHardwareBufferFlags.STATIC; }
                if (typeof pData === "undefined") { pData = null; }
                var iMinWidth = 32;
                var iWidth, iHeight;
                var pTextureData = null;
                var pDataU8 = pData;
                /*header size*/
                var iAdditionalHeaderSize = (((pData) != null)) ? 32 : 0;
                iByteSize = akra.math.max(iByteSize + iAdditionalHeaderSize, akra.pixelUtil.getMemorySize(iMinWidth, iMinWidth, 1, this._ePixelFormat));
                if ((((iFlags) & (akra.EHardwareBufferFlags.READABLE)) != 0)) {
                    ((iFlags) |= (akra.EHardwareBufferFlags.BACKUP_COPY));
                }
                _super.prototype.create.call(this, iByteSize, iFlags, pData);
                var pPOTSize = akra.math.calcPOTtextureSize(akra.math.ceil(iByteSize / (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor((this._ePixelFormat)).elemBytes)));
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                var i;
                iWidth = pPOTSize[0];
                iHeight = pPOTSize[1];
 {
                    akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 85);
                    akra.logger.assert(this._pWebGLTexture == null, "webgl texture already allocated");
                }
                ;
                this._iWidth = iWidth;
                this._iHeight = iHeight;
                this._iFlags = iFlags;
 {
                    akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 91);
                    akra.logger.assert(pWebGLContext !== null, "cannot grab webgl context");
                }
                ;
                //Софтварного рендеринга буфера у нас нет
                 {
                    akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 94);
                    akra.logger.assert(!(((((this)._iFlags) & (/*checked (origin: akra)>>*/akra.EHardwareBufferFlags.SOFTWARE)) != 0)), "no software rendering");
                }
                ;
                //Если есть локальная копия то буфер можно читать
                if (((this)._pBackupCopy != null)) {
                    ((this._iFlags) |= (akra.EHardwareBufferFlags.READABLE));
                }
 {
                    akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 102);
                    akra.logger.assert(!pData || pData.byteLength <= iByteSize, "Размер переданного массива больше переданного размера буфера");
                }
                ;
 {
                    akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 105);
                    akra.logger.assert(webgl.loadExtension(pWebGLContext, "OES_texture_float"), "OES_texture_float extension is necessary for correct work.");
                }
                ;
                this._pWebGLTexture = (pWebGLRenderer._pWebGLContext.createTexture());
                this._eWebGLFormat = webgl.getWebGLFormat(this._ePixelFormat);
                this._eWebGLType = webgl.getWebGLDataType(this._ePixelFormat);
                if (!this._pWebGLTexture) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 112);
                        akra.logger.criticalError("Не удалось создать буфер");
                    }
                    ;
                    this.destroy();
                    return false;
                }
                if (((pData) != null)) {
                    if (pData.BYTES_PER_ELEMENT > 1) {
                        pDataU8 = new Uint8Array(pData, pData.byteOffset, pData.byteLength);
                    }
                    pTextureData = new Uint8Array((/*checked (origin: akra)>>*/akra.pixelUtil.getMemorySize((this)._iWidth, (this)._iHeight, 1, (this)._ePixelFormat)));
                    pTextureData.set(pDataU8);
                }
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(0x0DE1, this._pWebGLTexture);
                pWebGLContext.texImage2D(0x0DE1, 0, this._eWebGLFormat, this._iWidth, this._iHeight, 0, this._eWebGLFormat, this._eWebGLType, pTextureData);
                pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_MAG_FILTER, pWebGLContext.NEAREST);
                pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_MIN_FILTER, pWebGLContext.NEAREST);
                pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_WRAP_S, pWebGLContext.CLAMP_TO_EDGE);
                pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_WRAP_T, pWebGLContext.CLAMP_TO_EDGE);
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(0x0DE1, null);
                //create header
                this._pHeader = this.allocateData([
                    (({
count: (2),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.TEXTURE_HEADER)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                ], this._header());
                /**
                * update program
                **/
                var pProgram = (((((this).pResourcePool)).pManager)).shaderProgramPool.findResource("WEBGL_vertex_texture_update");
                if (((pProgram) === null)) {
                    pProgram = (((((this).pResourcePool)).pManager)).shaderProgramPool.createResource("WEBGL_vertex_texture_update");
                    pProgram.create("																									\n	        	uniform sampler2D sourceTexture;																	\n				attribute vec4  VALUE;																				\n				attribute float INDEX;																				\n				attribute float SHIFT;																				\n				                      																				\n				uniform vec2 size;																					\n				varying vec4 color;																					\n				                   																					\n				void main(void){																					\n				    vec4 value = VALUE;																				\n				    float  serial = INDEX;																			\n				                          																			\n				    int shift = int(SHIFT);																			\n				    if (shift != 0) {																				\n				        color = texture2D(sourceTexture,                                        					\n				            vec2((mod(serial, size.x) +.5 ) / size.x, (floor(serial / size.x) + .5) / size.y)		\n				            );																						\n																													\n																													\n				        if (shift == 1) {																			\n				            color = vec4(color.r, value.gba);														\n				        }																							\n				        else if (shift == 2) {																		\n				            color = vec4(color.rg, value.ba);														\n				        }																							\n				        else if (shift == 3) {																		\n				            color = vec4(color.rgb, value.a);														\n				        }																							\n				        else if (shift == -1) {																		\n				            color = vec4(value.r, color.gba);														\n				        }																							\n				        else if (shift == -2) {																		\n				            color = vec4(value.rg, color.ba);														\n				        }																							\n				        else {																						\n				            color = vec4(value.rgb, color.a);														\n				        }																							\n				    }																								\n				    else {																							\n				        color = value;																				\n				    }																								\n				    gl_PointSize = 1.;																				\n				    gl_Position = vec4(2. * (mod(serial, size.x) + .5) / size.x - 1.,								\n				                    2. * (floor(serial / size.x)  + .5) / size.y - 1., 0., 1.);						\n				}																									\n				", "									\n				#ifdef GL_ES                        \n				    precision highp float;          \n				#endif								\n				varying vec4 color;                 \n				                                    \n				void main(void) {                   \n				    gl_FragColor = color;           \n				}                                   \n				");
                }
                /**
                * resize program
                **/
                pProgram = (((((this).pResourcePool)).pManager)).shaderProgramPool.findResource("WEBGL_vertex_texture_resize");
                if (((pProgram) === null)) {
                    pProgram = (((((this).pResourcePool)).pManager)).shaderProgramPool.createResource("WEBGL_vertex_texture_resize");
                    pProgram.create("																									\n	        	attribute float INDEX;																				\n	        																										\n	        	uniform sampler2D sourceTexture;																	\n				                      																				\n				uniform vec2 v2fSrcTexSize;																			\n				uniform vec2 v2fDstTexSize;																			\n																													\n				varying vec4 v4fValue;																				\n				                   																					\n				void main(void){																					\n					                       																			\n				    vec2 v2fSrcPosition = vec2((mod(INDEX, v2fSrcTexSize.x) + 0.5)/v2fSrcTexSize.x,					\n				    						   (floor(INDEX/v2fSrcTexSize.x) + 0.5)/v2fSrcTexSize.y);				\n	        																										\n	        		vec2 v2fDstPosition = vec2((mod(INDEX, v2fDstTexSize.x) + 0.5)/v2fDstTexSize.x,					\n				    						   (floor(INDEX/v2fDstTexSize.x) + 0.5)/v2fDstTexSize.y);				\n	        																										\n	        		v4fValue = texture2D(sourceTexture, v2fSrcPosition);											\n	        																										\n	        		gl_PointSize = 1.;																				\n	        		gl_Position = vec4(v2fDstPosition*2. - 1., 0., 1.);												\n				}																									\n				", "									\n				#ifdef GL_ES                        \n				    precision highp float;          \n				#endif								\n				varying vec4 v4fValue;              \n				                                    \n				void main(void) {                   \n				    gl_FragColor = v4fValue;        \n				}                                   \n				");
                }
                if (((WebGLVertexTexture._pWebGLBuffer1) === null)) {
                    WebGLVertexTexture._pWebGLBuffer1 = (pWebGLRenderer._pWebGLContext.createBuffer());
                }
                if (((WebGLVertexTexture._pWebGLBuffer2) === null)) {
                    WebGLVertexTexture._pWebGLBuffer2 = (pWebGLRenderer._pWebGLContext.createBuffer());
                }
                if (((WebGLVertexTexture._pWebGLBuffer3) === null)) {
                    WebGLVertexTexture._pWebGLBuffer3 = (pWebGLRenderer._pWebGLContext.createBuffer());
                }
                return true;
            };
            WebGLVertexTexture.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                (pWebGLRenderer._pWebGLContext.deleteTexture((this._pWebGLTexture)));
                this._pWebGLTexture = null;
            };
            WebGLVertexTexture.prototype.readData = function (iOffset, iSize, ppDest) {
 {
                    akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 281);
                    akra.logger.assert(!((this._pWebGLTexture) === null), "Буффер еще не создан");
                }
                ;
                if (!((this)._pBackupCopy != null)) {
                    return false;
                }
                if (arguments.length === 1) {
                    this._pBackupCopy.readData(arguments[0]);
                } else {
                    this._pBackupCopy.readData(iOffset, iSize, ppDest);
                }
                return true;
            };
            WebGLVertexTexture.prototype.writeData = function (pData, iOffset, iSize, bDiscardWholeBuffer) {
                if (typeof bDiscardWholeBuffer === "undefined") { bDiscardWholeBuffer = false; }
                /*предпологается, что float*/
                                var iTypeSize = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/akra.pixelUtil.getComponentTypeBits(this._ePixelFormat) / 8, nElementsPerPix = /*число float'ов в пикселе*/
                (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor((this._ePixelFormat)).componentCount), iFrom, iCount;
                /*номер float'a с которого начинается обновление*/
                /*исло float'ов для обновления*/
                /*данные для обновления*/
                var pBufferData;
                /*смещение внутри первого пикселя*/
                                var iLeftShift, iRightShift, iBeginPix, iEndPix, nPixels, nElements;
                /*смещение внутри последнего пикселя*/
                /*пиксель с которого начинается обновление*/
                /*пиксель на котором заканчивается обновление*/
                /*число пикселей*/
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                var pDataU8 = pData;
 {
                    akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 319);
                    akra.logger.assert(bDiscardWholeBuffer === false, "Discard option temporary unsupported.");
                }
                ;
                if (pData.BYTES_PER_ELEMENT > 1) {
                    pDataU8 = new Uint8Array(pData.buffer, pData.byteOffset, pData.byteLength);
                }
                iOffset = iOffset || 0;
                iSize = iSize || pData.byteLength;
                pDataU8 = pDataU8.subarray(0, iSize);
                if ((/*checked (origin: akra)>>*/akra.pixelUtil.getMemorySize((this)._iWidth, (this)._iHeight, 1, (this)._ePixelFormat)) < iOffset + iSize) {
                    this.resize(iOffset + iSize);
                }
                if (((this)._pBackupCopy != null) && this._bForceUpdateBackupCopy) {
                    this._pBackupCopy.writeData(pDataU8, iOffset);
                }
                this._bForceUpdateBackupCopy = true;
 {
                    akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 340);
                    akra.logger.assert(iOffset % iTypeSize === 0 && iSize % iTypeSize === 0, "Incorrect data size or offset");
                }
                ;
                iFrom = iOffset / iTypeSize;
                iCount = iSize / iTypeSize;
                iLeftShift = iFrom % nElementsPerPix;
                iRightShift = ((iFrom + iCount) % nElementsPerPix);
                iBeginPix = Math.floor(iFrom / nElementsPerPix);
                iEndPix = Math.floor((iFrom + iCount) / nElementsPerPix);
                nPixels = Math.ceil((iFrom + iCount) / nElementsPerPix) - Math.floor(iFrom / nElementsPerPix);
                nElements = nPixels * nElementsPerPix;
                pBufferData = new Float32Array(pDataU8.buffer, pDataU8.byteOffset);
                if (iLeftShift === 0 && iRightShift === 0) {
                    var iWidth = this._iWidth;
                    var iYmin = Math.floor(iBeginPix / iWidth);
                    var iYmax = Math.ceil(iEndPix / iWidth);
                    var iXbegin = iBeginPix % iWidth;
                    var iXend = iEndPix % iWidth;
                    var iHeight = iYmax - iYmin;
                    var iBeginElement = 0, iEndElement = 0;
                    //hack: if iEndPixel is first pixel from next row
                    iXend = (iXend === 0 ? iWidth : iXend);
                    //FIX THIS, move this function from here...
                    var me = this;
                    function updatePixelRect(iX, iY, iW, iH) {
                        iBeginElement = iEndElement;
                        iEndElement = iW * iH * nElementsPerPix + iEndElement;
                        /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(0x0DE1, me._pWebGLTexture);
                        pWebGLContext.texSubImage2D(0x0DE1, 0, iX, iY, iW, iH, me._eWebGLFormat, me._eWebGLType, pBufferData.subarray(iBeginElement, iEndElement));
                        /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(0x0DE1, null);
                    }
                    ;
                    if (iHeight === 1) {
                        updatePixelRect(iXbegin, iYmin, iXend - iXbegin, 1);
                    } else {
                        updatePixelRect(iXbegin, iYmin, iWidth - iXbegin, 1);
                        if (iHeight > 2) {
                            updatePixelRect(0, iYmin + 1, iWidth, iHeight - 2);
                        }
                        updatePixelRect(0, iYmax - 1, iXend, 1);
                    }
                } else if (((this)._pBackupCopy != null)) {
                    var iRealOffset = iBeginPix * nElementsPerPix * iTypeSize;
                    var iRealSize = nElements * iTypeSize;
                    var pTempData = this._pBackupCopy.lock(iRealOffset, iRealSize);
                    //var iTotalSize: uint 	= iRealOffset + iRealSize;
                    //FIX ME:
                    this._pBackupCopy.unlock();
                    this._bForceUpdateBackupCopy = false;
                    return this.writeData(pTempData, iRealOffset, iRealSize);
                } else {
                    //console.error(this);
                    var pMarkupDataIndex = new Float32Array(nPixels);
                    var pMarkupDataShift = new Float32Array(nPixels);
                    var pRealData = new Float32Array(nElements);
                    pMarkupDataIndex[0] = iBeginPix;
                    pMarkupDataShift[0] = iLeftShift;
                    pMarkupDataIndex[nPixels - 1] = iBeginPix + nPixels - 1;
                    pMarkupDataShift[nPixels - 1] = -iRightShift;
                    for(var i = 1; i < nPixels - 1; ++i) {
                        pMarkupDataIndex[i] = iBeginPix + i;
                    }
                    for(var i = 0; i < iCount; i++) {
                        pRealData[iLeftShift + i] = pBufferData[i];
                    }
                    var pOldFrameBuffer = pWebGLRenderer.getParameter(0x8CA6);
                    var pWebGLFramebuffer = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.createWebGLFramebuffer();
                    var pWebGLProgram = (((((this).pResourcePool)).pManager)).shaderProgramPool.findResource("WEBGL_vertex_texture_update");
                    var pValueBuffer = WebGLVertexTexture._pWebGLBuffer1;
                    var pMarkupIndexBuffer = WebGLVertexTexture._pWebGLBuffer2;
                    var pMarkupShiftBuffer = WebGLVertexTexture._pWebGLBuffer3;
 {
                        akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 440);
                        akra.logger.assert(((pWebGLProgram) !== undefined), "cound not find WEBGL_vertex_texture_update program");
                    }
                    ;
                    pWebGLRenderer.disableAllWebGLVertexAttribs();
                    (pWebGLRenderer._pWebGLContext.bindFramebuffer((0x8D40), (pWebGLFramebuffer)));
                    (pWebGLRenderer._pWebGLContext.useProgram(((pWebGLProgram._pWebGLProgram))));
                    pWebGLContext.disable(0x0B71);
                    pWebGLContext.disable(0x0C11);
                    pWebGLContext.disable(0x0BE2);
                    pWebGLContext.disable(0x0B44);
                    var iValueAttribLocation = (((pWebGLProgram._pWebGLAttributeLocations[("VALUE")]) !== undefined) ? pWebGLProgram._pWebGLAttributeLocations[("VALUE")] : -1);
                    var iIndexAttribLocation = (((pWebGLProgram._pWebGLAttributeLocations[("INDEX")]) !== undefined) ? pWebGLProgram._pWebGLAttributeLocations[("INDEX")] : -1);
                    var iShiftAttribLocation = (((pWebGLProgram._pWebGLAttributeLocations[("SHIFT")]) !== undefined) ? pWebGLProgram._pWebGLAttributeLocations[("SHIFT")] : -1);
                    pWebGLContext.enableVertexAttribArray(iValueAttribLocation);
                    pWebGLContext.enableVertexAttribArray(iIndexAttribLocation);
                    pWebGLContext.enableVertexAttribArray(iShiftAttribLocation);
                    pWebGLContext.framebufferTexture2D(0x8D40, 0x8CE0, 0x0DE1, this._pWebGLTexture, 0);
                    (pWebGLRenderer._pWebGLContext.bindBuffer((0x8892), (pValueBuffer)));
                    pWebGLContext.bufferData(0x8892, pRealData, 0x88E0);
                    pWebGLContext.vertexAttribPointer(iValueAttribLocation, 4, 0x1406, false, 0, 0);
                    (pWebGLRenderer._pWebGLContext.bindBuffer((0x8892), (pMarkupIndexBuffer)));
                    pWebGLContext.bufferData(0x8892, pMarkupDataIndex, 0x88E0);
                    pWebGLContext.vertexAttribPointer(iIndexAttribLocation, 1, 0x1406, false, 0, 0);
                    (pWebGLRenderer._pWebGLContext.bindBuffer((0x8892), (pMarkupShiftBuffer)));
                    pWebGLContext.bufferData(0x8892, pMarkupDataShift, 0x88E0);
                    pWebGLContext.vertexAttribPointer(iShiftAttribLocation, 1, 0x1406, false, 0, 0);
                    (pWebGLRenderer._pWebGLContext.activeTexture((0x84C0)));
                    /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(0x0DE1, this._pWebGLTexture);
                    (pWebGLProgram._pWebGLContext.uniform1i(pWebGLProgram._pWebGLUniformLocations[("sourceTexture")], (0)));
                    pWebGLProgram.setVec2("size", akra.Vec2.stackCeil.set(this._iWidth, this._iHeight));
                    pWebGLContext.viewport(0, 0, this._iWidth, this._iHeight);
                    pWebGLContext.drawArrays(0x0000, 0, nPixels);
                    pWebGLContext.flush();
                    pWebGLContext.framebufferTexture2D(0x8D40, 0x8CE0, 0x0DE1, null, 0);
                    (pWebGLRenderer._pWebGLContext.bindBuffer((0x8892), (null)));
                    /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(0x0DE1, null);
                    pWebGLContext.disableVertexAttribArray(iValueAttribLocation);
                    pWebGLContext.disableVertexAttribArray(iIndexAttribLocation);
                    pWebGLContext.disableVertexAttribArray(iShiftAttribLocation);
                    //pWebGLRenderer.deleteWebGLBuffer(pValueBuffer);
                    //pWebGLRenderer.deleteWebGLBuffer(pMarkupShiftBuffer);
                    //pWebGLRenderer.deleteWebGLBuffer(pMarkupIndexBuffer);
                    (pWebGLRenderer._pWebGLContext.bindFramebuffer((0x8D40), (pOldFrameBuffer)));
                    (pWebGLRenderer._pWebGLFramebufferList.push((pWebGLFramebuffer)));
                }
                return true;
            };
            WebGLVertexTexture.prototype.resize = function (iSize) {
                var pWebGLRenderer = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.getEngine().getRenderer();
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                var iMax = 0;
                if (iSize < (/*checked (origin: akra)>>*/akra.pixelUtil.getMemorySize((this)._iWidth, (this)._iHeight, 1, (this)._ePixelFormat))) {
                    for(var k = 0; k < this._pVertexDataArray.length; ++k) {
                        var pVertexData = this._pVertexDataArray[k];
                        if (pVertexData.byteOffset + pVertexData.byteLength > iMax) {
                            iMax = pVertexData.byteOffset + pVertexData.byteLength;
                        }
                    }
                    if (iMax > iSize) {
 {
                            akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 523);
                            akra.logger.assert(false, "Уменьшение невозможно. Страая разметка не укладывается в новый размер");
                        }
                        ;
                        return false;
                    }
                }
                var pPOTSize = akra.math.calcPOTtextureSize(akra.math.ceil(iSize / (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor((this._ePixelFormat)).elemBytes)));
                pPOTSize[0] = (pPOTSize[0] < 32) ? 32 : pPOTSize[0];
                pPOTSize[1] = (pPOTSize[1] < 32) ? 32 : pPOTSize[1];
                if (pPOTSize[0] !== this._iWidth || pPOTSize[1] !== this._iHeight) {
                    if (((this)._pBackupCopy != null)) {
                        this._iWidth = pPOTSize[0];
                        this._iHeight = pPOTSize[1];
                        /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(0x0DE1, this._pWebGLTexture);
                        pWebGLContext.texImage2D(0x0DE1, 0, this._eWebGLFormat, this._iWidth, this._iHeight, 0, this._eWebGLFormat, this._eWebGLType, null);
                        /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(0x0DE1, null);
                        var iByteLength = (/*checked (origin: akra)>>*/akra.pixelUtil.getMemorySize((this)._iWidth, (this)._iHeight, 1, (this)._ePixelFormat));
                        /*resing backup copy don't cause data loss*/
                        this._pBackupCopy.resize(iByteLength);
                        var pData = new Uint8Array(iByteLength);
                        if (!this.readData(pData)) {
 {
                                akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 552);
                                akra.logger.warning("cannot read data from buffer");
                            }
                            ;
                            return false;
                        }
                        this.writeData(pData, 0, iByteLength);
                    } else {
                        var pWebGLProgram = (((((this).pResourcePool)).pManager)).shaderProgramPool.findResource("WEBGL_vertex_texture_resize");
 {
                            akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 561);
                            akra.logger.assert(((pWebGLProgram) !== undefined), "cound not find WEBGL_vertex_texture_resize program");
                        }
                        ;
                        (pWebGLRenderer._pWebGLContext.useProgram(((pWebGLProgram._pWebGLProgram))));
                        //create new texture for resize
                        var pTexture = (pWebGLRenderer._pWebGLContext.createTexture());
                        (pWebGLRenderer._pWebGLContext.activeTexture((0x84C1)));
                        /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(0x0DE1, pTexture);
                        pWebGLContext.texImage2D(0x0DE1, 0, this._eWebGLFormat, pPOTSize[0], pPOTSize[1], 0, this._eWebGLFormat, this._eWebGLType, null);
                        pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_MAG_FILTER, pWebGLContext.NEAREST);
                        pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_MIN_FILTER, pWebGLContext.NEAREST);
                        pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_WRAP_S, pWebGLContext.CLAMP_TO_EDGE);
                        pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_WRAP_T, pWebGLContext.CLAMP_TO_EDGE);
                        var pOldFrameBuffer = pWebGLRenderer.getParameter(0x8CA6);
                        var pWebGLFramebuffer = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.createWebGLFramebuffer();
                        (pWebGLRenderer._pWebGLContext.bindFramebuffer((0x8D40), (pWebGLFramebuffer)));
                        pWebGLContext.framebufferTexture2D(0x8D40, 0x8CE0, 0x0DE1, pTexture, 0);
                        if (iSize >= (/*checked (origin: akra)>>*/akra.pixelUtil.getMemorySize((this)._iWidth, (this)._iHeight, 1, (this)._ePixelFormat))) {
                            /*in other case we already have iMax*/
                            for(var k = 0; k < this._pVertexDataArray.length; ++k) {
                                var pVertexData = this._pVertexDataArray[k];
                                if (pVertexData.byteOffset + pVertexData.byteLength > iMax) {
                                    iMax = pVertexData.byteOffset + pVertexData.byteLength;
                                }
                            }
                        }
                        /*предпологается, что float*/
                        var iTypeSize = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/akra.pixelUtil.getComponentTypeBits(this._ePixelFormat) / 8;
                        /*число float'ов в пикселе*/
                        var nElementsPerPix = (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor((this._ePixelFormat)).componentCount);
                        var nPixels = akra.math.ceil(iMax / iTypeSize / nElementsPerPix);
                        var pIndexBufferData = new Float32Array(nPixels);
                        for(var i = 0; i < nPixels; i++) {
                            pIndexBufferData[i] = i;
                        }
                        pWebGLRenderer.disableAllWebGLVertexAttribs();
                        var iIndexAttribLocation = (((pWebGLProgram._pWebGLAttributeLocations[("INDEX")]) !== undefined) ? pWebGLProgram._pWebGLAttributeLocations[("INDEX")] : -1);
                        pWebGLContext.enableVertexAttribArray(iIndexAttribLocation);
                        if (((WebGLVertexTexture._pWebGLBuffer1) === null)) {
                            WebGLVertexTexture._pWebGLBuffer1 = (pWebGLRenderer._pWebGLContext.createBuffer());
                        }
                        var pIndexBuffer = WebGLVertexTexture._pWebGLBuffer1;
                        (pWebGLRenderer._pWebGLContext.bindBuffer((0x8892), (pIndexBuffer)));
                        pWebGLContext.bufferData(0x8892, pIndexBufferData, 0x88E0);
                        pWebGLContext.vertexAttribPointer(iIndexAttribLocation, 1, 0x1406, false, 0, 0);
                        pWebGLContext.disable(0x0B71);
                        pWebGLContext.disable(0x0C11);
                        pWebGLContext.disable(0x0BE2);
                        pWebGLContext.disable(0x0B44);
                        (pWebGLRenderer._pWebGLContext.activeTexture((0x84C0)));
                        /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(0x0DE1, this._pWebGLTexture);
                        (pWebGLProgram._pWebGLContext.uniform1i(pWebGLProgram._pWebGLUniformLocations[("sourceTexture")], (0)));
                        pWebGLProgram.setVec2("v2fSrcTexSize", akra.Vec2.stackCeil.set(this._iWidth, this._iHeight));
                        pWebGLProgram.setVec2("v2fDstTexSize", akra.Vec2.stackCeil.set(pPOTSize[0], pPOTSize[1]));
                        pWebGLContext.viewport(0, 0, pPOTSize[0], pPOTSize[1]);
                        pWebGLContext.drawArrays(0x0000, 0, nPixels);
                        pWebGLContext.flush();
                        pWebGLContext.framebufferTexture2D(0x8D40, 0x8CE0, 0x0DE1, null, 0);
                        pWebGLContext.disableVertexAttribArray(iIndexAttribLocation);
                        (pWebGLRenderer._pWebGLContext.bindBuffer((0x8892), (null)));
                        /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(0x0DE1, null);
                        //pWebGLRenderer.deleteWebGLBuffer(pIndexBuffer);
                        (pWebGLRenderer._pWebGLContext.bindFramebuffer((0x8D40), (pOldFrameBuffer)));
                        (pWebGLRenderer._pWebGLFramebufferList.push((pWebGLFramebuffer)));
                        (pWebGLRenderer._pWebGLContext.deleteTexture((this._pWebGLTexture)));
                        this._pWebGLTexture = pTexture;
                        this._iWidth = pPOTSize[0];
                        this._iHeight = pPOTSize[1];
                    }
                }
                this._pHeader.setData(this._header());
                ((this).setAlteredFlag(true));
                return true;
            };
            WebGLVertexTexture.prototype.lockImpl = /**@protected*/ function (iOffset, iSize, iLockFlags) {
                var pRetData = new Uint8Array(iSize);
                this.readData(iOffset, iSize, pRetData);
                this._pLockData = pRetData;
                return pRetData;
            };
            WebGLVertexTexture.prototype.unlockImpl = /**@protected*/ function () {
                this.writeData(this._pLockData, this._iLockStart, this._iLockSize);
            };
            WebGLVertexTexture.prototype.copyBackupToRealImpl = /**@protected*/ function (pRealData, pBackupData, iLockFlags) {
                pRealData.set(pBackupData);
            };
            WebGLVertexTexture.prototype._header = /**@protected*/ function (iTextureSizeX, iTextureSizeY) {
                if (typeof iTextureSizeX === "undefined") { iTextureSizeX = this._iWidth; }
                if (typeof iTextureSizeY === "undefined") { iTextureSizeY = this._iHeight; }
                var pHeader = new Float32Array(8);
                pHeader[0] = iTextureSizeX;
                pHeader[1] = iTextureSizeY;
                pHeader[2] = 1 / iTextureSizeX;
                pHeader[3] = 1 / iTextureSizeY;
                pHeader[4] = iTextureSizeX * iTextureSizeY;
                pHeader[5] = pHeader[4] * (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor((this._ePixelFormat)).elemBytes);
                return pHeader;
            };
            WebGLVertexTexture._pWebGLBuffer1 = null;
            WebGLVertexTexture._pWebGLBuffer2 = null;
            WebGLVertexTexture._pWebGLBuffer3 = null;
            return WebGLVertexTexture;
        })(akra.core.pool.resources.VertexBuffer);
        webgl.WebGLVertexTexture = WebGLVertexTexture;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (data) {
        var IndexData = (function () {
            function IndexData(pIndexBuffer, id, iOffset, iCount, ePrimitiveType, eElementsType) {
                if (typeof ePrimitiveType === "undefined") { ePrimitiveType = akra.EPrimitiveTypes.TRIANGLELIST; }
                if (typeof eElementsType === "undefined") { eElementsType = akra.EDataTypes.UNSIGNED_SHORT; }
 {
                    akra.logger.setSourceLocation("data/IndexData.ts", 36);
                    akra.logger.assert(eElementsType == akra.EDataTypes.UNSIGNED_SHORT || eElementsType == akra.EDataTypes.UNSIGNED_BYTE || eElementsType == akra.EDataTypes.UNSIGNED_INT, "supported only short, byte, uint data types.");
                }
                ;
                this._pIndexBuffer = pIndexBuffer;
                this._iOffset = iOffset;
                this._iLength = iCount;
                this._iId = id;
                this._ePrimitiveType = ePrimitiveType;
                this._eElementsType = eElementsType;
 {
                    akra.logger.setSourceLocation("data/IndexData.ts", 46);
                    akra.logger.assert(pIndexBuffer.byteLength >= ((this)._iLength * (/*checked (origin: akra)>>*/akra.getTypeSize(((this))._eElementsType))) + ((this)._iOffset), "out of buffer limits.");
                }
                ;
            }
            Object.defineProperty(IndexData.prototype, "id", {
                get: /** @inline */function () {
                    return this._iId;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(IndexData.prototype, "type", {
                get: /** @inline */function () {
                    return this._eElementsType;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(IndexData.prototype, "length", {
                get: /** @inline */function () {
                    return this._iLength;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(IndexData.prototype, "bytesPerIndex", {
                get: /** @inline */function () {
                    return akra.getTypeSize(this._eElementsType);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(IndexData.prototype, "byteOffset", {
                get: /** @inline */function () {
                    return this._iOffset;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(IndexData.prototype, "byteLength", {
                get: /** @inline */function () {
                    return this._iLength * (/*checked (origin: akra)>>*/akra.getTypeSize((this)._eElementsType));
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(IndexData.prototype, "buffer", {
                get: /** @inline */function () {
                    return this._pIndexBuffer;
                },
                enumerable: true,
                configurable: true
            });
            IndexData.prototype.getData = function (iOffset, iSize) {
 {
                    akra.logger.setSourceLocation("data/IndexData.ts", 51);
                    akra.logger.assert(iOffset + iSize <= ((this)._iLength * (/*checked (origin: akra)>>*/akra.getTypeSize(((this))._eElementsType))), "out of buffer limits");
                }
                ;
                var pBuffer = new Uint8Array(iSize);
                if (this._pIndexBuffer.readData(((this)._iOffset) + iOffset, iSize, pBuffer)) {
                    return pBuffer.buffer;
                }
 {
                    akra.logger.setSourceLocation("data/IndexData.ts", 58);
                    akra.logger.error("cannot read data from index buffer");
                }
                ;
                return null;
            };
            IndexData.prototype.getTypedData = function (iStart, iCount) {
 {
                    akra.logger.setSourceLocation("data/IndexData.ts", 64);
                    akra.logger.assert((iStart + iCount) <= this._iLength, "out of buffer limits");
                }
                ;
                var iTypeSize = akra.getTypeSize(this._eElementsType);
                var iOffset = iStart * iTypeSize;
                var iSize = iCount * iTypeSize;
                var pBuffer = new Uint8Array(iSize);
                if (this._pIndexBuffer.readData(((this)._iOffset) + iOffset, iSize, pBuffer)) {
                    switch(this._eElementsType) {
                        case akra.EDataTypes.UNSIGNED_BYTE:
                            return pBuffer;
                        case akra.EDataTypes.UNSIGNED_SHORT:
                            return new Uint16Array(pBuffer.buffer);
                        case akra.EDataTypes.UNSIGNED_INT:
                            return new Uint32Array(pBuffer.buffer);
                        default:
                            return null;
                    }
                }
                return null;
            };
            IndexData.prototype.setData = function (pData, iOffset, iCount) {
                if (typeof iOffset === "undefined") { iOffset = 0; }
                if (typeof iCount === "undefined") { iCount = pData.byteLength / (/*checked (origin: akra)>>*/akra.getTypeSize((this)._eElementsType)); }
 {
                    akra.logger.setSourceLocation("data/IndexData.ts", 90);
                    akra.logger.assert((iOffset + iCount) * (/*checked (origin: akra)>>*/akra.getTypeSize((this)._eElementsType)) <= ((this)._iLength * (/*checked (origin: akra)>>*/akra.getTypeSize(((this))._eElementsType))), "out of buffer limits.");
                }
                ;
                return this._pIndexBuffer.writeData(pData, ((this)._iOffset) + iOffset * (/*checked (origin: akra)>>*/akra.getTypeSize((this)._eElementsType)), iCount * (/*checked (origin: akra)>>*/akra.getTypeSize((this)._eElementsType)));
            };
            IndexData.prototype.destroy = function () {
                this._pIndexBuffer = null;
                this._iOffset = undefined;
                this._iLength = undefined;
                this._eElementsType = undefined;
                this._eElementsType = undefined;
            };
            IndexData.prototype.getPrimitiveType = /** @inline */function () {
                return this._ePrimitiveType;
            };
            IndexData.prototype.getPrimitiveCount = /** @inline */function (iIndexCount) {
                if (typeof iIndexCount === "undefined") { iIndexCount = ((this)._iLength); }
                return IndexData.getPrimitiveCount(this._ePrimitiveType, iIndexCount);
            };
            IndexData.prototype.getBufferHandle = /** @inline */function () {
                return this._pIndexBuffer.resourceHandle;
            };
            IndexData.getPrimitiveCount = function getPrimitiveCount(eType, nVertices) {
                switch(eType) {
                    case akra.EPrimitiveTypes.POINTLIST:
                        return nVertices;
                    case akra.EPrimitiveTypes.LINELIST:
                        return nVertices / 2;
                    case akra.EPrimitiveTypes.LINESTRIP:
                        return nVertices - 1;
                    case akra.EPrimitiveTypes.LINELOOP:
                        return nVertices;
                    case akra.EPrimitiveTypes.TRIANGLELIST:
                        return nVertices / 3;
                    case akra.EPrimitiveTypes.TRIANGLEFAN:
                    case akra.EPrimitiveTypes.TRIANGLESTRIP:
                        return nVertices - 2;
                }
 {
                    akra.logger.setSourceLocation("data/IndexData.ts", 135);
                    akra.logger.error("unhandled case detected..");
                }
                ;
                return 0;
            };
            return IndexData;
        })();
        data.IndexData = IndexData;        
    })(akra.data || (akra.data = {}));
    var data = akra.data;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var IndexBuffer = (function (_super) {
                    __extends(IndexBuffer, _super);
                    /*pManager: IResourcePoolManager*/
                    function IndexBuffer() {
                        /*pManager*/
                                        _super.call(this);
                        /**@protected*/ this._pIndexDataArray = [];
                        /**@protected*/ this._iDataCounter = 0;
                    }
                    Object.defineProperty(IndexBuffer.prototype, "length", {
                        get: /** @inline */function () {
                            return this._pIndexDataArray.length;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    IndexBuffer.prototype.create = //create(iByteSize: uint, iFlags?: uint, pData?: Uint8Array): bool;
                    function (iByteSize, iFlags, pData) {
                        //create(iByteSize: uint, iFlags?: uint, pData?: ArrayBufferView): bool {
                        _super.prototype.create.call(this, 0, iFlags || 0);
                        if ((((iFlags) & (akra.EHardwareBufferFlags.BACKUP_COPY)) != 0)) {
                            this._pBackupCopy = new resources.MemoryBuffer();
                            this._pBackupCopy.create(iByteSize);
                            this._pBackupCopy.writeData(pData, 0, iByteSize);
                        }
                        return true;
                    };
                    IndexBuffer.prototype.destroy = function () {
                        _super.prototype.destroy.call(this);
                        this._pBackupCopy.destroy();
                        this.freeIndexData();
                        this._iDataCounter = 0;
                    };
                    IndexBuffer.prototype.getIndexData = function (iOffset, iCount, ePrimitiveType, eElementsType) {
                        var pIndexData = new akra.data.IndexData(this, this._iDataCounter++, iOffset, iCount, ePrimitiveType, eElementsType);
                        this._pIndexDataArray.push(pIndexData);
                        return pIndexData;
                    };
                    IndexBuffer.prototype.getEmptyIndexData = function (iCount, ePrimitiveType, eElementsType) {
                        var pHole = new Array();
                        var i;
                        var pIndexData;
                        pHole[0] = {
                            start: 0,
                            end: this.byteLength
                        };
                        //console.log(pHole[0].end);
                        for(var k = 0; k < this._pIndexDataArray.length; ++k) {
                            pIndexData = this._pIndexDataArray[k];
                            for(i = 0; i < pHole.length; i++) {
                                //console.log("pHole:",pHole[i].start,pHole[i].end);
                                //Полностью попадает внутрь
                                if (pIndexData.byteOffset > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength < pHole[i].end) {
                                    var iTemp = pHole[i].end;
                                    pHole[i].end = pIndexData.byteOffset;
                                    pHole.splice(i + 1, 0, {
                                        start: pIndexData.byteOffset + pIndexData.byteLength,
                                        end: iTemp
                                    });
                                    i--;
                                } else if (pIndexData.byteOffset == pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength < pHole[i].end) {
                                    pHole[i].start = pIndexData.byteOffset + pIndexData.byteLength;
                                } else if (pIndexData.byteOffset > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength == pHole[i].end) {
                                } else if (pIndexData.byteOffset == pHole[i].start && pIndexData.byteLength == (pHole[i].end - pHole[i].start)) {
                                    pHole.splice(i, 1);
                                    i--;
                                } else //Перекрывает снизу
                                if (pIndexData.byteOffset < pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength < pHole[i].end) {
                                    pHole[i].start = pIndexData.byteOffset + pIndexData.byteLength;
                                } else if (pIndexData.byteOffset < pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength == pHole[i].end) {
                                    pHole.splice(i, 1);
                                    i--;
                                } else //Перекрывается сверху
                                if (pIndexData.byteOffset + pIndexData.byteLength > pHole[i].end && pIndexData.byteOffset > pHole[i].start && pIndexData.byteOffset < pHole[i].end) {
                                    pHole[i].end = pIndexData.byteOffset;
                                } else if (pIndexData.byteOffset + pIndexData.byteLength > pHole[i].end && pIndexData.byteOffset == pHole[i].start && pIndexData.byteOffset < pHole[i].end) {
                                    pHole.splice(i, 1);
                                    i--;
                                } else //полнстью перекрывает
                                if (pIndexData.byteOffset < pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength > pHole[i].end) {
                                    i--;
                                }
                            }
                        }
                        pHole.sort(/** @inline */function (a, b) {
                            return ((a.end - a.start) - (b.end - b.start));
                        });
                        for(i = 0; i < pHole.length; i++) {
                            if ((pHole[i].end - pHole[i].start) >= iCount * akra.getTypeSize(eElementsType)) {
                                pIndexData = new akra.data.IndexData(this, this._iDataCounter++, pHole[i].start, iCount, ePrimitiveType, eElementsType);
                                this._pIndexDataArray.push(pIndexData);
                                return pIndexData;
                            }
                        }
                        return null;
                    };
                    IndexBuffer.prototype.freeIndexData = function (pIndexData) {
                        if (arguments.length == 0) {
                            for(var i = 0; i < this._pIndexDataArray.length; i++) {
                                this._pIndexDataArray[Number(i)].destroy();
                            }
                            this._pIndexDataArray = null;
                        } else {
                            for(var i = 0; i < this._pIndexDataArray.length; i++) {
                                if (this._pIndexDataArray[i] == pIndexData) {
                                    pIndexData.destroy();
                                    this._pIndexDataArray.splice(i, 1);
                                    ((this).setAlteredFlag(true));
                                    return true;
                                }
                            }
                            return false;
                        }
                        ((this).setAlteredFlag(true));
                        return true;
                    };
                    IndexBuffer.prototype.allocateData = function (ePrimitiveType, eElementsType, pData) {
                        var pIndexData;
                        var iCount = pData.byteLength / akra.getTypeSize(eElementsType);
 {
                            akra.logger.setSourceLocation("core/pool/resources/IndexBuffer.ts", 164);
                            akra.logger.assert(iCount === akra.math.floor(iCount), "data size should be a multiple of the vertex declaration");
                        }
                        ;
                        pIndexData = this.getEmptyIndexData(iCount, ePrimitiveType, eElementsType);
                        pIndexData.setData(pData);
                        return pIndexData;
                    };
                    return IndexBuffer;
                })(resources.HardwareBuffer);
                resources.IndexBuffer = IndexBuffer;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLIndexBuffer = (function (_super) {
            __extends(WebGLIndexBuffer, _super);
            /*pManager: IResourcePoolManager*/
            function WebGLIndexBuffer() {
                /*pManager*/
                        _super.call(this);
                this._pLockData = null;
            }
            Object.defineProperty(WebGLIndexBuffer.prototype, "byteLength", {
                get: /** @inline */function () {
                    return this._iByteSize;
                },
                enumerable: true,
                configurable: true
            });
            WebGLIndexBuffer.prototype.create = function (iByteSize, iFlags, pData) {
                if (typeof iFlags === "undefined") { iFlags = akra.EHardwareBufferFlags.STATIC; }
                if (typeof pData === "undefined") { pData = null; }
                iByteSize = akra.math.max(iByteSize, 1024);
                if ((((iFlags) & (akra.EHardwareBufferFlags.READABLE)) != 0)) {
                    ((iFlags) |= (akra.EHardwareBufferFlags.BACKUP_COPY));
                }
                _super.prototype.create.call(this, iByteSize, iFlags, pData);
                var pWebGLRenderer = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.getEngine().getRenderer();
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                var i;
 {
                    akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 45);
                    akra.logger.assert(this._pWebGLBuffer == null, "webgl buffer already allocated");
                }
                ;
                this._iByteSize = iByteSize;
                this._iFlags = iFlags;
                pWebGLContext = (pWebGLRenderer._pWebGLContext);
 {
                    akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 51);
                    akra.logger.assert(pWebGLContext !== null, "cannot grab webgl context");
                }
                ;
                //Софтварного рендеринга буфера у нас нет
                 {
                    akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 54);
                    akra.logger.assert(!(((((this)._iFlags) & (/*checked (origin: akra)>>*/akra.EHardwareBufferFlags.SOFTWARE)) != 0)), "no sftware rendering");
                }
                ;
                //Если есть локальная копия то буфер можно читать
                if (((this)._pBackupCopy != null)) {
                    ((this._iFlags) |= (akra.EHardwareBufferFlags.READABLE));
                }
 {
                    akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 62);
                    akra.logger.assert(!pData || pData.byteLength <= iByteSize, "Размер переданного массива больше переданного размера буфера");
                }
                ;
                this._pWebGLBuffer = (pWebGLRenderer._pWebGLContext.createBuffer());
                if (!this._pWebGLBuffer) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 68);
                        akra.logger.criticalError("cannot create WebGL index buffer");
                    }
                    ;
                    this.destroy();
                    return false;
                }
                (pWebGLRenderer._pWebGLContext.bindBuffer((0x8893), (this._pWebGLBuffer)));
                pWebGLContext.bufferData(0x8893, this._iByteSize, webgl.getWebGLUsage(this._iFlags));
                if (pData) {
                    pWebGLContext.bufferSubData(0x8893, 0, (((pData) instanceof ArrayBuffer) ? pData : (pData).buffer));
                }
                return true;
            };
            WebGLIndexBuffer.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
                var pWebGLRenderer = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.getEngine().getRenderer();
                (pWebGLRenderer._pWebGLContext.deleteBuffer((this._pWebGLBuffer)));
                this._pWebGLBuffer = null;
                this._iByteSize = 0;
            };
            WebGLIndexBuffer.prototype.readData = function (iOffset, iSize, ppDest) {
 {
                    akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 99);
                    akra.logger.assert(!((this._pWebGLBuffer) === null), "WebGL buffer not exists");
                }
                ;
                if (!((this)._pBackupCopy != null)) {
                    return false;
                }
                if (arguments.length === 1) {
                    this._pBackupCopy.readData(arguments[0]);
                } else {
                    this._pBackupCopy.readData(iOffset, iSize, ppDest);
                }
                return true;
            };
            WebGLIndexBuffer.prototype.writeData = function (pData, iOffset, iSize, bDiscardWholeBuffer) {
                if (typeof bDiscardWholeBuffer === "undefined") { bDiscardWholeBuffer = false; }
 {
                    akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 119);
                    akra.logger.assert(!((this._pWebGLBuffer) === null), "WebGL buffer not exists");
                }
                ;
                var pWebGLRenderer = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.getEngine().getRenderer();
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                (pWebGLRenderer._pWebGLContext.bindBuffer((0x8893), (this._pWebGLBuffer)));
 {
                    akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 126);
                    akra.logger.assert(pData.byteLength <= iSize, "Размер переданного массива больше переданного размера");
                }
                ;
 {
                    akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 127);
                    akra.logger.assert(((this)._iByteSize) >= iOffset + iSize, "Данные выйдут за предел буфера");
                }
                ;
                var pU8Data = null;
                if (((pData) instanceof ArrayBuffer)) {
                    pU8Data = new Uint8Array(pData);
                } else {
                    pU8Data = new Uint8Array(pData.buffer, pData.byteOffset, pData.byteLength);
                }
                pU8Data = pU8Data.subarray(0, iSize);
                pWebGLContext.bufferSubData(0x8893, iOffset, pU8Data);
                if (((this)._pBackupCopy != null)) {
                    this._pBackupCopy.writeData(pU8Data, iOffset);
                }
                ((this).setAlteredFlag(true));
                return true;
            };
            WebGLIndexBuffer.prototype.resize = function (iSize) {
                var eUsage;
                var pData;
                var iMax = 0;
                var pIndexData;
                var pWebGLRenderer = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.getEngine().getRenderer();
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                if (((this)._pBackupCopy != null)) {
                    return false;
                }
                if (iSize < ((this)._iByteSize)) {
                    for(var k = 0; k < this._pIndexDataArray.length; ++k) {
                        pIndexData = this._pIndexDataArray[k];
                        if (pIndexData.byteOffset + pIndexData.byteLength > iMax) {
                            iMax = pIndexData.byteOffset + pIndexData.byteLength;
                        }
                    }
 {
                        akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 174);
                        akra.logger.assert(iMax <= iSize, "Уменьшение невозможно. Страая разметка не укладывается в новый размер");
                    }
                    ;
                }
                if (pWebGLContext.isBuffer(this._pWebGLBuffer)) {
                    (pWebGLRenderer._pWebGLContext.deleteBuffer((this._pWebGLBuffer)));
                }
                eUsage = webgl.getWebGLUsage(this._iFlags);
                this._pWebGLBuffer = (pWebGLRenderer._pWebGLContext.createBuffer());
                if (!this._pWebGLBuffer) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 186);
                        akra.logger.criticalError("cannot create WebGL index buffer");
                    }
                    ;
                    this.destroy();
                    return false;
                }
                (pWebGLRenderer._pWebGLContext.bindBuffer((0x8893), (this._pWebGLBuffer)));
                pWebGLContext.bufferData(0x8893, iSize, eUsage);
                pData = new Uint8Array(this._iByteSize);
                if (this.readData(pData)) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 199);
                        akra.logger.warning("cannot read data from buffer");
                    }
                    ;
                    return false;
                }
                this.writeData(pData, 0, this._iByteSize);
                this._pBackupCopy.resize(iSize);
                this._iByteSize = iSize;
                ((this).setAlteredFlag(true));
                return true;
            };
            WebGLIndexBuffer.prototype.getWebGLBuffer = /** @inline */function () {
                return this._pWebGLBuffer;
            };
            WebGLIndexBuffer.prototype.lockImpl = /**@protected*/ function (iOffset, iSize, iLockFlags) {
                var pRetData = new Uint8Array(iSize);
                this.readData(iOffset, iSize, pRetData);
                this._pLockData = pRetData;
                return pRetData;
            };
            WebGLIndexBuffer.prototype.unlockImpl = /**@protected*/ function () {
                this.writeData(this._pLockData, this._iLockStart, this._iLockSize);
            };
            WebGLIndexBuffer.prototype.copyBackupToRealImpl = /**@protected*/ function (pRealData, pBackupData, iLockFlags) {
                pRealData.set(pBackupData);
            };
            return WebGLIndexBuffer;
        })(akra.core.pool.resources.IndexBuffer);
        webgl.WebGLIndexBuffer = WebGLIndexBuffer;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLInternalRenderBuffer = (function (_super) {
            __extends(WebGLInternalRenderBuffer, _super);
            function WebGLInternalRenderBuffer() {
                        _super.call(this);
                /**@protected*/ this._pWebGLRenderbuffer = null;
            }
            WebGLInternalRenderBuffer.prototype.create = function () {
                if (arguments.length !== 4) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLInternalRenderbuffer.ts", 21);
                        akra.logger.criticalError("Invalid number of arguments. For PixelBuffer it must be four");
                    }
                    ;
                }
                var iWebGLFormat = arguments[0];
                var iWidth = arguments[1];
                var iHeight = arguments[2];
                var bCreateStorage = arguments[3];
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                _super.prototype.create.call(this, iWidth, iHeight, 1, akra.webgl.getClosestAkraFormat(iWebGLFormat, akra.EPixelFormats.A8R8G8B8), 0);
                this._iWebGLInternalFormat = iWebGLFormat;
                this._pWebGLRenderbuffer = (pWebGLRenderer._pWebGLContext.createRenderbuffer());
                (pWebGLRenderer._pWebGLContext.bindRenderbuffer((0x8D41), (this._pWebGLRenderbuffer)));
                if (bCreateStorage) {
                    pWebGLContext.renderbufferStorage(0x8D41, iWebGLFormat, iWidth, iHeight);
                }
                /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyCreated();
                return true;
            };
            WebGLInternalRenderBuffer.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                (pWebGLRenderer._pWebGLContext.deleteRenderbuffer((this._pWebGLRenderbuffer)));
                this._pWebGLRenderbuffer = null;
            };
            WebGLInternalRenderBuffer.prototype._bindToFramebuffer = function (iAttachment, iZOffset) {
 {
                    akra.logger.setSourceLocation("webgl/WebGLInternalRenderbuffer.ts", 56);
                    akra.logger.assert(iZOffset < this._iDepth);
                }
                ;
                var pWebGLRenderer = (((((((((this).pResourcePool)).pManager))).pEngine))._pRenderer);
                var pWebGLContext = (pWebGLRenderer._pWebGLContext);
                pWebGLContext.framebufferRenderbuffer(0x8D40, iAttachment, 0x8D41, this._pWebGLRenderbuffer);
            };
            return WebGLInternalRenderBuffer;
        })(webgl.WebGLPixelBuffer);
        webgl.WebGLInternalRenderBuffer = WebGLInternalRenderBuffer;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var DepthBuffer = (function (_super) {
                    __extends(DepthBuffer, _super);
                    function DepthBuffer() {
                                        _super.call(this);
                        /**@protected*/ this._iBitDepth = 0;
                        /**@protected*/ this._iWidth = 0;
                        /**@protected*/ this._iHeight = 0;
                        /**@protected*/ this._isManual = false;
                        /**@protected*/ this._pAttachedRenderTargetsList = null;
                    }
                    Object.defineProperty(DepthBuffer.prototype, "bitDepth", {
                        get: /** @inline */function () {
                            return this._iBitDepth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DepthBuffer.prototype, "width", {
                        get: /** @inline */function () {
                            return this._iWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DepthBuffer.prototype, "height", {
                        get: /** @inline */function () {
                            return this._iHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DepthBuffer.prototype.create = function (iBitDepth, iWidth, iHeight, isManual) {
                        this._iBitDepth = iBitDepth;
                        this._iWidth = iWidth;
                        this._iHeight = iHeight;
                        this._isManual = isManual;
                        this._pAttachedRenderTargetsList = [];
                        /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyCreated();
                        return true;
                    };
                    DepthBuffer.prototype.destroy = function () {
                        this.detachFromAllRenderTargets();
                        this._pAttachedRenderTargetsList = null;
                    };
                    DepthBuffer.prototype.destroyResource = function () {
                        this.destroy();
                        /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.notifyDestroyed();
                        return true;
                    };
                    DepthBuffer.prototype.isManual = function () {
                        return this._isManual;
                    };
                    DepthBuffer.prototype.isCompatible = function (pTarget) {
                        if (this._iWidth >= pTarget.width && this._iHeight >= pTarget.height) {
                            return true;
                        }
                        return false;
                    };
                    DepthBuffer.prototype._notifyRenderTargetAttached = function (pTarget) {
 {
                            akra.logger.setSourceLocation("core/pool/resources/DepthBuffer.ts", 70);
                            akra.logger.assert(this._pAttachedRenderTargetsList.indexOf(pTarget) === -1, "RenderTarget alrady has been attached to this DepthBuffer");
                        }
                        ;
                        this._pAttachedRenderTargetsList.push(pTarget);
                    };
                    DepthBuffer.prototype._notifyRenderTargetDetached = function (pTarget) {
                        var index = this._pAttachedRenderTargetsList.indexOf(pTarget);
 {
                            akra.logger.setSourceLocation("core/pool/resources/DepthBuffer.ts", 78);
                            akra.logger.assert(index !== -1, "Can not detach RenderTarget from DepthBuffer beacuse it hasn`t been attached to it");
                        }
                        ;
                        this._pAttachedRenderTargetsList.splice(index, 1);
                    };
                    DepthBuffer.prototype.detachFromAllRenderTargets = /**@protected*/ function () {
                        var i = 0;
                        for(i = 0; i < this._pAttachedRenderTargetsList.length; i++) {
                            //If we call, detachDepthBuffer, we'll invalidate the iterators
                            this._pAttachedRenderTargetsList[i].detachDepthBuffer();
                        }
                        this._pAttachedRenderTargetsList.clear();
                    };
                    return DepthBuffer;
                })(pool.ResourcePoolItem);
                resources.DepthBuffer = DepthBuffer;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        var RenderTexture = (function (_super) {
            __extends(RenderTexture, _super);
            function RenderTexture(pRenderer, pBuffer, iZOffset) {
                        _super.call(this, pRenderer);
                /**@protected*/ this._pBuffer = null;
                /**@protected*/ this._iZOffset = 0;
                this._pBuffer = pBuffer;
                this._iZOffset = iZOffset;
                this._iWidth = pBuffer.width;
                this._iHeight = pBuffer.height;
                this._iColorDepth = (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor((pBuffer.format)).elemBytes * 8);
            }
            RenderTexture.prototype.getPixelBuffer = /** @inline */function () {
                return this._pBuffer;
            };
            RenderTexture.prototype.destroy = function () {
                this._pBuffer._clearRTT(this._iZOffset);
                this._pBuffer = null;
            };
            RenderTexture.prototype.suggestPixelFormat = /** @inline */function () {
                return this._pBuffer.format;
            };
            RenderTexture.prototype.copyContentsToMemory = function (pDest, eBuffer) {
                if (eBuffer === akra.EFramebuffer.AUTO) {
                    eBuffer = akra.EFramebuffer.FRONT;
                }
                if (eBuffer !== akra.EFramebuffer.FRONT) {
 {
                        akra.logger.setSourceLocation("render/RenderTexture.ts", 45);
                        akra.logger.criticalError("Invalid buffer.");
                    }
                    ;
                }
                this._pBuffer.blitToMemory(pDest);
            };
            return RenderTexture;
        })(render.RenderTarget);
        render.RenderTexture = RenderTexture;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLRenderTexture = (function (_super) {
            __extends(WebGLRenderTexture, _super);
            function WebGLRenderTexture(pRenderer, pTarget) {
                        _super.call(this, pRenderer, pTarget, 0);
                /**@protected*/ this._pFrameBuffer = null;
                this._pFrameBuffer = new webgl.WebGLInternalFrameBuffer(pRenderer);
                // switch(pTarget.format){
                // 	case EPixelFormats.DEPTH8:
                // 	case EPixelFormats.DEPTH16:
                // 	case EPixelFormats.DEPTH32:
                // 		this._pFrameBuffer.bindSurface(GL_DEPTH_ATTACHMENT, pTarget);
                // 		break;
                // 	case EPixelFormats.DEPTH24STENCIL8:
                // 		this._pFrameBuffer.bindSurface(GL_DEPTH_STENCIL_ATTACHMENT, pTarget);
                // 		break;
                // 	default:
                //		this._pFrameBuffer.bindSurface(GL_COLOR_ATTACHMENT0, pTarget);
                // 		break;
                // }
                this._pFrameBuffer.bindSurface(0x8CE0, pTarget);
                this._iWidth = ((((this._pFrameBuffer)._pAttachments[0x8CE0])._iWidth));
                this._iHeight = ((((this._pFrameBuffer)._pAttachments[0x8CE0])._iHeight));
            }
            Object.defineProperty(WebGLRenderTexture.prototype, "width", {
                get: /** @inline */function () {
                    return this._iWidth = ((((this._pFrameBuffer)._pAttachments[0x8CE0])._iWidth));
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLRenderTexture.prototype, "height", {
                get: /** @inline */function () {
                    return this._iHeight = ((((this._pFrameBuffer)._pAttachments[0x8CE0])._iHeight));
                },
                enumerable: true,
                configurable: true
            });
            WebGLRenderTexture.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
            };
            WebGLRenderTexture.prototype.requiresTextureFlipping = function () {
                return true;
            };
            WebGLRenderTexture.prototype.getCustomAttribute = function (sName) {
                if (sName === "FBO") {
                    return this._pFrameBuffer;
                }
                return null;
            };
            WebGLRenderTexture.prototype.swapBuffers = function () {
                this._pFrameBuffer.swapBuffers();
            };
            WebGLRenderTexture.prototype.attachDepthBuffer = function (pDepthBuffer) {
                var bResult = false;
                bResult = _super.prototype.attachDepthBuffer.call(this, pDepthBuffer);
                if (bResult) {
                    this._pFrameBuffer.attachDepthBuffer(pDepthBuffer);
                }
                return bResult;
            };
            WebGLRenderTexture.prototype.attachDepthPixelBuffer = function (pBuffer) {
                var bResult = false;
                bResult = _super.prototype.attachDepthPixelBuffer.call(this, pBuffer);
                if (bResult) {
                    if (pBuffer.format !== akra.EPixelFormats.DEPTH8) {
                        this.detachDepthPixelBuffer();
                        return false;
                    }
                    this._pFrameBuffer.bindSurface(0x8D00, pBuffer);
                    (pBuffer).addRef();
                }
                return bResult;
            };
            WebGLRenderTexture.prototype.attachDepthTexture = function (pTexture) {
                this._pFrameBuffer.attachDepthTexture(pTexture);
                return true;
            };
            WebGLRenderTexture.prototype.detachDepthPixelBuffer = function () {
                this._pFrameBuffer.unbindSurface(0x8D00);
                (this._pDepthPixelBuffer).release();
                _super.prototype.detachDepthPixelBuffer.call(this);
            };
            WebGLRenderTexture.prototype.detachDepthBuffer = function () {
                this._pFrameBuffer.detachDepthBuffer();
                _super.prototype.detachDepthBuffer.call(this);
            };
            WebGLRenderTexture.prototype.detachDepthTexture = function () {
                this._pFrameBuffer.detachDepthTexture();
            };
            return WebGLRenderTexture;
        })(akra.render.RenderTexture);
        webgl.WebGLRenderTexture = WebGLRenderTexture;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLInternalFrameBuffer = (function () {
            function WebGLInternalFrameBuffer(pWebGLRenderer) {
                this._pWebGLRenderer = null;
                this._pWebGLFramebuffer = null;
                this._pAttachments = null;
                this._iWebglActiveAttachment = 0;
                this._pWebGLRenderer = pWebGLRenderer;
                this._pWebGLFramebuffer = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this._pWebGLRenderer.createWebGLFramebuffer();
                this._pAttachments = {};
                for(var i = 0; i < akra.webgl.maxColorAttachments; i++) {
                    this._pAttachments[0x8CE0 + i] = null;
                }
                this._pAttachments[0x8D00] = null;
                this._pAttachments[0x8D20] = null;
                this._pAttachments[0x821A] = null;
            }
            WebGLInternalFrameBuffer.prototype.destroy = function () {
                ((this._pWebGLRenderer)._pWebGLFramebufferList.push((this._pWebGLFramebuffer)));
                this._pWebGLFramebuffer = null;
            };
            Object.defineProperty(WebGLInternalFrameBuffer.prototype, "width", {
                get: /** @inline */function () {
                    return ((this._pAttachments[0x8CE0])._iWidth);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLInternalFrameBuffer.prototype, "height", {
                get: /** @inline */function () {
                    return ((this._pAttachments[0x8CE0])._iHeight);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLInternalFrameBuffer.prototype, "format", {
                get: /** @inline */function () {
                    return ((this._pAttachments[0x8CE0])._eFormat);
                },
                enumerable: true,
                configurable: true
            });
            WebGLInternalFrameBuffer.prototype.getColorAttachment = /** @inline */function (iAttachment) {
                return this._pAttachments[0x8CE0 + iAttachment];
            };
            WebGLInternalFrameBuffer.prototype.getAttachment = /** @inline */function (iWebGLAttachment) {
                return this._pAttachments[iWebGLAttachment];
            };
            WebGLInternalFrameBuffer.prototype.bindSurface = function (iWebGLAttachment, pSurface) {
                if (!((this._pAttachments[iWebGLAttachment]) !== undefined)) {
                    return;
                }
                /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.releaseAttachment(iWebGLAttachment);
                this._pAttachments[iWebGLAttachment] = pSurface;
                if (this.checkAttachment(iWebGLAttachment)) {
                    ((((this)._pWebGLRenderer)._pWebGLContext.bindFramebuffer((0x8D40), ((this)._pWebGLFramebuffer))));
                    (pSurface)._bindToFramebuffer(iWebGLAttachment, 0);
                    (pSurface).addRef();
                }
            };
            WebGLInternalFrameBuffer.prototype.unbindSurface = function (iWebGLAttachment) {
                if (!((this._pAttachments[iWebGLAttachment]) !== undefined)) {
                    return;
                }
                var pWebGLContext = ((this._pWebGLRenderer)._pWebGLContext);
                /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.releaseAttachment(iWebGLAttachment);
                this._pAttachments[iWebGLAttachment] = null;
                pWebGLContext.framebufferRenderbuffer(0x8D40, iWebGLAttachment, 0x8D41, null);
            };
            WebGLInternalFrameBuffer.prototype.bindColorSurface = /** @inline */function (iAttachment, pSurface) {
                this.bindSurface(0x8CE0 + iAttachment, pSurface);
            };
            WebGLInternalFrameBuffer.prototype._bind = /** @inline */function () {
                ((this._pWebGLRenderer)._pWebGLContext.bindFramebuffer((0x8D40), (this._pWebGLFramebuffer)));
            };
            WebGLInternalFrameBuffer.prototype.attachDepthBuffer = function (pDepthBuffer) {
                var pWebGLContext = ((this._pWebGLRenderer)._pWebGLContext);
                var pOldFramebuffer = this._pWebGLRenderer.getParameter(0x8CA6);
                ((this._pWebGLRenderer)._pWebGLContext.bindFramebuffer((0x8D40), (this._pWebGLFramebuffer)));
                if (!((pDepthBuffer) === null)) {
                    var pDepthRenderBuffer = (((pDepthBuffer))._pDepthBuffer);
                    var pStencilRenderBuffer = (((pDepthBuffer))._pStencilBuffer);
                    if (!((pDepthRenderBuffer) === null)) {
                        pDepthRenderBuffer._bindToFramebuffer(0x8D00, 0);
                        /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.releaseAttachment(0x8D00);
                        this._pAttachments[0x8D00] = pDepthRenderBuffer;
                        pDepthRenderBuffer.addRef();
                    }
                    if (!((pStencilRenderBuffer) === null)) {
                        pStencilRenderBuffer._bindToFramebuffer(0x8D20, 0);
                        /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.releaseAttachment(0x8D20);
                        this._pAttachments[0x8D20] = pStencilRenderBuffer;
                        pDepthRenderBuffer.addRef();
                    }
                    if (!this.checkAttachment(0x8D00) || !this.checkAttachment(0x8D20)) {
 {
                            akra.logger.setSourceLocation("webgl/WebGLInternalFrameBuffer.ts", 124);
                            akra.logger.error("Invalid frame buffer depthbuffer attachment. Wrong size.");
                        }
                        ;
                        return;
                    }
                } else {
                    pWebGLContext.framebufferRenderbuffer(0x8D40, 0x8D00, 0x8D41, null);
                    pWebGLContext.framebufferRenderbuffer(0x8D40, 0x8D20, 0x8D41, null);
                    /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.releaseAttachment(0x8D00);
                    /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.releaseAttachment(0x8D20);
                    this._pAttachments[0x8D00] = null;
                    this._pAttachments[0x8D20] = null;
                }
                ((this._pWebGLRenderer)._pWebGLContext.bindFramebuffer((0x8D40), (pOldFramebuffer)));
            };
            WebGLInternalFrameBuffer.prototype.attachDepthTexture = function (pDepthTexture) {
                var pTextureBuffer = (pDepthTexture).getBuffer();
                ((((this)._pWebGLRenderer)._pWebGLContext.bindFramebuffer((0x8D40), ((this)._pWebGLFramebuffer))));
                this.bindSurface(0x8D00, pTextureBuffer);
            };
            WebGLInternalFrameBuffer.prototype.detachDepthTexture = function () {
                ((((this)._pWebGLRenderer)._pWebGLContext.bindFramebuffer((0x8D40), ((this)._pWebGLFramebuffer))));
                this.unbindSurface(0x8D00);
            };
            WebGLInternalFrameBuffer.prototype.detachDepthBuffer = function () {
                var pWebGLContext = ((this._pWebGLRenderer)._pWebGLContext);
                var pOldFramebuffer = this._pWebGLRenderer.getParameter(0x8CA6);
                ((this._pWebGLRenderer)._pWebGLContext.bindFramebuffer((0x8D40), (this._pWebGLFramebuffer)));
                pWebGLContext.framebufferRenderbuffer(0x8D40, 0x8D00, 0x8D41, null);
                pWebGLContext.framebufferRenderbuffer(0x8D40, 0x8D20, 0x8D41, null);
                /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.releaseAttachment(0x8D00);
                /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.releaseAttachment(0x8D20);
                this._pAttachments[0x8D00] = null;
                this._pAttachments[0x8D20] = null;
                ((this._pWebGLRenderer)._pWebGLContext.bindFramebuffer((0x8D40), (pOldFramebuffer)));
            };
            WebGLInternalFrameBuffer.prototype.swapBuffers = function () {
            };
            WebGLInternalFrameBuffer.prototype.checkAttachment = function (iWebGLAttachment) {
                if (iWebGLAttachment === 0x8CE0) {
                    var isOk = true;
                    for(var i = 1; i < akra.webgl.maxColorAttachments; i++) {
                        isOk = this.checkAttachment(0x8CE0 + i);
                        if (!isOk) {
                            return false;
                        }
                    }
                    isOk = this.checkAttachment(0x8D00);
                    if (!isOk) {
                        return false;
                    }
                    isOk = this.checkAttachment(0x8D20);
                    if (!isOk) {
                        return false;
                    }
                    isOk = this.checkAttachment(0x821A);
                    if (!isOk) {
                        return false;
                    }
                    return true;
                } else {
                    var pBuffer = this._pAttachments[iWebGLAttachment];
                    if (((pBuffer) === null)) {
                        return true;
                    }
                    if (((((this)._pAttachments[0x8CE0])._iWidth)) === 0 && ((((this)._pAttachments[0x8CE0])._iHeight)) === 0) {
                        return true;
                    }
                    if (((((this)._pAttachments[0x8CE0])._iWidth)) !== pBuffer.width && ((((this)._pAttachments[0x8CE0])._iHeight)) !== pBuffer.height) {
                        return false;
                    }
                    if (iWebGLAttachment > 0x8CE0 && iWebGLAttachment < 0x8CE0 + akra.webgl.maxColorAttachments) {
                        if (!((this._pAttachments[0x8CE0]) === null) && ((((this)._pAttachments[0x8CE0])._eFormat)) !== pBuffer.format) {
                            return false;
                        }
                    }
                    return true;
                }
            };
            WebGLInternalFrameBuffer.prototype.releaseAttachment = /** @inline */function (iWebGLAttachment) {
                if (!((this._pAttachments[iWebGLAttachment]) === null)) {
                    this._pAttachments[iWebGLAttachment].release();
                }
            };
            return WebGLInternalFrameBuffer;
        })();
        webgl.WebGLInternalFrameBuffer = WebGLInternalFrameBuffer;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLDepthBuffer = (function (_super) {
            __extends(WebGLDepthBuffer, _super);
            function WebGLDepthBuffer() {
                        _super.call(this);
                /**@protected*/ this._pDepthBuffer = null;
                /**@protected*/ this._pStencilBuffer = null;
            }
            Object.defineProperty(WebGLDepthBuffer.prototype, "depthBuffer", {
                get: /** @inline */function () {
                    return this._pDepthBuffer;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLDepthBuffer.prototype, "stencilBuffer", {
                get: /** @inline */function () {
                    return this._pStencilBuffer;
                },
                enumerable: true,
                configurable: true
            });
            WebGLDepthBuffer.prototype.create = function () {
                if (arguments.length !== 5) {
 {
                        akra.logger.setSourceLocation("webgl/WebGLDepthBuffer.ts", 30);
                        akra.logger.criticalError("Invalid number of arguments. For WebGLDepthBuffer it must be five");
                    }
                    ;
                }
                _super.prototype.create.call(this, 0, arguments[2], arguments[3], arguments[4]);
                var pDepth = arguments[0];
                var pStencil = arguments[1];
                this._pDepthBuffer = pDepth;
                this._pStencilBuffer = pStencil;
                if (!((pDepth) === null)) {
                    switch(pDepth._getWebGLFormat()) {
                        case 0x81A5:
                            this._iBitDepth = 16;
                            break;
                        case 0x81A6:
                        case 0x81A7:
                        case 0x88F0:
                            if (akra.webgl.hasExtension("OES_depth24") || akra.webgl.hasExtension("OES_depth32") || akra.webgl.hasExtension("OES_packed_depth_stencil")) {
                                this._iBitDepth = 32;
                            }
                            break;
                    }
                }
                return true;
            };
            WebGLDepthBuffer.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
                if (!((this._pStencilBuffer) === null) && this._pStencilBuffer !== this._pDepthBuffer) {
                    this._pStencilBuffer.release();
                }
                if (!((this._pDepthBuffer) === null)) {
                    this._pDepthBuffer.release();
                }
                this._pStencilBuffer = null;
                this._pDepthBuffer = null;
            };
            WebGLDepthBuffer.prototype.isCompatible = function (pTarget) {
                if (this._iWidth >= pTarget.width && this._iHeight >= pTarget.height) {
                    return true;
                }
                return false;
            };
            return WebGLDepthBuffer;
        })(akra.core.pool.resources.DepthBuffer);
        webgl.WebGLDepthBuffer = WebGLDepthBuffer;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            //is this class really singleton??
            var ResourcePoolManager = (function () {
                function ResourcePoolManager(pEngine) {
                    /** Списки пулов по семействам ресурсов */
                    this.pResourceFamilyList = null;
                    /** Карта пулов по коду ресурса */
                    this.pResourceTypeMap = null;
                    /** Ресурс для ожидания остальных */
                    this.pWaiterResource = null;
                    //super();
                    this.pEngine = pEngine;
                    this.pResourceFamilyList = new Array(akra.EResourceFamilies.TOTAL_RESOURCE_FAMILIES);
                    for(var i = 0; i < akra.EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i++) {
                        this.pResourceFamilyList[i] = new Array();
                    }
                    this.pResourceTypeMap = new Array();
                    /*this*/
                    this.pWaiterResource = new core.pool.ResourcePoolItem();
                    this.createDeviceResource();
                }
                Object.defineProperty(ResourcePoolManager.prototype, "surfaceMaterialPool", {
                    get: function () {
                        return this.pSurfaceMaterialPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "effectPool", {
                    get: function () {
                        return this.pEffectPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "renderMethodPool", {
                    get: function () {
                        return this.pRenderMethodPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "vertexBufferPool", {
                    get: function () {
                        return this.pVertexBufferPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "indexBufferPool", {
                    get: function () {
                        return this.pIndexBufferPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "colladaPool", {
                    get: function () {
                        return this.pColladaPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "imagePool", {
                    get: function () {
                        return this.pImagePool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "texturePool", {
                    get: function () {
                        return this.pTexturePool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "videoBufferPool", {
                    get: function () {
                        return this.pVideoBufferPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "shaderProgramPool", {
                    get: function () {
                        return this.pShaderProgramPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "componentPool", {
                    get: function () {
                        return this.pComponentPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "textureBufferPool", {
                    get: function () {
                        return this.pTextureBufferPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "renderBufferPool", {
                    get: function () {
                        return this.pRenderBufferPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "depthBufferPool", {
                    get: function () {
                        return this.pDepthBufferPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "effectDataPool", {
                    get: function () {
                        return this.pEffectDataPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                ResourcePoolManager.prototype.initialize = function () {
                    this.registerDeviceResources();
                    return true;
                };
                ResourcePoolManager.prototype.destroy = function () {
                    this.unregisterDeviceResources();
                };
                ResourcePoolManager.prototype.registerResourcePool = function (pCode, pPool) {
 {
                        akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 115);
                        akra.logger.assert(pCode.family >= 0 && pCode.family < akra.EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid code familyi index");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 117);
                        akra.logger.assert(!((this.pResourceTypeMap[pCode.toNumber()]) !== undefined), "Resource type code already registered");
                    }
                    ;
                    this.pResourceTypeMap[pCode.toNumber()] = pPool;
                    this.pResourceFamilyList[pCode.family].push(pPool);
                };
                ResourcePoolManager.prototype.unregisterResourcePool = function (pCode) {
 {
                        akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 124);
                        akra.logger.assert(pCode.family >= 0, "invalid family index");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 125);
                        akra.logger.assert(pCode.family < akra.EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index");
                    }
                    ;
                    var iCode = pCode.toNumber();
                    var pPool = null;
                    if (this.pResourceTypeMap[iCode] != undefined) {
                        pPool = this.pResourceTypeMap[iCode];
                        delete this.pResourceTypeMap[iCode];
                    }
                    if (pPool != null) {
                        for(var i in this.pResourceFamilyList[pCode.family]) {
                            if (this.pResourceFamilyList[pCode.family][i] == pPool) {
                                delete this.pResourceFamilyList[pCode.family][i];
                                return pPool;
                            }
                        }
                    }
                    return pPool;
                };
                ResourcePoolManager.prototype.destroyResourceFamily = function (eFamily) {
 {
                        akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 148);
                        akra.logger.assert(eFamily < akra.EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index");
                    }
                    ;
                    for(var i in this.pResourceFamilyList[eFamily]) {
                        this.pResourceFamilyList[eFamily][i].destroyAll();
                    }
                };
                ResourcePoolManager.prototype.restoreResourceFamily = function (eFamily) {
 {
                        akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 157);
                        akra.logger.assert(eFamily >= 0, "invalid family index");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 158);
                        akra.logger.assert(eFamily < akra.EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index");
                    }
                    ;
                    for(var i in this.pResourceFamilyList[eFamily]) {
                        this.pResourceFamilyList[eFamily][i].restoreAll();
                    }
                };
                ResourcePoolManager.prototype.disableResourceFamily = function (eFamily) {
 {
                        akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 166);
                        akra.logger.assert(eFamily >= 0, "invalid family index");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 167);
                        akra.logger.assert(eFamily < akra.EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index");
                    }
                    ;
                    for(var i in this.pResourceFamilyList[eFamily]) {
                        this.pResourceFamilyList[eFamily][i].disableAll();
                    }
                };
                ResourcePoolManager.prototype.cleanResourceFamily = function (eFamily) {
 {
                        akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 175);
                        akra.logger.assert(eFamily >= 0, "invalid family index");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 176);
                        akra.logger.assert(eFamily < akra.EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index");
                    }
                    ;
                    for(var i in this.pResourceFamilyList[eFamily]) {
                        this.pResourceFamilyList[eFamily][i].clean();
                    }
                };
                ResourcePoolManager.prototype.destroyResourceType = function (pCode) {
                    if (((this.pResourceTypeMap[pCode.toNumber()]) !== undefined)) {
                        this.pResourceTypeMap[pCode.toNumber()].destroyAll();
                    }
                };
                ResourcePoolManager.prototype.restoreResourceType = function (pCode) {
                    if (((this.pResourceTypeMap[pCode.toNumber()]) !== undefined)) {
                        this.pResourceTypeMap[pCode.toNumber()].restoreAll();
                    }
                };
                ResourcePoolManager.prototype.disableResourceType = function (pCode) {
                    if (((this.pResourceTypeMap[pCode.toNumber()]) !== undefined)) {
                        this.pResourceTypeMap[pCode.toNumber()].disableAll();
                    }
                };
                ResourcePoolManager.prototype.cleanResourceType = function (pCode) {
                    if (((this.pResourceTypeMap[pCode.toNumber()]) !== undefined)) {
                        this.pResourceTypeMap[pCode.toNumber()].clean();
                    }
                };
                ResourcePoolManager.prototype.findResourcePool = function (pCode) {
                    if (((this.pResourceTypeMap[pCode.toNumber()]) !== undefined)) {
                        return this.pResourceTypeMap[pCode.toNumber()];
                    }
                    return null;
                };
                ResourcePoolManager.prototype.findResourceHandle = function (pCode, sName) {
                    var pPool = this.findResourcePool(pCode);
                    var iHandle = akra.INVALID_INDEX;
                    if (!((pPool) === null)) {
                        iHandle = pPool.findResourceHandle(sName);
                    }
                    return iHandle;
                };
                ResourcePoolManager.prototype.findResource = function (pCode, sName) {
                    var pPool = this.findResourcePool(pCode);
                    var pResult = null;
                    var iHandle = 0;
                    if ((typeof (arguments[1]) === "string")) {
                        iHandle = pPool.findResourceHandle(sName);
                    } else if ((typeof (arguments[1]) === "number")) {
                        iHandle = arguments[1];
                    }
                    if (pPool != null && iHandle != akra.INVALID_INDEX) {
                        pResult = pPool.getResource(iHandle);
                    }
                    return pResult;
                };
                ResourcePoolManager.prototype.monitorInitResources = function (fnMonitor) {
                    var me = this;
                    this.pWaiterResource.setStateWatcher(akra.EResourceItemEvents.LOADED, function () {
                        fnMonitor.apply(me, arguments);
                    });
                };
                ResourcePoolManager.prototype.setLoadedAllRoutine = function (fnCallback) {
                    var pPool;
                    var pResource;
                    var iHandleResource;
                    var pWaiterResouse = this.pWaiterResource;
                    var fnResCallback = function (iFlagBit, iResourceFlags, isSetting) {
                        if (iFlagBit == akra.EResourceItemEvents.LOADED && isSetting) {
                            fnCallback();
                        }
                    };
                    pWaiterResouse.notifyLoaded();
                    for(var n = 0; n < akra.EResourceFamilies.TOTAL_RESOURCE_FAMILIES; n++) {
                        var nTotal = parseInt(ResourcePoolManager.pTypedResourseTotal[n]);
                        for(var i = 0; i < nTotal; i++) {
                            pPool = this.findResourcePool(new pool.ResourceCode(n, i));
                            if (pPool) {
                                var pResources = pPool.getResources();
                                var pResource;
                                for(var h = 0; h < pResources.length; ++h) {
                                    pResource = pResources[h];
                                    pWaiterResouse.sync(pResource, akra.EResourceItemEvents.LOADED);
                                }
                            }
                        }
                    }
                    if (pWaiterResouse.isResourceLoaded()) {
                        fnCallback();
                    } else {
                        pWaiterResouse.setChangesNotifyRoutine(fnResCallback);
                    }
                };
                ResourcePoolManager.prototype.destroyAll = function () {
                    for(var i = 0; i < akra.EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i++) {
                        this.destroyResourceFamily(i);
                    }
                };
                ResourcePoolManager.prototype.restoreAll = function () {
                    for(var i = 0; i < akra.EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i++) {
                        this.restoreResourceFamily(i);
                    }
                };
                ResourcePoolManager.prototype.disableAll = function () {
                    for(var i = 0; i < akra.EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i++) {
                        this.disableResourceFamily(i);
                    }
                };
                ResourcePoolManager.prototype.clean = function () {
                    for(var i = 0; i < akra.EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i++) {
                        this.cleanResourceFamily(i);
                    }
                };
                ResourcePoolManager.prototype.createDeviceResources = function () {
                    return true;
                };
                ResourcePoolManager.prototype.destroyDeviceResources = function () {
                    this.disableDeviceResources();
                    // then destroy...
                     {
                        akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 330);
                        akra.logger.log("Destroying Video Device Resources\n");
                    }
                    ;
                    this.destroyResourceFamily(akra.EResourceFamilies.VIDEO_RESOURCE);
                    return true;
                };
                ResourcePoolManager.prototype.restoreDeviceResources = function () {
 {
                        akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 338);
                        akra.logger.log("Restoring Video Device Resources\n");
                    }
                    ;
                    this.restoreResourceFamily(akra.EResourceFamilies.VIDEO_RESOURCE);
                    return true;
                };
                ResourcePoolManager.prototype.disableDeviceResources = function () {
 {
                        akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 344);
                        akra.logger.log("Disabling Video Device Resources\n");
                    }
                    ;
                    this.disableResourceFamily(akra.EResourceFamilies.VIDEO_RESOURCE);
                    return true;
                };
                ResourcePoolManager.prototype.getEngine = /** @inline */function () {
                    return this.pEngine;
                };
                ResourcePoolManager.prototype.createRenderMethod = /** @inline */function (sResourceName) {
                    return this.renderMethodPool.createResource(sResourceName);
                };
                ResourcePoolManager.prototype.createTexture = /** @inline */function (sResourceName) {
                    return this.texturePool.createResource(sResourceName);
                };
                ResourcePoolManager.prototype.createEffect = /** @inline */function (sResourceName) {
                    return this.effectPool.createResource(sResourceName);
                };
                ResourcePoolManager.prototype.createSurfaceMaterial = /** @inline */function (sResourceName) {
                    return this.surfaceMaterialPool.createResource(sResourceName);
                };
                ResourcePoolManager.prototype.createVertexBuffer = /** @inline */function (sResourceName) {
                    return this.vertexBufferPool.createResource(sResourceName);
                };
                ResourcePoolManager.prototype.createVideoBuffer = /** @inline */function (sResourceName) {
                    return this.videoBufferPool.createResource(sResourceName);
                };
                ResourcePoolManager.prototype.createIndexBuffer = /** @inline */function (sResourceName) {
                    return this.indexBufferPool.createResource(sResourceName);
                };
                ResourcePoolManager.prototype.createShaderProgram = /** @inline */function (sResourceName) {
                    return this.shaderProgramPool.createResource(sResourceName);
                };
                ResourcePoolManager.prototype.createModel = /** @inline */function (sResourceName) {
                    return this.colladaPool.createResource(sResourceName);
                };
                ResourcePoolManager.prototype.createImg = /** @inline */function (sResourceName) {
                    return this.imagePool.createResource(sResourceName);
                };
                ResourcePoolManager.prototype.loadModel = /** @inline */function (sFilename, pOptions) {
                    if (typeof pOptions === "undefined") { pOptions = null; }
                    if (akra.util.pathinfo(sFilename).ext.toLowerCase() === "dae") {
                        var pCollada = this.colladaPool.findResource(sFilename);
                        if (((pCollada) === null)) {
                            pCollada = this.colladaPool.createResource(sFilename);
                        }
                        if (!pCollada.isResourceLoaded()) {
                            pCollada.loadResource(sFilename, pOptions);
                        }
                        return pCollada;
                    }
                    return null;
                };
                ResourcePoolManager.prototype.loadImage = function (sFilename) {
                    var pImg = this.imagePool.findResource(sFilename);
                    if (((pImg) === null)) {
                        pImg = this.imagePool.createResource(sFilename);
                        if (!pImg.isResourceLoaded()) {
                            pImg.loadResource(sFilename);
                        }
                    }
                    return pImg;
                };
                ResourcePoolManager.prototype.createDeviceResource = function () {
                    this.pSurfaceMaterialPool = new pool.ResourcePool(this, pool.resources.SurfaceMaterial);
                    this.pSurfaceMaterialPool.initialize(16);
                    this.pEffectPool = new pool.ResourcePool(this, pool.resources.Effect);
                    this.pEffectPool.initialize(16);
                    this.pRenderMethodPool = new pool.ResourcePool(this, pool.resources.RenderMethod);
                    this.pRenderMethodPool.initialize(16);
                    this.pColladaPool = new pool.ResourcePool(this, pool.resources.Collada);
                    this.pColladaPool.initialize(0);
                    this.pImagePool = new pool.ResourcePool(this, pool.resources.Img);
                    this.pImagePool.initialize(16);
                    this.pTexturePool = new pool.ResourcePool(this, akra.webgl.WebGLInternalTexture);
                    this.pTexturePool.initialize(16);
                    this.pIndexBufferPool = new pool.ResourcePool(this, akra.webgl.WebGLIndexBuffer);
                    this.pIndexBufferPool.initialize(16);
                    this.pVertexBufferPool = new pool.ResourcePool(this, akra.webgl.WebGLVertexBuffer);
                    this.pVertexBufferPool.initialize(16);
                    this.pVideoBufferPool = new pool.ResourcePool(this, akra.webgl.WebGLVertexTexture);
                    this.pVideoBufferPool.initialize(16);
                    this.pTextureBufferPool = new pool.ResourcePool(this, akra.webgl.WebGLTextureBuffer);
                    this.pTextureBufferPool.initialize(16);
                    this.pShaderProgramPool = new pool.ResourcePool(this, akra.webgl.WebGLShaderProgram);
                    this.pShaderProgramPool.initialize(16);
                    this.pRenderBufferPool = new pool.ResourcePool(this, akra.webgl.WebGLInternalRenderBuffer);
                    this.pRenderBufferPool.initialize(16);
                    this.pDepthBufferPool = new pool.ResourcePool(this, akra.webgl.WebGLDepthBuffer);
                    this.pDepthBufferPool.initialize(16);
                    this.pEffectDataPool = new pool.ResourcePool(this, pool.resources.EffectData);
                    this.pEffectDataPool.initialize(8);
                    this.pComponentPool = new pool.ResourcePool(this, pool.resources.Component);
                    this.pComponentPool.initialize(16);
                };
                ResourcePoolManager.prototype.registerDeviceResources = function () {
 {
                        akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 478);
                        akra.logger.log("Registering Video Device Resources\n");
                    }
                    ;
                    this.pTexturePool.registerResourcePool(new pool.ResourceCode(akra.EResourceFamilies.VIDEO_RESOURCE, akra.EVideoResources.TEXTURE_RESOURCE));
                    this.pVertexBufferPool.registerResourcePool(new pool.ResourceCode(akra.EResourceFamilies.VIDEO_RESOURCE, akra.EVideoResources.VERTEXBUFFER_RESOURCE));
                    this.pIndexBufferPool.registerResourcePool(new pool.ResourceCode(akra.EResourceFamilies.VIDEO_RESOURCE, akra.EVideoResources.INDEXBUFFER_RESOURCE));
                    this.pEffectPool.registerResourcePool(new pool.ResourceCode(akra.EResourceFamilies.VIDEO_RESOURCE, akra.EVideoResources.EFFECT_RESOURCE));
                    this.pRenderMethodPool.registerResourcePool(new pool.ResourceCode(akra.EResourceFamilies.VIDEO_RESOURCE, akra.EVideoResources.RENDERMETHOD_RESOURCE));
                    this.pColladaPool.registerResourcePool(new pool.ResourceCode(akra.EResourceFamilies.VIDEO_RESOURCE, akra.EVideoResources.MODEL_RESOURCE));
                    this.pImagePool.registerResourcePool(new pool.ResourceCode(akra.EResourceFamilies.VIDEO_RESOURCE, akra.EVideoResources.IMAGE_RESOURCE));
                    this.pSurfaceMaterialPool.registerResourcePool(new pool.ResourceCode(akra.EResourceFamilies.VIDEO_RESOURCE, akra.EVideoResources.SURFACEMATERIAL_RESOURCE));
                    this.pVideoBufferPool.registerResourcePool(new pool.ResourceCode(akra.EResourceFamilies.VIDEO_RESOURCE, akra.EVideoResources.VIDEOBUFFER_RESOURCE));
                    this.pShaderProgramPool.registerResourcePool(new pool.ResourceCode(akra.EResourceFamilies.VIDEO_RESOURCE, akra.EVideoResources.SHADERPROGRAM_RESOURCE));
                    this.pComponentPool.registerResourcePool(new pool.ResourceCode(akra.EResourceFamilies.VIDEO_RESOURCE, akra.EVideoResources.COMPONENT_RESOURCE));
                    this.pEffectDataPool.registerResourcePool(new pool.ResourceCode(akra.EResourceFamilies.VIDEO_RESOURCE, akra.EVideoResources.EFFECTDATA_RESOURCE));
                };
                ResourcePoolManager.prototype.unregisterDeviceResources = function () {
 {
                        akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 530);
                        akra.logger.log("Unregistering Video Device Resources");
                    }
                    ;
                    this.pTexturePool.unregisterResourcePool();
                    this.pVertexBufferPool.unregisterResourcePool();
                    this.pIndexBufferPool.unregisterResourcePool();
                    this.pEffectPool.unregisterResourcePool();
                    this.pRenderMethodPool.unregisterResourcePool();
                    this.pColladaPool.unregisterResourcePool();
                    this.pImagePool.unregisterResourcePool();
                    this.pSurfaceMaterialPool.unregisterResourcePool();
                    this.pVideoBufferPool.unregisterResourcePool();
                    this.pShaderProgramPool.unregisterResourcePool();
                    this.pComponentPool.unregisterResourcePool();
                };
                ResourcePoolManager.pTypedResourseTotal = [
                    akra.EVideoResources.TOTAL_VIDEO_RESOURCES, 
                    akra.EAudioResources.TOTAL_AUDIO_RESOURCES, 
                    akra.EGameResources.TOTAL_GAME_RESOURCES
                ];
                return ResourcePoolManager;
            })();
            pool.ResourcePoolManager = ResourcePoolManager;            
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        (function (objects) {
            var ModelEntry = (function (_super) {
                __extends(ModelEntry, _super);
                function ModelEntry(pScene, pModel) {
                                _super.call(this, pScene, akra.EEntityTypes.MODEL_ENTRY);
                    /**@protected*/ this._pModelResource = null;
                    this._pModelResource = pModel;
                }
                Object.defineProperty(ModelEntry.prototype, "resource", {
                    get: /** @inline */function () {
                        return this._pModelResource;
                    },
                    enumerable: true,
                    configurable: true
                });
                return ModelEntry;
            })(scene.SceneNode);
            objects.ModelEntry = ModelEntry;            
            function isModelEntry(pEntity) {
                return !((pEntity) === null) && pEntity.type === akra.EEntityTypes.MODEL_ENTRY;
            }
            objects.isModelEntry = isModelEntry;
        })(scene.objects || (scene.objects = {}));
        var objects = scene.objects;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        var DisplayList = (function () {
            function DisplayList() {
                /**@protected*/ this._pScene = null;
                /**@protected*/ this._sName = "";
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
            }
            Object.defineProperty(DisplayList.prototype, "name", {
                get: /** @inline */function () {
                    return this._sName;
                },
                set: /** @inline */function (sName) {
                    this._sName = sName;
                },
                enumerable: true,
                configurable: true
            });
            DisplayList.prototype._onNodeAttachment = function (pScene, pNode) {
                this.attachObject(pNode);
            };
            DisplayList.prototype._onNodeDetachment = function (pScene, pNode) {
                this.detachObject(pNode);
            };
            DisplayList.prototype.attachObject = /**@protected*/ function (pNode) {
 {
                    akra.logger.setSourceLocation("DisplayList.ts", 29);
                    akra.logger.error("pure virtual method DisplayList::attachObject()");
                }
                ;
            };
            DisplayList.prototype.detachObject = /**@protected*/ function (pNode) {
 {
                    akra.logger.setSourceLocation("DisplayList.ts", 33);
                    akra.logger.error("pure virtual method DisplayList::detachObject()");
                }
                ;
            };
            DisplayList.prototype._setup = function (pScene) {
                if (((this._pScene) != null)) {
 {
                        akra.logger.setSourceLocation("DisplayList.ts", 38);
                        akra.logger.criticalError("list movement from scene to another scene temprary unsupported!");
                    }
                    ;
                }
                this._pScene = pScene;
                ((pScene).getEventTable().addDestination(((((pScene)))._iGuid), ("nodeAttachment"), (this), ("_onNodeAttachment"), (undefined)));
                ((pScene).getEventTable().addDestination(((((pScene)))._iGuid), ("nodeDetachment"), (this), ("_onNodeDetachment"), (undefined)));
                var me = this;
                pScene.getRootNode().explore(function (pEntity) {
                    me._onNodeAttachment(pScene, pEntity);
                });
            };
            DisplayList.prototype._findObjects = function (pCamera, pResultArray, bQuickSearch) {
                if (typeof bQuickSearch === "undefined") { bQuickSearch = false; }
 {
                    akra.logger.setSourceLocation("DisplayList.ts", 54);
                    akra.logger.error("pure virtual method");
                }
                ;
                return null;
            };
            DisplayList.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            DisplayList._pEventTable = new akra.events.EventTable();
            DisplayList.prototype.getEventTable = /** @inline */function () {
                return DisplayList._pEventTable;
            };
            DisplayList.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            DisplayList.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            DisplayList.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (DisplayList._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            DisplayList.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (DisplayList._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            DisplayList.prototype._syncTable = /** @inline */function (pFrom) {
                (DisplayList._pEventTable)._sync(this, pFrom);
            };
            return DisplayList;
        })();
        scene.DisplayList = DisplayList;        
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        ;
        var ObjectList = (function () {
            function ObjectList(pData) {
                /**@protected*/ this._pHead = null;
                /**@protected*/ this._pTail = null;
                /**@protected*/ this._pCurrent = null;
                /**@protected*/ this._iLength = 0;
                /**@protected*/ this._bLock = false;
                if (arguments.length) {
                    this.fromArray(pData);
                }
            }
            Object.defineProperty(ObjectList.prototype, "length", {
                get: /** @inline */function () {
                    return this._iLength;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ObjectList.prototype, "first", {
                get: /** @inline */function () {
                    this._pCurrent = this._pHead;
                    return (((this._pCurrent) != null)) ? this._pCurrent.data : null;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ObjectList.prototype, "last", {
                get: /** @inline */function () {
                    this._pCurrent = this._pTail;
                    return (((this._pCurrent) != null)) ? this._pCurrent.data : null;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ObjectList.prototype, "current", {
                get: /** @inline */function () {
                    return (((this._pCurrent) != null)) ? this._pCurrent.data : null;
                },
                enumerable: true,
                configurable: true
            });
            ObjectList.prototype.lock = /** @inline */function () {
                this._bLock = true;
            };
            ObjectList.prototype.unlock = /** @inline */function () {
                this._bLock = false;
            };
            ObjectList.prototype.isLocked = /** @inline */function () {
                return this._bLock;
            };
            ObjectList.prototype.value = /** @inline */function (n) {
                return /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.find(n).data;
            };
            ObjectList.prototype.indexOf = function (pData, iFrom) {
                if (typeof iFrom === "undefined") { iFrom = 0; }
                var pItem = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.find(iFrom);
                for(var i = iFrom; i < this._iLength; i++) {
                    if (pItem.data === pData) {
                        return i;
                    }
                    pItem = pItem.next;
                }
                return -1;
            };
            ObjectList.prototype.mid = function (iPos, iSize) {
                if (typeof iPos === "undefined") { iPos = 0; }
                if (typeof iSize === "undefined") { iSize = this._iLength; }
                iSize = Math.min(this._iLength - iPos, iSize);
                if (iPos > this._iLength - 1) {
                    return null;
                }
                var pNewList = new ObjectList();
                var pItem = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.find(iPos);
                for(var i = 0; i < iSize; ++i) {
                    pNewList.push(pItem.data);
                    pItem = pItem.next;
                }
                ;
                return pNewList;
            };
            ObjectList.prototype.slice = /** @inline */function (iStart, iEnd) {
                if (typeof iStart === "undefined") { iStart = 0; }
                if (typeof iEnd === "undefined") { iEnd = Math.max(this._iLength - iStart, 0); }
                return this.mid(iStart, iEnd - iStart);
            };
            ObjectList.prototype.move = /** @inline */function (iFrom, iTo) {
                return this.insert(iTo - 1, /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/this.takeAt(iFrom));
            };
            ObjectList.prototype.replace = /** @inline */function (iPos, pData) {
 {
                    util.logger.setSourceLocation("util/ObjectList.ts", 102);
                    util.logger.assert(!((this)._bLock), "list locked.");
                }
                ;
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.find(iPos).data = pData;
                return this;
            };
            ObjectList.prototype.erase = function (begin, end) {
                if (arguments.length < 2) {
                    /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/this.takeAt(arguments[0]);
                } else {
                    end = Math.min(end, this._iLength);
                    for(var i = begin; i < end; i++) {
                        /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/this.takeAt(i);
                    }
                }
                return this;
            };
            ObjectList.prototype.contains = /** @inline */function (pData) {
                return (this.indexOf(pData) >= 0);
            };
            ObjectList.prototype.removeAt = /** @inline */function (n) {
                /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/this.takeAt(n);
            };
            ObjectList.prototype.removeOne = /** @inline */function (pData) {
                (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/(this).takeAt((this.indexOf(pData))));
            };
            ObjectList.prototype.removeAll = /** @inline */function (pData) {
                var i;
                var n = ((this)._iLength);
                while((i = this.indexOf(pData)) >= 0) {
                    (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*/(this).takeAt((i)));
                    i--;
                }
                return n;
            };
            ObjectList.prototype.swap = function (i, j) {
 {
                    util.logger.setSourceLocation("util/ObjectList.ts", 147);
                    util.logger.assert(!((this)._bLock), "list locked.");
                }
                ;
                i = Math.min(i, this._iLength - 1);
                j = Math.min(j, this._iLength - 1);
                if (i != j) {
                    var pItem1 = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.find(i);
                    var pItem2 = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.find(j);
                    var pTmp = pItem1.data;
                    pItem1.data = pItem2.data;
                    pItem2.data = pTmp;
                }
                return this;
            };
            ObjectList.prototype.add = function (pList) {
                pList.seek(0);
                if (pList.length > 1) {
                    ((this).insert((this)._iLength, (pList.first())));
                }
                for(var i = 1; i < pList.length; i++) {
                    ((this).insert((this)._iLength, (pList.next())));
                }
                return this;
            };
            ObjectList.prototype.seek = function (n) {
                if (typeof n === "undefined") { n = 0; }
                var pElement;
                n = Math.min(n, this._iLength - 1);
                if (n > this._iLength / 2) {
                    pElement = this._pTail;
                    for(var m = this._iLength - 1 - n; m > 0; --m) {
                        pElement = pElement.prev;
                    }
                } else {
                    pElement = this._pHead;
                    for(var i = 0; i < n; ++i) {
                        pElement = pElement.next;
                    }
                }
                this._pCurrent = pElement;
                return this;
            };
            ObjectList.prototype.next = /** @inline */function () {
                return (((this._pCurrent) != null) && ((this._pCurrent.next) != null)) ? (this._pCurrent = this._pCurrent.next).data : null;
            };
            ObjectList.prototype.prev = /** @inline */function () {
                return (((this._pCurrent) != null) && ((this._pCurrent.prev) != null)) ? (this._pCurrent = this._pCurrent.prev).data : null;
            };
            ObjectList.prototype.push = /** @inline */function (pElement) {
                return this.insert(this._iLength, pElement);
            };
            ObjectList.prototype.takeAt = /** @inline */function (n) {
 {
                    util.logger.setSourceLocation("util/ObjectList.ts", 217);
                    util.logger.assert(!((this)._bLock), "list locked.");
                }
                ;
                if (n < 0) {
                    return null;
                }
                return this.pullElement(/*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.find(n));
            };
            ObjectList.prototype.pullElement = function (pItem) {
                if (((pItem) === null)) {
                    //this case theoretically cannot happen, but ....
                    return null;
                }
                if (((pItem.prev) === null)) {
                    this._pHead = pItem.next;
                } else {
                    pItem.prev.next = pItem.next;
                }
                if (((pItem.next) === null)) {
                    this._pTail = pItem.prev;
                } else {
                    pItem.next.prev = pItem.prev;
                }
                this._iLength--;
                if (((pItem.next) === null)) {
                    this._pCurrent = this._pTail;
                } else {
                    this._pCurrent = pItem.next;
                }
                return /*not inlined, because supportes only single statement functions(cur. st. count: 7)*/this.releaseItem(pItem);
            };
            ObjectList.prototype.takeFirst = /** @inline */function () {
                return /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/this.takeAt(0);
            };
            ObjectList.prototype.takeLast = /** @inline */function () {
                return /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/this.takeAt(this._iLength - 1);
            };
            ObjectList.prototype.takeCurrent = /** @inline */function (isPrev) {
                if (typeof isPrev === "undefined") { isPrev = false; }
                //console.log(isDefAndNotNull(this._pCurrent));
                return this.pullElement(this._pCurrent);
            };
            ObjectList.prototype.pop = /** @inline */function () {
                return /*not inlined, because supportes only single statement functions(cur. st. count: 5)*/this.takeAt(this._iLength - 1);
            };
            ObjectList.prototype.prepend = /** @inline */function (pElement) {
                return this.insert(0, pElement);
            };
            ObjectList.prototype.find = /** @inline */function (n) {
                if (n < this._iLength) {
                    this.seek(n);
                    return this._pCurrent;
                }
                return null;
            };
            ObjectList.prototype.releaseItem = /** @inline */function (pItem) {
                var pData = pItem.data;
                pItem.next = null;
                pItem.prev = null;
                pItem.data = null;
                ObjectList.listItemPool.push(pItem);
                return pData;
            };
            ObjectList.prototype.createItem = /** @inline */function () {
                if (ObjectList.listItemPool.length == 0) {
                    // LOG("allocated object list item");
                    return {
                        next: null,
                        prev: null,
                        data: null
                    };
                }
                // LOG("before pop <----------", this._iLength, this.first);
                return ObjectList.listItemPool.pop();
            };
            ObjectList.prototype.fromArray = function (elements, iOffset, iSize) {
                if (typeof iOffset === "undefined") { iOffset = 0; }
                if (typeof iSize === "undefined") { iSize = elements.length; }
                iOffset = Math.min(iOffset, this._iLength);
                for(var i = 0; i < iSize; i++) {
                    this.insert(iOffset + i, elements[i]);
                }
                return this;
            };
            ObjectList.prototype.insert = function (n, pData) {
 {
                    util.logger.setSourceLocation("util/ObjectList.ts", 321);
                    util.logger.assert(!((this)._bLock), "list locked.");
                }
                ;
                var pNew = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.createItem();
                var pItem;
                n = Math.min(n, this._iLength);
                pNew.data = pData;
                if (n == 0) {
                    if (((this._pHead) === null)) {
                        this._pTail = pNew;
                    }
                    pNew.next = this._pHead;
                    this._pHead = pNew;
                } else {
                    pItem = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.find(n - 1);
                    if (pItem == null) {
                        this._pHead = pNew;
                    } else {
                        if (pItem.next == null) {
                            this._pTail = pNew;
                        } else {
                            pNew.next = pItem.next;
                            pItem.next.prev = pNew;
                        }
                        pItem.next = pNew;
                        pNew.prev = pItem;
                    }
                }
                this._iLength++;
                this._pCurrent = pNew;
                return this;
            };
            ObjectList.prototype.isEqual = function (pList) {
                if (this._iLength == pList.length) {
                    if (this === pList) {
                        return true;
                    }
                    var l1 = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.first;
                    var l2 = pList.first;
                    for(var i = 0; i < this._iLength; ++i) {
                        if (l1 != l2) {
                            return false;
                        }
                        l1 = (((((this)._pCurrent) != null) && (((this)._pCurrent.next) != null)) ? ((this)._pCurrent = (this)._pCurrent.next).data : null);
                        l2 = pList.next();
                    }
                    return true;
                }
                return false;
            };
            ObjectList.prototype.clear = function () {
 {
                    util.logger.setSourceLocation("util/ObjectList.ts", 390);
                    util.logger.assert(!((this)._bLock), "list locked.");
                }
                ;
                var pPrev;
                var pNext;
                this._pCurrent = this._pHead;
                for(var i = 0; i < this._iLength; ++i) {
                    pPrev = this._pCurrent;
                    pNext = this._pCurrent = this._pCurrent.next;
                    /*not inlined, because supportes only single statement functions(cur. st. count: 7)*/this.releaseItem(pPrev);
                }
                this._pHead = this._pCurrent = this._pTail = null;
                this._iLength = 0;
                return this;
            };
            ObjectList.prototype.forEach = function (fn) {
                var pItem = this._pHead;
                var n = 0;
                do {
                    if (fn(pItem.data, n++) === false) {
                        return;
                    }
                } while((pItem = pItem.next));
            };
            ObjectList.listItemPool = new util.ObjectArray();
            return ObjectList;
        })();
        util.ObjectList = ObjectList;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.ObjectList = akra.util.ObjectList;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        /** OcTreeNode class represent node of OcTree */
        var OcTreeNode = (function () {
            //index - is xyz where x-left = 0, x-right = 1 etc.
            function OcTreeNode(pTree) {
                /** Level of node */
                this.level = 0;
                /** Byte x-coord of node */
                //x: int = 0;
                /** Byte y-coord of node */
                //y: int = 0;
                /** Byte z-coord of node */
                //z: int = 0;
                /** Index in array of nodes in tree */
                this.index = 0;
                /** Link to previous node in tree */
                this.rearNodeLink = null;
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
                this.membersList = new akra.util.ObjectList();
                this.worldBounds = new akra.geometry.Rect3d();
                this.childrenList = new Array(8);
                for(var i = 0; i < 8; i++) {
                    this.childrenList[i] = new akra.util.ObjectList();
                }
                this.tree = pTree;
            }
            OcTreeNode.prototype.addMember = /**
            * Add object in this node
            */
            function (pObject) {
                this.membersList.push(pObject);
                ((pObject).getEventTable().addDestination(((((pObject)))._iGuid), ("worldBoundsUpdated"), (this), ("OcTreeObjectMoved"), (/*checked (origin: akra)>>*/akra.EEventTypes.UNICAST)));
                // console.log(this.membersList);
                            };
            OcTreeNode.prototype.removeMember = /**
            * Remove member object from node and release node if there are not members in it
            */
            function (pObject) {
                var i = this.membersList.indexOf(pObject);
                // console.log('position in list ------------>',i);
                // make sure this is one of ours
                 {
                    akra.logger.setSourceLocation("OcTreeNode.ts", 69);
                    akra.logger.assert(i >= 0, "error removing member cannot find member");
                }
                ;
                if (i >= 0) {
                    this.membersList.takeAt(i);
                    ((pObject).getEventTable().removeDestination(((((pObject)))._iGuid), ("worldBoundsUpdated"), (this), ("OcTreeObjectMoved"), (/*checked (origin: akra)>>*/akra.EEventTypes.UNICAST)));
                }
                if (this.membersList.length === 0) {
                    this.tree.deleteNodeFromTree(this);
                }
            };
            OcTreeNode.prototype.toString = function () {
                var sStr = "guid: " + this._iGuid.toString() + "\n";
                sStr += "level: " + this.level.toString() + "\n";
                sStr += "index: " + this.index.toString() + "\n";
                sStr += "world bounds: " + this.worldBounds.toString() + "\n";
                return sStr;
            };
            OcTreeNode.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            OcTreeNode._pEventTable = new akra.events.EventTable();
            OcTreeNode.prototype.getEventTable = /** @inline */function () {
                return OcTreeNode._pEventTable;
            };
            OcTreeNode.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            OcTreeNode.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            OcTreeNode.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (OcTreeNode._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            OcTreeNode.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (OcTreeNode._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            OcTreeNode.prototype._syncTable = /** @inline */function (pFrom) {
                (OcTreeNode._pEventTable)._sync(this, pFrom);
            };
            OcTreeNode.prototype.OcTreeObjectMoved = function (pObject) {
                // console.warn('object moving');
                var pNode = this.tree.findTreeNode(pObject);
                if (pNode !== this) {
                    this.removeMember(pObject);
                    pNode.addMember(pObject);
                }
            };
            return OcTreeNode;
        })();
        scene.OcTreeNode = OcTreeNode;        
        ;
        var OcTreeRootNode = (function (_super) {
            __extends(OcTreeRootNode, _super);
            function OcTreeRootNode(pTree) {
                        _super.call(this, pTree);
                var iTmp = (1 << this.tree.depth);
                this._pBasicWorldBounds = new akra.geometry.Rect3d(0, iTmp, 0, iTmp, 0, iTmp);
                this._pBasicWorldBounds.divSelf(this.tree.worldScale);
                this._pBasicWorldBounds.subSelf(this.tree.worldOffset);
                this.worldBounds.set(this._pBasicWorldBounds);
            }
            OcTreeRootNode.prototype.addMember = function (pMember) {
                _super.prototype.addMember.call(this, pMember);
                //обновляем границы нода, критично, в том случае если объект выходит за границы нода, так как иначе отсекаться будет неправильно
                this._updateNodeBoundingBox();
            };
            OcTreeRootNode.prototype.removeMember = function (pObject) {
                var i = this.membersList.indexOf(pObject);
                // make sure this is one of ours
                 {
                    akra.logger.setSourceLocation("OcTreeNode.ts", 127);
                    akra.logger.assert(i >= 0, "error removing member cannot find member");
                }
                ;
                if (i >= 0) {
                    this.membersList.takeAt(i);
                    ((pObject).getEventTable().removeDestination(((((pObject)))._iGuid), ("worldBoundsUpdated"), (this), ("OcTreeObjectMoved"), (/*checked (origin: akra)>>*/akra.EEventTypes.UNICAST)));
                }
                //обновляем границы нода, критично, в том случае если объект выходит за границы нода, так как иначе отсекаться будет неправильно
                this._updateNodeBoundingBox();
            };
            OcTreeRootNode.prototype._updateNodeBoundingBox = /**@protected*/ function () {
                var pNodeWorldBounds = this.worldBounds;
                pNodeWorldBounds.set(this._pBasicWorldBounds);
                var pObject = this.membersList.first;
                while(((pObject) != null)) {
                    pNodeWorldBounds.unionRect(pObject.worldBounds);
                    pObject = this.membersList.next();
                }
            };
            return OcTreeRootNode;
        })(OcTreeNode);
        scene.OcTreeRootNode = OcTreeRootNode;        
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (geometry) {
        var Ray2d = (function () {
            function Ray2d() {
                this.point = new akra.Vec2();
                this.normal = new akra.Vec2();
            }
            return Ray2d;
        })();
        geometry.Ray2d = Ray2d;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (geometry) {
        var Ray3d = (function () {
            function Ray3d() {
                this.point = new akra.Vec3();
                this.normal = new akra.Vec3();
            }
            return Ray3d;
        })();
        geometry.Ray3d = Ray3d;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (geometry) {
        function intersectPlane2dRay2d(pPlane, pRay) {
            var fDistance = pPlane.signedDistance(pRay.point);
            var fNdotV = pPlane.normal.dot(pRay.normal);
            if (fDistance == 0.) {
                return true;
            } else {
                if (fNdotV == 0.) {
                    return false;
                } else {
                    if (fDistance / fNdotV < 0.) {
                        return true;
                    } else {
                        return false;
                    }
                }
            }
        }
        geometry.intersectPlane2dRay2d = intersectPlane2dRay2d;
        ;
        function intersectPlane3dRay3d(pPlane, pRay) {
            var fDistance = pPlane.signedDistance(pRay.point);
            var fNdotV = pPlane.normal.dot(pRay.normal);
            if (fDistance == 0.) {
                return true;
            } else {
                if (fNdotV == 0.) {
                    return false;
                } else {
                    if (fDistance / fNdotV < 0.) {
                        return true;
                    } else {
                        return false;
                    }
                }
            }
        }
        geometry.intersectPlane3dRay3d = intersectPlane3dRay3d;
        ;
        function intersectCircleRay2d(pCircle, pRay) {
            var v2fCenterToPoint = pRay.point.subtract(pCircle.center, akra.Vec2.stackCeil.set());
            var v2fNormal = pRay.normal;
            //a*t^2+ 2b*t + c = 0;
            var fA = v2fNormal.lengthSquare();
            var fB = v2fCenterToPoint.dot(v2fNormal);
            var fC = v2fCenterToPoint.lengthSquare() - pCircle.radius * pCircle.radius;
            /*b^2/4 - a*c*/
            var fDiscriminant = fB * fB - fA * fC;
            if (fDiscriminant < 0.) {
                return false;
            }
            var fSqrtDiscriminant = akra.math.sqrt(fDiscriminant);
            var fT1 = (-fB + fSqrtDiscriminant) / fA;
            //var fT2: float = (-fB - fSqrtDiscriminant)/fA;
            //fT2 don't needed because fT2 < fT1 always
            //since fA > 0
            if (fT1 < 0.) {
                return false;
            } else {
                return true;
            }
        }
        geometry.intersectCircleRay2d = intersectCircleRay2d;
        ;
        function intersectSphereRay3d(pSphere, pRay) {
            var v3fCenterToPoint = pRay.point.subtract(pSphere.center, akra.Vec3.stackCeil.set());
            var v3fNormal = pRay.normal;
            //a*t^2+ 2b*t + c = 0;
            var fA = v3fNormal.lengthSquare();
            var fB = v3fCenterToPoint.dot(v3fNormal);
            var fC = v3fCenterToPoint.lengthSquare() - pSphere.radius * pSphere.radius;
            /*b^2/4 - a*c*/
            var fDiscriminant = fB * fB - fA * fC;
            if (fDiscriminant < 0.) {
                return false;
            }
            var fSqrtDiscriminant = akra.math.sqrt(fDiscriminant);
            var fT1 = (-fB + fSqrtDiscriminant) / fA;
            //var fT2: float = (-fB - fSqrtDiscriminant)/fA;
            //fT2 don't needed because fT2 < fT1 always
            //since fA > 0
            if (fT1 < 0.) {
                return false;
            } else {
                return true;
            }
        }
        geometry.intersectSphereRay3d = intersectSphereRay3d;
        ;
        function intersectRect2dRay2d(pRect, pRay) {
            var v2fNormal = pRay.normal;
            var v2fPoint = pRay.point;
            var fT1, fT2;
            var fX1, fX2;
            var fY1, fY2;
            if (v2fNormal.x != 0.) {
                fT1 = (pRect.x0 - v2fPoint.x) / v2fNormal.x;
                fT2 = (pRect.x1 - v2fPoint.x) / v2fNormal.x;
            } else {
                fT1 = (pRect.y0 - v2fPoint.y) / v2fNormal.y;
                fT2 = (pRect.y1 - v2fPoint.y) / v2fNormal.y;
            }
            if (fT1 < 0 && fT2 < 0) {
                return false;
            }
            fT1 = akra.math.max(fT1, 0.);
            fT2 = akra.math.max(fT2, 0.);
            fX1 = v2fPoint.x + fT1 * v2fNormal.x;
            fX2 = v2fPoint.x + fT2 * v2fNormal.x;
            fY1 = v2fPoint.y + fT1 * v2fNormal.y;
            fY2 = v2fPoint.y + fT2 * v2fNormal.y;
            if ((fX1 < pRect.x0 && fX2 < pRect.x0) || (fX1 > pRect.x1 && fX2 > pRect.x1) || (fY1 < pRect.y0 && fY2 < pRect.y0) || (fY1 > pRect.y1 && fY2 > pRect.y1)) {
                return false;
            }
            return true;
        }
        geometry.intersectRect2dRay2d = intersectRect2dRay2d;
        ;
        function intersectRect3dRay3d(pRect, pRay) {
            var v3fNormal = pRay.normal;
            var v3fPoint = pRay.point;
            var fT1, fT2;
            var fX1, fX2;
            var fY1, fY2;
            var fZ1, fZ2;
            if (v3fNormal.x != 0.) {
                fT1 = (pRect.x0 - v3fPoint.x) / v3fNormal.x;
                fT2 = (pRect.x1 - v3fPoint.x) / v3fNormal.x;
            } else if (v3fNormal.y != 0.) {
                fT1 = (pRect.y0 - v3fPoint.y) / v3fNormal.y;
                fT2 = (pRect.y1 - v3fPoint.y) / v3fNormal.y;
            } else {
                fT1 = (pRect.z0 - v3fPoint.z) / v3fNormal.z;
                fT2 = (pRect.z1 - v3fPoint.z) / v3fNormal.z;
            }
            if (fT1 < 0 && fT2 < 0) {
                return false;
            }
            fT1 = akra.math.max(fT1, 0.);
            fT2 = akra.math.max(fT2, 0.);
            fX1 = v3fPoint.x + fT1 * v3fNormal.x;
            fX2 = v3fPoint.x + fT2 * v3fNormal.x;
            fY1 = v3fPoint.y + fT1 * v3fNormal.y;
            fY2 = v3fPoint.y + fT2 * v3fNormal.y;
            fZ1 = v3fPoint.z + fT1 * v3fNormal.z;
            fZ2 = v3fPoint.z + fT2 * v3fNormal.z;
            if ((fX1 < pRect.x0 && fX2 < pRect.x0) || (fX1 > pRect.x1 && fX2 > pRect.x1) || (fY1 < pRect.y0 && fY2 < pRect.y0) || (fY1 > pRect.y1 && fY2 > pRect.y1) || (fZ1 < pRect.z0 && fZ2 < pRect.z0) || (fZ1 > pRect.z1 && fZ2 > pRect.z1)) {
                return false;
            }
            return true;
        }
        geometry.intersectRect3dRay3d = intersectRect3dRay3d;
        ;
        function intersectCircleCircle(pCircle1, pCircle2) {
            var v2fCenter1 = pCircle1.center;
            var v2fCenter2 = pCircle2.center;
            var fX = v2fCenter2.x - v2fCenter1.x;
            var fY = v2fCenter2.y - v2fCenter1.y;
            var fContactRadius = pCircle1.radius + pCircle2.radius;
            if ((fX * fX + fY * fY) > fContactRadius * fContactRadius) {
                return false;
            }
            return true;
        }
        geometry.intersectCircleCircle = intersectCircleCircle;
        ;
        function intersectSphereSphere(pSphere1, pSphere2) {
            var v3fCenter1 = pSphere1.center;
            var v3fCenter2 = pSphere2.center;
            var fX = v3fCenter2.x - v3fCenter1.x;
            var fY = v3fCenter2.y - v3fCenter1.y;
            var fZ = v3fCenter2.z - v3fCenter1.z;
            var fContactRadius = pSphere1.radius + pSphere2.radius;
            if ((fX * fX + fY * fY + fZ * fZ) > fContactRadius * fContactRadius) {
                return false;
            }
            return true;
        }
        geometry.intersectSphereSphere = intersectSphereSphere;
        ;
        function intersectRect2dCircle(pRect, pCircle) {
            var v2fCenter = pCircle.center;
            var fOffsetX = 0., fOffsetY = 0.;
            var nInside = 0;
            if (v2fCenter.x < pRect.x0) {
                fOffsetX = pRect.x0 - v2fCenter.x;
            } else if (v2fCenter.x > pRect.x1) {
                fOffsetX = v2fCenter.x - pRect.x1;
            } else {
                nInside++;
            }
            if (v2fCenter.y < pRect.y0) {
                fOffsetY = pRect.y0 - v2fCenter.y;
            } else if (v2fCenter.y > pRect.y1) {
                fOffsetY = v2fCenter.y - pRect.y1;
            } else {
                nInside++;
            }
            //if nInside == 2 then circle inside rect
            if (nInside === 2) {
                return true;
            }
            var fOffsetLengthSquare = fOffsetX * fOffsetX + fOffsetY * fOffsetY;
            var fRadius = pCircle.radius;
            if (fOffsetLengthSquare > fRadius * fRadius) {
                return false;
            }
            return true;
        }
        geometry.intersectRect2dCircle = intersectRect2dCircle;
        ;
        function intersectRect3dSphere(pRect, pSphere) {
            var v3fCenter = pSphere.center;
            var fOffsetX = 0., fOffsetY = 0., fOffsetZ = 0.;
            var nInside = 0;
            if (v3fCenter.x < pRect.x0) {
                fOffsetX = pRect.x0 - v3fCenter.x;
            } else if (v3fCenter.x > pRect.x1) {
                fOffsetX = v3fCenter.x - pRect.x1;
            } else {
                nInside++;
            }
            if (v3fCenter.y < pRect.y0) {
                fOffsetY = pRect.y0 - v3fCenter.y;
            } else if (v3fCenter.y > pRect.y1) {
                fOffsetY = v3fCenter.y - pRect.y1;
            } else {
                nInside++;
            }
            if (v3fCenter.z < pRect.z0) {
                fOffsetZ = pRect.z0 - v3fCenter.z;
            } else if (v3fCenter.z > pRect.z1) {
                fOffsetZ = v3fCenter.z - pRect.z1;
            } else {
                nInside++;
            }
            //if nInside == 3 then sphere inside rect
            if (nInside === 3) {
                return true;
            }
            var fOffsetLengthSquare = fOffsetX * fOffsetX + fOffsetY * fOffsetY + fOffsetZ * fOffsetZ;
            var fRadius = pSphere.radius;
            if (fOffsetLengthSquare > fRadius * fRadius) {
                return false;
            }
            return true;
        }
        geometry.intersectRect3dSphere = intersectRect3dSphere;
        ;
        function intersectRect2dRect2d(pRect1, pRect2, pResult) {
            if (!((pResult) !== undefined)) {
                var fX0 = akra.math.max(pRect1.x0, pRect2.x0);
                var fX1 = akra.math.min(pRect1.x1, pRect2.x1);
                if (fX0 <= fX1) {
                    var fY0 = akra.math.max(pRect1.y0, pRect2.y0);
                    var fY1 = akra.math.min(pRect1.y1, pRect2.y1);
                    if (fY0 <= fY1) {
                        return true;
                    }
                }
                return false;
            } else {
                pResult.x0 = akra.math.max(pRect1.x0, pRect2.x0);
                pResult.x1 = akra.math.min(pRect1.x1, pRect2.x1);
                pResult.y0 = akra.math.max(pRect1.y0, pRect2.y0);
                pResult.y1 = akra.math.min(pRect1.y1, pRect2.y1);
                return pResult.isValid();
            }
        }
        geometry.intersectRect2dRect2d = intersectRect2dRect2d;
        ;
        function intersectRect3dRect3d(pRect1, pRect2, pResult) {
            if (!((pResult) !== undefined)) {
                var fX0 = akra.math.max(pRect1.x0, pRect2.x0);
                var fX1 = akra.math.min(pRect1.x1, pRect2.x1);
                if (fX0 <= fX1) {
                    var fY0 = akra.math.max(pRect1.y0, pRect2.y0);
                    var fY1 = akra.math.min(pRect1.y1, pRect2.y1);
                    if (fY0 <= fY1) {
                        var fZ0 = akra.math.max(pRect1.z0, pRect2.z0);
                        var fZ1 = akra.math.min(pRect1.z1, pRect2.z1);
                        if (fZ0 <= fZ1) {
                            return true;
                        }
                    }
                }
                return false;
            } else {
                pResult.x0 = akra.math.max(pRect1.x0, pRect2.x0);
                pResult.x1 = akra.math.min(pRect1.x1, pRect2.x1);
                pResult.y0 = akra.math.max(pRect1.y0, pRect2.y0);
                pResult.y1 = akra.math.min(pRect1.y1, pRect2.y1);
                pResult.z0 = akra.math.max(pRect1.z0, pRect2.z0);
                pResult.z1 = akra.math.min(pRect1.z1, pRect2.z1);
                return pResult.isValid();
            }
        }
        geometry.intersectRect3dRect3d = intersectRect3dRect3d;
        ;
                                                                                                        function intersect(pRect1, pRect2, pResult) {
            var nArgumentsLength = arguments.length;
            if (nArgumentsLength === 3) {
                if (arguments[2] instanceof geometry.Rect2d) {
                    return intersectRect2dRect2d(arguments[0], arguments[1], arguments[2]);
                } else {
                    return intersectRect3dRect3d(arguments[0], arguments[1], arguments[2]);
                }
            } else {
                var pArg0 = arguments[0];
                var pArg1 = arguments[1];
                if (pArg1 instanceof geometry.Ray2d) {
                    if (pArg0 instanceof geometry.Plane2d) {
                        return intersectPlane2dRay2d(pArg0, pArg1);
                    } else if (pArg0 instanceof geometry.Circle) {
                        return intersectCircleRay2d(pArg0, pArg1);
                    } else {
                        return intersectRect2dRay2d(pArg0, pArg1);
                    }
                } else if (pArg1 instanceof geometry.Ray3d) {
                    if (pArg0 instanceof geometry.Plane3d) {
                        return intersectPlane3dRay3d(pArg0, pArg1);
                    } else if (pArg0 instanceof geometry.Sphere) {
                        return intersectSphereRay3d(pArg0, pArg1);
                    } else {
                        return intersectRect3dRay3d(pArg0, pArg1);
                    }
                } else if (pArg1 instanceof geometry.Circle) {
                    if (pArg0 instanceof geometry.Circle) {
                        return intersectCircleCircle(pArg0, pArg1);
                    } else {
                        return intersectRect2dCircle(pArg0, pArg1);
                    }
                } else if (pArg1 instanceof geometry.Sphere) {
                    if (pArg0 instanceof geometry.Sphere) {
                        return intersectSphereSphere(pArg0, pArg1);
                    } else {
                        return intersectRect3dSphere(pArg0, pArg1);
                    }
                } else {
                    if (pArg0 instanceof geometry.Rect2d) {
                        return intersectRect2dRect2d(pArg0, pArg1);
                    } else {
                        return intersectRect3dRect3d(pArg0, pArg1);
                    }
                }
            }
        }
        geometry.intersect = intersect;
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
;
var akra;
(function (akra) {
    (function (scene) {
        (function (EOcTreeConstants) {
            EOcTreeConstants._map = [];
            EOcTreeConstants.k_MinimumTreeDepth = 0;
            EOcTreeConstants.k_MaximumTreeDepth = 10;
        })(scene.EOcTreeConstants || (scene.EOcTreeConstants = {}));
        var EOcTreeConstants = scene.EOcTreeConstants;
        ;
        var OcTree = (function (_super) {
            __extends(OcTree, _super);
            /**
            * Список байтовых ректов ректа камеры для тестов объектов.
            */
            //protected _pTestLocalRect: IOcTreeRect[] = null;
            function OcTree() {
                        _super.call(this);
                /** List of OcTreeNodes on each level */
                //protected _ppLevelNodes: IOcTreeNode[][] = null;
                /** First node in list of all nodes */
                //protected _pFirstNode: IOcTreeNode = null;
                /**@protected*/ this._pHead = null;
                /** Size of world bounding box */
                /**@protected*/ this._v3fWorldExtents = new akra.Vec3();
                /** Negate min point of bounding box */
                /**@protected*/ this._v3fWorldScale = new akra.Vec3();
                /** Value of relation between (1024,1024,1024) and bounding box size */
                /**@protected*/ this._v3fWorldOffset = new akra.Vec3();
                /** Maximum depth of tree. Value set when you call OcTree::create() */
                /**@protected*/ this._iDepth = 0;
                //protected _iSize: int = 0;//2^iDepth;
                /**
                * Список свободных узлов(объектов OcTreeNode).
                * Необходимо для экономии ресурсов памяти и чтобы не делать лишних delete
                */
                /**@protected*/ this._pFreeNodePool = null;
                ((this)._sName = ("OcTree"));
            }
            Object.defineProperty(OcTree.prototype, "depth", {
                get: /** @inline */function () {
                    return this._iDepth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(OcTree.prototype, "worldScale", {
                get: /** @inline */function () {
                    return this._v3fWorldScale;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(OcTree.prototype, "worldOffset", {
                get: /** @inline */function () {
                    return this._v3fWorldOffset;
                },
                enumerable: true,
                configurable: true
            });
            OcTree.prototype.create = /**
            * Create
            */
            function (pWorldBoundingBox, iDepth, nNodes) {
                if (typeof nNodes === "undefined") { nNodes = 64; }
                var v3fTemp = akra.Vec3.stackCeil.set();
                var i = 0;
 {
                    akra.logger.setSourceLocation("OcTree.ts", 72);
                    akra.logger.assert(!this.isReady(), "the Oc tree has already been created");
                }
                ;
 {
                    akra.logger.setSourceLocation("OcTree.ts", 74);
                    akra.logger.assert(iDepth >= EOcTreeConstants.k_MinimumTreeDepth && iDepth <= EOcTreeConstants.k_MaximumTreeDepth, "invalid tree depth");
                }
                ;
                this._iDepth = iDepth;
                this._v3fWorldExtents.set(pWorldBoundingBox.size(v3fTemp));
                this._v3fWorldOffset.set(pWorldBoundingBox.minPoint(v3fTemp).negate());
                var iSize = 1 << iDepth;
                this._v3fWorldScale.x = iSize / this._v3fWorldExtents.x;
                this._v3fWorldScale.y = iSize / this._v3fWorldExtents.y;
                this._v3fWorldScale.z = iSize / this._v3fWorldExtents.z;
                // allocate the nodes
                // this._ppLevelNodes = new Array(iDepth);
                // for (i = 0; i < iDepth; ++i) {
                //     this._ppLevelNodes[i] = new Array();
                // }
                // this._pTestLocalRect = new Array(iDepth);
                // for (i = 0; i < iDepth; ++i) {
                //     this._pTestLocalRect[i] = new OcTreeRect;
                // }
                this._pHead = new scene.OcTreeRootNode(this);
                this._pHead.level = 0;
                this._pFreeNodePool = new Array();
                for(i = 0; i < nNodes; ++i) {
                    this._pFreeNodePool.push(new scene.OcTreeNode(this));
                }
            };
            OcTree.prototype.isReady = /**
            * is any levels of tree are availeable(some object in a tree)
            */
            function () {
                if (this._iDepth > 0) {
                    return true;
                } else {
                    return false;
                }
            };
            OcTree.prototype.findTreeNode = /**
            * find node
            */
            function (pObject) {
                var pRect = pObject.worldBounds;
                var iX0 = pRect.x0, iX1 = pRect.x1, iY0 = pRect.y0, iY1 = pRect.y1, iZ0 = pRect.z0, iZ1 = pRect.z1;
                var v3fWorldOffset = this._v3fWorldOffset;
                var v3fWorldScale = this._v3fWorldScale;
                iX0 += v3fWorldOffset.x;
                iX1 += v3fWorldOffset.x;
                iY0 += v3fWorldOffset.y;
                iY1 += v3fWorldOffset.y;
                iZ0 += v3fWorldOffset.z;
                iZ1 += v3fWorldOffset.z;
                iX0 *= v3fWorldScale.x;
                iX1 *= v3fWorldScale.x;
                iY0 *= v3fWorldScale.y;
                iY1 *= v3fWorldScale.y;
                iZ0 *= v3fWorldScale.z;
                iZ1 *= v3fWorldScale.z;
                //round it
                iX0 = akra.math.floor(iX0);
                iX1 = akra.math.ceil(iX1);
                iY0 = akra.math.floor(iY0);
                iY1 = akra.math.ceil(iY1);
                iZ0 = akra.math.floor(iZ0);
                iZ1 = akra.math.ceil(iZ1);
                iX1 = (iX1 === iX0) ? iX0 + 1 : iX1;
                iY1 = (iY1 === iY0) ? iY0 + 1 : iY1;
                iZ1 = (iZ1 === iZ0) ? iZ0 + 1 : iZ1;
                //var iMax1: int = 1 << this._iDepth - 2;
                //var iMax2: int = 1 << this._iDepth - 1;
                //iX0 = math.clamp(iX0, 0, iMax1);
                //iY0 = math.clamp(iY0, 0, iMax1);
                //iZ0 = math.clamp(iZ0, 0, iMax1);
                //iX1 = math.clamp(iX1, iX0 + 1, iMax2);
                //iY1 = math.clamp(iY1, iY0 + 1, iMax2);
                //iZ1 = math.clamp(iZ1, iZ0 + 1, iMax2);
                // LOG(pRect.toString());
                // if(pRect.x0 == 128 && pRect.x1 == 160 && pRect.y0 == 480 && pRect.y1 == 512){
                //     console.error(iX0, iX1, iY0, iY1, iZ0, iZ1);
                // }
                var pNode = this.findTreeNodeByRect(iX0, iX1, iY0, iY1, iZ0, iZ1);
                return pNode;
            };
            OcTree.prototype.findTreeNodeByRect = /**
            * Find tree node by Rect
            */
            function (iX0, iX1, iY0, iY1, iZ0, iZ1) {
                var nMax = (1 << this._iDepth);
                if (iX0 < 0 || iX1 > nMax || iY0 < 0 || iY1 > nMax || iZ0 < 0 || iZ1 > nMax) {
                    return this._pHead;
                }
                var iDepth = this._iDepth;
                var iLevel;
                ///////////////////////////
                iLevel = this._findNodeLevel(iX0, iX1, iY0, iY1, iZ0, iZ1);
                // console.warn(iLevel);
                ///////////////////////////
                if (iLevel == 0) {
                    return this._pHead;
                }
                var iComposedIndex;
                var iShift = iDepth - iLevel;
                iComposedIndex = (iX0 >> (iDepth - iLevel)) << (2 * iDepth + iShift);
                // console.log(iComposedIndex);
                iComposedIndex += (iY0 >> (iDepth - iLevel)) << (iDepth + iShift);
                // console.log(iComposedIndex);
                iComposedIndex += (iZ0 >> (iDepth - iLevel)) << (iShift);
                var iWay;
                var pParentNode, pNode;
                pParentNode = this._pHead;
                pNode = null;
                var iX, iY, iZ;
                var i = 0;
                while(i < iLevel) {
                    iX = (iX0 >> (iDepth - i - 1)) & 1;
                    iY = (iY0 >> (iDepth - i - 1)) & 1;
                    iZ = (iZ0 >> (iDepth - i - 1)) & 1;
                    iWay = 4 * iX + 2 * iY + iZ;
                    var pNodeList = pParentNode.childrenList[iWay];
                    if (pNodeList.length === 0) {
                        pNode = this.getAndSetFreeNode(iLevel, iComposedIndex, pParentNode);
                        pNodeList.push(pNode);
                        return pNode;
                    }
                    var iPosition = 0;
                    var pTestNode = pNodeList.first;
                    var iTestMask = (iDepth >= i + 2) ? 1 << (iDepth - i - 2) : 0;
                    var iMask = (iTestMask << (2 * iDepth)) + (iTestMask << iDepth) + iTestMask;
                    var pParentNodeOld = pParentNode;
                    while(((pTestNode) != null)) {
                        var iTestNodeIndex = pTestNode.index;
                        var iResult1 = iTestNodeIndex & iMask;
                        var iResult2 = iComposedIndex & iMask;
                        if (iResult1 === iResult2) {
                            if (pTestNode.level === iLevel && iTestNodeIndex == iComposedIndex) {
                                return pTestNode;
                            } else if (pTestNode.level < iLevel && this._parentTest(pTestNode.level, iTestNodeIndex, iComposedIndex)) {
                                pParentNode = pTestNode;
                                i = pTestNode.level;
                                break;
                            } else if (pTestNode.level > iLevel && this._parentTest(iLevel, iComposedIndex, iTestNodeIndex)) {
                                //alert("" + <string><any>pTestNode.level + "  " + <string><any>iLevel);
                                if (pNode === null) {
                                    pNode = this.getAndSetFreeNode(iLevel, iComposedIndex, pParentNode);
                                    pParentNode.childrenList[iWay].push(pNode);
                                    i = iLevel;
                                }
                                var iShift = iDepth - i - 1;
                                iX = (iTestNodeIndex >> (2 * iDepth + iShift)) & 1;
                                iY = (iTestNodeIndex >> (iDepth + iShift)) & 1;
                                iZ = (iTestNodeIndex >> iShift) & 1;
                                var iTestWay = 4 * iX + 2 * iY + iZ;
                                pNode.childrenList[iTestWay].push(pTestNode);
                                pTestNode.rearNodeLink = pNode;
                                pNodeList.takeAt(iPosition);
                                if (iPosition === 0) {
                                    pNodeList.seek(0);
                                    pTestNode = pNodeList.first;
                                    continue;
                                }
                                pNodeList.seek(iPosition - 1);
                                iPosition--;
                            }
                        }
                        pTestNode = pNodeList.next();
                        iPosition++;
                    }
                    if (pNode === null && pParentNodeOld === pParentNode) {
                        pNode = this.getAndSetFreeNode(iLevel, iComposedIndex, pParentNode);
                        pParentNode.childrenList[iWay].push(pNode);
                        break;
                    }
                }
                return pNode;
            };
            OcTree.prototype._parentTest = function (iLevel, iParentIndex, iChildIndex) {
                var iDepth = this._iDepth;
                var iTmp = (1 << iDepth) - (1 << (iDepth - iLevel));
                var iMask = (iTmp << (2 * iDepth)) + (iTmp << iDepth) + iTmp;
                if ((iParentIndex & iMask) == (iChildIndex & iMask)) {
                    return true;
                }
                return false;
            };
            OcTree.prototype._findNodeLevel = function (iX0, iX1, iY0, iY1, iZ0, iZ1) {
                var iLengthX = iX1 - iX0;
                var iLengthY = iY1 - iY0;
                var iLengthZ = iZ1 - iZ0;
                var iLength = akra.math.max(iLengthX, akra.math.max(iLengthY, iLengthZ));
                //maximum possible level
                var iLevel = this._iDepth - akra.math.floor(akra.math.log(iLength) / akra.math.LN2);
                while(iLevel > 0) {
                    var iPitch = 1 << (this._iDepth - iLevel);
                    var iTest1, iTest2;
                    //first test for x then for y and z
                    var i;
                    for(i = 0; i < 3; i++) {
                        iTest1 = akra.math.floor(arguments[2 * i] / iPitch);
                        iTest2 = akra.math.floor(arguments[2 * i + 1] / iPitch);
                        if (iTest1 != iTest2) {
                            if ((iTest1 + 1) == iTest2) {
                                if ((arguments[2 * i + 1] % iPitch) != 0) {
                                    break;
                                }
                            } else {
                                break;
                            }
                        }
                    }
                    if (i != 3) {
                        iLevel--;
                    } else {
                        break;
                    }
                }
                return iLevel;
            };
            OcTree.prototype.getAndSetFreeNode = /**
            * Get free node.
            * Get it from _pFreeNodePull or create new OcTreeNode if it`s empty and set his data.
            */
            function (iLevel, iComposedIndex, pParentNode) {
                var pNode = this._pFreeNodePool.pop();
                if (!((pNode) != null)) {
                    pNode = new scene.OcTreeNode(this);
                }
                var iDepth = this._iDepth;
                var iMask = (1 << this._iDepth) - 1;
                var iIndexX = (iComposedIndex >> (2 * iDepth)) & iMask;
                var iIndexY = (iComposedIndex >> (iDepth)) & iMask;
                var iIndexZ = iComposedIndex & iMask;
                var iSize = 1 << (this._iDepth - iLevel);
                pNode.level = iLevel;
                // pNode.x = iX;
                // pNode.y = iY;
                // pNode.z = iZ;
                pNode.index = iComposedIndex;
                pNode.rearNodeLink = pParentNode;
                pNode.worldBounds.set(iIndexX, iIndexX + iSize, iIndexY, iIndexY + iSize, iIndexZ, iIndexZ + iSize);
                pNode.worldBounds.divSelf(this._v3fWorldScale);
                pNode.worldBounds.subSelf(this._v3fWorldOffset);
                return pNode;
            };
            OcTree.prototype.deleteNodeFromTree = /**
            * Delete node from tree
            */
            function (pNode) {
                var pParentNode = pNode.rearNodeLink;
 {
                    akra.logger.setSourceLocation("OcTree.ts", 390);
                    akra.logger.assert(pNode.membersList.length == 0, "list members of node don't empty");
                }
                ;
                var iDepth = this._iDepth;
                var iParentLevel = pParentNode.level;
                var iIndex = pNode.index;
                var iShift = iDepth - iParentLevel - 1;
                var iX = (iIndex >> (2 * iDepth + iShift)) & 1;
                var iY = (iIndex >> (iDepth + iShift)) & 1;
                var iZ = (iIndex >> iShift) & 1;
                var iWay = 4 * iX + 2 * iY + iZ;
                var pParentBranch = pParentNode.childrenList[iWay];
                //console.log('iWay ------------>', iWay);
                var iNode = pParentBranch.indexOf(pNode);
 {
                    akra.logger.setSourceLocation("OcTree.ts", 409);
                    akra.logger.assert(iNode != -1, "can't remove node from parent, node not found");
                }
                ;
                //deleting node from parent list
                pParentBranch.takeAt(iNode);
                for(var i = 0; i < 8; i++) {
                    var pChildrens = pNode.childrenList[i];
                    while(pChildrens.length > 0) {
                        var pChildNode = pChildrens.pop();
                        pChildNode.rearNodeLink = pParentNode;
                        pParentBranch.push(pChildNode);
                    }
                }
                pNode.level = 0;
                pNode.rearNodeLink = null;
                pNode.worldBounds.clear();
                this._pFreeNodePool.push(pNode);
            };
            OcTree.prototype._findObjects = function (pCamera, pResultArray, bFastSearch) {
                if (typeof pResultArray === "undefined") { pResultArray = new akra.util.ObjectArray(); }
                if (typeof bFastSearch === "undefined") { bFastSearch = false; }
                //while we ignore second parametr
                //don't have normal implementation
                pResultArray.clear();
                if (!((pCamera.frustum) !== undefined)) {
                    this._buildSearchResultsByRect(pCamera.searchRect, this._pHead, pResultArray);
                } else {
                    this._buildSearchResultsByRectAndFrustum(pCamera.searchRect, pCamera.frustum, this._pHead, pResultArray);
                }
                return pResultArray;
            };
            OcTree.prototype._buildSearchResultsByRect = /**@protected*/ function (pSearchRect, pNode, pResultList) {
                var pNodeRect = pNode.worldBounds;
                var kResult = akra.geometry.classifyRect3d(pSearchRect, pNodeRect);
                if (kResult == akra.EVolumeClassifications.B_CONTAINS_A || kResult == akra.EVolumeClassifications.INTERSECTING) {
                    //надо проводить дополнительные тесты
                    var pMemberList = pNode.membersList;
                    var pObject = pMemberList.first;
                    while(((pObject) != null)) {
                        if (akra.geometry.intersectRect3dRect3d(pSearchRect, pObject.worldBounds)) {
                            pResultList.push(pObject);
                        }
                        pObject = pMemberList.next();
                    }
                    for(var i = 0; i < 8; i++) {
                        var pChildrenList = pNode.childrenList[i];
                        var pChildNode = pChildrenList.first;
                        while(((pChildNode) != null)) {
                            this._buildSearchResultsByRect(pSearchRect, pChildNode, pResultList);
                            pChildNode = pChildrenList.next();
                        }
                    }
                } else if (kResult != akra.EVolumeClassifications.NO_RELATION) {
                    //объект полностью попал
                    this._includeAllTreeSubbranch(pNode, pResultList);
                }
            };
            OcTree.prototype._buildSearchResultsByRectAndFrustum = /**@protected*/ function (pSearchRect, pFrustum, pNode, pResultList) {
                var pNodeRect = pNode.worldBounds;
                //var pChildRect: IRect3d;
                if (akra.geometry.intersectRect3dRect3d(pSearchRect, pNodeRect)) {
                    var kTestResult = akra.geometry.classifyFrustumRect3d(pFrustum, pNodeRect);
                    if (kTestResult == akra.EVolumeClassifications.A_CONTAINS_B) {
                        //объект полностью попал
                        this._includeAllTreeSubbranch(pNode, pResultList);
                    } else if (kTestResult == akra.EVolumeClassifications.INTERSECTING) {
                        //объект попал частично
                        var pMemberList = pNode.membersList;
                        var pObject = pMemberList.first;
                        while(((pObject) != null)) {
                            if (pFrustum.testRect(pObject.worldBounds)) {
                                pResultList.push(pObject);
                            }
                            pObject = pMemberList.next();
                        }
                        for(var i = 0; i < 8; i++) {
                            //TODO: test by child rect
                            var pChildrenList = pNode.childrenList[i];
                            var pChildNode = pChildrenList.first;
                            while(((pChildNode) != null)) {
                                this._buildSearchResultsByRectAndFrustum(pSearchRect, pFrustum, pChildNode, pResultList);
                                pChildNode = pChildrenList.next();
                            }
                        }
                    }
                }
            };
            OcTree.prototype._includeAllTreeSubbranch = /**@protected*/ function (pNode, pResultList) {
                //console.warn("----------------> including all subbranch <------------------");
                var pMemberList = pNode.membersList;
                var pObject = pMemberList.first;
                while(((pObject) != null)) {
                    pResultList.push(pObject);
                    pObject = pMemberList.next();
                }
                for(var i = 0; i < 8; i++) {
                    var pChildrenList = pNode.childrenList[i];
                    var pChildNode = pChildrenList.first;
                    while(((pChildNode) != null)) {
                        this._includeAllTreeSubbranch(pChildNode, pResultList);
                        pChildNode = pChildrenList.next();
                    }
                }
            };
            OcTree.prototype.attachObject = /**@protected*/ function (pNode) {
                if (((pNode).type >= /*checked (origin: akra)>>*/akra.EEntityTypes.SCENE_OBJECT && (pNode).type < /*checked (origin: akra)>>*/akra.EEntityTypes.OBJECTS_LIMIT)) {
                    var pOcTreeNode = this.findTreeNode(pNode);
                    pOcTreeNode.addMember(pNode);
                }
            };
            OcTree.prototype.detachObject = /**@protected*/ function (pNode) {
                if (((pNode).type >= /*checked (origin: akra)>>*/akra.EEntityTypes.SCENE_OBJECT && (pNode).type < /*checked (origin: akra)>>*/akra.EEntityTypes.OBJECTS_LIMIT)) {
                    var pOcTreeNode = this.findTreeNode(pNode);
                    pOcTreeNode.removeMember(pNode);
                }
            };
            OcTree.prototype._toSimpleObject = function (pNode) {
                if (typeof pNode === "undefined") { pNode = this._pHead; }
                var pResult = {};
                pResult.members = [];
                pResult.childrens = new Array(8);
                for(var i = 0; i < 8; i++) {
                    pResult.childrens[i] = [];
                }
                pResult.level = pNode.level;
                pResult.index = pNode.index;
                pResult.worldBounds = pNode.worldBounds.toString();
                var pMemberList = pNode.membersList;
                var pObject = pMemberList.first;
                while(((pObject) != null)) {
                    pResult.members.push(pObject.worldBounds.toString());
                    pObject = pMemberList.next();
                }
                for(var i = 0; i < 8; i++) {
                    var pList = pNode.childrenList[i];
                    var pChildNode = pList.first;
                    while(((pChildNode) != null)) {
                        pResult.childrens[i].push(this._toSimpleObject(pChildNode));
                        pChildNode = pList.next();
                    }
                }
                return pResult;
            };
            return OcTree;
        })(scene.DisplayList);
        scene.OcTree = OcTree;        
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
;
var akra;
(function (akra) {
    (function (scene) {
        (function (light) {
            var LightPoint = (function (_super) {
                __extends(LightPoint, _super);
                function LightPoint(pScene, eType) {
                    if (typeof eType === "undefined") { eType = akra.ELightTypes.UNKNOWN; }
                                _super.call(this, pScene, akra.EEntityTypes.LIGHT);
                    /**@protected*/ this._isShadowCaster = false;
                    /**@protected*/ this._isEnabled = true;
                    /**@protected*/ this._iMaxShadowResolution = 256;
                    //optimized camera frustum for better shadow casting
                    /**@protected*/ this._pOptimizedCameraFrustum = new akra.geometry.Frustum();
                    this._eLightType = eType;
                }
                Object.defineProperty(LightPoint.prototype, "lightType", {
                    get: /** @inline */function () {
                        return this._eLightType;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LightPoint.prototype, "enabled", {
                    get: /** @inline */function () {
                        return this._isEnabled;
                    },
                    set: /** @inline */function (bValue) {
                        this._isEnabled = bValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LightPoint.prototype, "params", {
                    get: /** @inline */function () {
                        // return this._pLightParameters;
                        return null;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LightPoint.prototype, "isShadowCaster", {
                    get: /** @inline */function () {
                        return this._isShadowCaster;
                    },
                    set: /** @inline */function (bValue) {
                        this._isShadowCaster = bValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LightPoint.prototype, "optimizedCameraFrustum", {
                    get: /** @inline */function () {
                        return this._pOptimizedCameraFrustum;
                    },
                    enumerable: true,
                    configurable: true
                });
                LightPoint.prototype.create = function (isShadowCaster, iMaxShadowResolution) {
                    if (typeof isShadowCaster === "undefined") { isShadowCaster = true; }
                    if (typeof iMaxShadowResolution === "undefined") { iMaxShadowResolution = 256; }
                    var isOk = _super.prototype.create.call(this);
                    //есть тени от источника или нет
                    this._isShadowCaster = isShadowCaster;
                    //мкасимальный размер shadow текстуры
                    this._iMaxShadowResolution = iMaxShadowResolution;
                    return isOk;
                };
                LightPoint.prototype._prepareForLighting = function (pCamera) {
 {
                        akra.logger.setSourceLocation("light/LightPoint.ts", 67);
                        akra.logger.warning("pure virtual method");
                    }
                    ;
                    return false;
                };
                LightPoint.prototype._calculateShadows = function () {
 {
                        akra.logger.setSourceLocation("light/LightPoint.ts", 72);
                        akra.logger.log(("\n" + (new Error()).stack.split("\n").slice(1).join("\n")));
                    }
                    ;
 {
                        akra.logger.setSourceLocation("light/LightPoint.ts", 73);
                        akra.logger.criticalError("NOT IMPLEMENTED!");
                    }
                    ;
                };
                return LightPoint;
            })(scene.SceneNode);
            light.LightPoint = LightPoint;            
            function isLightPoint(pNode) {
                return pNode.type === akra.EEntityTypes.LIGHT;
            }
            light.isLightPoint = isLightPoint;
        })(scene.light || (scene.light = {}));
        var light = scene.light;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        var LightGraph = (function (_super) {
            __extends(LightGraph, _super);
            function LightGraph() {
                        _super.call(this);
                /**@protected*/ this._pLightPoints = new akra.util.ObjectList();
                ((this)._sName = ("LightGraph"));
            }
            LightGraph.prototype._findObjects = function (pCamera, pResultArray, bFastSearch) {
                if (typeof pResultArray === "undefined") { pResultArray = new akra.util.ObjectArray(); }
                if (typeof bFastSearch === "undefined") { bFastSearch = false; }
                //while we ignore second parametr
                //don't have normal implementation
                pResultArray.clear();
                var pList = this._pLightPoints;
                var pLightPoint = pList.first;
                while(((pLightPoint) != null)) {
                    if (pLightPoint._prepareForLighting(pCamera)) {
                        // LOG("light point added");
                        pResultArray.push(pLightPoint);
                    }
                    pLightPoint = pList.next();
                }
                return pResultArray;
            };
            LightGraph.prototype.attachObject = /**@protected*/ function (pNode) {
                if (scene.light.isLightPoint(pNode)) {
                    this._pLightPoints.push(pNode);
                }
            };
            LightGraph.prototype.detachObject = /**@protected*/ function (pNode) {
                if (scene.light.isLightPoint(pNode)) {
                    var iPosition = this._pLightPoints.indexOf(pNode);
                    if (iPosition != -1) {
                        this._pLightPoints.takeAt(iPosition);
                    } else {
 {
                            akra.logger.setSourceLocation("LightGraph.ts", 58);
                            akra.logger.assert(false, "cannot find light point");
                        }
                        ;
                    }
                }
            };
            return LightGraph;
        })(scene.DisplayList);
        scene.LightGraph = LightGraph;        
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (model) {
        var Skin = (function () {
            function Skin(pMesh) {
                this._pSkeleton = null;
                // name of bones/nodes
                this._pNodeNames = null;
                //bind matrix from collada
                this._m4fBindMatrix = new akra.Mat4(1);
                //BONE_MATRIX = WORLD_MATRIX x OFFSET_MATRIX
                this._pBoneTransformMatrices = null;
                /**
                * Common buffer for all transform matrices.
                * _pBoneOffsetMatrixBuffer = [_pBoneTransformMatrices[0], ..., _pBoneTransformMatrices[N]]
                */
                this._pBoneOffsetMatrixBuffer = null;
                // bone offset matrices from collada
                this._pBoneOffsetMatrices = null;
                /**
                * Pointers to nodes, that affect to this skin.
                */
                this._pAffectingNodes = null;
                /**
                * Format:
                * BONE_INF_COUNT - number of bones, that influence to the vertex.
                * BONE_INF_LOC - address of influence, pointer to InfData structire list.
                * ..., [BONE_INF_COUNT: float, BONE_INF_LOC: float], ...
                *
                */
                this._pInfMetaData = null;
                /**
                * Format:
                * BONE_INF_DATA - bone matrix address, pointer to BONE_MATRIX list
                * BONE_WEIGHT - bone weight
                * ..., [BONE_INF_DATA: float, BONE_WEIGHT: float], ...
                */
                this._pInfData = null;
                /**
                * Format:
                * ..., [BONE_MATRIX: matrix4], ...
                */
                this._pBoneTransformMatrixData = null;
                this._pWeights = null;
                /**
                * Links to VertexData, that contain meta from this skin.
                */
                this._pTiedData = [];
 {
                    akra.logger.setSourceLocation("Skin.ts", 101);
                    akra.logger.assert(((pMesh) != null), "you must specify mesh for skin");
                }
                ;
                this._pMesh = pMesh;
            }
            Object.defineProperty(Skin.prototype, "data", {
                get: /** @inline */function () {
                    return this._pMesh.data;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Skin.prototype, "skeleton", {
                get: /** @inline */function () {
                    return this._pSkeleton;
                },
                set: /** @inline */function (pSkeleton) {
                    if (((pSkeleton) === null) || pSkeleton.totalBones < ((this)._pNodeNames.length)) {
 {
                            akra.logger.setSourceLocation("Skin.ts", 83);
                            akra.logger.warning("cannnot set skeletonm because skeleton has to little bones");
                        }
                        ;
                        return;
                    }
                    for(var i = 0, nMatrices = ((this)._pNodeNames.length); i < nMatrices; i++) {
                        this._pAffectingNodes[i] = pSkeleton.findJoint(this._pNodeNames[i]);
 {
                            akra.logger.setSourceLocation("Skin.ts", 89);
                            akra.logger.assert(((this._pAffectingNodes[i]) != null), "joint<" + this._pNodeNames[i] + "> must exists...");
                        }
                        ;
                    }
                    this._pSkeleton = pSkeleton;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Skin.prototype, "totalBones", {
                get: /** @inline */function () {
                    return this._pNodeNames.length;
                },
                enumerable: true,
                configurable: true
            });
            Skin.prototype.setBindMatrix = function (m4fMatrix) {
                this._m4fBindMatrix.set(m4fMatrix);
            };
            Skin.prototype.getBindMatrix = function () {
                return this._m4fBindMatrix;
            };
            Skin.prototype.getBoneOffsetMatrices = function () {
                return this._pBoneOffsetMatrices;
            };
            Skin.prototype.getBoneOffsetMatrix = function (sBoneName) {
                var pBoneNames = this._pNodeNames;
                for(var i = 0; i < pBoneNames.length; i++) {
                    if (pBoneNames[i] === sBoneName) {
                        return this._pBoneOffsetMatrices[i];
                    }
                }
                ;
                return null;
            };
            Skin.prototype.setSkeleton = function (pSkeleton) {
                if (!pSkeleton || pSkeleton.totalBones < ((this)._pNodeNames.length)) {
 {
                        akra.logger.setSourceLocation("Skin.ts", 133);
                        akra.logger.warning("number of bones in skeleton (" + pSkeleton.totalBones + ") less then number of bones in skin (" + ((this)._pNodeNames.length) + ").");
                    }
                    ;
                    return false;
                }
                for(var i = 0, nMatrices = ((this)._pNodeNames.length); i < nMatrices; i++) {
                    this._pAffectingNodes[i] = pSkeleton.findJoint(this._pNodeNames[i]);
 {
                        akra.logger.setSourceLocation("Skin.ts", 139);
                        akra.logger.assert(!((this._pAffectingNodes[i]) === null), "joint<" + this._pNodeNames[i] + "> must exists...");
                    }
                    ;
                }
                this._pSkeleton = pSkeleton;
                return true;
            };
            Skin.prototype.attachToScene = function (pRootNode) {
                for(var i = 0, nMatrices = ((this)._pNodeNames.length); i < nMatrices; i++) {
                    this._pAffectingNodes[i] = pRootNode.findEntity(this._pNodeNames[i]);
 {
                        akra.logger.setSourceLocation("Skin.ts", 150);
                        akra.logger.assert(((this._pAffectingNodes[i]) != null), "node<" + this._pNodeNames[i] + "> must exists...");
                    }
                    ;
                }
                return true;
            };
            Skin.prototype.setBoneNames = function (pNames) {
                if (((pNames) === null)) {
                    return false;
                }
                this._pNodeNames = pNames;
                this._pAffectingNodes = new Array(pNames.length);
                return true;
            };
            Skin.prototype.setBoneOffsetMatrices = function (pMatrices) {
                var pMatrixNames = this._pNodeNames;
 {
                    akra.logger.setSourceLocation("Skin.ts", 173);
                    akra.logger.assert(((pMatrices) != null) && ((pMatrixNames) != null) && pMatrixNames.length === pMatrices.length, "number of matrix names must equal matrices data length:\n" + pMatrixNames.length + " / " + pMatrices.length);
                }
                ;
                var nMatrices = pMatrixNames.length;
                var pData = ((this)._pMesh.data);
                var pMatrixData = new Float32Array(nMatrices * 16);
                //FIXME: правильно положить матрицы...
                this._pBoneOffsetMatrices = pMatrices;
                this._pBoneTransformMatrixData = pData._allocateData([
                    (({
count: (16),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("BONE_MATRIX")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                ], pMatrixData);
                this._pBoneTransformMatrices = new Array(nMatrices);
                for(var i = 0; i < nMatrices; i++) {
                    this._pBoneTransformMatrices[i] = new akra.Mat4(pMatrixData.subarray(i * 16, (i + 1) * 16), true);
                }
                this._pBoneOffsetMatrixBuffer = pMatrixData;
            };
            Skin.prototype.setWeights = function (pWeights) {
                this._pWeights = pWeights;
                return true;
            };
            Skin.prototype.getInfluenceMetaData = function () {
                return this._pInfMetaData;
            };
            Skin.prototype.getInfluences = function () {
                return this._pInfData;
            };
            Skin.prototype.setInfluences = function (pInfluencesCount, pInfluences) {
 {
                    akra.logger.setSourceLocation("Skin.ts", 206);
                    akra.logger.assert(this._pInfMetaData == null && this._pInfData == null, "vertex weights already setuped.");
                }
                ;
 {
                    akra.logger.setSourceLocation("Skin.ts", 207);
                    akra.logger.assert(!((this._pWeights) === null), "you must set weight data before setup influences");
                }
                ;
                var pData = ((this)._pMesh.data);
                var pInfluencesMeta = new Float32Array(pInfluencesCount.length * 2);
                var pWeights = this._pWeights;
                var iInfLoc = 0;
                var iTransformLoc = 0;
                //получаем копию массива влияний
                pInfluences = new Float32Array(pInfluences);
                //вычисляем адресса матриц транфсормации и весов
                iTransformLoc = this._pBoneTransformMatrixData.byteOffset / akra.EDataTypeSizes.BYTES_PER_FLOAT;
                for(var i = 0, n = pInfluences.length; i < n; i += 2) {
                    pInfluences[i] = pInfluences[i] * 16 + iTransformLoc;
                    pInfluences[i + 1] = pWeights[pInfluences[i + 1]];
                }
                //запоминаем модифицированную информацию о влияниях
                this._pInfData = pData._allocateData([
                    /*адрес матрицы кости*/
                    (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (('BONE_INF_DATA')),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
})), 
                    /*весовой коэффициент*/
                    (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (('BONE_WEIGHT')),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                ], pInfluences);
                iInfLoc = this._pInfData.byteOffset / akra.EDataTypeSizes.BYTES_PER_FLOAT;
                //подсчет мета данных, которые укажут, где взять влияния на кость..
                for(var i = 0, j = 0, n = iInfLoc; i < pInfluencesMeta.length; i += 2) {
                    var iCount = pInfluencesCount[j++];
                    /*число влияний на вершину*/
                    pInfluencesMeta[i] = iCount;
                    /*адрес начала информации о влияниях */
                    pInfluencesMeta[i + 1] = n;
                    //(пары индекс коэф. веса и индекс матрицы)
                    n += 2 * iCount;
                }
                //influences meta: разметка влияний
                this._pInfMetaData = pData._allocateData([
                    /*число костей и весов, влияющих на вершину*/
                    (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (('BONE_INF_COUNT')),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
})), 
                    /*адресс начала влияний на вершину*/
                    (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (('BONE_INF_LOC')),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
})), 
                    
                ], pInfluencesMeta);
                return this._pInfMetaData !== null && this._pInfData !== null;
            };
            Skin.prototype.setVertexWeights = function (pInfluencesCount, pInfluences, pWeights) {
 {
                    akra.logger.setSourceLocation("Skin.ts", 257);
                    akra.logger.assert(arguments.length > 1, 'you must specify all parameters');
                }
                ;
                //загружаем веса
                if (pWeights) {
                    this.setWeights(pWeights);
                }
                return this.setInfluences(pInfluencesCount, pInfluences);
            };
            Skin.prototype.applyBoneMatrices = function (bForce) {
                if (typeof bForce === "undefined") { bForce = false; }
                var pData;
                var bResult;
                var pNode;
                var isUpdated = false;
                for(var i = 0, nMatrices = ((this)._pNodeNames.length); i < nMatrices; ++i) {
                    pNode = this._pAffectingNodes[i];
                    if (pNode.isWorldMatrixNew() || bForce) {
                        pNode.worldMatrix.multiply(this._pBoneOffsetMatrices[i], this._pBoneTransformMatrices[i]);
                        isUpdated = true;
                    }
                }
                if (isUpdated) {
                    pData = this._pBoneOffsetMatrixBuffer;
                    return this._pBoneTransformMatrixData.setData(pData, 0, pData.byteLength);
                }
                return false;
            };
            Skin.prototype.isReady = function () {
                return !(((this._pInfMetaData) === null) || ((this._pInfData) === null) || ((this._pWeights) === null) || ((this._pBoneOffsetMatrixBuffer) === null) || ((this._pBoneOffsetMatrices) === null) || ((this._pNodeNames) === null) || ((this._m4fBindMatrix) === null));
            };
            Skin.prototype.getBoneTransforms = function () {
                return this._pBoneTransformMatrixData;
            };
            Skin.prototype.isAffect = function (pData) {
                if (((pData) != null)) {
                    for(var i = 0; i < this._pTiedData.length; i++) {
                        if (this._pTiedData[i] === pData) {
                            return true;
                        }
                    }
                }
                return false;
            };
            Skin.prototype.attach = function (pData) {
 {
                    akra.logger.setSourceLocation("Skin.ts", 315);
                    akra.logger.assert(pData.stride === 16, "you cannot add skin to mesh with POSITION: {x, y, z}" + "\nyou need POSITION: {x, y, z, w}");
                }
                ;
                pData.getVertexDeclaration().append((({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclUsages.BLENDMETA)),
offset: ((12))
})));
                this._pTiedData.push(pData);
            };
            return Skin;
        })();
        model.Skin = Skin;        
        function createSkin(pMesh) {
            return new Skin(pMesh);
        }
        model.createSkin = createSkin;
    })(akra.model || (akra.model = {}));
    var model = akra.model;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (geometry) {
        var Segment2d = (function () {
            function Segment2d() {
                this.ray = new geometry.Ray2d();
                this.distance = 0.;
            }
            Object.defineProperty(Segment2d.prototype, "point", {
                get: function () {
                    return this.ray.point;
                },
                set: function (v2fPoint) {
                    this.ray.point.set(v2fPoint);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Segment2d.prototype, "normal", {
                get: function () {
                    return this.ray.normal;
                },
                set: function (v2fNormal) {
                    this.ray.normal.set(v2fNormal);
                },
                enumerable: true,
                configurable: true
            });
            return Segment2d;
        })();
        geometry.Segment2d = Segment2d;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (geometry) {
        var Segment3d = (function () {
            function Segment3d() {
                this.ray = new geometry.Ray3d();
                this.distance = 0.;
            }
            Object.defineProperty(Segment3d.prototype, "point", {
                get: function () {
                    return this.ray.point;
                },
                set: function (v3fPoint) {
                    this.ray.point.set(v3fPoint);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Segment3d.prototype, "normal", {
                get: function () {
                    return this.ray.normal;
                },
                set: function (v3fNormal) {
                    this.ray.normal.set(v3fNormal);
                },
                enumerable: true,
                configurable: true
            });
            return Segment3d;
        })();
        geometry.Segment3d = Segment3d;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (geometry) {
                                                                /**
        * Computes a coordinate-axis oriented bounding box.
        */
        function computeBoundingBox(pVertexData, pBoundingBox) {
            var fX0 = 0, fY0 = 0, fZ0 = 0, fX1 = 0, fY1 = 0, fZ1 = 0;
            var fTemp, pTempData;
            var i = 0;
            var pVertexDeclaration, pVertexElement, pData;
            var nStride, nCount;
            pVertexDeclaration = pVertexData.getVertexDeclaration();
            if (((pVertexDeclaration) === null)) {
                return false;
            }
            pVertexElement = pVertexDeclaration.findElement(akra.DeclUsages.POSITION, 3);
            if (((pVertexElement) === null)) {
                return false;
            }
            nCount = pVertexData.length;
            nStride = pVertexElement.size;
            pData = pVertexData.getData(pVertexElement.offset, pVertexElement.size);
            if (((pData) === null)) {
                return false;
            }
            pTempData = new Float32Array(pData, 0, 3);
            fX0 = fX1 = pTempData[0];
            fY0 = fY1 = pTempData[1];
            fZ0 = fZ1 = pTempData[2];
            for(i = nStride; i < nStride * nCount; i += nStride) {
                pTempData = new Float32Array(pData, i, 3);
                fTemp = pTempData[0];
                /*Min*/
                fX0 = fX0 > fTemp ? fTemp : fX0;
                /*Max*/
                fX1 = fX1 > fTemp ? fX1 : fTemp;
                fTemp = pTempData[1];
                /*Min*/
                fY0 = fY0 > fTemp ? fTemp : fY0;
                /*Max*/
                fY1 = fY1 > fTemp ? fY1 : fTemp;
                fTemp = pTempData[2];
                /*Min*/
                fZ0 = fZ0 > fTemp ? fTemp : fZ0;
                /*Max*/
                fZ1 = fZ1 > fTemp ? fZ1 : fTemp;
            }
            pBoundingBox.set(fX0, fX1, fY0, fY1, fZ0, fZ1);
            return true;
        }
        geometry.computeBoundingBox = computeBoundingBox;
        ;
        /** расчет данных для отрисовки бокса */
        function computeDataForCascadeBoundingBox(pBoundingBox, ppVertexes, ppIndexes, fMinSize) {
            if (typeof fMinSize === "undefined") { fMinSize = .25; }
            var pInd;
            var pPoints;
            var i, j, k;
            pPoints = new Array(8);
            for(i = 0; i < 8; i++) {
                pPoints[i] = new Array(4);
                for(j = 0; j < 4; j++) {
                    pPoints[i][j] = new akra.Vec3(0);
                }
            }
            //Выставление точек Rect3d
            pPoints[0][0].set([
                pBoundingBox.x0, 
                pBoundingBox.y0, 
                pBoundingBox.z0
            ]);
            pPoints[1][0].set([
                pBoundingBox.x0, 
                pBoundingBox.y1, 
                pBoundingBox.z0
            ]);
            pPoints[2][0].set([
                pBoundingBox.x0, 
                pBoundingBox.y0, 
                pBoundingBox.z1
            ]);
            pPoints[3][0].set([
                pBoundingBox.x0, 
                pBoundingBox.y1, 
                pBoundingBox.z1
            ]);
            pPoints[4][0].set([
                pBoundingBox.x1, 
                pBoundingBox.y0, 
                pBoundingBox.z0
            ]);
            pPoints[5][0].set([
                pBoundingBox.x1, 
                pBoundingBox.y1, 
                pBoundingBox.z0
            ]);
            pPoints[6][0].set([
                pBoundingBox.x1, 
                pBoundingBox.y0, 
                pBoundingBox.z1
            ]);
            pPoints[7][0].set([
                pBoundingBox.x1, 
                pBoundingBox.y1, 
                pBoundingBox.z1
            ]);
            var fTempFunc = function (pPoints, iPoint, iToPoint1, iToPoint2, iToPoint3) {
                for(var i = 0; i < 3; i++) {
                    pPoints[arguments[i + 2]][0].subtract(pPoints[iPoint][0], pPoints[iPoint][i + 1]);
                    if (pPoints[iPoint][i + 1].length() > fMinSize) {
                        pPoints[iPoint][i + 1].scale(0.1);
                    }
                    pPoints[iPoint][i + 1].add(pPoints[iPoint][0]);
                }
            };
            fTempFunc(pPoints, 0, 1, 2, 4);
            fTempFunc(pPoints, 1, 0, 3, 5);
            fTempFunc(pPoints, 2, 0, 3, 6);
            fTempFunc(pPoints, 3, 1, 2, 7);
            fTempFunc(pPoints, 4, 0, 5, 6);
            fTempFunc(pPoints, 5, 1, 4, 7);
            fTempFunc(pPoints, 6, 2, 4, 7);
            fTempFunc(pPoints, 7, 3, 5, 6);
            for(i = 0; i < 8; i++) {
                for(j = 0; j < 4; j++) {
                    ppVertexes[i * 12 + j * 3 + 0] = pPoints[i][j].x;
                    ppVertexes[i * 12 + j * 3 + 1] = pPoints[i][j].y;
                    ppVertexes[i * 12 + j * 3 + 2] = pPoints[i][j].z;
                }
            }
            pInd = [
                0, 
                1, 
                0, 
                2, 
                0, 
                3, 
                4, 
                5, 
                4, 
                6, 
                4, 
                7, 
                8, 
                9, 
                8, 
                10, 
                8, 
                11, 
                12, 
                13, 
                12, 
                14, 
                12, 
                15, 
                16, 
                17, 
                16, 
                18, 
                16, 
                19, 
                20, 
                21, 
                20, 
                22, 
                20, 
                23, 
                24, 
                25, 
                24, 
                26, 
                24, 
                27, 
                28, 
                29, 
                28, 
                30, 
                28, 
                31
            ];
            for(var i = 0; i < pInd.length; ++i) {
                ppIndexes[i] = pInd[i];
            }
            return true;
        }
        geometry.computeDataForCascadeBoundingBox = computeDataForCascadeBoundingBox;
        /** подсчет обобщающей сферы над двумя сферами */
        function computeGeneralizingSphere(pSphereA, pSphereB, pSphereDest) {
            if (!((pSphereDest) !== undefined)) {
                pSphereDest = pSphereA;
            }
            var fR1 = pSphereA.radius;
            var fR2 = pSphereB.radius;
            var v3fC1 = pSphereA.center;
            var v3fC2 = pSphereB.center;
            var v3fD = new akra.Vec3();
            v3fC1.subtract(v3fC2, v3fD);
            var fD = v3fD.length();
            if (fD < fR1 && fR1 > fR2) {
                pSphereDest.set(pSphereA);
                return false;
            }
            if (fD < fR2) {
                pSphereDest.set(pSphereB);
                return false;
            }
            var v3fN = new akra.Vec3();
            v3fD.normalize(v3fN);
            pSphereDest.radius = v3fD.add(v3fN.scale(fR1 + fR2)).length() / 2.0;
            var v3fTemp = v3fD;
            pSphereDest.center = v3fC1.add(v3fC2, v3fTemp).add(v3fN.scale((fR1 - fR2) / (fR1 + fR2))).scale(.5);
            return true;
        }
        geometry.computeGeneralizingSphere = computeGeneralizingSphere;
        /** расчет данных для отрисовки сферы */
        function computeDataForCascadeBoundingSphere(pBoundingSphere, ppVertexes, ppIndexes, fMinSize) {
            if (typeof fMinSize === "undefined") { fMinSize = 0.25; }
            var fTheta, fDelta, fAlpha;
            var nCount = 10;
            var i, j, k;
            fDelta = akra.math.TWO_PI / nCount;
            for(i = 0; i <= nCount / 2; i++) {
                fTheta = -akra.math.PI + (i * fDelta);
                for(j = 0; j <= nCount; j++) {
                    fAlpha = j * fDelta;
                    ppVertexes[(i * (nCount + 1) + j) * 3 + 0] = pBoundingSphere.center.x + pBoundingSphere.radius * akra.math.sin(fTheta) * akra.math.cos(fAlpha);
                    ppVertexes[(i * (nCount + 1) + j) * 3 + 1] = pBoundingSphere.center.y + pBoundingSphere.radius * akra.math.sin(fTheta) * akra.math.sin(fAlpha);
                    ppVertexes[(i * (nCount + 1) + j) * 3 + 2] = pBoundingSphere.center.z + pBoundingSphere.radius * akra.math.cos(fTheta);
                }
            }
            for(i = 0; i < nCount / 2; i++) {
                for(j = 0; j < nCount; j++) {
                    ppIndexes[(i * (nCount) + j) * 12 + 0] = i * (nCount + 1) + j;
                    ppIndexes[(i * (nCount) + j) * 12 + 1] = i * (nCount + 1) + j + 1;
                    ppIndexes[(i * (nCount) + j) * 12 + 2] = i * (nCount + 1) + j + 2 + nCount;
                    ppIndexes[(i * (nCount) + j) * 12 + 3] = i * (nCount + 1) + j;
                    ppIndexes[(i * (nCount) + j) * 12 + 4] = i * (nCount + 1) + j + 1;
                    ppIndexes[(i * (nCount) + j) * 12 + 5] = i * (nCount + 1) + j + 2 + nCount;
                    ppIndexes[(i * (nCount) + j) * 12 + 6] = i * (nCount + 1) + j;
                    ppIndexes[(i * (nCount) + j) * 12 + 7] = i * (nCount + 1) + j + 1 + nCount;
                    ppIndexes[(i * (nCount) + j) * 12 + 8] = i * (nCount + 1) + j + 2 + nCount;
                    ppIndexes[(i * (nCount) + j) * 12 + 9] = i * (nCount + 1) + j + 1 + nCount;
                    ppIndexes[(i * (nCount) + j) * 12 + 10] = i * (nCount + 1) + j + 2 + nCount;
                    ppIndexes[(i * (nCount) + j) * 12 + 11] = i * (nCount + 1) + j;
                }
            }
            return true;
        }
        geometry.computeDataForCascadeBoundingSphere = computeDataForCascadeBoundingSphere;
        /**
        * Computes a bounding sphere.
        * При использование быстрого вычисления, опционально можно получить баундинг бокс.
        */
        function computeBoundingSphere(pVertexData, pSphere, bFastMethod, pBoundingBox) {
            if (typeof bFastMethod === "undefined") { bFastMethod = true; }
            if (typeof pBoundingBox === "undefined") { pBoundingBox = null; }
            if (bFastMethod) {
                return computeBoundingSphereFast(pVertexData, pSphere, pBoundingBox);
            } else {
                return computeBoundingSphereMinimal(pVertexData, pSphere);
            }
        }
        geometry.computeBoundingSphere = computeBoundingSphere;
        /**
        * Computes a bounding sphere - not minimal. Also if it need compute dounding box
        */
        function computeBoundingSphereFast(pVertexData, pSphere, pBoundingBox) {
            if (typeof pBoundingBox === "undefined") { pBoundingBox = null; }
            var i;
            var pVertexDeclaration, pVertexElement;
            var nCount, nStride;
            var pData, pTempData;
            pVertexDeclaration = pVertexData.getVertexDeclaration();
            if (((pVertexDeclaration) === null)) {
                return false;
            }
            pVertexElement = pVertexDeclaration.findElement(akra.DeclUsages.POSITION, 3);
            if (((pVertexElement) === null)) {
                return false;
            }
            nCount = pVertexData.length;
            nStride = pVertexElement.size;
            pData = pVertexData.getData(pVertexElement.offset, pVertexElement.size);
            if (((pData) === null)) {
                return false;
            }
            if (((pBoundingBox) === null)) {
                pBoundingBox = geometry.Rect3d.stackCeil.set();
            }
            if (pBoundingBox.isClear()) {
                if (!computeBoundingBox(pVertexData, pBoundingBox)) {
                    return false;
                }
            }
            var fCenterX = (pBoundingBox.x0 + pBoundingBox.x1) / 2;
            var fCenterY = (pBoundingBox.y0 + pBoundingBox.y1) / 2;
            var fCenterZ = (pBoundingBox.z0 + pBoundingBox.z1) / 2;
            var fRadius = 0;
            var fDistance = 0;
            for(i = 0; i < nStride * nCount; i += nStride) {
                pTempData = new Float32Array(pData, i, 3);
                fDistance = (pTempData[0] - fCenterX) * (pTempData[0] - fCenterX) + (pTempData[1] - fCenterY) * (pTempData[1] - fCenterY) + (pTempData[2] - fCenterZ) * (pTempData[2] - fCenterZ);
                fRadius = fDistance > fRadius ? fDistance : fRadius;
            }
            pSphere.set(fCenterX, fCenterY, fCenterZ, akra.math.sqrt(fRadius));
            return true;
        }
        geometry.computeBoundingSphereFast = computeBoundingSphereFast;
        /**
        * Computes a bounding sphere - minimal.
        */
        function computeBoundingSphereMinimal(pVertexData, pSphere) {
            var i = 0, j = 0, k = 0;
            var points = [];
            var length = 0;
            var isAdd = false;
            var isNew = true;
            var fDiametr = 0;
            var fDistance = 0;
            var pVertexDeclaration, pVertexElement;
            var nCount, nStride;
            var pData, pTempData1, pTempData2;
            pVertexDeclaration = pVertexData.getVertexDeclaration();
            if (((pVertexData) === null)) {
                return false;
            }
            if (((pVertexDeclaration) === null)) {
                return false;
            }
            pVertexElement = pVertexDeclaration.findElement(akra.DeclUsages.POSITION, 3);
            if (((pVertexElement) === null)) {
                return false;
            }
            nCount = pVertexData.length;
            nStride = pVertexElement.size;
            pData = pVertexData.getData(pVertexElement.offset, pVertexElement.size);
            if (!pData) {
                return false;
            }
            for(i = 0; i < nStride * nCount; i += nStride) {
                isNew = true;
                isAdd = false;
                pTempData1 = new Float32Array(pData, i, 3);
                for(k = 0; k < points.length; k += 3) {
                    if (points[k] == pTempData1[0] && points[k + 1] == pTempData1[1] && points[k + 2] == pTempData1[2]) {
                        isNew = false;
                        break;
                    }
                }
                if (isNew) {
                    for(j = i + nStride; j < nStride * nCount; j += nStride) {
                        pTempData2 = new Float32Array(pData, j, 3);
                        fDistance = (pTempData1[0] - pTempData2[0]) * (pTempData1[0] - pTempData2[0]) + (pTempData1[1] - pTempData2[1]) * (pTempData1[1] - pTempData2[1]) + (pTempData1[2] - pTempData2[2]) * (pTempData1[2] - pTempData2[2]);
                        if (fDistance > fDiametr) {
                            fDiametr = fDistance;
                            isAdd = true;
                            points[0] = pTempData2[0];
                            points[1] = pTempData2[1];
                            points[2] = pTempData2[2];
                            length = 3;
                        } else if (fDistance.toFixed(7) == fDiametr.toFixed(7)) {
                            isAdd = true;
                            for(k = 0; k < points.length; k += 3) {
                                if (points[k] == pTempData2[0] && points[k + 1] == pTempData2[1] && points[k + 2] == pTempData2[2]) {
                                    isNew = false;
                                    break;
                                }
                            }
                            if (isNew) {
                                points[length] = pTempData2[0];
                                points[length + 1] = pTempData2[1];
                                points[length + 2] = pTempData2[2];
                                length += 3;
                            }
                        }
                    }
                    if (isAdd) {
                        points[length] = pTempData1[0];
                        points[length + 1] = pTempData1[1];
                        points[length + 2] = pTempData1[2];
                        length += 3;
                    }
                }
            }
            var fX = 0, fY = 0, fZ = 0;
            for(i = 0; i < points.length; i += 3) {
                fX += points[i];
                fY += points[i + 1];
                fZ += points[i + 2];
            }
            var x = pSphere.center.x = fX / points.length * 3;
            var y = pSphere.center.y = fY / points.length * 3;
            var z = pSphere.center.z = fZ / points.length * 3;
            pSphere.radius = akra.math.sqrt((points[0] - x) * (points[0] - x) + (points[1] - y) * (points[1] - y) + (points[2] - z) * (points[2] - z));
            return true;
        }
        geometry.computeBoundingSphereMinimal = computeBoundingSphereMinimal;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        function calculateSkin(pMeshSubset) {
            var pRenderData = pMeshSubset.data;
            var isOk = pRenderData.selectIndexSet(".update_skinned_position");
            if (!isOk) {
                return false;
            }
            var pEngine = pRenderData.buffer.getEngine();
            var pResourceManager = pEngine.getResourceManager();
            var pWebGLRenderer = pEngine.getRenderer();
            var pWebGLContext = (pWebGLRenderer._pWebGLContext);
            var pWebGLVertexTexture = pRenderData.buffer.buffer;
            var pWebGLTexture = (pWebGLVertexTexture._pWebGLTexture);
            /*update skinned position program*/
            var pWebGLProgram = pResourceManager.shaderProgramPool.findResource(".WEBGL_skinning_update");
            if (((pWebGLProgram) === null)) {
                pWebGLProgram = pResourceManager.shaderProgramPool.createResource(".WEBGL_skinning_update");
                pWebGLProgram.create("																																\n        		#ifndef A_VB_COMPONENT3																											\n				#define A_VB_COMPONENT4																											\n				#endif																															\n				#ifdef A_VB_COMPONENT4																											\n				#define A_VB_ELEMENT_SIZE 4.																									\n				#endif																															\n				#ifdef A_VB_COMPONENT3																											\n				#define A_VB_ELEMENT_SIZE 3.																									\n				#endif																															\n				#define A_tex2D(S, H, X, Y) texture2D(S, vec2(H.stepX * X , H.stepY * Y))														\n				#define A_tex2Dv(S, H, V) texture2D(S, V)																						\n																																				\n				struct A_TextureHeader { float width; float height; float stepX; float stepY; };												\n																																				\n				void A_extractTextureHeader(const sampler2D src, out A_TextureHeader header){													\n					vec4 v = texture2D(src, vec2(0.00001));																						\n					header = A_TextureHeader(v.r, v.g, v.b, v.a);																				\n				}																																\n																																				\n				vec2 A_findPixel(const A_TextureHeader header, const float offset){																\n					float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE);																		\n				return vec2(header.stepX * (mod(pixelNumber, header.width) + .5),																\n					 header.stepY * (floor(pixelNumber / header.width) + .5));																	\n				}																																\n																																				\n				vec2 A_extractVec2(const sampler2D sampler, const A_TextureHeader header, const float offset){									\n					vec2 pPos = A_findPixel(header, offset);																					\n					int shift = int(mod(offset, A_VB_ELEMENT_SIZE));																			\n																																				\n					#ifdef A_VB_COMPONENT4																										\n																																				\n					if(shift == 0) return A_tex2Dv(sampler, header, pPos).rg;																	\n					else if(shift == 1) return A_tex2Dv(sampler, header, pPos).gb;																\n					else if(shift == 2) return A_tex2Dv(sampler, header, pPos).ba;																\n					else if(shift == 3) {																										\n						if(int(pPos.x*header.width) == int(header.width - 1.)){																	\n							return vec2(A_tex2Dv(sampler, header, pPos).a,																		\n								A_tex2Dv(sampler, header, vec2(0.5 * header.stepX, pPos.y + header.stepY)).r);									\n						}																														\n						else{																													\n							return vec2(A_tex2Dv(sampler, header, pPos).a, A_tex2Dv(sampler, header, vec2(pPos.x + header.stepX, pPos.y)).r);	\n						}																														\n					}																															\n					#endif																														\n																																				\n					return vec2(0.);																											\n				}																																\n																																				\n				vec4 A_extractVec4(const sampler2D sampler, const A_TextureHeader header, const float offset){									\n					vec2 pPos = A_findPixel(header, offset);																					\n					int shift = int(mod(offset, A_VB_ELEMENT_SIZE));																			\n																																				\n					#ifdef A_VB_COMPONENT4																										\n																																				\n					if(shift == 0) return A_tex2Dv(sampler, header, pPos);																		\n					else if(shift == 1){																										\n						if(int(pPos.x*header.width) == int(header.width - 1.)){																	\n							return vec4(A_tex2Dv(sampler, header, pPos).gba,																	\n								A_tex2Dv(sampler, header, vec2(0.5 * header.stepX, pPos.y + header.stepY)).r);									\n						}																														\n						else{																													\n							return vec4(A_tex2Dv(sampler, header, pPos).gba, A_tex2Dv(sampler, header, vec2(pPos.x + header.stepX, pPos.y)).r);	\n						}																														\n					}																															\n					else if(shift == 2){																										\n						if(int(pPos.x*header.width) == int(header.width - 1.)){																	\n							return vec4(A_tex2Dv(sampler, header, pPos).ba,																		\n								A_tex2Dv(sampler, header, vec2(0.5 * header.stepX, pPos.y + header.stepY)).rg);									\n						}																														\n						else{																													\n							return vec4(A_tex2Dv(sampler, header, pPos).ba, A_tex2Dv(sampler, header, vec2(pPos.x + header.stepX, pPos.y)).rg);	\n						}																														\n					}																															\n					else if(shift == 3){																										\n						if(int(pPos.x*header.width) == int(header.width - 1.)){																	\n							return vec4(A_tex2Dv(sampler, header, pPos).a,																		\n								A_tex2Dv(sampler, header, vec2(0.5 * header.stepX, pPos.y + header.stepY)).rgb);								\n						}																														\n						else{																													\n							return vec4(A_tex2Dv(sampler, header, pPos).a, A_tex2Dv(sampler, header, vec2(pPos.x + header.stepX, pPos.y)).rgb);	\n						}																														\n					}																															\n																																				\n					#endif																														\n																																				\n					#ifdef A_VB_COMPONENT3																										\n					#endif																														\n																																				\n					return vec4(0.);																											\n				}																																\n																																				\n				mat4 A_extractMat4(const sampler2D sampler, const A_TextureHeader header, const float offset){									\n					return mat4(A_tex2Dv(sampler, header, A_findPixel(header, offset)),															\n								A_tex2Dv(sampler, header, A_findPixel(header, offset + 4.)),													\n								A_tex2Dv(sampler, header, A_findPixel(header, offset + 8.)),													\n								A_tex2Dv(sampler, header, A_findPixel(header, offset + 12.)));													\n				}																																\n																																				\n				attribute float positionIndex;																									\n				attribute float normalIndex;																									\n				attribute float destinationIndex;																								\n																																				\n				uniform sampler2D videoBuffer;																									\n				uniform vec2 frameBufferSize;																									\n				uniform int type;																												\n				uniform mat4 bind_matrix;																										\n																																				\n				varying vec4 data;																												\n																																				\n				void main(void){																												\n					A_TextureHeader header;																										\n					A_extractTextureHeader(videoBuffer, header);																				\n																																				\n					vec4 position = A_extractVec4(videoBuffer, header, positionIndex);															\n					vec2 meta_data = A_extractVec2(videoBuffer, header, position.w);															\n																																				\n					float number_matrix = meta_data.x;																							\n					float bone_inf_ptr = meta_data.y;																							\n																																				\n					mat4 bone_matrix = mat4(0.);																								\n					float weight;																												\n																																				\n					mat4 result_mat = mat4(0.);																									\n																																				\n					for(float i = 0.; i < 16.; i++) {																							\n						if(i < number_matrix){																									\n							//get data about matrix and weight																					\n							vec2 bone_inf = A_extractVec2(videoBuffer, header, bone_inf_ptr + i * 2.);											\n																																				\n							bone_matrix = A_extractMat4(videoBuffer, header, bone_inf.x);														\n							weight = bone_inf.y;																								\n																																				\n							result_mat += bone_matrix * weight;																					\n						}																														\n						else {																													\n							break;																												\n						}																														\n					}																															\n																																				\n					result_mat = result_mat * bind_matrix;																						\n																																				\n					if(type == 0){																												\n						data = result_mat * vec4(position.xyz, 1.);																				\n					}																															\n					else if(type == 1){																											\n						vec4 normal = A_extractVec4(videoBuffer, header, normalIndex);															\n						data = vec4((result_mat * vec4(normal.xyz, 0.)).xyz, normal.w);															\n					}																															\n																																				\n					vec2 outPixelPosition = vec2((mod(destinationIndex/4., frameBufferSize.x) + 0.5)/frameBufferSize.x,							\n												 (floor(destinationIndex/4./frameBufferSize.x) + 0.5)/frameBufferSize.y);						\n																																				\n					gl_Position = vec4(outPixelPosition*2. - 1., 0. ,1.);																		\n					gl_PointSize = 1.;																											\n				}																																\n																																				\n        		", "																																\n				#ifdef GL_ES                        																							\n				    precision highp float;          																							\n				#endif																															\n				varying vec4 data;                  																							\n				                                    																							\n				void main(void) {                   																							\n				    gl_FragColor = data;            																							\n				}                                   																							\n				");
            }
            var pOldFrameBuffer = pWebGLRenderer.getParameter(0x8CA6);
            var pWebGLFramebuffer = /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.createWebGLFramebuffer();
            pWebGLRenderer.disableAllWebGLVertexAttribs();
            (pWebGLRenderer._pWebGLContext.bindFramebuffer((0x8D40), (pWebGLFramebuffer)));
            (pWebGLRenderer._pWebGLContext.useProgram(((pWebGLProgram._pWebGLProgram))));
            pWebGLContext.disable(0x0B71);
            pWebGLContext.disable(0x0C11);
            pWebGLContext.disable(0x0BE2);
            pWebGLContext.disable(0x0B44);
            var iPositionAttribLocation = (((pWebGLProgram._pWebGLAttributeLocations[("positionIndex")]) !== undefined) ? pWebGLProgram._pWebGLAttributeLocations[("positionIndex")] : -1);
            var iNormalAttribLocation = (((pWebGLProgram._pWebGLAttributeLocations[("normalIndex")]) !== undefined) ? pWebGLProgram._pWebGLAttributeLocations[("normalIndex")] : -1);
            var iDestinationAttribLocation = (((pWebGLProgram._pWebGLAttributeLocations[("destinationIndex")]) !== undefined) ? pWebGLProgram._pWebGLAttributeLocations[("destinationIndex")] : -1);
            pWebGLContext.enableVertexAttribArray(iPositionAttribLocation);
            pWebGLContext.enableVertexAttribArray(iNormalAttribLocation);
            pWebGLContext.enableVertexAttribArray(iDestinationAttribLocation);
            pWebGLContext.framebufferTexture2D(0x8D40, 0x8CE0, 0x0DE1, pWebGLTexture, 0);
            //get data from renderData for position update
            pRenderData.selectIndexSet(".update_skinned_position");
            var pIndexData = pRenderData.getIndices();
            var pBuffer = pIndexData.buffer;
            var pDeclaration = pIndexData.getVertexDeclaration();
            //LOG(pIndexData.toString());
            var iStride = pDeclaration.stride;
            var iPositionOffset = pDeclaration.findElement("UPP_INDEX").offset;
            var iDestinationOffset = pDeclaration.findElement("DESTINATION_SP").offset;
            var iNormalOffset = 0.;
            (pWebGLRenderer._pWebGLContext.bindBuffer((0x8892), ((pBuffer._pWebGLBuffer))));
            pWebGLContext.vertexAttribPointer(iPositionAttribLocation, 1, 0x1406, false, iStride, iPositionOffset);
            pWebGLContext.vertexAttribPointer(iDestinationAttribLocation, 1, 0x1406, false, iStride, iDestinationOffset);
            /////////////////////////////////////////////////////////////////////////
            //просто подаем данные чтобы можно было порендерить, мы все равно ими не пользуемся
            pWebGLContext.vertexAttribPointer(iNormalAttribLocation, 1, 0x1406, false, iStride, iPositionOffset);
            //
            /////////////////////////////////////////////////////////////////////////
            (pWebGLRenderer._pWebGLContext.activeTexture((0x84C0)));
            /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(0x0DE1, pWebGLTexture);
            var iWidth = (pWebGLVertexTexture._iWidth);
            var iHeight = (pWebGLVertexTexture._iHeight);
            (pWebGLProgram._pWebGLContext.uniform1i(pWebGLProgram._pWebGLUniformLocations[("videoBuffer")], (0)));
            pWebGLProgram.setVec2("frameBufferSize", akra.Vec2.stackCeil.set(iWidth, iHeight));
            (pWebGLProgram._pWebGLContext.uniform1i(pWebGLProgram._pWebGLUniformLocations[("type")], (0)));
            pWebGLProgram.setMat4("bind_matrix", pMeshSubset.skin.getBindMatrix());
            pWebGLContext.viewport(0, 0, iWidth, iHeight);
            //PASS 1
            ///////////////////////////////////////////////
            pWebGLContext.drawArrays(0x0000, pIndexData.byteOffset / iStride, pIndexData.length);
            ///////////////////////////////////////////////
            //get data from renderData for normal update
            pRenderData.selectIndexSet(".update_skinned_normal");
            pIndexData = pRenderData.getIndices();
            pBuffer = pIndexData.buffer;
            pDeclaration = pIndexData.getVertexDeclaration();
            //LOG(pIndexData.toString());
            iStride = pDeclaration.stride;
            iPositionOffset = pDeclaration.findElement("UNP_INDEX").offset;
            iNormalOffset = pDeclaration.findElement("UNN_INDEX").offset;
            iDestinationOffset = pDeclaration.findElement("DESTINATION_SN").offset;
            (pWebGLRenderer._pWebGLContext.bindBuffer((0x8892), ((pBuffer._pWebGLBuffer))));
            pWebGLContext.vertexAttribPointer(iPositionAttribLocation, 1, 0x1406, false, iStride, iPositionOffset);
            pWebGLContext.vertexAttribPointer(iNormalAttribLocation, 1, 0x1406, false, iStride, iNormalOffset);
            pWebGLContext.vertexAttribPointer(iDestinationAttribLocation, 1, 0x1406, false, iStride, iDestinationOffset);
            (pWebGLProgram._pWebGLContext.uniform1i(pWebGLProgram._pWebGLUniformLocations[("type")], (1)));
            //PASS 2
            ///////////////////////////////////////////////
            pWebGLContext.drawArrays(0x0000, pIndexData.byteOffset / iStride, pIndexData.length);
            ///////////////////////////////////////////////
            pWebGLContext.flush();
            (pWebGLRenderer._pWebGLContext.bindFramebuffer((0x8D40), (pOldFrameBuffer)));
            (pWebGLRenderer._pWebGLFramebufferList.push((pWebGLFramebuffer)));
            pWebGLContext.disableVertexAttribArray(iPositionAttribLocation);
            pWebGLContext.disableVertexAttribArray(iNormalAttribLocation);
            pWebGLContext.disableVertexAttribArray(iDestinationAttribLocation);
            (pWebGLRenderer._pWebGLContext.bindBuffer((0x8892), (null)));
            /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pWebGLRenderer.bindWebGLTexture(0x0DE1, null);
            pWebGLRenderer._setViewport(null);
            return true;
        }
        util.calculateSkin = calculateSkin;
        ;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (model) {
        var MeshSubset = (function (_super) {
            __extends(MeshSubset, _super);
            function MeshSubset(pMesh, pRenderData, sName) {
                if (typeof sName === "undefined") { sName = null; }
                        _super.call(this, akra.ERenderDataTypes.MESH_SUBSET);
                /**@protected*/ this._sName = null;
                /**@protected*/ this._pMesh = null;
                /**@protected*/ this._pSkin = null;
                /**@protected*/ this._pBoundingBox = null;
                /**@protected*/ this._pBoundingSphere = null;
                /**@protected*/ this._isOptimizedSkinned = false;
                this.setup(pMesh, pRenderData, sName);
            }
            Object.defineProperty(MeshSubset.prototype, "boundingBox", {
                get: /** @inline */function () {
                    return this._pBoundingBox;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MeshSubset.prototype, "boundingSphere", {
                get: /** @inline */function () {
                    return this._pBoundingSphere;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MeshSubset.prototype, "skin", {
                get: /** @inline */function () {
                    return this._pSkin;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MeshSubset.prototype, "name", {
                get: /** @inline */function () {
                    return this._sName;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MeshSubset.prototype, "mesh", {
                get: /** @inline */function () {
                    return this._pMesh;
                },
                enumerable: true,
                configurable: true
            });
            MeshSubset.prototype.setup = /**@protected*/ function (pMesh, pRenderData, sName) {
 {
                    akra.logger.setSourceLocation("MeshSubset.ts", 39);
                    akra.logger.assert(this._pMesh === null, "mesh subset already prepared");
                }
                ;
                this._pMesh = pMesh;
                this._pRenderData = pRenderData;
                this._sName = sName;
                _super.prototype._setup.call(this, pMesh.getEngine().getRenderer());
            };
            MeshSubset.prototype.createBoundingBox = function () {
                var pVertexData;
                var pNewBoundingBox;
                pNewBoundingBox = new akra.geometry.Rect3d();
                pVertexData = ((this)._pRenderData)._getData(akra.DeclUsages.POSITION);
                if (((pVertexData) === null)) {
                    return false;
                }
                if (akra.geometry.computeBoundingBox(pVertexData, pNewBoundingBox) == false) {
                    return false;
                }
                this._pBoundingBox = pNewBoundingBox;
                return true;
            };
            MeshSubset.prototype.deleteBoundingBox = function () {
                this._pBoundingBox = null;
                return true;
            };
            MeshSubset.prototype.showBoundingBox = function () {
                var pMaterial;
                var iData;
                var iCurrentIndexSet;
                var pPoints, pIndexes;
                if (((this._pBoundingBox) === null)) {
                    if (!this.createBoundingBox()) {
                        return false;
                    }
                }
                pPoints = new Array();
                pIndexes = new Array();
                akra.geometry.computeDataForCascadeBoundingBox(this._pBoundingBox, pPoints, pIndexes, 10.0);
                iCurrentIndexSet = ((this)._pRenderData).getIndexSet();
                if (!((this)._pRenderData).selectIndexSet(".BoundingBox")) {
                    if (((this)._pRenderData).addIndexSet(false, akra.EPrimitiveTypes.LINELIST, ".BoundingBox") == -1) {
 {
                            akra.logger.setSourceLocation("MeshSubset.ts", 94);
                            akra.logger.error("could not add index set '.BoundingBox'");
                        }
                        ;
                        return false;
                    }
                    iData = ((this)._pRenderData).allocateData([
                        (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclUsages.POSITION)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                    ], new Float32Array(pPoints));
                    ((this)._pRenderData).allocateIndex([
                        (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclUsages.INDEX0)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                    ], new Float32Array(pIndexes));
                    ((this)._pRenderData).index(iData, akra.DeclUsages.INDEX0);
                    // this.applyFlexMaterial(".MaterialBoundingBox");
                    //       //TODO: некорректно задавать так boundingBox, т.к. надо рендерится со своим рендер методом, а его никто не выбирает.
                    // pMaterial = this.getFlexMaterial(".MaterialBoundingBox");
                    // pMaterial.emissive = new Color(0.0, 0.0, 1.0, 1.0);
                    // pMaterial.diffuse  = new Color(0.0, 0.0, 1.0, 1.0);
                                    } else {
                    ((this)._pRenderData)._getData(akra.DeclUsages.POSITION).setData(new Float32Array(pPoints), akra.DeclUsages.POSITION);
                }
                ((this)._pRenderData).setRenderable(((this)._pRenderData).getIndexSet(), true);
                ((this)._pRenderData).selectIndexSet(iCurrentIndexSet);
                return true;
            };
            MeshSubset.prototype.isBoundingBoxVisible = /** @inline */function () {
                return ((this)._pRenderData).isRenderable(((this)._pRenderData).findIndexSet(".BoundingBox"));
            };
            MeshSubset.prototype.hideBoundingBox = function () {
                var iCurrentIndexSet;
                iCurrentIndexSet = ((this)._pRenderData).getIndexSet();
                if (!((this)._pRenderData).selectIndexSet(".BoundingBox")) {
                    return false;
                } else {
                    ((this)._pRenderData).setRenderable(((this)._pRenderData).getIndexSet(), false);
                }
                return ((this)._pRenderData).selectIndexSet(iCurrentIndexSet);
            };
            MeshSubset.prototype.createBoundingSphere = function () {
                var pVertexData;
                var pNewBoundingSphere;
                pNewBoundingSphere = new akra.geometry.Sphere();
                pVertexData = ((this)._pRenderData)._getData(akra.DeclUsages.POSITION);
                if (!pVertexData) {
                    return false;
                }
                if (!akra.geometry.computeBoundingSphere(pVertexData, pNewBoundingSphere, false, this._pBoundingBox)) {
                    return false;
                }
                this._pBoundingSphere = pNewBoundingSphere;
                return true;
            };
            MeshSubset.prototype.deleteBoundingSphere = function () {
                this._pBoundingSphere = null;
                return true;
            };
            MeshSubset.prototype.showBoundingSphere = function () {
                var pMaterial;
                var iData;
                var iCurrentIndexSet;
                var pPoints, pIndexes;
                if (((this._pBoundingSphere) === null)) {
                    if (!this.createBoundingSphere()) {
                        return false;
                    }
                }
                pPoints = new Array();
                pIndexes = new Array();
                akra.geometry.computeDataForCascadeBoundingSphere(this._pBoundingSphere, pPoints, pIndexes);
                iCurrentIndexSet = ((this)._pRenderData).getIndexSet();
                if (!((this)._pRenderData).selectIndexSet(".BoundingSphere")) {
                    ((this)._pRenderData).addIndexSet(false, akra.EPrimitiveTypes.LINELIST, ".BoundingSphere");
                    iData = ((this)._pRenderData).allocateData([
                        (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclUsages.POSITION)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                    ], new Float32Array(pPoints));
                    ((this)._pRenderData).allocateIndex([
                        (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclUsages.INDEX0)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                    ], new Float32Array(pIndexes));
                    ((this)._pRenderData).index(iData, akra.DeclUsages.INDEX0);
                    // this.applyFlexMaterial(".MaterialBoundingSphere");
                    // pMaterial = this.getFlexMaterial(".MaterialBoundingSphere");
                    // pMaterial.emissive = new Color(0.0, 0.0, 1.0, 1.0);
                    // pMaterial.diffuse  = new Color(0.0, 0.0, 1.0, 1.0);
                                    } else {
                    ((this)._pRenderData)._getData(akra.DeclUsages.POSITION).setData(new Float32Array(pPoints), akra.DeclUsages.POSITION);
                }
                ((this)._pRenderData).setRenderable(((this)._pRenderData).getIndexSet(), true);
                ((this)._pRenderData).selectIndexSet(iCurrentIndexSet);
                return true;
            };
            MeshSubset.prototype.wireframe = function (bEnable) {
                if (typeof bEnable === "undefined") { bEnable = true; }
                if (((this)._pRenderData).findIndexSet(".wireframe") == -1) {
                    var ePrimType = ((this)._pRenderData).getPrimitiveType();
                    if (ePrimType !== akra.EPrimitiveTypes.TRIANGLELIST) {
 {
                            akra.logger.setSourceLocation("MeshSubset.ts", 213);
                            akra.logger.warning("wireframe supported only for TRIANGLELIST");
                        }
                        ;
                        return false;
                    }
                    var pIndices = ((this)._pRenderData).getIndexFor("POSITION");
                    var pWFindices = [];
                    var pWFCache = {};
                    var pPairs = [
                        [
                            0, 
                            1
                        ], 
                        [
                            1, 
                            2
                        ], 
                        [
                            2, 
                            0
                        ]
                    ];
                    for(var n = 0; n < pIndices.length / 3; ++n) {
                        var t = n * 3;
                        for(var i = 0; i < pPairs.length; ++i) {
                            var i1 = pPairs[i][0];
                            var i2 = pPairs[i][1];
                            var v1 = pIndices[t + i1];
                            var v2 = pIndices[t + i2];
                            if (v2 < v1) {
                                var y = v2;
                                v1 = v2;
                                v2 = y;
                            }
                            var k = v1 + "_" + v2;
                            if (pWFCache[k]) {
                                continue;
                            }
                            pWFCache[k] = true;
                            pWFindices.push(v1, v2);
                        }
                    }
                    var iData = ((this)._pRenderData).getDataLocation("POSITION");
                    var iCurrentIndexSet = ((this)._pRenderData).getIndexSet();
                    var iWireframeSet = ((this)._pRenderData).addIndexSet(false, akra.EPrimitiveTypes.LINELIST, ".wireframe");
                    ((this)._pRenderData).allocateIndex([
                        (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("WF_INDEX")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                    ], new Float32Array(pWFindices));
                    ((this)._pRenderData).index(iData, "WF_INDEX", false, 0, true);
                    ((this)._pRenderData).setRenderable(iWireframeSet, true);
                    ((this)._pRenderData).setRenderable(iCurrentIndexSet, false);
                    ((this)._pRenderData).selectIndexSet(iCurrentIndexSet);
                }
                var iWireframeSet = ((this)._pRenderData).findIndexSet(".wireframe");
                var iCurrentIndexSet = 0;
                ((this)._pRenderData).setRenderable(iWireframeSet, bEnable);
                ((this)._pRenderData).setRenderable(iCurrentIndexSet, !bEnable);
                return true;
            };
            MeshSubset.prototype.isBoundingSphereVisible = /** @inline */function () {
                return ((this)._pRenderData).isRenderable(((this)._pRenderData).findIndexSet(".BoundingSphere"));
            };
            MeshSubset.prototype.hideBoundingSphere = function () {
                var iCurrentIndexSet = ((this)._pRenderData).getIndexSet();
                if (!((this)._pRenderData).selectIndexSet(".BoundingSphere")) {
                    return false;
                } else {
                    ((this)._pRenderData).setRenderable(((this)._pRenderData).getIndexSet(), false);
                }
                return ((this)._pRenderData).selectIndexSet(iCurrentIndexSet);
            };
            MeshSubset.prototype.computeNormals = function () {
                //TODO: calc normals
                            };
            MeshSubset.prototype.computeTangents = function () {
                //TODO: compute normals
                            };
            MeshSubset.prototype.computeBinormals = function () {
                //TODO: calc binormals
                            };
            MeshSubset.prototype.isSkinned = /** @inline */function () {
                return this._pSkin !== null;
            };
            MeshSubset.prototype.isOptimizedSkinned = /** @inline */function () {
                return ((this)._pSkin !== null) && this._isOptimizedSkinned;
            };
            MeshSubset.prototype.getSkin = function () {
                return this._pSkin;
            };
            MeshSubset.prototype.applyFlexMaterial = function (sMaterial, pMaterialData) {
                if (typeof pMaterialData === "undefined") { pMaterialData = null; }
                if (this._pMesh.addFlexMaterial(sMaterial, pMaterialData)) {
                    return this.setFlexMaterial(sMaterial);
                }
                return false;
            };
            MeshSubset.prototype.getFlexMaterial = function (iMaterial) {
                return this._pMesh.getFlexMaterial(iMaterial);
            };
            MeshSubset.prototype.hasFlexMaterial = function () {
                return this._pRenderData.hasSemantics(akra.DeclUsages.MATERIAL);
            };
            MeshSubset.prototype.setFlexMaterial = function (iMaterial) {
                var pMaterial = this._pMesh.getFlexMaterial(iMaterial);
                if (((pMaterial) === null)) {
 {
                        akra.logger.setSourceLocation("MeshSubset.ts", 336);
                        akra.logger.warning("could not find material <" + iMaterial + "> in sub mesh <" + ((this)._sName) + ">");
                    }
                    ;
                    return false;
                }
                var pRenderData = this._pRenderData;
                var pIndexData = pRenderData.getIndices();
                var pMatFlow = pRenderData._getFlow(akra.DeclUsages.MATERIAL);
                var eSemantics = akra.DeclUsages.INDEX10;
                var pIndexDecl, pFloatArray;
                var iMatFlow;
                var iMat = (pMaterial).data.byteOffset;
                if (pMatFlow) {
                    iMatFlow = pMatFlow.flow;
                    eSemantics = pMatFlow.mapper.semantics;
                    pIndexData = pMatFlow.mapper.data;
                    pRenderData._addData((pMaterial).data, iMatFlow);
                    return pRenderData.index(iMat, eSemantics, true);
                }
                pIndexDecl = akra.createVertexDeclaration([
                    (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((eSemantics)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                ]);
                pFloatArray = new Float32Array((pIndexData).length);
                iMatFlow = pRenderData._addData((pMaterial).data);
 {
                    akra.logger.setSourceLocation("MeshSubset.ts", 362);
                    akra.logger.assert(iMatFlow >= 0, "cannot add data flow with material for mesh subsset");
                }
                ;
                if (!pRenderData.allocateIndex(pIndexDecl, pFloatArray)) {
 {
                        akra.logger.setSourceLocation("MeshSubset.ts", 365);
                        akra.logger.warning("cannot allocate index for material!!!");
                    }
                    ;
                    return false;
                }
                return pRenderData.index(iMat, eSemantics, true);
            };
            MeshSubset.prototype._draw = function () {
                //		    this._pRenderData._draw();
                 {
                    akra.logger.setSourceLocation("MeshSubset.ts", 374);
                    akra.logger.criticalError("Need to do.");
                }
                ;
            };
            MeshSubset.prototype.show = /** @inline */function () {
                ((this)._pRenderData).setRenderable(true);
            };
            MeshSubset.prototype.hide = /** @inline */function () {
                ((this)._pRenderData).setRenderable(false);
            };
            MeshSubset.prototype.isRenderable = /** @inline */function () {
                return ((this)._pRenderData).isRenderable();
            };
            MeshSubset.prototype.setSkin = //исходим из того, что данные скина 1:1 соотносятся с вершинами.
            function (pSkin) {
                var pRenderData = ((this)._pRenderData);
                var pPosData;
                var pPositionFlow;
                var pNormalFlow;
                var pMetaData;
                //мета данные разметки
                var pInfMetaData;
                //адресс мета данных во флотах
                var iInfMetaDataLoc;
                //шаг мета данных во флотах
                var iInfMetaDataStride;
                /*
                Получаем данные вершин, чтобы проложить в {W} компоненту адерес мета информации,
                о влиянии на данную вершины.
                */
                //получаем поток данных с вершиными
                pPositionFlow = pRenderData._getFlow(akra.DeclUsages.POSITION);
 {
                    akra.logger.setSourceLocation("MeshSubset.ts", 409);
                    akra.logger.assert(((pPositionFlow) != null), "skin require position with indices in mesh subset");
                }
                ;
                pPosData = pPositionFlow.data;
                //проверяем, что данные еще не подвязаны к другому Skin'у
                if (pPosData.hasSemantics(akra.DeclUsages.BLENDMETA)) {
                    //тоже самый skin?
                    if (pSkin.isAffect(pPosData)) {
                        return true;
                    }
 {
                        akra.logger.setSourceLocation("MeshSubset.ts", 420);
                        akra.logger.error("mesh subset already has another skin");
                    }
                    ;
                    return false;
                }
                //проверяем, что текущий подмеш пренадлежит мешу, на который натягивается skin,
                //или его клону.
                 {
                    akra.logger.setSourceLocation("MeshSubset.ts", 427);
                    akra.logger.assert(((this)._pRenderData).buffer == pSkin.data, "can not bind to skin mesh subset that does not belong skin's mesh.");
                }
                //подвязывем скин, к данным с вершинами текущего подмеша.
                //т.е. добавляем разметку в конец каждого пикселя
                pSkin.attach(pPosData);
                /*
                //получаем данные разметки
                pMetaData = <Float32Array>pPosData.getTypedData(DeclUsages.BLENDMETA);
                
                //если по каким то причинам нет разметки...
                debug_assert(isDefAndNotNull(pMetaData), "you must specify location for storage blending data");
                
                //выставляем разметку мета данных вершин, так чтобы они адрессовали сразу на данные
                pInfMetaData = pSkin.getInfluenceMetaData();
                iInfMetaDataLoc = pInfMetaData.byteOffset / EDataTypeSizes.BYTES_PER_FLOAT;
                iInfMetaDataStride = pInfMetaData.stride / EDataTypeSizes.BYTES_PER_FLOAT;
                
                for (var i: int = 0; i < pMetaData.length; ++ i) {
                pMetaData[i] = iInfMetaDataLoc + i * iInfMetaDataStride;
                }
                
                //обновляем адреса мета данных вершин
                pPosData.setData(pMetaData, DeclUsages.BLENDMETA);
                
                */
                var pDeclaration = pPosData.getVertexDeclaration();
                var pVEMeta = pDeclaration.findElement(akra.DeclUsages.BLENDMETA);
                //if BLENDMETA not found
                 {
                    akra.logger.setSourceLocation("MeshSubset.ts", 457);
                    akra.logger.assert(((pVEMeta) != null), "you must specify location for storage blending data");
                }
                ;
                //read all data for acceleration
                pMetaData = new Float32Array(pPosData.getData(0, pDeclaration.stride));
                //выставляем разметку мета данных вершин, так чтобы они адрессовали сразу на данные
                pInfMetaData = pSkin.getInfluenceMetaData();
                iInfMetaDataLoc = pInfMetaData.byteOffset / akra.EDataTypeSizes.BYTES_PER_FLOAT;
                iInfMetaDataStride = pInfMetaData.stride / akra.EDataTypeSizes.BYTES_PER_FLOAT;
                var iCount = pMetaData.byteLength / pDeclaration.stride;
                var iOffset = pVEMeta.offset / akra.EDataTypeSizes.BYTES_PER_FLOAT;
                var iStride = pDeclaration.stride / akra.EDataTypeSizes.BYTES_PER_FLOAT;
                for(var i = 0; i < iCount; ++i) {
                    pMetaData[iOffset + i * iStride] = iInfMetaDataLoc + i * iInfMetaDataStride;
                }
                pPosData.setData(pMetaData, 0, pDeclaration.stride);
                var pIndexData = pRenderData.getIndices();
                pNormalFlow = pRenderData._getFlow(akra.DeclUsages.NORMAL);
                var pIndex0 = pIndexData.getTypedData(pPositionFlow.mapper.semantics);
                var pIndex1 = pIndexData.getTypedData(pNormalFlow.mapper.semantics);
                var iAdditionPosition = pPosData.byteOffset;
                var iAdditionNormal = pNormalFlow.data.byteOffset;
                for(var i = 0; i < pIndex0.length; i++) {
                    pIndex0[i] = (pIndex0[i] * akra.EDataTypeSizes.BYTES_PER_FLOAT - iAdditionPosition) / pPositionFlow.data.stride;
                    pIndex1[i] = (pIndex1[i] * akra.EDataTypeSizes.BYTES_PER_FLOAT - iAdditionNormal) / pNormalFlow.data.stride;
                }
                //update position index
                var pUPPositionIndex = new Float32Array(pPosData.length);
                for(var i = 0; i < pPosData.length; i++) {
                    pUPPositionIndex[i] = i;
                }
                //update normal index
                var pTmp = {};
                var pSkinnedNormalIndex = [];
                /*update normal position index*/
                var pUNPositionIndex = [];
                /*update normal normal index*/
                var pUNNormalIndex = [];
                var pDestinationSkinnedNormalIndex = [];
                var iCounter = 0;
                for(var i = 0; i < pIndex0.length; i++) {
                    var sKey = pIndex0[i].toString() + "_" + pIndex1[i];
                    if (!((pTmp[sKey]) !== undefined)) {
                        pTmp[sKey] = iCounter;
                        pUNPositionIndex.push(pIndex0[i]);
                        pUNNormalIndex.push(pIndex1[i]);
                        pSkinnedNormalIndex.push(iCounter);
                        pDestinationSkinnedNormalIndex.push(iCounter);
                        iCounter++;
                    } else {
                        pSkinnedNormalIndex.push(pDestinationSkinnedNormalIndex[pTmp[sKey]]);
                    }
                }
                var iSkinnedPos = pRenderData.allocateData([
                    (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("SKINNED_POSITION")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
})), 
                    (({
count: (0),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.UNSIGNED_BYTE),
usage: (/*checked (origin: akra)>>*/akra.DeclUsages.END),
offset: ((16))
}))
                ], new Float32Array(pPosData.length * 4));
                /*skinned vertices uses same index as vertices*/
                pRenderData.allocateIndex([
                    (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("SP_INDEX")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                ], pIndex0);
                pRenderData.index(iSkinnedPos, "SP_INDEX");
                var iSkinnedNorm = pRenderData.allocateData([
                    (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("SKINNED_NORMAL")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
})), 
                    (({
count: (0),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.UNSIGNED_BYTE),
usage: (/*checked (origin: akra)>>*/akra.DeclUsages.END),
offset: ((16))
}))
                ], new Float32Array(pUNNormalIndex.length * 4));
                /*skinned normals uses new index*/
                pRenderData.allocateIndex([
                    (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("SN_INDEX")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                ], new Float32Array(pSkinnedNormalIndex));
                pRenderData.index(iSkinnedNorm, "SN_INDEX");
                var iPreviousSet = pRenderData.getIndexSet();
                var iUPIndexSet = pRenderData.addIndexSet(true, akra.EPrimitiveTypes.POINTLIST, ".update_skinned_position");
                pRenderData.allocateIndex([
                    (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("UPP_INDEX")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                ], pUPPositionIndex);
                pRenderData.index(pPosData.byteOffset, "UPP_INDEX");
                pRenderData.allocateIndex([
                    (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("DESTINATION_SP")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                ], pUPPositionIndex);
                pRenderData.index(iSkinnedPos, "DESTINATION_SP");
                var iUNIndexSet = pRenderData.addIndexSet(true, akra.EPrimitiveTypes.POINTLIST, ".update_skinned_normal");
                pRenderData.allocateIndex([
                    (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("UNP_INDEX")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                ], new Float32Array(pUNPositionIndex));
                pRenderData.index(pPosData.byteOffset, "UNP_INDEX");
                pRenderData.allocateIndex([
                    (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("UNN_INDEX")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                ], new Float32Array(pUNNormalIndex));
                pRenderData.index(pRenderData._getFlow(akra.DeclUsages.NORMAL, false).data.byteOffset, "UNN_INDEX");
                pRenderData.allocateIndex([
                    (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("DESTINATION_SN")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                ], new Float32Array(pDestinationSkinnedNormalIndex));
                pRenderData.index(iSkinnedNorm, "DESTINATION_SN");
                pRenderData.selectIndexSet(iPreviousSet);
                // LOG(pRenderData.toString());
                // pRenderData.selectIndexSet(iUPIndexSet);
                // LOG(pRenderData.toString());
                // pRenderData.selectIndexSet(iUNIndexSet);
                // LOG(pRenderData.toString());
                pRenderData.setRenderable(iUPIndexSet, false);
                pRenderData.setRenderable(iUNIndexSet, false);
                // LOG(iPreviousSet, iUPIndexSet);
                // LOG(pSkinnedNormalIndex);
                // LOG(pUNPositionIndex);
                // LOG(pUNNormalIndex);
                this._pSkin = pSkin;
                this.skinAdded(pSkin);
                return true;
            };
            MeshSubset.prototype._calculateSkin = function () {
                var isOk = akra.util.calculateSkin(this);
                this._isOptimizedSkinned = isOk;
                return isOk;
            };
            MeshSubset.prototype.skinAdded = function (pSkin) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((/*checked (origin: render)>>*/akra.render.RenderableObject._pEventTable))).broadcast[(this._iGuid)] = (((/*checked (origin: render)>>*/akra.render.RenderableObject._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).skinAdded;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pSkin) : _broadcast[i].listener(_recivier, pSkin);
                    }
                }
            };
            return MeshSubset;
        })(akra.render.RenderableObject);
        model.MeshSubset = MeshSubset;        
    })(akra.model || (akra.model = {}));
    var model = akra.model;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (model) {
        var Mesh = (function (_super) {
            __extends(Mesh, _super);
            function Mesh(pEngine, eOptions, sName, pDataBuffer) {
                        _super.call(this);
                this._pFlexMaterials = null;
                this._pBuffer = null;
                this._eOptions = 0;
                this._pSkeleton = null;
                this._pBoundingBox = null;
                this._pBoundingSphere = null;
                this._pSubMeshes = [];
                this._bShadow = true;
                this._pSkinList = [];
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
                this._sName = sName || null;
                this._pEngine = pEngine;
                this.setup(sName, eOptions, pDataBuffer);
            }
            Object.defineProperty(Mesh.prototype, "length", {
                get: /** @inline */function () {
                    return this._pSubMeshes.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mesh.prototype, "flexMaterials", {
                get: /** @inline */function () {
                    return this._pFlexMaterials;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mesh.prototype, "name", {
                get: /** @inline */function () {
                    return this._sName;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mesh.prototype, "data", {
                get: /** @inline */function () {
                    return this._pBuffer;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mesh.prototype, "skeleton", {
                get: /** @inline */function () {
                    return this._pSkeleton;
                },
                set: /** @inline */function (pSkeleton) {
                    this._pSkeleton = pSkeleton;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mesh.prototype, "boundingBox", {
                get: /** @inline */function () {
                    if (((this._pBoundingBox) === null)) {
                        if (!this.createBoundingBox()) {
 {
                                akra.logger.setSourceLocation("model/Mesh.ts", 67);
                                akra.logger.warning("could not compute bounding box fo mesh");
                            }
                            ;
                        }
                    }
                    return this._pBoundingBox;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mesh.prototype, "boundingSphere", {
                get: /** @inline */function () {
                    if (((this._pBoundingSphere) === null)) {
                        if (!this.createBoundingSphere()) {
 {
                                akra.logger.setSourceLocation("model/Mesh.ts", 77);
                                akra.logger.warning("could not compute bounding sphere for mesh");
                            }
                            ;
                        }
                    }
                    return this._pBoundingSphere;
                },
                enumerable: true,
                configurable: true
            });
            Mesh.prototype.setSkeleton = function (pSkeleton) {
                ((this)._pSkeleton = (pSkeleton));
            };
            Mesh.prototype.getOptions = function () {
                return this._eOptions;
            };
            Mesh.prototype.getEngine = function () {
                return this._pEngine;
            };
            Mesh.prototype._drawSubset = function (iSubset) {
                this._pBuffer._draw(iSubset);
            };
            Mesh.prototype._draw = function () {
                for(var i = 0; i < ((this)._pSubMeshes.length); i++) {
                    this._pSubMeshes[i]._draw();
                }
                ;
            };
            Mesh.prototype.isReadyForRender = function () {
                for(var i = 0; i < this._pSubMeshes.length; ++i) {
                    if (this._pSubMeshes[i].isReadyForRender()) {
                        return true;
                    }
                }
                return false;
            };
            Mesh.prototype.setup = function (sName, eOptions, pDataCollection) {
 {
                    akra.logger.setSourceLocation("model/Mesh.ts", 125);
                    akra.logger.assert(this._pBuffer === null, "mesh already setuped.");
                }
                ;
                if (((pDataCollection) === null)) {
                    this._pBuffer = this._pEngine.createRenderDataCollection(eOptions);
                } else {
 {
                        akra.logger.setSourceLocation("model/Mesh.ts", 132);
                        akra.logger.assert(pDataCollection.getEngine() === this.getEngine(), "you can not use a buffer with a different context");
                    }
                    ;
                    this._pBuffer = pDataCollection;
                    eOptions |= pDataCollection.getOptions();
                }
                this._pBuffer.addRef();
                this._eOptions = eOptions || 0;
                this._sName = sName || "unknown";
                return true;
            };
            Mesh.prototype.createSubset = function (sName, ePrimType, eOptions) {
                if (typeof eOptions === "undefined") { eOptions = 0; }
                var pData;
                //TODO: modify options and create options for data dactory.
                /*EPrimitiveTypes.POINTLIST*/
                pData = this._pBuffer.getEmptyRenderData(ePrimType, eOptions);
                pData.addRef();
                if (((pData) === null)) {
                    return null;
                }
                return this.appendSubset(sName, pData);
            };
            Mesh.prototype.appendSubset = function (sName, pData) {
 {
                    akra.logger.setSourceLocation("model/Mesh.ts", 159);
                    akra.logger.assert(pData.buffer === this._pBuffer, "invalid data used");
                }
                ;
                var pSubMesh = new model.MeshSubset(this, pData, sName);
                this._pSubMeshes.push(pSubMesh);
                ((pSubMesh).getEventTable().addDestination(((((pSubMesh)))._iGuid), ("skinAdded"), (this), ("_skinAdded"), (undefined)));
                ((pSubMesh).getEventTable().addDestination(((((pSubMesh)))._iGuid), ("shadow"), (this), ("shadow"), (/*checked (origin: akra)>>*/akra.EEventTypes.UNICAST)));
                return pSubMesh;
            };
            Mesh.prototype._skinAdded = function (pSubMesh, pSkin) {
                if (this._pSkinList.indexOf(pSkin) != -1) {
                    return;
                }
                this._pSkinList.push(pSkin);
            };
            Mesh.prototype.replaceFlexMaterials = function (pFlexMaterials) {
                this._pFlexMaterials = pFlexMaterials;
            };
            Mesh.prototype.freeSubset = function (sName) {
 {
                    akra.logger.setSourceLocation("model/Mesh.ts", 183);
                    akra.logger.error("Метод freeSubset не реализован");
                }
                ;
                return false;
            };
            Mesh.prototype.getFlexMaterial = function (arg) {
                if (!this._pFlexMaterials) {
                    return null;
                }
                if (typeof arguments[0] === 'number') {
                    return this._pFlexMaterials[arguments[0]] || null;
                } else {
                    for(var i = 0, pMaterials = this._pFlexMaterials; i < pMaterials.length; ++i) {
                        if (pMaterials[i].name === arguments[0]) {
                            return pMaterials[i];
                        }
                    }
                }
                return null;
            };
            Mesh.prototype.addFlexMaterial = function (sName, pMaterialData) {
                if (typeof sName === "undefined") { sName = 'unknown'; }
                if (typeof pMaterialData === "undefined") { pMaterialData = null; }
                var pMaterial;
                var pMaterialId;
 {
                    akra.logger.setSourceLocation("model/Mesh.ts", 212);
                    akra.logger.assert(arguments.length < 7, "only base material supported now...");
                }
                ;
                //debug_assert(this.getFlexMaterial(sName) === null, 'material with name <' + sName + '> already exists');
                pMaterial = this.getFlexMaterial(sName);
                if (pMaterial) {
                    if (pMaterialData) {
                        pMaterial.set(pMaterialData);
                    }
                    return true;
                }
                if (!this._pFlexMaterials) {
                    this._pFlexMaterials = [];
                }
                pMaterialId = this._pFlexMaterials.length;
                pMaterial = akra.material._createFlex(sName, this._pBuffer._allocateData(akra.material.VERTEX_DECL, null));
                if (!pMaterialData) {
                    pMaterialData = akra.material.create(null, akra.material.DEFAULT);
                }
                pMaterial.set(pMaterialData);
                //pMaterial.id = pMaterialId;
                this._pFlexMaterials.push(pMaterial);
                return true;
            };
            Mesh.prototype.setFlexMaterial = function (iMaterial) {
                var bResult = true;
                for(var i = 0; i < ((this)._pSubMeshes.length); ++i) {
                    if (!this._pSubMeshes[i].setFlexMaterial(iMaterial)) {
 {
                            akra.logger.setSourceLocation("model/Mesh.ts", 252);
                            akra.logger.warning("cannot set material<" + iMaterial + "> for mesh<" + ((this)._sName) + "> subset<" + this._pSubMeshes[i].name + ">");
                        }
                        ;
                        bResult = false;
                    }
                }
                return bResult;
            };
            Mesh.prototype.destroy = function () {
                this._pFlexMaterials = null;
                this._pSubMeshes = null;
                /*this*/
                this._pBuffer.destroy();
            };
            Mesh.prototype.getSubset = function (n) {
                if ((typeof (arguments[0]) === "number")) {
                    return this._pSubMeshes[arguments[0]] || null;
                } else {
                    for(var i = 0; i < ((this)._pSubMeshes.length); ++i) {
                        if (this._pSubMeshes[i].name == arguments[0]) {
                            return this._pSubMeshes[i];
                        }
                    }
                }
                return null;
            };
            Mesh.prototype.setSkin = function (pSkin) {
                for(var i = 0; i < ((this)._pSubMeshes.length); ++i) {
                    this._pSubMeshes[i].setSkin(pSkin);
                }
            };
            Mesh.prototype.createSkin = function () {
                var pSkin = model.createSkin(this);
                return pSkin;
            };
            Mesh.prototype.clone = function (iCloneOptions) {
                var pClone = null;
                var pRenderData;
                var pSubMesh;
                if (iCloneOptions & akra.EMeshCloneOptions.SHARED_GEOMETRY) {
                    pClone = this.getEngine().createMesh(((this)._sName), this.getOptions(), ((this)._pBuffer));
                    for(var i = 0; i < ((this)._pSubMeshes.length); ++i) {
                        pRenderData = this._pSubMeshes[i].data;
                        pRenderData.addRef();
                        pClone.appendSubset(this._pSubMeshes[i].name, pRenderData);
                        pClone.getSubset(i).material.name = this._pSubMeshes[i].material.name;
                    }
                    pClone.replaceFlexMaterials(((this)._pFlexMaterials));
                    //trace('created clone', pClone);
                                    } else {
                    //TODO: clone mesh data.
                                    }
                if (iCloneOptions & akra.EMeshCloneOptions.GEOMETRY_ONLY) {
                    return pClone;
                } else {
                    //TODO: clone mesh shading
                                    }
                return pClone;
            };
            Mesh.prototype.createAndShowSubBoundingBox = function () {
                for(var i = 0; i < ((this)._pSubMeshes.length); i++) {
                    var pSubMesh = this.getSubset(i);
                    if (pSubMesh.createBoundingBox()) {
                        if (!pSubMesh.showBoundingBox()) {
 {
                                akra.logger.setSourceLocation("model/Mesh.ts", 332);
                                akra.logger.error("could not show sub bounding box");
                            }
                            ;
                        }
                    } else {
 {
                            akra.logger.setSourceLocation("model/Mesh.ts", 336);
                            akra.logger.error("could not create sub bounding box.");
                        }
                        ;
                    }
                    //console.log("SubMesh" + i);
                                    }
            };
            Mesh.prototype.createAndShowSubBoundingSphere = function () {
                for(var i = 0; i < ((this)._pSubMeshes.length); i++) {
                    var pSubMesh = this.getSubset(i);
                    pSubMesh.createBoundingSphere();
                    pSubMesh.showBoundingSphere();
                    //console.log("SubMesh" + i);
                                    }
            };
            Mesh.prototype.createBoundingBox = function () {
                var pVertexData;
                var pSubMesh;
                var pNewBoundingBox;
                var pTempBoundingBox;
                var i;
                pNewBoundingBox = new akra.geometry.Rect3d();
                pTempBoundingBox = new akra.geometry.Rect3d();
                pSubMesh = this.getSubset(0);
                pVertexData = pSubMesh.data._getData(akra.DeclUsages.POSITION);
                if (((pVertexData) === null)) {
                    return false;
                }
                if (akra.geometry.computeBoundingBox(pVertexData, pNewBoundingBox) == false) {
                    return false;
                }
                if (pSubMesh.isSkinned()) {
                    pNewBoundingBox.transform(pSubMesh.skin.getBindMatrix());
                    pNewBoundingBox.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
                }
                for(i = 1; i < ((this)._pSubMeshes.length); i++) {
                    pSubMesh = this.getSubset(i);
                    pVertexData = pSubMesh.data._getData(akra.DeclUsages.POSITION);
                    //trace(pSubMesh.name);
                    if (!pVertexData) {
                        return false;
                    }
                    if (akra.geometry.computeBoundingBox(pVertexData, pTempBoundingBox) == false) {
                        return false;
                    }
                    //trace('>>> before box >>');
                    if (pSubMesh.isSkinned()) {
                        //trace('calc skinned box');
                        pTempBoundingBox.transform(pSubMesh.skin.getBindMatrix());
                        pTempBoundingBox.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
                    }
                    // trace('<<< after box <<');
                    pNewBoundingBox.x0 = Math.min(pNewBoundingBox.x0, pTempBoundingBox.x0);
                    pNewBoundingBox.y0 = Math.min(pNewBoundingBox.y0, pTempBoundingBox.y0);
                    pNewBoundingBox.z0 = Math.min(pNewBoundingBox.z0, pTempBoundingBox.z0);
                    pNewBoundingBox.x1 = Math.max(pNewBoundingBox.x1, pTempBoundingBox.x1);
                    pNewBoundingBox.y1 = Math.max(pNewBoundingBox.y1, pTempBoundingBox.y1);
                    pNewBoundingBox.z1 = Math.max(pNewBoundingBox.z1, pTempBoundingBox.z1);
                }
                this._pBoundingBox = pNewBoundingBox;
                return true;
            };
            Mesh.prototype.deleteBoundingBox = function () {
                this._pBoundingBox = null;
                return true;
            };
            Mesh.prototype.showBoundingBox = function () {
                var pSubMesh;
                var pMaterial;
                var iData;
                var pPoints, pIndexes;
                if (((this._pBoundingBox) === null)) {
                    if (!this.createBoundingBox()) {
                        return false;
                    }
                }
                pPoints = new Array();
                pIndexes = new Array();
                akra.geometry.computeDataForCascadeBoundingBox(this._pBoundingBox, pPoints, pIndexes, 0.1);
                pSubMesh = this.getSubset(".BoundingBox");
                if (!pSubMesh) {
                    pSubMesh = this.createSubset(".BoundingBox", akra.EPrimitiveTypes.LINELIST, akra.EHardwareBufferFlags.STATIC);
                    if (((pSubMesh) === null)) {
 {
                            akra.logger.setSourceLocation("model/Mesh.ts", 439);
                            akra.logger.error("could not create bounding box subset...");
                        }
                        ;
                        return false;
                    }
                    iData = pSubMesh.data.allocateData([
                        (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclUsages.POSITION)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                    ], new Float32Array(pPoints));
                    pSubMesh.data.allocateIndex([
                        (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclUsages.INDEX0)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                    ], new Float32Array(pIndexes));
                    pSubMesh.data.index(iData, akra.DeclUsages.INDEX0);
                    // pSubMesh.applyFlexMaterial(".MaterialBoundingBox");
                    /*getFlexMaterial(".MaterialBoundingBox");*/
                    pMaterial = pSubMesh.material;
                    pMaterial.emissive = new akra.Color(1.0, 1.0, 1.0, 1.0);
                    pMaterial.diffuse = new akra.Color(1.0, 1.0, 1.0, 1.0);
                    pMaterial.ambient = new akra.Color(1.0, 1.0, 1.0, 1.0);
                    pMaterial.specular = new akra.Color(1.0, 1.0, 1.0, 1.0);
                    pSubMesh.effect.addComponent("akra.system.mesh_texture");
                    pSubMesh.hasShadow = false;
                } else {
                    pSubMesh.data._getData(akra.DeclUsages.POSITION).setData(new Float32Array(pPoints), akra.DeclUsages.POSITION);
                }
                pSubMesh.data.setRenderable(pSubMesh.data.getIndexSet(), true);
                return true;
            };
            Mesh.prototype.hideBoundingBox = function () {
                var pSubMesh = this.getSubset(".BoundingBox");
                if (!pSubMesh) {
                    return false;
                }
                //TODO: hide bounding box!!
                pSubMesh.data.setRenderable(pSubMesh.data.getIndexSet(), false);
                return true;
            };
            Mesh.prototype.isBoundingBoxVisible = function () {
                var pSubMesh = this.getSubset(".BoundingBox");
                if (!pSubMesh) {
                    return false;
                }
                return pSubMesh.data.isRenderable(pSubMesh.data.getIndexSet());
            };
            Mesh.prototype.createBoundingSphere = function () {
                var pVertexData;
                var pSubMesh;
                var pNewBoundingSphere, pTempBoundingSphere;
                var i;
                pNewBoundingSphere = new akra.geometry.Sphere();
                pTempBoundingSphere = new akra.geometry.Sphere();
                pSubMesh = this.getSubset(0);
                pVertexData = pSubMesh.data._getData(akra.DeclUsages.POSITION);
                if (!pVertexData) {
                    return false;
                }
                if (akra.geometry.computeBoundingSphere(pVertexData, pNewBoundingSphere) == false) {
                    return false;
                }
                if (pSubMesh.isSkinned()) {
                    pNewBoundingSphere.transform(pSubMesh.skin.getBindMatrix());
                    pNewBoundingSphere.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
                }
                for(i = 1; i < ((this)._pSubMeshes.length); i++) {
                    pSubMesh = this.getSubset(i);
                    pVertexData = pSubMesh.data._getData(akra.DeclUsages.POSITION);
                    if (((pVertexData) === null)) {
                        return false;
                    }
                    if (akra.geometry.computeBoundingSphere(pVertexData, pTempBoundingSphere) == false) {
                        return false;
                    }
                    if (pSubMesh.isSkinned()) {
                        pTempBoundingSphere.transform(pSubMesh.skin.getBindMatrix());
                        pTempBoundingSphere.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
                        // trace(pTempBoundingSphere.fRadius, '<<<');
                                            }
                    akra.geometry.computeGeneralizingSphere(pNewBoundingSphere, pTempBoundingSphere);
                }
                this._pBoundingSphere = pNewBoundingSphere;
                return true;
            };
            Mesh.prototype.deleteBoundingSphere = function () {
                this._pBoundingSphere = null;
                return true;
            };
            Mesh.prototype.showBoundingSphere = function () {
                var pSubMesh, pMaterial;
                var iData;
                var pPoints, pIndexes;
                if (!this._pBoundingSphere) {
                    if (!this.createBoundingSphere()) {
                        return false;
                    }
                }
                pPoints = new Array();
                pIndexes = new Array();
                akra.geometry.computeDataForCascadeBoundingSphere(this._pBoundingSphere, pPoints, pIndexes);
                pSubMesh = this.getSubset(".BoundingSphere");
                if (!pSubMesh) {
                    pSubMesh = this.createSubset(".BoundingSphere", akra.EPrimitiveTypes.LINELIST, akra.EHardwareBufferFlags.STATIC);
                    if (((pSubMesh) === null)) {
                        return false;
                    }
                    iData = pSubMesh.data.allocateData([
                        (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclUsages.POSITION)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                    ], new Float32Array(pPoints));
                    pSubMesh.data.allocateIndex([
                        (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclUsages.INDEX0)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                    ], new Float32Array(pIndexes));
                    pSubMesh.data.index(iData, akra.DeclUsages.INDEX0);
                    // pSubMesh.applyFlexMaterial(".MaterialBoundingSphere");
                    // //pSubMesh.getFlexMaterial(".MaterialBoundingSphere");
                    pMaterial = pSubMesh.material;
                    pMaterial.emissive = new akra.Color(1.0, 1.0, 1.0, 1.0);
                    pMaterial.diffuse = new akra.Color(1.0, 1.0, 1.0, 1.0);
                    pMaterial.ambient = new akra.Color(1.0, 1.0, 1.0, 1.0);
                    pMaterial.specular = new akra.Color(1.0, 1.0, 1.0, 1.0);
                    pSubMesh.effect.addComponent("akra.system.mesh_texture");
                    pSubMesh.hasShadow = false;
                } else {
                    pSubMesh.data._getData(akra.DeclUsages.POSITION).setData(new Float32Array(pPoints), akra.DeclUsages.POSITION);
                }
                pSubMesh.data.setRenderable(pSubMesh.data.getIndexSet(), true);
                return true;
            };
            Mesh.prototype.hideBoundingSphere = function () {
                var pSubMesh;
                pSubMesh = this.getSubset(".BoundingSphere");
                if (!pSubMesh) {
                    return false;
                }
                pSubMesh.data.setRenderable(pSubMesh.data.getIndexSet(), false);
                return true;
            };
            Mesh.prototype.isBoundingSphereVisible = function () {
                var pSubMesh = this.getSubset(".BoundingSphere");
                if (!pSubMesh) {
                    return false;
                }
                return pSubMesh.data.isRenderable(pSubMesh.data.getIndexSet());
            };
            Object.defineProperty(Mesh.prototype, "hasShadow", {
                get: /** @inline */function () {
                    return this._bShadow;
                },
                set: function (bValue) {
                    for(var i = 0; i < this._pSubMeshes.length; ++i) {
                        this._pSubMeshes[i].hasShadow = bValue;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Mesh.prototype.toSceneModel = function (pParent, sName) {
                if (typeof sName === "undefined") { sName = null; }
                if (((pParent) === null)) {
                    return null;
                }
                var pSceneModel = pParent.scene.createModel(sName);
                if (!pSceneModel.create()) {
                    return null;
                }
                pSceneModel.mesh = this;
                pSceneModel.attachToParent(pParent);
                return pSceneModel;
            };
            Mesh.prototype.update = function () {
                var isOk = false;
                for(var i = 0; i < this._pSkinList.length; ++i) {
                    isOk = this._pSkinList[i].applyBoneMatrices() ? true : isOk;
                }
                if (isOk) {
                    for(var i = 0; i < ((this)._pSubMeshes.length); ++i) {
                        if (this._pSubMeshes[i].isSkinned()) {
                            this._pSubMeshes[i]._calculateSkin();
                        }
                    }
                }
                return isOk;
            };
            Mesh.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            Mesh._pEventTable = new akra.events.EventTable();
            Mesh.prototype.getEventTable = /** @inline */function () {
                return Mesh._pEventTable;
            };
            Mesh.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Mesh.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Mesh.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (Mesh._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Mesh.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (Mesh._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Mesh.prototype._syncTable = /** @inline */function (pFrom) {
                (Mesh._pEventTable)._sync(this, pFrom);
            };
            Mesh.prototype.shadow = function (pSubMesh, bShadow) {
                this._bShadow = bShadow;
                if (!bShadow) {
                    for(var i = 0; i < this._pSubMeshes.length; ++i) {
                        if (this._pSubMeshes[i].hasShadow) {
                            this._bShadow = true;
                            break;
                        }
                    }
                }
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Mesh._pEventTable))).broadcast[(this._iGuid)] = (((Mesh._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).shadow;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pSubMesh, bShadow) : _broadcast[i].listener(_recivier, pSubMesh, bShadow);
                    }
                }
                ;
            };
            return Mesh;
        })(akra.util.ReferenceCounter);        
        function createMesh(pEngine, sName, eOptions, pDataBuffer) {
            if (typeof sName === "undefined") { sName = null; }
            if (typeof eOptions === "undefined") { eOptions = 0; }
            if (typeof pDataBuffer === "undefined") { pDataBuffer = null; }
            return new Mesh(pEngine, eOptions, sName, pDataBuffer);
        }
        model.createMesh = createMesh;
    })(akra.model || (akra.model = {}));
    var model = akra.model;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        var SceneModel = (function (_super) {
            __extends(SceneModel, _super);
            function SceneModel(pScene) {
                        _super.call(this, pScene, akra.EEntityTypes.MODEL);
                this._pMesh = null;
            }
            Object.defineProperty(SceneModel.prototype, "mesh", {
                get: /** @inline */function () {
                    return this._pMesh;
                },
                set: /** @inline */function (pMesh) {
                    if (!((this._pMesh) === null)) {
                        this.accessLocalBounds().set(0.01, 0.01, 0.01);
                        this._pMesh.disconnect(this.scene, "postUpdate", "update");
                        this._pMesh = null;
                    }
                    if (!((pMesh) === null)) {
                        this.accessLocalBounds().set(pMesh.boundingBox);
                        this._pMesh = pMesh;
                        pMesh.connect(this.scene, "postUpdate", "update");
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SceneModel.prototype, "totalRenderable", {
                get: /** @inline */function () {
                    return ((this._pMesh) === null) ? 0 : this._pMesh.length;
                },
                enumerable: true,
                configurable: true
            });
            SceneModel.prototype.getRenderable = /** @inline */function (i) {
                if (typeof i === "undefined") { i = 0; }
                if (((this._pMesh) === null)) {
 {
                        akra.logger.setSourceLocation("SceneModel.ts", 43);
                        akra.logger.warning(this);
                    }
                    ;
                }
                return this._pMesh.getSubset(i);
            };
            Object.defineProperty(SceneModel.prototype, "hasShadow", {
                get: /** @inline */function () {
                    return this._pMesh.hasShadow;
                },
                set: /** @inline */function (bValue) {
                    this._pMesh.hasShadow = bValue;
                },
                enumerable: true,
                configurable: true
            });
            SceneModel.prototype.toString = function (isRecursive, iDepth) {
                if (typeof isRecursive === "undefined") { isRecursive = false; }
                if (typeof iDepth === "undefined") { iDepth = 0; }
                if (!isRecursive) {
                    var sData = "<model" + (((this)._sName) ? " " + ((this)._sName) : "") + "(" + (((this._pMesh) === null) ? 0 : this._pMesh.length) + ")" + '>';
                    if (!((this._pMesh) === null)) {
                        sData += "( " + this._pMesh.name + " )";
                    }
                    return sData;
                }
                return _super.prototype.toString.call(this, isRecursive, iDepth);
            };
            return SceneModel;
        })(scene.SceneObject);
        scene.SceneModel = SceneModel;        
        var iUpdatedOnce = 0;
        /** @inline */function isModel(pEntity) {
            return pEntity.type === akra.EEntityTypes.MODEL;
        }
        scene.isModel = isModel;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        ;
        var RenderData = (function (_super) {
            __extends(RenderData, _super);
            function RenderData(pCollection) {
                if (typeof pCollection === "undefined") { pCollection = null; }
                        _super.call(this);
                /**
                * Options.
                */
                this._eOptions = 0;
                /**
                * Buffer, that create this class.
                */
                this._pBuffer = null;
                /**
                * ID of this data.
                */
                this._iId = -1;
                /**
                * Buffer with indices.
                * If the data is the simplest mesh, with no more
                * than one index, the type will be IndexBuffer,
                * otherwise VertexBuffer.
                */
                this._pIndexBuffer = null;
                /**
                * Buffer with attributes.
                */
                this._pAttribBuffer = null;
                /**
                * Data with indices.
                * If _pIndexBuffer has type IndexBuffer, indices data
                * has type IndexData, otherwise VertexData.
                */
                this._pIndexData = null;
                /**
                * Data with attributes.
                */
                this._pAttribData = null;
                /**
                * Buffer map for current index set.
                */
                this._pMap = null;
                /**
                * Buffer maps of all index sets.
                */
                this._pIndicesArray = [];
                /**
                * Current index set.
                */
                this._iIndexSet = 0;
                this._iRenderable = 1;
                this._pComposer = null;
                this._pBuffer = pCollection;
                this._pComposer = pCollection.getEngine().getComposer();
            }
            Object.defineProperty(RenderData.prototype, "buffer", {
                get: /** @inline */function () {
                    return this._pBuffer;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderData.prototype, "indexSet", {
                get: /** @inline */function () {
                    return this._pIndicesArray[this._iIndexSet];
                },
                enumerable: true,
                configurable: true
            });
            RenderData.prototype.allocateData = function (pDecl, pData, hasIndex) {
                if (typeof hasIndex === "undefined") { hasIndex = true; }
                var pDataDecl = akra.createVertexDeclaration(pDecl);
                var eType = akra.ERenderDataTypes.INDEXED;
                if (!hasIndex || this.useSingleIndex()) {
                    eType = akra.ERenderDataTypes.DIRECT;
                } else if (this.useAdvancedIndex()) {
                    eType = akra.ERenderDataTypes.I2I;
                }
                return this._allocateData(pDataDecl, pData, eType);
            };
            RenderData.prototype.releaseData = /**
            * Remove data from this render data.
            */
            function (iDataLocation) {
                //TODO: release data.
                            };
            RenderData.prototype.allocateAttribute = function (pAttrDecl, pData) {
                var pIndexData = this._pIndexData;
                var pAttribData = this._pAttribData;
                var pAttribBuffer = this._pAttribBuffer;
                var pBuffer = this._pBuffer;
                if (!pAttribData) {
                    if (!pAttribBuffer) {
                        pAttribBuffer = pBuffer.getEngine().getResourceManager().createVertexBuffer('render_data_attrs_' + akra.sid());
                        pAttribBuffer.create((pData).byteLength, akra.EHardwareBufferFlags.BACKUP_COPY);
                        this._pAttribBuffer = pAttribBuffer;
                    }
                    this._pAttribData = this._pAttribBuffer.allocateData(pAttrDecl, pData);
                    this._pIndicesArray[this._iIndexSet].pAttribData = this._pAttribData;
                    this._pMap.flow(this._pAttribData);
                    return this._pAttribData !== null;
                }
                if (!pAttribData.extend(pAttrDecl, pData)) {
 {
                        akra.logger.setSourceLocation("RenderData.ts", 139);
                        akra.logger.log('invalid data for allocation:', arguments);
                    }
                    ;
 {
                        akra.logger.setSourceLocation("RenderData.ts", 140);
                        akra.logger.warning('cannot allocate attribute in data subset..');
                    }
                    ;
                    return false;
                }
                return true;
            };
            RenderData.prototype.allocateIndex = function (pDecl, pData) {
                var pAttrDecl = akra.createVertexDeclaration(pDecl);
                if (this.useAdvancedIndex()) {
                    return this._allocateAdvancedIndex(pAttrDecl, pData);
                }
                return this._allocateIndex(pAttrDecl, pData);
            };
            RenderData.prototype.getAdvancedIndexData = function (sSemantics) {
                return this._getData(sSemantics, true);
            };
            RenderData.prototype.addIndexSet = /**
            * Add new set of indices.
            */
            function (usePreviousDataSet, ePrimType, sName) {
                if (typeof usePreviousDataSet === "undefined") { usePreviousDataSet = true; }
                if (typeof ePrimType === "undefined") { ePrimType = akra.EPrimitiveTypes.TRIANGLELIST; }
                if (typeof sName === "undefined") { sName = null; }
                // if (this._pIndexData === null) {
                //     return false;
                // }
                if (usePreviousDataSet) {
                    this._pMap = this._pMap.clone(false);
                    if (!this._pMap) {
 {
                            akra.logger.setSourceLocation("RenderData.ts", 181);
                            akra.logger.warning("could not clone buffer map");
                        }
                        ;
                        return -1;
                    }
                } else {
                    this._pMap = this._pBuffer.getEngine().createBufferMap();
                    this._pAttribData = null;
                }
                this._pMap.primType = ePrimType;
                this._pIndexData = null;
                this._iIndexSet = this._pIndicesArray.length;
                this._pIndicesArray.push({
                    pMap: this._pMap,
                    pIndexData: this._pIndexData,
                    pAttribData: this._pAttribData,
                    sName: sName,
                    pI2IDataCache: null,
                    pAdditionCache: null
                });
                return this._iIndexSet;
            };
            RenderData.prototype.getNumIndexSet = function () {
                return this._pIndicesArray.length;
            };
            RenderData.prototype.getIndexSetName = function (iSet) {
                if (typeof iSet === "undefined") { iSet = this._iIndexSet; }
                return this._pIndicesArray[iSet].sName;
            };
            RenderData.prototype.selectIndexSet = function (a) {
                var iSet = -1;
                if ((typeof (arguments[0]) === "string")) {
                    iSet = this.findIndexSet(arguments[0]);
                    if (iSet < 0) {
                        return false;
                    }
                } else {
                    iSet = arguments[0];
                }
                var pIndexSet = this._pIndicesArray[iSet];
                if (pIndexSet) {
                    this._pMap = pIndexSet.pMap;
                    this._pIndexData = pIndexSet.pIndexData;
                    this._pAttribData = pIndexSet.pAttribData;
                    this._iIndexSet = iSet;
                    return true;
                }
                return false;
            };
            RenderData.prototype.findIndexSet = function (sName) {
                for(var i = 0; i < this._pIndicesArray.length; ++i) {
                    if (this._pIndicesArray[i].sName === sName) {
                        return i;
                    }
                }
                return -1;
            };
            RenderData.prototype.getIndexSet = /**
            * Get number of current index set.
            */
            function () {
                return this._iIndexSet;
            };
            RenderData.prototype.hasAttributes = /** @inline */function () {
                return !((this._pAttribData) === null);
            };
            RenderData.prototype.useAdvancedIndex = /**
            * Specifies uses advanced index.
            */
            function () {
                return (this._eOptions & akra.ERenderDataOptions.ADVANCED_INDEX) != 0;
            };
            RenderData.prototype.useSingleIndex = function () {
                return (this._eOptions & akra.ERenderDataOptions.SINGLE_INDEX) != 0;
            };
            RenderData.prototype.useMultiIndex = function () {
                return (this._eOptions & akra.ERenderDataOptions.SINGLE_INDEX) == 0;
            };
            RenderData.prototype.setRenderable = function (iIndexSet, bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                if (arguments.length < 2) {
                    //mark all render data as renderable or not
                    if (arguments[0]) {
                        ((this._eOptions) |= (akra.ERenderDataOptions.RENDERABLE));
                    } else {
                        ((this._eOptions) &= ~(akra.ERenderDataOptions.RENDERABLE));
                    }
                }
                //mark index set is renderable or not
                (bValue ? ((this._iRenderable) |= (1 << (iIndexSet))) : ((this._iRenderable) &= ~(1 << (iIndexSet))));
            };
            RenderData.prototype.isRenderable = function (iIndexSet) {
                if (arguments.length > 0) {
                    //is this index set renderable ?
                    return ((this._iRenderable & (1 << (iIndexSet))) != 0);
                }
                //is this data renderable ?
                return this._eOptions & akra.ERenderDataOptions.RENDERABLE ? true : false;
            };
            RenderData.prototype.hasSemantics = /**
            * Check whether the semantics used in this data set.
            */
            function (sSemantics, bSearchComplete) {
                if (typeof bSearchComplete === "undefined") { bSearchComplete = true; }
                return this._getFlow(sSemantics, bSearchComplete) !== null;
            };
            RenderData.prototype.getDataLocation = function (sSemantics) {
                var pData = this._getData(sSemantics);
                return pData ? pData.byteOffset : -1;
            };
            RenderData.prototype.getIndices = /**
            * Get indices that uses in current index set.
            */
            function () {
                return this._pIndexData;
            };
            RenderData.prototype.getIndexFor = function (sSemantics) {
                var pFlow = this._getFlow(sSemantics);
                if (!((pFlow.mapper) === null)) {
                    return pFlow.mapper.data.getTypedData(pFlow.mapper.semantics);
                }
                return null;
            };
            RenderData.prototype.getPrimitiveCount = /**
            * Get number of primitives for rendering.
            */
            /** @inline */function () {
                return this._pMap.primCount;
            };
            RenderData.prototype.getPrimitiveType = /** @inline */function () {
                return this._pMap.primType;
            };
            RenderData.prototype.index = function (data, sSemantics, useSame, iBeginWith, bForceUsage) {
                if (typeof useSame === "undefined") { useSame = false; }
                if (typeof iBeginWith === "undefined") { iBeginWith = 0; }
                if (typeof bForceUsage === "undefined") { bForceUsage = false; }
                var iData = (typeof (arguments[0]) === "number") ? arguments[0] : 0;
                var iFlow = -1;
                var iAddition, iRealAddition, iPrevAddition;
                var pFlow;
                var pData, pRealData;
                var pFloat32Array;
                var iIndexOffset;
                var pIndexData = this._pIndexData;
                var sData;
                var iStride;
                var iTypeSize = akra.EDataTypeSizes.BYTES_PER_FLOAT;
                if (this.useAdvancedIndex()) {
                    pRealData = this._getData(arguments[0]);
                    iAddition = pRealData.byteOffset;
                    iStride = pRealData.stride;
                    //индекс, который подал юзер
                    pData = this._getData(sSemantics, true);
                    pData.applyModifier(sSemantics, function (pTypedData) {
                        for(var i = 0; i < pTypedData.length; i++) {
                            pTypedData[i] = (pTypedData[i] * iStride + iAddition) / iTypeSize;
                        }
                    });
                    iData = pData.byteOffset;
                    sSemantics = "INDEX_" + sSemantics;
                } else if ((typeof (arguments[0]) === "string")) {
                    if (arguments[0] === "TEXCOORD") {
                        iData = this.getDataLocation("TEXCOORD0");
                    } else {
                        iData = this.getDataLocation(arguments[0]);
                    }
 {
                        akra.logger.setSourceLocation("RenderData.ts", 400);
                        akra.logger.assert(iData >= 0, "cannot find data with semantics: " + arguments[0]);
                    }
                    ;
                }
                pFlow = this._getFlow(iData);
                if (pFlow === null) {
                    //поищем эти данные в общем буфере
                    pData = ((this)._pBuffer).getData(iData);
                    if (((pData) === null)) {
 {
                            akra.logger.setSourceLocation("RenderData.ts", 410);
                            akra.logger.warning("Could not find data flow <" + iData + "> int buffer map: " + this._pMap.toString(true));
                        }
                        ;
                        return false;
                    }
                    //все ок, данные найдены, зарегистрируем их у себя в мапе
                     {
                        akra.logger.setSourceLocation("RenderData.ts", 414);
                        akra.logger.assert(this._addData(pData) !== -1, "could not add automatcly add data to map");
                    }
                    ;
                    pFlow = this._getFlow(iData);
                }
                iFlow = pFlow.flow;
                iIndexOffset = (pIndexData).getVertexDeclaration().findElement(sSemantics).offset;
                pFloat32Array = (pIndexData).getTypedData(sSemantics);
                iAddition = iData;
                if (!pFloat32Array) {
                    return false;
                }
                iStride = pFlow.data.stride;
                if (((this)._pIndicesArray[(this)._iIndexSet]).pAdditionCache[iIndexOffset] !== iAddition && !bForceUsage) {
                    if (!useSame) {
                        iPrevAddition = ((this)._pIndicesArray[(this)._iIndexSet]).pAdditionCache[iIndexOffset] || 0;
                        iRealAddition = iAddition - iPrevAddition;
                        for(var i = 0; i < pFloat32Array.length; i++) {
                            pFloat32Array[i] = (pFloat32Array[i] * iStride + iRealAddition) / iTypeSize;
                        }
                    } else {
                        iRealAddition = iAddition;
                        for(var i = 0; i < pFloat32Array.length; i++) {
                            pFloat32Array[i] = (iBeginWith + iRealAddition) / iTypeSize;
                        }
                    }
                    //remeber addition, that we added to index.
                    ((this)._pIndicesArray[(this)._iIndexSet]).pAdditionCache[iIndexOffset] = iAddition;
                    if (!(pIndexData).setData(pFloat32Array, sSemantics)) {
                        return false;
                    }
                }
                return this._pMap.mapping(iFlow, pIndexData, sSemantics);
            };
            RenderData.prototype._setup = /*Setup.*/
            function (pCollection, iId, ePrimType, eOptions) {
                if (typeof ePrimType === "undefined") { ePrimType = akra.EPrimitiveTypes.TRIANGLELIST; }
                if (typeof eOptions === "undefined") { eOptions = 0; }
                if (this._pBuffer === null && arguments.length < 2) {
                    return false;
                }
                this.setRenderable(true);
                this._eOptions |= eOptions;
                this._pBuffer = pCollection;
                this._iId = iId;
                //setup buffer map
                this._pMap = pCollection.getEngine().createBufferMap();
                this._pMap.primType = ePrimType;
                //setup default index set
                this._pIndicesArray.push({
                    sName: ".main",
                    pMap: this._pMap,
                    pIndexData: null,
                    pAttribData: null,
                    pI2IDataCache: {},
                    pAdditionCache: null
                });
 {
                    akra.logger.setSourceLocation("RenderData.ts", 486);
                    akra.logger.assert(this.useSingleIndex() === false, "single indexed data not implimented");
                }
                ;
                return true;
            };
            RenderData.prototype._allocateData = function (pDataDecl, pData, eType) {
                if (eType === akra.ERenderDataTypes.DIRECT) {
                    return this.allocateAttribute(pDataDecl, pData) ? 0 : -1;
                }
                var iFlow;
                var pVertexData = this._pBuffer._allocateData(pDataDecl, pData);
                var iOffset = pVertexData.byteOffset;
                iFlow = this._addData(pVertexData, undefined, eType);
                if (iFlow < 0) {
 {
                        akra.logger.setSourceLocation("RenderData.ts", 506);
                        akra.logger.log("invalid data", pDataDecl, pData);
                    }
                    ;
 {
                        akra.logger.setSourceLocation("RenderData.ts", 507);
                        akra.logger.error("cannot allocate data for submesh");
                    }
                    ;
                    return -1;
                }
                return iOffset;
            };
            RenderData.prototype._addData = /**
            * Add vertex data to this render data.
            */
            function (pVertexData, iFlow, eType) {
                if (typeof eType === "undefined") { eType = akra.ERenderDataTypes.DIRECT; }
                if ((arguments.length < 3 && this.useAdvancedIndex()) || arguments[2] === akra.ERenderDataTypes.I2I) {
                    return this._registerData(pVertexData);
                }
                return (!((iFlow) !== undefined) ? this._pMap.flow(pVertexData) : this._pMap.flow(iFlow, pVertexData));
            };
            RenderData.prototype._registerData = /**
            * Register data in this render.
            * Necessary for index to index mode, when data realy
            * not using in this render data for building final buffer map.
            */
            function (pVertexData) {
                'use strict';
                var iOffset = pVertexData.byteOffset;
                var pDataDecl = pVertexData.getVertexDeclaration();
                //необходимо запоминать расположение данных, которые подаются,
                //т.к. иначе их потом нельзя будет найти среди других данных
                for(var i = 0; i < (pDataDecl._pElements.length); i++) {
                    ((this)._pIndicesArray[(this)._iIndexSet]).pI2IDataCache[(pDataDecl._pElements[(i)] || null).usage] = iOffset;
                }
                return 0;
            };
            RenderData.prototype._allocateAdvancedIndex = function (pAttrDecl, pData) {
                var pDecl = akra.createVertexDeclaration(pAttrDecl);
                var nCount = pData.byteLength / pDecl.stride;
                //TODO: remove index dublicates
                var iIndLoc = this._allocateData(pAttrDecl, pData, akra.ERenderDataTypes.INDEXED);
                var pI2IData = new Float32Array(nCount);
                var pI2IDecl = [];
                for(var i = 0; i < (pDecl._pElements.length); i++) {
                    pI2IDecl.push((({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (('INDEX_' + (pDecl._pElements[(i)] || null).usage)),
offset: ((0))
})));
                }
                for(var i = 0; i < pI2IData.length; i++) {
                    pI2IData[i] = i;
                }
                if (!this._allocateIndex(pI2IDecl, pI2IData)) {
                    this.releaseData(iIndLoc);
                    pI2IData = null;
                    pI2IDecl = null;
 {
                        akra.logger.setSourceLocation("RenderData.ts", 579);
                        akra.logger.warning('cannot allocate index for index in render data subset');
                    }
                    ;
                    return false;
                }
                return true;
            };
            RenderData.prototype._createIndex = function (pAttrDecl, pData) {
                'use strict';
                if (!this._pIndexBuffer) {
                    if (this.useMultiIndex()) {
                        this._pIndexBuffer = this._pBuffer.getEngine().getResourceManager().createVertexBuffer('subset_' + akra.sid());
                        this._pIndexBuffer.create(((pData).byteLength), akra.EHardwareBufferFlags.BACKUP_COPY);
                    } else {
                        //TODO: add support for sinle indexed mesh.
                                            }
                }
                this._pIndexData = (this._pIndexBuffer).allocateData(pAttrDecl, pData);
                ((this)._pIndicesArray[(this)._iIndexSet]).pIndexData = this._pIndexData;
                ((this)._pIndicesArray[(this)._iIndexSet]).pAdditionCache = {};
                return this._pIndexData !== null;
            };
            RenderData.prototype._allocateIndex = function (pDecl, pData) {
                'use strict';
                var pAttrDecl = akra.createVertexDeclaration(pDecl);
                var pIndexData = this._pIndexData;
                var pIndexBuffer = this._pIndexBuffer;
                var pBuffer = this._pBuffer;
                for(var i = 0; i < (pAttrDecl._pElements.length); i++) {
                    if ((pAttrDecl._pElements[(i)] || null).type !== akra.EDataTypes.FLOAT) {
                        return false;
                    }
                }
                if (!this._pIndexData) {
                    return this._createIndex(pAttrDecl, pData);
                }
                if (!(this._pIndexData).extend(pAttrDecl, pData)) {
 {
                        akra.logger.setSourceLocation("RenderData.ts", 640);
                        akra.logger.log('invalid data for allocation:', arguments);
                    }
                    ;
 {
                        akra.logger.setSourceLocation("RenderData.ts", 641);
                        akra.logger.warning('cannot allocate index in data subset..');
                    }
                    ;
                    return false;
                }
                return true;
            };
            RenderData.prototype._setIndexLength = function (iLength) {
                var bResult = (this._pIndexData).resize(iLength);
                if (bResult) {
                    this._pMap._length = iLength;
                }
                return bResult;
            };
            RenderData.prototype._getFlow = function (a, b) {
                if (typeof arguments[0] === 'string') {
                    return this._pMap.getFlow(arguments[0], arguments[1]);
                }
                for(var i = 0, n = this._pMap.limit; i < n; ++i) {
                    var pFlow = this._pMap.getFlow(i, false);
                    if (pFlow.data && pFlow.data.byteOffset === arguments[0]) {
                        return pFlow;
                    }
                }
                return null;
            };
            RenderData.prototype._getData = function (a, b) {
                var pFlow;
                if (this.useAdvancedIndex() && arguments.length < 2) {
                    if (typeof arguments[0] === 'string') {
                        return this._getData(((this)._pIndicesArray[(this)._iIndexSet]).pI2IDataCache[arguments[0]]);
                    }
                    return this._pBuffer.getData(arguments[0]);
                }
                if (typeof arguments[0] === 'string') {
                    for(var i = 0, n = this._pMap.limit; i < n; ++i) {
                        pFlow = this._pMap.getFlow(i, false);
                        if (pFlow.data != null && pFlow.data.hasSemantics(arguments[0])) {
                            return pFlow.data;
                        }
                    }
                    //this._pBuffer._getData(arguments[0]);        	    return null;
                                    }
                pFlow = this._getFlow(arguments[0]);
                return pFlow === null ? null : pFlow.data;
            };
            RenderData.prototype._draw = /**
            * Draw this data.
            */
            function (pTechnique, pViewport, pRenderable, pSceneObject) {
                for(var i = 0; i < this._pIndicesArray.length; i++) {
                    if (this.isRenderable(i)) {
                        //this._pIndicesArray[i].pMap._draw();
                        this._pComposer.applyBufferMap(this._pIndicesArray[i].pMap);
                        pTechnique._renderTechnique(pViewport, pRenderable, pSceneObject);
                    }
                }
            };
            RenderData.prototype.toString = //applyMe(): bool;
            function () {
                var s;
                s = "\nRENDER DATA SUBSET: #" + this._iId + "\n";
                s += "        ATTRIBUTES: " + (this._pAttribData ? "TRUE" : "FALSE") + "\n";
                s += "----------------------------------------------------------------\n";
                s += this._pMap.toString();
                return s;
            };
            return RenderData;
        })(akra.util.ReferenceCounter);
        render.RenderData = RenderData;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        var RenderDataCollection = (function (_super) {
            __extends(RenderDataCollection, _super);
            function RenderDataCollection(pEngine, eOptions) {
                if (typeof eOptions === "undefined") { eOptions = 0; }
                        _super.call(this);
                this._pDataBuffer = null;
                this._pEngine = null;
                this._eDataOptions = 0;
                this._pDataArray = [];
                this._pEngine = pEngine;
                this.setup(eOptions);
            }
            Object.defineProperty(RenderDataCollection.prototype, "buffer", {
                get: /** @inline */function () {
                    return this._pDataBuffer;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderDataCollection.prototype, "length", {
                get: /** @inline */function () {
                    return this._pDataArray.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderDataCollection.prototype, "byteLength", {
                get: /** @inline */function () {
                    return this._pDataBuffer.byteLength;
                },
                enumerable: true,
                configurable: true
            });
            RenderDataCollection.prototype.clone = function (pSrc) {
 {
                    akra.logger.setSourceLocation("render/RenderDataCollection.ts", 37);
                    akra.logger.criticalError("TODO: RenderDataCollection::clone();");
                }
                ;
                return false;
            };
            RenderDataCollection.prototype.getEngine = function () {
                return this._pEngine;
            };
            RenderDataCollection.prototype.getOptions = function () {
                return this._eDataOptions;
            };
            RenderDataCollection.prototype.getData = function (a) {
                var pBuffer = this._pDataBuffer;
                var pData;
                var n;
                if (!((pBuffer) === null)) {
                    n = this._pDataBuffer.length;
                    if ((typeof (arguments[0]) === "string")) {
                        for(var i = 0; i < n; i++) {
                            pData = pBuffer.getVertexData(i);
                            if (pData.hasSemantics(arguments[0])) {
                                return pData;
                            }
                        }
                        ;
                    } else {
                        for(var i = 0; i < n; i++) {
                            pData = pBuffer.getVertexData(i);
                            if (pData.byteOffset === arguments[0]) {
                                return pData;
                            }
                        }
                        ;
                    }
                }
                return null;
            };
            RenderDataCollection.prototype._allocateData = function (pDecl, pData) {
                if (!this._pDataBuffer) {
                    this.createDataBuffer();
                }
                var pVertexDecl = akra.createVertexDeclaration(pDecl);
                var pVertexData;
                if ((arguments.length < 2) || (typeof (arguments[1]) === "number") || ((arguments[1]) === null)) {
                    pVertexData = this._pDataBuffer.getEmptyVertexData(pData || 1, pVertexDecl);
                } else {
                    pVertexData = this._pDataBuffer.allocateData(pVertexDecl, pData);
                }
 {
                    akra.logger.setSourceLocation("render/RenderDataCollection.ts", 108);
                    akra.logger.assert(pVertexData !== null, "cannot allocate data:\n" + pVertexDecl.toString());
                }
                ;
                return pVertexData;
            };
            RenderDataCollection.prototype.allocateData = function (pDecl, pData, isCommon) {
                if (typeof isCommon === "undefined") { isCommon = true; }
                var pVertexData;
                var pDataDecl = akra.createVertexDeclaration(pDecl);
                for(var i = 0; i < (pDataDecl._pElements.length); i++) {
                    if (this.getData((pDataDecl._pElements[(i)] || null).usage) !== null && (pDataDecl._pElements[(i)] || null).count !== 0) {
 {
                            akra.logger.setSourceLocation("render/RenderDataCollection.ts", 127);
                            akra.logger.warning("data buffer already contains data with similar vertex decloration <" + (pDataDecl._pElements[(i)] || null).usage + ">.");
                        }
                        ;
                    }
                }
                ;
                pVertexData = this._allocateData(pDataDecl, pData);
                if (isCommon) {
                    for(var i = 0; i < this._pDataArray.length; ++i) {
                        this._pDataArray[i]._addData(pVertexData);
                    }
                }
                return pVertexData.byteOffset;
            };
            RenderDataCollection.prototype.getDataLocation = function (sSemantics) {
                if (this._pDataBuffer) {
                    var pData;
                    for(var i = 0, n = this._pDataBuffer.length; i < n; i++) {
                        pData = this._pDataBuffer.getVertexData(i);
                        if (pData.hasSemantics(sSemantics)) {
                            return pData.byteOffset;
                        }
                    }
                    ;
                }
                return -1;
            };
            RenderDataCollection.prototype.createDataBuffer = function () {
                //TODO: add support for eOptions
                var iVbOption = 0;
                var eOptions = this._eDataOptions;
                if (eOptions & akra.ERenderDataBufferOptions.VB_READABLE) {
                    iVbOption = akra.ERenderDataBufferOptions.VB_READABLE;
                }
                //trace('creating new video buffer for render data buffer ...');
                this._pDataBuffer = this._pEngine.getResourceManager().createVideoBuffer("render_data_buffer" + "_" + akra.sid());
                this._pDataBuffer.create(0, iVbOption);
                this._pDataBuffer.addRef();
                return this._pDataBuffer !== null;
            };
            RenderDataCollection.prototype.getRenderData = function (iSubset) {
                return this._pDataArray[iSubset];
            };
            RenderDataCollection.prototype.getEmptyRenderData = function (ePrimType, eOptions) {
                if (typeof eOptions === "undefined") { eOptions = 0; }
                var iSubsetId = this._pDataArray.length;
                var pDataset = new render.RenderData(this);
                eOptions |= this._eDataOptions;
                if (!pDataset._setup(this, iSubsetId, ePrimType, eOptions)) {
 {
                        akra.logger.setSourceLocation("render/RenderDataCollection.ts", 187);
                        akra.logger.error("cannot setup submesh...");
                    }
                    ;
                }
                this._pDataArray.push(pDataset);
                return pDataset;
            };
            RenderDataCollection.prototype._draw = function (iSubset) {
                // if (arguments.length > 0) {
                //     this._pDataArray[iSubset]._draw();
                // }
                // for (var i: int = 0; i < this._pDataArray.length; i++) {
                //     this._pDataArray[i]._draw();
                // };
                 {
                    akra.logger.setSourceLocation("render/RenderDataCollection.ts", 205);
                    akra.logger.criticalError("TODO");
                }
                ;
            };
            RenderDataCollection.prototype.destroy = function () {
                this._pDataArray = null;
                if (this._pDataBuffer) {
                    // this._pDataBuffer.release();
                    this._pDataBuffer.destroy();
                    this._pDataBuffer = null;
                }
                this._pEngine = null;
                this._eDataOptions = 0;
            };
            RenderDataCollection.prototype.setup = function (eOptions) {
                if (typeof eOptions === "undefined") { eOptions = 0; }
                this._eDataOptions = eOptions;
            };
            return RenderDataCollection;
        })(akra.util.ReferenceCounter);
        render.RenderDataCollection = RenderDataCollection;        
        // inline isValid(): bool { return true; }
        // inline isDynamic(): bool { return false; }
        // inline isStatic(): bool { return false; }
        // inline isStream(): bool { return false; }
        // inline isReadable(): bool { return true; }
        // inline isBackupPresent(): bool { return true; }
        function createRenderDataCollection(pEngine, eOptions) {
            if (typeof eOptions === "undefined") { eOptions = 0; }
            return new RenderDataCollection(pEngine, eOptions);
        }
        render.createRenderDataCollection = createRenderDataCollection;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (ERPCPacketTypes) {
        ERPCPacketTypes._map = [];
        ERPCPacketTypes._map[0] = "FAILURE";
        ERPCPacketTypes.FAILURE = 0;
        ERPCPacketTypes._map[1] = "REQUEST";
        ERPCPacketTypes.REQUEST = 1;
        ERPCPacketTypes._map[2] = "RESPONSE";
        ERPCPacketTypes.RESPONSE = 2;
    })(akra.ERPCPacketTypes || (akra.ERPCPacketTypes = {}));
    var ERPCPacketTypes = akra.ERPCPacketTypes;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EPipeTypes) {
        EPipeTypes._map = [];
        EPipeTypes._map[0] = "UNKNOWN";
        EPipeTypes.UNKNOWN = 0;
        EPipeTypes._map[1] = "WEBSOCKET";
        /** Connect to websocket. */
        EPipeTypes.WEBSOCKET = 1;
        EPipeTypes._map[2] = "WEBWORKER";
        /** Connect to webworker. */
        EPipeTypes.WEBWORKER = 2;
    })(akra.EPipeTypes || (akra.EPipeTypes = {}));
    var EPipeTypes = akra.EPipeTypes;
    (function (EPipeDataTypes) {
        EPipeDataTypes._map = [];
        EPipeDataTypes._map[0] = "BINARY";
        EPipeDataTypes.BINARY = 0;
        EPipeDataTypes._map[1] = "STRING";
        EPipeDataTypes.STRING = 1;
    })(akra.EPipeDataTypes || (akra.EPipeDataTypes = {}));
    var EPipeDataTypes = akra.EPipeDataTypes;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (net) {
        /**@const*/ net.WEBSOCKET_PORT = 1337;
        var Pipe = (function () {
            function Pipe(sAddr) {
                if (typeof sAddr === "undefined") { sAddr = null; }
                /**@protected*/ this._pAddr = null;
                /** Number of sended messages.*/
                /**@protected*/ this._nMesg = 0;
                /**@protected*/ this._eType = akra.EPipeTypes.UNKNOWN;
                /**@protected*/ this._pConnect = null;
                /**@protected*/ this._bSetupComplete = false;
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
                if (!((sAddr) === null)) {
                    this.open(sAddr);
                }
            }
            Object.defineProperty(Pipe.prototype, "uri", {
                get: /** @inline */function () {
                    return (new /*checked (origin: akra)>>*/akra.util.URI((this._pAddr.toString())));
                },
                enumerable: true,
                configurable: true
            });
            Pipe.prototype.open = function (sAddr) {
                if (typeof sAddr === "undefined") { sAddr = null; }
                var pAddr;
                var eType;
                var pSocket = null;
                var pWorker = null;
                var pPipe = this;
                if (!((sAddr) === null)) {
                    pAddr = (new /*checked (origin: akra)>>*/akra.util.URI((sAddr)));
                } else {
                    if ((!(((this)._pConnect) === null))) {
                        this.close();
                    }
                    pAddr = ((new /*checked (origin: akra)>>*/akra.util.URI(((this)._pAddr.toString()))));
                }
                // pipe to websocket
                if (pAddr.protocol.toLowerCase() === "ws") {
                    //unknown port
                    if (!(pAddr.port > 0)) {
                        pAddr.port = net.WEBSOCKET_PORT;
                    }
                    //websocket unsupported
                    if (!((WebSocket) != null)) {
 {
                            akra.logger.setSourceLocation("Pipe.ts", 64);
                            akra.logger.error("Your browser does not support websocket api.");
                        }
                        ;
                        return false;
                    }
                    pSocket = new WebSocket(pAddr.toString());
                    pSocket.binaryType = "arraybuffer";
                    eType = akra.EPipeTypes.WEBSOCKET;
                } else if (akra.util.pathinfo(pAddr.path).ext.toLowerCase() === "js") {
                    if (!((Worker) != null)) {
 {
                            akra.logger.setSourceLocation("Pipe.ts", 76);
                            akra.logger.error("Your browser does not support webworker api.");
                        }
                        ;
                        return false;
                    }
                    pWorker = new Worker(pAddr.toString());
                    eType = akra.EPipeTypes.WEBWORKER;
                } else {
 {
                        akra.logger.setSourceLocation("Pipe.ts", 84);
                        akra.logger.error("Pipe supported only websockets/webworkers.");
                    }
                    ;
                    return false;
                }
                this._pConnect = pWorker || pSocket;
                this._pAddr = pAddr;
                this._eType = eType;
                if (((window) != null)) {
                    window.onunload = function () {
                        pPipe.close();
                    };
                }
                if (!((this._pConnect) === null)) {
                    this.setupConnect();
                    return true;
                }
                return false;
            };
            Pipe.prototype.setupConnect = function () {
                var pConnect = this._pConnect;
                var pPipe = this;
                var pAddr = this._pAddr;
                if (this._bSetupComplete) {
                    return;
                }
                pConnect.onmessage = function (pMessage) {
                    if (((pMessage.data) instanceof ArrayBuffer)) {
                        pPipe.message(pMessage.data, akra.EPipeDataTypes.BINARY);
                    } else {
                        pPipe.message(pMessage.data, akra.EPipeDataTypes.STRING);
                    }
                };
                pConnect.onopen = function (pEvent) {
 {
                        akra.logger.setSourceLocation("Pipe.ts", 126);
                        akra.logger.log("created connect to: " + pAddr.toString());
                    }
                    ;
                    pPipe.opened(pEvent);
                };
                pConnect.onerror = function (pErr) {
 {
                        akra.logger.setSourceLocation("Pipe.ts", 132);
                        akra.logger.warning("pipe error detected: " + pErr.message);
                    }
                    ;
                    pPipe.error(pErr);
                };
                pConnect.onclose = function (pEvent) {
 {
                        akra.logger.setSourceLocation("Pipe.ts", 137);
                        akra.logger.log("connection to " + pAddr.toString() + " closed");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("Pipe.ts", 138);
                        akra.logger.log("Close event:", pEvent);
                    }
                    ;
                    pPipe.closed(pEvent);
                };
                this._bSetupComplete = true;
            };
            Pipe.prototype.close = function () {
                var pSocket;
                var pWorker;
                if (this.isOpened()) {
                    switch(this._eType) {
                        case akra.EPipeTypes.WEBSOCKET:
                            pSocket = this._pConnect;
                            pSocket.onmessage = null;
                            pSocket.onerror = null;
                            pSocket.onopen = null;
                            pSocket.close();
                            break;
                        case akra.EPipeTypes.WEBWORKER:
                            pWorker = this._pConnect;
                            pWorker.terminate();
                    }
                }
                this._pConnect = null;
                this._bSetupComplete = false;
            };
            Pipe.prototype.write = function (pValue) {
                var pSocket;
                var pWorker;
                if (this.isOpened()) {
                    this._nMesg++;
                    switch(this._eType) {
                        case akra.EPipeTypes.WEBSOCKET:
                            pSocket = this._pConnect;
                            if (akra.isObject(pValue)) {
                                pValue = JSON.stringify(pValue);
                            }
                            pSocket.send(pValue);
                            return true;
                        case akra.EPipeTypes.WEBWORKER:
                            pWorker = this._pConnect;
                            if (((pValue.byteLength) !== undefined)) {
                                pWorker.postMessage(pValue, [
                                    pValue
                                ]);
                            } else {
                                pWorker.postMessage(pValue);
                            }
                            return true;
                    }
                }
                return false;
            };
            Pipe.prototype.isClosed = function () {
                switch(this._eType) {
                    case akra.EPipeTypes.WEBSOCKET:
                        return ((this._pConnect) === null) || ((this._pConnect).readyState === WebSocket.CLOSED);
                }
                return ((this._pConnect) === null);
            };
            Pipe.prototype.isOpened = function () {
                switch(this._eType) {
                    case akra.EPipeTypes.WEBSOCKET:
                        return !((this._pConnect) === null) && (this._pConnect).readyState === WebSocket.OPEN;
                }
                return !((this._pConnect) === null);
            };
            Pipe.prototype.isCreated = /** @inline */function () {
                return !((this._pConnect) === null);
            };
            Pipe.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            Pipe._pEventTable = new akra.events.EventTable();
            Pipe.prototype.getEventTable = /** @inline */function () {
                return Pipe._pEventTable;
            };
            Pipe.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Pipe.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Pipe.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (Pipe._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Pipe.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (Pipe._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Pipe.prototype._syncTable = /** @inline */function (pFrom) {
                (Pipe._pEventTable)._sync(this, pFrom);
            };
            Pipe.prototype.opened = function () {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Pipe._pEventTable))).broadcast[(this._iGuid)] = (((Pipe._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).opened;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            Pipe.prototype.closed = function (ev) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Pipe._pEventTable))).broadcast[(this._iGuid)] = (((Pipe._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).closed;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, ev) : _broadcast[i].listener(_recivier, ev);
                    }
                }
            };
            Pipe.prototype.error = function (err) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Pipe._pEventTable))).broadcast[(this._iGuid)] = (((Pipe._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).error;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, err) : _broadcast[i].listener(_recivier, err);
                    }
                }
            };
            Pipe.prototype.message = function (data, type) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Pipe._pEventTable))).broadcast[(this._iGuid)] = (((Pipe._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).message;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, data, type) : _broadcast[i].listener(_recivier, data, type);
                    }
                }
            };
            return Pipe;
        })();        
        function createPipe(sAddr) {
            if (typeof sAddr === "undefined") { sAddr = null; }
            return new Pipe(sAddr);
        }
        net.createPipe = createPipe;
    })(akra.net || (akra.net = {}));
    var net = akra.net;
})(akra || (akra = {}));
var akra;
(function (akra) {
    /// @: {data}/server|src(inc/net/server)|location()|data_location({data},DATA)
    (function (net) {
        var ERpcStates;
        (function (ERpcStates) {
            ERpcStates._map = [];
            ERpcStates._map[0] = "k_Deteached";
            //not connected
            ERpcStates.k_Deteached = 0;
            ERpcStates._map[1] = "k_Joined";
            //connected, and connection must be established
            ERpcStates.k_Joined = 1;
            ERpcStates._map[2] = "k_Closing";
            //must be closed
            ERpcStates.k_Closing = 2;
        })(ERpcStates || (ERpcStates = {}));
        var RPC = (function () {
            function RPC(pAddr, pOption) {
                if (typeof pAddr === "undefined") { pAddr = null; }
                if (typeof pOption === "undefined") { pOption = {}; }
                /**@protected*/ this._pPipe = null;
                /**@protected*/ this._iGroupID = -1;
                /**@protected*/ this._pGroupCalls = null;
                //стек вызововы, которые были отложены
                /**@protected*/ this._pDefferedRequests = new akra.ObjectList();
                //стек вызовов, ожидающих результата
                //type: ObjectList<IRPCCallback>
                /**@protected*/ this._pCallbacks = new akra.ObjectList();
                //число совершенных вызовов
                /**@protected*/ this._nCalls = 0;
                /**@protected*/ this._pRemoteAPI = {};
                /**@protected*/ this._eState = ERpcStates.k_Deteached;
                //rejoin timer
                /**@protected*/ this._iReconnect = -1;
                //timer for system routine
                /**@protected*/ this._iSystemRoutine = -1;
                /**@protected*/ this._iGroupCallRoutine = -1;
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
                for(var i in RPC.OPTIONS) {
                    if (!((pOption[i]) !== undefined)) {
                        pOption[i] = RPC.OPTIONS[i];
                    }
                }
                this._pOption = pOption;
                if (!((pOption.procMap) != null)) {
                    pOption.procMap = {};
                }
                pOption.procMap[pOption.procListName] = {
                    lifeTime: -1,
                    priority: 10
                };
                pAddr = pAddr || pOption.addr;
                if (((pAddr) != null)) {
                    this.join(pAddr);
                }
            }
            Object.defineProperty(RPC.prototype, "remote", {
                get: /** @inline */function () {
                    return this._pRemoteAPI;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RPC.prototype, "options", {
                get: /** @inline */function () {
                    return this._pOption;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RPC.prototype, "group", {
                get: /** @inline */function () {
                    return !((this._pGroupCalls) === null) ? this._iGroupID : -1;
                },
                enumerable: true,
                configurable: true
            });
            RPC.prototype.join = function (sAddr) {
                if (typeof sAddr === "undefined") { sAddr = null; }
                var pPipe = this._pPipe;
                var pRPC = this;
                var pDeffered = this._pDefferedRequests;
                if (((pPipe) === null)) {
                    pPipe = akra.net.createPipe();
                    pPipe.bind("message", function (pPipe, pMessage, eType) {
                        // LOG(pMessage);
                        if (eType !== akra.EPipeDataTypes.BINARY) {
                            pRPC.parse(JSON.parse(pMessage));
                        } else {
                            pRPC.parseBinary(new Uint8Array(pMessage));
                        }
                    });
                    pPipe.bind("opened", function (pPipe, pEvent) {
                        pRPC._startRoutines();
                        //if we have unhandled call in deffered...
                        if (pDeffered.length) {
                            pDeffered.seek(0);
                            while(pDeffered.length > 0) {
                                pPipe.write(pDeffered.current);
                                pRPC._releaseRequest(pDeffered.takeCurrent());
                            }
 {
                                akra.logger.setSourceLocation("net/RPC.ts", 122);
                                akra.logger.assert(pDeffered.length === 0, "something going wrong. length is: " + pDeffered.length);
                            }
                            ;
                        }
                        pRPC.proc((pRPC._pOption).procListName, function (pError, pList) {
                            if (!((pError) === null)) {
 {
                                    akra.logger.setSourceLocation("net/RPC.ts", 128);
                                    akra.logger.criticalError("could not get proc. list");
                                }
                                ;
                            }
                            //TODO: FIX akra. prefix...
                            if (!((pList) === null) && akra.isArray(pList)) {
                                for(var i = 0; i < pList.length; ++i) {
                                    (function (sMethod) {
                                        (pRPC._pOption).procMap[sMethod] = (pRPC._pOption).procMap[sMethod] || {
                                            lifeTime: -1,
                                            priority: 0
                                        };
                                        (pRPC._pRemoteAPI)[sMethod] = function () {
                                            var pArguments = [
                                                sMethod
                                            ];
                                            for(var j = 0; j < arguments.length; ++j) {
                                                pArguments.push(arguments[j]);
                                            }
                                            return pRPC.proc.apply(pRPC, pArguments);
                                        };
                                    })(String(pList[i]));
                                }
                                // debug_print("rpc options: ", pRPC.options);
                                                            }
                            pRPC.joined();
                        });
                    });
                    pPipe.bind("error", function (pPipe, pError) {
 {
                            akra.logger.setSourceLocation("net/RPC.ts", 164);
                            akra.logger.error("pipe error occured...");
                        }
                        ;
                        //pRPC.rejoin();
                                            });
                    pPipe.bind("closed", function (pPipe, pEvent) {
                        pRPC._stopRoutines();
                        pRPC.rejoin();
                    });
                }
                pPipe.open(sAddr);
                this._pPipe = pPipe;
                this._eState = ERpcStates.k_Joined;
            };
            RPC.prototype.rejoin = function () {
                var pRPC = this;
                clearTimeout(this._iReconnect);
                //rejoin not needed, because pipe already connected
                if (this._pPipe.isOpened()) {
                    this._eState = ERpcStates.k_Joined;
                    return;
                }
                //rejoin not needed, because we want close connection
                if (this._eState == ERpcStates.k_Closing) {
                    this._eState = ERpcStates.k_Deteached;
                    return;
                }
                if (this._pPipe.isClosed()) {
                    //callbacks that will not be called, because connection was lost
                    this.freeCallbacks();
                    if ((((this)._pOption).reconnectTimeout > 0)) {
                        this._iReconnect = setTimeout(/** @inline */function () {
                            pRPC.join();
                        }, ((this)._pOption).reconnectTimeout);
                    }
                }
            };
            RPC.prototype.parse = function (pRes) {
                if (!((pRes.n) !== undefined)) {
 {
                        akra.logger.setSourceLocation("net/RPC.ts", 214);
                        akra.logger.log(pRes);
                    }
                    ;
 {
                        akra.logger.setSourceLocation("net/RPC.ts", 215);
                        akra.logger.warning("message droped, because seriial not recognized.");
                    }
                    ;
                }
                ;
                this.response(pRes.n, pRes.type, pRes.res);
            };
            RPC.prototype.parseBinary = function (pBuffer) {
                var iHeaderByteLength = 12;
                var pHeader = new Uint32Array(pBuffer.buffer, pBuffer.byteOffset, iHeaderByteLength / 4);
                var nMsg = pHeader[0];
                var eType = pHeader[1];
                var iByteLength = pHeader[2];
                var pResult = pBuffer.subarray(iHeaderByteLength, iHeaderByteLength + iByteLength);
                this.response(nMsg, eType, pResult);
                var iPacketByteLength = iHeaderByteLength + iByteLength;
                if (pBuffer.byteLength > iPacketByteLength) {
                    // console.log("group message detected >> ");
                    this.parseBinary(pBuffer.subarray(iPacketByteLength));
                }
            };
            RPC.prototype.response = function (nSerial, eType, pResult) {
                var pStack = this._pCallbacks;
                var fn = null;
                if (eType === akra.ERPCPacketTypes.RESPONSE) {
                    var pCallback = pStack.last;
                    // WARNING("---------------->",nSerial,"<-----------------");
                    // LOG(pStack.length);
                    do {
                        // LOG("#n: ", nSerial, " result: ", pResult);
                        if (pCallback.n === nSerial) {
                            fn = pCallback.fn;
                            this._releaseCallback(pStack.takeCurrent());
                            if (!((fn) === null)) {
                                fn(null, pResult);
                            }
                            return;
                        }
                    } while(pCallback = pStack.prev());
                    // WARNING("package droped, invalid serial: " + nSerial);
                                    } else if (eType === akra.ERPCPacketTypes.REQUEST) {
 {
                        akra.logger.setSourceLocation("net/RPC.ts", 268);
                        akra.logger.error("TODO: REQUEST package type temprary unsupported.");
                    }
                    ;
                } else if (eType === akra.ERPCPacketTypes.FAILURE) {
 {
                        akra.logger.setSourceLocation("net/RPC.ts", 271);
                        akra.logger.error("detected FAILURE on " + nSerial + " package");
                    }
                    ;
 {
                        akra.logger.setSourceLocation("net/RPC.ts", 272);
                        akra.logger.log(pResult);
                    }
                    ;
                } else {
 {
                        akra.logger.setSourceLocation("net/RPC.ts", 275);
                        akra.logger.error("unsupported response type detected: " + eType);
                    }
                    ;
                }
            };
            RPC.prototype.freeRequests = function () {
                var pStack = this._pDefferedRequests;
                var pReq = pStack.first;
                if (pReq) {
                    do {
                        this._releaseRequest(pReq);
                    } while(pReq = pStack.next());
                    pStack.clear();
                }
            };
            RPC.prototype.freeCallbacks = function () {
                var pStack = this._pCallbacks;
                var pCallback = pStack.first;
                if (pCallback) {
                    do {
                        this._releaseCallback(pCallback);
                    } while(pCallback = pStack.next());
                    pStack.clear();
                }
            };
            RPC.prototype.free = function () {
                this.freeRequests();
                this.freeCallbacks();
            };
            RPC.prototype.detach = function () {
                this._eState = ERpcStates.k_Closing;
                if (!((this._pPipe) === null) && this._pPipe.isOpened()) {
                    this._pPipe.close();
                }
                this.free();
            };
            RPC.prototype.findLifeTimeFor = /** @inline */function (sProc) {
                var pProcOpt = this._pOption.procMap[sProc];
                if (pProcOpt) {
                    var iProcLt = pProcOpt.lifeTime;
                    if (iProcLt >= 0) {
                        return iProcLt;
                    }
                }
                return this._pOption.callbackLifetime;
            };
            RPC.prototype.findPriorityFor = function (sProc) {
                var pProcOpt = this._pOption.procMap[sProc];
                if (pProcOpt) {
                    var iProcPr = pProcOpt.priority || 0;
                    return iProcPr;
                }
                return 0;
            };
            RPC.prototype.setProcedureOption = function (sProc, sOpt, pValue) {
                var pOptions = ((this)._pOption).procMap[sProc];
                if (!pOptions) {
                    pOptions = ((this)._pOption).procMap[sProc] = {
                        lifeTime: -1
                    };
                }
                pOptions[sOpt] = pValue;
            };
            RPC.prototype.proc = function () {
                var argv = [];
                for (var _i = 0; _i < (arguments.length - 0); _i++) {
                    argv[_i] = arguments[_i + 0];
                }
                var IRPCCallback = arguments.length - 1;
                var fnCallback = (/*checked (origin: akra)>>*/akra.typeOf((arguments[IRPCCallback])) === "function") ? arguments[IRPCCallback] : null;
                var nArg = arguments.length - (fnCallback ? 2 : 1);
                var pArgv = new Array(nArg);
                var pPipe = this._pPipe;
                var pCallback = null;
                for(var i = 0; i < nArg; ++i) {
                    pArgv[i] = arguments[i + 1];
                }
                var pProc = this._createRequest();
                pProc.n = this._nCalls++;
                pProc.type = akra.ERPCPacketTypes.REQUEST;
                pProc.proc = String(arguments[0]);
                pProc.argv = pArgv;
                pProc.next = null;
                pProc.lt = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.findLifeTimeFor(pProc.proc);
                pProc.pr = this.findPriorityFor(pProc.proc);
                pCallback = this._createCallback();
                pCallback.n = pProc.n;
                pCallback.fn = fnCallback;
                pCallback.timestamp = (Date.now());
                pCallback.procInfo = pProc.proc + "(" + pArgv.join(',') + ")";
                if (((pPipe) === null) || !pPipe.isOpened()) {
                    if (!(((this)._pOption).deferredCallsLimit >= 0) || this._pDefferedRequests.length <= ((this)._pOption).deferredCallsLimit) {
                        this._pDefferedRequests.push(pProc);
                        this._pCallbacks.push(pCallback);
                    } else {
                        pCallback.fn(RPC.ERRORS.STACK_SIZE_EXCEEDED);
 {
                            akra.logger.setSourceLocation("net/RPC.ts", 398);
                            akra.logger.warning(RPC.ERRORS.STACK_SIZE_EXCEEDED);
                        }
                        ;
                        this._releaseCallback(pCallback);
                        this._releaseRequest(pProc);
                    }
                    return false;
                }
                this._pCallbacks.push(pCallback);
                return this.callProc(pProc);
            };
            RPC.prototype.callProc = function (pProc) {
                var pPipe = this._pPipe;
                var bResult = false;
                if ((((this)._pOption).callsFrequency > 0)) {
                    if (((this._pGroupCalls) === null)) {
                        this._pGroupCalls = pProc;
                        this._iGroupID++;
                    } else {
                        pProc.next = this._pGroupCalls;
                        this._pGroupCalls = pProc;
                    }
                    return true;
                } else {
                    bResult = pPipe.write(pProc);
                    this._releaseRequest(pProc);
                }
                return bResult;
            };
            RPC.prototype._systemRoutine = /** @inline */function () {
                this._removeExpiredCallbacks();
            };
            RPC.prototype._startRoutines = function () {
                var pRPC = this;
                if ((((this)._pOption).systemRoutineInterval > 0)) {
                    this._iSystemRoutine = setInterval(/** @inline */function () {
                        (pRPC._removeExpiredCallbacks());
                    }, ((this)._pOption).systemRoutineInterval);
                }
                if ((((this)._pOption).callsFrequency > 0)) {
                    this._iGroupCallRoutine = setInterval(/** @inline */function () {
                        pRPC.groupCall();
                    }, ((this)._pOption).callsFrequency);
                }
            };
            RPC.prototype._stopRoutines = function () {
                clearInterval(this._iSystemRoutine);
                ((this)._removeExpiredCallbacks());
                clearInterval(this._iGroupCallRoutine);
                //TODO: remove calls from group call, if RPC finally detached!
                            };
            RPC.prototype.groupCall = function () {
                var pReq = this._pGroupCalls;
                if (((pReq) === null)) {
                    return;
                }
                this._pPipe.write(pReq);
                return this.dropGroupCall();
            };
            RPC.prototype.dropGroupCall = function () {
                var pReq = this._pGroupCalls;
                for(; ; ) {
                    var pNext = pReq.next;
                    this._releaseRequest(pReq);
                    if (!pNext) {
                        break;
                    }
                    pReq = pNext;
                }
                this._pGroupCalls = null;
                return this._iGroupID;
            };
            RPC.prototype._removeExpiredCallbacks = function () {
                var pCallbacks = this._pCallbacks;
                var pCallback = pCallbacks.first;
                var iNow = (Date.now());
                var fn = null;
                var sInfo = null;
                while(!((pCallback) === null)) {
                    if ((((this)._pOption).callbackLifetime > 0) && (iNow - pCallback.timestamp) >= ((this)._pOption).callbackLifetime) {
                        fn = pCallback.fn;
                        sInfo = pCallback.procInfo;
                        this._releaseCallback(pCallbacks.takeCurrent());
                        pCallback = pCallbacks.current;
                        if (!((fn) === null)) {
                            // debug_print("procedure info: ", sInfo);
                            fn(RPC.ERRORS.CALLBACK_LIFETIME_EXPIRED, null);
                        }
                    } else {
                        pCallback = pCallbacks.next();
                    }
                }
            };
            RPC.prototype._releaseRequest = function (pReq) {
                pReq.n = 0;
                pReq.proc = null;
                pReq.argv = null;
                pReq.next = null;
                pReq.lt = 0;
                pReq.pr = 0;
                RPC.requestPool.push(pReq);
            };
            RPC.prototype._createRequest = function () {
                if (RPC.requestPool.length == 0) {
                    // LOG("allocated rpc request");
                    return {
                        n: 0,
                        type: akra.ERPCPacketTypes.REQUEST,
                        proc: null,
                        argv: null,
                        next: null,
                        lt: 0,
                        pr: 0
                    };
                }
                return RPC.requestPool.pop();
            };
            RPC.prototype._releaseCallback = function (pCallback) {
                pCallback.n = 0;
                pCallback.fn = null;
                pCallback.timestamp = 0;
                pCallback.procInfo = null;
                RPC.callbackPool.push(pCallback);
            };
            RPC.prototype._createCallback = function () {
                if (RPC.callbackPool.length == 0) {
                    // LOG("allocated callback");
                    return {
                        n: 0,
                        fn: null,
                        timestamp: 0,
                        procInfo: null
                    };
                }
                return RPC.callbackPool.pop();
            };
            RPC.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            RPC._pEventTable = new akra.events.EventTable();
            RPC.prototype.getEventTable = /** @inline */function () {
                return RPC._pEventTable;
            };
            RPC.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            RPC.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            RPC.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (RPC._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            RPC.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (RPC._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            RPC.prototype._syncTable = /** @inline */function (pFrom) {
                (RPC._pEventTable)._sync(this, pFrom);
            };
            RPC.prototype.joined = function () {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((RPC._pEventTable))).broadcast[(this._iGuid)] = (((RPC._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).joined;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            RPC.requestPool = new akra.ObjectArray();
            RPC.callbackPool = new akra.ObjectArray();
            RPC.OPTIONS = {
                deferredCallsLimit: 20000,
                reconnectTimeout: 2500,
                systemRoutineInterval: 10000,
                callbackLifetime: 60000,
                procListName: "proc_list",
                callsFrequency: -1
            };
            RPC.ERRORS = {
                STACK_SIZE_EXCEEDED: new Error("stack size exceeded"),
                CALLBACK_LIFETIME_EXPIRED: new Error("procedure life time expired")
            };
            return RPC;
        })();        
                        function createRpc(addr, opt) {
            if (arguments.length == 1) {
                if ((typeof (addr) === "string")) {
                    return new RPC(addr);
                }
                return new RPC(null, arguments[0]);
            }
            return new RPC(addr, opt);
        }
        net.createRpc = createRpc;
    })(akra.net || (akra.net = {}));
    var net = akra.net;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (terrain) {
        var MegaTexture = (function () {
            function MegaTexture(pEngine) {
                this._pEngine = null;
                // private _pDevice = null;
                this._pObject = null;
                this._pWorldExtents = null;
                //Координаты камеры на объекте
                this._v2fCameraCoord = new akra.Vec2(0, 0);
                //Путь откуда запрашиваются куски текстуры
                this._sSurfaceTextures = "";
                //Маскимальный размер стороны текстуры
                this._v2iOriginalTextreMaxSize = new akra.Vec2(1024 * 32.);
                this._v2iOriginalTextreMinSize = new akra.Vec2(1024 * 4.);
                this._v2iTextureLevelSize = new akra.Vec2(1024);
                this._iMinLevel = 0;
                this._iMaxLevel = 0;
                //Тип хранимых тектсур
                this._eTextureFormat = akra.EPixelFormats.BYTE_RGB;
                //Размер блока текстуры(минимальный размер выгружаемого куска текстуры)
                this._iBlockSize = 32;
                this._iBufferWidth = 0;
                this._iBufferHeight = 0;
                this._pTextures = null;
                this._pTextureForSwap = null;
                //Карта с разметкой буфера, чтобы знать какой части буффер уже отсылалось задание на заполнение
                this._pSectorLoadInfo = null;
                this._pXY = null;
                //Всякие темповые буферы
                this._pLoadInfoForSwap = null;
                this._pDefaultSectorLoadInfo = null;
                this._pRPC = null;
                this._fTexCourdXOld = 0xFFFFFFFF;
                this._fTexCourdYOld = 0xFFFFFFFF;
                this._nCountRender = 0;
                this._iSectorLifeTime = 60000;
                this._pSamplerUniforms = null;
                this._pLoadStatusUniforms = null;
                this._pTexcoordOffsetUniforms = null;
                this._bError = false;
                this._tLastTime = 0;
                this._fThresHold = 0.1;
                this._bColored = false;
                this._iTrafficCounter = 0;
                this._iResponseCount = 0;
                this._iQueryCount = 0;
                this._fnPRCCallBack = null;
                this.pDataList = new Array(8);
                this._pEngine = pEngine;
            }
            MegaTexture.prototype.init = function (pObject, sSurfaceTextures) {
                this._pObject = pObject;
                this._pWorldExtents = pObject.localBounds;
                this._sSurfaceTextures = sSurfaceTextures;
                if (!this.checkTextureSizeSettings()) {
 {
                        akra.logger.setSourceLocation("terrain/MegaTexture.ts", 86);
                        akra.logger.criticalError("Wrong texture size settings for MegaTexture");
                    }
                    ;
                }
                var iCountTex = this._iMaxLevel - this._iMinLevel + 1;
                this._pTextures = new Array(iCountTex);
                this._pSectorLoadInfo = new Array(iCountTex);
                this._pXY = new Array(iCountTex);
                this._iBufferWidth = this._v2iTextureLevelSize.x * 1;
                this._iBufferHeight = this._v2iTextureLevelSize.y * 1;
                this._pLoadInfoForSwap = new Uint32Array(this._v2iTextureLevelSize.y * this._v2iTextureLevelSize.x / (this._iBlockSize * this._iBlockSize));
                this._pDefaultSectorLoadInfo = new Uint32Array(this._v2iTextureLevelSize.y * this._v2iTextureLevelSize.x / (this._iBlockSize * this._iBlockSize));
                for(var i = 0; i < this._pDefaultSectorLoadInfo.length; i++) {
                    this._pDefaultSectorLoadInfo[i] = 0;
                }
                this.setSectorLoadInfoToDefault(this._pLoadInfoForSwap);
                //Создаем куски мегатекстуры
                var pRmgr = this._pEngine.getResourceManager();
                this._pTextureForSwap = pRmgr.createTexture(".texture-for-mega-swap_" + akra.sid());
                this._pTextureForSwap.create(this._v2iTextureLevelSize.x, this._v2iTextureLevelSize.y, 1, null, akra.ETextureFlags.DYNAMIC, 0, 1, akra.ETextureTypes.TEXTURE_2D, this._eTextureFormat);
                this._pTextureForSwap.setWrapMode(akra.ETextureParameters.WRAP_S, akra.ETextureWrapModes.CLAMP_TO_EDGE);
                this._pTextureForSwap.setWrapMode(akra.ETextureParameters.WRAP_T, akra.ETextureWrapModes.CLAMP_TO_EDGE);
                //create texture levels
                for(var i = 0; i < this._pTextures.length; i++) {
                    this._pTextures[i] = pRmgr.createTexture(".texture-for-mega-" + i + "_" + akra.sid());
                    if (i === 0) {
                        this._pTextures[i].create(this._v2iOriginalTextreMinSize.x, this._v2iOriginalTextreMinSize.y, 1, null, akra.ETextureFlags.DYNAMIC, 0, 1, akra.ETextureTypes.TEXTURE_2D, akra.EPixelFormats.BYTE_RGB);
                        /*this._v2iTextureLevelSize.y * this._v2iTextureLevelSize.x*/
                        this._pSectorLoadInfo[i] = new Uint32Array(this._v2iOriginalTextreMinSize.y * this._v2iOriginalTextreMinSize.x / (this._iBlockSize * this._iBlockSize));
                        this._pXY[i] = {
                            iX: /*Координты буфера в основной текстуре, для простыты должны быть кратну размеру блока*/
                            0,
                            iY: 0,
                            iTexX: /*Координаты мегатекстуры в текстуре*/
                            0,
                            iTexY: 0,
                            width: this._v2iOriginalTextreMinSize.x,
                            height: this._v2iOriginalTextreMinSize.y,
                            isUpdated: true,
                            isLoaded: false
                        };
                    } else {
                        this._pTextures[i].create(this._v2iTextureLevelSize.x, this._v2iTextureLevelSize.y, 1, null, akra.ETextureFlags.DYNAMIC, 0, 1, akra.ETextureTypes.TEXTURE_2D, this._eTextureFormat);
                        this._pSectorLoadInfo[i] = new Uint32Array(this._v2iTextureLevelSize.y * this._v2iTextureLevelSize.x / (this._iBlockSize * this._iBlockSize));
                        this.setSectorLoadInfoToDefault(this._pSectorLoadInfo[i]);
                        this._pTextures[i].setWrapMode(akra.ETextureParameters.WRAP_S, akra.ETextureWrapModes.CLAMP_TO_EDGE);
                        this._pTextures[i].setWrapMode(akra.ETextureParameters.WRAP_T, akra.ETextureWrapModes.CLAMP_TO_EDGE);
                        this._pXY[i] = {
                            iX: /*Координты буфера в основной текстуре, для простыты должны быть кратну размеру блока*/
                            0,
                            iY: 0,
                            iTexX: /*Координаты мегатекстуры в текстуре*/
                            0,
                            iTexY: 0,
                            width: this._pTextures[i].width,
                            height: this._pTextures[i].height,
                            isUpdated: true,
                            isLoaded: false
                        };
                    }
                }
                this.createUniforms();
                this.testDataInit();
                this._pRPC = akra.net.createRpc();
                this._pRPC.join("ws://192.168.88.53:6112");
                this._pRPC.setProcedureOption("getMegaTexture", "lifeTime", 60000);
                this._pRPC.setProcedureOption("getMegaTexture", "priority", 1);
                this.loadMinTextureLevel();
            };
            MegaTexture.prototype.prepareForRender = function (pViewport) {
                if (this._bError) {
 {
                        akra.logger.setSourceLocation("terrain/MegaTexture.ts", 170);
                        akra.logger.criticalError("ERROR");
                    }
                    ;
                }
                if (!this._pXY[0].isLoaded) {
                    this.loadMinTextureLevel();
                    return;
                }
                var tCurrentTime = (this._pEngine.getTimer().absoluteTime * 1000) >>> 0;
                if (tCurrentTime - this._tLastTime < 30) {
                    return;
                }
                this._tLastTime = tCurrentTime;
                var pCamera = pViewport.getCamera();
                var v4fCameraCoord = akra.Vec4.stackCeil.set(pCamera.worldPosition, 1.);
                var m4fTransposeInverse = this._pObject.inverseWorldMatrix;
                v4fCameraCoord = m4fTransposeInverse.multiplyVec4(v4fCameraCoord);
                //Вычисление текстурных координат над которыми находиться камера
                var fTexCourdX = (v4fCameraCoord.x - this._pWorldExtents.x0) / akra.math.abs(this._pWorldExtents.x1 - this._pWorldExtents.x0);
                var fTexCourdY = (v4fCameraCoord.y - this._pWorldExtents.y0) / akra.math.abs(this._pWorldExtents.y1 - this._pWorldExtents.y0);
                this._v2fCameraCoord.set(fTexCourdX, fTexCourdY);
                var iX = 0, iX1 = 0, iX2 = 0;
                var iY = 0, iY1 = 0, iY2 = 0;
                var iWidth = 0, iHeight = 0;
                //Нужно ли перекладвывать, отсавим на запас 8 блоков
                //Опираемся на текстуру самого хорошего разрешения
                //Координаты квадрата this._v2iTextureLevelSize.x Х this._v2iTextureLevelSize.y с центром в камере на текстуре самого большого разрешения.
                iX = akra.math.round(fTexCourdX * (this.getWidthOrig(this._pTextures.length - 1)) - this._v2iTextureLevelSize.x / 2);
                iY = akra.math.round(fTexCourdY * (this.getHeightOrig(this._pTextures.length - 1)) - this._v2iTextureLevelSize.y / 2);
                iWidth = this._v2iTextureLevelSize.x;
                iHeight = this._v2iTextureLevelSize.y;
                // Перемещаем данные из одного пиксель буффера в другой
                if ((this._fTexCourdXOld !== fTexCourdX || this._fTexCourdYOld !== fTexCourdY)) {
                    //Перемещаем
                    //Для всех уровней текстур
                    for(i = 1; i < this._pTextures.length; i++) {
                        // LOG("Уровень", i)
                        //Вычисляем новые координаты буфера в текстуре
                        var iXnew = akra.math.round(fTexCourdX * this.getWidthOrig(i) - this._v2iTextureLevelSize.x / 2);
                        var iYnew = akra.math.round(fTexCourdY * this.getHeightOrig(i) - this._v2iTextureLevelSize.y / 2);
                        // iXnew -= (this._iBufferWidth - this._v2iTextureLevelSize.x) / 2;
                        // iYnew -= (this._iBufferHeight - this._v2iTextureLevelSize.y) / 2;
                        //Округлили на размер блока
                        iXnew = akra.math.round((iXnew / this._iBlockSize)) * this._iBlockSize;
                        iYnew = akra.math.round((iYnew / this._iBlockSize)) * this._iBlockSize;
                        //Копирование совпадающего куска
                        var iXOverlappingBlockInOldBuf = iXnew - this._pXY[i].iX;
                        var iYOverlappingBlockInOldBuf = iYnew - this._pXY[i].iY;
                        var iXOverlappingBlockInNewBuf = -iXOverlappingBlockInOldBuf;
                        var iYOverlappingBlockInNewBuf = -iYOverlappingBlockInOldBuf;
                        iXOverlappingBlockInOldBuf = akra.math.max(0, iXOverlappingBlockInOldBuf);
                        iYOverlappingBlockInOldBuf = akra.math.max(0, iYOverlappingBlockInOldBuf);
                        iXOverlappingBlockInNewBuf = akra.math.max(0, iXOverlappingBlockInNewBuf);
                        iYOverlappingBlockInNewBuf = akra.math.max(0, iYOverlappingBlockInNewBuf);
                        if (iXOverlappingBlockInOldBuf < this._iBufferWidth && iYOverlappingBlockInOldBuf < this._iBufferHeight && iXOverlappingBlockInNewBuf < this._iBufferWidth && iYOverlappingBlockInNewBuf < this._iBufferHeight) {
                            //произошло совпадение кусков
                            var iOverlappingBlockWidth = this._iBufferWidth - akra.math.abs(iXnew - this._pXY[i].iX);
                            var iOverlappingBlockHeight = this._iBufferHeight - akra.math.abs(iYnew - this._pXY[i].iY);
                            //копируем данные
                            var pSwapBuffer = this._pTextureForSwap.getBuffer(0, 0);
                            var pTextureBuffer = this._pTextures[i].getBuffer(0, 0);
                            var pTmpBox1 = akra.geometry.box(iXOverlappingBlockInNewBuf, iYOverlappingBlockInNewBuf, iOverlappingBlockWidth + iXOverlappingBlockInNewBuf, iOverlappingBlockHeight + iYOverlappingBlockInNewBuf);
                            var pTmpBox2 = akra.geometry.box(iXOverlappingBlockInOldBuf, iYOverlappingBlockInOldBuf, iOverlappingBlockWidth + iXOverlappingBlockInOldBuf, iOverlappingBlockHeight + iYOverlappingBlockInOldBuf);
                            var pTmpBox3 = akra.geometry.box(0, 0, this._v2iTextureLevelSize.x, this._v2iTextureLevelSize.y);
                            var pTempPixelBox = akra.pixelUtil.pixelBox(pTmpBox3, this._eTextureFormat);
                            pTempPixelBox.data = null;
                            /* Save overlapped data */
                            pSwapBuffer.blit(pTextureBuffer, pTmpBox2, pTmpBox2);
                            /* Clear texture */
                            pTextureBuffer.blitFromMemory(pTempPixelBox, pTmpBox3);
                            /* Put overlapperd data */
                            pTextureBuffer.blit(pSwapBuffer, pTmpBox2, pTmpBox1);
                            this.setSectorLoadInfoToDefault(this._pLoadInfoForSwap);
                            // LOG(iXOverlappingBlockInOldBuf + " ---> " + iXOverlappingBlockInNewBuf,
                            // 	iYOverlappingBlockInOldBuf + " ---> " + iYOverlappingBlockInNewBuf);
                            this._setDataBetweenBufferMap(this._pLoadInfoForSwap, iXOverlappingBlockInNewBuf / this._iBlockSize, iYOverlappingBlockInNewBuf / this._iBlockSize, this._pSectorLoadInfo[i], iXOverlappingBlockInOldBuf / this._iBlockSize, iYOverlappingBlockInOldBuf / this._iBlockSize, iOverlappingBlockWidth / this._iBlockSize, iOverlappingBlockHeight / this._iBlockSize);
                            var s = this._pSectorLoadInfo[i];
                            this._pSectorLoadInfo[i] = this._pLoadInfoForSwap;
                            this._pLoadInfoForSwap = s;
                        } else {
                            var pTextureBuffer = this._pTextures[i].getBuffer(0, 0);
                            var pTmpBox3 = akra.geometry.box(0, 0, this._v2iTextureLevelSize.x, this._v2iTextureLevelSize.y);
                            var pTempPixelBox = akra.pixelUtil.pixelBox(pTmpBox3, this._eTextureFormat);
                            pTempPixelBox.data = null;
                            pTextureBuffer.blitFromMemory(pTempPixelBox, pTmpBox3);
                            this.setSectorLoadInfoToDefault(this._pSectorLoadInfo[i]);
                        }
                        this._pXY[i].iX = iXnew;
                        this._pXY[i].iY = iYnew;
                    }
                }
                //Подгрузка части буфера которую ложиться в текстуру + 8 блоков
                //Нулевая статична, поэтому ее не меняем
                for(var i = 1; i < this._pTextures.length; i++) {
                    // for (var i: uint = this._pTextures.length - 1; i >= 1; i--) {
                    iX = akra.math.round(fTexCourdX * this.getWidthOrig(i) - this._v2iTextureLevelSize.x / 2);
                    iY = akra.math.round(fTexCourdY * this.getHeightOrig(i) - this._v2iTextureLevelSize.y / 2);
                    iX = akra.math.round((iX / this._iBlockSize)) * this._iBlockSize;
                    iY = akra.math.round((iY / this._iBlockSize)) * this._iBlockSize;
                    this._pXY[i].iTexX = iX / this.getWidthOrig(i);
                    this._pXY[i].iTexY = iY / this.getHeightOrig(i);
                    iWidth = this._v2iTextureLevelSize.x;
                    iHeight = this._v2iTextureLevelSize.y;
                    //На данный момент нужен кусок текстуры таких размеров iX1,iY1,iWidth,iHeight,
                    var iAreaX1 = iX;
                    var iAreaY1 = iY;
                    var iAreaX2 = iX + iWidth;
                    var iAreaY2 = iY + iHeight;
                    //Смотрим попадаем ли мы в текущий буфер
                    //Типа попали
                    //Значит нужно загрузить необходимые куски
                    //Обрезаемся чтобы не вылезти за пределы
                    // iX -= this._iBlockSize * 8;
                    // iY -= this._iBlockSize * 8;
                    // iWidth += this._iBlockSize * 16;
                    // iHeight += this._iBlockSize * 16;
                    iX1 = (/*checked (origin: math)>>*/akra.math.max((0), /*checked (origin: math)>>*/akra.math.min((iX), (this.getWidthOrig(i)))));
                    iY1 = (/*checked (origin: math)>>*/akra.math.max((0), /*checked (origin: math)>>*/akra.math.min((iY), (this.getHeightOrig(i)))));
                    iX2 = (/*checked (origin: math)>>*/akra.math.max((0), /*checked (origin: math)>>*/akra.math.min((iX + iWidth), (this.getWidthOrig(i)))));
                    iY2 = (/*checked (origin: math)>>*/akra.math.max((0), /*checked (origin: math)>>*/akra.math.min((iY + iHeight), (this.getHeightOrig(i)))));
                    var iAreaX1 = (/*checked (origin: math)>>*/akra.math.max((0), /*checked (origin: math)>>*/akra.math.min((iAreaX1), (this.getWidthOrig(i)))));
                    var iAreaY1 = (/*checked (origin: math)>>*/akra.math.max((0), /*checked (origin: math)>>*/akra.math.min((iAreaY1), (this.getHeightOrig(i)))));
                    var iAreaX2 = (/*checked (origin: math)>>*/akra.math.max((0), /*checked (origin: math)>>*/akra.math.min((iAreaX2), (this.getWidthOrig(i)))));
                    var iAreaY2 = (/*checked (origin: math)>>*/akra.math.max((0), /*checked (origin: math)>>*/akra.math.min((iAreaY2), (this.getHeightOrig(i)))));
                    if (this._pXY[i - 1].isLoaded) {
                        /*Остальные область проверки*/
                        this.getDataFromServer(i, iX1, iY1, iX2 - iX1, iY2 - iY1, iAreaX1, iAreaY1, iAreaX2 - iAreaX1, iAreaY2 - iAreaY1);
                    } else {
                        this._pXY[i].isLoaded = false;
                    }
                    // this.getDataFromServer(i, iX1, iY1, iX2 - iX1, iY2 - iY1, /*Остальные область проверки*/iAreaX1,
                    //                        iAreaY1, iAreaX2 - iAreaX1, iAreaY2 - iAreaY1);
                                    }
                this._fTexCourdXOld = fTexCourdX;
                this._fTexCourdYOld = fTexCourdY;
            };
            MegaTexture.prototype.applyForRender = function (pRenderPass) {
                pRenderPass.setForeign("nTotalLevels", this._iMaxLevel - this._iMinLevel + 1);
                pRenderPass.setUniform("MIN_MEGATEXTURE_LEVEL", this._iMinLevel);
                pRenderPass.setUniform("threshold", this._fThresHold);
                pRenderPass.setUniform("bColored", this._bColored);
                for(var i = 0; i < this._pTextures.length; i++) {
                    this._pLoadStatusUniforms[i] = this._pXY[i].isLoaded ? 1 : 0;
                    this._pTexcoordOffsetUniforms[i].set(this._pXY[i].iTexX, this._pXY[i].iTexY);
                    this._pSamplerUniforms[i].texture = this._pTextures[i];
                }
                pRenderPass.setUniform("S_TERRAIN", this._pSamplerUniforms);
                pRenderPass.setUniform("TEXTURE_LOAD_STATUS", this._pLoadStatusUniforms);
                pRenderPass.setUniform("TEXTURE_LEVEL_OFFSET", this._pTexcoordOffsetUniforms);
            };
            MegaTexture.prototype.getWidthOrig = function (iLevel) {
                return this._v2iTextureLevelSize.x << (this._iMinLevel + iLevel);
            };
            MegaTexture.prototype.getHeightOrig = function (iLevel) {
                return this._v2iTextureLevelSize.y << (this._iMinLevel + iLevel);
            };
            MegaTexture.prototype.checkTextureSizeSettings = /**@protected*/ function () {
                var v2iCountTexMin = akra.Vec2.stackCeil.set();
                var v2iCountTexMax = akra.Vec2.stackCeil.set();
                v2iCountTexMin.x = (/*checked (origin: math)>>*/akra.math.log((this._v2iOriginalTextreMinSize.x / this._v2iTextureLevelSize.x)) / /*checked (origin: math)>>*/akra.math.LN2);
                v2iCountTexMin.y = (/*checked (origin: math)>>*/akra.math.log((this._v2iOriginalTextreMinSize.y / this._v2iTextureLevelSize.y)) / /*checked (origin: math)>>*/akra.math.LN2);
                v2iCountTexMax.x = (/*checked (origin: math)>>*/akra.math.log((this._v2iOriginalTextreMaxSize.x / this._v2iTextureLevelSize.x)) / /*checked (origin: math)>>*/akra.math.LN2);
                v2iCountTexMax.y = (/*checked (origin: math)>>*/akra.math.log((this._v2iOriginalTextreMaxSize.y / this._v2iTextureLevelSize.y)) / /*checked (origin: math)>>*/akra.math.LN2);
                if (v2iCountTexMin.x !== v2iCountTexMin.y || v2iCountTexMax.x !== v2iCountTexMax.y) {
                    return false;
                }
                if (v2iCountTexMax.x < v2iCountTexMin.x) {
                    return false;
                }
                this._iMinLevel = v2iCountTexMin.x;
                this._iMaxLevel = v2iCountTexMax.x;
                return true;
            };
            MegaTexture.prototype.createUniforms = /**@protected*/ function () {
                var iCountTex = this._iMaxLevel - this._iMinLevel + 1;
                this._pSamplerUniforms = new Array(iCountTex);
                this._pLoadStatusUniforms = new Array(iCountTex);
                this._pTexcoordOffsetUniforms = new Array(iCountTex);
                for(var i = 0; i < iCountTex; i++) {
                    this._pSamplerUniforms[i] = {
                        textureName: "",
                        texture: this._pTextures[i],
                        wrap_s: akra.ETextureWrapModes.CLAMP_TO_EDGE,
                        wrap_t: akra.ETextureWrapModes.CLAMP_TO_EDGE,
                        mag_filter: akra.ETextureFilters.LINEAR,
                        min_filter: akra.ETextureFilters.LINEAR
                    };
                    this._pLoadStatusUniforms[i] = 0;
                    this._pTexcoordOffsetUniforms[i] = new akra.Vec2();
                }
            };
            MegaTexture.prototype.loadMinTextureLevel = /**@protected*/ function () {
                var me = this;
                var tCurrentTime = (this._pEngine.getTimer().absoluteTime * 1000) >>> 0;
                if (tCurrentTime - this._pSectorLoadInfo[0][0] > 120000) {
                    this._pSectorLoadInfo[0][0] = tCurrentTime;
                    var sExt = "jpg";
                    this._pRPC.proc('loadMegaTexture', me._sSurfaceTextures, sExt, me._v2iOriginalTextreMinSize.x, me._v2iOriginalTextreMinSize.x, function (pError, pData) {
                        if (me._pXY[0].isLoaded) {
                            return;
                        }
                        if (!((pError) === null)) {
 {
                                akra.logger.setSourceLocation("terrain/MegaTexture.ts", 456);
                                akra.logger.log(pError.message);
                            }
                            ;
                            return;
                        }
                        var pTempImg = me._pEngine.getResourceManager().imagePool.findResource(".megatexture.temp_image");
                        if (((pTempImg) === null)) {
                            pTempImg = me._pEngine.getResourceManager().imagePool.createResource(".megatexture.temp_image");
                        }
                        pTempImg.load(pData, sExt, function (isLoaded) {
                            me._pTextures[0].destroyResource();
                            me._pTextures[0].loadImage(pTempImg);
                            me._pXY[0].isLoaded = true;
                            pTempImg.destroyResource();
                        });
                    });
                }
                // this.getDataFromServer(0, 0, 0, this._v2iOriginalTextreMinSize.x, this._v2iOriginalTextreMinSize.y);
                            };
            MegaTexture.prototype.getDataFromServer = /**@protected*/ function (iLevelTex, iOrigTexX, iOrigTexY, iWidth, iHeight, iAreaX, iAreaY, iAreaWidth, iAreaHeight) {
                /** this._pXY[iLevelTex].width / this._v2iTextureLevelSize.x*/
                var iBlockSize = this._iBlockSize;
                var iOrigTexEndX = akra.math.ceil((iOrigTexX + iWidth) / iBlockSize) * iBlockSize;
                var iOrigTexEndY = akra.math.ceil((iOrigTexY + iHeight) / iBlockSize) * iBlockSize;
                iOrigTexX = akra.math.max(0, iOrigTexX);
                iOrigTexY = akra.math.max(0, iOrigTexY);
                // iOrigTexX = math.floor(iOrigTexX / iBlockSize) * iBlockSize;
                // iOrigTexY = math.floor(iOrigTexY / iBlockSize) * iBlockSize;
                iOrigTexEndX = akra.math.min(iOrigTexEndX, this.getWidthOrig(iLevelTex));
                iOrigTexEndY = akra.math.min(iOrigTexEndY, this.getHeightOrig(iLevelTex));
                var iAreaEndX = iAreaX + iAreaWidth;
                var iAreaEndY = iAreaY + iAreaHeight;
                iAreaX = akra.math.max(0, iAreaX);
                iAreaY = akra.math.max(0, iAreaY);
                iAreaEndX = akra.math.min(iAreaEndX, this.getWidthOrig(iLevelTex));
                iAreaEndY = akra.math.min(iAreaEndY, this.getHeightOrig(iLevelTex));
                var isLoaded = true;
                var tCurrentTime = (this._pEngine.getTimer().absoluteTime * 1000) >>> 0;
                for(var i = iOrigTexY; i < iOrigTexEndY; i += iBlockSize) {
                    for(var j = iOrigTexX; j < iOrigTexEndX; j += iBlockSize) {
                        var iSectorInfoCoord = (i - this._pXY[iLevelTex].iY) / iBlockSize * (this._pXY[iLevelTex].width / iBlockSize) + (j - this._pXY[iLevelTex].iX) / iBlockSize;
                        if (this._pSectorLoadInfo[iLevelTex][iSectorInfoCoord] !== 0xFFFFFFFF) {
                            isLoaded = false;
                        }
                        if (tCurrentTime - this._pSectorLoadInfo[iLevelTex][iSectorInfoCoord] < this._iSectorLifeTime) {
                            continue;
                        }
                        if (this._pSectorLoadInfo[iLevelTex][iSectorInfoCoord] === 0xFFFFFFFF) {
                            continue;
                        }
                        this._pSectorLoadInfo[iLevelTex][iSectorInfoCoord] = tCurrentTime;
                        var iLev = iLevelTex;
                        var iX = j, iY = i;
                        var iXBuf = j - this._pXY[iLevelTex].iX;
                        var iYBuf = i - this._pXY[iLevelTex].iY;
                        if (iXBuf < 0 || iXBuf > this._pXY[iLevelTex].width - iBlockSize || iYBuf < 0 || iYBuf > this._pXY[iLevelTex].height - iBlockSize) {
                            return;
                        }
                        this._iQueryCount++;
                        this.getDataByRPC(iLevelTex, j, i, iBlockSize);
                    }
                }
                this._pXY[iLevelTex].isLoaded = isLoaded;
            };
            MegaTexture.prototype._printTraffic = function () {
 {
                    akra.logger.setSourceLocation("terrain/MegaTexture.ts", 549);
                    akra.logger.log(this._iTrafficCounter / 1000000 + "Mb", this._iQueryCount + "/" + this._iResponseCount);
                }
                ;
            };
            MegaTexture.prototype.getDataByRPC = function (iLev, iX, iY, iBlockSize) {
                var me = this;
                if (((this._fnPRCCallBack) === null)) {
                    this._fnPRCCallBack = function (pError, pData) {
                        if (!((pError) === null)) {
                            // debug_print(pError.message);
                            return;
                        }
                        me._iTrafficCounter += pData.length;
                        var pHeaderData = new Uint16Array(pData.buffer, pData.byteOffset, 4);
                        var pTextureData = pData.subarray(8);
                        var iLev = (/*checked (origin: math)>>*/akra.math.log((pHeaderData[0] / me._v2iTextureLevelSize.x)) / /*checked (origin: math)>>*/akra.math.LN2) - me._iMinLevel;
                        var iBlockSize = pHeaderData[1];
                        var iX = pHeaderData[2];
                        var iY = pHeaderData[3];
                        // var pTextureData = this.pDataList[this._iMinLevel + iLev];
                        // pHeaderData.set(pData.subarray(0, 8));
                        var iXBuf = iX - me._pXY[iLev].iX;
                        var iYBuf = iY - me._pXY[iLev].iY;
                        if (iXBuf < 0 || iXBuf > me._pXY[iLev].width - iBlockSize || iYBuf < 0 || iYBuf > me._pXY[iLev].height - iBlockSize) {
                            return;
                        }
                        var iSectorInfoCoord = iYBuf / iBlockSize * (me._pXY[iLev].width / iBlockSize) + iXBuf / iBlockSize;
                        if (me._pSectorLoadInfo[iLev][iSectorInfoCoord] === 0xFFFFFFFF) {
                            return;
                        }
                        me._iResponseCount++;
                        me._pSectorLoadInfo[iLev][iSectorInfoCoord] = 0xFFFFFFFF;
                        var pTmpBox1 = akra.geometry.box(0, 0, iBlockSize, iBlockSize);
                        var pTmpBox2 = akra.geometry.box(iXBuf, iYBuf, iBlockSize + iXBuf, iBlockSize + iYBuf);
                        var pSourceBox = akra.pixelUtil.pixelBox(pTmpBox1, me._eTextureFormat, pTextureData);
                        me._pTextures[iLev].getBuffer(0, 0).blitFromMemory(pSourceBox, pTmpBox2);
                        pSourceBox.data = null;
                    };
                }
                this._pRPC.proc('getMegaTexture', me._sSurfaceTextures, me.getWidthOrig(iLev), me.getHeightOrig(iLev), iX, iY, iBlockSize, iBlockSize, me._eTextureFormat, this._fnPRCCallBack);
            };
            MegaTexture.prototype.setDataT = /**@protected*/ function (pBuffer, iX, iY, iWidth, iHeight, pBufferIn, iInX, iInY, iInWidth, iInHeight, iBlockWidth, iBlockHeight, iComponents) {
                iBlockHeight = akra.math.max(0, iBlockHeight);
                iBlockWidth = akra.math.max(0, iBlockWidth);
                iBlockHeight = akra.math.min(iBlockHeight, iHeight - iY, iInHeight - iInY);
                iBlockWidth = akra.math.min(iBlockWidth, iWidth - iX, iInWidth - iInX);
                if (pBuffer.length < ((iY + iBlockHeight - 1) * iWidth + iX + iBlockWidth) * iComponents) {
 {
                        akra.logger.setSourceLocation("terrain/MegaTexture.ts", 616);
                        akra.logger.error("Выход за предел массива 1");
                    }
                    ;
                }
                if (pBufferIn.length < ((iInY + iBlockHeight - 1) * iInWidth + iInX + iBlockWidth) * iComponents) {
 {
                        akra.logger.setSourceLocation("terrain/MegaTexture.ts", 619);
                        akra.logger.error("Выход за предел массива 2");
                    }
                    ;
                }
                var iLenStr = iBlockWidth * iComponents;
                var iStartIn = 0;
                var iStartOut = 0;
                for(var i = 0; i < iBlockHeight; i++) {
                    iStartIn = ((iInY + i) * iInWidth + iInX) * iComponents;
                    iStartOut = ((iY + i) * iWidth + iX) * iComponents;
                    if (pBufferIn.BYTES_PER_ELEMENT == 8) {
                        pBuffer.set(new Float64Array(pBufferIn.buffer.slice(iStartIn * 8, (iStartIn + iLenStr) * 8)), iStartOut);
                    } else if (pBufferIn.BYTES_PER_ELEMENT == 4) {
                        pBuffer.set(new Uint32Array(pBufferIn.buffer.slice(iStartIn * 4, (iStartIn + iLenStr) * 4)), iStartOut);
                    } else if (pBufferIn.BYTES_PER_ELEMENT == 2) {
                        pBuffer.set(new Uint16Array(pBufferIn.buffer.slice(iStartIn * 2, (iStartIn + iLenStr) * 2)), iStartOut);
                    } else {
                        pBuffer.set(new Uint8Array(pBufferIn.buffer.slice(iStartIn, iStartIn + iLenStr)), iStartOut);
                    }
                }
            };
            MegaTexture.prototype._setDataBetweenBufferMap = function (pBuffer, iX, iY, pBufferIn, iInX, iInY, iBlockWidth, iBlockHeight) {
                var iInWidth = this._iBufferWidth / this._iBlockSize;
                var iInHeight = this._iBufferHeight / this._iBlockSize;
                var iComponents = 1;
                var iWidth = this._iBufferWidth / this._iBlockSize;
                var iHeight = this._iBufferHeight / this._iBlockSize;
                this.setDataT(pBuffer, iX, iY, iWidth, iHeight, pBufferIn, iInX, iInY, iInWidth, iInHeight, iBlockWidth, iBlockHeight, iComponents);
            };
            MegaTexture.prototype.setSectorLoadInfoToDefault = /**@protected*/ function (pBuffer) {
                pBuffer.set(this._pDefaultSectorLoadInfo, 0);
            };
            MegaTexture.prototype.testDataInit = function () {
                for(var i = 0; i < this.pDataList.length; i++) {
                    this.pDataList[i] = new Uint8Array(this._iBlockSize * this._iBlockSize * 3);
                    var iLev = i;
                    var pData = this.pDataList[i];
                    for(var k = 0; k < pData.length; k += 3) {
                        if (iLev === 0) {
                            pData[k] = 0;
                            pData[k + 1] = 255;
                            pData[k + 2] = 0;
                        } else if (iLev === 1) {
                            pData[k] = 255;
                            pData[k + 1] = 0;
                            pData[k + 2] = 0;
                        } else if (iLev === 2) {
                            pData[k] = 0;
                            pData[k + 1] = 0;
                            pData[k + 2] = 255;
                        } else if (iLev === 3) {
                            pData[k] = 255;
                            pData[k + 1] = 0;
                            pData[k + 2] = 255;
                        } else if (iLev === 4) {
                            pData[k] = 255;
                            pData[k + 1] = 255;
                            pData[k + 2] = 0;
                        } else if (iLev === 5) {
                            pData[k] = 0;
                            pData[k + 1] = 255;
                            pData[k + 2] = 255;
                        } else {
                            pData[k] = 170;
                            pData[k + 1] = 50;
                            pData[k + 2] = 170;
                        }
                    }
                }
            };
            return MegaTexture;
        })();
        terrain.MegaTexture = MegaTexture;        
    })(akra.terrain || (akra.terrain = {}));
    var terrain = akra.terrain;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (terrain) {
        var TerrainSection = (function (_super) {
            __extends(TerrainSection, _super);
            function TerrainSection(pScene, eType) {
                if (typeof eType === "undefined") { eType = akra.EEntityTypes.TERRAIN_SECTION; }
                        _super.call(this, pScene, eType);
                this._pTerrainSystem = null;
                /**@protected*/ this._iVertexID = 0;
                //Ее коорлинаты на карте высот
                /**@protected*/ this._iHeightMapX = 0;
                /**@protected*/ this._iHeightMapY = 0;
                //номер сектора по иксу и по игрику
                /**@protected*/ this._iSectorX = 0;
                /**@protected*/ this._iSectorY = 0;
                //Ращмеры сетки вершин
                /**@protected*/ this._iXVerts = 0;
                /**@protected*/ this._iYVerts = 0;
                //Положение сетора в мире
                /**@protected*/ this._pWorldRect = new akra.geometry.Rect3d();
                this._pRenderableObject = null;
                this._pVertexDescription = null;
            }
            Object.defineProperty(TerrainSection.prototype, "sectorX", {
                get: /** @inline */function () {
                    return this._iSectorX;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainSection.prototype, "sectorY", {
                get: /** @inline */function () {
                    return this._iSectorY;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainSection.prototype, "terrainSystem", {
                get: /** @inline */function () {
                    return this._pTerrainSystem;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainSection.prototype, "sectionIndex", {
                get: /** @inline */function () {
                    return (this._iSectorY * this._pTerrainSystem.sectorCountX + this._iSectorX);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainSection.prototype, "heightX", {
                get: /** @inline */function () {
                    return akra.math.abs(this._pWorldRect.x1 - this._pWorldRect.x0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainSection.prototype, "heightY", {
                get: /** @inline */function () {
                    return akra.math.abs(this._pWorldRect.y1 - this._pWorldRect.y0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainSection.prototype, "vertexDescription", {
                get: /** @inline */function () {
                    return this._pVertexDescription;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainSection.prototype, "totalRenderable", {
                get: /** @inline */function () {
                    return !((this._pRenderableObject) === null) ? 1 : 0;
                },
                enumerable: true,
                configurable: true
            });
            TerrainSection.prototype.getRenderable = /** @inline */function (i) {
                return this._pRenderableObject;
            };
            TerrainSection.prototype._internalCreate = function (pParentSystem, iSectorX, iSectorY, iHeightMapX, iHeightMapY, iXVerts, iYVerts, pWorldRect) {
                var bResult = false;
                this._pTerrainSystem = pParentSystem;
                this._iXVerts = iXVerts;
                this._iYVerts = iYVerts;
                this._iSectorX = iSectorX;
                this._iSectorY = iSectorY;
                this._pWorldRect.x0 = pWorldRect.x0;
                this._pWorldRect.x1 = pWorldRect.x1;
                this._pWorldRect.y0 = pWorldRect.y0;
                //??
                this._pWorldRect.y1 = pWorldRect.y1;
                this._iHeightMapX = iHeightMapX;
                this._iHeightMapY = iHeightMapY;
                if (((this)._pTerrainSystem)._useVertexNormal()) {
                    this._pVertexDescription = [
                        (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.POSITION)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
})), 
                        (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.NORMAL)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
})), 
                        (({
count: (2),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.TEXCOORD)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                    ];
                } else {
                    this._pVertexDescription = [
                        (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.POSITION)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
})), 
                        (({
count: (2),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.TEXCOORD)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                    ];
                }
                bResult = this._createRenderDataForVertexAndIndex();
                bResult = bResult && this._buildVertexBuffer();
                bResult = bResult && this._buildIndexBuffer();
                // set the scene object bounds data
                this.accessLocalBounds().set(this._pWorldRect.x0, this._pWorldRect.x1, this._pWorldRect.y0, this._pWorldRect.y1, this._pWorldRect.z0, this._pWorldRect.z1);
                if (bResult) {
                    this.attachToParent(this._pTerrainSystem);
                    ((this)._eInheritance = (/*checked (origin: akra)>>*/akra.ENodeInheritance.ALL));
                    return true;
                } else {
                    return false;
                }
            };
            TerrainSection.prototype._createRenderable = function () {
                if (((this._pRenderableObject) === null)) {
                    this._pRenderableObject = new akra.render.RenderableObject();
                    this._pRenderableObject._setup(this.scene.getManager().getEngine().getRenderer());
                }
            };
            TerrainSection.prototype._createRenderDataForVertexAndIndex = /**@protected*/ function () {
                var pRenderable = ((this)._pRenderableObject);
                if (((pRenderable) === null)) {
                    return true;
                }
 {
                    akra.logger.setSourceLocation("terrain/TerrainSection.ts", 135);
                    akra.logger.assert(((pRenderable.data) === null), "У терраин сектиона уже созданы данные");
                }
                ;
                pRenderable._setRenderData(((this)._pTerrainSystem).dataFactory.getEmptyRenderData(akra.EPrimitiveTypes.TRIANGLESTRIP, 0));
                if (((pRenderable.data) === null)) {
                    return false;
                }
                return true;
            };
            TerrainSection.prototype._buildVertexBuffer = /**@protected*/ function () {
                this._pWorldRect.z0 = akra.MAX_FLOAT64;
                this._pWorldRect.z1 = akra.MIN_FLOAT64;
                if (!((((this)._pRenderableObject)) === null)) {
                    var nElementSize = 0;
                    if (((this)._pTerrainSystem)._useVertexNormal()) {
                        /*кординаты вершин*/
                        /*нормаль*/
                        /*текстурные координаты*/
                        nElementSize = (3 + 3 + 2);
                    } else {
                        /*кординаты вершин*/
                        /*текстурные координаты*/
                        nElementSize = (3 + 2);
                    }
                    var pVerts = new Array(this._iXVerts * this._iYVerts * nElementSize);
                    var v3fNormal = new akra.Vec3();
                    //размер ячейки сектора
                    var v2fCellSize = new akra.Vec2();
                    v2fCellSize.set((/*checked (origin: akra)>>*/akra.math.abs((this)._pWorldRect.x1 - (this)._pWorldRect.x0)) / (this._iXVerts - 1), //размер сектора/количество ячеек в секторе
                    (/*checked (origin: akra)>>*/akra.math.abs((this)._pWorldRect.y1 - (this)._pWorldRect.y0)) / (this._iYVerts - 1));
                    //Координаты вершина в секторе
                    var v2fVert = new akra.Vec2();
                    v2fVert.set(0.0, 0.0);
                    for(var y = 0; y < this._iYVerts; ++y) {
                        v2fVert.set(this._pWorldRect.x0, y * v2fCellSize.y + this._pWorldRect.y0);
                        for(var x = 0; x < this._iXVerts; ++x) {
                            var fHeight = ((this)._pTerrainSystem).readWorldHeight(this._iHeightMapX + x, this._iHeightMapY + y);
                            pVerts[((y * this._iXVerts) + x) * nElementSize + 0] = v2fVert.x;
                            pVerts[((y * this._iXVerts) + x) * nElementSize + 1] = v2fVert.y;
                            pVerts[((y * this._iXVerts) + x) * nElementSize + 2] = fHeight;
                            if (((this)._pTerrainSystem)._useVertexNormal()) {
                                ((this)._pTerrainSystem).readWorldNormal(v3fNormal, this._iHeightMapX + x, this._iHeightMapY + y);
                                pVerts[((y * this._iXVerts) + x) * nElementSize + 3] = v3fNormal.x;
                                pVerts[((y * this._iXVerts) + x) * nElementSize + 4] = v3fNormal.y;
                                pVerts[((y * this._iXVerts) + x) * nElementSize + 5] = v3fNormal.z;
                                pVerts[((y * this._iXVerts) + x) * nElementSize + 6] = (this._iSectorX + x / (this._iXVerts - 1)) / ((this)._pTerrainSystem).sectorCountX;
                                pVerts[((y * this._iXVerts) + x) * nElementSize + 7] = (this._iSectorY + y / (this._iYVerts - 1)) / ((this)._pTerrainSystem).sectorCountY;
                            } else {
                                pVerts[((y * this._iXVerts) + x) * nElementSize + 3] = (this._iSectorX + x / (this._iXVerts - 1)) / ((this)._pTerrainSystem).sectorCountX;
                                pVerts[((y * this._iXVerts) + x) * nElementSize + 4] = (this._iSectorY + y / (this._iYVerts - 1)) / ((this)._pTerrainSystem).sectorCountY;
                            }
                            this._pWorldRect.z0 = akra.math.min(this._pWorldRect.z0, fHeight);
                            this._pWorldRect.z1 = akra.math.max(this._pWorldRect.z1, fHeight);
                            v2fVert.x += v2fCellSize.x;
                        }
                    }
                    this._iVertexID = ((this)._pRenderableObject).data.allocateData(((this)._pVertexDescription), new Float32Array(pVerts));
                } else {
                    for(var y = 0; y < this._iYVerts; ++y) {
                        for(var x = 0; x < this._iXVerts; ++x) {
                            var fHeight = ((this)._pTerrainSystem).readWorldHeight(this._iHeightMapX + x, this._iHeightMapY + y);
                            this._pWorldRect.z0 = akra.math.min(this._pWorldRect.z0, fHeight);
                            this._pWorldRect.z1 = akra.math.max(this._pWorldRect.z1, fHeight);
                        }
                    }
                }
                return true;
            };
            TerrainSection.prototype._buildIndexBuffer = /**@protected*/ function () {
                if (!((((this)._pRenderableObject)) === null)) {
                    var pIndexList = new Float32Array(TerrainSection.getCountIndexForStripGrid(this._iXVerts, this._iYVerts));
                    TerrainSection.createSingleStripGrid(pIndexList, /*width of grid*/
                    this._iXVerts, /*height of grid*/
                    this._iYVerts, /*horz vertex count per cell*/
                    1, /*vert vertex count per cell*/
                    1, /*horz vertex count in vbuffer*/
                    this._iYVerts, 0);
                    ((this)._pRenderableObject).data.allocateIndex([
                        (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.INDEX0)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                    ], pIndexList);
                    ((this)._pRenderableObject).data.index(this._iVertexID, akra.DeclarationUsages.INDEX0);
                }
                return true;
            };
            TerrainSection.createSingleStripGrid = /**@protected*/ function createSingleStripGrid(pIndexValues, iXVerts, iYVerts, iXStep, iYStep, iSride, iFlags) {
                //TRIANGLESTRIP
                var iTotalStrips = iYVerts - 1;
                var iTotalIndexesPerStrip = iXVerts << 1;
                // the total number of indices is equal
                // to the number of strips times the
                // indices used per strip plus one
                // degenerate triangle between each strip
                //общее количество идексов равно количесву линий умноженному на колчесвто идексов в линии + вырожденный треуголник между полосами
                var iTotalIndexes = (iTotalStrips * iTotalIndexesPerStrip) + (iTotalStrips << 1) - 2;
                if (pIndexValues.length < iTotalIndexes) {
                    return 0;
                }
                var iIndex = 0;
                var iStartVert = 0;
                var iLineStep = iYStep * iSride;
                for(var j = 0; j < iTotalStrips; ++j) {
                    var k = 0;
                    var iVert = iStartVert;
                    // create a strip for this row
                    for(k = 0; k < iXVerts; ++k) {
                        pIndexValues[iIndex++] = iVert;
                        pIndexValues[iIndex++] = iVert + iLineStep;
                        iVert += iXStep;
                    }
                    iStartVert += iLineStep;
                    if (j + 1 < iTotalStrips) {
                        // add a degenerate to attach to
                        // the next row
                        pIndexValues[iIndex++] = (iVert - iXStep) + iLineStep;
                        pIndexValues[iIndex++] = iStartVert;
                    }
                }
                // return
                return iTotalIndexes;
            };
            TerrainSection.getCountIndexForStripGrid = /**@protected*/ function getCountIndexForStripGrid(iXVerts, iYVerts) {
                //TRIANGLESTRIP
                var iTotalStrips = iYVerts - 1;
                var iTotalIndexesPerStrip = iXVerts << 1;
                var iTotalIndexes = (iTotalStrips * iTotalIndexesPerStrip) + (iTotalStrips << 1) - 2;
                return iTotalIndexes;
            };
            return TerrainSection;
        })(akra.scene.SceneObject);
        terrain.TerrainSection = TerrainSection;        
    })(akra.terrain || (akra.terrain = {}));
    var terrain = akra.terrain;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (terrain) {
        var Terrain = (function (_super) {
            __extends(Terrain, _super);
            function Terrain(pScene, eType) {
                if (typeof eType === "undefined") { eType = akra.EEntityTypes.TERRAIN; }
                        _super.call(this, pScene, eType);
                /**@protected*/ this._pEngine = null;
                // private _pDevice = null;
                /**@protected*/ this._pWorldExtents = new akra.geometry.Rect3d();
                this._v3fWorldSize = new akra.Vec3();
                this._v3fMapScale = new akra.Vec3();
                //массив подчиненный секций
                /**@protected*/ this._pSectorArray = null;
                /**@protected*/ this._pDataFactory = null;
                /**@protected*/ this._v2fSectorSize = new akra.Vec2();
                //Таблица(карта высот)
                this._pHeightTable = null;
                this._pNormalMapTexture = null;
                this._pNormalMapImage = null;
                this._pBaseNormalTexture = null;
                this._pBaseNormalImage = null;
                this._pHeightMapTexture = null;
                this._pTempNormalColor = new akra.Color();
                //отоброжаемые куски текстуры
                this._pMegaTexures = null;
                this._bUseVertexNormal = false;
                /**@protected*/ this._pDefaultRenderMethod = null;
                /**@protected*/ this._pRenderMethod = null;
                /**@protected*/ this._pDefaultScreen = null;
                this._fMaxHeight = 0.;
                this._f2DDiagonal = 0.;
                /**@protected*/ this._isCreate = false;
                this._pEngine = pScene.getManager().getEngine();
                this._pDataFactory = akra.render.createRenderDataCollection(this._pEngine, akra.ERenderDataBufferOptions.VB_READABLE);
            }
            Object.defineProperty(Terrain.prototype, "dataFactory", {
                get: /** @inline */function () {
                    return this._pDataFactory;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "worldExtents", {
                get: /** @inline */function () {
                    return this._pWorldExtents;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "worldSize", {
                get: /** @inline */function () {
                    return this._v3fWorldSize;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "mapScale", {
                get: /** @inline */function () {
                    return this._v3fMapScale;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "sectorCountX", {
                get: /** @inline */function () {
                    return this._iSectorCountX;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "sectorCountY", {
                get: /** @inline */function () {
                    return this._iSectorCountY;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "sectorSize", {
                get: /** @inline */function () {
                    return this._v2fSectorSize;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "tableWidth", {
                get: /** @inline */function () {
                    return this._iTableWidth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "tableHeight", {
                get: /** @inline */function () {
                    return this._iTableHeight;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "sectorShift", {
                get: /** @inline */function () {
                    return this._iSectorShift;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "maxHeight", {
                get: /** @inline */function () {
                    return this._fMaxHeight;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "terrain2DLength", {
                get: /** @inline */function () {
                    return this._f2DDiagonal;
                },
                enumerable: true,
                configurable: true
            });
            Terrain.prototype.isCreate = /** @inline */function () {
                return this._isCreate;
            };
            Terrain.prototype._initSystemData = /**@protected*/ function () {
                var pEngine = this._pEngine, pRmgr = pEngine.getResourceManager();
                if (((this._pDefaultRenderMethod) === null)) {
                    var pMethod = null, pEffect = null;
                    pMethod = pRmgr.renderMethodPool.findResource(".terrain_render");
                    if (!((pMethod) === null)) {
                        this._pDefaultRenderMethod = pMethod;
                        return true;
                    }
                    pEffect = pRmgr.createEffect(".terrain_render");
                    pEffect.addComponent("akra.system.terrain");
                    pMethod = pRmgr.createRenderMethod(".terrain_render");
                    pMethod.effect = pEffect;
                    pMethod.surfaceMaterial = pRmgr.createSurfaceMaterial(".terrain_render");
                    this._pDefaultRenderMethod = pMethod;
                }
                if (((this._pDefaultScreen) === null)) {
                    this._pDefaultScreen = new akra.render.Screen(pEngine.getRenderer());
                    var pMethod = null, pEffect = null;
                    pMethod = pRmgr.renderMethodPool.findResource(".terrain_generate_normal");
                    if (((pMethod) === null)) {
                        pEffect = pRmgr.createEffect(".terrain_generate_normal");
                        pEffect.addComponent("akra.system.generateNormalMapByHeightMap");
                        pMethod = pRmgr.createRenderMethod(".terrain_generate_normal");
                        pMethod.effect = pEffect;
                    }
                    this._pDefaultScreen.addRenderMethod(pMethod, ".terrain_generate_normal");
                    ((this._pDefaultScreen.getTechnique(".terrain_generate_normal")).getEventTable().addDestination(((((this._pDefaultScreen.getTechnique(".terrain_generate_normal"))))._iGuid), ("render"), (this), ("_onGenerateNormalRender"), (undefined)));
                }
                return true;
            };
            Terrain.prototype.init = function (pMap, worldExtents, iShift, iShiftX, iShiftY, sSurfaceTextures, pRootNode) {
                if (typeof pRootNode === "undefined") { pRootNode = null; }
                if (!((pRootNode) === null)) {
                    if (!this.attachToParent(pRootNode)) {
                        return false;
                    }
                }
                this._initSystemData();
                //Основные параметры
                this._iSectorShift = iShift;
                this._iSectorUnits = 1 << iShift;
                this._iSectorVerts = this._iSectorUnits + 1;
                this._pWorldExtents = new akra.geometry.Rect3d(worldExtents.x0, worldExtents.x1, worldExtents.y0, worldExtents.y1, worldExtents.z0, worldExtents.z1);
                this._pWorldExtents.normalize();
                this._v3fWorldSize = this._pWorldExtents.size(this._v3fWorldSize);
                //this._iTableWidth >> this._iSectorShift;
                this._iSectorCountX = 1 << iShiftX;
                //this._iTableHeight >> this._iSectorShift;
                this._iSectorCountY = 1 << iShiftY;
                this._iTableWidth = this._iSectorCountX * this._iSectorUnits + 1;
                this._iTableHeight = this._iSectorCountY * this._iSectorUnits + 1;
                this._v2fSectorSize.set(this._v3fWorldSize.x / this._iSectorCountX, this._v3fWorldSize.y / this._iSectorCountY);
                this._v3fMapScale.x = this._v3fWorldSize.x / this._iTableWidth;
                this._v3fMapScale.y = this._v3fWorldSize.y / this._iTableHeight;
                this._v3fMapScale.z = this._v3fWorldSize.z;
                // convert the height map to
                // data stored in local tables
                this._buildHeightAndNormalTables(pMap["height"], pMap["normal"]);
                for(var sImgMap in pMap) {
                    if (pMap[sImgMap].destroyResource) {
                        pMap[sImgMap].destroyResource();
                    }
                }
                if (!this._allocateSectors()) {
 {
                        akra.logger.setSourceLocation("terrain/Terrain.ts", 226);
                        akra.logger.error("Can not alloacte terrain sections");
                    }
                    ;
                    return false;
                }
                this.computeBoundingBox();
                //Мегатекстурные параметры
                this._pMegaTexures = new terrain.MegaTexture(this._pEngine);
                this._pMegaTexures.init(this, sSurfaceTextures);
                this._isCreate = true;
                return true;
            };
            Terrain.prototype.findSection = function (iX, iY) {
                var pSection = null;
                if (iX >= 0 && iX < this._iSectorCountX && iY >= 0 && iY < this._iSectorCountY) {
                    pSection = this._pSectorArray[(iY * this._iSectorCountX) + iX];
                } else {
                    // if we had additional cRoamTerrain objects,
                    // we could reach out here to link with neighbors
                                    }
                return pSection;
            };
            Terrain.prototype._allocateSectors = /**@protected*/ function () {
                this._pSectorArray = new Array(this._iSectorCountX * this._iSectorCountY);
                // create the sector objects themselves
                for(var y = 0; y < this._iSectorCountY; ++y) {
                    for(var x = 0; x < this._iSectorCountX; ++x) {
                        var v2fSectorPos = new akra.Vec2();
                        var r2fSectorRect = new akra.geometry.Rect2d();
                        v2fSectorPos.set(this._pWorldExtents.x0 + (x * this._v2fSectorSize.x), this._pWorldExtents.y0 + (y * this._v2fSectorSize.y));
                        r2fSectorRect.set(v2fSectorPos.x, v2fSectorPos.x + this._v2fSectorSize.x, v2fSectorPos.y, v2fSectorPos.y + this._v2fSectorSize.y);
                        var iXPixel = x << this._iSectorShift;
                        var iYPixel = y << this._iSectorShift;
                        var iIndex = (y * this._iSectorCountX) + x;
                        this._pSectorArray[iIndex] = this.scene.createTerrainSection();
                        this._pSectorArray[iIndex]._createRenderable();
                        if (!this._pSectorArray[iIndex]._internalCreate(this, x, y, iXPixel, iYPixel, this._iSectorVerts, this._iSectorVerts, r2fSectorRect)) {
                            return false;
                        }
                    }
                }
                this._setRenderMethod(this._pDefaultRenderMethod);
                return true;
            };
            Terrain.prototype._setRenderMethod = /**@protected*/ function (pRenderMethod) {
                this._pRenderMethod = pRenderMethod;
                if (this._pRenderMethod) {
                    this._pRenderMethod.addRef();
                }
                var pSection = null;
                for(var i = 0; i < this._pSectorArray.length; i++) {
                    pSection = this._pSectorArray[i];
                    pSection.getRenderable().getTechnique().setMethod(this._pDefaultRenderMethod);
                    ((pSection.getRenderable().getTechnique()).getEventTable().addDestination(((((pSection.getRenderable().getTechnique())))._iGuid), ("render"), (this), ("_onRender"), (undefined)));
                }
            };
            Terrain.prototype._buildHeightAndNormalTables = /**@protected*/ function (pImageHightMap, pImageNormalMap) {
                var fHeight = 0;
                var iComponents = 4;
                this._pHeightTable = null;
                var iMaxY = this._iTableHeight;
                var iMaxX = this._iTableWidth;
                var pColorData = new Uint8Array(4 * iMaxY * iMaxX);
                /*float*/
                this._pHeightTable = new Array(iMaxX * iMaxY);
                // first, build a table of heights
                if (pImageHightMap.isResourceLoaded()) {
                    if (pImageHightMap.width !== iMaxX && pImageHightMap.height !== iMaxY) {
 {
                            akra.logger.setSourceLocation("terrain/Terrain.ts", 333);
                            akra.logger.warning("Размеры карты высот не совпадают с другими размерами. Нужно: " + iMaxX + "x" + iMaxY + ". Есть: " + pImageHightMap.width + "x" + pImageHightMap.height);
                        }
                        ;
                        return;
                    }
                    for(var iY = 0; iY < iMaxY; iY++) {
                        for(var iX = 0; iX < iMaxX; iX++) {
                            fHeight = pImageHightMap.getColorAt(this._pTempNormalColor, iX, iY).r;
                            fHeight = (fHeight * this._v3fMapScale.z) + this._pWorldExtents.z0;
                            this._pHeightTable[iY * iMaxX + iX] = fHeight;
                        }
                    }
                    if (this._useVertexNormal()) {
                        this.computeBaseNormal(pImageHightMap);
                    }
                } else {
 {
                        akra.logger.setSourceLocation("terrain/Terrain.ts", 351);
                        akra.logger.warning("Height map not loaded");
                    }
                }
                if (pImageNormalMap.isResourceLoaded()) {
                    this._pNormalMapTexture = this._pEngine.getResourceManager().createTexture(".terrain-normal-texture" + ((this)._iGuid));
                    this._pNormalMapTexture.loadImage(pImageNormalMap);
                    this._pNormalMapImage = pImageNormalMap;
                } else {
 {
                        akra.logger.setSourceLocation("terrain/Terrain.ts", 360);
                        akra.logger.warning("Normal map not loaded");
                    }
                }
            };
            Terrain.prototype.readWorldHeight = function (iMapX, iMapY) {
                if (arguments.length === 2) {
                    if (iMapX >= this._iTableWidth) {
                        iMapX = this._iTableWidth - 1;
                    }
                    if (iMapY >= this._iTableHeight) {
                        iMapY = this._iTableHeight - 1;
                    }
                    return this._pHeightTable[(iMapY * this._iTableWidth) + iMapX];
                } else {
                    var iMapIndex = iMapX;
 {
                        akra.logger.setSourceLocation("terrain/Terrain.ts", 379);
                        akra.logger.assert(iMapIndex < this._iTableWidth * this._iTableHeight, "invalid index");
                    }
                    ;
                    return this._pHeightTable[iMapIndex];
                }
            };
            Terrain.prototype.readWorldNormal = function (v3fNormal, iMapX, iMapY) {
                if (iMapX >= this._pBaseNormalImage.width) {
                    iMapX = this._pBaseNormalImage.width - 1;
                }
                if (iMapY >= this._pBaseNormalImage.height) {
                    iMapY = this._pBaseNormalImage.height - 1;
                }
                this._pBaseNormalImage.getColorAt(this._pTempNormalColor, iMapX, iMapY);
                v3fNormal.set(this._pTempNormalColor.r, this._pTempNormalColor.g, this._pTempNormalColor.b);
                return v3fNormal;
            };
            Terrain.prototype.projectPoint = function (v3fCoord, v3fDestenation) {
                var v4fTerrainCoord = akra.Vec4.stackCeil.set(v3fCoord, 1.);
                v4fTerrainCoord = this.inverseWorldMatrix.multiplyVec4(v4fTerrainCoord);
                if (v4fTerrainCoord.x < ((this)._pWorldExtents).x0 || v4fTerrainCoord.x > ((this)._pWorldExtents).x1 || v4fTerrainCoord.y < ((this)._pWorldExtents).y0 || v4fTerrainCoord.y > ((this)._pWorldExtents).y1) {
                    return false;
                }
                var iMapX = akra.math.floor((v4fTerrainCoord.x - ((this)._pWorldExtents).x0) / ((this)._pWorldExtents).sizeX() * ((this)._iTableWidth));
                var iMapY = akra.math.floor((v4fTerrainCoord.y - ((this)._pWorldExtents).y0) / ((this)._pWorldExtents).sizeY() * ((this)._iTableHeight));
                var fHeight = this.readWorldHeight(iMapX, iMapY);
                var v4fTempDestenation = akra.Vec4.stackCeil.set(v4fTerrainCoord.x, v4fTerrainCoord.y, fHeight, 1.);
                v4fTempDestenation = ((this)._m4fWorldMatrix).multiplyVec4(v4fTempDestenation);
                v3fDestenation.set(v4fTempDestenation.x, v4fTempDestenation.y, v4fTempDestenation.z);
                return true;
            };
            Terrain.prototype.prepareForRender = /**
            * Подготовка терраина к рендерингу.
            */
            function (pViewport) {
                this._pMegaTexures.prepareForRender(pViewport);
            };
            Terrain.prototype.reset = /**
            * Сброс параметров.
            */
            function () {
            };
            Terrain.prototype.computeBaseNormal = /**@protected*/ function (pImageHightMap) {
                var pRmgr = this._pEngine.getResourceManager();
                this._pHeightMapTexture = pRmgr.createTexture(".terrain-hight-texture" + ((this)._iGuid));
                this._pHeightMapTexture.loadImage(pImageHightMap);
                this._pBaseNormalTexture = pRmgr.createTexture(".terrain-base-normal-texture" + ((this)._iGuid));
                this._pBaseNormalTexture.create(pImageHightMap.width, pImageHightMap.height, 1, null, akra.ETextureFlags.RENDERTARGET, 0, 0, akra.ETextureTypes.TEXTURE_2D, akra.EPixelFormats.R8G8B8A8);
                var pTarget = this._pBaseNormalTexture.getBuffer().getRenderTarget();
                pTarget.setAutoUpdated(false);
                var pViewport = pTarget.addViewport(null, ".terrain_generate_normal", 0, 0, 0, 1, 1);
                pViewport.setDepthParams(false, false, 0);
                pViewport.setClearEveryFrame(false);
                pViewport.startFrame();
                pViewport.renderObject(this._pDefaultScreen);
                pViewport.endFrame();
                this._pBaseNormalImage = pRmgr.createImg(".terrain-base-normal-img" + ((this)._iGuid));
                this._pBaseNormalTexture.convertToImage(this._pBaseNormalImage, false);
            };
            Terrain.prototype._tableIndex = function (iMapX, iMapY) {
                // clamp to the table dimensions
                if (iMapX >= this._iTableWidth) {
                    iMapX = this._iTableWidth - 1;
                }
                if (iMapY >= this._iTableHeight) {
                    iMapY = this._iTableHeight - 1;
                }
                return (iMapY * this._iTableWidth) + iMapX;
            };
            Terrain.prototype._useVertexNormal = function () {
                return this._bUseVertexNormal;
            };
            Terrain.prototype.computeBoundingBox = /**@protected*/ function () {
                var fX0, fY0, fZ0, fX1, fY1, fZ1;
                fX0 = fY0 = fZ0 = akra.MAX_FLOAT64;
                fX1 = fY1 = fZ1 = akra.MIN_FLOAT64;
                for(var i = 0; i < this._pSectorArray.length; i++) {
                    var pSectionBox = this._pSectorArray[i].localBounds;
                    fX0 = akra.math.min(fX0, pSectionBox.x0);
                    fY0 = akra.math.min(fY0, pSectionBox.y0);
                    fZ0 = akra.math.min(fZ0, pSectionBox.z0);
                    fX1 = akra.math.max(fX1, pSectionBox.x1);
                    fY1 = akra.math.max(fY1, pSectionBox.y1);
                    fZ1 = akra.math.max(fZ1, pSectionBox.z1);
                }
                this.accessLocalBounds().set(fX0, fX1, fY0, fY1, fZ0, fZ1);
                this._fMaxHeight = fZ1 - fZ0;
                this._f2DDiagonal = akra.math.sqrt((fX1 - fX0) * (fX1 - fX0) + (fY1 - fY0) * (fY1 - fY0));
            };
            Terrain.prototype._onRender = function (pTechnique, iPass) {
                var pPass = pTechnique.getPass(iPass);
                //pPass.setTexture("TEXTURE6", this._pBaseNormalTexture);
                pPass.setTexture("TEXTURE6", this._pNormalMapTexture);
                pPass.setSamplerTexture("S_NORMAL", "TEXTURE6");
                this._pMegaTexures.applyForRender(pPass);
            };
            Terrain.prototype._onGenerateNormalRender = function (pTechnique, iPass) {
                var pPass = pTechnique.getPass(iPass);
                pPass.setSamplerTexture("HEIGHT_SAMPLER", this._pHeightMapTexture);
                pPass.setUniform("STEPS", akra.Vec2.stackCeil.set(1. / this._pHeightMapTexture.width, 1. / this._pHeightMapTexture.height));
                pPass.setUniform("SCALE", this._v3fMapScale.z);
                pPass.setUniform("CHANNEL", 0);
            };
            return Terrain;
        })(akra.scene.SceneObject);
        terrain.Terrain = Terrain;        
    })(akra.terrain || (akra.terrain = {}));
    var terrain = akra.terrain;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (terrain) {
        var TerrainSectionROAM = (function (_super) {
            __extends(TerrainSectionROAM, _super);
            function TerrainSectionROAM(pScene, eType) {
                if (typeof eType === "undefined") { eType = akra.EEntityTypes.TERRAIN_SECTION_ROAM; }
                        _super.call(this, pScene, eType);
                //два дерева треугольников
                this._pRootTriangleA = new terrain.TriTreeNode();
                this._pRootTriangleB = new terrain.TriTreeNode();
                //Урове5нь погрещности для двух деревьев
                this._pVarianceTreeA = null;
                this._pVarianceTreeB = null;
                //расстояние от камеры до углов секции
                this._v3fDistance0 = new akra.Vec3();
                this._v3fDistance1 = new akra.Vec3();
                this._v3fDistance2 = new akra.Vec3();
                this._v3fDistance3 = new akra.Vec3();
                this._leftNeighborOfA = null;
                this._rightNeighborOfA = null;
                this._leftNeighborOfB = null;
                this._rightNeighborOfB = null;
                this._iStartIndex = undefined;
                this._pTerrainSystem = null;
                this._iTempTotalIndices = undefined;
                this._pTempIndexList = undefined;
                this._iMaxIndices = undefined;
            }
            Object.defineProperty(TerrainSectionROAM.prototype, "terrainSystem", {
                get: /** @inline */function () {
                    return this._pTerrainSystem;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainSectionROAM.prototype, "triangleA", {
                get: /** @inline */function () {
                    return this._pRootTriangleA;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainSectionROAM.prototype, "triangleB", {
                get: /** @inline */function () {
                    return this._pRootTriangleB;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainSectionROAM.prototype, "queueSortValue", {
                get: /** @inline */function () {
                    return this._fQueueSortValue;
                },
                enumerable: true,
                configurable: true
            });
            TerrainSectionROAM.prototype._internalCreate = function (pParentSystem, iSectorX, iSectorY, iHeightMapX, iHeightMapY, iXVerts, iYVerts, pWorldRect, iStartIndex) {
 {
                    akra.logger.setSourceLocation("terrain/TerrainSectionROAM.ts", 74);
                    akra.logger.assert(arguments.length === 9, "Not valid arguments count.");
                }
                ;
                var iVerts = akra.math.max(iXVerts, iYVerts);
                this._iStartIndex = iStartIndex;
                var bResult = _super.prototype._internalCreate.call(this, pParentSystem, iSectorX, iSectorY, iHeightMapX, iHeightMapY, iVerts, iVerts, pWorldRect);
                if (!bResult) {
                    return false;
                }
                this._iTotalDetailLevels = 2 * (akra.math.round(akra.math.log(iVerts - 1) / akra.math.LN2));
                this._iTotalVariances = 1 << this._iTotalDetailLevels;
                this._pVarianceTreeA = new Array(this._iTotalVariances);
                // this._pVarianceTreeA.set(0);
                this._pVarianceTreeB = new Array(this._iTotalVariances);
                // this._pVarianceTreeB.set(0);
                for(var i = 0; i < this._iTotalVariances; i++) {
                    this._pVarianceTreeA[i] = 0;
                    this._pVarianceTreeB[i] = 0;
                }
                var pRoamTerrain = ((this)._pTerrainSystem);
                var pNorthSection = pRoamTerrain.findSection(iSectorX, iSectorY - 1);
                var pSouthSection = pRoamTerrain.findSection(iSectorX, iSectorY + 1);
                var pEastSection = pRoamTerrain.findSection(iSectorX + 1, iSectorY);
                var pWestSection = pRoamTerrain.findSection(iSectorX - 1, iSectorY);
                if (pNorthSection) {
                    this._leftNeighborOfA = pNorthSection.triangleB;
                }
                if (pSouthSection) {
                    this._leftNeighborOfB = pSouthSection.triangleA;
                }
                if (pEastSection) {
                    this._rightNeighborOfB = pEastSection.triangleA;
                }
                if (pWestSection) {
                    this._rightNeighborOfA = pWestSection.triangleB;
                }
                // establish basic links
                this.reset();
                // build the variance trees
                this.computeVariance();
                return bResult;
            };
            TerrainSectionROAM.prototype.prepareForRender = //private _v3fOldPosition:
            function (pViewport) {
                _super.prototype.prepareForRender.call(this, pViewport);
                var pCamera = pViewport.getCamera();
                if (!((this)._pTerrainSystem).resetWithCamera(pCamera)) {
                    return;
                }
                var v3fViewPoint = ((this)._pTerrainSystem).localCameraCoord;
                // compute view distance to our 4 corners
                var fHeight0 = ((this)._pTerrainSystem).readWorldHeight(akra.math.ceil(this._iHeightMapX), akra.math.ceil(this._iHeightMapY));
                var fHeight1 = ((this)._pTerrainSystem).readWorldHeight(akra.math.ceil(this._iHeightMapX), akra.math.ceil(this._iHeightMapY + this._iYVerts));
                var fHeight2 = ((this)._pTerrainSystem).readWorldHeight(akra.math.ceil(this._iHeightMapX + this._iXVerts), akra.math.ceil(this._iHeightMapY + this._iYVerts));
                var fHeight3 = ((this)._pTerrainSystem).readWorldHeight(akra.math.ceil(this._iHeightMapX + this._iXVerts), akra.math.ceil(this._iHeightMapY));
                this._v3fDistance0.set(v3fViewPoint.x - this._pWorldRect.x0, v3fViewPoint.y - this._pWorldRect.y0, v3fViewPoint.z - fHeight0);
                this._v3fDistance1.set(v3fViewPoint.x - this._pWorldRect.x0, v3fViewPoint.y - this._pWorldRect.y1, v3fViewPoint.z - fHeight1);
                this._v3fDistance2.set(v3fViewPoint.x - this._pWorldRect.x1, v3fViewPoint.y - this._pWorldRect.y1, v3fViewPoint.z - fHeight2);
                this._v3fDistance3.set(v3fViewPoint.x - this._pWorldRect.x1, v3fViewPoint.y - this._pWorldRect.y0, v3fViewPoint.z - fHeight3);
                this._fDistance0 = this._v3fDistance0.length();
                this._fDistance1 = this._v3fDistance1.length();
                this._fDistance2 = this._v3fDistance2.length();
                this._fDistance3 = this._v3fDistance3.length();
                // compute min distance as our sort value
                this._fQueueSortValue = akra.math.min(this._fDistance0, this._fDistance1);
                this._fQueueSortValue = akra.math.min(this._fQueueSortValue, this._fDistance2);
                this._fQueueSortValue = akra.math.min(this._fQueueSortValue, this._fDistance3);
                // submit to the tessellation queue of our parent
                ((this)._pTerrainSystem).addToTessellationQueue(this);
            };
            TerrainSectionROAM.prototype.reset = function () {
                this._pRootTriangleA.leftChild = null;
                this._pRootTriangleA.rightChild = null;
                this._pRootTriangleB.leftChild = null;
                this._pRootTriangleB.rightChild = null;
                this._pRootTriangleA.baseNeighbor = this._pRootTriangleB;
                this._pRootTriangleB.baseNeighbor = this._pRootTriangleA;
                // link to our neighbors
                this._pRootTriangleA.leftNeighbor = this._leftNeighborOfA;
                this._pRootTriangleA.rightNeighbor = this._rightNeighborOfA;
                this._pRootTriangleB.leftNeighbor = this._leftNeighborOfB;
                this._pRootTriangleB.rightNeighbor = this._rightNeighborOfB;
            };
            TerrainSectionROAM.prototype.tessellate = function (fScale, fLimit) {
                var iIndex0 = ((this)._pTerrainSystem)._tableIndex(this._iHeightMapX, this._iHeightMapY);
                var iIndex1 = ((this)._pTerrainSystem)._tableIndex(this._iHeightMapX, this._iHeightMapY + this._iYVerts - 1);
                var iIndex2 = ((this)._pTerrainSystem)._tableIndex(this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY + this._iYVerts - 1);
                var iIndex3 = ((this)._pTerrainSystem)._tableIndex(this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY);
                var fHeight0 = ((this)._pTerrainSystem).readWorldHeight(iIndex0);
                var fHeight1 = ((this)._pTerrainSystem).readWorldHeight(iIndex1);
                var fHeight2 = ((this)._pTerrainSystem).readWorldHeight(iIndex2);
                var fHeight3 = ((this)._pTerrainSystem).readWorldHeight(iIndex3);
                this.recursiveTessellate(this._pRootTriangleA, this._iHeightMapX, this._iHeightMapY + this._iYVerts - 1, fHeight1, this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY + this._iYVerts - 1, fHeight2, this._iHeightMapX, this._iHeightMapY, fHeight0, this._pVarianceTreeA, 1);
                this.recursiveTessellate(this._pRootTriangleA, this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY, fHeight3, this._iHeightMapX, this._iHeightMapY, fHeight0, this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY + this._iYVerts - 1, fHeight2, this._pVarianceTreeB, 1);
            };
            TerrainSectionROAM.prototype.recursiveTessellate = /**@protected*/ function (pTri, iCornerAX, iCornerAY, fCornerAZ, iCornerBX, iCornerBY, fCornerBZ, iCornerCX, iCornerCY, fCornerCZ, pVTree, iIndex) {
                if ((iIndex << 1) + 1 > this._iTotalVariances) {
                    return;
                }
                var iMidpointX = (iCornerBX + iCornerCX) >> 1;
                var iMidpointY = (iCornerBY + iCornerCY) >> 1;
                if ((iMidpointX === iCornerBX || iMidpointX === iCornerCX) && (iMidpointY === iCornerBY || iMidpointY === iCornerCY)) {
                    return;
                }
                var fMidPointZ = (fCornerBZ + fCornerCZ) / 2;
                var fRealMidPointZ = ((this)._pTerrainSystem).readWorldHeight(iMidpointX, iMidpointY);
                var v3fLoaclCameraCoord = ((this)._pTerrainSystem).localCameraCoord;
                var pTerrainExtents = ((this)._pTerrainSystem).worldExtents;
                var iHeightMapWidth = ((this)._pTerrainSystem).tableWidth;
                var iHeightMapHeight = ((this)._pTerrainSystem).tableHeight;
                var fTerrainSizeZ = ((this)._pTerrainSystem).maxHeight;
                var fTerrainDiagonal = ((this)._pTerrainSystem).terrain2DLength;
                var fLocalMidX = pTerrainExtents.x0 + iMidpointX * pTerrainExtents.sizeX() / iHeightMapWidth;
                var fLocalMidY = pTerrainExtents.y0 + iMidpointY * pTerrainExtents.sizeY() / iHeightMapHeight;
                var fDistanceSquare = (v3fLoaclCameraCoord.x - fLocalMidX) * (v3fLoaclCameraCoord.x - fLocalMidX) + (v3fLoaclCameraCoord.y - fLocalMidY) * (v3fLoaclCameraCoord.y - fLocalMidY) + (v3fLoaclCameraCoord.z - fMidPointZ) * (v3fLoaclCameraCoord.z - fMidPointZ);
                // Если треугольник не поделен
                if (!pTri.leftChild) {
                    var fScale = ((this)._pTerrainSystem).tessellationScale;
                    var fLimit = ((this)._pTerrainSystem).tessellationLimit;
                    var fDistance = akra.math.sqrt(fDistanceSquare + 0.0001);
                    var fRatio = 0.;
                    /*1 +*/
                    fRatio = (pVTree[iIndex] / fTerrainSizeZ * fScale) / ((fDistance / fTerrainDiagonal) * fLimit);
                    if (fRatio > 1.) {
                        // subdivide this triangle
                        this.split(pTri);
                    }
                }
                // Если треугольник поделен, продолжаем
                if (pTri.leftChild) {
                    this.recursiveTessellate(pTri.leftChild, iMidpointX, iMidpointY, fRealMidPointZ, iCornerAX, iCornerAY, fCornerAZ, iCornerBX, iCornerBY, fCornerBZ, pVTree, iIndex << 1);
                    this.recursiveTessellate(pTri.rightChild, iMidpointX, iMidpointY, fRealMidPointZ, iCornerCX, iCornerCY, fCornerCZ, iCornerAX, iCornerAY, fCornerAZ, pVTree, (iIndex << 1) + 1);
                }
            };
            TerrainSectionROAM.prototype.split = /**@protected*/ function (pTri) {
                // Если разбит то смысла разбивать еще нет
                if (pTri.leftChild) {
                    return;
                }
                // If this triangle is not in a proper diamond, force split our base neighbor
                if (pTri.baseNeighbor && (pTri.baseNeighbor.baseNeighbor !== pTri)) {
                    this.split(pTri.baseNeighbor);
                }
                // Create children and link into mesh
                pTri.leftChild = ((this)._pTerrainSystem).requestTriNode();
                pTri.rightChild = ((this)._pTerrainSystem).requestTriNode();
 {
                    akra.logger.setSourceLocation("terrain/TerrainSectionROAM.ts", 292);
                    akra.logger.assert(pTri.leftChild != pTri, "recursive link");
                }
                ;
 {
                    akra.logger.setSourceLocation("terrain/TerrainSectionROAM.ts", 293);
                    akra.logger.assert(pTri.rightChild != pTri, "recursive link");
                }
                ;
                // Если не удалось выделить треугольник, то не разбиваем
                if ((!pTri.leftChild) || (!pTri.rightChild)) {
                    pTri.leftChild = null;
                    pTri.rightChild = null;
                    return;
                }
                // Fill in the information we can get from the parent (neighbor pointers)
                pTri.leftChild.baseNeighbor = pTri.leftNeighbor;
                pTri.leftChild.leftNeighbor = pTri.rightChild;
                pTri.rightChild.baseNeighbor = pTri.rightNeighbor;
                pTri.rightChild.rightNeighbor = pTri.leftChild;
                // Link our Left Neighbor to the new children
                if (pTri.leftNeighbor) {
                    if (pTri.leftNeighbor.baseNeighbor == pTri) {
                        pTri.leftNeighbor.baseNeighbor = pTri.leftChild;
                    } else if (pTri.leftNeighbor.leftNeighbor == pTri) {
                        pTri.leftNeighbor.leftNeighbor = pTri.leftChild;
                    } else if (pTri.leftNeighbor.rightNeighbor == pTri) {
                        pTri.leftNeighbor.rightNeighbor = pTri.leftChild;
                    } else {
                        console.log(pTri);
 {
                            akra.logger.setSourceLocation("terrain/TerrainSectionROAM.ts", 319);
                            akra.logger.warning("Invalid Left Neighbor!");
                        }
                        ;
 {
                            akra.logger.setSourceLocation("terrain/TerrainSectionROAM.ts", 320);
                            akra.logger.criticalError("stop");
                        }
                        ;
                        // debugger;
                                            }
                }
                // Link our Right Neighbor to the new children
                if (pTri.rightNeighbor) {
                    if (pTri.rightNeighbor.baseNeighbor == pTri) {
                        pTri.rightNeighbor.baseNeighbor = pTri.rightChild;
                    } else if (pTri.rightNeighbor.rightNeighbor == pTri) {
                        pTri.rightNeighbor.rightNeighbor = pTri.rightChild;
                    } else if (pTri.rightNeighbor.leftNeighbor == pTri) {
                        pTri.rightNeighbor.leftNeighbor = pTri.rightChild;
                    } else {
 {
                            akra.logger.setSourceLocation("terrain/TerrainSectionROAM.ts", 334);
                            akra.logger.warning("Invalid Right Neighbor!");
                        }
                        ;
                    }
                }
                // Link our Base Neighbor to the new children
                if (pTri.baseNeighbor) {
                    if (pTri.baseNeighbor.leftChild) {
                        pTri.baseNeighbor.leftChild.rightNeighbor = pTri.rightChild;
                        pTri.baseNeighbor.rightChild.leftNeighbor = pTri.leftChild;
                        pTri.leftChild.rightNeighbor = pTri.baseNeighbor.rightChild;
                        pTri.rightChild.leftNeighbor = pTri.baseNeighbor.leftChild;
                    } else {
                        // Base Neighbor (in a diamond with us) was not split yet, so do that now.
                        this.split(pTri.baseNeighbor);
                    }
                } else {
                    // An edge triangle, trivial case.
                    pTri.leftChild.rightNeighbor = null;
                    pTri.rightChild.leftNeighbor = null;
                }
            };
            TerrainSectionROAM.prototype._createRenderDataForVertexAndIndex = function () {
                return true;
            };
            TerrainSectionROAM.prototype._buildIndexBuffer = function () {
                // this._iMaxIndices=a.TerrainROAM.MaxTriTreeNodes*3;
                this._iMaxIndices = ((this)._pTerrainSystem).maxTriTreeNodes * 3;
                return true;
            };
            TerrainSectionROAM.prototype._buildVertexBuffer = function () {
                this._pWorldRect.z0 = akra.MAX_FLOAT64;
                this._pWorldRect.z1 = akra.MIN_FLOAT64;
                var nElementSize = 0;
                if (((this)._pTerrainSystem)._useVertexNormal()) {
                    /*кординаты вершин*/
                    /*нормаль*/
                    /*текстурные координаты*/
                    nElementSize = (3 + 3 + 2);
                } else {
                    /*кординаты вершин*/
                    /*текстурные координаты*/
                    nElementSize = (3 + 2);
                }
                var pVerts = ((this)._pTerrainSystem).verts;
                var v3fNormal = new akra.Vec3();
                // размер ячейки сектора
                var v2fCellSize = new akra.Vec2();
                v2fCellSize.set((/*checked (origin: akra)>>*/akra.math.abs((this)._pWorldRect.x1 - (this)._pWorldRect.x0)) / (this._iXVerts - 1), /*размер сектора/количество ячеек в секторе*/
                (/*checked (origin: akra)>>*/akra.math.abs((this)._pWorldRect.y1 - (this)._pWorldRect.y0)) / (this._iYVerts - 1));
                //Координаты вершина в секторе
                var v2fVert = new akra.Vec2();
                v2fVert.set(0.0, 0.0);
                for(var y = 0; y < this._iYVerts; ++y) {
                    v2fVert.set(this._pWorldRect.x0, y * v2fCellSize.y + this._pWorldRect.y0);
                    for(var x = 0; x < this._iXVerts; ++x) {
                        var fHeight = ((this)._pTerrainSystem).readWorldHeight(this._iHeightMapX + x, this._iHeightMapY + y);
                        pVerts[((y * this._iXVerts) + x) * nElementSize + 0 + this._iStartIndex * nElementSize] = v2fVert.x;
                        pVerts[((y * this._iXVerts) + x) * nElementSize + 1 + this._iStartIndex * nElementSize] = v2fVert.y;
                        pVerts[((y * this._iXVerts) + x) * nElementSize + 2 + this._iStartIndex * nElementSize] = fHeight;
                        if (((this)._pTerrainSystem)._useVertexNormal()) {
                            ((this)._pTerrainSystem).readWorldNormal(v3fNormal, this._iHeightMapX + x, this._iHeightMapY + y);
                            pVerts[((y * this._iXVerts) + x) * nElementSize + 3 + this._iStartIndex * nElementSize] = v3fNormal.x;
                            pVerts[((y * this._iXVerts) + x) * nElementSize + 4 + this._iStartIndex * nElementSize] = v3fNormal.y;
                            pVerts[((y * this._iXVerts) + x) * nElementSize + 5 + this._iStartIndex * nElementSize] = v3fNormal.z;
                            pVerts[((y * this._iXVerts) + x) * nElementSize + 6 + this._iStartIndex * nElementSize] = (this._iSectorX + x / (this._iXVerts - 1)) / ((this)._pTerrainSystem).sectorCountX;
                            pVerts[((y * this._iXVerts) + x) * nElementSize + 7 + this._iStartIndex * nElementSize] = (this._iSectorY + y / (this._iYVerts - 1)) / ((this)._pTerrainSystem).sectorCountY;
                        } else {
                            pVerts[((y * this._iXVerts) + x) * nElementSize + 3 + this._iStartIndex * nElementSize] = (this._iSectorX + x / (this._iXVerts - 1)) / ((this)._pTerrainSystem).sectorCountX;
                            pVerts[((y * this._iXVerts) + x) * nElementSize + 4 + this._iStartIndex * nElementSize] = (this._iSectorY + y / (this._iYVerts - 1)) / ((this)._pTerrainSystem).sectorCountY;
                        }
                        this._pWorldRect.z0 = akra.math.min(this._pWorldRect.z0, fHeight);
                        this._pWorldRect.z1 = akra.math.max(this._pWorldRect.z1, fHeight);
                        v2fVert.x += v2fCellSize.x;
                    }
                }
                return true;
            };
            TerrainSectionROAM.prototype.buildTriangleList = function () {
                this._iTempTotalIndices = ((this)._pTerrainSystem).totalIndex;
                this._pTempIndexList = ((this)._pTerrainSystem).index;
                this._iVertexID = ((this)._pTerrainSystem).vertexId;
                // add all the triangles to the roamTerrain
                // in root triangle A
                this.recursiveBuildTriangleList(this._pRootTriangleA, 0, this._iXVerts - 1, (this._iYVerts - 1) * this._iXVerts);
                // add all the triangles to the roamTerrain
                // in root triangle B
                this.recursiveBuildTriangleList(this._pRootTriangleB, (this._iYVerts * this._iXVerts) - 1, (this._iYVerts - 1) * this._iXVerts, this._iXVerts - 1);
                ((this)._pTerrainSystem).totalIndex = this._iTempTotalIndices;
                this._iTempTotalIndices = undefined;
                this._iVertexID = undefined;
                this._pTempIndexList = null;
            };
            TerrainSectionROAM.prototype.recursiveBuildTriangleList = /**@protected*/ function (pTri, iPointBase, iPointLeft, iPointRight) {
                if (pTri.leftChild) {
                    if (!pTri.rightChild) {
 {
                            akra.logger.setSourceLocation("terrain/TerrainSectionROAM.ts", 460);
                            akra.logger.warning("invalid triangle node");
                        }
                        ;
                    }
                    var iPointMid = (iPointLeft + iPointRight) * 0.5;
                    this.recursiveBuildTriangleList(pTri.leftChild, iPointMid, iPointBase, iPointLeft);
                    this.recursiveBuildTriangleList(pTri.rightChild, iPointMid, iPointRight, iPointBase);
                } else if (this._iTempTotalIndices + 3 < this._iMaxIndices) {
                    var nElementSize = 0;
                    if (((this)._pTerrainSystem)._useVertexNormal()) {
                        /*кординаты вершин*/
                        /*нормаль*/
                        /*текстурные координаты*/
                        nElementSize = (3 + 3 + 2);
                    } else {
                        /*кординаты вершин*/
                        /*текстурные координаты*/
                        nElementSize = (3 + 2);
                    }
                    // add the local triangle to the index list
                    this._pTempIndexList[this._iTempTotalIndices++] = ((iPointRight + this._iStartIndex) * nElementSize * 4 + this._iVertexID) / 4;
                    this._pTempIndexList[this._iTempTotalIndices++] = ((iPointLeft + this._iStartIndex) * nElementSize * 4 + this._iVertexID) / 4;
                    this._pTempIndexList[this._iTempTotalIndices++] = ((iPointBase + this._iStartIndex) * nElementSize * 4 + this._iVertexID) / 4;
                } else {
 {
                        akra.logger.setSourceLocation("terrain/TerrainSectionROAM.ts", 486);
                        akra.logger.log("else", this._iTempTotalIndices, this._iMaxIndices);
                    }
                }
            };
            TerrainSectionROAM.prototype.computeVariance = /**@protected*/ function () {
                var iTableWidth = ((this)._pTerrainSystem).tableWidth;
                var iTableHeight = ((this)._pTerrainSystem).tableHeight;
                var iIndex0 = ((this)._pTerrainSystem)._tableIndex(this._iHeightMapX, this._iHeightMapY);
                var iIndex1 = ((this)._pTerrainSystem)._tableIndex(this._iHeightMapX, this._iHeightMapY + this._iYVerts - 1);
                var iIndex2 = ((this)._pTerrainSystem)._tableIndex(this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY + this._iYVerts - 1);
                var iIndex3 = ((this)._pTerrainSystem)._tableIndex(this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY);
                var fHeight0 = ((this)._pTerrainSystem).readWorldHeight(iIndex0);
                var fHeight1 = ((this)._pTerrainSystem).readWorldHeight(iIndex1);
                var fHeight2 = ((this)._pTerrainSystem).readWorldHeight(iIndex2);
                var fHeight3 = ((this)._pTerrainSystem).readWorldHeight(iIndex3);
                this.recursiveComputeVariance(this._iHeightMapX, this._iHeightMapY + this._iYVerts - 1, this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY + this._iYVerts - 1, this._iHeightMapX, this._iHeightMapY, fHeight1, fHeight2, fHeight0, this._pVarianceTreeA, 1);
                this.recursiveComputeVariance(this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY, this._iHeightMapX, this._iHeightMapY, this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY + this._iYVerts - 1, fHeight3, fHeight0, fHeight2, this._pVarianceTreeB, 1);
            };
            TerrainSectionROAM.prototype.recursiveComputeVariance = /**@protected*/ function (iCornerAX, iCornerAY, iCornerBX, iCornerBY, iCornerCX, iCornerCY, fHeightA, fHeightB, fHeightC, pVTree, iIndex) {
                if (iIndex < pVTree.length) {
                    var iMidpointX = (iCornerBX + iCornerCX) >> 1;
                    var iMidpointY = (iCornerBY + iCornerCY) >> 1;
                    if ((iMidpointX === iCornerBX || iMidpointX === iCornerCX) && (iMidpointY === iCornerBY || iMidpointY === iCornerCY)) {
                        return 0;
                    }
                    var fMidHeight = ((this)._pTerrainSystem).readWorldHeight(iMidpointX, iMidpointY);
                    var fInterpolatedHeight = (fHeightB + fHeightC) * 0.5;
                    var fVariance = akra.math.abs(fMidHeight - fInterpolatedHeight);
                    // find the variance of our children
                    var fLeft = this.recursiveComputeVariance(iMidpointX, iMidpointY, iCornerAX, iCornerAY, iCornerBX, iCornerBY, fMidHeight, fHeightA, fHeightB, pVTree, iIndex << 1);
                    var fRight = this.recursiveComputeVariance(iMidpointX, iMidpointY, iCornerCX, iCornerCY, iCornerAX, iCornerAY, fMidHeight, fHeightC, fHeightA, pVTree, 1 + (iIndex << 1));
                    // local variance is the minimum of all three
                    fVariance = akra.math.max(fVariance, fLeft);
                    fVariance = akra.math.max(fVariance, fRight);
                    // store the variance as 1/(variance+1)
                    pVTree[iIndex] = fVariance;
                    // this.drawVariance(iIndex,
                    // 	this.terrainSystem._tableIndex(iCornerAX, iCornerAY),
                    // 	this.terrainSystem._tableIndex(iCornerBX, iCornerBY),
                    // 	this.terrainSystem._tableIndex(iCornerCX, iCornerCY), pVTree);
                    return fVariance;
                }
                // return a value which will be ignored by the parent
                // (because the minimum function is used with this result)
                return 0;
            };
            TerrainSectionROAM.prototype.maxVariance = /**@protected*/ function () {
                var fVarianceMaxA = 0;
                var fVarianceMaxB = 0;
                for(var i = 0; i < this._pVarianceTreeA.length; i++) {
                    if (fVarianceMaxA < this._pVarianceTreeA[i]) {
                        fVarianceMaxA = this._pVarianceTreeA[i];
                    }
                    if (fVarianceMaxB < this._pVarianceTreeB[i]) {
                        fVarianceMaxB = this._pVarianceTreeB[i];
                    }
                }
 {
                    akra.logger.setSourceLocation("terrain/TerrainSectionROAM.ts", 586);
                    akra.logger.log("MAX ---> In A: " + fVarianceMaxA + ". In B: " + fVarianceMaxB);
                }
                ;
            };
            TerrainSectionROAM.prototype.minVariance = /**@protected*/ function () {
                var fVarianceMaxA = 0xffffff;
                var fVarianceMaxB = 0xffffff;
                for(var i = 0; i < this._pVarianceTreeA.length; i++) {
                    if (fVarianceMaxA > this._pVarianceTreeA[i] && this._pVarianceTreeA[i] !== 0) {
                        fVarianceMaxA = this._pVarianceTreeA[i];
                    }
                    if (fVarianceMaxB > this._pVarianceTreeB[i] && this._pVarianceTreeB[i] !== 0) {
                        fVarianceMaxB = this._pVarianceTreeB[i];
                    }
                }
 {
                    akra.logger.setSourceLocation("terrain/TerrainSectionROAM.ts", 603);
                    akra.logger.log("MIN ---> In A: " + fVarianceMaxA + ". In B: " + fVarianceMaxB);
                }
                ;
            };
            TerrainSectionROAM.prototype.drawVariance = /**@protected*/ function (iIndex, iCornerA, iCornerB, iCornerC, pVTree) {
                var iLevel = akra.math.floor(akra.math.log(iIndex) / akra.math.LN2);
                var iStart = 3;
                if (iLevel >= iStart && iLevel < iStart + 4) {
                    //#####################################################################################
                    //Получение канваса
                    var pCanvas = document.getElementById("canvasVariance" + (iLevel - iStart));
                    var p2D = pCanvas.getContext("2d");
                    // цвет фона
                    p2D.fillStyle = "rgb(0," + akra.math.floor(pVTree[iIndex]) + ",0)";
                    //#####################################################################################
                    //Рисование треугольников
                    //цвет линий
                    p2D.strokeStyle = "#f00";
                    p2D.lineWidth = 1;
                    p2D.beginPath();
                    var iTW = ((this)._pTerrainSystem).tableWidth;
                    var iTH = ((this)._pTerrainSystem).tableHeight;
                    var iXA = iCornerA % iTW;
                    var iYA = akra.math.floor(iCornerA / iTW);
                    var iXB = iCornerB % iTW;
                    var iYB = akra.math.floor(iCornerB / iTW);
                    var iXC = iCornerC % iTW;
                    var iYC = akra.math.floor(iCornerC / iTW);
                    var iXMid = akra.math.floor((iXA + iXB + iXC) / 3);
                    var iYMid = akra.math.floor((iYA + iYB + iYC) / 3);
                    p2D.arc(akra.math.floor(iXMid / iTW * pCanvas.width), akra.math.floor(iYMid / iTH * pCanvas.height), 1, 0, akra.math.PI * 2, false);
                    p2D.fill();
                }
            };
            return TerrainSectionROAM;
        })(terrain.TerrainSection);
        terrain.TerrainSectionROAM = TerrainSectionROAM;        
    })(akra.terrain || (akra.terrain = {}));
    var terrain = akra.terrain;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (terrain) {
        var TriTreeNode = (function () {
            function TriTreeNode() {
                this._pBaseNeighbor = null;
                this._pLeftNeighbor = null;
                this._pRightNeighbor = null;
                this._pLeftChild = null;
                this._pRightChild = null;
            }
            Object.defineProperty(TriTreeNode.prototype, "baseNeighbor", {
                get: /** @inline */function () {
                    return this._pBaseNeighbor;
                },
                set: /** @inline */function (pBaseNeighbor) {
                    this._pBaseNeighbor = pBaseNeighbor;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TriTreeNode.prototype, "leftNeighbor", {
                get: /** @inline */function () {
                    return this._pLeftNeighbor;
                },
                set: /** @inline */function (pLeftNeighbor) {
                    this._pLeftNeighbor = pLeftNeighbor;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TriTreeNode.prototype, "rightNeighbor", {
                get: /** @inline */function () {
                    return this._pRightNeighbor;
                },
                set: /** @inline */function (pRightNeighbor) {
                    this._pRightNeighbor = pRightNeighbor;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TriTreeNode.prototype, "leftChild", {
                get: /** @inline */function () {
                    return this._pLeftChild;
                },
                set: /** @inline */function (pLeftChild) {
                    this._pLeftChild = pLeftChild;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TriTreeNode.prototype, "rightChild", {
                get: /** @inline */function () {
                    return this._pRightChild;
                },
                set: /** @inline */function (pRightChild) {
                    this._pRightChild = pRightChild;
                },
                enumerable: true,
                configurable: true
            });
            return TriTreeNode;
        })();
        terrain.TriTreeNode = TriTreeNode;        
        var TriangleNodePool = (function () {
            function TriangleNodePool(iCount) {
                this._iNextTriNode = 0;
                this._iMaxCount = undefined;
                this._pPool = null;
                this._iMaxCount = iCount;
                ((this)._pPool = (Array(iCount)));
                // console.log("TriangleNodePool",this.maxCount);
                for(var i = 0; i < ((this)._iMaxCount); i++) {
                    this.pool[i] = new TriTreeNode();
                }
            }
            Object.defineProperty(TriangleNodePool.prototype, "nextTriNode", {
                get: /** @inline */function () {
                    return this._iNextTriNode;
                },
                set: /** @inline */function (iNextTriNode) {
                    this._iNextTriNode = iNextTriNode;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TriangleNodePool.prototype, "maxCount", {
                get: /** @inline */function () {
                    return this._iMaxCount;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TriangleNodePool.prototype, "pool", {
                get: /** @inline */function () {
                    return this._pPool;
                },
                set: /** @inline */function (pPool) {
                    this._pPool = pPool;
                },
                enumerable: true,
                configurable: true
            });
            TriangleNodePool.prototype.request = function () {
                var pNode = null;
                if (((this)._iNextTriNode) < ((this)._iMaxCount)) {
                    pNode = this.pool[((this)._iNextTriNode)];
                    pNode.baseNeighbor = null;
                    pNode.leftNeighbor = null;
                    pNode.rightNeighbor = null;
                    pNode.leftChild = null;
                    pNode.rightChild = null;
                    ((this)._iNextTriNode)++;
                }
                return pNode;
            };
            TriangleNodePool.prototype.reset = function () {
                ((this)._iNextTriNode = (0));
            };
            return TriangleNodePool;
        })();
        terrain.TriangleNodePool = TriangleNodePool;        
    })(akra.terrain || (akra.terrain = {}));
    var terrain = akra.terrain;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (terrain) {
        var TerrainROAM = (function (_super) {
            __extends(TerrainROAM, _super);
            function TerrainROAM(pScene, eType) {
                if (typeof eType === "undefined") { eType = akra.EEntityTypes.TERRAIN_ROAM; }
                        _super.call(this, pScene, eType);
                this._pRenderableObject = null;
                this._pRenderData = null;
                this._pDataIndex = null;
                this._pIndexList = null;
                this._pNodePool = null;
                this._pThistessellationQueue = null;
                this._iTessellationQueueCount = 0;
                this._isRenderInThisFrame = false;
                /*64k triangle nodes*/
                this._iMaxTriTreeNodes = (1024 * 64);
                this._iTessellationQueueSize = 0;
                //массив подчиненный секций
                /**@protected*/ this._pSectorArray = null;
                /**@protected*/ this._fScale = 0.0;
                /**@protected*/ this._fLimit = 0.0;
                this._iTessellationQueueCountOld = 0;
                this._nCountRender = 0;
                this._m4fLastCameraMatrix = new akra.Mat4();
                this._m4fLastTesselationMatrix = new akra.Mat4();
                this._v3fLocalCameraCoord = new akra.Vec3();
                this._isNeedReset = true;
                this._fLastTessealationTime = 0.;
                this._fTessealationInterval = 1. / 30.;
                this._pRenderData = this._pDataFactory.getEmptyRenderData(akra.EPrimitiveTypes.TRIANGLELIST, akra.ERenderDataBufferOptions.RD_ADVANCED_INDEX);
                this._pRenderableObject = new akra.render.RenderableObject();
                this._pRenderableObject._setup(this._pEngine.getRenderer());
                this._pRenderableObject._setRenderData(this._pRenderData);
                ((this._pRenderableObject).getEventTable().addDestination(((((this._pRenderableObject)))._iGuid), ("beforeRender"), (this), ("_onBeforeRender"), (/*checked (origin: akra)>>*/akra.EEventTypes.UNICAST)));
            }
            Object.defineProperty(TerrainROAM.prototype, "tessellationScale", {
                get: /** @inline */function () {
                    return this._fScale;
                },
                set: /** @inline */function (fScale) {
                    this._fScale = fScale;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainROAM.prototype, "tessellationLimit", {
                get: /** @inline */function () {
                    return this._fLimit;
                },
                set: /** @inline */function (fLimit) {
                    this._fLimit = fLimit;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainROAM.prototype, "maxTriTreeNodes", {
                get: /** @inline */function () {
                    return this._iMaxTriTreeNodes;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainROAM.prototype, "verts", {
                get: /** @inline */function () {
                    return this._pVerts;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainROAM.prototype, "index", {
                get: /** @inline */function () {
                    return this._pIndexList;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainROAM.prototype, "totalIndex", {
                get: /** @inline */function () {
                    return this._iTotalIndices;
                },
                set: /** @inline */function (iTotalIndices) {
                    this._iTotalIndices = iTotalIndices;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainROAM.prototype, "vertexId", {
                get: /** @inline */function () {
                    return this._iVertexID;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainROAM.prototype, "totalRenderable", {
                get: /** @inline */function () {
                    return !((this._pRenderableObject) === null) ? 1 : 0;
                },
                enumerable: true,
                configurable: true
            });
            TerrainROAM.prototype.getRenderable = /** @inline */function (i) {
                return this._pRenderableObject;
            };
            Object.defineProperty(TerrainROAM.prototype, "localCameraCoord", {
                get: /** @inline */function () {
                    return this._v3fLocalCameraCoord;
                },
                enumerable: true,
                configurable: true
            });
            TerrainROAM.prototype.init = function (pImgMap, worldExtents, iShift, iShiftX, iShiftY, sSurfaceTextures, pRootNode) {
                if (typeof pRootNode === "undefined") { pRootNode = null; }
                var bResult = _super.prototype.init.call(this, pImgMap, worldExtents, iShift, iShiftX, iShiftY, sSurfaceTextures, pRootNode);
                if (bResult) {
                    this._iTessellationQueueSize = ((this)._iSectorCountX) * ((this)._iSectorCountY);
                    this._pNodePool = new terrain.TriangleNodePool(this._iMaxTriTreeNodes);
                    this._pThistessellationQueue = new Array(this._iTessellationQueueSize);
                    this._iTessellationQueueCount = 0;
                    this._isCreate = true;
                    this._iTotalIndicesMax = 0;
                    this._pRenderableObject.getTechnique().setMethod(this._pDefaultRenderMethod);
                    ((this._pRenderableObject.getTechnique()).getEventTable().addDestination(((((this._pRenderableObject.getTechnique())))._iGuid), ("render"), (this), ("_onRender"), (undefined)));
 {
                        akra.logger.setSourceLocation("terrain/TerrainROAM.ts", 123);
                        akra.logger.log(this._pRenderableObject.material.toString());
                    }
                    ;
                    this._setTessellationParameters(10.0, 0.5);
                    this.reset();
                }
                this._isCreate = bResult;
                return bResult;
            };
            TerrainROAM.prototype.destroy = function () {
                delete this._pNodePool;
                delete this._pThistessellationQueue;
                this._iTessellationQueueCount = 0;
                this._fScale = 0;
                this._fLimit = 0;
                //Terrain.prototype.destroy.call(this); с какого то хуя этого метода не оказалось
                            };
            TerrainROAM.prototype._allocateSectors = /**@protected*/ function () {
                var nElementSize = 0;
                if (this._useVertexNormal()) {
                    /*кординаты вершин*/
                    /*нормаль*/
                    /*текстурные координаты*/
                    nElementSize = (3 + 3 + 2);
                } else {
                    /*кординаты вершин*/
                    /*текстурные координаты*/
                    nElementSize = (3 + 2);
                }
                this._pSectorArray = new Array(this._iSectorCountX * this._iSectorCountY);
                //Вершинный буфер для всех
                /*количество секции*/
                this._pVerts = new Array((this._iSectorCountX * this._iSectorCountY) * /*размер секции в вершинах*/
                (this._iSectorVerts * this._iSectorVerts) * (nElementSize));
                for(var i = 0; i < this._pSectorArray.length; i++) {
                    this._pSectorArray[i] = this.scene.createTerrainSectionROAM();
                }
                // create the sector objects themselves
                for(var y = 0; y < this._iSectorCountY; ++y) {
                    for(var x = 0; x < this._iSectorCountX; ++x) {
                        //cVector2 sectorPos(
                        var v2fSectorPos = new akra.Vec2();
                        v2fSectorPos.set(this._pWorldExtents.x0 + (x * this._v2fSectorSize.x), this._pWorldExtents.y0 + (y * this._v2fSectorSize.y));
                        //cRect2d r2fSectorRect(
                        var r2fSectorRect = new akra.geometry.Rect2d();
                        r2fSectorRect.set(v2fSectorPos.x, v2fSectorPos.x + this._v2fSectorSize.x, v2fSectorPos.y, v2fSectorPos.y + this._v2fSectorSize.y);
                        var iXPixel = x << this._iSectorShift;
                        var iYPixel = y << this._iSectorShift;
                        var iIndex = (y * this._iSectorCountX) + x;
                        if (!this._pSectorArray[iIndex]._internalCreate(/*Терраин*/
                        this, /*Номер секции оп иксу и игрику*/
                        x, y, /*Координаты секции в картах нормалей и врешин*/
                        iXPixel, iYPixel, /*Количесвто вершин в секции по иску и игрику*/
                        this._iSectorVerts, this._iSectorVerts, r2fSectorRect, /*размер секции в вершинах*/
                        iIndex * (this._iSectorVerts * this._iSectorVerts))) {
                            return false;
                        }
                    }
                }
                var pVertexDescription = null;
                if (this._useVertexNormal()) {
                    pVertexDescription = [
                        (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.POSITION)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
})), 
                        (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.NORMAL)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
})), 
                        (({
count: (2),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.TEXCOORD)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                    ];
                } else {
                    pVertexDescription = [
                        (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.POSITION)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
})), 
                        (({
count: (2),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.TEXCOORD)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                    ];
                }
                this._iVertexID = this._pRenderData.allocateData(pVertexDescription, new Float32Array(this._pVerts));
                //Индексны буфер для всех
                this._iTotalIndices = 0;
                //Максимальное количество треугольников помноженное на 3 вершины на каждый треугольник
                this._pIndexList = new Float32Array(this._iMaxTriTreeNodes * 3);
                this._pRenderData.allocateIndex([
                    (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.INDEX0)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
})), 
                    (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.POSITION)),
offset: ((0))
}))
                ], this._pIndexList);
                this._pRenderData.index(this._iVertexID, akra.DeclarationUsages.INDEX0);
                this._pDataIndex = this._pRenderData.getAdvancedIndexData(akra.DeclarationUsages.INDEX0);
                return true;
            };
            TerrainROAM.prototype.reset = function () {
                this._isRenderInThisFrame = false;
                if (this._isCreate) {
                    _super.prototype.reset.call(this);
                    // reset internal counters
                    this._iTessellationQueueCount = 0;
                    this._pThistessellationQueue.length = this._iTessellationQueueSize;
                    this._pNodePool.reset();
                    // reset each section
                    for(var i in this._pSectorArray) {
                        this._pSectorArray[i].reset();
                    }
                }
            };
            TerrainROAM.prototype.resetWithCamera = function (pCamera) {
                if (!((this)._m4fLastCameraMatrix.isEqual((pCamera).worldMatrix))) {
                    if (this._isNeedReset) {
                        this.reset();
                        this._isNeedReset = false;
                        var v4fCameraCoord = akra.Vec4.stackCeil.set(pCamera.worldPosition, 1.);
                        v4fCameraCoord = this.inverseWorldMatrix.multiplyVec4(v4fCameraCoord);
                        this._v3fLocalCameraCoord.set(v4fCameraCoord.x, v4fCameraCoord.y, v4fCameraCoord.z);
                    }
                    return true;
                } else {
                    return false;
                }
            };
            TerrainROAM.prototype.requestTriNode = function () {
                return this._pNodePool.request();
            };
            TerrainROAM.prototype.addToTessellationQueue = function (pSection) {
                if (this._iTessellationQueueCount < this._iTessellationQueueSize) {
                    this._pThistessellationQueue[this._iTessellationQueueCount] = pSection;
                    this._iTessellationQueueCount++;
                    return true;
                }
                // while we handle this failure gracefully
                // in release builds, we alert ourselves
                // to the situation with an assert in debug
                // builds so we can increase the queue size
                 {
                    akra.logger.setSourceLocation("terrain/TerrainROAM.ts", 272);
                    akra.logger.warning("increase the size of the ROAM tessellation queue");
                }
                ;
                return false;
            };
            TerrainROAM.prototype.processTessellationQueue = /**@protected*/ function () {
                this._pThistessellationQueue.length = this._iTessellationQueueCount;
                function fnSortSection(a, b) {
                    return a.queueSortValue - b.queueSortValue;
                }
                this._pThistessellationQueue.sort(fnSortSection);
                for(var i = 0; i < this._iTessellationQueueCount; ++i) {
                    // split triangles based on the
                    // scale and limit values
                    this._pThistessellationQueue[i].tessellate(this._fScale, this._fLimit);
                }
                this._iTotalIndices = 0;
                // gather up all the triangles into
                // a final index buffer per section
                for(var i = 0; i < this._iTessellationQueueCount; ++i) {
                    this._pThistessellationQueue[i].buildTriangleList();
                }
                if (this._iTotalIndicesOld === this._iTotalIndices && this._iTotalIndices !== this._iTotalIndicesMax) {
                    return;
                }
                this._pRenderData._setIndexLength(this._iTotalIndices);
                this._pDataIndex.setData(this._pIndexList, 0, akra.getTypeSize(akra.EDataTypes.FLOAT), 0, this._iTotalIndices);
                this._iTotalIndicesOld = this._iTotalIndices;
                this._iTotalIndicesMax = akra.math.max(this._iTotalIndicesMax, this._iTotalIndices);
                this._pRenderableObject._setRenderData(this._pRenderData);
            };
            TerrainROAM.prototype._setTessellationParameters = /**@protected*/ function (fScale, fLimit) {
                this._fScale = fScale;
                this._fLimit = fLimit;
            };
            TerrainROAM.prototype._isOldCamera = /** @inline */function (pCamera) {
                return this._m4fLastCameraMatrix.isEqual(pCamera.worldMatrix);
            };
            TerrainROAM.prototype._onBeforeRender = function (pRenderableObject, pViewport) {
                if (this._isCreate) {
                    var pCamera = pViewport.getCamera();
                    var fCurrentTime = this.scene.getManager().getEngine().time;
                    this._m4fLastCameraMatrix.set(pCamera.worldMatrix);
                    if (fCurrentTime - this._fLastTessealationTime > this._fTessealationInterval) {
                        if (!this._m4fLastCameraMatrix.isEqual(this._m4fLastTesselationMatrix)) {
                            this.processTessellationQueue();
                            this._m4fLastTesselationMatrix.set(this._m4fLastCameraMatrix);
                            //this._iTessellationQueueCountOld = this._iTessellationQueueCount;
                                                    }
                        this._fLastTessealationTime = fCurrentTime;
                    }
                }
                this._isNeedReset = true;
            };
            return TerrainROAM;
        })(terrain.Terrain);
        terrain.TerrainROAM = TerrainROAM;        
    })(akra.terrain || (akra.terrain = {}));
    var terrain = akra.terrain;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        (function (light) {
            var ProjectParameters = (function () {
                function ProjectParameters() {
                    this.ambient = new akra.Color();
                    this.diffuse = new akra.Color();
                    this.specular = new akra.Color();
                    this.attenuation = new akra.Vec3();
                }
                return ProjectParameters;
            })();
            light.ProjectParameters = ProjectParameters;            
            var ProjectLight = (function (_super) {
                __extends(ProjectLight, _super);
                function ProjectLight(pScene) {
                                _super.call(this, pScene, akra.ELightTypes.PROJECT);
                    /**@protected*/ this._pDepthTexture = null;
                    /**@protected*/ this._pColorTexture = null;
                    /**@protected*/ this._pLightParameters = new ProjectParameters();
                    this._pShadowCaster = pScene._createShadowCaster(this);
                }
                Object.defineProperty(ProjectLight.prototype, "params", {
                    get: /** @inline */function () {
                        return this._pLightParameters;
                    },
                    enumerable: true,
                    configurable: true
                });
                ProjectLight.prototype.create = function (isShadowCaster, iMaxShadowResolution) {
                    if (typeof isShadowCaster === "undefined") { isShadowCaster = true; }
                    if (typeof iMaxShadowResolution === "undefined") { iMaxShadowResolution = 256; }
                    var isOk = _super.prototype.create.call(this, isShadowCaster, iMaxShadowResolution);
                    var pCaster = this._pShadowCaster;
                    pCaster.setParameter(akra.ECameraParameters.CONST_ASPECT, true);
                    pCaster.setInheritance(akra.ENodeInheritance.ALL);
                    pCaster.attachToParent(this);
                    if (((this)._isShadowCaster)) {
                        this.initializeTextures();
                    }
                    return isOk;
                };
                ProjectLight.prototype.getDepthTexture = /** @inline */function () {
                    return this._pDepthTexture;
                };
                ProjectLight.prototype.getRenderTarget = /** @inline */function () {
                    // return this._pDepthTexture.getBuffer().getRenderTarget();
                    return this._pColorTexture.getBuffer().getRenderTarget();
                };
                ProjectLight.prototype.getShadowCaster = /** @inline */function () {
                    return this._pShadowCaster;
                };
                Object.defineProperty(ProjectLight.prototype, "isShadowCaster", {
                    get: /** @inline */function () {
                        return this._isShadowCaster;
                    },
                    set: /**
                    * overridden setter isShadow caster,
                    * if depth texture don't created then create depth texture
                    */
                    function (bValue) {
                        this._isShadowCaster = bValue;
                        if (bValue && ((this._pDepthTexture) === null)) {
                            this.initializeTextures();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                ProjectLight.prototype.initializeTextures = /**@protected*/ function () {
                    var pEngine = this.scene.getManager().getEngine();
                    var pResMgr = pEngine.getResourceManager();
                    var iSize = this._iMaxShadowResolution;
                    // if (!isNull(this._pDepthTexture)){
                    // 	this._pDepthTexture.destroyResource();
                    // }
                    var pDepthTexture = this._pDepthTexture = pResMgr.createTexture("depth_texture_" + ((this)._iGuid));
                    pDepthTexture.create(iSize, iSize, 1, null, 0, 0, 0, akra.ETextureTypes.TEXTURE_2D, akra.EPixelFormats.DEPTH32);
                    pDepthTexture.setWrapMode(akra.ETextureParameters.WRAP_S, akra.ETextureWrapModes.CLAMP_TO_EDGE);
                    pDepthTexture.setWrapMode(akra.ETextureParameters.WRAP_T, akra.ETextureWrapModes.CLAMP_TO_EDGE);
                    pDepthTexture.setFilter(akra.ETextureParameters.MAG_FILTER, akra.ETextureFilters.LINEAR);
                    pDepthTexture.setFilter(akra.ETextureParameters.MIN_FILTER, akra.ETextureFilters.LINEAR);
                    // if (this._pColorTexture) {
                    // 	this._pColorTexture.destroy();
                    // }
                    var pColorTexture = pResMgr.createTexture("light_color_texture_" + ((this)._iGuid));
                    pColorTexture.create(iSize, iSize, 1, null, akra.ETextureFlags.RENDERTARGET, 0, 0, akra.ETextureTypes.TEXTURE_2D, akra.EPixelFormats.R8G8B8A8);
                    this._pColorTexture = pColorTexture;
                    // this._pColorTexture = pColorTexture;
                    //TODO: Multiple render target
                    ((this)._pColorTexture.getBuffer().getRenderTarget()).attachDepthTexture(pDepthTexture);
                    ((this)._pColorTexture.getBuffer().getRenderTarget()).setAutoUpdated(false);
                    ((this)._pColorTexture.getBuffer().getRenderTarget()).addViewport(this._pShadowCaster, akra.EViewportTypes.SHADOWVIEWPORT);
                };
                ProjectLight.prototype._calculateShadows = function () {
                    if (((this)._isEnabled) && ((this)._isShadowCaster)) {
                        ((this)._pColorTexture.getBuffer().getRenderTarget()).update();
                    }
                };
                ProjectLight.prototype._prepareForLighting = function (pCamera) {
                    if (!((this)._isEnabled)) {
                        return false;
                    } else {
                        /*************************************************************/
                        //optimize camera frustum
                        var pDepthRange = pCamera.getDepthRange();
                        var fFov = pCamera.fov;
                        var fAspect = pCamera.aspect;
                        var m4fTmp = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/akra.Mat4.perspective(fFov, fAspect, -pDepthRange.min, -pDepthRange.max, akra.Mat4.stackCeil.set());
                        ((this)._pOptimizedCameraFrustum).extractFromMatrix(m4fTmp, pCamera.worldMatrix);
                        /*************************************************************/
                        if (!((this)._isShadowCaster)) {
                            var pResult = this._defineLightingInfluence(pCamera);
                            return (pResult.length == 0) ? false : true;
                        } else {
                            var pResult = this._defineShadowInfluence(pCamera);
                            return (pResult.length == 0) ? false : true;
                        }
                    }
                };
                ProjectLight.prototype._defineLightingInfluence = /**@protected*/ function (pCamera) {
                    var pShadowCaster = this._pShadowCaster;
                    var pCameraFrustum = ((this)._pOptimizedCameraFrustum);
                    var pResult = pShadowCaster.affectedObjects;
                    pResult.clear();
                    //fast test on frustum intersection
                    if (!pCameraFrustum.testFrustum(pShadowCaster.frustum)) {
                        //frustums don't intersecting
                        return pResult;
                    }
                    var pRawResult = pShadowCaster.display(0);
                    for(var i = 0; i < pRawResult.length; i++) {
                        var pObject = pRawResult.value(i);
                        if (pCameraFrustum.testRect(pObject.worldBounds)) {
                            pResult.push(pObject);
                        }
                    }
                    return pResult;
                };
                ProjectLight.prototype._defineShadowInfluence = /**@protected*/ function (pCamera) {
                    var pShadowCaster = this._pShadowCaster;
                    var pCameraFrustum = ((this)._pOptimizedCameraFrustum);
                    var pResult = pShadowCaster.affectedObjects;
                    pResult.clear();
                    //fast test on frustum intersection
                    if (!pCameraFrustum.testFrustum(pShadowCaster.frustum)) {
                        //frustums don't intersecting
                        pShadowCaster._optimizeProjectionMatrix(pCameraFrustum);
                        return pResult;
                    }
                    var pRawResult = pShadowCaster.display(0);
                    var pTestArray = ProjectLight._pFrustumPlanes;
                    var pFrustumPlanesKeys = akra.geometry.Frustum.frustumPlanesKeys;
                    var nAdditionalTestLength = 0;
                    if (pShadowCaster.projectionMatrix.isOrthogonalProjection()) {
                        //orthogonal projection
                        //defining light sight direction;
                        //TODO: rewrite additional testing
                        var pLightFrustumVertices = pShadowCaster.frustum.frustumVertices;
                        var v3fDirection1 = akra.Vec3.stackCeil.set(0.);
                        var v3fDirection2 = akra.Vec3.stackCeil.set(0.);
                        var v3fDirection = akra.Vec3.stackCeil.set(0.);
                        //nearPlane
                        for(var i = 0; i < 4; i++) {
                            v3fDirection1.add(pLightFrustumVertices[i]);
                        }
                        //farPlane
                        for(var i = 4; i < 8; i++) {
                            v3fDirection2.add(pLightFrustumVertices[i]);
                        }
                        v3fDirection2.subtract(v3fDirection1, v3fDirection);
                        v3fDirection.normalize();
                        for(var i = 0; i < 6; i++) {
                            var sKey = pFrustumPlanesKeys[i];
                            var pPlane = pCameraFrustum[sKey];
                            if (v3fDirection.dot(pPlane.normal) >= 0.) {
                                //adding plane
                                pTestArray[nAdditionalTestLength].set(pPlane);
                                nAdditionalTestLength++;
                            } else {
                                var pPlanePoints = [
                                    new akra.Vec3(), 
                                    new akra.Vec3(), 
                                    new akra.Vec3(), 
                                    new akra.Vec3()
                                ];
                                pCameraFrustum.getPlanePoints(sKey, pPlanePoints);
                                //find far points;
                                var pDirections = new Array(4);
                                for(var j = 0; j < 4; j++) {
                                    pDirections[j] = new akra.Vec3();
                                    pPlanePoints[j].subtract(((this)._v3fWorldPosition), pDirections[j]);
                                }
                                var fLength1 = pDirections[0].length();
                                var fLength2 = pDirections[1].length();
                                var fLength3 = pDirections[2].length();
                                var fLength4 = pDirections[3].length();
                                var pTmp1 = [
                                    fLength1, 
                                    fLength2, 
                                    fLength3, 
                                    fLength4
                                ];
                                var pIndex = [
                                    -1, 
                                    -1, 
                                    -1, 
                                    -1
                                ];
                                for(var j = 0; j < 4; j++) {
                                    var iTest = 3;
                                    for(var k = 0; k < 4; k++) {
                                        if (k == j) {
                                            continue;
                                        }
                                        if (pTmp1[j] >= pTmp1[k]) {
                                            iTest--;
                                        }
                                    }
                                    for(var k = 0; k < 4; k++) {
                                        if (pIndex[iTest] == -1) {
                                            pIndex[iTest] = j;
                                            break;
                                        } else {
                                            iTest++;
                                        }
                                    }
                                }
                                var pPoint1 = pPlanePoints[pIndex[0]];
                                var pPoint2 = pPlanePoints[pIndex[1]];
                                var pTestPoint1 = pPlanePoints[pIndex[2]];
                                var pTestPoint2 = pPlanePoints[pIndex[3]];
                                // console.log(pPoint1, pPoint2, pTestPoint1, pTestPoint2)
                                var v3fDir = pPoint2.subtract(pPoint1, akra.Vec3.stackCeil.set());
                                var v3fNormal = v3fDir.cross(v3fDirection, akra.Vec3.stackCeil.set()).normalize();
                                var pTestPlane = pTestArray[nAdditionalTestLength];
                                pTestPlane.set(v3fNormal, -v3fNormal.dot(pPoint1));
                                var pVertices = pCamera.frustum.frustumVertices;
                                var iTest = 0;
                                for(var k = 0; k < 8; k++) {
                                    // console.log(pTestPlane.signedDistance(pVertices[k]));
                                    if (pTestPlane.signedDistance(pVertices[k]) > 0.1) {
                                        iTest++;
                                    }
                                }
                                if (iTest == 6) {
                                    pTestPlane.negate();
                                } else if (iTest != 0) {
                                    continue;
                                }
                                nAdditionalTestLength++;
                                //pTestPlane.set(v3fNormal, -v3fNormal.dot(pPoint1));
                                // if(pTestPlane.signedDistance(pTestPoint1) > 0.1 && math.abs(pTestPlane.signedDistance(pTestPoint2)) > 0.1){
                                // 	v3fNormal.negate();
                                // }
                                                            }
                        }
                    } else {
                        //frustum projection
                        //TODO: rewrite additional testing
                        //create list for additional testing
                        var v3fLightPosition = ((this)._v3fWorldPosition);
                        for(var i = 0; i < 6; i++) {
                            var sKey = pFrustumPlanesKeys[i];
                            var pPlane = pCameraFrustum[sKey];
                            var v3fNormal = akra.Vec3.stackCeil.set().set(pPlane.normal);
                            var fDistance = pPlane.distance;
                            if (pPlane.signedDistance(v3fLightPosition) > 0) {
                                // fDistance = -v3fNormal.dot(v3fLightPosition);
                                var pPlanePoints = [
                                    new akra.Vec3(), 
                                    new akra.Vec3(), 
                                    new akra.Vec3(), 
                                    new akra.Vec3()
                                ];
                                pCameraFrustum.getPlanePoints(sKey, pPlanePoints);
                                //find far points;
                                var pDirections = new Array(4);
                                for(var j = 0; j < 4; j++) {
                                    pDirections[j] = new akra.Vec3();
                                    pPlanePoints[j].subtract(v3fLightPosition, pDirections[j]);
                                }
                                var fLength1 = pDirections[0].length();
                                var fLength2 = pDirections[1].length();
                                var fLength3 = pDirections[2].length();
                                var fLength4 = pDirections[3].length();
                                var pTmp1 = [
                                    fLength1, 
                                    fLength2, 
                                    fLength3, 
                                    fLength4
                                ];
                                var pIndex = [
                                    -1, 
                                    -1, 
                                    -1, 
                                    -1
                                ];
                                for(var j = 0; j < 4; j++) {
                                    var iTest = 3;
                                    for(var k = 0; k < 4; k++) {
                                        if (k == j) {
                                            continue;
                                        }
                                        if (pTmp1[j] >= pTmp1[k]) {
                                            iTest--;
                                        }
                                    }
                                    for(var k = 0; k < 4; k++) {
                                        if (pIndex[iTest] == -1) {
                                            pIndex[iTest] = j;
                                            break;
                                        } else {
                                            iTest++;
                                        }
                                    }
                                }
                                var pDir1 = pDirections[pIndex[0]];
                                var pDir2 = pDirections[pIndex[1]];
                                var pTestPoint1 = pPlanePoints[pIndex[2]];
                                var pTestPoint2 = pPlanePoints[pIndex[3]];
                                pDir1.cross(pDir2, v3fNormal).normalize();
                                var pTestPlane = pTestArray[i];
                                pTestPlane.set(v3fNormal, -v3fNormal.dot(v3fLightPosition));
                                // console.log(pTestPlane.signedDistance(pTestPoint1), pTestPlane.signedDistance(pTestPoint2));
                                var fThreshold = 0.1;
                                if (akra.math.abs(pTestPlane.signedDistance(pTestPoint1)) <= fThreshold && akra.math.abs(pTestPlane.signedDistance(pTestPoint2)) <= fThreshold) {
                                    pTestPlane.set(pPlane.normal, -pPlane.normal.dot(v3fLightPosition));
                                } else if (pTestPlane.signedDistance(pTestPoint1) > 0 && akra.math.abs(pTestPlane.signedDistance(pTestPoint2)) > 0) {
                                    pTestPlane.negate();
                                }
                                // console.log(pTestPlane.normal.toString(), pTestPlane.distance);
                                // console.log(pTmp1[pIndex[0]], pTmp1[pIndex[1]], pTmp1[pIndex[2]], pTmp1[pIndex[3]]);
                                                            } else {
                                pTestArray[i].set(v3fNormal, fDistance);
                            }
                        }
                        nAdditionalTestLength = 6;
                    }
                    for(var i = 0; i < pRawResult.length; i++) {
                        var pObject = pRawResult.value(i);
                        var pWorldBounds = pObject.worldBounds;
                        //have object shadows?
                        if (pObject.hasShadow) {
                            var j = 0;
                            for(j = 0; j < nAdditionalTestLength; j++) {
                                var pPlane = pTestArray[j];
                                if (akra.geometry.planeClassifyRect3d(pPlane, pWorldBounds) == akra.EPlaneClassifications.PLANE_FRONT) {
                                    break;
                                }
                            }
                            if (j == nAdditionalTestLength) {
                                pResult.push(pObject);
                            }
                        } else {
                            if (pCameraFrustum.testRect(pWorldBounds)) {
                                pResult.push(pObject);
                            }
                        }
                    }
                    pShadowCaster._optimizeProjectionMatrix(pCameraFrustum);
                    return pResult;
                };
                ProjectLight._pFrustumPlanes = new Array(6);
                return ProjectLight;
            })(light.LightPoint);
            light.ProjectLight = ProjectLight;            
            for(var i = 0; i < 6; i++) {
                ProjectLight._pFrustumPlanes[i] = new akra.geometry.Plane3d();
            }
        })(scene.light || (scene.light = {}));
        var light = scene.light;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        (function (light) {
            var OmniParameters = (function () {
                function OmniParameters() {
                    this.ambient = new akra.Color();
                    this.diffuse = new akra.Color();
                    this.specular = new akra.Color();
                    this.attenuation = new akra.Vec3();
                }
                return OmniParameters;
            })();
            light.OmniParameters = OmniParameters;            
            var OmniLight = (function (_super) {
                __extends(OmniLight, _super);
                function OmniLight(pScene) {
                                _super.call(this, pScene, akra.ELightTypes.OMNI);
                    /**@protected*/ this._pDepthTextureCube = null;
                    /**@protected*/ this._pColorTextureCube = null;
                    /**@protected*/ this._pLightParameters = new OmniParameters();
                    /**@protected*/ this._pShadowCasterCube = null;
                    this._pShadowCasterCube = new Array(6);
                    for(var i = 0; i < 6; i++) {
                        this._pShadowCasterCube[i] = pScene._createShadowCaster(this, i);
                    }
                }
                Object.defineProperty(OmniLight.prototype, "params", {
                    get: /** @inline */function () {
                        return this._pLightParameters;
                    },
                    enumerable: true,
                    configurable: true
                });
                OmniLight.prototype.create = function (isShadowCaster, iMaxShadowResolution) {
                    if (typeof isShadowCaster === "undefined") { isShadowCaster = true; }
                    if (typeof iMaxShadowResolution === "undefined") { iMaxShadowResolution = 256; }
                    var isOk = _super.prototype.create.call(this, isShadowCaster, iMaxShadowResolution);
                    var pCasterCube = this._pShadowCasterCube;
                    var pCaster;
                    for(var i = 0; i < 6; i++) {
                        pCaster = pCasterCube[i];
                        pCaster.setInheritance(akra.ENodeInheritance.ALL);
                        pCaster.attachToParent(this);
                        pCaster.setProjParams(akra.math.PI / 2, 1, 0.01, 1000);
                        pCaster.setParameter(akra.ECameraParameters.CONST_ASPECT, true);
                    }
                    //POSITIVE_X
                    /*first column, not row!*/
                    pCasterCube[0].localMatrix = akra.Mat4.stackCeil.set([
                        0, 
                        0, 
                        1, 
                        0, 
                        0, 
                        1, 
                        0, 
                        0, 
                        -1, 
                        0, 
                        0, 
                        0, 
                        0, 
                        0, 
                        0, 
                        1
                    ]);
                    //NEGATIVE_X
                    /*first column, not row!*/
                    pCasterCube[1].localMatrix = akra.Mat4.stackCeil.set([
                        0, 
                        0, 
                        -1, 
                        0, 
                        0, 
                        1, 
                        0, 
                        0, 
                        1, 
                        0, 
                        0, 
                        0, 
                        0, 
                        0, 
                        0, 
                        1
                    ]);
                    //POSITIVE_Y
                    /*first column, not row!*/
                    pCasterCube[2].localMatrix = akra.Mat4.stackCeil.set([
                        1, 
                        0, 
                        0, 
                        0, 
                        0, 
                        0, 
                        1, 
                        0, 
                        0, 
                        -1, 
                        0, 
                        0, 
                        0, 
                        0, 
                        0, 
                        1
                    ]);
                    //NEGATIVE_Y
                    /*first column, not row!*/
                    pCasterCube[3].localMatrix = akra.Mat4.stackCeil.set([
                        1, 
                        0, 
                        0, 
                        0, 
                        0, 
                        0, 
                        -1, 
                        0, 
                        0, 
                        1, 
                        0, 
                        0, 
                        0, 
                        0, 
                        0, 
                        1
                    ]);
                    //POSITIVE_Z
                    /*first column, not row!*/
                    pCasterCube[4].localMatrix = akra.Mat4.stackCeil.set([
                        -1, 
                        0, 
                        0, 
                        0, 
                        0, 
                        1, 
                        0, 
                        0, 
                        0, 
                        0, 
                        -1, 
                        0, 
                        0, 
                        0, 
                        0, 
                        1
                    ]);
                    //NEGATIVE_Z
                    /*first column, not row!*/
                    pCasterCube[5].localMatrix = akra.Mat4.stackCeil.set([
                        1, 
                        0, 
                        0, 
                        0, 
                        0, 
                        1, 
                        0, 
                        0, 
                        0, 
                        0, 
                        1, 
                        0, 
                        0, 
                        0, 
                        0, 
                        1
                    ]);
                    if (((this)._isShadowCaster)) {
                        this.initializeTextures();
                    }
                    return isOk;
                };
                OmniLight.prototype.getDepthTextureCube = /** @inline */function () {
                    return this._pDepthTextureCube;
                };
                OmniLight.prototype.getRenderTarget = /** @inline */function (iFace) {
                    // return this._pDepthTextureCube[iFace].getBuffer().getRenderTarget();
                    return this._pColorTextureCube[iFace].getBuffer().getRenderTarget();
                };
                OmniLight.prototype.getShadowCaster = /** @inline */function () {
                    return this._pShadowCasterCube;
                };
                Object.defineProperty(OmniLight.prototype, "isShadowCaster", {
                    get: /** @inline */function () {
                        return this._isShadowCaster;
                    },
                    set: /**
                    * overridden setter isShadow caster,
                    * if depth textures don't created then create depth textures
                    */
                    function (bValue) {
                        this._isShadowCaster = bValue;
                        if (bValue && ((this._pDepthTextureCube) === null)) {
                            this.initializeTextures();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                OmniLight.prototype.initializeTextures = /**@protected*/ function () {
                    var pEngine = this.scene.getManager().getEngine();
                    var pResMgr = pEngine.getResourceManager();
                    var iSize = this._iMaxShadowResolution;
                    this._pDepthTextureCube = new Array(6);
                    this._pColorTextureCube = new Array(6);
                    for(var i = 0; i < 6; ++i) {
                        // if (this._pDepthTextureCube[i]) {
                        // 	this._pDepthTextureCube[i].destroyResource();
                        // }
                        var pDepthTexture = this._pDepthTextureCube[i] = pResMgr.createTexture("depth_texture_" + i + "_" + ((this)._iGuid));
                        pDepthTexture.create(iSize, iSize, 1, null, 0, 0, 0, akra.ETextureTypes.TEXTURE_2D, akra.EPixelFormats.DEPTH32);
                        pDepthTexture.setWrapMode(akra.ETextureParameters.WRAP_S, akra.ETextureWrapModes.CLAMP_TO_EDGE);
                        pDepthTexture.setWrapMode(akra.ETextureParameters.WRAP_T, akra.ETextureWrapModes.CLAMP_TO_EDGE);
                        pDepthTexture.setFilter(akra.ETextureParameters.MAG_FILTER, akra.ETextureFilters.LINEAR);
                        pDepthTexture.setFilter(akra.ETextureParameters.MIN_FILTER, akra.ETextureFilters.LINEAR);
                        var pColorTexture = this._pColorTextureCube[i] = pResMgr.createTexture("light_color_texture_" + i + "_" + ((this)._iGuid));
                        pColorTexture.create(iSize, iSize, 1, null, akra.ETextureFlags.RENDERTARGET, 0, 0, akra.ETextureTypes.TEXTURE_2D, akra.EPixelFormats.R8G8B8A8);
                        //TODO: Multiple render target
                        ((this)._pColorTextureCube[(i)].getBuffer().getRenderTarget()).attachDepthTexture(pDepthTexture);
                        ((this)._pColorTextureCube[(i)].getBuffer().getRenderTarget()).setAutoUpdated(false);
                        ((this)._pColorTextureCube[(i)].getBuffer().getRenderTarget()).addViewport(this._pShadowCasterCube[i], akra.EViewportTypes.SHADOWVIEWPORT);
                    }
                };
                OmniLight.prototype._calculateShadows = function () {
                    if (((this)._isEnabled) && ((this)._isShadowCaster)) {
                        for(var i = 0; i < 6; i++) {
                            ((this)._pColorTextureCube[(i)].getBuffer().getRenderTarget()).update();
                            // this.getRenderTarget(i).getRenderer()._setViewport(this.getRenderTarget(i).getViewport(0));
                            // console.log("GL_DEPTH_RANLE", (<webgl.WebGLRenderer>this.getRenderTarget(i).getRenderer()).getWebGLContext().getParameter(0x0B70));
                                                    }
                    }
                };
                OmniLight.prototype._prepareForLighting = function (pCamera) {
                    if (!((this)._isEnabled)) {
                        return false;
                    } else {
                        /*************************************************************/
                        //optimize camera frustum
                        var pDepthRange = pCamera.getDepthRange();
                        var fFov = pCamera.fov;
                        var fAspect = pCamera.aspect;
                        var m4fTmp = /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/akra.Mat4.perspective(fFov, fAspect, -pDepthRange.min, -pDepthRange.max, akra.Mat4.stackCeil.set());
                        ((this)._pOptimizedCameraFrustum).extractFromMatrix(m4fTmp, pCamera.worldMatrix);
                        /*************************************************************/
                        var haveInfluence = false;
                        if (!((this)._isShadowCaster)) {
                            for(var i = 0; i < 6; i++) {
                                var pResult = this._defineLightingInfluence(pCamera, i);
                                if (pResult.length != 0) {
                                    haveInfluence = true;
                                }
                            }
                            return haveInfluence;
                        } else {
                            for(var i = 0; i < 6; i++) {
                                var pResult = this._defineShadowInfluence(pCamera, i);
                                if (pResult.length != 0) {
                                    haveInfluence = true;
                                }
                            }
                            return haveInfluence;
                        }
                    }
                };
                OmniLight.prototype._defineLightingInfluence = /**@protected*/ function (pCamera, iFace) {
                    var pShadowCaster = this._pShadowCasterCube[iFace];
                    var pCameraFrustum = ((this)._pOptimizedCameraFrustum);
                    // var pCameraFrustum: IFrustum = pCamera.frustum;
                    var pResult = pShadowCaster.affectedObjects;
                    pResult.clear();
                    //fast test on frustum intersection
                    if (!pCameraFrustum.testFrustum(pShadowCaster.frustum)) {
                        //frustums don't intersecting
                        return pResult;
                    }
                    var pRawResult = pShadowCaster.display(0);
                    for(var i = 0; i < pRawResult.length; i++) {
                        var pObject = pRawResult.value(i);
                        if (pCameraFrustum.testRect(pObject.worldBounds)) {
                            pResult.push(pObject);
                        }
                    }
                    return pResult;
                };
                OmniLight.prototype._defineShadowInfluence = /**@protected*/ function (pCamera, iFace) {
                    var pShadowCaster = this._pShadowCasterCube[iFace];
                    var pCameraFrustum = ((this)._pOptimizedCameraFrustum);
                    var pResult = pShadowCaster.affectedObjects;
                    pResult.clear();
                    //fast test on frustum intersection
                    if (!pCameraFrustum.testFrustum(pShadowCaster.frustum)) {
                        //frustums don't intersecting
                        pShadowCaster._optimizeProjectionMatrix(pCameraFrustum);
                        return pResult;
                    }
                    var pRawResult = pShadowCaster.display(0);
                    var v3fLightPosition = ((this)._v3fWorldPosition);
                    var pTestArray = OmniLight._pFrustumPlanes;
                    var pFrustumPlanesKeys = akra.geometry.Frustum.frustumPlanesKeys;
                    //frustum projection
                    //TODO: rewrite additional testing
                    //create list for additional testing
                    var v3fLightPosition = ((this)._v3fWorldPosition);
                    for(var i = 0; i < 6; i++) {
                        var sKey = pFrustumPlanesKeys[i];
                        var pPlane = pCameraFrustum[sKey];
                        var v3fNormal = akra.Vec3.stackCeil.set().set(pPlane.normal);
                        var fDistance = pPlane.distance;
                        if (pPlane.signedDistance(v3fLightPosition) > 0) {
                            // fDistance = -v3fNormal.dot(v3fLightPosition);
                            var pPlanePoints = [
                                new akra.Vec3(), 
                                new akra.Vec3(), 
                                new akra.Vec3(), 
                                new akra.Vec3()
                            ];
                            pCameraFrustum.getPlanePoints(sKey, pPlanePoints);
                            //find far points;
                            var pDirections = new Array(4);
                            for(var j = 0; j < 4; j++) {
                                pDirections[j] = new akra.Vec3();
                                pPlanePoints[j].subtract(v3fLightPosition, pDirections[j]);
                            }
                            var fLength1 = pDirections[0].length();
                            var fLength2 = pDirections[1].length();
                            var fLength3 = pDirections[2].length();
                            var fLength4 = pDirections[3].length();
                            var pTmp1 = [
                                fLength1, 
                                fLength2, 
                                fLength3, 
                                fLength4
                            ];
                            var pIndex = [
                                -1, 
                                -1, 
                                -1, 
                                -1
                            ];
                            for(var j = 0; j < 4; j++) {
                                var iTest = 3;
                                for(var k = 0; k < 4; k++) {
                                    if (k == j) {
                                        continue;
                                    }
                                    if (pTmp1[j] >= pTmp1[k]) {
                                        iTest--;
                                    }
                                }
                                for(var k = 0; k < 4; k++) {
                                    if (pIndex[iTest] == -1) {
                                        pIndex[iTest] = j;
                                        break;
                                    } else {
                                        iTest++;
                                    }
                                }
                            }
                            var pDir1 = pDirections[pIndex[0]];
                            var pDir2 = pDirections[pIndex[1]];
                            var pTestPoint1 = pPlanePoints[pIndex[2]];
                            var pTestPoint2 = pPlanePoints[pIndex[3]];
                            pDir1.cross(pDir2, v3fNormal).normalize();
                            var pTestPlane = pTestArray[i];
                            pTestPlane.set(v3fNormal, -v3fNormal.dot(v3fLightPosition));
                            // console.log(pTestPlane.signedDistance(pTestPoint1), pTestPlane.signedDistance(pTestPoint2));
                            var fThreshold = 0.1;
                            if (akra.math.abs(pTestPlane.signedDistance(pTestPoint1)) <= fThreshold && akra.math.abs(pTestPlane.signedDistance(pTestPoint2)) <= fThreshold) {
                                pTestPlane.set(pPlane.normal, -pPlane.normal.dot(v3fLightPosition));
                            } else if (pTestPlane.signedDistance(pTestPoint1) > 0 && akra.math.abs(pTestPlane.signedDistance(pTestPoint2)) > 0) {
                                pTestPlane.negate();
                            }
                            // console.log(pTestPlane.normal.toString(), pTestPlane.distance);
                            // console.log(pTmp1[pIndex[0]], pTmp1[pIndex[1]], pTmp1[pIndex[2]], pTmp1[pIndex[3]]);
                                                    } else {
                            pTestArray[i].set(v3fNormal, fDistance);
                        }
                    }
                    for(var i = 0; i < pRawResult.length; i++) {
                        var pObject = pRawResult.value(i);
                        var pWorldBounds = pObject.worldBounds;
                        //have object shadows?
                        if (pObject.hasShadow) {
                            var j = 0;
                            for(j = 0; j < 6; j++) {
                                var pPlane = pTestArray[j];
                                if (akra.geometry.planeClassifyRect3d(pPlane, pWorldBounds) == akra.EPlaneClassifications.PLANE_FRONT) {
                                    break;
                                }
                            }
                            if (j == 6) {
                                pResult.push(pObject);
                            }
                        } else {
                            if (pCameraFrustum.testRect(pWorldBounds)) {
                                pResult.push(pObject);
                            }
                        }
                    }
                    pShadowCaster._optimizeProjectionMatrix(pCameraFrustum);
                    return pResult;
                };
                OmniLight._pFrustumPlanes = new Array(6);
                return OmniLight;
            })(light.LightPoint);
            light.OmniLight = OmniLight;            
            for(var i = 0; i < 6; i++) {
                OmniLight._pFrustumPlanes[i] = new akra.geometry.Plane3d();
            }
        })(scene.light || (scene.light = {}));
        var light = scene.light;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        (function (light) {
            var SunParameters = (function () {
                function SunParameters() {
                    this.eyePosition = new akra.Vec3();
                    this.sunDir = new akra.Vec3();
                    this.groundC0 = new akra.Vec3();
                    this.groundC1 = new akra.Vec3();
                    this.hg = new akra.Vec3();
                }
                return SunParameters;
            })();
            light.SunParameters = SunParameters;            
            var SunLight = (function (_super) {
                __extends(SunLight, _super);
                function SunLight(pScene) {
                                _super.call(this, pScene, akra.ELightTypes.SUN);
                    /**@protected*/ this._pLightParameters = new SunParameters();
                    /**@protected*/ this._pSkyDome = null;
                }
                Object.defineProperty(SunLight.prototype, "params", {
                    get: /** @inline */function () {
                        return this._pLightParameters;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SunLight.prototype, "skyDome", {
                    get: /** @inline */function () {
                        return this._pSkyDome;
                    },
                    set: /** @inline */function (pSkyDome) {
                        this._pSkyDome = pSkyDome;
                    },
                    enumerable: true,
                    configurable: true
                });
                SunLight.prototype._calculateShadows = function () {
                };
                SunLight.prototype._prepareForLighting = // create(caster: bool): bool{
                // 	return super.create(false, 0);
                // };
                function (pCamera) {
                    return true;
                };
                return SunLight;
            })(light.LightPoint);
            light.SunLight = SunLight;            
        })(scene.light || (scene.light = {}));
        var light = scene.light;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        var Scene3d = (function () {
            function Scene3d(pSceneManager) {
                // protected _pNodeList: ISceneNode[];
                // protected _pObjectList: ISceneObject[];
                /**@protected*/ this._pDisplayLists = [];
                /**@protected*/ this._pDisplayListsCount = 0;
                /**@protected*/ this._isUpdated = false;
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
                this._pSceneManager = pSceneManager;
                this._pRootNode = this.createNode("root-node");
                this._pRootNode.create();
                var i;
                //TODO: fix this method, do right!!
                var pOctree = new akra.scene.OcTree();
                pOctree.create(new akra.geometry.Rect3d(1024, 1024, 1024), 5, 100);
                var i = /*not inlined, because supportes only single statement functions(cur. st. count: 12)*/this.addDisplayList(pOctree);
 {
                    akra.logger.setSourceLocation("Scene3d.ts", 62);
                    akra.logger.assert(i == 0, "invalid default list index");
                }
                ;
                var pLightGraph = new akra.scene.LightGraph();
                i = /*not inlined, because supportes only single statement functions(cur. st. count: 12)*/this.addDisplayList(pLightGraph);
 {
                    akra.logger.setSourceLocation("Scene3d.ts", 67);
                    akra.logger.assert(i == 1, "invalid default list index");
                }
                ;
                // this._pNodeList = [];
                // this._pObjectList = [];
                //TODO передача пользовательских параметров в OcTree
                // i = this.addDisplayList(new OcTree);
                // debug_assert(i == DL_DEFAULT, "invalid default list index");
                //TODO передача пользовательских параметров в LightGraph
                // i = this.addDisplayList(new LightGraph);
                // debug_assert(i == DL_LIGHTING, "invalid lighting list index");
                            }
            Object.defineProperty(Scene3d.prototype, "type", {
                get: /** @inline */function () {
                    return akra.ESceneTypes.TYPE_3D;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Scene3d.prototype, "totalDL", {
                get: /** @inline */function () {
                    return this._pDisplayListsCount;
                },
                enumerable: true,
                configurable: true
            });
            Scene3d.prototype.getManager = /** @inline */function () {
                return this._pSceneManager;
            };
            Scene3d.prototype.isUpdated = /** @inline */function () {
                return this._isUpdated;
            };
            Scene3d.prototype.getRootNode = /** @inline */function () {
                return this._pRootNode;
            };
            Scene3d.prototype.recursivePreUpdate = function () {
                this._isUpdated = false;
                this.preUpdate();
                this._pRootNode.recursivePreUpdate();
            };
            Scene3d.prototype.recursiveUpdate = function () {
                this.beforeUpdate();
                this._isUpdated = this._pRootNode.recursiveUpdate();
                this.postUpdate();
            };
            Scene3d.prototype.updateCamera = function () {
                return false;
            };
            Scene3d.prototype.updateScene = function () {
                return false;
            };
            Scene3d.prototype.createObject = function (sName) {
                if (typeof sName === "undefined") { sName = null; }
                var pNode = new scene.SceneObject(this);
                if (!pNode.create()) {
 {
                        akra.logger.setSourceLocation("Scene3d.ts", 123);
                        akra.logger.error("cannot create scene node..");
                    }
                    ;
                    return null;
                }
                return this.setupNode(pNode, sName);
            };
            Scene3d.prototype.createNode = function (sName) {
                if (typeof sName === "undefined") { sName = null; }
                var pNode = new scene.SceneNode(this);
                if (!pNode.create()) {
 {
                        akra.logger.setSourceLocation("Scene3d.ts", 136);
                        akra.logger.error("cannot create scene node..");
                    }
                    ;
                    return null;
                }
                return this.setupNode(pNode, sName);
            };
            Scene3d.prototype.createModel = function (sName) {
                if (typeof sName === "undefined") { sName = null; }
                var pNode = new scene.SceneModel(this);
                if (!pNode.create()) {
 {
                        akra.logger.setSourceLocation("Scene3d.ts", 147);
                        akra.logger.error("cannot create model..");
                    }
                    ;
                    return null;
                }
                return this.setupNode(pNode, sName);
            };
            Scene3d.prototype.createCamera = function (sName) {
                if (typeof sName === "undefined") { sName = null; }
                var pCamera = new scene.objects.Camera(this);
                if (!pCamera.create()) {
 {
                        akra.logger.setSourceLocation("Scene3d.ts", 158);
                        akra.logger.error("cannot create camera..");
                    }
                    ;
                    return null;
                }
                return this.setupNode(pCamera, sName);
            };
            Scene3d.prototype.createLightPoint = function (eType, isShadowCaster, iMaxShadowResolution, sName) {
                if (typeof eType === "undefined") { eType = akra.ELightTypes.UNKNOWN; }
                if (typeof isShadowCaster === "undefined") { isShadowCaster = true; }
                if (typeof iMaxShadowResolution === "undefined") { iMaxShadowResolution = 256; }
                if (typeof sName === "undefined") { sName = null; }
                var pLight;
                switch(eType) {
                    case akra.ELightTypes.PROJECT:
                        pLight = (new scene.light.ProjectLight(this));
                        break;
                    case akra.ELightTypes.OMNI:
                        pLight = (new scene.light.OmniLight(this));
                        break;
                    case akra.ELightTypes.SUN:
                        pLight = (new scene.light.SunLight(this));
                        break;
                    default:
                        return null;
                }
                if (!pLight.create(isShadowCaster, iMaxShadowResolution)) {
 {
                        akra.logger.setSourceLocation("Scene3d.ts", 185);
                        akra.logger.error("cannot create light");
                    }
                    ;
                    return null;
                }
                return this.setupNode(pLight, sName);
            };
            Scene3d.prototype.createSprite = function (sName) {
                if (typeof sName === "undefined") { sName = null; }
                return null;
            };
            Scene3d.prototype.createJoint = function (sName) {
                if (typeof sName === "undefined") { sName = null; }
                return this.setupNode(new scene.Joint(this), sName);
            };
            Scene3d.prototype._createModelEntry = function (pModel) {
                return this.setupNode(new scene.objects.ModelEntry(this, pModel));
            };
            Scene3d.prototype.createText3d = function (sName) {
                if (typeof sName === "undefined") { sName = null; }
                return null;
            };
            Scene3d.prototype.createTerrain = function (sName) {
                var pTerrain = new akra.terrain.Terrain(this);
                if (!pTerrain.create()) {
 {
                        akra.logger.setSourceLocation("Scene3d.ts", 213);
                        akra.logger.error("cannot create terrain..");
                    }
                    ;
                    return null;
                }
                return this.setupNode(pTerrain, sName);
            };
            Scene3d.prototype.createTerrainROAM = function (sName) {
                var pTerrainROAM = new akra.terrain.TerrainROAM(this);
                if (!pTerrainROAM.create()) {
 {
                        akra.logger.setSourceLocation("Scene3d.ts", 224);
                        akra.logger.error("cannot create terrain..");
                    }
                    ;
                    return null;
                }
                return this.setupNode(pTerrainROAM, sName);
            };
            Scene3d.prototype.createTerrainSection = function (sName) {
                var pNode = new akra.terrain.TerrainSection(this);
                if (!pNode.create()) {
 {
                        akra.logger.setSourceLocation("Scene3d.ts", 235);
                        akra.logger.error("cannot create terrain section..");
                    }
                    ;
                    return null;
                }
                return this.setupNode(pNode, sName);
            };
            Scene3d.prototype.createTerrainSectionROAM = function (sName) {
                var pNode = new akra.terrain.TerrainSectionROAM(this);
                if (!pNode.create()) {
 {
                        akra.logger.setSourceLocation("Scene3d.ts", 246);
                        akra.logger.error("cannot create terrain section roam..");
                    }
                    ;
                    return null;
                }
                return this.setupNode(pNode, sName);
            };
            Scene3d.prototype._createShadowCaster = function (pLightPoint, iFace, sName) {
                if (typeof iFace === "undefined") { iFace = akra.ECubeFace.POSITIVE_X; }
                if (typeof sName === "undefined") { sName = null; }
                var pShadowCaster = new scene.light.ShadowCaster(pLightPoint, iFace);
                if (!pShadowCaster.create()) {
 {
                        akra.logger.setSourceLocation("Scene3d.ts", 257);
                        akra.logger.error("cannot create shadow caster..");
                    }
                    ;
                    return null;
                }
                return this.setupNode(pShadowCaster, sName);
            };
            Scene3d.prototype.getDisplayList = // inline getAllNodes(): ISceneNode[] {
            // 	return this._pNodeList;
            // }
            // inline getAllObjects(): ISceneObject[] {
            // 	return this._pObjectList;
            // }
            /** @inline */function (i) {
 {
                    akra.logger.setSourceLocation("Scene3d.ts", 274);
                    akra.logger.assert(((this._pDisplayLists[i]) != null), "display list not defined");
                }
                ;
                return this._pDisplayLists[i];
            };
            Scene3d.prototype.getDisplayListByName = function (csName) {
                for(var i = 0; i < this._pDisplayLists.length; ++i) {
                    if (this._pDisplayLists[i].name === csName) {
                        return i;
                    }
                }
                return -1;
            };
            Scene3d.prototype._render = // _findObjects(pCamera: ICamera, csList: string = null): ISceneObject[] {
            // 	var pList: IDisplayList = this._pDisplayListMap[csList || DEFAULT_DLIST];
            // 	debug_assert(!isNull(pList), "display list not founded.");
            // 	return pList.findObjects(pCamera);
            // }
            function (pCamera, pViewport) {
            };
            Scene3d.prototype.setupNode = function (pNode, sName) {
                if (typeof sName === "undefined") { sName = null; }
                pNode.name = sName;
                ((pNode).getEventTable().addDestination(((((pNode)))._iGuid), ("attached"), (this), ("nodeAttachment"), (/*checked (origin: akra)>>*/akra.EEventTypes.UNICAST)));
                ((pNode).getEventTable().addDestination(((((pNode)))._iGuid), ("detached"), (this), ("nodeDetachment"), (/*checked (origin: akra)>>*/akra.EEventTypes.UNICAST)));
                return pNode;
            };
            Scene3d.prototype.delDisplayList = function (index) {
                var pLists = this._pDisplayLists;
                for(var i = 0; i < pLists.length; ++i) {
                    if (i === index && ((pLists[i]) != null)) {
                        pLists[i] = null;
                        this._pDisplayListsCount--;
                        this.displayListRemoved(pLists[i], i);
                        return true;
                    }
                }
                ;
                return false;
            };
            Scene3d.prototype.addDisplayList = /** @inline */function (pList) {
 {
                    akra.logger.setSourceLocation("Scene3d.ts", 329);
                    akra.logger.assert(((this.getDisplayListByName(pList.name)) != null), "DL with name <" + pList.name + "> already exists");
                }
                ;
                var pLists = this._pDisplayLists;
                var iIndex = this._pDisplayLists.length;
                for(var i = 0; i < pLists.length; ++i) {
                    if (pLists[i] === null) {
                        pLists[i] = pList;
                        iIndex = i;
                        break;
                    }
                }
                ;
                if (iIndex == this._pDisplayLists.length) {
                    this._pDisplayLists.push(pList);
                }
                pList._setup(this);
                this.displayListAdded(pList, iIndex);
                this._pDisplayListsCount++;
                return iIndex;
            };
            Scene3d.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            Scene3d._pEventTable = new akra.events.EventTable();
            Scene3d.prototype.getEventTable = /** @inline */function () {
                return Scene3d._pEventTable;
            };
            Scene3d.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Scene3d.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Scene3d.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (Scene3d._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Scene3d.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (Scene3d._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Scene3d.prototype._syncTable = /** @inline */function (pFrom) {
                (Scene3d._pEventTable)._sync(this, pFrom);
            };
            Scene3d.prototype.nodeAttachment = function (pNode) {
                // this._pNodeList.push(pNode);
                // if (SceneObject.isSceneObject(pNode)) {
                // 	this._pObjectList.push(<ISceneObject>pNode);
                // }
                // console.warn("------>here");
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Scene3d._pEventTable))).broadcast[(this._iGuid)] = (((Scene3d._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).nodeAttachment;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pNode) : _broadcast[i].listener(_recivier, pNode);
                    }
                }
                ;
            };
            Scene3d.prototype.nodeDetachment = function (pNode) {
                // for (var i: int = 0; i < this._pNodeList.length; ++ i) {
                // 	if (pNode == this._pNodeList[i]) {
                // 		this._pNodeList.splice(i, 1);
                // 		break;
                // 	}
                // };
                // if (SceneObject.isSceneObject(pNode)) {
                // 	for (var i: int = 0; i < this._pObjectList.length; ++ i) {
                // 		if (<ISceneObject>pNode == this._pObjectList[i]) {
                // 			this._pObjectList.splice(i, 1);
                // 			break;
                // 		}
                // 	};
                // }
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Scene3d._pEventTable))).broadcast[(this._iGuid)] = (((Scene3d._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).nodeDetachment;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pNode) : _broadcast[i].listener(_recivier, pNode);
                    }
                }
                ;
            };
            Scene3d.prototype.displayListAdded = function (list, index) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Scene3d._pEventTable))).broadcast[(this._iGuid)] = (((Scene3d._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).displayListAdded;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, list, index) : _broadcast[i].listener(_recivier, list, index);
                    }
                }
            };
            Scene3d.prototype.displayListRemoved = function (list, index) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Scene3d._pEventTable))).broadcast[(this._iGuid)] = (((Scene3d._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).displayListRemoved;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, list, index) : _broadcast[i].listener(_recivier, list, index);
                    }
                }
            };
            Scene3d.prototype.beforeUpdate = function () {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Scene3d._pEventTable))).broadcast[(this._iGuid)] = (((Scene3d._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).beforeUpdate;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            Scene3d.prototype.postUpdate = function () {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Scene3d._pEventTable))).broadcast[(this._iGuid)] = (((Scene3d._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).postUpdate;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            Scene3d.prototype.preUpdate = function () {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Scene3d._pEventTable))).broadcast[(this._iGuid)] = (((Scene3d._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).preUpdate;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            return Scene3d;
        })();
        scene.Scene3d = Scene3d;        
        // BROADCAST(nodeAttachment, CALL(pNode));
        // BROADCAST(nodeDetachment, CALL(pNode));
            })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        var SceneManager = (function () {
            function SceneManager(pEngine) {
                this._pEngine = null;
                this._pSceneList = [];
                this._fUpdateTimeCount = 0.;
                /*60 updates per frame*/
                this._fMillisecondsPerTick = 0.01666;
                this._pEngine = pEngine;
            }
            SceneManager.prototype.getEngine = function () {
                return this._pEngine;
            };
            SceneManager.prototype.update = function () {
                var isSceneUpdated = false;
                // add the real time elapsed to our
                // internal delay counter
                this._fUpdateTimeCount += this._pEngine.elapsedTime;
                // is there an update ready to happen?
                // LOG(this._fUpdateTimeCount, this._pEngine.elapsedTime);
                var fUpdateTime = this._fUpdateTimeCount;
                while(this._fUpdateTimeCount > this._fMillisecondsPerTick) {
                    // update the scene
                    this.notifyUpdateScene();
                    // subtract the time interval
                    // emulated with each tick
                    this._fUpdateTimeCount -= this._fMillisecondsPerTick;
                }
                if (fUpdateTime !== this._fUpdateTimeCount) {
                    this.notifyPreUpdateScene();
                }
            };
            SceneManager.prototype.notifyUpdateScene = // inline preUpdate(): void {
            //     this.notifyPreUpdateScene();
            // }
            function () {
                // update the scene attached to the root node
                for(var i = 0; i < this._pSceneList.length; ++i) {
                    var pScene = this._pSceneList[i];
                    if (pScene.type != akra.ESceneTypes.TYPE_3D) {
                        continue;
                    }
                    (pScene).recursiveUpdate();
                }
            };
            SceneManager.prototype.notifyPreUpdateScene = function () {
                for(var i = 0; i < this._pSceneList.length; ++i) {
                    var pScene = this._pSceneList[i];
                    if (pScene.type != akra.ESceneTypes.TYPE_3D) {
                        continue;
                    }
                    (pScene).recursivePreUpdate();
                }
            };
            SceneManager.prototype.createScene3D = function () {
                var pScene = new scene.Scene3d(this);
                this._pSceneList.push(pScene);
                return pScene;
            };
            SceneManager.prototype.createScene2D = function () {
                return null;
            };
            SceneManager.prototype.createUI = function () {
                return null;
            };
            SceneManager.prototype.getScene3D = function (iScene) {
                if (typeof iScene === "undefined") { iScene = 0; }
                var pScene;
                if (iScene === 0 && this._pSceneList.length === 0) {
                    this.createScene3D();
 {
                        akra.logger.setSourceLocation("scene/SceneManager.ts", 109);
                        akra.logger.log("Default scene automatically created.");
                    }
                    ;
                }
                pScene = this._pSceneList[iScene];
                if (pScene && pScene.type === akra.ESceneTypes.TYPE_3D) {
                    return pScene;
                }
                return null;
            };
            SceneManager.prototype.getScene2D = function (IScene) {
                var pScene = this._pSceneList[IScene];
                if (pScene && pScene.type === akra.ESceneTypes.TYPE_2D) {
                    return pScene;
                }
                return null;
            };
            SceneManager.prototype.getScene = function (IScene, eType) {
                return this._pSceneList[IScene] || null;
            };
            SceneManager.prototype.initialize = function () {
                //this.initText2Dlayer();
                return true;
            };
            SceneManager.prototype.destroy = function () {
            };
            return SceneManager;
        })();
        scene.SceneManager = SceneManager;        
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    /** @inline */
    /*
    draw2DText(iX: int = 0, iY: int = 0, sText: string = "", pFont: IFont2d = new util.Font2d()): IString2d {
    return (new a.String2D(iX, iY, pFont, sStr, this.pTextLayer));
    }
    
    
    
    private initText2Dlayer(): void {
    var pCanvas: HTMLCanvasElement = this.pEngine.canvas;
    var x: int = findPosX(pCanvas);
    var y: int = findPosY(pCanvas);
    
    var pDiv: HTMLDivElement = <HTMLDivElement>document.createElement('div');
    var pStyle: CSSStyleDeclaration = pDiv.style;
    var pScreen: IScreenInfo = info.screen;
    
    var iBorder: int = 0;
    
    pDiv.setAttribute("id", "akra-canvas-overlay");
    
    pStyle.width = String(pScreen.width) + "px";
    pStyle.height = String(pScreen.height) + "px";
    
    if (pCanvas.style.border != "none") {
    iBorder = parseInt(pCanvas.style.border);
    }
    
    pStyle.position = 'absolute';
    pStyle.left = String(x) + 'px';
    pStyle.top = String(y) + 'px';
    
    pStyle.overflow = 'hidden';
    pStyle.whiteSpace = 'nowrap';
    
    if (pCanvas.style.zIndex) {
    pStyle.zIndex = pCanvas.style.zIndex + 1;
    }
    else {
    pStyle.zIndex = 2;
    }
    
    document.body.appendChild(pDiv);
    
    this.pTextLayer = pDiv;
    }
    */
    // #ifndef IAFXEFFECT_TS
    // #define IAFXEFFECT_TS
    // #include "IResourcePoolItem.ts"
    // module akra {
    // 	export interface IAFXEffect extends IResourcePoolItem {
    // 	}
    // }
    // #endif
    // #ifndef IAFXEFFECT_TS
    // #define IAFXEFFECT_TS
    // #include "IResourcePoolItem.ts"
    // module akra {
    // 	export interface IAFXEffect extends IResourcePoolItem {
    // 	}
    // }
    // #endif
    (function (fx) {
        //Errors
        akra.logger.registerCode(2201, "You trying to redefine system type: {typeName}. In line: {line}. In column: {column}");
        akra.logger.registerCode(2202, "You trying to redefine type: {typeName}. In line: {line}. In column: {column}");
        akra.logger.registerCode(2203, "You try to use unssuported type declaration. We implement it soon. In line: {line}.");
        akra.logger.registerCode(2204, "You try to use unssuported expr: {exprName}. We implement it soon. In line: {line}.");
        akra.logger.registerCode(2205, "Unknown variable name: {varName}. In line: {line}. In column: {column}");
        akra.logger.registerCode(2206, "Invalid arithmetic operation!. There no operator '{operator}'" + " for left-type '{leftTypeName}' " + " and right-type '{rightTypeName}'. In line: {line}.");
        akra.logger.registerCode(2207, "Invalid arithmetic-assignment operation!. " + " There no operator {operator} for left-type '{leftTypeName}' " + " and right-type '{rightTypeName}'. In line: {line}.");
        akra.logger.registerCode(2208, "Invalid assignment operation!. It`s no possible to do assignment " + " between left-type '{leftTypeName}' " + " and right-type '{rightTypeName}'. In line: {line}.");
        akra.logger.registerCode(2209, "Invalid relational operation!. There no operator {operator} " + " for left-type '{leftTypeName}' " + " and right-type '{rightTypeName}'. In line: {line}.");
        akra.logger.registerCode(2210, "Invalid logical operation!. In operator: {operator}. " + " Cannot convert type '{typeName}' to 'bool'. In line: {line}.");
        akra.logger.registerCode(2211, "Invalid conditional expression!. Cannot convert type '{typeName}' to 'bool'. " + " In line: {line}.");
        akra.logger.registerCode(2212, "Invalid conditional expression!. Type '{leftTypeName}' and type '{rightTypeName}'" + " are not equal. In line: {line}.");
        akra.logger.registerCode(2213, "Invalid type cast!. Bad type casting. Only base types without usages are supported. " + " WebGL don`t support so casting. In line: {line}.");
        akra.logger.registerCode(2214, "Invalid type cast!. Bad type for casting '{typeName}'. " + " WebGL support only base-type casting. In line: {line}.");
        akra.logger.registerCode(2216, "Invalid unary expression!. Bad type: '{typeName}' " + " for operator '{opeator}'. In line: {line}.");
        akra.logger.registerCode(2217, "Invalid postfix-array expression!. " + " Type of expression is not array: '{typeName}'. In line: {line}.");
        akra.logger.registerCode(2218, "Invalid postfix-array expression!. Bad type of index: '{typeName}'. " + "Must be 'int'. In line: {line}.");
        akra.logger.registerCode(2219, "Invalid postfix-point expression!. Type '{typeName}' has no field '{fieldName}'. " + "In line: {line}.");
        akra.logger.registerCode(2220, "Invalid postfix-point expression!. Type '{typeName}' is not pointer. " + "In line: {line}.");
        akra.logger.registerCode(2221, "Invalid postfix-arithmetic expression!. Bad type '{typeName}' " + "for operator {operator}. In line: {line}.");
        akra.logger.registerCode(2222, "Invalid primary expression!. Bad type '{typeName}'." + "It`s not pointer. In line: {line}.");
        akra.logger.registerCode(2223, "Invalid function call expression!. Could not find function-signature " + "with name {funcName} and so types. In line: {line}.");
        akra.logger.registerCode(2224, "Invalid constructor call!. There are not so type. In line: {line}.");
        akra.logger.registerCode(2225, "Invalid constructor call!. Could not find constructor-signature " + "with name {typeName} and so types. In line: {line}.");
        akra.logger.registerCode(2226, "Invalid compile expression!. Could not find function-signature " + "with name {funcName} and so types. In line: {line}.");
        akra.logger.registerCode(2227, "You try to redefine function. With name {funcName}. In line: {line}.");
        akra.logger.registerCode(2228, "Bad type of while-condition. Must be 'bool' but it is '{typeName}'. " + "In line: {line}.");
        akra.logger.registerCode(2229, "Bad type of do-while-condition. Must be 'bool' but it is '{typeName}'. " + "In line: {line}.");
        akra.logger.registerCode(2230, "Bad type of if-condition. Must be 'bool' but it is '{typeName}'. " + "In line: {line}.");
        akra.logger.registerCode(2231, "Bad for-init expression. WebGL support only VariableDecl as for-init expression, " + "like \"int i = 0;\" or \"float i = 0.0;\". " + "In line: {line}.");
        akra.logger.registerCode(2232, "Bad for-init expression. WebGL support only VariableDecl as for-init expression, " + "like \"int i = 0;\" or \"float i = 0.0;\". " + "In line: {line}.");
        akra.logger.registerCode(2233, "Bad for-cond expression. WebGL does not support empty conditional expression in for-loop. " + "In line: {line}.");
        akra.logger.registerCode(2238, "Bad for-cond expression. WebGL support only relational expression for condition in for-loop. " + "In line: {line}.");
        akra.logger.registerCode(2239, "Bad for-step expression. WebGL does not support empty step expression. " + "In line: {line}.");
        akra.logger.registerCode(2240, "Bad for-step expression. WebGL does not support operator '{operator}' in step expression. " + "In line: {line}.");
        akra.logger.registerCode(2241, "Bad for-step expression. WebGL support only unary and assignment expression in for-step. " + "In line: {line}.");
        akra.logger.registerCode(2235, "You trying to redefine system variable: {varName}. In line: {line}. In column: {column}");
        akra.logger.registerCode(2234, "You trying to redefine variable: {varName}. In line: {line}. In column: {column}");
        akra.logger.registerCode(2237, "You trying to redefine system function: {funcName}. In line: {line}. In column: {column}");
        akra.logger.registerCode(2236, "You trying to redefine function: {funcName}. In line: {line}. In column: {column}");
        akra.logger.registerCode(2242, "You trying to add field to struct with name '{varName}', but it`s already in it. " + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2243, "You trying to add field to struct with semantic '{semanticName}'," + "but struct already has this semantic." + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2244, "Bad variable name '{varName}'. Annotation already has variable with that name." + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2245, "Bad parameter '{varName}' in function '{funcName}'. Need default value." + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2246, "Bad function call. There are two or more call signatures for function '{funcName}'." + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2247, "Bad function definition. There are two or more different retturn type signatures for function '{funcName}'." + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2248, "Bad system function '{funcName}'. Already have this function.");
        akra.logger.registerCode(2250, "Bad type. Could not find type with name '{typeName}'." + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2251, "Bad type. We don`t support vector and matrix typename." + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2252, "Bad technique name '{techName}'. Effect already have technique with that name." + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2253, "Bad 'memof'-operator argument. Literal for its argument is bad idea." + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2254, "Bad 'memof'-operator argument. No buffer for argument." + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2255, "Bad function '{funcDef}'. It is recursion.");
        akra.logger.registerCode(2256, "Bad function '{funcDef}'. It use bad-function with recursion.");
        akra.logger.registerCode(2257, "Bad function '{funcDef}'. Can not use in vertex-shader.");
        akra.logger.registerCode(2258, "Bad function '{funcDef}'. Can not use in pixel-shader.");
        akra.logger.registerCode(2259, "Bad function with defenition '{funcDef}'. Can not be used as vertex-shader.");
        akra.logger.registerCode(2260, "Bad function with defenition '{funcDef}'. Can not be used as pixel-shader.");
        akra.logger.registerCode(2261, "Bad return stmt. You try to return something in void-function." + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2262, "Bad return stmt. You can not call empty return in non-void-function." + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2263, "Bad return stmt. Types of return expression and return type of function are not equal." + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2264, "Bad return type for '{funcName}'. Return type for function can not contain or be sampler/pointer." + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2265, "Bad parameter '{varName}' in function '{funcName}'. Bad usage." + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2266, "Bad variable with name 'Out'. It is sytem for used like return variable in shaders." + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2267, "Variable type is not writable. " + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2268, "Variable type is not readable. " + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2269, "Bad init expr for variable '{varName}'. " + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2270, "Don`t supported construction '[uint]' in sampler_state. " + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2271, "Incorrect texture setup for sampler. " + "In line: {line}. In column: {column}");
        akra.logger.registerCode(2272, "Can not calculate padding for type '{typeName}'.");
        akra.logger.registerCode(2273, "Can not extract type '{typeName}'.");
        akra.logger.registerCode(2274, "Bad extract exrpression.");
        akra.logger.registerCode(2275, "Bad imports in technique '{techniqueName}'.");
        akra.logger.registerCode(2276, "You try use 'engine' variable in out of pass." + "In line: {line}. In column: {column}.");
        akra.logger.registerCode(2277, "You try to import not exuisted component '{componentName}'");
        akra.logger.registerCode(2300, "We don`t support array of pinters now. Only pointe to array.                              In line: {line}. In column: {column}");
        akra.logger.registerCode(2301, "We don`t support using complex shader input like functions params.                             Shader: '{funcName}'");
        akra.logger.registerCode(2302, "We don`t support using complex shader output like functions params.                             Shader: '{funcName}'");
        akra.logger.registerCode(2303, "We don`t support 'provide ... as' operator now.");
        function sourceLocationToString(pLocation) {
            var sLocation = "[" + pLocation.file + ":" + pLocation.line.toString() + "]: ";
            return sLocation;
        }
        function syntaxErrorLogRoutine(pLogEntity) {
            var sPosition = sourceLocationToString(pLogEntity.location);
            var sError = "Code: " + pLogEntity.code.toString() + ". ";
            var pParseMessage = pLogEntity.message.split(/\{(\w+)\}/);
            var pInfo = pLogEntity.info;
            for(var i = 0; i < pParseMessage.length; i++) {
                if (((pInfo[pParseMessage[i]]) !== undefined)) {
                    pParseMessage[i] = pInfo[pParseMessage[i]];
                }
            }
            var sMessage = sPosition + sError + pParseMessage.join("");
            console["error"].call(console, sMessage);
        }
        akra.logger.setCodeFamilyRoutine("EffectSyntaxErrors", syntaxErrorLogRoutine, akra.ELogLevel.ERROR);
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        (function (EScopeType) {
            EScopeType._map = [];
            EScopeType._map[0] = "k_Default";
            EScopeType.k_Default = 0;
            EScopeType._map[1] = "k_Struct";
            EScopeType.k_Struct = 1;
            EScopeType._map[2] = "k_Annotation";
            EScopeType.k_Annotation = 2;
        })(fx.EScopeType || (fx.EScopeType = {}));
        var EScopeType = fx.EScopeType;
        var ProgramScope = (function () {
            function ProgramScope() {
                this._pScopeMap = {};
                this._iCurrentScope = null;
                this._nScope = 0;
            }
            ProgramScope.prototype.isStrictMode = function (iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                var pScope = this._pScopeMap[iScope];
                while(!((pScope) === null)) {
                    if (pScope.isStrictMode) {
                        return true;
                    }
                    pScope = pScope.parent;
                }
                return false;
            };
            ProgramScope.prototype.setStrictModeOn = function (iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                this._pScopeMap[iScope].isStrictMode = true;
            };
            ProgramScope.prototype.newScope = function (eType) {
                var isFirstScope = false;
                var pParentScope;
                if (((this._iCurrentScope) === null)) {
                    pParentScope = null;
                } else {
                    pParentScope = this._pScopeMap[this._iCurrentScope];
                }
                this._iCurrentScope = this._nScope++;
                var pNewScope = {
                    parent: pParentScope,
                    index: this._iCurrentScope,
                    type: eType,
                    isStrictMode: false,
                    variableMap: null,
                    typeMap: null,
                    functionMap: null
                };
                this._pScopeMap[this._iCurrentScope] = pNewScope;
            };
            ProgramScope.prototype.resumeScope = function () {
                if (this._nScope === 0) {
                    return;
                }
                this._iCurrentScope = this._nScope - 1;
            };
            ProgramScope.prototype.setScope = function (iScope) {
                this._iCurrentScope = iScope;
            };
            ProgramScope.prototype.getScope = function () {
                return this._iCurrentScope;
            };
            ProgramScope.prototype.endScope = function () {
                if (((this._iCurrentScope) === null)) {
                    return;
                }
                var pOldScope = this._pScopeMap[this._iCurrentScope];
                var pNewScope = pOldScope.parent;
                if (((pNewScope) === null)) {
                    this._iCurrentScope = null;
                } else {
                    this._iCurrentScope = pNewScope.index;
                }
            };
            ProgramScope.prototype.getScopeType = /** @inline */function () {
                return this._pScopeMap[this._iCurrentScope].type;
            };
            ProgramScope.prototype.getVariable = function (sVariableName, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                if (((iScope) === null)) {
                    return null;
                }
                var pScope = this._pScopeMap[iScope];
                while(!((pScope) === null)) {
                    var pVariableMap = pScope.variableMap;
                    if (!((pVariableMap) === null)) {
                        var pVariable = pVariableMap[sVariableName];
                        if (((pVariable) !== undefined)) {
                            return pVariable;
                        }
                    }
                    pScope = pScope.parent;
                }
                return null;
            };
            ProgramScope.prototype.getType = function (sTypeName, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                var pTypeDecl = this.getTypeDecl(sTypeName, iScope);
                if (!((pTypeDecl) === null)) {
                    return pTypeDecl.getType();
                } else {
                    return null;
                }
            };
            ProgramScope.prototype.getTypeDecl = function (sTypeName, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                if (((iScope) === null)) {
                    return null;
                }
                var pScope = this._pScopeMap[iScope];
                while(!((pScope) === null)) {
                    var pTypeMap = pScope.typeMap;
                    if (!((pTypeMap) === null)) {
                        var pType = pTypeMap[sTypeName];
                        if (((pType) !== undefined)) {
                            return pType;
                        }
                    }
                    pScope = pScope.parent;
                }
                return null;
            };
            ProgramScope.prototype.getFunction = /**
            * get function by name and list of types
            * return null - if threre are not function; undefined - if there more then one function; function - if all ok
            */
            function (sFuncName, pArgumentTypes, iScope) {
                if (typeof iScope === "undefined") { iScope = 0; }
                if (((iScope) === null)) {
                    return null;
                }
                var pScope = this._pScopeMap[iScope];
                var pFunction = null;
                while(!((pScope) === null)) {
                    var pFunctionListMap = pScope.functionMap;
                    if (!((pFunctionListMap) === null)) {
                        var pFunctionList = pFunctionListMap[sFuncName];
                        if (((pFunctionList) !== undefined)) {
                            for(var i = 0; i < pFunctionList.length; i++) {
                                var pTestedFunction = pFunctionList[i];
                                var pTestedArguments = pTestedFunction.getArguments();
                                if (pArgumentTypes.length > pTestedArguments.length || pArgumentTypes.length < pTestedFunction.getNumNeededArguments()) {
                                    continue;
                                }
                                var isParamsEqual = true;
                                for(var j = 0; j < pArgumentTypes.length; j++) {
                                    isParamsEqual = false;
                                    if (!pArgumentTypes[j].getType().isEqual(pTestedArguments[j].getType())) {
                                        break;
                                    }
                                    isParamsEqual = true;
                                }
                                if (isParamsEqual) {
                                    if (!((pFunction) === null)) {
                                        return undefined;
                                    }
                                    pFunction = pTestedFunction;
                                }
                            }
                        }
                    }
                    pScope = pScope.parent;
                }
                return pFunction;
            };
            ProgramScope.prototype.getShaderFunction = /**
            * get shader function by name and list of types
            * return null - if threre are not function; undefined - if there more then one function; function - if all ok
            */
            function (sFuncName, pArgumentTypes, iScope) {
                if (typeof iScope === "undefined") { iScope = 0; }
                if (((iScope) === null)) {
                    return null;
                }
                var pScope = this._pScopeMap[iScope];
                var pFunction = null;
                while(!((pScope) === null)) {
                    var pFunctionListMap = pScope.functionMap;
                    if (!((pFunctionListMap) === null)) {
                        var pFunctionList = pFunctionListMap[sFuncName];
                        if (((pFunctionList) !== undefined)) {
                            for(var i = 0; i < pFunctionList.length; i++) {
                                var pTestedFunction = pFunctionList[i];
                                var pTestedArguments = pTestedFunction.getArguments();
                                if (pArgumentTypes.length > pTestedArguments.length) {
                                    continue;
                                }
                                var isParamsEqual = true;
                                var iArg = 0;
                                if (pArgumentTypes.length === 0) {
                                    if (!((pFunction) === null)) {
                                        return undefined;
                                    }
                                    pFunction = pTestedFunction;
                                    continue;
                                }
                                for(var j = 0; j < pTestedArguments.length; j++) {
                                    isParamsEqual = false;
                                    if (iArg >= pArgumentTypes.length) {
                                        if (pTestedArguments[j].isUniform()) {
                                            break;
                                        } else {
                                            isParamsEqual = true;
                                        }
                                    } else if (pTestedArguments[j].isUniform()) {
                                        if (!pArgumentTypes[iArg].getType().isEqual(pTestedArguments[j].getType())) {
                                            break;
                                        } else {
                                            iArg++;
                                            isParamsEqual = true;
                                        }
                                    }
                                }
                                if (isParamsEqual) {
                                    if (!((pFunction) === null)) {
                                        return undefined;
                                    }
                                    pFunction = pTestedFunction;
                                }
                            }
                        }
                    }
                    pScope = pScope.parent;
                }
                return pFunction;
            };
            ProgramScope.prototype.addVariable = function (pVariable, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                if (((iScope) === null)) {
                    return false;
                }
                var pScope = this._pScopeMap[iScope];
                var pVariableMap = pScope.variableMap;
                if (((pVariableMap) === null)) {
                    pVariableMap = pScope.variableMap = {};
                }
                var sVariableName = pVariable.getName();
                if (!pVariable.getType().isShared()) {
                    if (((((this)._pScopeMap[(iScope)].variableMap[(sVariableName)]) !== undefined))) {
                        return false;
                    }
                    pVariableMap[sVariableName] = pVariable;
                    pVariable._setScope(iScope);
                } else {
                    if (!((((this)._pScopeMap[(iScope)].variableMap[(sVariableName)]) !== undefined))) {
                        pVariableMap[sVariableName] = pVariable;
                        pVariable._setScope(iScope);
                    } else {
                        var pBlendVariable = pVariableMap[sVariableName].blend(pVariable, akra.EAFXBlendMode.k_Shared);
                        if (((pBlendVariable) === null)) {
                            return false;
                        }
                        pVariableMap[sVariableName] = pBlendVariable;
                        pBlendVariable._setScope(iScope);
                    }
                }
                return true;
            };
            ProgramScope.prototype.addType = function (pType, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                if (((iScope) === null)) {
                    return false;
                }
                var pScope = this._pScopeMap[iScope];
                var pTypeMap = pScope.typeMap;
                if (((pTypeMap) === null)) {
                    pTypeMap = pScope.typeMap = {};
                }
                var sTypeName = pType.getName();
                if (((((this)._pScopeMap[(iScope)].typeMap[(sTypeName)]) !== undefined))) {
                    return false;
                }
                pTypeMap[sTypeName] = pType;
                pType._setScope(iScope);
                return true;
            };
            ProgramScope.prototype.addFunction = function (pFunction, iScope) {
                if (typeof iScope === "undefined") { iScope = 0; }
                if (((iScope) === null)) {
                    return false;
                }
                var pScope = this._pScopeMap[iScope];
                var pFunctionMap = pScope.functionMap;
                if (((pFunctionMap) === null)) {
                    pFunctionMap = pScope.functionMap = {};
                }
                var sFuncName = pFunction.getName();
                if (this.hasFunctionInScope(pFunction, iScope)) {
                    return false;
                }
                if (!((pFunctionMap[sFuncName]) !== undefined)) {
                    pFunctionMap[sFuncName] = [];
                }
                pFunctionMap[sFuncName].push(pFunction);
                pFunction._setScope(iScope);
                return true;
            };
            ProgramScope.prototype.hasVariable = function (sVariableName, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                if (((iScope) === null)) {
                    return false;
                }
                var pScope = this._pScopeMap[iScope];
                while(!((pScope) === null)) {
                    var pVariableMap = pScope.variableMap;
                    if (!((pVariableMap) === null)) {
                        var pVariable = pVariableMap[sVariableName];
                        if (((pVariable) !== undefined)) {
                            return true;
                        }
                    }
                    pScope = pScope.parent;
                }
                return false;
            };
            ProgramScope.prototype.hasType = function (sTypeName, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                if (((iScope) === null)) {
                    return false;
                }
                var pScope = this._pScopeMap[iScope];
                while(!((pScope) === null)) {
                    var pTypeMap = pScope.typeMap;
                    if (!((pTypeMap) === null)) {
                        var pType = pTypeMap[sTypeName];
                        if (((pType) !== undefined)) {
                            return true;
                        }
                    }
                    pScope = pScope.parent;
                }
                return false;
            };
            ProgramScope.prototype.hasFunction = function (sFuncName, pArgumentTypes, iScope) {
                if (typeof iScope === "undefined") { iScope = 0; }
                if (((iScope) === null)) {
                    return false;
                }
                var pScope = this._pScopeMap[iScope];
                while(!((pScope) === null)) {
                    var pFunctionListMap = pScope.functionMap;
                    if (!((pFunctionListMap) === null)) {
                        var pFunctionList = pFunctionListMap[sFuncName];
                        if (((pFunctionList) !== undefined)) {
                            var pFunction = null;
                            for(var i = 0; i < pFunctionList.length; i++) {
                                var pTestedFunction = pFunctionList[i];
                                var pTestedArguments = pTestedFunction.getArguments();
                                if (pArgumentTypes.length > pTestedArguments.length || pArgumentTypes.length < pTestedFunction.getNumNeededArguments()) {
                                    continue;
                                }
                                var isParamsEqual = true;
                                for(var j = 0; j < pArgumentTypes.length; j++) {
                                    isParamsEqual = false;
                                    if (!pArgumentTypes[j].getType().isEqual(pTestedArguments[j].getType())) {
                                        break;
                                    }
                                    isParamsEqual = true;
                                }
                                if (isParamsEqual) {
                                    return true;
                                }
                            }
                        }
                    }
                    pScope = pScope.parent;
                }
                return false;
            };
            ProgramScope.prototype.hasVariableInScope = /** @inline */function (sVariableName, iScope) {
                return ((this._pScopeMap[iScope].variableMap[sVariableName]) !== undefined);
            };
            ProgramScope.prototype.hasTypeInScope = /** @inline */function (sTypeName, iScope) {
                return ((this._pScopeMap[iScope].typeMap[sTypeName]) !== undefined);
            };
            ProgramScope.prototype.hasFunctionInScope = function (pFunction, iScope) {
                if (((iScope) === null)) {
                    return false;
                }
                var pScope = this._pScopeMap[iScope];
                var pFunctionListMap = pScope.functionMap;
                var pFunctionList = pFunctionListMap[pFunction.getName()];
                if (!((pFunctionList) !== undefined)) {
                    return false;
                }
                var pFunctionArguments = pFunction.getArguments();
                var hasFunction = false;
                for(var i = 0; i < pFunctionList.length; i++) {
                    var pTestedArguments = pFunctionList[i].getArguments();
                    if (pTestedArguments.length !== pFunctionArguments.length) {
                        continue;
                    }
                    var isParamsEqual = true;
                    for(var j = 0; j < pFunctionArguments.length; j++) {
                        isParamsEqual = false;
                        if (!pTestedArguments[j].getType().isEqual(pFunctionArguments[j].getType())) {
                            break;
                        }
                        isParamsEqual = true;
                    }
                    if (isParamsEqual) {
                        hasFunction = true;
                        break;
                    }
                }
                return hasFunction;
            };
            return ProgramScope;
        })();
        fx.ProgramScope = ProgramScope;        
        var ExprTemplateTranslator = (function () {
            function ExprTemplateTranslator(sExprTemplate) {
                this._pInToOutArgsMap = null;
                this._pExprPart = null;
                this._pInToOutArgsMap = {};
                this._pExprPart = [];
                var pSplitTemplate = sExprTemplate.split(/(\$\d+)/);
                for(var i = 0; i < pSplitTemplate.length; i++) {
                    if (pSplitTemplate[i]) {
                        if (pSplitTemplate[i][0] !== '$') {
                            this._pExprPart.push(new fx.SimpleInstruction(pSplitTemplate[i]));
                        } else {
                            this._pExprPart.push(null);
                            this._pInToOutArgsMap[this._pExprPart.length - 1] = (((pSplitTemplate[i].substr(1))) * 1 - 1);
                        }
                    }
                }
            }
            ExprTemplateTranslator.prototype.toInstructionList = function (pArguments) {
                var pOutputInstructionList = [];
                for(var i = 0; i < this._pExprPart.length; i++) {
                    if (((this._pExprPart[i]) === null)) {
                        pOutputInstructionList.push(pArguments[this._pInToOutArgsMap[i]]);
                    } else {
                        pOutputInstructionList.push(this._pExprPart[i]);
                    }
                }
                return pOutputInstructionList;
            };
            return ExprTemplateTranslator;
        })();
        fx.ExprTemplateTranslator = ExprTemplateTranslator;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        var Instruction = (function () {
            function Instruction() {
                /**@protected*/ this._pParentInstruction = null;
                /**@protected*/ this._sOperatorName = null;
                /**@protected*/ this._pInstructionList = null;
                /**@protected*/ this._nInstructions = 0;
                /**@protected*/ this._eInstructionType = 0;
                /**@protected*/ this._pLastError = null;
                /**@protected*/ this._bErrorOccured = false;
                /**@protected*/ this._iInstructionID = 0;
                /**@protected*/ this._iScope = 0xffffff;
                this._isVisible = true;
                this._iInstructionID = Instruction._nInstructionCounter++;
                this._pParentInstruction = null;
                this._sOperatorName = null;
                this._pInstructionList = null;
                this._nInstructions = 0;
                this._eInstructionType = akra.EAFXInstructionTypes.k_Instruction;
                this._pLastError = {
                    code: 0,
                    info: null
                };
            }
            Instruction._nInstructionCounter = 0;
            Instruction.prototype.getGuid = /** @inline */function () {
                return ((this)._iInstructionID);
            };
            Instruction.prototype.getParent = /** @inline */function () {
                return this._pParentInstruction;
            };
            Instruction.prototype.setParent = /** @inline */function (pParentInstruction) {
                this._pParentInstruction = pParentInstruction;
            };
            Instruction.prototype.getOperator = /** @inline */function () {
                return this._sOperatorName;
            };
            Instruction.prototype.setOperator = /** @inline */function (sOperator) {
                this._sOperatorName = sOperator;
            };
            Instruction.prototype.getInstructions = /** @inline */function () {
                return this._pInstructionList;
            };
            Instruction.prototype.setInstructions = /** @inline */function (pInstructionList) {
                this._pInstructionList = pInstructionList;
            };
            Instruction.prototype._getInstructionType = /** @inline */function () {
                return this._eInstructionType;
            };
            Instruction.prototype._getInstructionID = /** @inline */function () {
                return this._iInstructionID;
            };
            Instruction.prototype._getScope = function () {
                return this._iScope !== 0xffffff ? this._iScope : !((((this)._pParentInstruction)) === null) ? ((this)._pParentInstruction)._getScope() : 0xffffff;
            };
            Instruction.prototype._setScope = /** @inline */function (iScope) {
                this._iScope = iScope;
            };
            Instruction.prototype._isInGlobalScope = /** @inline */function () {
                return this._getScope() === 0;
            };
            Instruction.prototype.getLastError = /** @inline */function () {
                return this._pLastError;
            };
            Instruction.prototype.setError = /** @inline */function (eCode, pInfo) {
                if (typeof pInfo === "undefined") { pInfo = null; }
                this._pLastError.code = eCode;
                this._pLastError.info = pInfo;
                this._bErrorOccured = true;
            };
            Instruction.prototype.clearError = /** @inline */function () {
                this._bErrorOccured = false;
                this._pLastError.code = 0;
                this._pLastError.info = null;
            };
            Instruction.prototype.isErrorOccured = /** @inline */function () {
                return this._bErrorOccured;
            };
            Instruction.prototype.setVisible = /** @inline */function (isVisible) {
                this._isVisible = isVisible;
            };
            Instruction.prototype.isVisible = /** @inline */function () {
                return this._isVisible;
            };
            Instruction.prototype.initEmptyInstructions = /** @inline */function () {
                this._pInstructionList = [];
            };
            Instruction.prototype.push = function (pInstruction, isSetParent) {
                if (typeof isSetParent === "undefined") { isSetParent = false; }
                if (!((this._pInstructionList) === null)) {
                    this._pInstructionList[this._nInstructions] = pInstruction;
                    this._nInstructions += 1;
                }
                if (isSetParent && !((pInstruction) === null)) {
                    pInstruction.setParent(this);
                }
            };
            Instruction.prototype.addRoutine = function (fnRoutine, iPriority) {
                //TODO
                            };
            Instruction.prototype.prepareFor = function (eUsedType) {
                if (!((this._pInstructionList) === null) && this._nInstructions > 0) {
                    for(var i = 0; i < this._nInstructions; i++) {
                        this._pInstructionList[i].prepareFor(eUsedType);
                    }
                }
            };
            Instruction.prototype.check = /**
            * Проверка валидности инструкции
            */
            function (eStage, pInfo) {
                if (typeof pInfo === "undefined") { pInfo = null; }
                if (this._bErrorOccured) {
                    return false;
                } else {
                    return true;
                }
            };
            Instruction.prototype.prepare = /**
            * Подготовка интсрукции к дальнейшему анализу
            */
            function () {
                return true;
            };
            Instruction.prototype.toString = function () {
                return null;
            };
            Instruction.prototype.toFinalCode = function () {
                return "";
            };
            Instruction.prototype.clone = function (pRelationMap) {
                if (typeof pRelationMap === "undefined") { pRelationMap = {}; }
                if (((pRelationMap[((this)._iInstructionID)]) !== undefined)) {
                    return pRelationMap[((this)._iInstructionID)];
                }
                var pNewInstruction = new this["constructor"]();
                var pParent = ((this)._pParentInstruction) || null;
                if (!((pParent) === null) && ((pRelationMap[pParent._getInstructionID()]) !== undefined)) {
                    pParent = pRelationMap[pParent._getInstructionID()];
                }
                pNewInstruction.setParent(pParent);
                pRelationMap[((this)._iInstructionID)] = pNewInstruction;
                if (!((this._pInstructionList) === null) && ((pNewInstruction.getInstructions()) === null)) {
                    pNewInstruction.initEmptyInstructions();
                }
                for(var i = 0; i < this._nInstructions; i++) {
                    pNewInstruction.push(this._pInstructionList[i].clone(pRelationMap));
                }
                pNewInstruction.setOperator(((this)._sOperatorName));
                return pNewInstruction;
            };
            return Instruction;
        })();
        fx.Instruction = Instruction;        
        var InstructionCollector = (function (_super) {
            __extends(InstructionCollector, _super);
            function InstructionCollector() {
                        _super.call(this);
                this._pInstructionList = [];
                this._eInstructionType = akra.EAFXInstructionTypes.k_InstructionCollector;
            }
            InstructionCollector.prototype.toFinalCode = function () {
                var sCode = "";
                for(var i = 0; i < this._nInstructions; i++) {
                    sCode += ((this)._pInstructionList)[i].toFinalCode();
                }
                return sCode;
            };
            return InstructionCollector;
        })(Instruction);
        fx.InstructionCollector = InstructionCollector;        
        var SimpleInstruction = (function (_super) {
            __extends(SimpleInstruction, _super);
            function SimpleInstruction(sValue) {
                        _super.call(this);
                this._sValue = "";
                this._pInstructionList = null;
                this._eInstructionType = akra.EAFXInstructionTypes.k_SimpleInstruction;
                this._sValue = sValue;
            }
            SimpleInstruction.prototype.setValue = /** @inline */function (sValue) {
                this._sValue = sValue;
            };
            SimpleInstruction.prototype.isValue = /** @inline */function (sValue) {
                return (this._sValue === sValue);
            };
            SimpleInstruction.prototype.toString = function () {
                return this._sValue;
            };
            SimpleInstruction.prototype.toFinalCode = function () {
                return this._sValue;
            };
            SimpleInstruction.prototype.clone = function (pRelationMap) {
                var pClone = _super.prototype.clone.call(this, pRelationMap);
                (pClone._sValue = (this._sValue));
                return pClone;
            };
            return SimpleInstruction;
        })(Instruction);
        fx.SimpleInstruction = SimpleInstruction;        
        var TypedInstruction = (function (_super) {
            __extends(TypedInstruction, _super);
            function TypedInstruction() {
                        _super.call(this);
                this._pType = null;
                this._eInstructionType = akra.EAFXInstructionTypes.k_TypedInstruction;
            }
            TypedInstruction.prototype.getType = function () {
                return this._pType;
            };
            TypedInstruction.prototype.setType = function (pType) {
                this._pType = pType;
            };
            TypedInstruction.prototype.clone = function (pRelationMap) {
                if (typeof pRelationMap === "undefined") { pRelationMap = {}; }
                var pClonedInstruction = (_super.prototype.clone.call(this, pRelationMap));
                if (!((this.getType()) === null)) {
                    pClonedInstruction.setType(this.getType().clone(pRelationMap));
                }
                return pClonedInstruction;
            };
            return TypedInstruction;
        })(Instruction);
        fx.TypedInstruction = TypedInstruction;        
        var DeclInstruction = (function (_super) {
            __extends(DeclInstruction, _super);
            function DeclInstruction() {
                        _super.call(this);
                /**@protected*/ this._sSemantic = "";
                /**@protected*/ this._pAnnotation = null;
                /**@protected*/ this._bForPixel = true;
                /**@protected*/ this._bForVertex = true;
                /**@protected*/ this._isBuiltIn = false;
                this._eInstructionType = akra.EAFXInstructionTypes.k_DeclInstruction;
            }
            DeclInstruction.prototype.setSemantic = function (sSemantic) {
                this._sSemantic = sSemantic;
            };
            DeclInstruction.prototype.setAnnotation = function (pAnnotation) {
                this._pAnnotation = pAnnotation;
            };
            DeclInstruction.prototype.getName = function () {
                return "";
            };
            DeclInstruction.prototype.getRealName = function () {
                return "";
            };
            DeclInstruction.prototype.getNameId = function () {
                return null;
            };
            DeclInstruction.prototype.getSemantic = /** @inline */function () {
                return this._sSemantic;
            };
            DeclInstruction.prototype.isBuiltIn = function () {
                return this._isBuiltIn;
            };
            DeclInstruction.prototype.setBuiltIn = function (isBuiltIn) {
                this._isBuiltIn = isBuiltIn;
            };
            DeclInstruction.prototype._isForAll = /** @inline */function () {
                return this._bForVertex && this._bForPixel;
            };
            DeclInstruction.prototype._isForPixel = /** @inline */function () {
                return this._bForPixel;
            };
            DeclInstruction.prototype._isForVertex = /** @inline */function () {
                return this._bForVertex;
            };
            DeclInstruction.prototype._setForAll = /** @inline */function (canUse) {
                this._bForVertex = canUse;
                this._bForPixel = canUse;
            };
            DeclInstruction.prototype._setForPixel = /** @inline */function (canUse) {
                this._bForPixel = canUse;
            };
            DeclInstruction.prototype._setForVertex = /** @inline */function (canUse) {
                this._bForVertex = canUse;
            };
            DeclInstruction.prototype.clone = function (pRelationMap) {
                if (typeof pRelationMap === "undefined") { pRelationMap = {}; }
                var pClonedInstruction = (_super.prototype.clone.call(this, pRelationMap));
                pClonedInstruction.setSemantic(this._sSemantic);
                pClonedInstruction.setAnnotation(this._pAnnotation);
                return pClonedInstruction;
            };
            return DeclInstruction;
        })(TypedInstruction);
        fx.DeclInstruction = DeclInstruction;        
        var IdInstruction = (function (_super) {
            __extends(IdInstruction, _super);
            /**
            * EMPTY_OPERATOR EMPTY_ARGUMENTS
            */
            function IdInstruction() {
                        _super.call(this);
                this._isForVarying = false;
                this._sName = "";
                this._sRealName = "";
                this._eInstructionType = akra.EAFXInstructionTypes.k_IdInstruction;
            }
            IdInstruction.prototype.isVisible = /** @inline */function () {
                return ((this)._pParentInstruction).isVisible();
            };
            IdInstruction.prototype.getName = /** @inline */function () {
                return this._sName;
            };
            IdInstruction.prototype.getRealName = /** @inline */function () {
                if (this._isForVarying) {
                    return "V_" + this._sRealName;
                } else {
                    return this._sRealName;
                }
            };
            IdInstruction.prototype.setName = /** @inline */function (sName) {
                this._sName = sName;
                this._sRealName = sName;
            };
            IdInstruction.prototype.setRealName = /** @inline */function (sRealName) {
                this._sRealName = sRealName;
            };
            IdInstruction.prototype._markAsVarying = /** @inline */function (bValue) {
                this._isForVarying = bValue;
            };
            IdInstruction.prototype.toString = function () {
                return this._sRealName;
            };
            IdInstruction.prototype.toFinalCode = function () {
                return /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this.getRealName();
            };
            IdInstruction.prototype.clone = function (pRelationMap) {
                var pClonedInstruction = (_super.prototype.clone.call(this, pRelationMap));
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pClonedInstruction.setName(this._sName);
                (pClonedInstruction._sRealName = (this._sRealName));
                return pClonedInstruction;
            };
            return IdInstruction;
        })(Instruction);
        fx.IdInstruction = IdInstruction;        
        var KeywordInstruction = (function (_super) {
            __extends(KeywordInstruction, _super);
            /**
            * EMPTY_OPERATOR EMPTY_ARGUMENTS
            */
            function KeywordInstruction() {
                        _super.call(this);
                this._sValue = "";
                this._eInstructionType = akra.EAFXInstructionTypes.k_KeywordInstruction;
            }
            KeywordInstruction.prototype.setValue = /** @inline */function (sValue) {
                this._sValue = sValue;
            };
            KeywordInstruction.prototype.isValue = /** @inline */function (sTestValue) {
                return this._sValue === sTestValue;
            };
            KeywordInstruction.prototype.toString = function () {
                return this._sValue;
            };
            KeywordInstruction.prototype.toFinalCode = function () {
                return this._sValue;
            };
            return KeywordInstruction;
        })(Instruction);
        fx.KeywordInstruction = KeywordInstruction;        
        var AnnotationInstruction = (function (_super) {
            __extends(AnnotationInstruction, _super);
            function AnnotationInstruction() {
                        _super.call(this);
                this._eInstructionType = akra.EAFXInstructionTypes.k_AnnotationInstruction;
            }
            return AnnotationInstruction;
        })(Instruction);
        fx.AnnotationInstruction = AnnotationInstruction;        
        var PassInstruction = (function (_super) {
            __extends(PassInstruction, _super);
            function PassInstruction() {
                        _super.call(this);
                this._pTempNodeList = null;
                this._pTempFoundedFuncList = null;
                this._pTempFoundedFuncTypeList = null;
                this._pParseNode = null;
                this._sFunctionCode = "";
                this._isComlexPass = false;
                this._pShadersMap = null;
                this._fnPassFunction = null;
                this._pVertexShader = null;
                this._pPixelShader = null;
                this._pPassStateMap = null;
                this._pSharedVariableMapV = null;
                this._pGlobalVariableMapV = null;
                this._pUniformVariableMapV = null;
                this._pForeignVariableMapV = null;
                this._pTextureVariableMapV = null;
                this._pUsedComplexTypeMapV = null;
                this._pSharedVariableMapP = null;
                this._pGlobalVariableMapP = null;
                this._pUniformVariableMapP = null;
                this._pForeignVariableMapP = null;
                this._pTextureVariableMapP = null;
                this._pUsedComplexTypeMapP = null;
                this._pFullUniformVariableMap = null;
                this._pFullForeignVariableMap = null;
                this._pFullTextureVariableMap = null;
                this._pInstructionList = null;
                this._eInstructionType = akra.EAFXInstructionTypes.k_PassInstruction;
            }
            PassInstruction.prototype._addFoundFunction = function (pNode, pShader, eType) {
                if (((this._pTempNodeList) === null)) {
                    this._pTempNodeList = [];
                    this._pTempFoundedFuncList = [];
                    this._pTempFoundedFuncTypeList = [];
                }
                this._pTempNodeList.push(pNode);
                this._pTempFoundedFuncList.push(pShader);
                this._pTempFoundedFuncTypeList.push(eType);
            };
            PassInstruction.prototype._getFoundedFunction = function (pNode) {
                if (((this._pTempNodeList) === null)) {
                    return null;
                }
                for(var i = 0; i < this._pTempNodeList.length; i++) {
                    if (this._pTempNodeList[i] === pNode) {
                        return this._pTempFoundedFuncList[i];
                    }
                }
                return null;
            };
            PassInstruction.prototype._getFoundedFunctionType = function (pNode) {
                if (((this._pTempNodeList) === null)) {
                    return null;
                }
                for(var i = 0; i < this._pTempNodeList.length; i++) {
                    if (this._pTempNodeList[i] === pNode) {
                        return this._pTempFoundedFuncTypeList[i];
                    }
                }
                return null;
            };
            PassInstruction.prototype._setParseNode = function (pNode) {
                this._pParseNode = pNode;
            };
            PassInstruction.prototype._getParseNode = function () {
                return this._pParseNode;
            };
            PassInstruction.prototype._addCodeFragment = function (sCode) {
                if (((this)._isComlexPass)) {
                    this._sFunctionCode += sCode;
                }
            };
            PassInstruction.prototype._markAsComplex = /** @inline */function (isComplex) {
                this._isComlexPass = isComplex;
            };
            PassInstruction.prototype._getSharedVariableMapV = /** @inline */function () {
                return this._pSharedVariableMapV;
            };
            PassInstruction.prototype._getGlobalVariableMapV = /** @inline */function () {
                return this._pGlobalVariableMapV;
            };
            PassInstruction.prototype._getUniformVariableMapV = /** @inline */function () {
                return this._pUniformVariableMapV;
            };
            PassInstruction.prototype._getForeignVariableMapV = /** @inline */function () {
                return this._pForeignVariableMapV;
            };
            PassInstruction.prototype._getTextureVariableMapV = /** @inline */function () {
                return this._pTextureVariableMapV;
            };
            PassInstruction.prototype._getUsedComplexTypeMapV = /** @inline */function () {
                return this._pUsedComplexTypeMapV;
            };
            PassInstruction.prototype._getSharedVariableMapP = /** @inline */function () {
                return this._pSharedVariableMapP;
            };
            PassInstruction.prototype._getGlobalVariableMapP = /** @inline */function () {
                return this._pGlobalVariableMapP;
            };
            PassInstruction.prototype._getUniformVariableMapP = /** @inline */function () {
                return this._pUniformVariableMapP;
            };
            PassInstruction.prototype._getForeignVariableMapP = /** @inline */function () {
                return this._pForeignVariableMapP;
            };
            PassInstruction.prototype._getTextureVariableMapP = /** @inline */function () {
                return this._pTextureVariableMapP;
            };
            PassInstruction.prototype._getUsedComplexTypeMapP = /** @inline */function () {
                return this._pUsedComplexTypeMapP;
            };
            PassInstruction.prototype._getFullUniformMap = /** @inline */function () {
                return this._pFullUniformVariableMap;
            };
            PassInstruction.prototype._getFullForeignMap = /** @inline */function () {
                return this._pFullForeignVariableMap;
            };
            PassInstruction.prototype._getFullTextureMap = /** @inline */function () {
                return this._pFullTextureVariableMap;
            };
            PassInstruction.prototype.isComplexPass = /** @inline */function () {
                return this._isComlexPass;
            };
            PassInstruction.prototype.getVertexShader = /** @inline */function () {
                return this._pVertexShader;
            };
            PassInstruction.prototype.getPixelShader = /** @inline */function () {
                return this._pPixelShader;
            };
            PassInstruction.prototype.addShader = function (pShader) {
                var isVertex = pShader.getFunctionType() === akra.EFunctionType.k_Vertex;
                if (((this)._isComlexPass)) {
                    if (((this._pShadersMap) === null)) {
                        this._pShadersMap = {};
                    }
                    var iShader = pShader._getInstructionID();
                    this._pShadersMap[iShader] = pShader;
                    var sCode = isVertex ? "this._pVertexShader=" : "this._pPixelShader=";
                    sCode += "this._pShadersMap[" + iShader.toString() + "];";
                    this._addCodeFragment(sCode);
                } else {
                    if (isVertex) {
                        this._pVertexShader = pShader;
                    } else {
                        this._pPixelShader = pShader;
                    }
                }
            };
            PassInstruction.prototype.setState = function (sType, sValue) {
                if (((this._pPassStateMap) === null)) {
                    this._pPassStateMap = {};
                }
                if (((this)._isComlexPass)) {
                    this._addCodeFragment("this._pPassStateMap[" + sType + "]=" + sValue + ";");
                } else {
                    this._pPassStateMap[sType] = sValue;
                }
            };
            PassInstruction.prototype.finalizePass = function () {
                if (((this)._isComlexPass)) {
                    this._fnPassFunction = (new Function("engine", "foreigns", "uniforms", this._sFunctionCode));
                }
                this.generateInfoAboutUsedVaraibles();
                this._pTempNodeList = null;
                this._pTempFoundedFuncList = null;
                this._pTempFoundedFuncTypeList = null;
                this._pParseNode = null;
                this._sFunctionCode = "";
            };
            PassInstruction.prototype.evaluate = function (pEngineStates, pForeigns, pUniforms) {
                if (((this)._isComlexPass)) {
                    this._pVertexShader = null;
                    this._pPixelShader = null;
                    this._fnPassFunction.call(this, pEngineStates, pForeigns, pUniforms);
                }
                return true;
            };
            PassInstruction.prototype.generateInfoAboutUsedVaraibles = function () {
                if (((this._pSharedVariableMapV) === null)) {
                    this._pSharedVariableMapV = {};
                    this._pGlobalVariableMapV = {};
                    this._pUniformVariableMapV = {};
                    this._pForeignVariableMapV = {};
                    this._pTextureVariableMapV = {};
                    this._pUsedComplexTypeMapV = {};
                    this._pSharedVariableMapP = {};
                    this._pGlobalVariableMapP = {};
                    this._pUniformVariableMapP = {};
                    this._pForeignVariableMapP = {};
                    this._pTextureVariableMapP = {};
                    this._pUsedComplexTypeMapP = {};
                    this._pFullUniformVariableMap = {};
                    this._pFullForeignVariableMap = {};
                    this._pFullTextureVariableMap = {};
                }
                if (((this)._isComlexPass)) {
                    for(var i in this._pShadersMap) {
                        this.addInfoAbouUsedVariablesFromFunction(this._pShadersMap[i]);
                    }
                } else {
                    if (!((this._pVertexShader) === null)) {
                        this.addInfoAbouUsedVariablesFromFunction(this._pVertexShader);
                    }
                    if (!((this._pPixelShader) === null)) {
                        this.addInfoAbouUsedVariablesFromFunction(this._pPixelShader);
                    }
                }
            };
            PassInstruction.prototype.addInfoAbouUsedVariablesFromFunction = function (pFunction) {
                var pSharedVars = pFunction._getSharedVariableMap();
                var pGlobalVars = pFunction._getGlobalVariableMap();
                var pUniformVars = pFunction._getUniformVariableMap();
                var pForeignVars = pFunction._getForeignVariableMap();
                var pTextureVars = pFunction._getTextureVariableMap();
                var pTypes = pFunction._getUsedComplexTypeMap();
                var pSharedVarsTo = null;
                var pGlobalVarsTo = null;
                var pUniformVarsTo = null;
                var pForeignVarsTo = null;
                var pTextureVarsTo = null;
                var pTypesTo = null;
                if (pFunction.getFunctionType() === akra.EFunctionType.k_Vertex) {
                    pSharedVarsTo = this._pSharedVariableMapV;
                    pGlobalVarsTo = this._pGlobalVariableMapV;
                    pUniformVarsTo = this._pUniformVariableMapV;
                    pForeignVarsTo = this._pForeignVariableMapV;
                    pTextureVarsTo = this._pTextureVariableMapV;
                    pTypesTo = this._pUsedComplexTypeMapV;
                } else {
                    pSharedVarsTo = this._pSharedVariableMapP;
                    pGlobalVarsTo = this._pGlobalVariableMapP;
                    pUniformVarsTo = this._pUniformVariableMapP;
                    pForeignVarsTo = this._pForeignVariableMapP;
                    pTextureVarsTo = this._pTextureVariableMapP;
                    pTypesTo = this._pUsedComplexTypeMapP;
                }
                for(var i in pSharedVars) {
                    if (!((pSharedVars[i]) === null) && !pSharedVars[i].isField()) {
                        pSharedVarsTo[i] = pSharedVars[i];
                    }
                }
                for(var i in pGlobalVars) {
                    if (!((pGlobalVars[i]) === null)) {
                        pGlobalVarsTo[i] = pGlobalVars[i];
                    }
                }
                for(var i in pUniformVars) {
                    if (!((pUniformVars[i]) === null)) {
                        pUniformVarsTo[i] = pUniformVars[i];
                        this._pFullUniformVariableMap[i] = pUniformVars[i];
                    }
                }
                for(var i in pForeignVars) {
                    if (!((pForeignVars[i]) === null)) {
                        pForeignVarsTo[i] = pForeignVars[i];
                        this._pFullForeignVariableMap[i] = pForeignVars[i];
                    }
                }
                for(var i in pTextureVars) {
                    if (!((pTextureVars[i]) === null)) {
                        pTextureVarsTo[i] = pTextureVars[i];
                        this._pFullTextureVariableMap[i] = pTextureVars[i];
                    }
                }
                for(var i in pTypes) {
                    if (!((pTypes[i]) === null)) {
                        pTypesTo[i] = pTypes[i];
                    }
                }
            };
            return PassInstruction;
        })(DeclInstruction);
        fx.PassInstruction = PassInstruction;        
        var TechniqueInstruction = (function (_super) {
            __extends(TechniqueInstruction, _super);
            function TechniqueInstruction() {
                        _super.call(this);
                this._sName = "";
                this._hasComplexName = false;
                this._pParseNode = null;
                this._pSharedVariableListV = null;
                this._pSharedVariableListP = null;
                this._pPassList = null;
                this._pComponentList = null;
                this._pComponentShiftList = null;
                this._pFullComponentList = null;
                this._pFullComponentShiftList = null;
                this._nTotalPasses = 0;
                this._pInstructionList = null;
                this._eInstructionType = akra.EAFXInstructionTypes.k_TechniqueInstruction;
            }
            TechniqueInstruction.prototype.setName = function (sName, isComplexName) {
                this._sName = sName;
                this._hasComplexName = isComplexName;
            };
            TechniqueInstruction.prototype.getName = function () {
                return this._sName;
            };
            TechniqueInstruction.prototype.hasComplexName = function () {
                return this._hasComplexName;
            };
            TechniqueInstruction.prototype.getSharedVariablesForVertex = function () {
                return this._pSharedVariableListV;
            };
            TechniqueInstruction.prototype.getSharedVariablesForPixel = function () {
                return this._pSharedVariableListP;
            };
            TechniqueInstruction.prototype.addPass = function (pPass) {
                if (((this._pPassList) === null)) {
                    this._pPassList = [];
                }
                this._pPassList.push(pPass);
            };
            TechniqueInstruction.prototype.getPassList = function () {
                return this._pPassList;
            };
            TechniqueInstruction.prototype.getPass = function (iPass) {
                return iPass < this._pPassList.length ? this._pPassList[iPass] : null;
            };
            TechniqueInstruction.prototype.totalOwnPasses = function () {
                return this._pPassList.length;
            };
            TechniqueInstruction.prototype.totalPasses = function () {
                return this._nTotalPasses;
            };
            TechniqueInstruction.prototype.addComponent = function (pComponent, iShift) {
                if (((this._pComponentList) === null)) {
                    this._pComponentList = [];
                    this._pComponentShiftList = [];
                }
                this._pComponentList.push(pComponent);
                this._pComponentShiftList.push(iShift);
            };
            TechniqueInstruction.prototype.getComponentList = /** @inline */function () {
                return this._pComponentList;
            };
            TechniqueInstruction.prototype.getComponentListShift = /** @inline */function () {
                return this._pComponentShiftList;
            };
            TechniqueInstruction.prototype.getFullComponentList = function () {
                return this._pFullComponentList;
            };
            TechniqueInstruction.prototype.getFullComponentShiftList = function () {
                return this._pFullComponentShiftList;
            };
            TechniqueInstruction.prototype.checkForCorrectImports = function () {
                return true;
            };
            TechniqueInstruction.prototype.finalizeTechnique = function (sProvideNameSpace, pGloabalComponentList, pGloabalComponentShiftList) {
                this.generateListOfSharedVariables();
                if (!this.hasComplexName() && sProvideNameSpace !== "") {
                    this._sName = sProvideNameSpace + "." + this._sName;
                }
                if (!((pGloabalComponentList) === null)) {
                    if (!((this._pComponentList) === null)) {
                        this._pComponentList = pGloabalComponentList.concat(this._pComponentList);
                        this._pComponentShiftList = pGloabalComponentShiftList.concat(this._pComponentShiftList);
                    } else {
                        this._pComponentList = pGloabalComponentList.concat();
                        this._pComponentShiftList = pGloabalComponentShiftList.concat();
                    }
                }
                this.generateFullListOfComponent();
            };
            TechniqueInstruction.prototype.generateListOfSharedVariables = function () {
                this._pSharedVariableListV = [];
                this._pSharedVariableListP = [];
                for(var i = 0; i < this._pPassList.length; i++) {
                    var pSharedV = this._pPassList[i]._getSharedVariableMapV();
                    var pSharedP = this._pPassList[i]._getSharedVariableMapP();
                    for(var j in pSharedV) {
                        this.addSharedVariable(pSharedV[j], akra.EFunctionType.k_Vertex);
                    }
                    for(var j in pSharedP) {
                        this.addSharedVariable(pSharedP[j], akra.EFunctionType.k_Pixel);
                    }
                }
            };
            TechniqueInstruction.prototype.addSharedVariable = function (pVar, eType) {
                var pAddTo = null;
                if (eType === akra.EFunctionType.k_Vertex) {
                    pAddTo = this._pSharedVariableListV;
                } else {
                    pAddTo = this._pSharedVariableListP;
                }
                for(var i = 0; i < pAddTo.length; i++) {
                    if (pAddTo[i] === pVar) {
                        return;
                    }
                }
                pAddTo.push(pVar);
            };
            TechniqueInstruction.prototype.generateFullListOfComponent = function () {
                this._nTotalPasses = this.totalOwnPasses();
                if (((this._pComponentList) === null)) {
                    return;
                }
                this._pFullComponentList = [];
                this._pFullComponentShiftList = [];
                for(var i = 0; i < this._pComponentList.length; i++) {
                    var pTechnique = this._pComponentList[i].getTechnique();
                    var iMainShift = this._pComponentShiftList[i];
                    var pAddComponentList = pTechnique.getFullComponentList();
                    var pAddComponentShiftList = pTechnique.getFullComponentShiftList();
                    if (!((pAddComponentList) === null)) {
                        for(var j = 0; j < pAddComponentList.length; i++) {
                            this._pFullComponentList.push(pAddComponentList[j]);
                            this._pFullComponentShiftList.push(pAddComponentShiftList[j] + iMainShift);
                        }
                    }
                    this._pFullComponentList.push(this._pComponentList[i]);
                    this._pFullComponentShiftList.push(iMainShift);
                    if (this._nTotalPasses < iMainShift + pTechnique.totalPasses()) {
                        this._nTotalPasses = iMainShift + pTechnique.totalPasses();
                    }
                }
            };
            return TechniqueInstruction;
        })(DeclInstruction);
        fx.TechniqueInstruction = TechniqueInstruction;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        var TypeDeclInstruction = (function (_super) {
            __extends(TypeDeclInstruction, _super);
            // EMPTY_OPERATOR VariableTypeInstruction
            function TypeDeclInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_TypeDeclInstruction;
            }
            TypeDeclInstruction.prototype.getType = /** @inline */function () {
                return this._pInstructionList[0];
            };
            TypeDeclInstruction.prototype.clone = function (pRelationMap) {
                return _super.prototype.clone.call(this, pRelationMap);
            };
            TypeDeclInstruction.prototype.toFinalCode = function () {
                return ((this)._pInstructionList[0])._toDeclString() + ";";
            };
            TypeDeclInstruction.prototype.getName = /** @inline */function () {
                return ((this)._pInstructionList[0]).getName();
            };
            TypeDeclInstruction.prototype.getRealName = /** @inline */function () {
                return ((this)._pInstructionList[0]).getRealName();
            };
            TypeDeclInstruction.prototype.blend = function (pDecl, eBlendMode) {
                if (pDecl !== this) {
                    return null;
                }
                return this;
            };
            return TypeDeclInstruction;
        })(fx.DeclInstruction);
        fx.TypeDeclInstruction = TypeDeclInstruction;        
        var VariableTypeInstruction = (function (_super) {
            __extends(VariableTypeInstruction, _super);
            function VariableTypeInstruction() {
                        _super.call(this);
                this._pSubType = null;
                this._pUsageList = null;
                this._sName = "";
                this._isWritable = null;
                this._isReadable = null;
                this._bUsedForWrite = false;
                this._bUsedForRead = false;
                this._sHash = "";
                this._sStrongHash = "";
                this._isArray = false;
                this._isPointer = false;
                this._isStrictPointer = false;
                this._isPointIndex = null;
                this._isUniform = null;
                this._isGlobal = null;
                this._isConst = null;
                this._isShared = null;
                this._isForeign = null;
                this._iLength = 0xffffff;
                this._isNeedToUpdateLength = false;
                // private $length = 0;
                // inline get _iLength() {
                // 	return this.$length;
                // }
                // inline set _iLength(n: int) {
                // 	if (n === null) {
                // 		LOG(__CALLSTACK__);
                // 	}
                // 	this.$length = n;
                // }
                this._isFromVariableDecl = null;
                this._isFromTypeDecl = null;
                this._isField = false;
                this._pArrayIndexExpr = null;
                this._pArrayElementType = null;
                this._pFieldDeclMap = null;
                this._pFieldDeclBySemanticMap = null;
                this._pFieldIdMap = null;
                this._pUsedFieldMap = null;
                this._pVideoBuffer = null;
                this._pMainPointIndex = null;
                this._pUpPointIndex = null;
                this._pDownPointIndex = null;
                this._nPointDim = 0;
                this._pPointerList = null;
                this._iPadding = 0xffffff;
                this._pSubDeclList = null;
                this._pAttrOffset = null;
                this._bUnverifiable = false;
                this._bCollapsed = false;
                this._pInstructionList = null;
                this._eInstructionType = akra.EAFXInstructionTypes.k_VariableTypeInstruction;
            }
            VariableTypeInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                if (!((this._pUsageList) === null)) {
                    if (!this.isShared()) {
                        for(var i = 0; i < this._pUsageList.length; i++) {
                            sCode += this._pUsageList[i] + " ";
                        }
                    }
                }
                sCode += ((this)._pSubType).toFinalCode();
                return sCode;
            };
            VariableTypeInstruction.prototype._toDeclString = function () {
                return ((this)._pSubType)._toDeclString();
            };
            VariableTypeInstruction.prototype.isBuiltIn = function () {
                return false;
            };
            VariableTypeInstruction.prototype.setBuiltIn = function (isBuiltIn) {
            };
            VariableTypeInstruction.prototype._setCollapsed = /** @inline */function (bValue) {
                this._bCollapsed = bValue;
            };
            VariableTypeInstruction.prototype._isCollapsed = /** @inline */function () {
                return this._bCollapsed;
            };
            VariableTypeInstruction.prototype.isBase = //-----------------------------------------------------------------//
            //----------------------------SIMPLE TESTS-------------------------//
            //-----------------------------------------------------------------//
            /** @inline */function () {
                return ((this)._pSubType).isBase() && this._isArray === false;
            };
            VariableTypeInstruction.prototype.isArray = /** @inline */function () {
                return this._isArray || (((this)._pSubType).isArray());
            };
            VariableTypeInstruction.prototype.isNotBaseArray = /** @inline */function () {
                return this._isArray || (((this)._pSubType).isNotBaseArray());
            };
            VariableTypeInstruction.prototype.isComplex = /** @inline */function () {
                return ((this)._pSubType).isComplex();
            };
            VariableTypeInstruction.prototype.isEqual = function (pType) {
                if (((this)._bUnverifiable)) {
                    return true;
                }
                if (((this)._isArray || ((((this))._pSubType).isNotBaseArray())) && pType.isNotBaseArray() && (this.getLength() !== pType.getLength() || this.getLength() === 0xffffff || pType.getLength() === 0xffffff)) {
                    return false;
                }
                if (this.getHash() !== pType.getHash()) {
                    return false;
                }
                return true;
            };
            VariableTypeInstruction.prototype.isStrongEqual = function (pType) {
                if (!this.isEqual(pType) || this.getStrongHash() !== pType.getStrongHash()) {
                    return false;
                }
                return true;
            };
            VariableTypeInstruction.prototype.isSampler = function () {
                return ((this)._pSubType).isSampler();
            };
            VariableTypeInstruction.prototype.isSamplerCube = function () {
                return ((this)._pSubType).isSamplerCube();
            };
            VariableTypeInstruction.prototype.isSampler2D = function () {
                return ((this)._pSubType).isSampler2D();
            };
            VariableTypeInstruction.prototype.isWritable = function () {
                if (!((this._isWritable) === null)) {
                    return this._isWritable;
                }
                if ((((this)._isArray || ((((this))._pSubType).isArray())) && !((((this))._pSubType).isBase() && (this)._isArray === false)) || this.isForeign() || this.isUniform()) {
                    this._isWritable = false;
                } else {
                    this._isWritable = ((this)._pSubType).isWritable();
                }
                return this._isWritable;
            };
            VariableTypeInstruction.prototype.isReadable = function () {
                if (!((this._isReadable) === null)) {
                    return this._isReadable;
                }
                if (this.hasUsage("out")) {
                    this._isReadable = false;
                } else {
                    this._isReadable = ((this)._pSubType).isReadable();
                }
                return this._isReadable;
            };
            VariableTypeInstruction.prototype._containArray = function () {
                return ((this)._pSubType)._containArray();
            };
            VariableTypeInstruction.prototype._containSampler = function () {
                return ((this)._pSubType)._containSampler();
            };
            VariableTypeInstruction.prototype._containPointer = function () {
                return ((this)._pSubType)._containPointer();
            };
            VariableTypeInstruction.prototype._containComplexType = function () {
                return ((this)._pSubType)._containComplexType();
            };
            VariableTypeInstruction.prototype.isPointer = function () {
                return this._isPointer || (((this)._pSubType)._getInstructionType() === akra.EAFXInstructionTypes.k_VariableTypeInstruction && (((this)._pSubType)).isPointer());
            };
            VariableTypeInstruction.prototype.isStrictPointer = function () {
                return this._isStrictPointer || (((this)._pSubType)._getInstructionType() === akra.EAFXInstructionTypes.k_VariableTypeInstruction && (((this)._pSubType)).isStrictPointer());
            };
            VariableTypeInstruction.prototype.isPointIndex = function () {
                if (((this._isPointIndex) === null)) {
                    this._isPointIndex = this.isStrongEqual(fx.Effect.getSystemType("ptr"));
                }
                return this._isPointIndex;
            };
            VariableTypeInstruction.prototype.isFromVariableDecl = function () {
                if (!((this._isFromVariableDecl) === null)) {
                    return this._isFromVariableDecl;
                }
                if (((((this)._pParentInstruction)) === null)) {
                    this._isFromVariableDecl = false;
                } else {
                    var eParentType = ((this)._pParentInstruction)._getInstructionType();
                    if (eParentType === akra.EAFXInstructionTypes.k_VariableDeclInstruction) {
                        this._isFromVariableDecl = true;
                    } else if (eParentType === akra.EAFXInstructionTypes.k_VariableTypeInstruction) {
                        this._isFromVariableDecl = (((this)._pParentInstruction)).isFromVariableDecl();
                    } else {
                        this._isFromVariableDecl = false;
                    }
                }
                return this._isFromVariableDecl;
            };
            VariableTypeInstruction.prototype.isFromTypeDecl = function () {
                if (!((this._isFromTypeDecl) === null)) {
                    return this._isFromTypeDecl;
                }
                if (((((this)._pParentInstruction)) === null)) {
                    this._isFromTypeDecl = false;
                } else {
                    var eParentType = ((this)._pParentInstruction)._getInstructionType();
                    if (eParentType === akra.EAFXInstructionTypes.k_TypeDeclInstruction) {
                        this._isFromTypeDecl = true;
                    } else if (eParentType === akra.EAFXInstructionTypes.k_VariableTypeInstruction) {
                        this._isFromTypeDecl = (((this)._pParentInstruction)).isFromVariableDecl();
                    } else {
                        this._isFromTypeDecl = false;
                    }
                }
                return this._isFromTypeDecl;
            };
            VariableTypeInstruction.prototype.isUniform = function () {
                if (((this._isUniform) === null)) {
                    this._isUniform = this.hasUsage("uniform");
                }
                return this._isUniform;
            };
            VariableTypeInstruction.prototype.isGlobal = function () {
                if (((this._isGlobal) === null)) {
                    this._isGlobal = this._getScope() === 0;
                }
                return this._isGlobal;
            };
            VariableTypeInstruction.prototype.isConst = function () {
                if (((this._isConst) === null)) {
                    this._isConst = this.hasUsage("const");
                }
                return this._isConst;
            };
            VariableTypeInstruction.prototype.isShared = function () {
                if (((this._isShared) === null)) {
                    this._isShared = this.hasUsage("shared");
                }
                return this._isShared;
            };
            VariableTypeInstruction.prototype.isForeign = function () {
                if (((this._isForeign) === null)) {
                    this._isForeign = this.hasUsage("foreign");
                }
                return this._isForeign;
            };
            VariableTypeInstruction.prototype._isTypeOfField = function () {
                if (((((this)._pParentInstruction)) === null)) {
                    return false;
                }
                if (((this)._pParentInstruction)._getInstructionType() === akra.EAFXInstructionTypes.k_VariableDeclInstruction) {
                    var pParentDecl = ((this)._pParentInstruction);
                    return pParentDecl.isField();
                }
                return false;
            };
            VariableTypeInstruction.prototype._isUnverifiable = /** @inline */function () {
                return this._bUnverifiable;
            };
            VariableTypeInstruction.prototype.setName = //-----------------------------------------------------------------//
            //----------------------------SET TYPE INFO------------------------//
            //-----------------------------------------------------------------//
            function (sName) {
                this._sName = sName;
            };
            VariableTypeInstruction.prototype._canWrite = /** @inline */function (isWritable) {
                this._isWritable = isWritable;
            };
            VariableTypeInstruction.prototype._canRead = /** @inline */function (isReadable) {
                this._isReadable = isReadable;
            };
            VariableTypeInstruction.prototype.setPadding = //-----------------------------------------------------------------//
            //----------------------------INIT API-----------------------------//
            //-----------------------------------------------------------------//
            /** @inline */function (iPadding) {
                this._iPadding = iPadding;
            };
            VariableTypeInstruction.prototype.pushType = function (pType) {
                var eType = pType._getInstructionType();
                if (eType === akra.EAFXInstructionTypes.k_SystemTypeInstruction || eType === akra.EAFXInstructionTypes.k_ComplexTypeInstruction) {
                    this._pSubType = pType;
                } else {
                    var pVarType = pType;
                    if (!pVarType.isNotBaseArray() && !pVarType.isPointer()) {
                        var pUsageList = pVarType.getUsageList();
                        if (!((pUsageList) === null)) {
                            for(var i = 0; i < pUsageList.length; i++) {
                                this.addUsage(pUsageList[i]);
                            }
                        }
                        this._pSubType = pVarType.getSubType();
                    } else {
                        this._pSubType = pType;
                    }
                }
            };
            VariableTypeInstruction.prototype.addUsage = function (sUsage) {
                if (((this._pUsageList) === null)) {
                    this._pUsageList = [];
                }
                if (!this.hasUsage(sUsage)) {
                    this._pUsageList.push(sUsage);
                }
            };
            VariableTypeInstruction.prototype.addArrayIndex = function (pExpr) {
                //TODO: add support for v[][10]
                this._pArrayElementType = new VariableTypeInstruction();
                this._pArrayElementType.pushType(((this)._pSubType));
                if (!((this._pUsageList) === null)) {
                    for(var i = 0; i < this._pUsageList.length; i++) {
                        this._pArrayElementType.addUsage(this._pUsageList[i]);
                    }
                }
                this._pArrayElementType.setParent(this);
                this._pArrayIndexExpr = pExpr;
                this._iLength = this._pArrayIndexExpr.evaluate() ? this._pArrayIndexExpr.getEvalValue() : 0xffffff;
                this._isArray = true;
                if (this._iLength === 0xffffff) {
                    this._isNeedToUpdateLength = true;
                }
            };
            VariableTypeInstruction.prototype.addPointIndex = function (isStrict) {
                if (typeof isStrict === "undefined") { isStrict = true; }
                this._nPointDim++;
                this._isPointer = true;
                if (isStrict) {
                    this._isStrictPointer = true;
                }
            };
            VariableTypeInstruction.prototype.setVideoBuffer = function (pBuffer) {
                if (this.isPointIndex()) {
                    (((this)._pParentInstruction).getParent()).getType().setVideoBuffer(pBuffer);
                    return;
                }
                this._pVideoBuffer = pBuffer;
                if (!((((this))._pSubType).isComplex())) {
                    return;
                }
                var pFieldNameList = this.getFieldNameList();
                for(var i = 0; i < pFieldNameList.length; i++) {
                    var pFieldType = this.getFieldType(pFieldNameList[i]);
                    if (pFieldType.isPointer()) {
                        pFieldType.setVideoBuffer(pBuffer);
                    }
                }
            };
            VariableTypeInstruction.prototype.initializePointers = function () {
                this._pPointerList = [];
                var pDownPointer = this._getParentVarDecl();
                for(var i = 0; i < this.getPointDim(); i++) {
                    var pPointer = new fx.VariableDeclInstruction();
                    var pPointerType = new VariableTypeInstruction();
                    var pPointerId = new fx.IdInstruction();
                    pPointer.push(pPointerType, true);
                    pPointer.push(pPointerId, true);
                    pPointerType.pushType(fx.Effect.getSystemType("ptr"));
                    pPointerId.setName("undef");
                    pPointerId.setName(this._getParentVarDecl().getName() + "_pointer_" + i.toString());
                    if (i > 0) {
                        (this._pPointerList[i - 1].getType())._setUpDownPointers(pPointer, pDownPointer);
                        pDownPointer = this._pPointerList[i - 1];
                    } else {
                        pPointerType._setUpDownPointers(null, pDownPointer);
                    }
                    pPointer.setParent(this._getParentVarDecl());
                    this._pPointerList.push(pPointer);
                }
                this._pPointerList[this._pPointerList.length - 1].getType()._setUpDownPointers(null, pDownPointer);
                this._pUpPointIndex = this._pPointerList[0];
                this._pMainPointIndex = this._pPointerList[this._pPointerList.length - 1];
            };
            VariableTypeInstruction.prototype._setPointerToStrict = function () {
                this._isStrictPointer = true;
            };
            VariableTypeInstruction.prototype._addPointIndexInDepth = function () {
                if (!((((this))._pSubType).isComplex())) {
                    return;
                }
                var pFieldNameList = this.getFieldNameList();
                for(var i = 0; i < pFieldNameList.length; i++) {
                    var pFieldType = this.getFieldType(pFieldNameList[i]);
                    if (!pFieldType.isPointer()) {
                        pFieldType.addPointIndex(false);
                        pFieldType._setVideoBufferInDepth();
                    }
                }
            };
            VariableTypeInstruction.prototype._setVideoBufferInDepth = function () {
                if (this.isPointer()) {
                    this.setVideoBuffer(fx.Effect.createVideoBufferVariable());
                } else if (((((this))._pSubType).isComplex()) && this._containPointer()) {
                    var pFieldNameList = this.getFieldNameList();
                    for(var i = 0; i < pFieldNameList.length; i++) {
                        var pFieldType = this.getFieldType(pFieldNameList[i]);
                        pFieldType._setVideoBufferInDepth();
                    }
                }
            };
            VariableTypeInstruction.prototype._markAsUnverifiable = /** @inline */function (isUnverifiable) {
                this._bUnverifiable = true;
            };
            VariableTypeInstruction.prototype._addAttrOffset = function (pOffset) {
                this._pAttrOffset = pOffset;
            };
            VariableTypeInstruction.prototype.getName = //-----------------------------------------------------------------//
            //----------------------------GET TYPE INFO------------------------//
            //-----------------------------------------------------------------//
            function () {
                return this._sName;
            };
            VariableTypeInstruction.prototype.getRealName = /** @inline */function () {
                return this.getBaseType().getRealName();
            };
            VariableTypeInstruction.prototype.getHash = function () {
                if (this._sHash === "") {
                    this.calcHash();
                }
                return this._sHash;
            };
            VariableTypeInstruction.prototype.getStrongHash = function () {
                if (this._sStrongHash === "") {
                    this.calcStrongHash();
                }
                return this._sStrongHash;
            };
            VariableTypeInstruction.prototype.getSize = function () {
                if (this.isPointer() || this.isPointIndex()) {
                    return 1;
                }
                if (this._isArray) {
                    var iSize = this._pArrayElementType.getSize();
                    if (this._iLength === 0xffffff || iSize === 0xffffff) {
                        return 0xffffff;
                    } else {
                        return iSize * this._iLength;
                    }
                } else {
                    return ((this)._pSubType).getSize();
                }
            };
            VariableTypeInstruction.prototype.getBaseType = function () {
                return ((this)._pSubType).getBaseType();
            };
            VariableTypeInstruction.prototype.getLength = function () {
                if (!((this)._isArray || ((((this))._pSubType).isNotBaseArray()))) {
                    this._iLength = 0;
                    return 0;
                }
                if (((this)._isArray || ((((this))._pSubType).isNotBaseArray())) && !this._isArray) {
                    this._iLength = ((this)._pSubType).getLength();
                } else if (this._iLength === 0xffffff || this._isNeedToUpdateLength) {
                    var isEval = this._pArrayIndexExpr.evaluate();
                    if (isEval) {
                        var iValue = this._pArrayIndexExpr.getEvalValue();
                        this._iLength = (typeof (iValue) === "number") ? iValue : 0xffffff;
                    }
                }
                return this._iLength;
            };
            VariableTypeInstruction.prototype.getPadding = function () {
                return this.isPointIndex() ? this._getDownPointer().getType().getPadding() : this._iPadding;
            };
            VariableTypeInstruction.prototype.getArrayElementType = function () {
                if (((this)._bUnverifiable)) {
                    return this;
                }
                if (!((this)._isArray || ((((this))._pSubType).isArray()))) {
                    return null;
                }
                if (((this._pArrayElementType) === null)) {
                    this._pArrayElementType = new VariableTypeInstruction();
                    this._pArrayElementType.pushType(((this)._pSubType).getArrayElementType());
                    if (!((this._pUsageList) === null)) {
                        for(var i = 0; i < this._pUsageList.length; i++) {
                            this._pArrayElementType.addUsage(this._pUsageList[i]);
                        }
                    }
                    this._pArrayElementType.setParent(this);
                }
                return this._pArrayElementType;
            };
            VariableTypeInstruction.prototype.getTypeDecl = function () {
                if (!this.isFromTypeDecl()) {
                    return null;
                }
                var eParentType = ((this)._pParentInstruction)._getInstructionType();
                if (eParentType === akra.EAFXInstructionTypes.k_TypeDeclInstruction) {
                    return ((this)._pParentInstruction);
                } else {
                    return (((this)._pParentInstruction)).getTypeDecl();
                }
            };
            VariableTypeInstruction.prototype.hasField = function (sFieldName) {
                return ((this)._bUnverifiable) ? true : ((this)._pSubType).hasField(sFieldName);
            };
            VariableTypeInstruction.prototype.hasFieldWithSematic = function (sSemantic) {
                if (!((((this))._pSubType).isComplex())) {
                    return false;
                }
                return ((this)._pSubType).hasFieldWithSematic(sSemantic);
            };
            VariableTypeInstruction.prototype.hasAllUniqueSemantics = function () {
                if (!((((this))._pSubType).isComplex())) {
                    return false;
                }
                return ((this)._pSubType).hasAllUniqueSemantics();
            };
            VariableTypeInstruction.prototype.hasFieldWithoutSemantic = function () {
                if (!((((this))._pSubType).isComplex())) {
                    return false;
                }
                return ((this)._pSubType).hasFieldWithoutSemantic();
            };
            VariableTypeInstruction.prototype.getField = function (sFieldName) {
                if (!this.hasField(sFieldName)) {
                    return null;
                }
                if (((this._pFieldDeclMap) === null)) {
                    this._pFieldDeclMap = {};
                }
                if (((this._pFieldDeclMap[sFieldName]) !== undefined)) {
                    return this._pFieldDeclMap[sFieldName];
                }
                var pField = new fx.VariableDeclInstruction();
                if (!((this)._bUnverifiable)) {
                    var pSubField = ((this)._pSubType).getField(sFieldName);
                    var pFieldType = new VariableTypeInstruction();
                    pFieldType.pushType(pSubField.getType());
                    // if(!this.isBase()){
                    pFieldType.setPadding(pSubField.getType().getPadding());
                    // }
                    pField.push(pFieldType, true);
                    pField.push(pSubField.getNameId(), false);
                    pField.setSemantic(pSubField.getSemantic());
                } else {
                    var pFieldName = new fx.IdInstruction();
                    pFieldName.setName(sFieldName);
                    pFieldName.setRealName(sFieldName);
                    pField.push(this, false);
                    pField.push(pFieldName, true);
                }
                pField.setParent(this);
                this._pFieldDeclMap[sFieldName] = pField;
                return pField;
            };
            VariableTypeInstruction.prototype.getFieldBySemantic = /** @inline */function (sSemantic) {
                if (this.hasFieldWithSematic(sSemantic)) {
                    return null;
                }
                if (((this._pFieldDeclBySemanticMap) === null)) {
                    this._pFieldDeclBySemanticMap = {};
                }
                if (((this._pFieldDeclBySemanticMap[sSemantic]) !== undefined)) {
                    return this._pFieldDeclBySemanticMap[sSemantic];
                }
                var pField = new fx.VariableDeclInstruction();
                var pSubField = ((this)._pSubType).getFieldBySemantic(sSemantic);
                var pFieldType = new VariableTypeInstruction();
                pFieldType.pushType(pSubField.getType());
                // if(!this.isBase()){
                pFieldType.setPadding(pSubField.getType().getPadding());
                // }
                pField.push(pFieldType, true);
                pField.push(pSubField.getNameId(), false);
                pField.setParent(this);
                this._pFieldDeclBySemanticMap[sSemantic] = pField;
                return pField;
            };
            VariableTypeInstruction.prototype.getFieldType = function (sFieldName) {
                return this.getField(sFieldName).getType();
            };
            VariableTypeInstruction.prototype.getFieldNameList = function () {
                return ((this)._pSubType).getFieldNameList();
            };
            VariableTypeInstruction.prototype.getUsageList = /** @inline */function () {
                return this._pUsageList;
            };
            VariableTypeInstruction.prototype.getSubType = /** @inline */function () {
                return this._pSubType;
            };
            VariableTypeInstruction.prototype.hasUsage = function (sUsageName) {
                if (((this._pUsageList) === null)) {
                    return false;
                }
                for(var i = 0; i < this._pUsageList.length; i++) {
                    if (this._pUsageList[i] === sUsageName) {
                        return true;
                    }
                }
                if (!((((this)._pSubType)) === null) && ((this)._pSubType)._getInstructionType() === akra.EAFXInstructionTypes.k_VariableTypeInstruction) {
                    return (((this)._pSubType)).hasUsage(sUsageName);
                }
                return false;
            };
            VariableTypeInstruction.prototype.hasVideoBuffer = function () {
                return !((this.getVideoBuffer()) === null);
            };
            VariableTypeInstruction.prototype.getPointDim = function () {
                return this._nPointDim || ((((this)._pSubType)._getInstructionType() === akra.EAFXInstructionTypes.k_VariableTypeInstruction) ? (((this)._pSubType)).getPointDim() : 0);
            };
            VariableTypeInstruction.prototype.getPointer = function () {
                if (!this.isFromVariableDecl() || !(this.isPointer() || this.isPointIndex()) || !this.hasVideoBuffer()) {
                    return null;
                }
                if (!((this._pUpPointIndex) === null)) {
                    return this._pUpPointIndex;
                }
                if (this.isPointIndex()) {
                    return null;
                }
                this.initializePointers();
                return this._pUpPointIndex;
            };
            VariableTypeInstruction.prototype.getVideoBuffer = function () {
                if (this.isPointIndex()) {
                    return (((this)._pParentInstruction).getParent()).getType().getVideoBuffer();
                }
                return this._pVideoBuffer;
            };
            VariableTypeInstruction.prototype.getFieldExpr = function (sFieldName) {
                if (!this.hasField(sFieldName)) {
                    return null;
                }
                var pField = this.getField(sFieldName);
                var pExpr = new fx.IdExprInstruction();
                pExpr.push(pField.getNameId(), false);
                pExpr.setType(pField.getType());
                return pExpr;
            };
            VariableTypeInstruction.prototype.getFieldIfExist = function (sFieldName) {
                if (((this._pFieldDeclMap) === null) && ((this._pFieldDeclMap[sFieldName]) !== undefined)) {
                    return this._pFieldDeclMap[sFieldName];
                } else {
                    return null;
                }
            };
            VariableTypeInstruction.prototype.getSubVarDecls = function () {
                if (!((((((this)))._pSubType).isComplex()) || (this).isPointer() || !(((this)._pAttrOffset) === null))) {
                    return null;
                }
                if (((this._pSubDeclList) === null)) {
                    this.generateSubDeclList();
                }
                return this._pSubDeclList;
            };
            VariableTypeInstruction.prototype._getFullName = function () {
                if (!this.isFromVariableDecl()) {
                    return "Not from variable decl";
                }
                var eParentType = ((this)._pParentInstruction)._getInstructionType();
                if (eParentType === akra.EAFXInstructionTypes.k_VariableDeclInstruction) {
                    return (((this)._pParentInstruction))._getFullName();
                } else {
                    return (((this)._pParentInstruction))._getFullName();
                }
            };
            VariableTypeInstruction.prototype._getVarDeclName = function () {
                if (!this.isFromVariableDecl()) {
                    return "";
                }
                var eParentType = ((this)._pParentInstruction)._getInstructionType();
                if (eParentType === akra.EAFXInstructionTypes.k_VariableDeclInstruction) {
                    return (((this)._pParentInstruction)).getName();
                } else {
                    return (((this)._pParentInstruction))._getVarDeclName();
                }
            };
            VariableTypeInstruction.prototype._getTypeDeclName = function () {
                if (!this.isFromVariableDecl()) {
                    return "";
                }
                var eParentType = ((this)._pParentInstruction)._getInstructionType();
                if (eParentType === akra.EAFXInstructionTypes.k_VariableDeclInstruction) {
                    return (((this)._pParentInstruction)).getName();
                } else {
                    return (((this)._pParentInstruction))._getTypeDeclName();
                }
            };
            VariableTypeInstruction.prototype._getParentVarDecl = function () {
                if (!this.isFromVariableDecl()) {
                    return null;
                }
                var eParentType = ((this)._pParentInstruction)._getInstructionType();
                if (eParentType === akra.EAFXInstructionTypes.k_VariableDeclInstruction) {
                    return ((this)._pParentInstruction);
                } else {
                    return (((this)._pParentInstruction))._getParentVarDecl();
                }
            };
            VariableTypeInstruction.prototype._getParentContainer = function () {
                if (!this.isFromVariableDecl() || !this._isTypeOfField()) {
                    return null;
                }
                var pContainerType = this._getParentVarDecl().getParent();
                if (!pContainerType.isFromVariableDecl()) {
                    return null;
                }
                return pContainerType._getParentVarDecl();
            };
            VariableTypeInstruction.prototype._getMainVariable = function () {
                if (!this.isFromVariableDecl()) {
                    return null;
                }
                if (this._isTypeOfField()) {
                    return (((this)._pParentInstruction).getParent())._getMainVariable();
                } else {
                    return (this._getParentVarDecl());
                }
            };
            VariableTypeInstruction.prototype._getMainPointer = function () {
                if (((this._pMainPointIndex) === null)) {
                    if (((this.getPointer()) === null)) {
                        this._pMainPointIndex = this._getParentVarDecl();
                    } else {
                        this._pMainPointIndex = this._getUpPointer().getType()._getMainPointer();
                    }
                }
                return this._pMainPointIndex;
            };
            VariableTypeInstruction.prototype._getUpPointer = function () {
                return this._pUpPointIndex;
            };
            VariableTypeInstruction.prototype._getDownPointer = function () {
                return this._pDownPointIndex;
            };
            VariableTypeInstruction.prototype._getAttrOffset = function () {
                return this._pAttrOffset;
            };
            VariableTypeInstruction.prototype.wrap = //-----------------------------------------------------------------//
            //----------------------------SYSTEM-------------------------------//
            //-----------------------------------------------------------------//
            function () {
                var pCloneType = new VariableTypeInstruction();
                pCloneType.pushType(this);
                return pCloneType;
            };
            VariableTypeInstruction.prototype.clone = function (pRelationMap) {
                if (typeof pRelationMap === "undefined") { pRelationMap = {}; }
                if (((pRelationMap[((this)._iInstructionID)]) !== undefined)) {
                    return pRelationMap[((this)._iInstructionID)];
                }
                if (this._pParentInstruction === null || !((pRelationMap[this._pParentInstruction._getInstructionID()]) !== undefined) || pRelationMap[this._pParentInstruction._getInstructionID()] === this._pParentInstruction) {
                    //pRelationMap[this._getInstructionID()] = this;
                    return this;
                }
                var pClone = _super.prototype.clone.call(this, pRelationMap);
                pClone.pushType(this._pSubType.clone(pRelationMap));
                if (!((this._pUsageList) === null)) {
                    for(var i = 0; i < this._pUsageList.length; i++) {
                        pClone.addUsage(this._pUsageList[i]);
                    }
                }
                pClone._canWrite(this._isWritable);
                pClone._canRead(this._isReadable);
                pClone._setCloneHash(this._sHash, this._sStrongHash);
                pClone.setPadding(this.getPadding());
                if (this._isArray) {
                    this._setCloneArrayIndex(this._pArrayElementType.clone(pRelationMap), this._pArrayIndexExpr.clone(pRelationMap), this._iLength);
                }
                if (this._isPointer) {
                    var pClonePointerList = null;
                    if (!((this._pPointerList) === null)) {
                        pClonePointerList = new Array(this._pPointerList.length);
                        var pDownPointer = pClone._getParentVarDecl();
                        for(var i = 0; i < this._pPointerList.length; i++) {
                            pClonePointerList[i] = this._pPointerList[i].clone(pRelationMap);
                            if (i > 0) {
                                (pClonePointerList[i - 1].getType())._setUpDownPointers(pClonePointerList[i], pDownPointer);
                                pDownPointer = pClonePointerList[i - 1];
                            } else {
                                pClonePointerList[0].getType()._setUpDownPointers(null, pDownPointer);
                            }
                        }
                        pClonePointerList[pClonePointerList.length - 1].getType()._setUpDownPointers(null, pDownPointer);
                    }
                    this._setClonePointeIndexes(this.getPointDim(), pClonePointerList);
                }
                if (!((this._pFieldDeclMap) === null)) {
                    var sFieldName = "";
                    var pCloneFieldMap = {};
                    for(sFieldName in this._pFieldDeclMap) {
                        pCloneFieldMap[sFieldName] = this._pFieldDeclMap[sFieldName].clone(pRelationMap);
                    }
                    this._setCloneFields(pCloneFieldMap);
                }
                return pClone;
            };
            VariableTypeInstruction.prototype.blend = function (pType, eMode) {
                if (this === pType) {
                    return this;
                }
                if (eMode === akra.EAFXBlendMode.k_Global) {
                    return null;
                }
                if (((((this))._pSubType).isComplex()) !== pType.isComplex() || (((this)._isArray || ((((this))._pSubType).isNotBaseArray())) !== pType.isNotBaseArray()) || (this.isPointer() !== pType.isPointer())) {
                    return null;
                }
                if (((this)._isArray || ((((this))._pSubType).isNotBaseArray())) || this.getLength() === 0xffffff || this.getLength() !== pType.getLength()) {
                    return null;
                }
                var pBlendBaseType = this.getBaseType().blend(pType.getBaseType(), eMode);
                if (((pBlendBaseType) === null)) {
                    return null;
                }
                var pBlendType = new VariableTypeInstruction();
                pBlendType.pushType(pBlendBaseType);
                if (((this)._isArray || ((((this))._pSubType).isNotBaseArray()))) {
                    var iLength = this.getLength();
                    var pLengthExpr = new fx.IntInstruction();
                    (pLengthExpr._iValue = (iLength));
                    pBlendType.addArrayIndex(pLengthExpr);
                }
                return pBlendType;
            };
            VariableTypeInstruction.prototype._setCloneHash = function (sHash, sStrongHash) {
                this._sHash = sHash;
                this._sStrongHash = sStrongHash;
            };
            VariableTypeInstruction.prototype._setCloneArrayIndex = function (pElementType, pIndexExpr, iLength) {
                this._isArray = true;
                this._pArrayElementType = pElementType;
                this._pArrayIndexExpr = pIndexExpr;
                this._iLength = iLength;
            };
            VariableTypeInstruction.prototype._setClonePointeIndexes = function (nDim, pPointerList) {
                this._isPointer = true;
                this._nPointDim = nDim;
                this._pPointerList = pPointerList;
                if (!((this._pPointerList) === null)) {
                    this._pUpPointIndex = this._pPointerList[0];
                }
            };
            VariableTypeInstruction.prototype._setCloneFields = function (pFieldMap) {
                this._pFieldDeclMap = pFieldMap;
            };
            VariableTypeInstruction.prototype._setUpDownPointers = /** @inline */function (pUpPointIndex, pDownPointIndex) {
                this._pUpPointIndex = pUpPointIndex;
                this._pDownPointIndex = pDownPointIndex;
            };
            VariableTypeInstruction.prototype.calcHash = function () {
                var sHash = ((this)._pSubType).getHash();
                if (this._isArray) {
                    sHash += "[";
                    var iLength = this.getLength();
                    if (iLength === 0xffffff) {
                        sHash += "undef";
                    } else {
                        sHash += iLength.toString();
                    }
                    sHash += "]";
                }
                this._sHash = sHash;
            };
            VariableTypeInstruction.prototype.calcStrongHash = function () {
                var sStrongHash = ((this)._pSubType).getStrongHash();
                if (this._isArray) {
                    sStrongHash += "[";
                    var iLength = this.getLength();
                    if (iLength === 0xffffff) {
                        sStrongHash += "undef";
                    } else {
                        sStrongHash += iLength.toString();
                    }
                    sStrongHash += "]";
                }
                if (this.isPointer()) {
                    for(var i = 0; i < this.getPointDim(); i++) {
                        sStrongHash = "@" + sStrongHash;
                    }
                }
                this._sStrongHash = sStrongHash;
            };
            VariableTypeInstruction.prototype.generateSubDeclList = function () {
                if (!((((((this)))._pSubType).isComplex()) || (this).isPointer() || !(((this)._pAttrOffset) === null))) {
                    return;
                }
                var pDeclList = [];
                var i = 0;
                if (!((this._pAttrOffset) === null)) {
                    pDeclList.push(this._pAttrOffset);
                }
                if (this.isPointer()) {
                    if (((this._getUpPointer()) === null)) {
                        this.initializePointers();
                    }
                    for(i = 0; i < this._pPointerList.length; i++) {
                        pDeclList.push(this._pPointerList[i]);
                    }
                }
                if (((((this))._pSubType).isComplex())) {
                    var pFieldNameList = this.getFieldNameList();
                    for(i = 0; i < pFieldNameList.length; i++) {
                        var pField = this.getField(pFieldNameList[i]);
                        var pFieldSubDeclList = pField.getSubVarDecls();
                        if (!((pFieldSubDeclList) === null)) {
                            for(var j = 0; j < pFieldSubDeclList.length; j++) {
                                pDeclList.push(pFieldSubDeclList[j]);
                            }
                        }
                    }
                }
                this._pSubDeclList = pDeclList;
            };
            VariableTypeInstruction.prototype.canHaveSubDecls = /** @inline */function () {
                return ((((this))._pSubType).isComplex()) || this.isPointer() || !((this._pAttrOffset) === null);
            };
            return VariableTypeInstruction;
        })(fx.Instruction);
        fx.VariableTypeInstruction = VariableTypeInstruction;        
        var SystemTypeInstruction = (function (_super) {
            __extends(SystemTypeInstruction, _super);
            function SystemTypeInstruction() {
                        _super.call(this);
                this._sName = "";
                this._sRealName = "";
                this._pElementType = null;
                this._iLength = 1;
                this._iSize = null;
                this._pFieldDeclMap = null;
                this._isArray = false;
                this._isWritable = true;
                this._isReadable = true;
                this._pFieldNameList = null;
                this._pWrapVariableType = null;
                this._isBuiltIn = true;
                this._sDeclString = "";
                this._eInstructionType = akra.EAFXInstructionTypes.k_SystemTypeInstruction;
                this._pWrapVariableType = new VariableTypeInstruction();
                this._pWrapVariableType.pushType(this);
            }
            SystemTypeInstruction.prototype._toDeclString = function () {
                return this._sDeclString;
            };
            SystemTypeInstruction.prototype.toFinalCode = function () {
                return this._sRealName;
            };
            SystemTypeInstruction.prototype.isBuiltIn = function () {
                return this._isBuiltIn;
            };
            SystemTypeInstruction.prototype.setBuiltIn = function (isBuiltIn) {
                this._isBuiltIn = isBuiltIn;
            };
            SystemTypeInstruction.prototype.setDeclString = function (sDecl) {
                this._sDeclString = sDecl;
            };
            SystemTypeInstruction.prototype.isBase = //-----------------------------------------------------------------//
            //----------------------------SIMPLE TESTS-------------------------//
            //-----------------------------------------------------------------//
            /** @inline */function () {
                return true;
            };
            SystemTypeInstruction.prototype.isArray = /** @inline */function () {
                return this._isArray;
            };
            SystemTypeInstruction.prototype.isNotBaseArray = /** @inline */function () {
                return false;
            };
            SystemTypeInstruction.prototype.isComplex = /** @inline */function () {
                return false;
            };
            SystemTypeInstruction.prototype.isEqual = /** @inline */function (pType) {
                return ((this)._sRealName) === pType.getHash();
            };
            SystemTypeInstruction.prototype.isStrongEqual = /** @inline */function (pType) {
                return ((this)._sName) === pType.getStrongHash();
            };
            SystemTypeInstruction.prototype.isConst = /** @inline */function () {
                return false;
            };
            SystemTypeInstruction.prototype.isSampler = function () {
                return ((this)._sName) === "sampler" || ((this)._sName) === "sampler2D" || ((this)._sName) === "samplerCUBE";
            };
            SystemTypeInstruction.prototype.isSamplerCube = function () {
                return ((this)._sName) === "samplerCUBE";
            };
            SystemTypeInstruction.prototype.isSampler2D = function () {
                return ((this)._sName) === "sampler" || ((this)._sName) === "sampler2D";
            };
            SystemTypeInstruction.prototype.isWritable = /** @inline */function () {
                return this._isWritable;
            };
            SystemTypeInstruction.prototype.isReadable = /** @inline */function () {
                return this._isReadable;
            };
            SystemTypeInstruction.prototype._containArray = function () {
                return false;
            };
            SystemTypeInstruction.prototype._containSampler = function () {
                return false;
            };
            SystemTypeInstruction.prototype._containPointer = function () {
                return false;
            };
            SystemTypeInstruction.prototype._containComplexType = function () {
                return false;
            };
            SystemTypeInstruction.prototype.setName = //-----------------------------------------------------------------//
            //----------------------------SET BASE TYPE INFO-------------------//
            //-----------------------------------------------------------------//
            /** @inline */function (sName) {
                this._sName = sName;
            };
            SystemTypeInstruction.prototype.setRealName = /** @inline */function (sRealName) {
                this._sRealName = sRealName;
            };
            SystemTypeInstruction.prototype.setSize = /** @inline */function (iSize) {
                this._iSize = iSize;
            };
            SystemTypeInstruction.prototype._canWrite = /** @inline */function (isWritable) {
                this._isWritable = isWritable;
            };
            SystemTypeInstruction.prototype._canRead = /** @inline */function (isReadable) {
                this._isReadable = isReadable;
            };
            SystemTypeInstruction.prototype.addIndex = //-----------------------------------------------------------------//
            //---------------------------INIT API------------------------------//
            //-----------------------------------------------------------------//
            function (pType, iLength) {
                this._pElementType = pType;
                this._iLength = iLength;
                this._iSize = iLength * pType.getSize();
                this._isArray = true;
            };
            SystemTypeInstruction.prototype.addField = function (sFieldName, pType, isWrite, sRealFieldName) {
                if (typeof isWrite === "undefined") { isWrite = true; }
                if (typeof sRealFieldName === "undefined") { sRealFieldName = sFieldName; }
                var pField = new fx.VariableDeclInstruction();
                var pFieldType = new VariableTypeInstruction();
                var pFieldId = new fx.IdInstruction();
                pFieldType.pushType(pType);
                (pFieldType._isWritable = (isWrite));
                pFieldId.setName(sFieldName);
                pFieldId.setRealName(sRealFieldName);
                pField.push(pFieldType, true);
                pField.push(pFieldId, true);
                if (((this._pFieldDeclMap) === null)) {
                    this._pFieldDeclMap = {};
                }
                this._pFieldDeclMap[sFieldName] = pField;
                if (((this._pFieldNameList) === null)) {
                    this._pFieldNameList = [];
                }
                this._pFieldNameList.push(sFieldName);
            };
            SystemTypeInstruction.prototype.getName = //-----------------------------------------------------------------//
            //----------------------------GET TYPE INFO------------------------//
            //-----------------------------------------------------------------//
            /** @inline */function () {
                return this._sName;
            };
            SystemTypeInstruction.prototype.getRealName = /** @inline */function () {
                return this._sRealName;
            };
            SystemTypeInstruction.prototype.getHash = /** @inline */function () {
                return this._sRealName;
            };
            SystemTypeInstruction.prototype.getStrongHash = /** @inline */function () {
                return this._sName;
            };
            SystemTypeInstruction.prototype.getSize = /** @inline */function () {
                return this._iSize;
            };
            SystemTypeInstruction.prototype.getBaseType = /** @inline */function () {
                return this;
            };
            SystemTypeInstruction.prototype.getVariableType = /** @inline */function () {
                return this._pWrapVariableType;
            };
            SystemTypeInstruction.prototype.getArrayElementType = /** @inline */function () {
                return this._pElementType;
            };
            SystemTypeInstruction.prototype.getTypeDecl = function () {
                if (this.isBuiltIn()) {
                    return null;
                }
                return ((this)._pParentInstruction);
            };
            SystemTypeInstruction.prototype.getLength = /** @inline */function () {
                return this._iLength;
            };
            SystemTypeInstruction.prototype.hasField = /** @inline */function (sFieldName) {
                return ((this._pFieldDeclMap[sFieldName]) !== undefined);
            };
            SystemTypeInstruction.prototype.hasFieldWithSematic = function (sSemantic) {
                return false;
            };
            SystemTypeInstruction.prototype.hasAllUniqueSemantics = function () {
                return false;
            };
            SystemTypeInstruction.prototype.hasFieldWithoutSemantic = function () {
                return false;
            };
            SystemTypeInstruction.prototype.getField = /** @inline */function (sFieldName) {
                return ((this._pFieldDeclMap[sFieldName]) !== undefined) ? this._pFieldDeclMap[sFieldName] : null;
            };
            SystemTypeInstruction.prototype.getFieldBySemantic = /** @inline */function (sSemantic) {
                return null;
            };
            SystemTypeInstruction.prototype.getFieldType = /** @inline */function (sFieldName) {
                return ((this._pFieldDeclMap[sFieldName]) !== undefined) ? this._pFieldDeclMap[sFieldName].getType() : null;
            };
            SystemTypeInstruction.prototype.getFieldNameList = /** @inline */function () {
                return this._pFieldNameList;
            };
            SystemTypeInstruction.prototype.clone = //-----------------------------------------------------------------//
            //----------------------------SYSTEM-------------------------------//
            //-----------------------------------------------------------------//
            /** @inline */function (pRelationMap) {
                return this;
            };
            SystemTypeInstruction.prototype.blend = /** @inline */function (pType, eMode) {
                if (((((this))._sName) === (pType).getStrongHash())) {
                    return this;
                }
                return null;
            };
            return SystemTypeInstruction;
        })(fx.Instruction);
        fx.SystemTypeInstruction = SystemTypeInstruction;        
        var ComplexTypeInstruction = (function (_super) {
            __extends(ComplexTypeInstruction, _super);
            function ComplexTypeInstruction() {
                        _super.call(this);
                this._sName = "";
                this._sRealName = "";
                this._sHash = "";
                this._sStrongHash = "";
                this._iSize = 0;
                this._pFieldDeclMap = null;
                this._pFieldDeclList = null;
                this._pFieldNameList = null;
                this._pFieldDeclBySemanticMap = null;
                this._hasAllUniqueSemantics = true;
                this._hasFieldWithoutSemantic = false;
                this._isContainArray = false;
                this._isContainSampler = false;
                this._isContainPointer = false;
                this._isContainComplexType = false;
                this._pInstructionList = null;
                this._eInstructionType = akra.EAFXInstructionTypes.k_ComplexTypeInstruction;
            }
            ComplexTypeInstruction.prototype._toDeclString = function () {
                var sCode = "struct " + this._sRealName + "{";
                for(var i = 0; i < this._pFieldDeclList.length; i++) {
                    sCode += "\t" + this._pFieldDeclList[i].toFinalCode() + ";\n";
                }
                sCode += "}";
                return sCode;
            };
            ComplexTypeInstruction.prototype.toFinalCode = function () {
                return this._sRealName;
            };
            ComplexTypeInstruction.prototype.isBuiltIn = function () {
                return false;
            };
            ComplexTypeInstruction.prototype.setBuiltIn = function (isBuiltIn) {
            };
            ComplexTypeInstruction.prototype.isBase = //-----------------------------------------------------------------//
            //----------------------------SIMPLE TESTS-------------------------//
            //-----------------------------------------------------------------//
            /** @inline */function () {
                return false;
            };
            ComplexTypeInstruction.prototype.isArray = /** @inline */function () {
                return false;
            };
            ComplexTypeInstruction.prototype.isNotBaseArray = /** @inline */function () {
                return false;
            };
            ComplexTypeInstruction.prototype.isComplex = /** @inline */function () {
                return true;
            };
            ComplexTypeInstruction.prototype.isEqual = /** @inline */function (pType) {
                return this.getHash() === pType.getHash();
            };
            ComplexTypeInstruction.prototype.isStrongEqual = /** @inline */function (pType) {
                return this.getStrongHash() === pType.getStrongHash();
            };
            ComplexTypeInstruction.prototype.isConst = /** @inline */function () {
                return false;
            };
            ComplexTypeInstruction.prototype.isSampler = function () {
                return false;
            };
            ComplexTypeInstruction.prototype.isSamplerCube = function () {
                return false;
            };
            ComplexTypeInstruction.prototype.isSampler2D = function () {
                return false;
            };
            ComplexTypeInstruction.prototype.isWritable = /** @inline */function () {
                return true;
            };
            ComplexTypeInstruction.prototype.isReadable = /** @inline */function () {
                return true;
            };
            ComplexTypeInstruction.prototype._containArray = /** @inline */function () {
                return this._isContainArray;
            };
            ComplexTypeInstruction.prototype._containSampler = /** @inline */function () {
                return this._isContainSampler;
            };
            ComplexTypeInstruction.prototype._containPointer = /** @inline */function () {
                return this._isContainPointer;
            };
            ComplexTypeInstruction.prototype._containComplexType = /** @inline */function () {
                return this._isContainComplexType;
            };
            ComplexTypeInstruction.prototype.setName = //-----------------------------------------------------------------//
            //----------------------------SET BASE TYPE INFO-------------------//
            //-----------------------------------------------------------------//
            /** @inline */function (sName) {
                this._sName = sName;
                this._sRealName = sName;
            };
            ComplexTypeInstruction.prototype.setRealName = /** @inline */function (sRealName) {
                this._sRealName = sRealName;
            };
            ComplexTypeInstruction.prototype.setSize = /** @inline */function (iSize) {
                this._iSize = iSize;
            };
            ComplexTypeInstruction.prototype._canWrite = /** @inline */function (isWritable) {
            };
            ComplexTypeInstruction.prototype._canRead = /** @inline */function (isWritable) {
            };
            ComplexTypeInstruction.prototype.addField = //-----------------------------------------------------------------//
            //----------------------------INIT API-----------------------------//
            //-----------------------------------------------------------------//
            function (pVariable) {
                if (((this._pFieldDeclMap) === null)) {
                    this._pFieldDeclMap = {};
                    this._pFieldNameList = [];
                }
                if (((this._pFieldDeclList) === null)) {
                    this._pFieldDeclList = [];
                }
                var sVarName = pVariable.getName();
                this._pFieldDeclMap[sVarName] = pVariable;
                if (this._iSize !== 0xffffff) {
                    var iSize = pVariable.getType().getSize();
                    if (iSize !== 0xffffff) {
                        this._iSize += iSize;
                    } else {
                        this._iSize = 0xffffff;
                    }
                }
                this._pFieldNameList.push(sVarName);
                if (this._pFieldDeclList.length < this._pFieldNameList.length) {
                    this._pFieldDeclList.push(pVariable);
                }
                var pType = pVariable.getType();
                //pType._markAsField();
                if (pType.isNotBaseArray() || pType._containArray()) {
                    this._isContainArray = true;
                }
                if (fx.Effect.isSamplerType(pType) || pType._containSampler()) {
                    this._isContainSampler = true;
                }
                if (pType.isPointer() || pType._containPointer()) {
                    this._isContainPointer = true;
                }
                if (pType.isComplex()) {
                    this._isContainComplexType = true;
                }
            };
            ComplexTypeInstruction.prototype.addFields = function (pFieldCollector, isSetParent) {
                if (typeof isSetParent === "undefined") { isSetParent = true; }
                this._pFieldDeclList = (pFieldCollector.getInstructions());
                for(var i = 0; i < this._pFieldDeclList.length; i++) {
                    this.addField(this._pFieldDeclList[i]);
                    this._pFieldDeclList[i].setParent(this);
                }
                this.calculatePaddings();
            };
            ComplexTypeInstruction.prototype.getName = //-----------------------------------------------------------------//
            //----------------------------GET TYPE INFO------------------------//
            //-----------------------------------------------------------------//
            /** @inline */function () {
                return this._sName;
            };
            ComplexTypeInstruction.prototype.getRealName = /** @inline */function () {
                return this._sRealName;
            };
            ComplexTypeInstruction.prototype.getHash = function () {
                if (this._sHash === "") {
                    this.calcHash();
                }
                return this._sHash;
            };
            ComplexTypeInstruction.prototype.getStrongHash = function () {
                if (this._sStrongHash === "") {
                    this.calcStrongHash();
                }
                return this._sStrongHash;
            };
            ComplexTypeInstruction.prototype.hasField = /** @inline */function (sFieldName) {
                return ((this._pFieldDeclMap[sFieldName]) !== undefined);
            };
            ComplexTypeInstruction.prototype.hasFieldWithSematic = function (sSemantic) {
                if (((this._pFieldDeclBySemanticMap) === null)) {
                    this.analyzeSemantics();
                }
                return ((this._pFieldDeclBySemanticMap[sSemantic]) !== undefined);
            };
            ComplexTypeInstruction.prototype.hasAllUniqueSemantics = function () {
                if (((this._pFieldDeclBySemanticMap) === null)) {
                    this.analyzeSemantics();
                }
                return this._hasAllUniqueSemantics;
            };
            ComplexTypeInstruction.prototype.hasFieldWithoutSemantic = function () {
                if (((this._pFieldDeclBySemanticMap) === null)) {
                    this.analyzeSemantics();
                }
                return this._hasFieldWithoutSemantic;
            };
            ComplexTypeInstruction.prototype.getField = /** @inline */function (sFieldName) {
                if (!((((this)._pFieldDeclMap[(sFieldName)]) !== undefined))) {
                    return null;
                }
                return this._pFieldDeclMap[sFieldName];
            };
            ComplexTypeInstruction.prototype.getFieldBySemantic = function (sSemantic) {
                if (!this.hasFieldWithSematic(sSemantic)) {
                    return null;
                }
                return this._pFieldDeclBySemanticMap[sSemantic];
            };
            ComplexTypeInstruction.prototype.getFieldType = /** @inline */function (sFieldName) {
                return ((this._pFieldDeclMap[sFieldName]) !== undefined) ? this._pFieldDeclMap[sFieldName].getType() : null;
            };
            ComplexTypeInstruction.prototype.getFieldNameList = /** @inline */function () {
                return this._pFieldNameList;
            };
            ComplexTypeInstruction.prototype.getSize = /** @inline */function () {
                if (this._iSize === 0xffffff) {
                    this._iSize = this._calcSize();
                }
                return this._iSize;
            };
            ComplexTypeInstruction.prototype.getBaseType = /** @inline */function () {
                return this;
            };
            ComplexTypeInstruction.prototype.getArrayElementType = /** @inline */function () {
                return null;
            };
            ComplexTypeInstruction.prototype.getTypeDecl = function () {
                return ((this)._pParentInstruction);
            };
            ComplexTypeInstruction.prototype.getLength = /** @inline */function () {
                return 0;
            };
            ComplexTypeInstruction.prototype._getFieldDeclList = function () {
                return this._pFieldDeclList;
            };
            ComplexTypeInstruction.prototype.clone = //-----------------------------------------------------------------//
            //----------------------------SYSTEM-------------------------------//
            //-----------------------------------------------------------------//
            /** @inline */function (pRelationMap) {
                if (typeof pRelationMap === "undefined") { pRelationMap = {}; }
                if (this._pParentInstruction === null || !((pRelationMap[this._pParentInstruction._getInstructionID()]) !== undefined) || pRelationMap[this._pParentInstruction._getInstructionID()] === this._pParentInstruction) {
                    //pRelationMap[this._getInstructionID()] = this;
                    return this;
                }
                var pClone = _super.prototype.clone.call(this, pRelationMap);
                pClone._setCloneName(this._sName, this._sRealName);
                pClone._setCloneHash(this._sHash, this._sStrongHash);
                pClone._setCloneContain(this._isContainArray, this._isContainSampler);
                var pFieldDeclList = new Array(this._pFieldDeclList.length);
                var pFieldNameList = new Array(this._pFieldNameList.length);
                var pFieldDeclMap = {};
                for(var i = 0; i < this._pFieldDeclList.length; i++) {
                    var pCloneVar = this._pFieldDeclList[i].clone(pRelationMap);
                    var sVarName = pCloneVar.getName();
                    pFieldDeclList[i] = pCloneVar;
                    pFieldNameList[i] = sVarName;
                    pFieldDeclMap[sVarName] = pCloneVar;
                }
                pClone._setCloneFields(pFieldDeclList, pFieldNameList, pFieldDeclMap);
                (pClone._iSize = (this._iSize));
                return pClone;
            };
            ComplexTypeInstruction.prototype.blend = function (pType, eMode) {
                if (pType === this) {
                    return this;
                }
                if (eMode === akra.EAFXBlendMode.k_TypeDecl) {
                    return null;
                }
                if (eMode === akra.EAFXBlendMode.k_Uniform || eMode === akra.EAFXBlendMode.k_Attribute) {
                    if (this.hasFieldWithoutSemantic() || pType.hasFieldWithoutSemantic()) {
                        return null;
                    }
                }
                var pFieldList = this._pFieldDeclList;
                var pBlendType = new ComplexTypeInstruction();
                var pRelationMap = {};
                if (((pFieldList) === null)) {
 {
                        akra.logger.setSourceLocation("fx/TypeInstruction.ts", 1899);
                        akra.logger.log(this, pType);
                    }
                    ;
                }
                for(var i = 0; i < pFieldList.length; i++) {
                    var pField = pFieldList[i];
                    var pBlendField = null;
                    var sFieldName = pField.getName();
                    var sFieldSemantic = pField.getSemantic();
                    if (eMode === akra.EAFXBlendMode.k_Shared) {
                        if (pType.hasField(sFieldName)) {
                            pBlendField = pField.blend(pType.getField(sFieldName), eMode);
                        } else {
                            pBlendField = pField.clone(pRelationMap);
                        }
                    } else if (eMode === akra.EAFXBlendMode.k_Attribute || eMode === akra.EAFXBlendMode.k_Uniform || eMode === akra.EAFXBlendMode.k_VertexOut) {
                        if (pType.hasFieldWithSematic(sFieldSemantic)) {
                            pBlendField = pField.blend(pType.getFieldBySemantic(sFieldSemantic), eMode);
                        } else {
                            pBlendField = pField.clone(pRelationMap);
                        }
                        if (!((pBlendField) === null)) {
                            pBlendField.getNameId().setName(sFieldSemantic);
                            pBlendField.getNameId().setRealName(sFieldSemantic);
                        }
                    }
                    if (((pBlendField) === null)) {
                        return null;
                    }
                    pBlendType.addField(pBlendField);
                }
                pFieldList = (pType)._getFieldDeclList();
                for(var i = 0; i < pFieldList.length; i++) {
                    var pField = pFieldList[i];
                    var pBlendField = null;
                    var sFieldName = pField.getName();
                    var sFieldSemantic = pField.getSemantic();
                    if (eMode === akra.EAFXBlendMode.k_Shared) {
                        if (!((((this)._pFieldDeclMap[(sFieldName)]) !== undefined))) {
                            pBlendField = pField.clone(pRelationMap);
                        }
                    } else if (eMode === akra.EAFXBlendMode.k_Attribute || eMode === akra.EAFXBlendMode.k_Uniform || eMode === akra.EAFXBlendMode.k_VertexOut) {
                        if (!this.hasFieldWithSematic(sFieldSemantic)) {
                            pBlendField = pField.clone(pRelationMap);
                            pBlendField.getNameId().setName(sFieldSemantic);
                            pBlendField.getNameId().setRealName(sFieldSemantic);
                        }
                    }
                    if (!((pBlendField) === null)) {
                        pBlendType.addField(pBlendField);
                    }
                }
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pBlendType.setName(((this)._sName));
                (pBlendType._sRealName = (((this)._sRealName)));
                return pBlendType;
            };
            ComplexTypeInstruction.prototype._setCloneName = function (sName, sRealName) {
                this._sName = sName;
                this._sRealName = sRealName;
            };
            ComplexTypeInstruction.prototype._setCloneHash = function (sHash, sStrongHash) {
                this._sHash = sHash;
                this._sStrongHash = sStrongHash;
            };
            ComplexTypeInstruction.prototype._setCloneContain = function (isContainArray, isContainSampler) {
                this._isContainArray = isContainArray;
                this._isContainSampler = isContainSampler;
            };
            ComplexTypeInstruction.prototype._setCloneFields = function (pFieldDeclList, pFieldNameList, pFieldDeclMap) {
                this._pFieldDeclList = pFieldDeclList;
                this._pFieldNameList = pFieldNameList;
                this._pFieldDeclMap = pFieldDeclMap;
            };
            ComplexTypeInstruction.prototype._calcSize = function () {
                var iSize = 0;
                for(var i = 0; i < this._pFieldDeclList.length; i++) {
                    var iFieldSize = this._pFieldDeclList[i].getType().getSize();
                    if (iFieldSize === 0xffffff) {
                        iSize = 0xffffff;
                        break;
                    } else {
                        iSize += iFieldSize;
                    }
                }
                return iSize;
            };
            ComplexTypeInstruction.prototype.calcHash = function () {
                var sHash = "{";
                for(var i = 0; i < this._pFieldDeclList.length; i++) {
                    sHash += this._pFieldDeclList[i].getType().getHash() + ";";
                }
                sHash += "}";
                this._sHash = sHash;
            };
            ComplexTypeInstruction.prototype.calcStrongHash = function () {
                var sStrongHash = "{";
                for(var i = 0; i < this._pFieldDeclList.length; i++) {
                    sStrongHash += this._pFieldDeclList[i].getType().getStrongHash() + ";";
                }
                sStrongHash += "}";
                this._sStrongHash = sStrongHash;
            };
            ComplexTypeInstruction.prototype.analyzeSemantics = function () {
                this._pFieldDeclBySemanticMap = {};
                for(var i = 0; i < this._pFieldDeclList.length; i++) {
                    var pVar = this._pFieldDeclList[i];
                    var sSemantic = pVar.getSemantic();
                    if (sSemantic === "") {
                        this._hasFieldWithoutSemantic = true;
                    }
                    if (((this._pFieldDeclBySemanticMap[sSemantic]) !== undefined)) {
                        this._hasAllUniqueSemantics = false;
                    }
                    this._pFieldDeclBySemanticMap[sSemantic] = pVar;
                    this._hasFieldWithoutSemantic = this._hasFieldWithoutSemantic || pVar.getType().hasFieldWithoutSemantic();
                    if (this._hasAllUniqueSemantics && pVar.getType().isComplex()) {
                        this._hasAllUniqueSemantics = pVar.getType().hasAllUniqueSemantics();
                    }
                }
            };
            ComplexTypeInstruction.prototype.calculatePaddings = function () {
                var iPadding = 0;
                for(var i = 0; i < this._pFieldDeclList.length; i++) {
                    var pVarType = this._pFieldDeclList[i].getType();
                    var iVarSize = pVarType.getSize();
                    if (iVarSize === 0xffffff) {
                        /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.setError(2272, {
                            typeName: ((this)._sName)
                        });
                        return;
                    }
                    pVarType.setPadding(iPadding);
                    iPadding += iVarSize;
                }
            };
            return ComplexTypeInstruction;
        })(fx.Instruction);
        fx.ComplexTypeInstruction = ComplexTypeInstruction;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        var ExprInstruction = (function (_super) {
            __extends(ExprInstruction, _super);
            /**
            * Respresent all kind of instruction
            */
            function ExprInstruction() {
                        _super.call(this);
                /**@protected*/ this._pLastEvalResult = null;
                this._eInstructionType = akra.EAFXInstructionTypes.k_ExprInstruction;
            }
            ExprInstruction.prototype.evaluate = function () {
                return false;
            };
            ExprInstruction.prototype.simplify = function () {
                return false;
            };
            ExprInstruction.prototype.getEvalValue = function () {
                return this._pLastEvalResult;
            };
            ExprInstruction.prototype.isConst = function () {
                return false;
            };
            ExprInstruction.prototype.getType = function () {
                return _super.prototype.getType.call(this);
            };
            ExprInstruction.prototype.clone = function (pRelationMap) {
                return _super.prototype.clone.call(this, pRelationMap);
            };
            ExprInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                var pInstructionList = ((this)._pInstructionList);
                if (((pInstructionList) === null)) {
                    return;
                }
                for(var i = 0; i < this._nInstructions; i++) {
                    pInstructionList[i].addUsedData(pUsedDataCollector, eUsedMode);
                }
            };
            return ExprInstruction;
        })(fx.TypedInstruction);
        fx.ExprInstruction = ExprInstruction;        
        var IntInstruction = (function (_super) {
            __extends(IntInstruction, _super);
            /**
            * EMPTY_OPERATOR EMPTY_ARGUMENTS
            */
            function IntInstruction() {
                        _super.call(this);
                this._iValue = 0;
                this._pType = ((/*checked (origin: fx)>>*/akra.fx.Effect.getSystemType("int"))._pWrapVariableType);
                this._eInstructionType = akra.EAFXInstructionTypes.k_IntInstruction;
            }
            IntInstruction.prototype.setValue = /** @inline */function (iValue) {
                this._iValue = iValue;
            };
            IntInstruction.prototype.toString = function () {
                return this._iValue;
            };
            IntInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                sCode += this._iValue.toString();
                return sCode;
            };
            IntInstruction.prototype.evaluate = function () {
                this._pLastEvalResult = this._iValue;
                return true;
            };
            IntInstruction.prototype.isConst = /** @inline */function () {
                return true;
            };
            IntInstruction.prototype.clone = function (pRelationMap) {
                var pClonedInstruction = (_super.prototype.clone.call(this, pRelationMap));
                pClonedInstruction.setValue(this._iValue);
                return pClonedInstruction;
            };
            return IntInstruction;
        })(ExprInstruction);
        fx.IntInstruction = IntInstruction;        
        var FloatInstruction = (function (_super) {
            __extends(FloatInstruction, _super);
            /**
            * EMPTY_OPERATOR EMPTY_ARGUMENTS
            */
            function FloatInstruction() {
                        _super.call(this);
                this._fValue = 0.0;
                this._pType = ((/*checked (origin: fx)>>*/akra.fx.Effect.getSystemType("float"))._pWrapVariableType);
                this._eInstructionType = akra.EAFXInstructionTypes.k_FloatInstruction;
            }
            FloatInstruction.prototype.setValue = /** @inline */function (fValue) {
                this._fValue = fValue;
            };
            FloatInstruction.prototype.toString = function () {
                return this._fValue;
            };
            FloatInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                sCode += this._fValue.toString();
                if (this._fValue % 1 === 0) {
                    sCode += ".";
                }
                return sCode;
            };
            FloatInstruction.prototype.evaluate = function () {
                this._pLastEvalResult = this._fValue;
                return true;
            };
            FloatInstruction.prototype.isConst = /** @inline */function () {
                return true;
            };
            FloatInstruction.prototype.clone = function (pRelationMap) {
                var pClonedInstruction = (_super.prototype.clone.call(this, pRelationMap));
                pClonedInstruction.setValue(this._fValue);
                return pClonedInstruction;
            };
            return FloatInstruction;
        })(ExprInstruction);
        fx.FloatInstruction = FloatInstruction;        
        var BoolInstruction = (function (_super) {
            __extends(BoolInstruction, _super);
            /**
            * EMPTY_OPERATOR EMPTY_ARGUMENTS
            */
            function BoolInstruction() {
                        _super.call(this);
                this._bValue = true;
                this._pType = ((/*checked (origin: fx)>>*/akra.fx.Effect.getSystemType("bool"))._pWrapVariableType);
                this._eInstructionType = akra.EAFXInstructionTypes.k_BoolInstruction;
            }
            BoolInstruction._pBoolType = null;
            BoolInstruction.prototype.setValue = /** @inline */function (bValue) {
                this._bValue = bValue;
            };
            BoolInstruction.prototype.toString = function () {
                return this._bValue;
            };
            BoolInstruction.prototype.toFinalCode = function () {
                if (this._bValue) {
                    return "true";
                } else {
                    return "false";
                }
            };
            BoolInstruction.prototype.evaluate = function () {
                this._pLastEvalResult = this._bValue;
                return true;
            };
            BoolInstruction.prototype.isConst = /** @inline */function () {
                return true;
            };
            BoolInstruction.prototype.clone = function (pRelationMap) {
                var pClonedInstruction = (_super.prototype.clone.call(this, pRelationMap));
                pClonedInstruction.setValue(this._bValue);
                return pClonedInstruction;
            };
            return BoolInstruction;
        })(ExprInstruction);
        fx.BoolInstruction = BoolInstruction;        
        var StringInstruction = (function (_super) {
            __extends(StringInstruction, _super);
            /**
            * EMPTY_OPERATOR EMPTY_ARGUMENTS
            */
            function StringInstruction() {
                        _super.call(this);
                this._sValue = "";
                this._pType = ((/*checked (origin: fx)>>*/akra.fx.Effect.getSystemType("string"))._pWrapVariableType);
                this._eInstructionType = akra.EAFXInstructionTypes.k_StringInstruction;
            }
            StringInstruction._pStringType = null;
            StringInstruction.prototype.setValue = /** @inline */function (sValue) {
                this._sValue = sValue;
            };
            StringInstruction.prototype.toString = function () {
                return this._sValue;
            };
            StringInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                sCode += this._sValue;
                return sCode;
            };
            StringInstruction.prototype.evaluate = function () {
                this._pLastEvalResult = this._sValue;
                return true;
            };
            StringInstruction.prototype.isConst = /** @inline */function () {
                return true;
            };
            StringInstruction.prototype.clone = function (pRelationMap) {
                var pClonedInstruction = (_super.prototype.clone.call(this, pRelationMap));
                pClonedInstruction.setValue(this._sValue);
                return pClonedInstruction;
            };
            return StringInstruction;
        })(ExprInstruction);
        fx.StringInstruction = StringInstruction;        
        var IdExprInstruction = (function (_super) {
            __extends(IdExprInstruction, _super);
            function IdExprInstruction() {
                        _super.call(this);
                this._pType = null;
                this._bToFinalCode = true;
                this._isInPassUnifoms = false;
                this._isInPassForeigns = false;
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_IdExprInstruction;
            }
            IdExprInstruction.prototype.isVisible = /** @inline */function () {
                return this._pInstructionList[0].isVisible();
            };
            IdExprInstruction.prototype.getType = function () {
                if (!((this._pType) === null)) {
                    return this._pType;
                } else {
                    var pVar = this._pInstructionList[0];
                    this._pType = ((pVar._pParentInstruction)).getType();
                    return this._pType;
                }
            };
            IdExprInstruction.prototype.isConst = function () {
                return this.getType().isConst();
            };
            IdExprInstruction.prototype.evaluate = function () {
                if (this.getType().isForeign()) {
                    var pVal = this.getType()._getParentVarDecl().getValue();
                    if (!((pVal) === null)) {
                        this._pLastEvalResult = pVal;
                        return true;
                    }
                }
                return false;
            };
            IdExprInstruction.prototype.prepareFor = function (eUsedMode) {
                if (!((this)._pInstructionList[0].isVisible())) {
                    this._bToFinalCode = false;
                }
                if (eUsedMode === akra.EFunctionType.k_PassFunction) {
                    var pVarDecl = ((this)._pInstructionList)[0].getParent();
                    if (!this.getType()._isUnverifiable() && ((pVarDecl.getParent()) === null)) {
                        if (pVarDecl.getType().isForeign()) {
                            this._isInPassForeigns = true;
                        } else {
                            this._isInPassUnifoms = true;
                        }
                    }
                }
            };
            IdExprInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                if (this._bToFinalCode) {
                    if (this._isInPassForeigns) {
                        sCode += "foreigns[\"" + ((this)._pInstructionList)[0].toFinalCode() + "\"]";
                    } else if (this._isInPassUnifoms) {
                        sCode += "uniforms[\"" + ((this)._pInstructionList)[0].toFinalCode() + "\"]";
                    } else {
                        sCode += ((this)._pInstructionList)[0].toFinalCode();
                    }
                }
                return sCode;
            };
            IdExprInstruction.prototype.clone = function (pRelationMap) {
                return _super.prototype.clone.call(this, pRelationMap);
            };
            IdExprInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                if (!this.getType().isFromVariableDecl()) {
                    return;
                }
                var pInfo = null;
                pInfo = pUsedDataCollector[this.getType()._getInstructionID()];
                if (!((pInfo) !== undefined)) {
                    pInfo = {
                        type: this.getType(),
                        isRead: false,
                        isWrite: false,
                        numRead: 0,
                        numWrite: 0,
                        numUsed: 0
                    };
                    pUsedDataCollector[this.getType()._getInstructionID()] = pInfo;
                }
                if (eUsedMode !== akra.EVarUsedMode.k_Write && eUsedMode !== akra.EVarUsedMode.k_Undefined) {
                    pInfo.isRead = true;
                    pInfo.numRead++;
                }
                if (eUsedMode === akra.EVarUsedMode.k_Write || eUsedMode === akra.EVarUsedMode.k_ReadWrite) {
                    pInfo.isWrite = true;
                    pInfo.numWrite++;
                }
                pInfo.numUsed++;
            };
            return IdExprInstruction;
        })(ExprInstruction);
        fx.IdExprInstruction = IdExprInstruction;        
        /**
        * Represent someExpr + / - * % someExpr
        * (+|-|*|/|%) Instruction Instruction
        */
        var ArithmeticExprInstruction = (function (_super) {
            __extends(ArithmeticExprInstruction, _super);
            function ArithmeticExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_ArithmeticExprInstruction;
            }
            ArithmeticExprInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                _super.prototype.addUsedData.call(this, pUsedDataCollector, akra.EVarUsedMode.k_Read);
            };
            ArithmeticExprInstruction.prototype.evaluate = function () {
                var pOperands = ((this)._pInstructionList);
                var pValL = pOperands[0].evaluate() ? pOperands[0].getEvalValue() : null;
                var pValR = pOperands[1].evaluate() ? pOperands[1].getEvalValue() : null;
                if (((pValL) === null) || ((pValR) === null)) {
                    return false;
                }
                try  {
                    switch(((this)._sOperatorName)) {
                        case "+":
                            this._pLastEvalResult = pValL + pValR;
                            break;
                        case "-":
                            this._pLastEvalResult = pValL - pValR;
                            break;
                        case "*":
                            this._pLastEvalResult = pValL * pValR;
                            break;
                        case "/":
                            this._pLastEvalResult = pValL / pValR;
                            break;
                        case "%":
                            this._pLastEvalResult = pValL % pValR;
                            break;
                    }
                    return true;
                } catch (e) {
                    return false;
                }
            };
            ArithmeticExprInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                sCode += ((this)._pInstructionList)[0].toFinalCode();
                sCode += ((this)._sOperatorName);
                sCode += ((this)._pInstructionList)[1].toFinalCode();
                return sCode;
            };
            ArithmeticExprInstruction.prototype.isConst = function () {
                var pOperands = ((this)._pInstructionList);
                return pOperands[0].isConst() && pOperands[1].isConst();
            };
            return ArithmeticExprInstruction;
        })(ExprInstruction);
        fx.ArithmeticExprInstruction = ArithmeticExprInstruction;        
        /**
        * Represent someExpr = += -= /= *= %= someExpr
        * (=|+=|-=|*=|/=|%=) Instruction Instruction
        */
        var AssignmentExprInstruction = (function (_super) {
            __extends(AssignmentExprInstruction, _super);
            function AssignmentExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_AssignmentExprInstruction;
            }
            AssignmentExprInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                sCode += ((this)._pInstructionList)[0].toFinalCode();
                sCode += ((this)._sOperatorName);
                sCode += ((this)._pInstructionList)[1].toFinalCode();
                return sCode;
            };
            AssignmentExprInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                var sOperator = ((this)._sOperatorName);
                var pSubExprLeft = ((this)._pInstructionList)[0];
                var pSubExprRight = ((this)._pInstructionList)[1];
                if (eUsedMode === akra.EVarUsedMode.k_Read || sOperator !== "=") {
                    pSubExprLeft.addUsedData(pUsedDataCollector, akra.EVarUsedMode.k_ReadWrite);
                } else {
                    pSubExprLeft.addUsedData(pUsedDataCollector, akra.EVarUsedMode.k_Write);
                }
                pSubExprRight.addUsedData(pUsedDataCollector, akra.EVarUsedMode.k_Read);
            };
            return AssignmentExprInstruction;
        })(ExprInstruction);
        fx.AssignmentExprInstruction = AssignmentExprInstruction;        
        /**
        * Represent someExpr == != < > <= >= someExpr
        * (==|!=|<|>|<=|>=) Instruction Instruction
        */
        var RelationalExprInstruction = (function (_super) {
            __extends(RelationalExprInstruction, _super);
            function RelationalExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_RelationalExprInstruction;
            }
            RelationalExprInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                sCode += ((this)._pInstructionList)[0].toFinalCode();
                sCode += ((this)._sOperatorName);
                sCode += ((this)._pInstructionList)[1].toFinalCode();
                return sCode;
            };
            RelationalExprInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                _super.prototype.addUsedData.call(this, pUsedDataCollector, akra.EVarUsedMode.k_Read);
            };
            RelationalExprInstruction.prototype.isConst = function () {
                return (((this)._pInstructionList)[0]).isConst() && (((this)._pInstructionList)[1]).isConst();
            };
            return RelationalExprInstruction;
        })(ExprInstruction);
        fx.RelationalExprInstruction = RelationalExprInstruction;        
        /**
        * Represent boolExpr && || boolExpr
        * (&& | ||) Instruction Instruction
        */
        var LogicalExprInstruction = (function (_super) {
            __extends(LogicalExprInstruction, _super);
            function LogicalExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_LogicalExprInstruction;
            }
            LogicalExprInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                sCode += ((this)._pInstructionList)[0].toFinalCode();
                sCode += ((this)._sOperatorName);
                sCode += ((this)._pInstructionList)[1].toFinalCode();
                return sCode;
            };
            LogicalExprInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                _super.prototype.addUsedData.call(this, pUsedDataCollector, akra.EVarUsedMode.k_Read);
            };
            LogicalExprInstruction.prototype.isConst = function () {
                return (((this)._pInstructionList)[0]).isConst() && (((this)._pInstructionList)[1]).isConst() && (((this)._pInstructionList)[2]).isConst();
            };
            return LogicalExprInstruction;
        })(ExprInstruction);
        fx.LogicalExprInstruction = LogicalExprInstruction;        
        /**
        * Represen boolExpr ? someExpr : someExpr
        * EMPTY_OPERATOR Instruction Instruction Instruction
        */
        var ConditionalExprInstruction = (function (_super) {
            __extends(ConditionalExprInstruction, _super);
            function ConditionalExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null, 
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_ConditionalExprInstruction;
            }
            ConditionalExprInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                sCode += ((this)._pInstructionList)[0].toFinalCode();
                sCode += "?";
                sCode += ((this)._pInstructionList)[1].toFinalCode();
                sCode += ":";
                sCode += ((this)._pInstructionList)[2].toFinalCode();
                return sCode;
            };
            ConditionalExprInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                _super.prototype.addUsedData.call(this, pUsedDataCollector, akra.EVarUsedMode.k_Read);
            };
            ConditionalExprInstruction.prototype.isConst = function () {
                return (((this)._pInstructionList)[0]).isConst() && (((this)._pInstructionList)[1]).isConst();
            };
            return ConditionalExprInstruction;
        })(ExprInstruction);
        fx.ConditionalExprInstruction = ConditionalExprInstruction;        
        /**
        * Represent (type) expr
        * EMPTY_OPERATOR VariableTypeInstruction Instruction
        */
        var CastExprInstruction = (function (_super) {
            __extends(CastExprInstruction, _super);
            function CastExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_CastExprInstruction;
            }
            CastExprInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                sCode += ((this)._pInstructionList)[0].toFinalCode();
                sCode += "(";
                sCode += ((this)._pInstructionList)[1].toFinalCode();
                sCode += ")";
                return sCode;
            };
            CastExprInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                var pSubExpr = ((this)._pInstructionList)[1];
                pSubExpr.addUsedData(pUsedDataCollector, akra.EVarUsedMode.k_Read);
                // pUsedDataCollector[this.getType()._getInstructionID()] = this.getType();
                            };
            CastExprInstruction.prototype.isConst = function () {
                return (((this)._pInstructionList)[1]).isConst();
            };
            return CastExprInstruction;
        })(ExprInstruction);
        fx.CastExprInstruction = CastExprInstruction;        
        /**
        * Represent + - ! ++ -- expr
        * (+|-|!|++|--|) Instruction
        */
        var UnaryExprInstruction = (function (_super) {
            __extends(UnaryExprInstruction, _super);
            function UnaryExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_UnaryExprInstruction;
            }
            UnaryExprInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                sCode += ((this)._sOperatorName);
                sCode += ((this)._pInstructionList)[0].toFinalCode();
                return sCode;
            };
            UnaryExprInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                if (((this)._sOperatorName) === "++" || ((this)._sOperatorName) === "--") {
                    (((this)._pInstructionList)[0]).addUsedData(pUsedDataCollector, akra.EVarUsedMode.k_ReadWrite);
                } else {
                    (((this)._pInstructionList)[0]).addUsedData(pUsedDataCollector, akra.EVarUsedMode.k_Read);
                }
            };
            UnaryExprInstruction.prototype.isConst = function () {
                return (((this)._pInstructionList)[0]).isConst();
            };
            UnaryExprInstruction.prototype.evaluate = function () {
                var sOperator = ((this)._sOperatorName);
                var pExpr = ((this)._pInstructionList)[0];
                if (!pExpr.evaluate()) {
                    return;
                }
                var pRes = null;
                try  {
                    pRes = pExpr.getEvalValue();
                    switch(sOperator) {
                        case "+":
                            pRes = +pRes;
                            break;
                        case "-":
                            pRes = -pRes;
                            break;
                        case "!":
                            pRes = !pRes;
                            break;
                        case "++":
                            pRes = ++pRes;
                            break;
                        case "--":
                            pRes = --pRes;
                            break;
                    }
                } catch (e) {
                    return false;
                }
                this._pLastEvalResult = pRes;
                return true;
            };
            return UnaryExprInstruction;
        })(ExprInstruction);
        fx.UnaryExprInstruction = UnaryExprInstruction;        
        /**
        * Represent someExpr[someIndex]
        * EMPTY_OPERATOR Instruction ExprInstruction
        */
        var PostfixIndexInstruction = (function (_super) {
            __extends(PostfixIndexInstruction, _super);
            function PostfixIndexInstruction() {
                        _super.call(this);
                this._pSamplerArrayDecl = null;
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_PostfixIndexInstruction;
            }
            PostfixIndexInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                // if((<ExprInstruction>this.getInstructions()[0]).getType().getLength() === 0){
                // 	return "";
                // }
                if (!((this._pSamplerArrayDecl) === null) && this._pSamplerArrayDecl.isDefinedByZero()) {
                    sCode += ((this)._pInstructionList)[0].toFinalCode();
                } else {
                    sCode += ((this)._pInstructionList)[0].toFinalCode();
                    if (!(((this)._pInstructionList)[0]).getType()._isCollapsed()) {
                        sCode += "[" + ((this)._pInstructionList)[1].toFinalCode() + "]";
                    }
                }
                return sCode;
            };
            PostfixIndexInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                var pSubExpr = ((this)._pInstructionList)[0];
                var pIndex = ((this)._pInstructionList)[1];
                pSubExpr.addUsedData(pUsedDataCollector, eUsedMode);
                pIndex.addUsedData(pUsedDataCollector, akra.EVarUsedMode.k_Read);
                if (pSubExpr.getType().isFromVariableDecl() && pSubExpr.getType().isSampler()) {
                    this._pSamplerArrayDecl = pSubExpr.getType()._getParentVarDecl();
                }
            };
            PostfixIndexInstruction.prototype.isConst = function () {
                return (((this)._pInstructionList)[0]).isConst() && (((this)._pInstructionList)[1]).isConst();
            };
            return PostfixIndexInstruction;
        })(ExprInstruction);
        fx.PostfixIndexInstruction = PostfixIndexInstruction;        
        /*
        * Represent someExpr.id
        * EMPTY_OPERATOR Instruction IdInstruction
        */
        var PostfixPointInstruction = (function (_super) {
            __extends(PostfixPointInstruction, _super);
            function PostfixPointInstruction() {
                        _super.call(this);
                this._bToFinalFirst = true;
                this._bToFinalSecond = true;
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_PostfixPointInstruction;
            }
            PostfixPointInstruction.prototype.prepareFor = function (eUsedMode) {
                if (!((this)._pInstructionList)[0].isVisible()) {
                    this._bToFinalFirst = false;
                }
                if (!((this)._pInstructionList)[1].isVisible()) {
                    this._bToFinalSecond = false;
                }
                ((this)._pInstructionList)[0].prepareFor(eUsedMode);
                ((this)._pInstructionList)[1].prepareFor(eUsedMode);
            };
            PostfixPointInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                sCode += this._bToFinalFirst ? ((this)._pInstructionList)[0].toFinalCode() : "";
                sCode += this._bToFinalFirst ? "." : "";
                sCode += this._bToFinalSecond ? ((this)._pInstructionList)[1].toFinalCode() : "";
                return sCode;
            };
            PostfixPointInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                var pSubExpr = ((this)._pInstructionList)[0];
                var pPoint = ((this)._pInstructionList)[1];
                pSubExpr.addUsedData(pUsedDataCollector, akra.EVarUsedMode.k_Undefined);
                pPoint.addUsedData(pUsedDataCollector, eUsedMode);
            };
            PostfixPointInstruction.prototype.isConst = function () {
                return (((this)._pInstructionList)[0]).isConst();
            };
            return PostfixPointInstruction;
        })(ExprInstruction);
        fx.PostfixPointInstruction = PostfixPointInstruction;        
        /**
        * Represent someExpr ++
        * (-- | ++) Instruction
        */
        var PostfixArithmeticInstruction = (function (_super) {
            __extends(PostfixArithmeticInstruction, _super);
            function PostfixArithmeticInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_PostfixArithmeticInstruction;
            }
            PostfixArithmeticInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                sCode += ((this)._pInstructionList)[0].toFinalCode();
                sCode += ((this)._sOperatorName);
                return sCode;
            };
            PostfixArithmeticInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                var pSubExpr = ((this)._pInstructionList)[0];
                pSubExpr.addUsedData(pUsedDataCollector, akra.EVarUsedMode.k_ReadWrite);
            };
            PostfixArithmeticInstruction.prototype.isConst = function () {
                return (((this)._pInstructionList)[0]).isConst();
            };
            return PostfixArithmeticInstruction;
        })(ExprInstruction);
        fx.PostfixArithmeticInstruction = PostfixArithmeticInstruction;        
        /**
        * Represent @ Expr
        * @ Instruction
        */
        var PrimaryExprInstruction = (function (_super) {
            __extends(PrimaryExprInstruction, _super);
            function PrimaryExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_PrimaryExprInstruction;
            }
            PrimaryExprInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                sCode += ((this)._pInstructionList)[0].toFinalCode();
                return sCode;
            };
            PrimaryExprInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                var pPointerType = this.getType();
                var pInfo = pUsedDataCollector[pPointerType._getInstructionID()];
                if (!((pInfo) !== undefined)) {
                    pInfo = {
                        type: pPointerType,
                        isRead: false,
                        isWrite: false,
                        numRead: 0,
                        numWrite: 0,
                        numUsed: 0
                    };
                    pUsedDataCollector[pPointerType._getInstructionID()] = pInfo;
                }
                if (eUsedMode === akra.EVarUsedMode.k_Read) {
                    pInfo.isRead = true;
                    pInfo.numRead++;
                } else if (eUsedMode === akra.EVarUsedMode.k_Write) {
                    pInfo.isWrite = true;
                    pInfo.numWrite++;
                } else if (eUsedMode === akra.EVarUsedMode.k_ReadWrite) {
                    pInfo.isRead = true;
                    pInfo.isWrite = true;
                    pInfo.numRead++;
                    pInfo.numWrite++;
                }
                pInfo.numUsed++;
            };
            return PrimaryExprInstruction;
        })(ExprInstruction);
        fx.PrimaryExprInstruction = PrimaryExprInstruction;        
        /**
        * Represent (expr)
        * EMPTY_OPERATOR ExprInstruction
        */
        var ComplexExprInstruction = (function (_super) {
            __extends(ComplexExprInstruction, _super);
            function ComplexExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_ComplexExprInstruction;
            }
            ComplexExprInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                sCode += "(" + ((this)._pInstructionList)[0].toFinalCode() + ")";
                return sCode;
            };
            ComplexExprInstruction.prototype.isConst = function () {
                return (((this)._pInstructionList)[0]).isConst();
            };
            ComplexExprInstruction.prototype.evaluate = function () {
                if ((((this)._pInstructionList)[0]).evaluate()) {
                    this._pLastEvalResult = (((this)._pInstructionList)[0]).getEvalValue();
                    return true;
                } else {
                    return false;
                }
            };
            return ComplexExprInstruction;
        })(ExprInstruction);
        fx.ComplexExprInstruction = ComplexExprInstruction;        
        // addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
        //                   eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
        // 	var pSubExpr: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[0];
        // 	pSubExpr.addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
        // }
        /**
        * Respresnt func(arg1,..., argn)
        * EMPTY_OPERATOR IdExprInstruction ExprInstruction ... ExprInstruction
        */
        var FunctionCallInstruction = (function (_super) {
            __extends(FunctionCallInstruction, _super);
            function FunctionCallInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_FunctionCallInstruction;
            }
            FunctionCallInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                sCode += ((this)._pInstructionList)[0].toFinalCode();
                sCode += "(";
                for(var i = 1; i < this._nInstructions; i++) {
                    sCode += ((this)._pInstructionList)[i].toFinalCode();
                    if (i !== this._nInstructions - 1) {
                        sCode += ",";
                    }
                }
                sCode += ")";
                return sCode;
            };
            FunctionCallInstruction.prototype.getFunction = function () {
                return (this._pInstructionList[0]).getType().getParent().getParent();
            };
            FunctionCallInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                var pExprList = ((this)._pInstructionList);
                var pFunction = this.getFunction();
                var pArguments = pFunction.getArguments();
                pExprList[0].addUsedData(pUsedDataCollector, eUsedMode);
                for(var i = 0; i < pArguments.length; i++) {
                    if (pArguments[i].getType().hasUsage("out")) {
                        pExprList[i + 1].addUsedData(pUsedDataCollector, akra.EVarUsedMode.k_Write);
                    } else if (pArguments[i].getType().hasUsage("inout")) {
                        pExprList[i + 1].addUsedData(pUsedDataCollector, akra.EVarUsedMode.k_ReadWrite);
                    } else {
                        pExprList[i + 1].addUsedData(pUsedDataCollector, akra.EVarUsedMode.k_Read);
                    }
                }
            };
            return FunctionCallInstruction;
        })(ExprInstruction);
        fx.FunctionCallInstruction = FunctionCallInstruction;        
        /**
        * Respresnt system_func(arg1,..., argn)
        * EMPTY_OPERATOR SimpleInstruction ... SimpleInstruction
        */
        var SystemCallInstruction = (function (_super) {
            __extends(SystemCallInstruction, _super);
            function SystemCallInstruction() {
                        _super.call(this);
                this._pSystemFunction = null;
                this._pSamplerDecl = null;
                this._pInstructionList = null;
                this._eInstructionType = akra.EAFXInstructionTypes.k_SystemCallInstruction;
            }
            SystemCallInstruction.prototype.toFinalCode = function () {
                if (!((this._pSamplerDecl) === null) && this._pSamplerDecl.isDefinedByZero()) {
                    return "vec4(0.)";
                }
                var sCode = "";
                for(var i = 0; i < ((this)._pInstructionList).length; i++) {
                    sCode += ((this)._pInstructionList)[i].toFinalCode();
                }
                return sCode;
            };
            SystemCallInstruction.prototype.setSystemCallFunction = function (pFunction) {
                this._pSystemFunction = pFunction;
                this.setType(pFunction.getType());
            };
            SystemCallInstruction.prototype.setInstructions = function (pInstructionList) {
                this._pInstructionList = pInstructionList;
                this._nInstructions = pInstructionList.length;
                for(var i = 0; i < pInstructionList.length; i++) {
                    pInstructionList[i].setParent(this);
                }
            };
            SystemCallInstruction.prototype.fillByArguments = function (pArguments) {
                this.setInstructions(this._pSystemFunction.closeArguments(pArguments));
            };
            SystemCallInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                var pInstructionList = ((this)._pInstructionList);
                for(var i = 0; i < this._nInstructions; i++) {
                    if (pInstructionList[i]._getInstructionType() !== akra.EAFXInstructionTypes.k_SimpleInstruction) {
                        pInstructionList[i].addUsedData(pUsedDataCollector, akra.EVarUsedMode.k_Read);
                        if ((pInstructionList[i]).getType().isSampler()) {
                            this._pSamplerDecl = (pInstructionList[i]).getType()._getParentVarDecl();
                        }
                    }
                }
            };
            SystemCallInstruction.prototype.clone = function (pRelationMap) {
                var pClone = _super.prototype.clone.call(this, pRelationMap);
                pClone.setSystemCallFunction(this._pSystemFunction);
                return pClone;
            };
            return SystemCallInstruction;
        })(ExprInstruction);
        fx.SystemCallInstruction = SystemCallInstruction;        
        /**
        * Respresnt ctor(arg1,..., argn)
        * EMPTY_OPERATOR IdInstruction ExprInstruction ... ExprInstruction
        */
        var ConstructorCallInstruction = (function (_super) {
            __extends(ConstructorCallInstruction, _super);
            function ConstructorCallInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_ConstructorCallInstruction;
            }
            ConstructorCallInstruction.prototype.toFinalCode = // isConst
            function () {
                var sCode = "";
                sCode += ((this)._pInstructionList)[0].toFinalCode();
                sCode += "(";
                for(var i = 1; i < this._nInstructions; i++) {
                    sCode += ((this)._pInstructionList)[i].toFinalCode();
                    if (i !== this._nInstructions - 1) {
                        sCode += ",";
                    }
                }
                sCode += ")";
                return sCode;
            };
            ConstructorCallInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                var pInstructionList = ((this)._pInstructionList);
                for(var i = 1; i < this._nInstructions; i++) {
                    pInstructionList[i].addUsedData(pUsedDataCollector, akra.EVarUsedMode.k_Read);
                }
            };
            ConstructorCallInstruction.prototype.isConst = function () {
                for(var i = 1; i < this._nInstructions; i++) {
                    if (!(((this)._pInstructionList)[i]).isConst()) {
                        return false;
                    }
                }
                return true;
            };
            ConstructorCallInstruction.prototype.evaluate = function () {
                if (!this.isConst()) {
                    return false;
                }
                var pRes = null;
                var pJSTypeCtor = fx.Effect.getExternalType(this.getType());
                var pArguments = new Array(this._nInstructions - 1);
                if (((pJSTypeCtor) === null)) {
                    return false;
                }
                try  {
                    if (fx.Effect.isScalarType(this.getType())) {
                        var pTestedInstruction = ((this)._pInstructionList)[1];
                        if (this._nInstructions > 2 || !pTestedInstruction.evaluate()) {
                            return false;
                        }
                        pRes = pJSTypeCtor(pTestedInstruction.getEvalValue());
                    } else {
                        for(var i = 1; i < this._nInstructions; i++) {
                            var pTestedInstruction = ((this)._pInstructionList)[i];
                            if (pTestedInstruction.evaluate()) {
                                pArguments[i - 1] = pTestedInstruction.getEvalValue();
                            } else {
                                return false;
                            }
                        }
                        pRes = new pJSTypeCtor();
                        pRes.set.apply(pRes, pArguments);
                    }
                } catch (e) {
                    return false;
                }
                this._pLastEvalResult = pRes;
                return true;
            };
            return ConstructorCallInstruction;
        })(ExprInstruction);
        fx.ConstructorCallInstruction = ConstructorCallInstruction;        
        /**
        * Represetn compile vs_func(...args)
        * compile IdExprInstruction ExprInstruction ... ExprInstruction
        */
        var CompileExprInstruction = (function (_super) {
            __extends(CompileExprInstruction, _super);
            function CompileExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_CompileExprInstruction;
            }
            CompileExprInstruction.prototype.getFunction = /** @inline */function () {
                return this._pInstructionList[0].getParent().getParent();
            };
            return CompileExprInstruction;
        })(ExprInstruction);
        fx.CompileExprInstruction = CompileExprInstruction;        
        var MemExprInstruction = (function (_super) {
            __extends(MemExprInstruction, _super);
            function MemExprInstruction() {
                        _super.call(this);
                this._pBuffer = null;
                this._pInstructionList = null;
                this._eInstructionType = akra.EAFXInstructionTypes.k_MemExprInstruction;
            }
            MemExprInstruction.prototype.getBuffer = function () {
                return this._pBuffer;
            };
            MemExprInstruction.prototype.setBuffer = function (pBuffer) {
                this._pBuffer = pBuffer;
                this.setType(pBuffer.getType());
            };
            MemExprInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                var pBufferType = this.getBuffer().getType();
                var pInfo = pUsedDataCollector[pBufferType._getInstructionID()];
                if (!((pInfo) !== undefined)) {
                    pInfo = {
                        type: pBufferType,
                        isRead: false,
                        isWrite: false,
                        numRead: 0,
                        numWrite: 0,
                        numUsed: 0
                    };
                    pUsedDataCollector[pBufferType._getInstructionID()] = pInfo;
                }
                if (eUsedMode !== akra.EVarUsedMode.k_Undefined) {
                    pInfo.isRead = true;
                    pInfo.numRead++;
                }
                pInfo.numUsed++;
            };
            return MemExprInstruction;
        })(ExprInstruction);
        fx.MemExprInstruction = MemExprInstruction;        
        var InitExprInstruction = (function (_super) {
            __extends(InitExprInstruction, _super);
            function InitExprInstruction() {
                        _super.call(this);
                this._pConstructorType = null;
                this._isConst = null;
                this._isArray = false;
                this._pInstructionList = [];
                this._eInstructionType = akra.EAFXInstructionTypes.k_InitExprInstruction;
            }
            InitExprInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                if (!((this._pConstructorType) === null)) {
                    sCode += this._pConstructorType.toFinalCode();
                }
                sCode += "(";
                for(var i = 0; i < this._nInstructions; i++) {
                    sCode += ((this)._pInstructionList)[i].toFinalCode();
                    if (i !== this._nInstructions - 1) {
                        sCode += ",";
                    }
                }
                sCode += ")";
                return sCode;
            };
            InitExprInstruction.prototype.isConst = function () {
                if (((this._isConst) === null)) {
                    var pInstructionList = ((this)._pInstructionList);
                    for(var i = 0; i < pInstructionList.length; i++) {
                        if (!pInstructionList[i].isConst()) {
                            this._isConst = false;
                            break;
                        }
                    }
                    this._isConst = ((this._isConst) === null) ? true : false;
                }
                return this._isConst;
            };
            InitExprInstruction.prototype.optimizeForVariableType = function (pType) {
                if ((pType.isNotBaseArray() && pType._getScope() === 0) || (pType.isArray() && this._nInstructions > 1)) {
                    if (pType.getLength() === 0xffffff || (pType.isNotBaseArray() && this._nInstructions !== pType.getLength()) || (!pType.isNotBaseArray() && this._nInstructions !== pType.getBaseType().getLength())) {
                        return false;
                    }
                    if (pType.isNotBaseArray()) {
                        this._isArray = true;
                    }
                    var pArrayElementType = pType.getArrayElementType();
                    var pTestedInstruction = null;
                    var isOk = false;
                    for(var i = 0; i < this._nInstructions; i++) {
                        pTestedInstruction = (((this)._pInstructionList)[i]);
                        if (pTestedInstruction._getInstructionType() === akra.EAFXInstructionTypes.k_InitExprInstruction) {
                            isOk = (pTestedInstruction).optimizeForVariableType(pArrayElementType);
                            if (!isOk) {
                                return false;
                            }
                        } else {
                            if (fx.Effect.isSamplerType(pArrayElementType)) {
                                if (pTestedInstruction._getInstructionType() !== akra.EAFXInstructionTypes.k_SamplerStateBlockInstruction) {
                                    return false;
                                }
                            } else {
                                isOk = pTestedInstruction.getType().isEqual(pArrayElementType);
                                if (!isOk) {
                                    return false;
                                }
                            }
                        }
                    }
                    this._pConstructorType = pType.getBaseType();
                    return true;
                } else {
                    var pFirstInstruction = ((this)._pInstructionList)[0];
                    if (this._nInstructions === 1 && pFirstInstruction._getInstructionType() !== akra.EAFXInstructionTypes.k_InitExprInstruction) {
                        if (fx.Effect.isSamplerType(pType)) {
                            if (pFirstInstruction._getInstructionType() === akra.EAFXInstructionTypes.k_SamplerStateBlockInstruction) {
                                return true;
                            } else {
                                return false;
                            }
                        }
                        if (pFirstInstruction.getType().isEqual(pType)) {
                            return true;
                        } else {
                            return false;
                        }
                    } else if (this._nInstructions === 1) {
                        return false;
                    }
                    var pInstructionList = ((this)._pInstructionList);
                    var pFieldNameList = pType.getFieldNameList();
                    for(var i = 0; i < pInstructionList.length; i++) {
                        var pFieldType = pType.getFieldType(pFieldNameList[i]);
                        if (!pInstructionList[i].optimizeForVariableType(pFieldType)) {
                            return false;
                        }
                    }
                    this._pConstructorType = pType.getBaseType();
                    return true;
                }
            };
            InitExprInstruction.prototype.evaluate = function () {
                if (!this.isConst()) {
                    this._pLastEvalResult = null;
                    return false;
                }
                var pRes = null;
                if (this._isArray) {
                    pRes = new Array(this._nInstructions);
                    for(var i = 0; i < this._nInstructions; i++) {
                        var pEvalInstruction = (((this)._pInstructionList)[i]);
                        if (pEvalInstruction.evaluate()) {
                            pRes[i] = pEvalInstruction.getEvalValue();
                        }
                    }
                } else if (this._nInstructions === 1) {
                    var pEvalInstruction = (((this)._pInstructionList)[0]);
                    pEvalInstruction.evaluate();
                    pRes = pEvalInstruction.getEvalValue();
                } else {
                    var pJSTypeCtor = fx.Effect.getExternalType(this._pConstructorType);
                    var pArguments = new Array(this._nInstructions);
                    if (((pJSTypeCtor) === null)) {
                        return false;
                    }
                    try  {
                        if (fx.Effect.isScalarType(this._pConstructorType)) {
                            var pTestedInstruction = ((this)._pInstructionList)[1];
                            if (this._nInstructions > 2 || !pTestedInstruction.evaluate()) {
                                return false;
                            }
                            pRes = pJSTypeCtor(pTestedInstruction.getEvalValue());
                        } else {
                            for(var i = 0; i < this._nInstructions; i++) {
                                var pTestedInstruction = ((this)._pInstructionList)[i];
                                if (pTestedInstruction.evaluate()) {
                                    pArguments[i] = pTestedInstruction.getEvalValue();
                                } else {
                                    return false;
                                }
                            }
                            pRes = new pJSTypeCtor();
                            pRes.set.apply(pRes, pArguments);
                        }
                    } catch (e) {
                        return false;
                    }
                }
                this._pLastEvalResult = pRes;
                return true;
            };
            return InitExprInstruction;
        })(ExprInstruction);
        fx.InitExprInstruction = InitExprInstruction;        
        /**
        * Represetn sampler_state { states }
        */
        var SamplerStateBlockInstruction = (function (_super) {
            __extends(SamplerStateBlockInstruction, _super);
            function SamplerStateBlockInstruction() {
                        _super.call(this);
                this._pTexture = null;
                this._pSamplerParams = null;
                this._pInstructionList = null;
                this._eInstructionType = akra.EAFXInstructionTypes.k_SamplerStateBlockInstruction;
            }
            SamplerStateBlockInstruction.prototype.addState = function (sStateType, sStateValue) {
                if (((this._pSamplerParams) === null)) {
                    this._pSamplerParams = {};
                }
                this._pSamplerParams[sStateType] = sStateValue;
                return;
            };
            SamplerStateBlockInstruction.prototype.setTexture = function (pTexture) {
                this._pTexture = pTexture;
            };
            SamplerStateBlockInstruction.prototype.getTexture = /** @inline */function () {
                return this._pTexture;
            };
            SamplerStateBlockInstruction.prototype.isConst = /** @inline */function () {
                return true;
            };
            SamplerStateBlockInstruction.prototype.evaluate = function () {
                var pSamplerState = {
                    texture: null,
                    textureName: "",
                    wrap_s: 0,
                    wrap_t: 0,
                    mag_filter: 0,
                    min_filter: 0
                };
                if (!((this._pTexture) === null)) {
                    pSamplerState.textureName = this._pTexture.getRealName();
                }
                if (!((this._pSamplerParams) === null)) {
                    if (((this._pSamplerParams["ADDRESSU"]) !== undefined)) {
                        pSamplerState.wrap_s = SamplerStateBlockInstruction.convertWrapMode(this._pSamplerParams["ADDRESSU"]);
                    }
                    if (((this._pSamplerParams["ADDRESSV"]) !== undefined)) {
                        pSamplerState.wrap_t = SamplerStateBlockInstruction.convertWrapMode(this._pSamplerParams["ADDRESSV"]);
                    }
                    if (((this._pSamplerParams["MAGFILTER"]) !== undefined)) {
                        pSamplerState.mag_filter = SamplerStateBlockInstruction.convertFilters(this._pSamplerParams["MAGFILTER"]);
                    }
                    if (((this._pSamplerParams["MINFILTER"]) !== undefined)) {
                        pSamplerState.min_filter = SamplerStateBlockInstruction.convertFilters(this._pSamplerParams["MINFILTER"]);
                    }
                }
                this._pLastEvalResult = pSamplerState;
                return true;
            };
            SamplerStateBlockInstruction.convertWrapMode = function convertWrapMode(sState) {
                switch(sState) {
                    case "WRAP":
                        return akra.ETextureWrapModes.REPEAT;
                    case "CLAMP":
                        return akra.ETextureWrapModes.CLAMP_TO_EDGE;
                    case "MIRROR":
                        return akra.ETextureWrapModes.MIRRORED_REPEAT;
                    default:
                        return 0;
                }
            };
            SamplerStateBlockInstruction.convertFilters = function convertFilters(sState) {
                switch(sState) {
                    case "NEAREST":
                        return akra.ETextureFilters.NEAREST;
                    case "LINEAR":
                        return akra.ETextureFilters.LINEAR;
                    case "NEAREST_MIPMAP_NEAREST":
                        return akra.ETextureFilters.NEAREST_MIPMAP_NEAREST;
                    case "LINEAR_MIPMAP_NEAREST":
                        return akra.ETextureFilters.LINEAR_MIPMAP_NEAREST;
                    case "NEAREST_MIPMAP_LINEAR":
                        return akra.ETextureFilters.NEAREST_MIPMAP_LINEAR;
                    case "LINEAR_MIPMAP_LINEAR":
                        return akra.ETextureFilters.LINEAR_MIPMAP_LINEAR;
                    default:
                        return 0;
                }
            };
            return SamplerStateBlockInstruction;
        })(ExprInstruction);
        fx.SamplerStateBlockInstruction = SamplerStateBlockInstruction;        
        var ExtractExprInstruction = (function (_super) {
            __extends(ExtractExprInstruction, _super);
            function ExtractExprInstruction() {
                        _super.call(this);
                this._eExtractExprType = 0;
                this._pPointer = null;
                this._pBuffer = null;
                this._pOffsetVar = null;
                this._sPaddingExpr = "";
                this._sExtractFunction = "";
                this._bNeedSecondBracket = false;
                this._pInstructionList = null;
                this._eInstructionType = akra.EAFXInstructionTypes.k_ExtractExprInstruction;
            }
            ExtractExprInstruction.prototype.getExtractFunction = function () {
                var pFunction = null;
                switch(this._eExtractExprType) {
                    case akra.EExtractExprType.k_Header:
                        pFunction = fx.Effect.findSystemFunction("extractHeader", null);
                        break;
                    case akra.EExtractExprType.k_Float:
                    case akra.EExtractExprType.k_Int:
                    case akra.EExtractExprType.k_Bool:
                        pFunction = fx.Effect.findSystemFunction("extractFloat", null);
                        break;
                    case akra.EExtractExprType.k_Float2:
                    case akra.EExtractExprType.k_Int2:
                    case akra.EExtractExprType.k_Bool2:
                        pFunction = fx.Effect.findSystemFunction("extractFloat2", null);
                        break;
                    case akra.EExtractExprType.k_Float3:
                    case akra.EExtractExprType.k_Int3:
                    case akra.EExtractExprType.k_Bool3:
                        pFunction = fx.Effect.findSystemFunction("extractFloat3", null);
                        break;
                    case akra.EExtractExprType.k_Float4:
                    case akra.EExtractExprType.k_Int4:
                    case akra.EExtractExprType.k_Bool4:
                        pFunction = fx.Effect.findSystemFunction("extractFloat4", null);
                        break;
                    case akra.EExtractExprType.k_Float4x4:
                        pFunction = fx.Effect.findSystemFunction("extractFloat4x4", null);
                        break;
                }
                return pFunction;
            };
            ExtractExprInstruction.prototype.initExtractExpr = function (pExtractType, pPointer, pBuffer, sPaddingExpr, pOffsetVar) {
                this._pPointer = pPointer;
                this._pBuffer = pBuffer;
                this._sPaddingExpr = sPaddingExpr;
                this._pOffsetVar = pOffsetVar;
                this.setType(pExtractType);
                if (pExtractType.isEqual(fx.Effect.getSystemType("float"))) {
                    this._eExtractExprType = akra.EExtractExprType.k_Float;
                    this._sExtractFunction += "A_extractFloat(";
                } else if (pExtractType.isEqual(fx.Effect.getSystemType("ptr"))) {
                    this._eExtractExprType = akra.EExtractExprType.k_Float;
                    this._sExtractFunction += "A_extractFloat(";
                } else if (pExtractType.isEqual(fx.Effect.getSystemType("video_buffer_header"))) {
                    this._eExtractExprType = akra.EExtractExprType.k_Header;
                    this._sExtractFunction += "A_extractTextureHeader(";
                } else if (pExtractType.isEqual(fx.Effect.getSystemType("bool"))) {
                    this._eExtractExprType = akra.EExtractExprType.k_Bool;
                    this._sExtractFunction += "bool(A_extractFloat(";
                    this._bNeedSecondBracket = true;
                } else if (pExtractType.isEqual(fx.Effect.getSystemType("int"))) {
                    this._eExtractExprType = akra.EExtractExprType.k_Int;
                    this._sExtractFunction += ("int(A_extractFloat(");
                    this._bNeedSecondBracket = true;
                } else if (pExtractType.isEqual(fx.Effect.getSystemType("float2"))) {
                    this._eExtractExprType = akra.EExtractExprType.k_Float2;
                    this._sExtractFunction += ("A_extractVec2(");
                } else if (pExtractType.isEqual(fx.Effect.getSystemType("float3"))) {
                    this._eExtractExprType = akra.EExtractExprType.k_Float3;
                    this._sExtractFunction += ("A_extractVec3(");
                } else if (pExtractType.isEqual(fx.Effect.getSystemType("float4"))) {
                    this._eExtractExprType = akra.EExtractExprType.k_Float4;
                    this._sExtractFunction += ("A_extractVec4(");
                } else if (pExtractType.isEqual(fx.Effect.getSystemType("int2"))) {
                    this._eExtractExprType = akra.EExtractExprType.k_Int2;
                    this._sExtractFunction += ("ivec2(A_extractVec2(");
                    this._bNeedSecondBracket = true;
                } else if (pExtractType.isEqual(fx.Effect.getSystemType("int3"))) {
                    this._eExtractExprType = akra.EExtractExprType.k_Int3;
                    this._sExtractFunction += ("ivec3(A_extractVec3(");
                    this._bNeedSecondBracket = true;
                } else if (pExtractType.isEqual(fx.Effect.getSystemType("int4"))) {
                    this._eExtractExprType = akra.EExtractExprType.k_Int4;
                    this._sExtractFunction += ("ivec4(A_extractVec4(");
                    this._bNeedSecondBracket = true;
                } else if (pExtractType.isEqual(fx.Effect.getSystemType("bool2"))) {
                    this._eExtractExprType = akra.EExtractExprType.k_Bool2;
                    this._sExtractFunction += ("bvec2(A_extractVec2(");
                    this._bNeedSecondBracket = true;
                } else if (pExtractType.isEqual(fx.Effect.getSystemType("bool3"))) {
                    this._eExtractExprType = akra.EExtractExprType.k_Bool3;
                    this._sExtractFunction += ("bvec3(A_extractVec3(");
                    this._bNeedSecondBracket = true;
                } else if (pExtractType.isEqual(fx.Effect.getSystemType("bool4"))) {
                    this._eExtractExprType = akra.EExtractExprType.k_Bool4;
                    this._sExtractFunction += ("bvec4(A_extractVec4(");
                    this._bNeedSecondBracket = true;
                } else if (pExtractType.isEqual(fx.Effect.getSystemType("float4x4"))) {
                    this._eExtractExprType = akra.EExtractExprType.k_Float4x4;
                    this._sExtractFunction += ("A_extractMat4(");
                } else {
                    /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.setError(2273, {
                        typeName: pExtractType.getHash()
                    });
                }
            };
            ExtractExprInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                var pPointerType = this._pPointer.getType();
                var pBufferType = this._pBuffer.getType();
                var pInfo = pUsedDataCollector[pPointerType._getInstructionID()];
                if (!((pInfo) !== undefined)) {
                    pInfo = {
                        type: pPointerType,
                        isRead: false,
                        isWrite: false,
                        numRead: 0,
                        numWrite: 0,
                        numUsed: 0
                    };
                    pUsedDataCollector[pPointerType._getInstructionID()] = pInfo;
                }
                pInfo.isRead = true;
                pInfo.numRead++;
                pInfo.numUsed++;
                pInfo = pUsedDataCollector[pBufferType._getInstructionID()];
                if (!((pInfo) !== undefined)) {
                    pInfo = {
                        type: pBufferType,
                        isRead: false,
                        isWrite: false,
                        numRead: 0,
                        numWrite: 0,
                        numUsed: 0
                    };
                    pUsedDataCollector[pBufferType._getInstructionID()] = pInfo;
                }
                pInfo.isRead = true;
                pInfo.numRead++;
                pInfo.numUsed++;
            };
            ExtractExprInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                if (this._pBuffer.isDefinedByZero()) {
                    switch(this._eExtractExprType) {
                        case akra.EExtractExprType.k_Header:
                            sCode = "A_TextureHeader(0.,0.,0.,0.)";
                            break;
                        case akra.EExtractExprType.k_Float:
                            sCode = "0.";
                            break;
                        case akra.EExtractExprType.k_Int:
                            sCode = "0";
                            break;
                        case akra.EExtractExprType.k_Bool:
                            sCode = "false";
                            break;
                        case akra.EExtractExprType.k_Float2:
                            sCode = "vec2(0.)";
                            break;
                        case akra.EExtractExprType.k_Int2:
                            sCode = "ivec2(0)";
                            break;
                        case akra.EExtractExprType.k_Bool2:
                            sCode = "bvec2(false)";
                            break;
                        case akra.EExtractExprType.k_Float3:
                            sCode = "vec3(0.)";
                            break;
                        case akra.EExtractExprType.k_Int3:
                            sCode = "ivec3(0)";
                            break;
                        case akra.EExtractExprType.k_Bool3:
                            sCode = "bvec3(false)";
                            break;
                        case akra.EExtractExprType.k_Float4:
                            sCode = "vec4(0.)";
                            break;
                        case akra.EExtractExprType.k_Int4:
                            sCode = "ivec4(0)";
                            break;
                        case akra.EExtractExprType.k_Bool4:
                            sCode = "bvec4(false)";
                            break;
                        case akra.EExtractExprType.k_Float4x4:
                            sCode = "mat4(0.)";
                            break;
                    }
                } else {
                    sCode = this._sExtractFunction;
                    sCode += this._pBuffer._getVideoBufferSampler().getNameId().toFinalCode();
                    sCode += "," + this._pBuffer._getVideoBufferHeader().getNameId().toFinalCode();
                    if (this._eExtractExprType !== akra.EExtractExprType.k_Header) {
                        sCode += "," + this._pPointer.getNameId().toFinalCode() + this._sPaddingExpr;
                        if (!((this._pOffsetVar) === null)) {
                            sCode += "+" + this._pOffsetVar.getNameId().toFinalCode();
                        }
                    }
                    sCode += ")";
                    if (this._bNeedSecondBracket) {
                        sCode += ")";
                    }
                }
                return sCode;
            };
            ExtractExprInstruction.prototype.clone = function (pRelationMap) {
                var pClone = _super.prototype.clone.call(this, pRelationMap);
                pClone._setCloneParams(this._pPointer.clone(pRelationMap), this._pBuffer, this._eExtractExprType, this._sPaddingExpr, this._sExtractFunction, this._bNeedSecondBracket);
                return pClone;
            };
            ExtractExprInstruction.prototype._setCloneParams = function (pPointer, pBuffer, eExtractExprType, sPaddingExpr, sExtractFunction, bNeedSecondBracket) {
                this._pPointer = pPointer;
                this._pBuffer = pBuffer;
                this._eExtractExprType = eExtractExprType;
                this._sPaddingExpr = sPaddingExpr;
                this._sExtractFunction = sExtractFunction;
                this._bNeedSecondBracket = bNeedSecondBracket;
            };
            return ExtractExprInstruction;
        })(ExprInstruction);
        fx.ExtractExprInstruction = ExtractExprInstruction;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        var VariableDeclInstruction = (function (_super) {
            __extends(VariableDeclInstruction, _super);
            /**
            * Represent type var_name [= init_expr]
            * EMPTY_OPERATOR VariableTypeInstruction IdInstruction InitExprInstruction
            */
            function VariableDeclInstruction() {
                        _super.call(this);
                this._isVideoBuffer = null;
                this._pVideoBufferSampler = null;
                this._pVideoBufferHeader = null;
                this._pFullNameExpr = null;
                this._bDefineByZero = false;
                this._pSubDeclList = null;
                this._bShaderOutput = false;
                this._pAttrOffset = null;
                this._pAttrExtractionBlock = null;
                this._pValue = null;
                this._pDefaultValue = null;
                this._bLockInitializer = false;
                this._pInstructionList = [
                    null, 
                    null, 
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_VariableDeclInstruction;
            }
            VariableDeclInstruction.prototype.hasInitializer = /** @inline */function () {
                return this._nInstructions === 3 && !((((((this))._pInstructionList)[2])) === null);
            };
            VariableDeclInstruction.prototype.getInitializeExpr = /** @inline */function () {
                return ((this)._pInstructionList)[2];
            };
            VariableDeclInstruction.prototype.hasConstantInitializer = /** @inline */function () {
                return ((this)._nInstructions === 3 && !(((((((this)))._pInstructionList)[2])) === null)) && ((((this))._pInstructionList)[2]).isConst();
            };
            VariableDeclInstruction.prototype.lockInitializer = /** @inline */function () {
                this._bLockInitializer = true;
            };
            VariableDeclInstruction.prototype.unlockInitializer = /** @inline */function () {
                this._bLockInitializer = false;
            };
            VariableDeclInstruction.prototype.getDefaultValue = function () {
                return this._pDefaultValue;
            };
            VariableDeclInstruction.prototype.prepareDefaultValue = function () {
                ((((this))._pInstructionList)[2]).evaluate();
                this._pDefaultValue = ((((this))._pInstructionList)[2]).getEvalValue();
            };
            VariableDeclInstruction.prototype.getValue = function () {
                return this._pValue;
            };
            VariableDeclInstruction.prototype.setValue = function (pValue) {
                this._pValue = pValue;
                if (((this)._pInstructionList[0]).isForeign()) {
                    this.setRealName(pValue);
                }
            };
            VariableDeclInstruction.prototype.getType = /** @inline */function () {
                return this._pInstructionList[0];
            };
            VariableDeclInstruction.prototype.setType = /** @inline */function (pType) {
                this._pInstructionList[0] = pType;
                pType.setParent(this);
                if (this._nInstructions === 0) {
                    this._nInstructions = 1;
                }
            };
            VariableDeclInstruction.prototype.setName = function (sName) {
                var pName = new fx.IdInstruction();
                pName.setName(sName);
                pName.setParent(this);
                this._pInstructionList[1] = pName;
                if (this._nInstructions < 2) {
                    this._nInstructions = 2;
                }
            };
            VariableDeclInstruction.prototype.setRealName = function (sRealName) {
                ((this)._pInstructionList[1]).setRealName(sRealName);
            };
            VariableDeclInstruction.prototype.setVideoBufferRealName = function (sSampler, sHeader) {
                if (!this.isVideoBuffer()) {
                    return;
                }
                this._getVideoBufferSampler().setRealName(sSampler);
                this._getVideoBufferHeader().setRealName(sHeader);
            };
            VariableDeclInstruction.prototype.getName = /** @inline */function () {
                return (this._pInstructionList[1]).getName();
            };
            VariableDeclInstruction.prototype.getRealName = /** @inline */function () {
                return (this._pInstructionList[1]).getRealName();
            };
            VariableDeclInstruction.prototype.getNameId = /** @inline */function () {
                return this._pInstructionList[1];
            };
            VariableDeclInstruction.prototype.isUniform = /** @inline */function () {
                return ((this)._pInstructionList[0]).hasUsage("uniform");
            };
            VariableDeclInstruction.prototype.isField = function () {
                if (((((this)._pParentInstruction)) === null)) {
                    return false;
                }
                var eParentType = ((this)._pParentInstruction)._getInstructionType();
                if (eParentType === akra.EAFXInstructionTypes.k_VariableTypeInstruction || eParentType === akra.EAFXInstructionTypes.k_ComplexTypeInstruction || eParentType === akra.EAFXInstructionTypes.k_SystemTypeInstruction) {
                    return true;
                }
                return false;
            };
            VariableDeclInstruction.prototype.isPointer = /** @inline */function () {
                return ((this)._pInstructionList[0]).isPointer();
            };
            VariableDeclInstruction.prototype.isVideoBuffer = function () {
                if (((this._isVideoBuffer) === null)) {
                    this._isVideoBuffer = ((this)._pInstructionList[0]).isStrongEqual(fx.Effect.getSystemType("video_buffer"));
                }
                return this._isVideoBuffer;
            };
            VariableDeclInstruction.prototype.isSampler = /** @inline */function () {
                return ((this)._pInstructionList[0]).isSampler();
            };
            VariableDeclInstruction.prototype.getSubVarDecls = /** @inline */function () {
                return ((this)._pInstructionList[0]).getSubVarDecls();
            };
            VariableDeclInstruction.prototype.isDefinedByZero = /** @inline */function () {
                return this._bDefineByZero;
            };
            VariableDeclInstruction.prototype.defineByZero = /** @inline */function (isDefine) {
                this._bDefineByZero = isDefine;
            };
            VariableDeclInstruction.prototype.toFinalCode = function () {
                if (((this)._bShaderOutput)) {
                    return "";
                }
                var sCode = "";
                if (this.isVideoBuffer()) {
                    this._getVideoBufferHeader().lockInitializer();
                    sCode = this._getVideoBufferHeader().toFinalCode();
                    sCode += ";\n";
                    sCode += this._getVideoBufferSampler().toFinalCode();
                    this._getVideoBufferHeader().unlockInitializer();
                } else {
                    sCode = ((this)._pInstructionList[0]).toFinalCode();
                    sCode += " " + ((this)._pInstructionList[1]).toFinalCode();
                    if (((this)._pInstructionList[0]).isNotBaseArray()) {
                        var iLength = ((this)._pInstructionList[0]).getLength();
                        if (akra.webgl.isANGLE && iLength === 1 && ((this)._pInstructionList[0]).isComplex()) {
                            sCode += "[" + 2 + "]";
                        } else {
                            sCode += "[" + iLength + "]";
                        }
                    }
                    if (((this)._nInstructions === 3 && !(((((((this)))._pInstructionList)[2])) === null)) && !((((this))._pInstructionList[0]).isSampler()) && !((((this))._pInstructionList[0]).hasUsage("uniform")) && !this._bLockInitializer) {
                        sCode += "=" + ((((this))._pInstructionList)[2]).toFinalCode();
                    }
                }
                return sCode;
            };
            VariableDeclInstruction.prototype._markAsVarying = /** @inline */function (bValue) {
                ((this)._pInstructionList[1])._markAsVarying(bValue);
            };
            VariableDeclInstruction.prototype._markAsShaderOutput = /** @inline */function (isShaderOutput) {
                this._bShaderOutput = isShaderOutput;
            };
            VariableDeclInstruction.prototype._isShaderOutput = /** @inline */function () {
                return this._bShaderOutput;
            };
            VariableDeclInstruction.prototype._setAttrExtractionBlock = function (pCodeBlock) {
                this._pAttrExtractionBlock = pCodeBlock;
            };
            VariableDeclInstruction.prototype._getAttrExtractionBlock = function () {
                return this._pAttrExtractionBlock;
            };
            VariableDeclInstruction.prototype._getFullNameExpr = function () {
                if (!((this._pFullNameExpr) === null)) {
                    return this._pFullNameExpr;
                }
                if (!this.isField() || !(((this)._pParentInstruction))._getParentVarDecl().isVisible()) {
                    this._pFullNameExpr = new fx.IdExprInstruction();
                    this._pFullNameExpr.push(((this)._pInstructionList[1]), false);
                } else {
                    var pMainVar = ((this)._pInstructionList[0])._getParentContainer();
                    if (((pMainVar) === null)) {
                        return null;
                    }
                    var pMainExpr = pMainVar._getFullNameExpr();
                    if (((pMainExpr) === null)) {
                        return null;
                    }
                    var pFieldExpr = new fx.IdExprInstruction();
                    pFieldExpr.push(((this)._pInstructionList[1]), false);
                    this._pFullNameExpr = new fx.PostfixPointInstruction();
                    this._pFullNameExpr.push(pMainExpr, false);
                    this._pFullNameExpr.push(pFieldExpr, false);
                    this._pFullNameExpr.setType(((this)._pInstructionList[0]));
                }
                return this._pFullNameExpr;
            };
            VariableDeclInstruction.prototype._getFullName = function () {
                if (this.isField() && (((this)._pParentInstruction))._getParentVarDecl().isVisible()) {
                    var sName = "";
                    var eParentType = ((this)._pParentInstruction)._getInstructionType();
                    if (eParentType === akra.EAFXInstructionTypes.k_VariableTypeInstruction) {
                        sName = (((this)._pParentInstruction))._getFullName();
                    }
                    sName += "." + (((this)._pInstructionList[1]).getName());
                    return sName;
                } else {
                    return (((this)._pInstructionList[1]).getName());
                }
            };
            VariableDeclInstruction.prototype._getVideoBufferSampler = function () {
                if (!this.isVideoBuffer()) {
                    return null;
                }
                if (((this._pVideoBufferSampler) === null)) {
                    this._pVideoBufferSampler = new VariableDeclInstruction();
                    var pType = new fx.VariableTypeInstruction();
                    var pId = new fx.IdInstruction();
                    pType.pushType(fx.Effect.getSystemType("sampler2D"));
                    pType.addUsage("uniform");
                    pId.setName((((this)._pInstructionList[1]).getName()) + "_sampler");
                    this._pVideoBufferSampler.push(pType, true);
                    this._pVideoBufferSampler.push(pId, true);
                }
                return this._pVideoBufferSampler;
            };
            VariableDeclInstruction.prototype._getVideoBufferHeader = function () {
                if (!this.isVideoBuffer()) {
                    return null;
                }
                if (((this._pVideoBufferHeader) === null)) {
                    this._pVideoBufferHeader = new VariableDeclInstruction();
                    var pType = new fx.VariableTypeInstruction();
                    var pId = new fx.IdInstruction();
                    var pExtarctExpr = new fx.ExtractExprInstruction();
                    pType.pushType(fx.Effect.getSystemType("video_buffer_header"));
                    pId.setName((((this)._pInstructionList[1]).getName()) + "_header");
                    this._pVideoBufferHeader.push(pType, true);
                    this._pVideoBufferHeader.push(pId, true);
                    this._pVideoBufferHeader.push(pExtarctExpr, true);
                    pExtarctExpr.initExtractExpr(pType, null, this, "", null);
                }
                return this._pVideoBufferHeader;
            };
            VariableDeclInstruction.prototype._getVideoBufferInitExpr = function () {
                if (!this.isVideoBuffer()) {
                    return null;
                }
                return this._getVideoBufferHeader().getInitializeExpr();
            };
            VariableDeclInstruction.prototype._setCollapsed = /** @inline */function (bValue) {
                ((this)._pInstructionList[0])._setCollapsed(bValue);
            };
            VariableDeclInstruction.prototype._isCollapsed = /** @inline */function () {
                return ((this)._pInstructionList[0])._isCollapsed();
            };
            VariableDeclInstruction.prototype.clone = function (pRelationMap) {
                return _super.prototype.clone.call(this, pRelationMap);
            };
            VariableDeclInstruction.prototype.blend = function (pVariableDecl, eMode) {
                var pBlendType = ((this)._pInstructionList[0]).blend(pVariableDecl.getType(), eMode);
                if (((pBlendType) === null)) {
                    return null;
                }
                var pBlendVar = new VariableDeclInstruction();
                var pId = new fx.IdInstruction();
                pId.setName(((this)._pInstructionList[1]).getName());
                pId.setRealName(((this)._pInstructionList[1]).getRealName());
                pBlendVar.setSemantic(((this)._sSemantic));
                pBlendVar.push(pBlendType, true);
                pBlendVar.push(pId, true);
                return pBlendVar;
            };
            return VariableDeclInstruction;
        })(fx.DeclInstruction);
        fx.VariableDeclInstruction = VariableDeclInstruction;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        /**
        * Represent all kind of statements
        */
        var StmtInstruction = (function (_super) {
            __extends(StmtInstruction, _super);
            function StmtInstruction() {
                        _super.call(this);
                this._eInstructionType = akra.EAFXInstructionTypes.k_StmtInstruction;
            }
            StmtInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                var pInstructionList = ((this)._pInstructionList);
                if (!((pUsedDataCollector) === null)) {
                    for(var i = 0; i < this._nInstructions; i++) {
                        pInstructionList[i].addUsedData(pUsedDataCollector, eUsedMode);
                    }
                }
            };
            return StmtInstruction;
        })(fx.Instruction);
        fx.StmtInstruction = StmtInstruction;        
        /**
        * Represent {stmts}
        * EMPTY_OPERATOR StmtInstruction ... StmtInstruction
        */
        var StmtBlockInstruction = (function (_super) {
            __extends(StmtBlockInstruction, _super);
            function StmtBlockInstruction() {
                        _super.call(this);
                this._pInstructionList = [];
                this._eInstructionType = akra.EAFXInstructionTypes.k_StmtBlockInstruction;
            }
            StmtBlockInstruction.prototype.toFinalCode = function () {
                var sCode = "{" + "\n";
                for(var i = 0; i < this._nInstructions; i++) {
                    sCode += "\t" + this._pInstructionList[i].toFinalCode() + "\n";
                }
                sCode += "}";
                return sCode;
            };
            return StmtBlockInstruction;
        })(StmtInstruction);
        fx.StmtBlockInstruction = StmtBlockInstruction;        
        /**
        * Represent expr;
        * EMPTY_OPERTOR ExprInstruction
        */
        var ExprStmtInstruction = (function (_super) {
            __extends(ExprStmtInstruction, _super);
            function ExprStmtInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_ExprStmtInstruction;
            }
            ExprStmtInstruction.prototype.toFinalCode = function () {
                return ((this)._pInstructionList)[0].toFinalCode() + ";";
            };
            return ExprStmtInstruction;
        })(StmtInstruction);
        fx.ExprStmtInstruction = ExprStmtInstruction;        
        /**
        * Reprsernt continue; break; discard;
        * (continue || break || discard)
        */
        var BreakStmtInstruction = (function (_super) {
            __extends(BreakStmtInstruction, _super);
            function BreakStmtInstruction() {
                        _super.call(this);
                this._pInstructionList = null;
                this._eInstructionType = akra.EAFXInstructionTypes.k_BreakStmtInstruction;
            }
            BreakStmtInstruction.prototype.toFinalCode = function () {
                return ((this)._sOperatorName) + ";";
            };
            return BreakStmtInstruction;
        })(StmtInstruction);
        fx.BreakStmtInstruction = BreakStmtInstruction;        
        /**
        * Represent while(expr) stmt
        * ( while || do_while) ExprInstruction StmtInstruction
        */
        var WhileStmtInstruction = (function (_super) {
            __extends(WhileStmtInstruction, _super);
            function WhileStmtInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_WhileStmtInstruction;
            }
            WhileStmtInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                if (((this)._sOperatorName) === "while") {
                    sCode += "while(";
                    sCode += ((this)._pInstructionList)[0].toFinalCode();
                    sCode += ")";
                    sCode += ((this)._pInstructionList)[1].toFinalCode();
                } else {
                    sCode += "do";
                    sCode += ((this)._pInstructionList)[1].toFinalCode();
                    sCode += "while(";
                    sCode += ((this)._pInstructionList)[0].toFinalCode();
                    sCode += ");";
                }
                return sCode;
            };
            return WhileStmtInstruction;
        })(StmtInstruction);
        fx.WhileStmtInstruction = WhileStmtInstruction;        
        /**
        * Represent for(forInit forCond ForStep) stmt
        * for ExprInstruction or VarDeclInstruction ExprInstruction ExprInstruction StmtInstruction
        */
        var ForStmtInstruction = (function (_super) {
            __extends(ForStmtInstruction, _super);
            function ForStmtInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null, 
                    null, 
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_ForStmtInstruction;
            }
            ForStmtInstruction.prototype.toFinalCode = function () {
                var sCode = "for(";
                sCode += ((this)._pInstructionList)[0].toFinalCode() + ";";
                sCode += ((this)._pInstructionList)[1].toFinalCode() + ";";
                sCode += ((this)._pInstructionList)[2].toFinalCode() + ")";
                sCode += ((this)._pInstructionList)[3].toFinalCode();
                return sCode;
            };
            ForStmtInstruction.prototype.check = function (eStage, pInfo) {
                if (typeof pInfo === "undefined") { pInfo = null; }
                var pInstructionList = ((this)._pInstructionList);
                if (this._nInstructions !== 4) {
                    /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.setError(2239);
                    return false;
                }
                if (((pInstructionList[0]) === null)) {
                    /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.setError(2232);
                    return false;
                }
                if (pInstructionList[0]._getInstructionType() !== akra.EAFXInstructionTypes.k_VariableDeclInstruction) {
                    /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.setError(2231);
                    return false;
                }
                if (((pInstructionList[1]) === null)) {
                    /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.setError(2233);
                    return false;
                }
                if (pInstructionList[1]._getInstructionType() !== akra.EAFXInstructionTypes.k_RelationalExprInstruction) {
                    /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.setError(2238);
                    return false;
                }
                if (pInstructionList[2]._getInstructionType() === akra.EAFXInstructionTypes.k_UnaryExprInstruction || pInstructionList[2]._getInstructionType() === akra.EAFXInstructionTypes.k_AssignmentExprInstruction || pInstructionList[2]._getInstructionType() === akra.EAFXInstructionTypes.k_PostfixArithmeticInstruction) {
                    var sOperator = pInstructionList[2].getOperator();
                    if (sOperator !== "++" && sOperator !== "--" && sOperator !== "+=" && sOperator !== "-=") {
                        /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.setError(2240, {
                            operator: sOperator
                        });
                        return false;
                    }
                } else {
                    /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.setError(2241);
                    return false;
                }
                return true;
            };
            ForStmtInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                var pForInit = ((this)._pInstructionList)[0];
                var pForCondition = ((this)._pInstructionList)[1];
                var pForStep = ((this)._pInstructionList)[2];
                var pForStmt = ((this)._pInstructionList)[3];
                var pIteratorType = pForInit.getType();
                pUsedDataCollector[pIteratorType._getInstructionID()] = {
                    type: pIteratorType,
                    isRead: false,
                    isWrite: true,
                    numRead: 0,
                    numWrite: 1,
                    numUsed: 1
                };
                pForCondition.addUsedData(pUsedDataCollector, eUsedMode);
                pForStep.addUsedData(pUsedDataCollector, eUsedMode);
                pForStmt.addUsedData(pUsedDataCollector, eUsedMode);
            };
            return ForStmtInstruction;
        })(StmtInstruction);
        fx.ForStmtInstruction = ForStmtInstruction;        
        /**
        * Represent if(expr) stmt or if(expr) stmt else stmt
        * ( if || if_else ) Expr Stmt [Stmt]
        */
        var IfStmtInstruction = (function (_super) {
            __extends(IfStmtInstruction, _super);
            function IfStmtInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null, 
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_IfStmtInstruction;
            }
            IfStmtInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                if (((this)._sOperatorName) === "if") {
                    sCode += "if(";
                    sCode += ((this)._pInstructionList)[0].toFinalCode() + ")";
                    sCode += ((this)._pInstructionList)[1].toFinalCode();
                } else {
                    sCode += "if(";
                    sCode += ((this)._pInstructionList)[0].toFinalCode() + ") ";
                    sCode += ((this)._pInstructionList)[1].toFinalCode();
                    sCode += "else ";
                    sCode += ((this)._pInstructionList)[2].toFinalCode();
                }
                return sCode;
            };
            return IfStmtInstruction;
        })(StmtInstruction);
        fx.IfStmtInstruction = IfStmtInstruction;        
        /**
        * Represent TypeDecl or VariableDecl or VarStructDecl
        * EMPTY DeclInstruction
        */
        var DeclStmtInstruction = (function (_super) {
            __extends(DeclStmtInstruction, _super);
            function DeclStmtInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_DeclStmtInstruction;
            }
            DeclStmtInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                var pVariableList = ((this)._pInstructionList);
                for(var i = 0; i < this._nInstructions; i++) {
                    sCode += pVariableList[i].toFinalCode() + ";\n";
                }
                return sCode;
            };
            DeclStmtInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                if (((((this)._pInstructionList)) === null) || this._nInstructions === 0) {
                    return;
                }
                if (((this)._pInstructionList)[0]._getInstructionType() === akra.EAFXInstructionTypes.k_TypeDeclInstruction) {
                    return;
                }
                var pVariableList = ((this)._pInstructionList);
                for(var i = 0; i < this._nInstructions; i++) {
                    var pVarType = pVariableList[i].getType();
                    pUsedDataCollector[pVarType._getInstructionID()] = {
                        type: pVarType,
                        isRead: false,
                        isWrite: true,
                        numRead: 0,
                        numWrite: 1,
                        numUsed: 1
                    };
                    if (pVariableList[i].hasInitializer()) {
                        pVariableList[i].getInitializeExpr().addUsedData(pUsedDataCollector, akra.EVarUsedMode.k_Read);
                    }
                }
            };
            return DeclStmtInstruction;
        })(StmtInstruction);
        fx.DeclStmtInstruction = DeclStmtInstruction;        
        /**
        * Represent return expr;
        * return ExprInstruction
        */
        var ReturnStmtInstruction = (function (_super) {
            __extends(ReturnStmtInstruction, _super);
            function ReturnStmtInstruction() {
                        _super.call(this);
                this._pPreparedCode = "";
                this._isPositionReturn = false;
                this._isColorReturn = false;
                this._isOnlyReturn = false;
                this._pInstructionList = [
                    null
                ];
                this._sOperatorName = "return";
                this._eInstructionType = akra.EAFXInstructionTypes.k_ReturnStmtInstruction;
            }
            ReturnStmtInstruction.prototype.prepareFor = function (eUsedMode) {
                var pReturn = ((this)._pInstructionList)[0];
                if (((pReturn) === null)) {
                    return;
                }
                if (eUsedMode === akra.EFunctionType.k_Vertex) {
                    if (pReturn.getType().isBase()) {
                        this._isPositionReturn = true;
                    } else {
                        this._isOnlyReturn = true;
                    }
                } else if (eUsedMode === akra.EFunctionType.k_Pixel) {
                    this._isColorReturn = true;
                }
                for(var i = 0; i < this._nInstructions; i++) {
                    this._pInstructionList[i].prepareFor(eUsedMode);
                }
            };
            ReturnStmtInstruction.prototype.toFinalCode = function () {
                if (this._isPositionReturn) {
                    return "Out.POSITION=" + this._pInstructionList[0].toFinalCode() + "; return;";
                }
                if (this._isColorReturn) {
                    //return "gl_FragColor=" + this._pInstructionList[0].toFinalCode() + "; return;";
                    return "resultAFXColor=" + this._pInstructionList[0].toFinalCode() + "; return;";
                }
                if (this._isOnlyReturn) {
                    return "return;";
                }
                if (this._nInstructions > 0) {
                    return "return " + this._pInstructionList[0].toFinalCode() + ";";
                } else {
                    return "return;";
                }
            };
            return ReturnStmtInstruction;
        })(StmtInstruction);
        fx.ReturnStmtInstruction = ReturnStmtInstruction;        
        var ExtractStmtInstruction = (function (_super) {
            __extends(ExtractStmtInstruction, _super);
            function ExtractStmtInstruction() {
                        _super.call(this);
                this._pExtractInVar = null;
                this._pExtractInExpr = null;
                this._pExtactExpr = null;
                this._pInstructionList = [];
                this._eInstructionType = akra.EAFXInstructionTypes.k_ExtractStmtInstruction;
            }
            ExtractStmtInstruction.prototype.generateStmtForBaseType = function (pVarDecl, pPointer, pBuffer, iPadding, pOffset) {
                if (typeof pOffset === "undefined") { pOffset = null; }
                var pVarType = pVarDecl.getType();
                var pVarNameExpr = pVarDecl._getFullNameExpr();
                if (pVarType.isComplex() || ((pVarNameExpr) === null) || pVarType.getSize() === 0xffffff) {
                    /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.setError(2274);
                    return;
                }
                // var pPointer: IAFXVariableDeclInstruction = isDef(pPointer) ? pPointer : pVarType.getPointer();
                // var pBuffer: IAFXVariableDeclInstruction = isDef(pBuffer) ?  pBuffer : pVarType.getVideoBuffer();
                var pBufferSampler = pBuffer._getVideoBufferSampler();
                var pBufferHeader = pBuffer._getVideoBufferHeader();
                var isArray = pVarType.isNotBaseArray();
                var iLength = pVarType.getLength();
                var sCodeFragment = "";
                var pExtractType = isArray ? pVarType.getArrayElementType() : pVarType;
                if (isArray) {
                    if (iLength === 0xffffff) {
                        /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.setError(2274);
                        return;
                    }
                    sCodeFragment = "for(int i=0;i<" + iLength.toString() + ";i++){";
                    this.push(new fx.SimpleInstruction(sCodeFragment), true);
                }
                this.push(pVarNameExpr, false);
                if (isArray) {
                    sCodeFragment = "[i]=";
                } else {
                    sCodeFragment = "=";
                }
                this.push(new fx.SimpleInstruction(sCodeFragment), true);
                var pExtractType = isArray ? pVarType.getArrayElementType() : pVarType;
                var pExtractExpr = new fx.ExtractExprInstruction();
                var sPaddingExpr = "";
                if (iPadding > 0) {
                    sPaddingExpr = "+" + iPadding.toString() + ".0";
                } else {
                    sPaddingExpr = "";
                }
                if (isArray) {
                    sPaddingExpr += "+float(i*" + pExtractType.getSize().toString() + ")";
                }
                pExtractExpr.initExtractExpr(pExtractType, pPointer, pBuffer, sPaddingExpr, pOffset);
                if ((pExtractExpr._bErrorOccured)) {
                    /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.setError((pExtractExpr._pLastError).code, (pExtractExpr._pLastError).info);
                    return;
                }
                this.push(pExtractExpr, true);
                sCodeFragment = ";";
                if (isArray) {
                    sCodeFragment += "}";
                }
                this.push(new fx.SimpleInstruction(sCodeFragment), true);
                this._pExtactExpr = pExtractExpr;
                this._pExtractInVar = pVarDecl;
                this._pExtractInExpr = pVarNameExpr;
            };
            ExtractStmtInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                for(var i = 0; i < this._nInstructions; i++) {
                    sCode += ((this)._pInstructionList)[i].toFinalCode();
                }
                return sCode;
            };
            ExtractStmtInstruction.prototype.addUsedData = function (pUsedDataCollector, eUsedMode) {
                if (typeof eUsedMode === "undefined") { eUsedMode = akra.EVarUsedMode.k_Undefined; }
                this._pExtractInExpr.addUsedData(pUsedDataCollector, akra.EVarUsedMode.k_Write);
                this._pExtactExpr.addUsedData(pUsedDataCollector, akra.EVarUsedMode.k_Read);
            };
            ExtractStmtInstruction.prototype.getExtractFunction = function () {
                return this._pExtactExpr.getExtractFunction();
            };
            return ExtractStmtInstruction;
        })(fx.ExprInstruction);
        fx.ExtractStmtInstruction = ExtractStmtInstruction;        
        /**
        * Represent empty statement only semicolon ;
        * ;
        */
        var SemicolonStmtInstruction = (function (_super) {
            __extends(SemicolonStmtInstruction, _super);
            function SemicolonStmtInstruction() {
                        _super.call(this);
                this._pInstructionList = null;
                this._eInstructionType = akra.EAFXInstructionTypes.k_SemicolonStmtInstruction;
            }
            SemicolonStmtInstruction.prototype.toFinalCode = function () {
                return ";";
            };
            return SemicolonStmtInstruction;
        })(StmtInstruction);
        fx.SemicolonStmtInstruction = SemicolonStmtInstruction;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        /**
        * Represent type func(...args)[:Semantic] [<Annotation> {stmts}]
        * EMPTY_OPERTOR FunctionDefInstruction StmtBlockInstruction
        */
        var FunctionDeclInstruction = (function (_super) {
            __extends(FunctionDeclInstruction, _super);
            function FunctionDeclInstruction() {
                        _super.call(this);
                /**@protected*/ this._pFunctionDefenition = null;
                /**@protected*/ this._pImplementation = null;
                /**@protected*/ this._eFunctionType = akra.EFunctionType.k_Function;
                /**@protected*/ this._bUsedAsFunction = false;
                /**@protected*/ this._bUsedAsVertex = false;
                /**@protected*/ this._bUsedAsPixel = false;
                /**@protected*/ this._bCanUsedAsFunction = true;
                /**@protected*/ this._bUsedInVertex = false;
                /**@protected*/ this._bUsedInPixel = false;
                /**@protected*/ this._pParseNode = null;
                /**@protected*/ this._iImplementationScope = 0xffffff;
                /**@protected*/ this._isInBlackList = false;
                /**@protected*/ this._pOutVariable = null;
                //Info about used data
                /**@protected*/ this._pUsedFunctionMap = null;
                /**@protected*/ this._pUsedFunctionList = null;
                /**@protected*/ this._pAttributeVariableMap = null;
                /**@protected*/ this._pVaryingVariableMap = null;
                /**@protected*/ this._pUsedVarTypeMap = null;
                /**@protected*/ this._pSharedVariableMap = null;
                /**@protected*/ this._pGlobalVariableMap = null;
                /**@protected*/ this._pUniformVariableMap = null;
                /**@protected*/ this._pForeignVariableMap = null;
                /**@protected*/ this._pTextureVariableMap = null;
                // protected _pSharedVariableTypeList: IAFXVariableTypeInstruction[] = null;
                // protected _pGlobalVariableTypeList: IAFXVariableTypeInstruction[] = null;
                // protected _pUniformVariableTypeList: IAFXVariableTypeInstruction[] = null;
                // protected _pForeignVariableTypeList: IAFXVariableTypeInstructionnt[] = null;
                /**@protected*/ this._pUsedComplexTypeMap = null;
                /**@protected*/ this._pAttributeVariableKeys = null;
                /**@protected*/ this._pVaryingVariableKeys = null;
                /**@protected*/ this._pSharedVariableKeys = null;
                /**@protected*/ this._pUniformVariableKeys = null;
                /**@protected*/ this._pForeignVariableKeys = null;
                /**@protected*/ this._pGlobalVariableKeys = null;
                /**@protected*/ this._pTextureVariableKeys = null;
                /**@protected*/ this._pUsedComplexTypeKeys = null;
                /**@protected*/ this._pVertexShader = null;
                /**@protected*/ this._pPixelShader = null;
                this._pExtSystemTypeList = null;
                this._pExtSystemFunctionList = null;
                this._pExtSystemMacrosList = null;
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._eInstructionType = akra.EAFXInstructionTypes.k_FunctionDeclInstruction;
            }
            FunctionDeclInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                sCode += this._pFunctionDefenition.toFinalCode();
                sCode += this._pImplementation.toFinalCode();
                return sCode;
            };
            FunctionDeclInstruction.prototype.toFinalDefCode = function () {
                return this._pFunctionDefenition.toFinalCode();
            };
            FunctionDeclInstruction.prototype.getType = /** @inline */function () {
                return ((((this)._pFunctionDefenition)._pReturnType));
            };
            FunctionDeclInstruction.prototype.getName = /** @inline */function () {
                return ((this._pFunctionDefenition)._pFunctionName.getName());
            };
            FunctionDeclInstruction.prototype.getRealName = /** @inline */function () {
                return ((this._pFunctionDefenition)._pFunctionName.getRealName());
            };
            FunctionDeclInstruction.prototype.getNameId = /** @inline */function () {
                return ((this._pFunctionDefenition)._pFunctionName);
            };
            FunctionDeclInstruction.prototype.getArguments = function () {
                return ((this._pFunctionDefenition)._pParameterList);
            };
            FunctionDeclInstruction.prototype.getNumNeededArguments = /** @inline */function () {
                return ((this._pFunctionDefenition)._nParamsNeeded);
            };
            FunctionDeclInstruction.prototype.hasImplementation = /** @inline */function () {
                return !((this._pImplementation) === null) || !((this._pParseNode) === null);
            };
            FunctionDeclInstruction.prototype.getReturnType = /** @inline */function () {
                return ((this._pFunctionDefenition)._pReturnType);
            };
            FunctionDeclInstruction.prototype.getFunctionType = /** @inline */function () {
                return this._eFunctionType;
            };
            FunctionDeclInstruction.prototype.setFunctionType = /** @inline */function (eFunctionType) {
                this._eFunctionType = eFunctionType;
            };
            FunctionDeclInstruction.prototype._setImplementationScope = /** @inline */function (iScope) {
                this._iImplementationScope = iScope;
            };
            FunctionDeclInstruction.prototype._getImplementationScope = /** @inline */function () {
                return this._iImplementationScope;
            };
            FunctionDeclInstruction.prototype._setParseNode = /** @inline */function (pNode) {
                this._pParseNode = pNode;
            };
            FunctionDeclInstruction.prototype._getParseNode = /** @inline */function () {
                return this._pParseNode;
            };
            FunctionDeclInstruction.prototype.setFunctionDef = function (pFunctionDef) {
                this._pFunctionDefenition = pFunctionDef;
                this._pInstructionList[0] = pFunctionDef;
                pFunctionDef.setParent(this);
                this._nInstructions = this._nInstructions === 0 ? 1 : this._nInstructions;
            };
            FunctionDeclInstruction.prototype.setImplementation = function (pImplementation) {
                this._pImplementation = pImplementation;
                this._pInstructionList[1] = pImplementation;
                pImplementation.setParent(pImplementation);
                this._nInstructions = 2;
                this._pParseNode = null;
            };
            FunctionDeclInstruction.prototype.clone = function (pRelationMap) {
                if (typeof pRelationMap === "undefined") { pRelationMap = {}; }
                var pClone = _super.prototype.clone.call(this, pRelationMap);
                if (!((this._pOutVariable) === null)) {
                    pClone._setOutVariable(pRelationMap[this._pOutVariable._getInstructionID()]);
                }
                var pUsedVarTypeMap = this.cloneVarTypeUsedMap(this._pUsedVarTypeMap, pRelationMap);
                var pSharedVariableMap = this.cloneVarDeclMap(this._pSharedVariableMap, pRelationMap);
                var pGlobalVariableMap = this.cloneVarDeclMap(this._pGlobalVariableMap, pRelationMap);
                var pUniformVariableMap = this.cloneVarDeclMap(this._pUniformVariableMap, pRelationMap);
                var pForeignVariableMap = this.cloneVarDeclMap(this._pForeignVariableMap, pRelationMap);
                var pTextureVariableMap = this.cloneVarDeclMap(this._pTextureVariableMap, pRelationMap);
                var pUsedComplexTypeMap = this.cloneTypeMap(this._pUsedComplexTypeMap, pRelationMap);
                pClone._setUsedFunctions(this._pUsedFunctionMap, this._pUsedFunctionList);
                pClone._setUsedVariableData(pUsedVarTypeMap, pSharedVariableMap, pGlobalVariableMap, pUniformVariableMap, pForeignVariableMap, pTextureVariableMap, pUsedComplexTypeMap);
                pClone._initAfterClone();
                return pClone;
            };
            FunctionDeclInstruction.prototype._addOutVariable = function (pVariable) {
                if (!((this._pOutVariable) === null)) {
                    return false;
                }
                if (!pVariable.getType().isEqual(((((this)._pFunctionDefenition)._pReturnType)))) {
                    return false;
                }
                this._pOutVariable = pVariable;
                return true;
            };
            FunctionDeclInstruction.prototype._getOutVariable = function () {
                return this._pOutVariable;
            };
            FunctionDeclInstruction.prototype._getVertexShader = function () {
                return this._pVertexShader;
            };
            FunctionDeclInstruction.prototype._getPixelShader = function () {
                return this._pPixelShader;
            };
            FunctionDeclInstruction.prototype._markUsedAs = function (eUsedType) {
                switch(eUsedType) {
                    case akra.EFunctionType.k_Vertex:
                        this._bUsedInVertex = true;
                        this._bUsedAsVertex = true;
                        break;
                    case akra.EFunctionType.k_Pixel:
                        this._bUsedInPixel = true;
                        this._bUsedAsPixel = true;
                        break;
                    case akra.EFunctionType.k_Function:
                        this._bUsedAsFunction = true;
                        break;
                }
            };
            FunctionDeclInstruction.prototype._isUsedAs = function (eUsedType) {
                switch(eUsedType) {
                    case akra.EFunctionType.k_Vertex:
                        return this._bUsedAsVertex;
                    case akra.EFunctionType.k_Pixel:
                        return this._bUsedAsPixel;
                    case akra.EFunctionType.k_Function:
                        return this._bUsedAsFunction;
                }
            };
            FunctionDeclInstruction.prototype._isUsedAsFunction = function () {
                return this._bUsedAsFunction;
            };
            FunctionDeclInstruction.prototype._isUsedAsVertex = function () {
                return this._bUsedAsVertex;
            };
            FunctionDeclInstruction.prototype._isUsedAsPixel = function () {
                return this._bUsedAsPixel;
            };
            FunctionDeclInstruction.prototype._markUsedInVertex = function () {
                this._bUsedInVertex = true;
            };
            FunctionDeclInstruction.prototype._markUsedInPixel = function () {
                this._bUsedInPixel = true;
            };
            FunctionDeclInstruction.prototype._isUsedInVertex = function () {
                return this._bUsedInVertex;
            };
            FunctionDeclInstruction.prototype._isUsedInPixel = function () {
                return this._bUsedInPixel;
            };
            FunctionDeclInstruction.prototype._isUsed = function () {
                return this._bUsedAsFunction || this._bUsedAsVertex || this._bUsedAsPixel;
            };
            FunctionDeclInstruction.prototype._checkVertexUsage = function () {
                return this._isUsedInVertex() ? ((this)._bForVertex) : true;
            };
            FunctionDeclInstruction.prototype._checkPixelUsage = function () {
                return this._isUsedInPixel() ? ((this)._bForPixel) : true;
            };
            FunctionDeclInstruction.prototype._checkDefenitionForVertexUsage = function () {
                return this._pFunctionDefenition._checkForVertexUsage();
            };
            FunctionDeclInstruction.prototype._checkDefenitionForPixelUsage = function () {
                return this._pFunctionDefenition._checkForPixelUsage();
            };
            FunctionDeclInstruction.prototype._canUsedAsFunction = function () {
                return this._bCanUsedAsFunction && this._pFunctionDefenition._canUsedAsFunction();
            };
            FunctionDeclInstruction.prototype._notCanUsedAsFunction = function () {
                this._bCanUsedAsFunction = false;
            };
            FunctionDeclInstruction.prototype._addUsedFunction = function (pFunction) {
                if (pFunction._getInstructionType() === akra.EAFXInstructionTypes.k_SystemFunctionInstruction && !pFunction.isBuiltIn()) {
                    this.addExtSystemFunction(pFunction);
                    return true;
                }
                if (((this._pUsedFunctionMap) === null)) {
                    this._pUsedFunctionMap = {};
                    this._pUsedFunctionList = [];
                }
                var iFuncId = pFunction._getInstructionID();
                if (!((this._pUsedFunctionMap[iFuncId]) !== undefined)) {
                    this._pUsedFunctionMap[iFuncId] = pFunction;
                    this._pUsedFunctionList.push(pFunction);
                    return true;
                }
                return false;
            };
            FunctionDeclInstruction.prototype._addUsedVariable = function (pVariable) {
            };
            FunctionDeclInstruction.prototype._getUsedFunctionList = function () {
                return this._pUsedFunctionList;
            };
            FunctionDeclInstruction.prototype._isBlackListFunction = function () {
                return this._isInBlackList;
            };
            FunctionDeclInstruction.prototype._addToBlackList = function () {
                this._isInBlackList = true;
            };
            FunctionDeclInstruction.prototype._getStringDef = function () {
                return this._pFunctionDefenition._getStringDef();
            };
            FunctionDeclInstruction.prototype._convertToVertexShader = function () {
                var pShader = null;
                if ((!this._canUsedAsFunction() || !this._isUsedAsFunction()) && (!this._isUsedInPixel())) {
                    pShader = this;
                } else {
                    pShader = this.clone();
                }
                pShader._prepareForVertex();
                this._pVertexShader = pShader;
                return pShader;
            };
            FunctionDeclInstruction.prototype._convertToPixelShader = function () {
                var pShader = null;
                if ((!this._canUsedAsFunction() || !this._isUsedAsFunction()) && (!this._isUsedInVertex())) {
                    pShader = this;
                } else {
                    pShader = this.clone();
                }
                pShader._prepareForPixel();
                this._pPixelShader = pShader;
                return pShader;
            };
            FunctionDeclInstruction.prototype._prepareForVertex = function () {
                ((this)._eFunctionType = (/*checked (origin: akra)>>*/akra.EFunctionType.k_Vertex));
                var pShaderInputParamList = ((this._pFunctionDefenition)._pParamListForShaderInput);
                for(var i = 0; i < pShaderInputParamList.length; i++) {
                    var pParamType = pShaderInputParamList[i].getType();
                    if (pParamType.isComplex() && ((this._pUsedVarTypeMap[pParamType._getInstructionID()]) !== undefined) && this._pUsedVarTypeMap[pParamType._getInstructionID()].isRead) {
                        /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.setError(2301, {
                            funcName: ((((this)._pFunctionDefenition)._pFunctionName.getName()))
                        });
                        return;
                    }
                }
                var pOutVariable = this._getOutVariable();
                if (!((pOutVariable) === null)) {
                    if (((this._pUsedVarTypeMap[pOutVariable.getType()._getInstructionID()]) !== undefined) && this._pUsedVarTypeMap[pOutVariable.getType()._getInstructionID()].isRead) {
                        /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.setError(2302, {
                            funcName: ((((this)._pFunctionDefenition)._pFunctionName.getName()))
                        });
                        return;
                    }
                    pOutVariable._markAsShaderOutput(true);
                }
                if (((this._pFunctionDefenition)._isComplexShaderInput)) {
                    pShaderInputParamList[0].setVisible(false);
                }
                this._pImplementation.prepareFor(akra.EFunctionType.k_Vertex);
                ((this._pFunctionDefenition)._bShaderDef = (true));
                this.generatesVertexAttrubutes();
                this.generateVertexVaryings();
            };
            FunctionDeclInstruction.prototype._prepareForPixel = function () {
                ((this)._eFunctionType = (/*checked (origin: akra)>>*/akra.EFunctionType.k_Pixel));
                var pShaderInputParamList = ((this._pFunctionDefenition)._pParamListForShaderInput);
                for(var i = 0; i < pShaderInputParamList.length; i++) {
                    var pParamType = pShaderInputParamList[i].getType();
                    if (pParamType.isComplex() && ((this._pUsedVarTypeMap[pParamType._getInstructionID()]) !== undefined) && this._pUsedVarTypeMap[pParamType._getInstructionID()].isRead) {
                        /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.setError(2301, {
                            funcName: ((((this)._pFunctionDefenition)._pFunctionName.getName()))
                        });
                        return;
                    }
                }
                if (((this._pFunctionDefenition)._isComplexShaderInput)) {
                    pShaderInputParamList[0].setVisible(false);
                }
                this._pImplementation.prepareFor(akra.EFunctionType.k_Pixel);
                ((this._pFunctionDefenition)._bShaderDef = (true));
                this.generatePixelVaryings();
            };
            FunctionDeclInstruction.prototype._setOutVariable = function (pVar) {
                this._pOutVariable = pVar;
            };
            FunctionDeclInstruction.prototype._setUsedFunctions = function (pUsedFunctionMap, pUsedFunctionList) {
                this._pUsedFunctionMap = pUsedFunctionMap;
                this._pUsedFunctionList = pUsedFunctionList;
            };
            FunctionDeclInstruction.prototype._setUsedVariableData = function (pUsedVarTypeMap, pSharedVariableMap, pGlobalVariableMap, pUniformVariableMap, pForeignVariableMap, pTextureVariableMap, pUsedComplexTypeMap) {
                this._pUsedVarTypeMap = pUsedVarTypeMap;
                this._pSharedVariableMap = pSharedVariableMap;
                this._pGlobalVariableMap = pGlobalVariableMap;
                this._pUniformVariableMap = pUniformVariableMap;
                this._pForeignVariableMap = pForeignVariableMap;
                this._pTextureVariableMap = pTextureVariableMap;
                this._pUsedComplexTypeMap = pUsedComplexTypeMap;
            };
            FunctionDeclInstruction.prototype._initAfterClone = function () {
                this._pFunctionDefenition = this._pInstructionList[0];
                this._pImplementation = this._pInstructionList[1];
            };
            FunctionDeclInstruction.prototype._generateInfoAboutUsedData = function () {
                if (!((this._pUsedVarTypeMap) === null)) {
                    return;
                }
                var pUsedData = {};
                this._pImplementation.addUsedData(pUsedData);
                this._pUsedVarTypeMap = pUsedData;
                if (((this._pUsedComplexTypeMap) === null)) {
                    this._pSharedVariableMap = {};
                    this._pGlobalVariableMap = {};
                    this._pUniformVariableMap = {};
                    this._pForeignVariableMap = {};
                    this._pTextureVariableMap = {};
                    this._pUsedComplexTypeMap = {};
                }
                //this.addUsedComplexType(this.getReturnType().getBaseType());
                for(var i in pUsedData) {
                    var pAnalyzedInfo = pUsedData[i];
                    var pAnalyzedType = pAnalyzedInfo.type;
                    if (pAnalyzedType._isInGlobalScope()) {
                        this.addGlobalVariableType(pAnalyzedType, pAnalyzedInfo.isWrite, pAnalyzedInfo.isRead);
                    } else if (pAnalyzedType.isUniform()) {
                        this.addUniformParameter(pAnalyzedType);
                    } else if (pAnalyzedType._getScope() < ((this)._iImplementationScope)) {
                        if (!this._isUsedAsFunction()) {
                            if (!((this._getOutVariable()) === null) && this._getOutVariable().getType() !== pAnalyzedType) {
                                this.addUsedComplexType(pAnalyzedType.getBaseType());
                            }
                        }
                    }
                }
                if (!((this._pUsedFunctionList) === null)) {
                    for(var j = 0; j < this._pUsedFunctionList.length; j++) {
                        this.addUsedInfoFromFunction(this._pUsedFunctionList[j]);
                    }
                }
            };
            FunctionDeclInstruction.prototype._getAttributeVariableMap = /** @inline */function () {
                return this._pAttributeVariableMap;
            };
            FunctionDeclInstruction.prototype._getVaryingVariableMap = /** @inline */function () {
                return this._pVaryingVariableMap;
            };
            FunctionDeclInstruction.prototype._getSharedVariableMap = /** @inline */function () {
                return this._pSharedVariableMap;
            };
            FunctionDeclInstruction.prototype._getGlobalVariableMap = /** @inline */function () {
                return this._pGlobalVariableMap;
            };
            FunctionDeclInstruction.prototype._getUniformVariableMap = /** @inline */function () {
                return this._pUniformVariableMap;
            };
            FunctionDeclInstruction.prototype._getForeignVariableMap = /** @inline */function () {
                return this._pForeignVariableMap;
            };
            FunctionDeclInstruction.prototype._getTextureVariableMap = /** @inline */function () {
                return this._pTextureVariableMap;
            };
            FunctionDeclInstruction.prototype._getUsedComplexTypeMap = /** @inline */function () {
                return this._pUsedComplexTypeMap;
            };
            FunctionDeclInstruction.prototype._getAttributeVariableKeys = function () {
                if (((this._pAttributeVariableKeys) === null) && !((this._pAttributeVariableMap) === null)) {
                    this._pAttributeVariableKeys = Object.keys(this._pAttributeVariableMap);
                }
                return this._pAttributeVariableKeys;
            };
            FunctionDeclInstruction.prototype._getVaryingVariableKeys = function () {
                if (((this._pVaryingVariableKeys) === null) && !((this._pVaryingVariableMap) === null)) {
                    this._pVaryingVariableKeys = Object.keys(this._pVaryingVariableMap);
                }
                return this._pVaryingVariableKeys;
            };
            FunctionDeclInstruction.prototype._getSharedVariableKeys = function () {
                if (((this._pSharedVariableKeys) === null) && !((this._pSharedVariableMap) === null)) {
                    this._pSharedVariableKeys = Object.keys(this._pSharedVariableMap);
                }
                return this._pSharedVariableKeys;
            };
            FunctionDeclInstruction.prototype._getUniformVariableKeys = function () {
                if (((this._pUniformVariableKeys) === null) && !((this._pUniformVariableMap) === null)) {
                    this._pUniformVariableKeys = Object.keys(this._pUniformVariableMap);
                }
                return this._pUniformVariableKeys;
            };
            FunctionDeclInstruction.prototype._getForeignVariableKeys = function () {
                if (((this._pForeignVariableKeys) === null) && !((this._pForeignVariableMap) === null)) {
                    this._pForeignVariableKeys = Object.keys(this._pForeignVariableMap);
                }
                return this._pForeignVariableKeys;
            };
            FunctionDeclInstruction.prototype._getGlobalVariableKeys = function () {
                if (((this._pGlobalVariableKeys) === null) && !((this._pGlobalVariableMap) === null)) {
                    this._pGlobalVariableKeys = Object.keys(this._pGlobalVariableMap);
                }
                return this._pGlobalVariableKeys;
            };
            FunctionDeclInstruction.prototype._getTextureVariableKeys = function () {
                if (((this._pTextureVariableKeys) === null) && !((this._pTextureVariableMap) === null)) {
                    this._pTextureVariableKeys = Object.keys(this._pTextureVariableMap);
                }
                return this._pTextureVariableKeys;
            };
            FunctionDeclInstruction.prototype._getUsedComplexTypeKeys = function () {
                if (((this._pUsedComplexTypeKeys) === null)) {
                    this._pUsedComplexTypeKeys = Object.keys(this._pUsedComplexTypeMap);
                }
                return this._pUsedComplexTypeKeys;
            };
            FunctionDeclInstruction.prototype._getExtSystemFunctionList = function () {
                return this._pExtSystemFunctionList;
            };
            FunctionDeclInstruction.prototype._getExtSystemMacrosList = function () {
                return this._pExtSystemMacrosList;
            };
            FunctionDeclInstruction.prototype._getExtSystemTypeList = function () {
                return this._pExtSystemTypeList;
            };
            FunctionDeclInstruction.prototype.generatesVertexAttrubutes = function () {
                var pShaderInputParamList = ((this._pFunctionDefenition)._pParamListForShaderInput);
                var isComplexInput = ((this._pFunctionDefenition)._isComplexShaderInput);
                this._pAttributeVariableMap = {};
                if (isComplexInput) {
                    var pContainerVariable = pShaderInputParamList[0];
                    var pContainerType = pContainerVariable.getType();
                    var pAttributeNames = pContainerType.getFieldNameList();
                    for(var i = 0; i < pAttributeNames.length; i++) {
                        var pAttr = pContainerType.getField(pAttributeNames[i]);
                        if (!this.isVariableTypeUse(pAttr.getType())) {
                            continue;
                        }
                        this._pAttributeVariableMap[pAttr._getInstructionID()] = pAttr;
                        this.generateExtractBlockForAttribute(pAttr);
                    }
                } else {
                    for(var i = 0; i < pShaderInputParamList.length; i++) {
                        var pAttr = pShaderInputParamList[i];
                        if (!this.isVariableTypeUse(pAttr.getType())) {
                            continue;
                        }
                        this._pAttributeVariableMap[pAttr._getInstructionID()] = pAttr;
                        this.generateExtractBlockForAttribute(pAttr);
                    }
                }
                this._pAttributeVariableKeys = this._getAttributeVariableKeys();
            };
            FunctionDeclInstruction.prototype.generateVertexVaryings = function () {
                if (((this._getOutVariable()) === null)) {
                    return;
                }
                this._pVaryingVariableMap = {};
                var pContainerVariable = this._getOutVariable();
                var pContainerType = pContainerVariable.getType();
                var pVaryingNames = pContainerType.getFieldNameList();
                for(var i = 0; i < pVaryingNames.length; i++) {
                    var pVarying = pContainerType.getField(pVaryingNames[i]);
                    if (!this.isVariableTypeUse(pVarying.getType())) {
                        continue;
                    }
                    this._pVaryingVariableMap[pVarying._getInstructionID()] = pVarying;
                }
                this._pVaryingVariableKeys = this._getVaryingVariableKeys();
            };
            FunctionDeclInstruction.prototype.generatePixelVaryings = function () {
                var pShaderInputParamList = ((this._pFunctionDefenition)._pParamListForShaderInput);
                var isComplexInput = ((this._pFunctionDefenition)._isComplexShaderInput);
                this._pVaryingVariableMap = {};
                if (isComplexInput) {
                    var pContainerVariable = pShaderInputParamList[0];
                    var pContainerType = pContainerVariable.getType();
                    var pVaryingNames = pContainerType.getFieldNameList();
                    for(var i = 0; i < pVaryingNames.length; i++) {
                        var pVarying = pContainerType.getField(pVaryingNames[i]);
                        if (!this.isVariableTypeUse(pVarying.getType())) {
                            continue;
                        }
                        this._pVaryingVariableMap[pVarying._getInstructionID()] = pVarying;
                    }
                } else {
                    for(var i = 0; i < pShaderInputParamList.length; i++) {
                        var pVarying = pShaderInputParamList[i];
                        if (!this.isVariableTypeUse(pVarying.getType())) {
                            continue;
                        }
                        this._pVaryingVariableMap[pVarying._getInstructionID()] = pVarying;
                    }
                }
                this._pVaryingVariableKeys = this._getVaryingVariableKeys();
            };
            FunctionDeclInstruction.prototype.cloneVarTypeUsedMap = function (pMap, pRelationMap) {
                var pCloneMap = {};
                for(var j in pMap) {
                    var pType = ((pRelationMap[j]) !== undefined) ? pRelationMap[j] : pMap[j].type;
                    var id = pType._getInstructionID();
                    pCloneMap[id] = {
                        type: pType,
                        isRead: pMap[j].isRead,
                        isWrite: pMap[j].isWrite,
                        numRead: pMap[j].numRead,
                        numWrite: pMap[j].numWrite,
                        numUsed: pMap[j].numUsed
                    };
                }
                return pCloneMap;
            };
            FunctionDeclInstruction.prototype.cloneVarDeclMap = function (pMap, pRelationMap) {
                var pCloneMap = {};
                for(var i in pMap) {
                    var pVar = ((pRelationMap[i]) !== undefined) ? pRelationMap[i] : pMap[i];
                    if (!((pVar) === null)) {
                        var id = pVar._getInstructionID();
                        pCloneMap[id] = pVar;
                    }
                }
                return pCloneMap;
            };
            FunctionDeclInstruction.prototype.cloneTypeMap = function (pMap, pRelationMap) {
                var pCloneMap = {};
                for(var i in pMap) {
                    var pVar = (((pRelationMap[i]) !== undefined) ? pRelationMap[i] : pMap[i]);
                    var id = pVar._getInstructionID();
                    pCloneMap[id] = pVar;
                }
                return pCloneMap;
            };
            FunctionDeclInstruction.prototype.addGlobalVariableType = function (pVariableType, isWrite, isRead) {
                if (!pVariableType.isFromVariableDecl()) {
                    return;
                }
                var pVariable = pVariableType._getParentVarDecl();
                var pMainVariable = pVariableType._getMainVariable();
                var iMainVar = pMainVariable._getInstructionID();
                var iVar = pVariable._getInstructionID();
                if (pMainVariable.getType().isShared()) {
                    // this._pSharedVariableMap[iVar] = pVariable;
                    this._pSharedVariableMap[iMainVar] = pMainVariable;
                } else if (pMainVariable.getType().isForeign()) {
                    this._pForeignVariableMap[iMainVar] = pMainVariable;
                } else if (isWrite || pMainVariable.getType().isConst()) {
                    this._pGlobalVariableMap[iMainVar] = pMainVariable;
                    if (((this._pUniformVariableMap[iMainVar]) != null)) {
                        this._pUniformVariableMap[iMainVar] = null;
                    }
                } else {
                    if (!((this._pGlobalVariableMap[iMainVar]) !== undefined)) {
                        this._pUniformVariableMap[iMainVar] = pMainVariable;
                        if (!pMainVariable.getType().isComplex() && pMainVariable.hasConstantInitializer()) {
                            pMainVariable.prepareDefaultValue();
                        }
                    }
                }
                if (pVariable.isSampler() && pVariable.hasInitializer()) {
                    var pInitExpr = pVariable.getInitializeExpr();
                    var pTexture = null;
                    var pSamplerStates = null;
                    if (pVariableType.isArray()) {
                        var pList = pInitExpr.getInstructions();
                        for(var i = 0; i < pList.length; i++) {
                            pSamplerStates = pList[i].getInstructions()[0];
                            pTexture = (pSamplerStates._pTexture);
                            this._pTextureVariableMap[pTexture._getInstructionID()] = pTexture;
                        }
                    } else {
                        pSamplerStates = pInitExpr.getInstructions()[0];
                        pTexture = (pSamplerStates._pTexture);
                        this._pTextureVariableMap[pTexture._getInstructionID()] = pTexture;
                    }
                }
                // this.addUsedComplexType(pMainVariable.getType().getBaseType());
                            };
            FunctionDeclInstruction.prototype.addUniformParameter = function (pType) {
                var pMainVariable = pType._getMainVariable();
                var iMainVar = pMainVariable._getInstructionID();
                if (((this._pGlobalVariableMap[iMainVar]) !== undefined)) {
 {
                        akra.logger.setSourceLocation("fx/FunctionInstruction.ts", 843);
                        akra.logger.error("UNEXPECTED ERROR WITH UNIFORM_PARAMETER");
                    }
                    ;
                }
                this._pUniformVariableMap[iMainVar] = pMainVariable;
                this.addUsedComplexType(pMainVariable.getType().getBaseType());
                if (!pMainVariable.getType().isComplex() && pMainVariable.hasConstantInitializer()) {
                    pMainVariable.prepareDefaultValue();
                }
            };
            FunctionDeclInstruction.prototype.addUsedComplexType = function (pType) {
                if (pType.isBase() || ((this._pUsedComplexTypeMap[pType._getInstructionID()]) !== undefined)) {
                    return;
                }
                this._pUsedComplexTypeMap[pType._getInstructionID()] = pType;
                var pFieldNameList = pType.getFieldNameList();
                for(var i = 0; i < pFieldNameList.length; i++) {
                    this.addUsedComplexType(pType.getFieldType(pFieldNameList[i]).getBaseType());
                }
            };
            FunctionDeclInstruction.prototype.addUsedInfoFromFunction = function (pFunction) {
                pFunction._generateInfoAboutUsedData();
                var pSharedVarMap = pFunction._getSharedVariableMap();
                var pGlobalVarMap = pFunction._getGlobalVariableMap();
                var pUniformVarMap = pFunction._getUniformVariableMap();
                var pForeignVarMap = pFunction._getForeignVariableMap();
                var pTextureVarMap = pFunction._getTextureVariableMap();
                var pUsedComplexTypeMap = pFunction._getUsedComplexTypeMap();
                for(var j in pSharedVarMap) {
                    this._pSharedVariableMap[pSharedVarMap[j]._getInstructionID()] = pSharedVarMap[j];
                }
                for(var j in pForeignVarMap) {
                    this._pForeignVariableMap[pForeignVarMap[j]._getInstructionID()] = pForeignVarMap[j];
                }
                for(var j in pTextureVarMap) {
                    this._pTextureVariableMap[pTextureVarMap[j]._getInstructionID()] = pTextureVarMap[j];
                }
                for(var j in pGlobalVarMap) {
                    this._pGlobalVariableMap[pGlobalVarMap[j]._getInstructionID()] = pGlobalVarMap[j];
                    if (((this._pUniformVariableMap[pGlobalVarMap[j]._getInstructionID()]) != null)) {
                        this._pUniformVariableMap[pGlobalVarMap[j]._getInstructionID()] = null;
                    }
                }
                for(var j in pUniformVarMap) {
                    if (!((this._pGlobalVariableMap[pUniformVarMap[j]._getInstructionID()]) !== undefined)) {
                        this._pUniformVariableMap[pUniformVarMap[j]._getInstructionID()] = pUniformVarMap[j];
                    }
                }
                for(var j in pUsedComplexTypeMap) {
                    this._pUsedComplexTypeMap[pUsedComplexTypeMap[j]._getInstructionID()] = pUsedComplexTypeMap[j];
                }
                this.addExtSystemFunction(pFunction);
            };
            FunctionDeclInstruction.prototype.addExtSystemFunction = function (pFunction) {
                if (((this._pExtSystemFunctionList) === null)) {
                    this._pExtSystemFunctionList = [];
                    this._pExtSystemTypeList = [];
                    this._pExtSystemMacrosList = [];
                }
                if (pFunction._getInstructionType() === akra.EAFXInstructionTypes.k_SystemFunctionInstruction) {
                    if (this._pExtSystemFunctionList.indexOf(pFunction) !== -1) {
                        return;
                    }
                    this._pExtSystemFunctionList.push(pFunction);
                }
                var pTypes = pFunction._getExtSystemTypeList();
                var pMacroses = pFunction._getExtSystemMacrosList();
                var pFunctions = pFunction._getExtSystemFunctionList();
                if (!((pTypes) === null)) {
                    for(var j = 0; j < pTypes.length; j++) {
                        if (this._pExtSystemTypeList.indexOf(pTypes[j]) === -1) {
                            this._pExtSystemTypeList.push(pTypes[j]);
                        }
                    }
                }
                if (!((pMacroses) === null)) {
                    for(var j = 0; j < pMacroses.length; j++) {
                        if (this._pExtSystemMacrosList.indexOf(pMacroses[j]) === -1) {
                            this._pExtSystemMacrosList.push(pMacroses[j]);
                        }
                    }
                }
                if (!((pFunctions) === null)) {
                    for(var j = 0; j < pFunctions.length; j++) {
                        if (this._pExtSystemFunctionList.indexOf(pFunctions[j]) === -1) {
                            this._pExtSystemFunctionList.unshift(pFunctions[j]);
                        }
                    }
                }
            };
            FunctionDeclInstruction.prototype.isVariableTypeUse = function (pVariableType) {
                var id = pVariableType._getInstructionID();
                if (!((this._pUsedVarTypeMap[id]) !== undefined)) {
                    return false;
                }
                if (this._pUsedVarTypeMap[id].numUsed === 0) {
                    return false;
                }
                return true;
            };
            FunctionDeclInstruction.prototype.generateExtractBlockForAttribute = function (pAttr) {
                if (!pAttr.getType().isPointer()) {
                    return null;
                }
                var pExtractCollector = new fx.InstructionCollector();
                var pMainPointer = pAttr.getType()._getMainPointer();
                pAttr._setAttrExtractionBlock(pExtractCollector);
                this.generateExtractStmtFromPointer(pMainPointer, null, 0, pExtractCollector);
                pAttr.getType().getSubVarDecls();
                return pExtractCollector;
            };
            FunctionDeclInstruction.prototype.generateExtractStmtFromPointer = function (pPointer, pOffset, iDepth, pCollector) {
                var pPointerType = pPointer.getType();
                var pWhatExtracted = pPointerType._getDownPointer();
                var pWhatExtractedType = null;
                while(!((pWhatExtracted) === null)) {
                    pWhatExtractedType = pWhatExtracted.getType();
                    if (!pWhatExtractedType.isPointIndex() && iDepth === 0) {
                        pOffset = this.createOffsetForAttr(pWhatExtracted);
                    }
                    if (!pWhatExtractedType.isComplex()) {
                        var pSingleExtract = new fx.ExtractStmtInstruction();
                        pSingleExtract.generateStmtForBaseType(pWhatExtracted, pWhatExtractedType.getPointer(), pWhatExtractedType.getVideoBuffer(), 0, pWhatExtractedType.isPointIndex() ? null : pOffset);
                        this._addUsedFunction(pSingleExtract.getExtractFunction());
                        pCollector.push(pSingleExtract, true);
                    } else {
                        iDepth++;
                        this.generateExtractStmtForComplexVar(pWhatExtracted, iDepth <= 1 ? pOffset : null, iDepth, pCollector, pWhatExtractedType.getPointer(), pWhatExtractedType.getVideoBuffer(), 0);
                    }
                    pWhatExtracted = pWhatExtractedType._getDownPointer();
                }
            };
            FunctionDeclInstruction.prototype.generateExtractStmtForComplexVar = function (pVarDecl, pOffset, iDepth, pCollector, pPointer, pBuffer, iPadding) {
                var pVarType = pVarDecl.getType();
                var pFieldNameList = pVarType.getFieldNameList();
                var pField = null;
                var pFieldType = null;
                var pSingleExtract = null;
                var isNeedPadding = false;
                for(var i = 0; i < pFieldNameList.length; i++) {
                    pField = pVarType.getField(pFieldNameList[i]);
                    if (((pField) === null)) {
                        continue;
                    }
                    pFieldType = pField.getType();
                    if (iDepth <= 1) {
                        pOffset = this.createOffsetForAttr(pField);
                        isNeedPadding = false;
                    } else {
                        isNeedPadding = true;
                    }
                    if (pFieldType.isPointer()) {
                        var pFieldPointer = pFieldType._getMainPointer();
                        pSingleExtract = new fx.ExtractStmtInstruction();
                        pSingleExtract.generateStmtForBaseType(pFieldPointer, pPointer, pFieldType.getVideoBuffer(), isNeedPadding ? (iPadding + pFieldType.getPadding()) : 0, pOffset);
                        this._addUsedFunction(pSingleExtract.getExtractFunction());
                        pCollector.push(pSingleExtract, true);
                        this.generateExtractStmtFromPointer(pFieldPointer, pOffset, iDepth, pCollector);
                    } else if (pFieldType.isComplex()) {
                        iDepth++;
                        this.generateExtractStmtForComplexVar(pField, pOffset, iDepth, pCollector, pPointer, pBuffer, isNeedPadding ? (iPadding + pFieldType.getPadding()) : 0);
                    } else {
                        pSingleExtract = new fx.ExtractStmtInstruction();
                        pSingleExtract.generateStmtForBaseType(pField, pPointer, pBuffer, isNeedPadding ? (iPadding + pFieldType.getPadding()) : 0, pOffset);
                        this._addUsedFunction(pSingleExtract.getExtractFunction());
                        pCollector.push(pSingleExtract, true);
                    }
                }
            };
            FunctionDeclInstruction.prototype.createOffsetForAttr = function (pAttr) {
                var pOffset = new fx.VariableDeclInstruction();
                var pOffsetType = new fx.VariableTypeInstruction();
                var pOffsetId = new fx.IdInstruction();
                pOffsetType.pushType(fx.Effect.getSystemType("float"));
                pOffsetType.addUsage("uniform");
                pOffsetId.setName("offset");
                pOffsetId.setRealName(pAttr.getRealName() + "_o");
                pOffset.push(pOffsetType, true);
                pOffset.push(pOffsetId, true);
                pOffset.setParent(pAttr);
                pOffset.setSemantic(pAttr.getSemantic());
                pAttr.getType()._addAttrOffset(pOffset);
                return pOffset;
            };
            return FunctionDeclInstruction;
        })(fx.DeclInstruction);
        fx.FunctionDeclInstruction = FunctionDeclInstruction;        
        var SystemFunctionInstruction = (function (_super) {
            __extends(SystemFunctionInstruction, _super);
            function SystemFunctionInstruction(sName, pReturnType, pExprTranslator, pArgumentTypes) {
                        _super.call(this);
                this._pExprTranslator = null;
                this._pName = null;
                this._pReturnType = null;
                this._pArguments = null;
                this._sDefinition = "";
                this._sImplementation = "";
                this._pExtSystemTypeList = null;
                this._pExtSystemFunctionList = null;
                this._pExtSystemMacrosList = null;
                this._eInstructionType = akra.EAFXInstructionTypes.k_SystemFunctionInstruction;
                this._pName = new fx.IdInstruction();
                this._pName.setName(sName);
                this._pName.setParent(this);
                this._pReturnType = new fx.VariableTypeInstruction();
                this._pReturnType.pushType(pReturnType);
                ((this._pReturnType)._pParentInstruction = (this));
                this._pArguments = [];
                if (!((pArgumentTypes) === null)) {
                    for(var i = 0; i < pArgumentTypes.length; i++) {
                        var pArgument = new fx.TypedInstruction();
                        pArgument.setType(pArgumentTypes[i]);
                        (pArgument._pParentInstruction = (this));
                        this._pArguments.push(pArgument);
                    }
                }
                this._pExprTranslator = pExprTranslator;
            }
            SystemFunctionInstruction.prototype.setDeclCode = function (sDefenition, sImplementation) {
                this._sDefinition = sDefenition;
                this._sImplementation = sImplementation;
            };
            SystemFunctionInstruction.prototype.toFinalCode = function () {
                return this._sDefinition + this._sImplementation;
            };
            SystemFunctionInstruction.prototype.toFinalDefCode = function () {
                return this._sDefinition;
            };
            SystemFunctionInstruction.prototype.setUsedSystemData = function (pTypeList, pFunctionList, pMacrosList) {
                this._pExtSystemTypeList = pTypeList;
                this._pExtSystemFunctionList = pFunctionList;
                this._pExtSystemMacrosList = pMacrosList;
            };
            SystemFunctionInstruction.prototype.closeSystemDataInfo = function () {
                for(var i = 0; i < this._pExtSystemFunctionList.length; i++) {
                    var pFunction = this._pExtSystemFunctionList[i];
                    var pTypes = pFunction._getExtSystemTypeList();
                    var pMacroses = pFunction._getExtSystemMacrosList();
                    var pFunctions = pFunction._getExtSystemFunctionList();
                    for(var j = 0; j < pTypes.length; j++) {
                        if (this._pExtSystemTypeList.indexOf(pTypes[j]) === -1) {
                            this._pExtSystemTypeList.push(pTypes[j]);
                        }
                    }
                    for(var j = 0; j < pMacroses.length; j++) {
                        if (this._pExtSystemMacrosList.indexOf(pMacroses[j]) === -1) {
                            this._pExtSystemMacrosList.push(pMacroses[j]);
                        }
                    }
                    for(var j = 0; j < pFunctions.length; j++) {
                        if (this._pExtSystemFunctionList.indexOf(pFunctions[j]) === -1) {
                            this._pExtSystemFunctionList.unshift(pFunctions[j]);
                        }
                    }
                }
            };
            SystemFunctionInstruction.prototype.setExprTranslator = function (pExprTranslator) {
                this._pExprTranslator = pExprTranslator;
            };
            SystemFunctionInstruction.prototype.getNameId = function () {
                return this._pName;
            };
            SystemFunctionInstruction.prototype.getArguments = function () {
                return this._pArguments;
            };
            SystemFunctionInstruction.prototype.getNumNeededArguments = /** @inline */function () {
                return this._pArguments.length;
            };
            SystemFunctionInstruction.prototype.hasImplementation = /** @inline */function () {
                return true;
            };
            SystemFunctionInstruction.prototype.getType = /** @inline */function () {
                return ((this)._pReturnType);
            };
            SystemFunctionInstruction.prototype.getReturnType = /** @inline */function () {
                return this._pReturnType;
            };
            SystemFunctionInstruction.prototype.getFunctionType = /** @inline */function () {
                return akra.EFunctionType.k_Function;
            };
            SystemFunctionInstruction.prototype.setFunctionType = /** @inline */function (eFunctionType) {
            };
            SystemFunctionInstruction.prototype.closeArguments = function (pArguments) {
                return this._pExprTranslator.toInstructionList(pArguments);
            };
            SystemFunctionInstruction.prototype.setFunctionDef = function (pFunctionDef) {
            };
            SystemFunctionInstruction.prototype.setImplementation = function (pImplementation) {
            };
            SystemFunctionInstruction.prototype.clone = /** @inline */function (pRelationMap) {
                return this;
            };
            SystemFunctionInstruction.prototype._addOutVariable = function (pVariable) {
                return false;
            };
            SystemFunctionInstruction.prototype._getOutVariable = function () {
                return null;
            };
            SystemFunctionInstruction.prototype._getVertexShader = function () {
                return null;
            };
            SystemFunctionInstruction.prototype._getPixelShader = function () {
                return null;
            };
            SystemFunctionInstruction.prototype._markUsedAs = function (eUsedType) {
            };
            SystemFunctionInstruction.prototype._isUsedAs = function (eUsedType) {
                return true;
            };
            SystemFunctionInstruction.prototype._isUsedAsFunction = function () {
                return true;
            };
            SystemFunctionInstruction.prototype._isUsedAsVertex = function () {
                return true;
            };
            SystemFunctionInstruction.prototype._isUsedAsPixel = function () {
                return true;
            };
            SystemFunctionInstruction.prototype._markUsedInVertex = function () {
            };
            SystemFunctionInstruction.prototype._markUsedInPixel = function () {
            };
            SystemFunctionInstruction.prototype._isUsedInVertex = function () {
                return null;
            };
            SystemFunctionInstruction.prototype._isUsedInPixel = function () {
                return null;
            };
            SystemFunctionInstruction.prototype._isUsed = function () {
                return null;
            };
            SystemFunctionInstruction.prototype._checkVertexUsage = function () {
                return ((this)._bForVertex);
            };
            SystemFunctionInstruction.prototype._checkPixelUsage = function () {
                return ((this)._bForPixel);
            };
            SystemFunctionInstruction.prototype._checkDefenitionForVertexUsage = function () {
                return false;
            };
            SystemFunctionInstruction.prototype._checkDefenitionForPixelUsage = function () {
                return false;
            };
            SystemFunctionInstruction.prototype._canUsedAsFunction = function () {
                return true;
            };
            SystemFunctionInstruction.prototype._notCanUsedAsFunction = function () {
            };
            SystemFunctionInstruction.prototype._addUsedFunction = function (pFunction) {
                return false;
            };
            SystemFunctionInstruction.prototype._addUsedVariable = function (pVariable) {
            };
            SystemFunctionInstruction.prototype._getUsedFunctionList = function () {
                return null;
            };
            SystemFunctionInstruction.prototype._isBlackListFunction = function () {
                return false;
            };
            SystemFunctionInstruction.prototype._addToBlackList = function () {
            };
            SystemFunctionInstruction.prototype._getStringDef = function () {
                return "system_func";
            };
            SystemFunctionInstruction.prototype._convertToVertexShader = function () {
                return null;
            };
            SystemFunctionInstruction.prototype._convertToPixelShader = function () {
                return null;
            };
            SystemFunctionInstruction.prototype._prepareForVertex = function () {
            };
            SystemFunctionInstruction.prototype._prepareForPixel = function () {
            };
            SystemFunctionInstruction.prototype.addUsedVariableType = function (pType, eUsedMode) {
                return false;
            };
            SystemFunctionInstruction.prototype._generateInfoAboutUsedData = function () {
            };
            SystemFunctionInstruction.prototype._getAttributeVariableMap = /** @inline */function () {
                return null;
            };
            SystemFunctionInstruction.prototype._getVaryingVariableMap = /** @inline */function () {
                return null;
            };
            SystemFunctionInstruction.prototype._getSharedVariableMap = /** @inline */function () {
                return null;
            };
            SystemFunctionInstruction.prototype._getGlobalVariableMap = /** @inline */function () {
                return null;
            };
            SystemFunctionInstruction.prototype._getUniformVariableMap = /** @inline */function () {
                return null;
            };
            SystemFunctionInstruction.prototype._getForeignVariableMap = /** @inline */function () {
                return null;
            };
            SystemFunctionInstruction.prototype._getTextureVariableMap = /** @inline */function () {
                return null;
            };
            SystemFunctionInstruction.prototype._getUsedComplexTypeMap = /** @inline */function () {
                return null;
            };
            SystemFunctionInstruction.prototype._getAttributeVariableKeys = /** @inline */function () {
                return null;
            };
            SystemFunctionInstruction.prototype._getVaryingVariableKeys = /** @inline */function () {
                return null;
            };
            SystemFunctionInstruction.prototype._getSharedVariableKeys = /** @inline */function () {
                return null;
            };
            SystemFunctionInstruction.prototype._getUniformVariableKeys = /** @inline */function () {
                return null;
            };
            SystemFunctionInstruction.prototype._getForeignVariableKeys = /** @inline */function () {
                return null;
            };
            SystemFunctionInstruction.prototype._getGlobalVariableKeys = /** @inline */function () {
                return null;
            };
            SystemFunctionInstruction.prototype._getTextureVariableKeys = /** @inline */function () {
                return null;
            };
            SystemFunctionInstruction.prototype._getUsedComplexTypeKeys = /** @inline */function () {
                return null;
            };
            SystemFunctionInstruction.prototype._getExtSystemFunctionList = function () {
                return this._pExtSystemFunctionList;
            };
            SystemFunctionInstruction.prototype._getExtSystemMacrosList = function () {
                return this._pExtSystemMacrosList;
            };
            SystemFunctionInstruction.prototype._getExtSystemTypeList = function () {
                return this._pExtSystemTypeList;
            };
            return SystemFunctionInstruction;
        })(fx.DeclInstruction);
        fx.SystemFunctionInstruction = SystemFunctionInstruction;        
        /**
        * Represent type func(...args)[:Semantic]
        * EMPTY_OPERTOR VariableTypeInstruction IdInstruction VarDeclInstruction ... VarDeclInstruction
        */
        var FunctionDefInstruction = (function (_super) {
            __extends(FunctionDefInstruction, _super);
            //private _sHash: string = "";
            function FunctionDefInstruction() {
                        _super.call(this);
                this._pParameterList = null;
                this._pParamListForShaderCompile = null;
                this._pParamListForShaderInput = null;
                this._isComplexShaderInput = false;
                this._pReturnType = null;
                this._pFunctionName = null;
                this._nParamsNeeded = 0;
                this._sDefinition = "";
                this._isAnalyzedForVertexUsage = false;
                this._isAnalyzedForPixelUsage = false;
                this._bCanUsedAsFunction = true;
                this._bShaderDef = false;
                this._pInstructionList = null;
                this._pParameterList = [];
                this._eInstructionType = akra.EAFXInstructionTypes.k_FunctionDefInstruction;
            }
            FunctionDefInstruction.prototype.toFinalCode = function () {
                var sCode = "";
                if (!((this)._bShaderDef)) {
                    sCode += this._pReturnType.toFinalCode();
                    sCode += " " + this._pFunctionName.toFinalCode();
                    sCode += "(";
                    for(var i = 0; i < this._pParameterList.length; i++) {
                        sCode += this._pParameterList[i].toFinalCode();
                        if (i !== this._pParameterList.length - 1) {
                            sCode += ",";
                        }
                    }
                    sCode += ")";
                } else {
                    sCode = "void " + this._pFunctionName.toFinalCode() + "()";
                }
                return sCode;
            };
            FunctionDefInstruction.prototype.setType = /** @inline */function (pType) {
                /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.setReturnType(pType);
            };
            FunctionDefInstruction.prototype.getType = /** @inline */function () {
                return ((this)._pReturnType);
            };
            FunctionDefInstruction.prototype.setReturnType = /** @inline */function (pReturnType) {
                this._pReturnType = pReturnType;
                pReturnType.setParent(this);
                return true;
            };
            FunctionDefInstruction.prototype.getReturnType = /** @inline */function () {
                return this._pReturnType;
            };
            FunctionDefInstruction.prototype.setFunctionName = /** @inline */function (pNameId) {
                this._pFunctionName = pNameId;
                pNameId.setParent(this);
                return true;
            };
            FunctionDefInstruction.prototype.getName = /** @inline */function () {
                return this._pFunctionName.getName();
            };
            FunctionDefInstruction.prototype.getRealName = /** @inline */function () {
                return this._pFunctionName.getRealName();
            };
            FunctionDefInstruction.prototype.getNameId = /** @inline */function () {
                return this._pFunctionName;
            };
            FunctionDefInstruction.prototype.getArguments = /** @inline */function () {
                return this._pParameterList;
            };
            FunctionDefInstruction.prototype.getNumNeededArguments = /** @inline */function () {
                return this._nParamsNeeded;
            };
            FunctionDefInstruction.prototype.markAsShaderDef = /** @inline */function (isShaderDef) {
                this._bShaderDef = isShaderDef;
            };
            FunctionDefInstruction.prototype.isShaderDef = /** @inline */function () {
                return this._bShaderDef;
            };
            FunctionDefInstruction.prototype.addParameter = function (pParameter, isStrictModeOn) {
                if (this._pParameterList.length > this._nParamsNeeded && !pParameter.hasInitializer()) {
                    /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.setError(2245, {
                        funcName: this._pFunctionName.getName(),
                        varName: pParameter.getName()
                    });
                    return false;
                }
                var pParameterType = pParameter.getType();
                if (pParameterType.isPointer() || pParameterType._containPointer()) {
                    if (pParameterType.hasUsage("uniform") || pParameterType.hasUsage("out") || pParameterType.hasUsage("inout")) {
                        /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this.setError(2265, {
                            funcName: this._pFunctionName.getName(),
                            varName: pParameter.getName()
                        });
                        return false;
                    }
                    this._isAnalyzedForVertexUsage = false;
                    this._isAnalyzedForPixelUsage = true;
                    ((this)._bForPixel = (false));
                    this._bCanUsedAsFunction = false;
                    pParameterType._setVideoBufferInDepth();
                } else if (!isStrictModeOn) {
                    if (pParameterType.isComplex() && !pParameterType.hasFieldWithoutSemantic() && pParameterType.hasAllUniqueSemantics()) {
                        if (pParameter.getSemantic() === "" && pParameterType.hasAllUniqueSemantics() && !pParameterType.hasFieldWithoutSemantic()) {
                            pParameterType._addPointIndexInDepth();
                        } else {
                            pParameterType.addPointIndex(false);
                            pParameterType._setVideoBufferInDepth();
                        }
                    } else if (pParameter.getSemantic() !== "") {
                        pParameterType.addPointIndex(false);
                        pParameterType._setVideoBufferInDepth();
                    }
                }
                this._pParameterList.push(pParameter);
                pParameter.setParent(this);
                if (!pParameter.hasInitializer()) {
                    this._nParamsNeeded++;
                }
                return true;
            };
            FunctionDefInstruction.prototype.getParameListForShaderInput = /** @inline */function () {
                return this._pParamListForShaderInput;
            };
            FunctionDefInstruction.prototype.isComplexShaderInput = /** @inline */function () {
                return this._isComplexShaderInput;
            };
            FunctionDefInstruction.prototype.clone = function (pRelationMap) {
                if (typeof pRelationMap === "undefined") { pRelationMap = {}; }
                var pClone = _super.prototype.clone.call(this, pRelationMap);
                /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/pClone.setFunctionName(this._pFunctionName.clone(pRelationMap));
                /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/pClone.setReturnType(((this)._pReturnType).clone(pRelationMap));
                for(var i = 0; i < this._pParameterList.length; i++) {
                    pClone.addParameter(this._pParameterList[i].clone(pRelationMap));
                }
                var pShaderParams = [];
                for(var i = 0; i < this._pParamListForShaderInput.length; i++) {
                    pShaderParams.push(this._pParamListForShaderInput[i].clone(pRelationMap));
                }
                pClone._setShaderParams(pShaderParams, this._isComplexShaderInput);
                pClone._setAnalyzedInfo(this._isAnalyzedForVertexUsage, this._isAnalyzedForPixelUsage, this._bCanUsedAsFunction);
                return pClone;
            };
            FunctionDefInstruction.prototype._setShaderParams = function (pParamList, isComplexInput) {
                this._pParamListForShaderInput = pParamList;
                this._isComplexShaderInput = isComplexInput;
            };
            FunctionDefInstruction.prototype._setAnalyzedInfo = function (isAnalyzedForVertexUsage, isAnalyzedForPixelUsage, bCanUsedAsFunction) {
                this._isAnalyzedForVertexUsage = isAnalyzedForVertexUsage;
                this._isAnalyzedForPixelUsage = isAnalyzedForPixelUsage;
                this._bCanUsedAsFunction = bCanUsedAsFunction;
            };
            FunctionDefInstruction.prototype._getStringDef = function () {
                if (this._sDefinition === "") {
                    this._sDefinition = this._pReturnType.getHash() + " " + ((this)._pFunctionName.getName()) + "(";
                    for(var i = 0; i < this._pParameterList.length; i++) {
                        this._sDefinition += this._pParameterList[i].getType().getHash() + ",";
                    }
                    this._sDefinition += ")";
                }
                return this._sDefinition;
            };
            FunctionDefInstruction.prototype._canUsedAsFunction = function () {
                return this._bCanUsedAsFunction;
            };
            FunctionDefInstruction.prototype._checkForVertexUsage = function () {
                if (this._isAnalyzedForVertexUsage) {
                    return ((this)._bForVertex);
                }
                this._isAnalyzedForVertexUsage = true;
                var isGood = true;
                isGood = this.checkReturnTypeForVertexUsage();
                if (!isGood) {
                    ((this)._bForVertex = (false));
                    return false;
                }
                isGood = this.checkArgumentsForVertexUsage();
                if (!isGood) {
                    ((this)._bForVertex = (false));
                    return false;
                }
                ((this)._bForVertex = (true));
                return true;
            };
            FunctionDefInstruction.prototype._checkForPixelUsage = function () {
                if (this._isAnalyzedForPixelUsage) {
                    return ((this)._bForPixel);
                }
                this._isAnalyzedForPixelUsage = true;
                var isGood = true;
                isGood = this.checkReturnTypeForPixelUsage();
                if (!isGood) {
                    ((this)._bForPixel = (false));
                    return false;
                }
                isGood = this.checkArgumentsForPixelUsage();
                if (!isGood) {
                    ((this)._bForPixel = (false));
                    return false;
                }
                ((this)._bForPixel = (true));
                return true;
            };
            FunctionDefInstruction.prototype.checkReturnTypeForVertexUsage = function () {
                var pReturnType = this._pReturnType;
                var isGood = true;
                if (pReturnType.isEqual(fx.Effect.getSystemType("void"))) {
                    return true;
                }
                if (pReturnType.isComplex()) {
                    isGood = !pReturnType.hasFieldWithoutSemantic();
                    if (!isGood) {
                        return false;
                    }
                    isGood = pReturnType.hasAllUniqueSemantics();
                    if (!isGood) {
                        return false;
                    }
                    // isGood = pReturnType.hasFieldWithSematic("POSITION");
                    // if(!isGood){
                    // 	return false;
                    // }
                    isGood = !pReturnType._containSampler();
                    if (!isGood) {
                        return false;
                    }
                    isGood = !pReturnType._containPointer() && !pReturnType.isPointer();
                    if (!isGood) {
                        return false;
                    }
                    isGood = !pReturnType._containComplexType();
                    if (!isGood) {
                        return false;
                    }
                    return true;
                } else {
                    isGood = pReturnType.isEqual(fx.Effect.getSystemType("float4"));
                    if (!isGood) {
                        return false;
                    }
                    isGood = (((this)._sSemantic) === "POSITION");
                    if (!isGood) {
                        return false;
                    }
                    return true;
                }
            };
            FunctionDefInstruction.prototype.checkReturnTypeForPixelUsage = function () {
                var pReturnType = this._pReturnType;
                var isGood = true;
                if (pReturnType.isEqual(fx.Effect.getSystemType("void"))) {
                    return true;
                }
                isGood = pReturnType.isBase();
                if (!isGood) {
                    return false;
                }
                isGood = pReturnType.isEqual(fx.Effect.getSystemType("float4"));
                if (!isGood) {
                    return false;
                }
                isGood = ((this)._sSemantic) === "COLOR";
                if (!isGood) {
                    return false;
                }
                return true;
            };
            FunctionDefInstruction.prototype.checkArgumentsForVertexUsage = function () {
                var pArguments = this._pParameterList;
                var isAttributeByStruct = false;
                var isAttributeByParams = false;
                var isStartAnalyze = false;
                this._pParamListForShaderInput = [];
                this._pParamListForShaderCompile = [];
                for(var i = 0; i < pArguments.length; i++) {
                    var pParam = pArguments[i];
                    if (pParam.isUniform()) {
                        this._pParamListForShaderCompile.push(pParam);
                        continue;
                    }
                    if (!isStartAnalyze) {
                        if (pParam.getSemantic() === "") {
                            if (pParam.getType().isBase() || pParam.getType().hasFieldWithoutSemantic() || !pParam.getType().hasAllUniqueSemantics()) {
                                return false;
                            }
                            isAttributeByStruct = true;
                        } else if (pParam.getSemantic() !== "") {
                            if (pParam.getType().isComplex() && (pParam.getType().hasFieldWithoutSemantic() || !pParam.getType().hasAllUniqueSemantics())) {
                                return false;
                            }
                            isAttributeByParams = true;
                        }
                        isStartAnalyze = true;
                    } else if (isAttributeByStruct) {
                        return false;
                    } else if (isAttributeByParams) {
                        if (pParam.getSemantic() === "") {
                            return false;
                        }
                        if (pParam.getType().isComplex() && (pParam.getType().hasFieldWithoutSemantic() || !pParam.getType().hasAllUniqueSemantics())) {
                            return false;
                        }
                    }
                    this._pParamListForShaderInput.push(pParam);
                }
                if (isAttributeByStruct) {
                    this._isComplexShaderInput = true;
                }
                return true;
            };
            FunctionDefInstruction.prototype.checkArgumentsForPixelUsage = function () {
                var pArguments = this._pParameterList;
                var isVaryingsByStruct = false;
                var isVaryingsByParams = false;
                var isStartAnalyze = false;
                this._pParamListForShaderInput = [];
                this._pParamListForShaderCompile = [];
                for(var i = 0; i < pArguments.length; i++) {
                    var pParam = pArguments[i];
                    if (pParam.isUniform()) {
                        this._pParamListForShaderCompile.push(pParam);
                        continue;
                    }
                    if (!isStartAnalyze) {
                        if (pParam.getSemantic() === "") {
                            if (pParam.getType().isBase() || pParam.getType().hasFieldWithoutSemantic() || !pParam.getType().hasAllUniqueSemantics() || pParam.getType()._containSampler() || pParam.getType()._containPointer() || pParam.getType().isPointer()) {
                                return false;
                            }
                            isVaryingsByStruct = true;
                        } else if (pParam.getSemantic() !== "") {
                            if (pParam.getType().isPointer() || pParam.getType()._containPointer() || pParam.getType()._containSampler() || fx.Effect.isSamplerType(pParam.getType())) {
                                return false;
                            }
                            if (pParam.getType().isComplex() && (pParam.getType().hasFieldWithoutSemantic() || !pParam.getType().hasAllUniqueSemantics())) {
                                return false;
                            }
                            isVaryingsByParams = true;
                        }
                        isStartAnalyze = true;
                    } else if (isVaryingsByStruct) {
                        return false;
                    } else if (isVaryingsByParams) {
                        if (pParam.getSemantic() === "") {
                            return false;
                        }
                        if (pParam.getType().isPointer() || pParam.getType()._containPointer() || pParam.getType()._containSampler() || fx.Effect.isSamplerType(pParam.getType())) {
                            return false;
                        }
                        if (pParam.getType().isComplex() && (pParam.getType().hasFieldWithoutSemantic() || !pParam.getType().hasAllUniqueSemantics())) {
                            return false;
                        }
                    }
                    this._pParamListForShaderInput.push(pParam);
                }
                if (isVaryingsByStruct) {
                    this._isComplexShaderInput = true;
                }
                return true;
            };
            return FunctionDefInstruction;
        })(fx.DeclInstruction);
        fx.FunctionDefInstruction = FunctionDefInstruction;        
        // getHash(): string {
        // 	if(this._sHash === "") {
        // 		this.calcHash();
        // 	}
        // 	return this._sHash;
        // }
        // private calcHash(): void {
        // 	var sHash: string = "";
        // 	sHash = this._pFunctionName.getName();
        // 	sHash += "(";
        // 	for(var i: uint = 0; i < this._pParameterList.length; i++){
        // 		sHash += this._pParameterList[i]
        // 	}
        // }
            })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        var Effect = (function () {
            function Effect(pComposer) {
                this._pComposer = null;
                this._pParseTree = null;
                this._pAnalyzedNode = null;
                this._pEffectScope = null;
                this._pCurrentInstruction = null;
                this._pCurrentFunction = null;
                this._pStatistics = null;
                this._sAnalyzedFileName = "";
                this._pSystemMacros = null;
                this._pSystemTypes = null;
                this._pSystemFunctionsMap = null;
                this._pSystemFunctionHashMap = null;
                this._pSystemVariables = null;
                this._pPointerForExtractionList = null;
                this._pFunctionWithImplementationList = null;
                this._pTechniqueList = null;
                this._pTechniqueMap = null;
                this._isAnalyzeInPass = false;
                this._sProvideNameSpace = "";
                this._pGlobalComponentList = null;
                this._pGlobalComponetShiftList = null;
                this._pAddedTechniqueList = null;
                this._pComposer = pComposer;
                this._pParseTree = null;
                this._pAnalyzedNode = null;
                this._pEffectScope = new fx.ProgramScope();
                this._pCurrentInstruction = null;
                this._pStatistics = null;
                this._sAnalyzedFileName = "";
                this._pPointerForExtractionList = [];
                this._pFunctionWithImplementationList = [];
                this._pTechniqueList = [];
                this._pTechniqueMap = {};
                this.initSystemMacros();
                this.initSystemTypes();
                this.initSystemFunctions();
                this.initSystemVariables();
            }
            Effect.pSystemMacros = null;
            Effect.pSystemTypes = null;
            Effect.pSystemFunctions = null;
            Effect.pSystemVariables = null;
            Effect.pSystemVertexOut = null;
            Effect.prototype.analyze = function (pTree) {
                var pRootNode = pTree.root;
                var iParseTime = (Date.now());
                // LOG(this);
                this._pParseTree = pTree;
                this._pStatistics = {
                    time: 0
                };
                try  {
                    ((this)._pEffectScope.newScope((/*checked (origin: fx)>>*/akra.fx.EScopeType.k_Default)));
                    // LOG("ok");
                    this.analyzeGlobalUseDecls();
                    // LOG("ok");
                    this.analyzeGlobalProvideDecls();
                    // LOG("ok");
                    this.analyzeGlobalTypeDecls();
                    // LOG("ok");
                    this.analyzeFunctionDefinitions();
                    // LOG("ok");
                    this.analyzeGlobalImports();
                    // LOG("ok");
                    this.analyzeTechniqueImports();
                    // LOG("ok");
                    this.analyzeVariableDecls();
                    // LOG("ok");
                    this.analyzeFunctionDecls();
                    // LOG("ok");
                    this.analyzeTechniques();
                    // LOG("ok");
                    // this.analyzeTypes();
                    // this.preAnalyzeFunctions();
                    // this.preAnalyzeVariables();
                    // this.preAnalyzeTechniques();
                    // this.analyzeDecls();
                    // this.analyzeEffect();
                    // this.postAnalyzeEffect();
                    // this.checkEffect();
                    ((this)._pEffectScope.endScope());
                } catch (e) {
                    // #ifdef DEBUG
                    throw e;
                    // #else
                    // return false;
                    // #endif
                                    }//Stats
                
                iParseTime = (Date.now()) - iParseTime;
                this._pStatistics.time = iParseTime;
                //LOG(this, iParseTime);
                return true;
            };
            Effect.prototype.getStats = function () {
                return this._pStatistics;
            };
            Effect.prototype.setAnalyzedFileName = function (sFileName) {
                this._sAnalyzedFileName = sFileName;
            };
            Effect.prototype.clear = function () {
            };
            Effect.prototype.getTechniqueList = /** @inline */function () {
                return this._pTechniqueList;
            };
            Effect.getBaseVertexOutType = function getBaseVertexOutType() {
                return Effect.pSystemVertexOut;
            };
            Effect.getSystemType = function getSystemType(sTypeName) {
                //bool, string, float and others
                return ((Effect.pSystemTypes[sTypeName]) !== undefined) ? Effect.pSystemTypes[sTypeName] : null;
            };
            Effect.getSystemVariable = function getSystemVariable(sName) {
                return ((Effect.pSystemVariables[sName]) !== undefined) ? Effect.pSystemVariables[sName] : null;
            };
            Effect.getSystemMacros = function getSystemMacros(sName) {
                return ((Effect.pSystemMacros[sName]) !== undefined) ? Effect.pSystemMacros[sName] : null;
            };
            Effect.findSystemFunction = function findSystemFunction(sFunctionName, pArguments) {
                var pSystemFunctions = Effect.pSystemFunctions[sFunctionName];
                if (!((pSystemFunctions) !== undefined)) {
                    return null;
                }
                if (((pArguments) === null)) {
                    for(var i = 0; i < pSystemFunctions.length; i++) {
                        if (((pSystemFunctions[i])._pArguments.length) === 0) {
                            return pSystemFunctions[i];
                        }
                    }
                }
                for(var i = 0; i < pSystemFunctions.length; i++) {
                    if (pArguments.length !== ((pSystemFunctions[i])._pArguments.length)) {
                        continue;
                    }
                    var pTestedArguments = pSystemFunctions[i].getArguments();
                    var isOk = true;
                    for(var j = 0; j < pArguments.length; j++) {
                        isOk = false;
                        if (!pArguments[j].getType().isEqual(pTestedArguments[j].getType())) {
                            break;
                        }
                        isOk = true;
                    }
                    if (isOk) {
                        return pSystemFunctions[i];
                    }
                }
            };
            Effect.createVideoBufferVariable = function createVideoBufferVariable() {
                var pBuffer = new fx.VariableDeclInstruction();
                var pBufferType = new fx.VariableTypeInstruction();
                var pBufferName = new fx.IdInstruction();
                pBufferType.pushType(Effect.getSystemType("video_buffer"));
                pBuffer.push(pBufferType, true);
                pBuffer.push(pBufferName, true);
                return pBuffer;
            };
            Effect.getExternalType = function getExternalType(pType) {
                if (pType.isEqual(Effect.getSystemType("int")) || pType.isEqual(Effect.getSystemType("float"))) {
                    return Number;
                } else if (pType.isEqual(Effect.getSystemType("bool"))) {
                    return Boolean;
                } else if (pType.isEqual(Effect.getSystemType("float2")) || pType.isEqual(Effect.getSystemType("bool2")) || pType.isEqual(Effect.getSystemType("int2"))) {
                    return akra.Vec2;
                } else if (pType.isEqual(Effect.getSystemType("float3")) || pType.isEqual(Effect.getSystemType("bool3")) || pType.isEqual(Effect.getSystemType("int3"))) {
                    return akra.Vec3;
                } else if (pType.isEqual(Effect.getSystemType("float4")) || pType.isEqual(Effect.getSystemType("bool4")) || pType.isEqual(Effect.getSystemType("int4"))) {
                    return akra.Vec4;
                } else // 	else if(pType.isEqual(Effect.getSystemType("float2x2")) ||
                // pType.isEqual(Effect.getSystemType("bool2x2")) ||
                // pType.isEqual(Effect.getSystemType("int2x2"))){
                // 		return Vec2;
                // 	}
                if (pType.isEqual(Effect.getSystemType("float3x3")) || pType.isEqual(Effect.getSystemType("bool3x3")) || pType.isEqual(Effect.getSystemType("int3x3"))) {
                    return akra.Mat3;
                } else if (pType.isEqual(Effect.getSystemType("float4x4")) || pType.isEqual(Effect.getSystemType("bool4x4")) || pType.isEqual(Effect.getSystemType("int4x4"))) {
                    return akra.Mat4;
                } else {
                    return null;
                }
            };
            Effect.isMatrixType = function isMatrixType(pType) {
                return pType.isEqual(Effect.getSystemType("float2x2")) || pType.isEqual(Effect.getSystemType("float3x3")) || pType.isEqual(Effect.getSystemType("float4x4")) || pType.isEqual(Effect.getSystemType("int2x2")) || pType.isEqual(Effect.getSystemType("int3x3")) || pType.isEqual(Effect.getSystemType("int4x4")) || pType.isEqual(Effect.getSystemType("bool2x2")) || pType.isEqual(Effect.getSystemType("bool3x3")) || pType.isEqual(Effect.getSystemType("bool4x4"));
            };
            Effect.isVectorType = function isVectorType(pType) {
                return pType.isEqual(Effect.getSystemType("float2")) || pType.isEqual(Effect.getSystemType("float3")) || pType.isEqual(Effect.getSystemType("float4")) || pType.isEqual(Effect.getSystemType("bool2")) || pType.isEqual(Effect.getSystemType("bool3")) || pType.isEqual(Effect.getSystemType("bool4")) || pType.isEqual(Effect.getSystemType("int2")) || pType.isEqual(Effect.getSystemType("int3")) || pType.isEqual(Effect.getSystemType("int4"));
            };
            Effect.isScalarType = function isScalarType(pType) {
                return pType.isEqual(Effect.getSystemType("bool")) || pType.isEqual(Effect.getSystemType("int")) || pType.isEqual(Effect.getSystemType("ptr")) || pType.isEqual(Effect.getSystemType("float"));
            };
            Effect.isFloatBasedType = function isFloatBasedType(pType) {
                return pType.isEqual(Effect.getSystemType("float")) || pType.isEqual(Effect.getSystemType("float2")) || pType.isEqual(Effect.getSystemType("float3")) || pType.isEqual(Effect.getSystemType("float4")) || pType.isEqual(Effect.getSystemType("float2x2")) || pType.isEqual(Effect.getSystemType("float3x3")) || pType.isEqual(Effect.getSystemType("float4x4")) || pType.isEqual(Effect.getSystemType("ptr"));
            };
            Effect.isIntBasedType = function isIntBasedType(pType) {
                return pType.isEqual(Effect.getSystemType("int")) || pType.isEqual(Effect.getSystemType("int2")) || pType.isEqual(Effect.getSystemType("int3")) || pType.isEqual(Effect.getSystemType("int4")) || pType.isEqual(Effect.getSystemType("int2x2")) || pType.isEqual(Effect.getSystemType("int3x3")) || pType.isEqual(Effect.getSystemType("int4x4"));
            };
            Effect.isBoolBasedType = function isBoolBasedType(pType) {
                return pType.isEqual(Effect.getSystemType("bool")) || pType.isEqual(Effect.getSystemType("bool2")) || pType.isEqual(Effect.getSystemType("bool3")) || pType.isEqual(Effect.getSystemType("bool4")) || pType.isEqual(Effect.getSystemType("bool2x2")) || pType.isEqual(Effect.getSystemType("bool3x3")) || pType.isEqual(Effect.getSystemType("bool4x4"));
            };
            Effect.isSamplerType = function isSamplerType(pType) {
                return pType.isEqual(Effect.getSystemType("sampler")) || pType.isEqual(Effect.getSystemType("sampler2D")) || pType.isEqual(Effect.getSystemType("samplerCUBE")) || pType.isEqual(Effect.getSystemType("video_buffer"));
            };
            Effect.prototype.generateSuffixLiterals = function (pLiterals, pOutput, iDepth) {
                if (typeof iDepth === "undefined") { iDepth = 0; }
                if (iDepth >= pLiterals.length) {
                    return;
                }
                if (iDepth === 0) {
                    for(var i = 0; i < pLiterals.length; i++) {
                        pOutput[pLiterals[i]] = true;
                    }
                    iDepth = 1;
                }
                var pOutputKeys = Object.keys(pOutput);
                for(var i = 0; i < pLiterals.length; i++) {
                    for(var j = 0; j < pOutputKeys.length; j++) {
                        if (pOutputKeys[j].indexOf(pLiterals[i]) !== -1) {
                            pOutput[pOutputKeys[j] + pLiterals[i]] = false;
                        } else {
                            pOutput[pOutputKeys[j] + pLiterals[i]] = (pOutput[pOutputKeys[j]] === false) ? false : true;
                        }
                    }
                }
                iDepth++;
                this.generateSuffixLiterals(pLiterals, pOutput, iDepth);
            };
            Effect.prototype.initSystemMacros = function () {
                if (((Effect.pSystemMacros) === null)) {
                    this._pSystemMacros = Effect.pSystemMacros = {};
                    this.addSystemMacros();
                }
                this._pSystemMacros = Effect.pSystemMacros;
            };
            Effect.prototype.initSystemTypes = function () {
                if (((Effect.pSystemTypes) === null)) {
                    this._pSystemTypes = Effect.pSystemTypes = {};
                    this.addSystemTypeScalar();
                    this.addSystemTypeVector();
                    this.addSystemTypeMatrix();
                    this.generateBaseVertexOutput();
                }
                this._pSystemTypes = Effect.pSystemTypes;
            };
            Effect.prototype.initSystemFunctions = function () {
                if (((Effect.pSystemFunctions) === null)) {
                    this._pSystemFunctionsMap = Effect.pSystemFunctions = {};
                    this.addSystemFunctions();
                }
                this._pSystemFunctionsMap = Effect.pSystemFunctions;
            };
            Effect.prototype.initSystemVariables = function () {
                if (((Effect.pSystemVariables) === null)) {
                    this._pSystemVariables = Effect.pSystemVariables = {};
                    this.addSystemVariables();
                }
                this._pSystemVariables = Effect.pSystemVariables;
            };
            Effect.prototype.addSystemMacros = function () {
                this.generateSystemMacros("ExtractMacros", "\n#ifdef AKRA_FRAGMENT\n" + "//#define texture2D(sampler, ) texture2D\n" + "#else\n" + "#define texture2D(A, B) texture2DLod(A, B, 0.)\n" + "#endif\n" + "#ifndef A_VB_COMPONENT3\n" + "#define A_VB_COMPONENT4\n" + "#endif\n" + "#ifdef A_VB_COMPONENT4\n" + "#define A_VB_ELEMENT_SIZE 4.\n" + "#endif\n" + "#ifdef A_VB_COMPONENT3\n" + "#define A_VB_ELEMENT_SIZE 3.\n" + "#endif\n" + "#define A_tex2D(S, H, X, Y) texture2D(S, vec2(H.stepX * X , H.stepY * Y))\n" + "#define A_tex2Dv(S, H, V) texture2D(S, V)\n");
            };
            Effect.prototype.addSystemVariables = function () {
                this.generateSystemVariable("fragCoord", "gl_FragCoord", "float4", false, true, true);
                this.generateSystemVariable("frontFacing", "gl_FrontFacing", "bool", false, true, true);
                this.generateSystemVariable("pointCoord", "gl_PointCoord", "float2", false, true, true);
                this.generateSystemVariable("resultAFXColor", "resultAFXColor", "float4", false, true, true);
                //Engine variable for passes
                this.generatePassEngineVariable();
            };
            Effect.prototype.generateSystemVariable = function (sName, sRealName, sTypeName, isForVertex, isForPixel, isOnlyRead) {
                if (((this._pSystemVariables[sName]) !== undefined)) {
                    return;
                }
                var pVariableDecl = new fx.VariableDeclInstruction();
                var pName = new fx.IdInstruction();
                var pType = new fx.VariableTypeInstruction();
                pName.setName(sName);
                pName.setRealName(sRealName);
                pType.pushType(Effect.getSystemType(sTypeName));
                if (isOnlyRead) {
                    pType._canWrite(false);
                }
                pVariableDecl._setForVertex(isForVertex);
                pVariableDecl._setForPixel(isForPixel);
                pVariableDecl.push(pType, true);
                pVariableDecl.push(pName, true);
                this._pSystemVariables[sName] = pVariableDecl;
                pVariableDecl.setBuiltIn(true);
            };
            Effect.prototype.generatePassEngineVariable = function () {
                var pVariableDecl = new fx.VariableDeclInstruction();
                var pName = new fx.IdInstruction();
                var pType = new fx.VariableTypeInstruction();
                pType._canWrite(false);
                pType._markAsUnverifiable(true);
                pName.setName("engine");
                pName.setRealName("engine");
                pVariableDecl.push(pType, true);
                pVariableDecl.push(pName, true);
                this._pSystemVariables["engine"] = pVariableDecl;
            };
            Effect.prototype.generateBaseVertexOutput = function () {
                //TODO: fix defenition of this variables
                var pOutBasetype = new fx.ComplexTypeInstruction();
                var pPosition = new fx.VariableDeclInstruction();
                var pPointSize = new fx.VariableDeclInstruction();
                var pPositionType = new fx.VariableTypeInstruction();
                var pPointSizeType = new fx.VariableTypeInstruction();
                var pPositionId = new fx.IdInstruction();
                var pPointSizeId = new fx.IdInstruction();
                pPositionType.pushType(Effect.getSystemType("float4"));
                pPointSizeType.pushType(Effect.getSystemType("float"));
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pPositionId.setName("pos");
                (pPositionId._sRealName = ("POSITION"));
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pPointSizeId.setName("psize");
                (pPointSizeId._sRealName = ("PSIZE"));
                pPosition.push(pPositionType, true);
                pPosition.push(pPositionId, true);
                pPointSize.push(pPointSizeType, true);
                pPointSize.push(pPointSizeId, true);
                pPosition.setSemantic("POSITION");
                pPointSize.setSemantic("PSIZE");
                var pFieldCollector = new fx.InstructionCollector();
                pFieldCollector.push(pPosition, false);
                pFieldCollector.push(pPointSize, false);
                pOutBasetype.addFields(pFieldCollector, true);
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pOutBasetype.setName("VS_OUT");
                (pOutBasetype._sRealName = ("VS_OUT_S"));
                Effect.pSystemVertexOut = pOutBasetype;
            };
            Effect.prototype.addSystemFunctions = function () {
                this._pSystemFunctionHashMap = {};
                this.generateSystemFunction("dot", "dot($1,$2)", "float", [
                    "template", 
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("mul", "$1*$2", "template", [
                    "template", 
                    "template"
                ], [
                    "float", 
                    "int", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("mod", "mod($1,$2)", "float", [
                    "float", 
                    "float"
                ], null);
                this.generateSystemFunction("floor", "floor($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("ceil", "ceil($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("fract", "fract($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("abs", "abs($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("normalize", "normalize($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("length", "length($1)", "float", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("cross", "cross($1, $2)", "float3", [
                    "float3", 
                    "float3"
                ], null);
                this.generateSystemFunction("reflect", "reflect($1,$2)", "template", [
                    "template", 
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("max", "max($1,$2)", "template", [
                    "template", 
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("max", "max($1,$2)", "template", [
                    "template", 
                    "float"
                ], [
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("min", "min($1,$2)", "template", [
                    "template", 
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("min", "min($1,$2)", "template", [
                    "template", 
                    "float"
                ], [
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("mix", "mix($1,$2,$3)", "template", [
                    "template", 
                    "template", 
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("mix", "mix($1,$2,$3)", "template", [
                    "template", 
                    "template", 
                    "float"
                ], [
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("clamp", "clamp($1,$2,$3)", "template", [
                    "template", 
                    "template", 
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("clamp", "clamp($1,$2,$3)", "template", [
                    "template", 
                    "float", 
                    "float"
                ], [
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("pow", "pow($1,$2)", "template", [
                    "template", 
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("mod", "mod($1,$2)", "template", [
                    "template", 
                    "template"
                ], [
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("mod", "mod($1,$2)", "template", [
                    "template", 
                    "float"
                ], [
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("exp", "exp($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("exp2", "exp2($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("log", "log($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("log2", "log2($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("inversesqrt", "inversesqrt($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("sqrt", "sqrt($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("all", "all($1)", "bool", [
                    "template"
                ], [
                    "bool2", 
                    "bool3", 
                    "bool4"
                ]);
                this.generateSystemFunction("any", "any($1)", "bool", [
                    "template"
                ], [
                    "bool2", 
                    "bool3", 
                    "bool4"
                ]);
                this.generateSystemFunction("not", "not($1)", "template", [
                    "template"
                ], [
                    "bool2", 
                    "bool3", 
                    "bool4"
                ]);
                this.generateSystemFunction("lessThan", "lessThan($1,$2)", "bool2", [
                    "template", 
                    "template"
                ], [
                    "float2", 
                    "int2"
                ]);
                this.generateSystemFunction("lessThan", "lessThan($1,$2)", "bool3", [
                    "template", 
                    "template"
                ], [
                    "float3", 
                    "int3"
                ]);
                this.generateSystemFunction("lessThan", "lessThan($1,$2)", "bool4", [
                    "template", 
                    "template"
                ], [
                    "float4", 
                    "int4"
                ]);
                this.generateSystemFunction("lessThanEqual", "lessThanEqual($1,$2)", "bool2", [
                    "template", 
                    "template"
                ], [
                    "float2", 
                    "int2"
                ]);
                this.generateSystemFunction("lessThanEqual", "lessThanEqual($1,$2)", "bool3", [
                    "template", 
                    "template"
                ], [
                    "float3", 
                    "int3"
                ]);
                this.generateSystemFunction("lessThanEqual", "lessThanEqual($1,$2)", "bool4", [
                    "template", 
                    "template"
                ], [
                    "float4", 
                    "int4"
                ]);
                this.generateSystemFunction("equal", "equal($1,$2)", "bool2", [
                    "template", 
                    "template"
                ], [
                    "float2", 
                    "int2"
                ]);
                this.generateSystemFunction("equal", "equal($1,$2)", "bool3", [
                    "template", 
                    "template"
                ], [
                    "float3", 
                    "int3"
                ]);
                this.generateSystemFunction("equal", "equal($1,$2)", "bool4", [
                    "template", 
                    "template"
                ], [
                    "float4", 
                    "int4"
                ]);
                this.generateSystemFunction("equal", "equal($1,$2)", "template", [
                    "template", 
                    "template"
                ], [
                    "bool2", 
                    "bool3", 
                    "bool4"
                ]);
                this.generateSystemFunction("notEqual", "notEqual($1,$2)", "bool2", [
                    "template", 
                    "template"
                ], [
                    "float2", 
                    "int2"
                ]);
                this.generateSystemFunction("notEqual", "notEqual($1,$2)", "bool3", [
                    "template", 
                    "template"
                ], [
                    "float3", 
                    "int3"
                ]);
                this.generateSystemFunction("notEqual", "notEqual($1,$2)", "bool4", [
                    "template", 
                    "template"
                ], [
                    "float4", 
                    "int4"
                ]);
                this.generateSystemFunction("notEqual", "notEqual($1,$2)", "template", [
                    "template", 
                    "template"
                ], [
                    "bool2", 
                    "bool3", 
                    "bool4"
                ]);
                this.generateSystemFunction("greaterThan", "greaterThan($1,$2)", "bool2", [
                    "template", 
                    "template"
                ], [
                    "float2", 
                    "int2"
                ]);
                this.generateSystemFunction("greaterThan", "greaterThan($1,$2)", "bool3", [
                    "template", 
                    "template"
                ], [
                    "float3", 
                    "int3"
                ]);
                this.generateSystemFunction("greaterThan", "greaterThan($1,$2)", "bool4", [
                    "template", 
                    "template"
                ], [
                    "float4", 
                    "int4"
                ]);
                this.generateSystemFunction("greaterThanEqual", "greaterThanEqual($1,$2)", "bool2", [
                    "template", 
                    "template"
                ], [
                    "float2", 
                    "int2"
                ]);
                this.generateSystemFunction("greaterThanEqual", "greaterThanEqual($1,$2)", "bool3", [
                    "template", 
                    "template"
                ], [
                    "float3", 
                    "int3"
                ]);
                this.generateSystemFunction("greaterThanEqual", "greaterThanEqual($1,$2)", "bool4", [
                    "template", 
                    "template"
                ], [
                    "float4", 
                    "int4"
                ]);
                this.generateSystemFunction("radians", "radians($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("degrees", "degrees($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("sin", "sin($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("cos", "cos($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("tan", "tan($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("asin", "asin($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("acos", "acos($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("atan", "atan($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("atan", "atan($1, $2)", "template", [
                    "template", 
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("tex2D", "texture2D($1,$2)", "float4", [
                    "sampler", 
                    "float2"
                ], null);
                this.generateSystemFunction("tex2D", "texture2D($1,$2)", "float4", [
                    "sampler2D", 
                    "float2"
                ], null);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", [
                    "sampler", 
                    "float3"
                ], null);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", [
                    "sampler2D", 
                    "float3"
                ], null);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", [
                    "sampler", 
                    "float4"
                ], null);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", [
                    "sampler2D", 
                    "float4"
                ], null);
                this.generateSystemFunction("texCUBE", "textureCube($1,$2)", "float4", [
                    "sampler", 
                    "float3"
                ], null);
                this.generateSystemFunction("texCUBE", "textureCube($1,$2)", "float4", [
                    "samplerCUBE", 
                    "float3"
                ], null);
                this.generateSystemFunction("tex2D", "texture2D($1,$2,$3)", "float4", [
                    "sampler", 
                    "float2", 
                    "float"
                ], null, false, true);
                this.generateSystemFunction("tex2D", "texture2D($1,$2,$3)", "float4", [
                    "sampler2D", 
                    "float2", 
                    "float"
                ], null, false, true);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", [
                    "sampler", 
                    "float3", 
                    "float"
                ], null, false, true);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", [
                    "sampler2D", 
                    "float3", 
                    "float"
                ], null, false, true);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", [
                    "sampler", 
                    "float4", 
                    "float"
                ], null, false, true);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", [
                    "sampler2D", 
                    "float4", 
                    "float"
                ], null, false, true);
                this.generateSystemFunction("texCUBE", "textureCube($1,$2,$3)", "float4", [
                    "sampler", 
                    "float3", 
                    "float"
                ], null, false, true);
                this.generateSystemFunction("texCUBE", "textureCube($1,$2,$3)", "float4", [
                    "samplerCUBE", 
                    "float3", 
                    "float"
                ], null, false, true);
                this.generateSystemFunction("tex2DLod", "texture2DLod($1,$2,$3)", "float4", [
                    "sampler", 
                    "float2", 
                    "float"
                ], null, true, false);
                this.generateSystemFunction("tex2DLod", "texture2DLod($1,$2,$3)", "float4", [
                    "sampler2D", 
                    "float2", 
                    "float"
                ], null, true, false);
                this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", [
                    "sampler", 
                    "float3", 
                    "float"
                ], null, true, false);
                this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", [
                    "sampler2D", 
                    "float3", 
                    "float"
                ], null, true, false);
                this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", [
                    "sampler", 
                    "float4", 
                    "float"
                ], null, true, false);
                this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", [
                    "sampler2D", 
                    "float4", 
                    "float"
                ], null, true, false);
                this.generateSystemFunction("texCUBELod", "textureCubeLod($1,$2,$3)", "float4", [
                    "sampler", 
                    "float3", 
                    "float"
                ], null, true, false);
                this.generateSystemFunction("texCUBELod", "textureCubeLod($1,$2,$3)", "float4", [
                    "samplerCUBE", 
                    "float3", 
                    "float"
                ], null, true, false);
                //OES_standard_derivatives
                this.generateSystemFunction("dFdx", "dFdx($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("dFdy", "dFdy($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("width", "width($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("frac", "fract($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("lerp", "mix($1,$2,$3)", "template", [
                    "template", 
                    "template", 
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("lerp", "mix($1,$2,$3)", "template", [
                    "template", 
                    "template", 
                    "float"
                ], [
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                //Extracts
                this.generateNotBuiltInSystemFuction("extractHeader", "void A_extractTextureHeader(const sampler2D src, out A_TextureHeader texture)", "{vec4 v = texture2D(src, vec2(0.00001)); " + "texture = A_TextureHeader(v.r, v.g, v.b, v.a);}", "void", [
                    "video_buffer_header"
                ], null, [
                    "ExtractMacros"
                ]);
                this.generateNotBuiltInSystemFuction("extractFloat", "float A_extractFloat(const sampler2D sampler, const A_TextureHeader header, const float offset)", "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " + "float y = floor(pixelNumber / header.width) + .5; " + "float x = mod(pixelNumber, header.width) + .5; " + "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); " + "\n#ifdef A_VB_COMPONENT4\n" + "if(shift == 0) return A_tex2D(sampler, header, x, y).r; " + "else if(shift == 1) return A_tex2D(sampler, header, x, y).g; " + "else if(shift == 2) return A_tex2D(sampler, header, x, y).b; " + "else if(shift == 3) return A_tex2D(sampler, header, x, y).a; " + "\n#endif\n" + "return 0.;}", "float", [
                    "video_buffer_header"
                ], [
                    "extractHeader"
                ], [
                    "ExtractMacros"
                ]);
                this.generateNotBuiltInSystemFuction("extractFloat2", "vec2 A_extractVec2(const sampler2D sampler, const A_TextureHeader header, const float offset)", "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " + "float y = floor(pixelNumber / header.width) + .5; " + "float x = mod(pixelNumber, header.width) + .5; " + "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); " + "\n#ifdef A_VB_COMPONENT4\n" + "if(shift == 0) return A_tex2D(sampler, header, x, y).rg; " + "else if(shift == 1) return A_tex2D(sampler, header, x, y).gb; " + "else if(shift == 2) return A_tex2D(sampler, header, x, y).ba; " + "else if(shift == 3) { " + "if(int(x) == int(header.width - 1.)) " + "return vec2(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, 0.5, (y + 1.)).r); " + "else " + "return vec2(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, (x + 1.), y).r); " + "} " + "\n#endif\n" + "return vec2(0.);}", "float2", [
                    "video_buffer_header"
                ], [
                    "extractHeader"
                ], [
                    "ExtractMacros"
                ]);
                this.generateNotBuiltInSystemFuction("extractFloat3", "vec3 A_extractVec3(const sampler2D sampler, const A_TextureHeader header, const float offset)", "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " + "float y = floor(pixelNumber / header.width) + .5; " + "float x = mod(pixelNumber, header.width) + .5; " + "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); " + "\n#ifdef A_VB_COMPONENT4\n" + "if(shift == 0) return A_tex2D(sampler, header, x, y).rgb; " + "else if(shift == 1) return A_tex2D(sampler, header, x, y).gba; " + "else if(shift == 2){ " + "if(int(x) == int(header.width - 1.))  return vec3(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, 0.5, (y + 1.)).r); " + "else return vec3(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, (x + 1.), y).r);} " + "else if(shift == 3){ " + "if(int(x) == int(header.width - 1.))  return vec3(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, 0.5, (y + 1.)).rg); " + "else return vec3(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, (x + 1.), y).rg);} " + "\n#endif\n" + "\n#ifdef A_VB_COMPONENT3\n" + "if(shift == 0) return A_tex2D(sampler, header,vec2(x,header.stepY*y)).rgb; " + "else if(shift == 1){ " + "if(x == header.width - 1.) return vec3(A_tex2D(sampler, header, x, y).gb, A_tex2D(sampler, header, 0.5, (y + 1.)).r); " + "else return vec3(A_tex2D(sampler, header, x, y).gb, A_tex2D(sampler, header, (x + 1.), y).r);} " + "else if(shift == 3){ " + "if(x == header.width - 1.) return vec3(A_tex2D(sampler, header, x, y).b, A_tex2D(sampler, header, 0.5, (y + 1.)).rg); " + "else return vec3(A_tex2D(sampler, header, x, y).b, A_tex2D(sampler, header, (x + 1)., y).rg);} " + "\n#endif\n" + "return vec3(0.);}", "float3", [
                    "video_buffer_header"
                ], [
                    "extractHeader"
                ], [
                    "ExtractMacros"
                ]);
                this.generateNotBuiltInSystemFuction("extractFloat4", "vec4 A_extractVec4(const sampler2D sampler, const A_TextureHeader header, const float offset)", "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " + "float y = floor(pixelNumber / header.width) + .5; " + "float x = mod(pixelNumber, header.width) + .5; " + "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); " + "\n#ifdef A_VB_COMPONENT4\n" + "if(shift == 0) return A_tex2D(sampler, header, x, y); " + "else if(shift == 1){ " + "if(int(x) == int(header.width - 1.)) " + "return vec4(A_tex2D(sampler, header, x, y).gba, A_tex2D(sampler, header, 0.5, (y + 1.)).r); " + "else " + "return vec4(A_tex2D(sampler, header, x, y).gba, A_tex2D(sampler, header, (x + 1.), y).r);} " + "else if(shift == 2){ " + "if(int(x) == int(header.width - 1.)) " + "return vec4(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, 0.5, (y + 1.)).rg); " + "else " + "return vec4(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, (x + 1.), y).rg);} " + "else if(shift == 3){ " + "if(int(x) == int(header.width - 1.)) " + "return vec4(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, 0.5, (y + 1.)).rgb); " + "else return vec4(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, (x + 1.), y).rgb);} " + "\n#endif\n" + "\n#ifdef A_VB_COMPONENT3\n" + "\n#endif\n" + "return vec4(0.);}", "float4", [
                    "video_buffer_header"
                ], [
                    "extractHeader"
                ], [
                    "ExtractMacros"
                ]);
                this.generateNotBuiltInSystemFuction("findPixel", "vec2 A_findPixel(const A_TextureHeader header, const float offset)", "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " + "return vec2(header.stepX * (mod(pixelNumber, header.width) + .5), header.stepY * (floor(pixelNumber / header.width) + .5));}", "float2", [
                    "video_buffer_header"
                ], [
                    "extractHeader"
                ], [
                    "ExtractMacros"
                ]);
                this.generateNotBuiltInSystemFuction("extractFloat4x4", "mat4 A_extractMat4(const sampler2D sampler, const A_TextureHeader header, const float offset)", "{return mat4(A_tex2Dv(sampler, header, A_findPixel(header, offset))," + "A_tex2Dv(sampler, header, A_findPixel(header, offset + 4.))," + "A_tex2Dv(sampler, header, A_findPixel(header, offset + 8.))," + "A_tex2Dv(sampler, header, A_findPixel(header, offset + 12.)));}", "float4x4", [
                    "video_buffer_header"
                ], [
                    "findPixel"
                ], [
                    "ExtractMacros"
                ]);
            };
            Effect.prototype.generateSystemFunction = function (sName, sTranslationExpr, sReturnTypeName, pArgumentsTypes, pTemplateTypes, isForVertex, isForPixel) {
                if (typeof isForVertex === "undefined") { isForVertex = true; }
                if (typeof isForPixel === "undefined") { isForPixel = true; }
                var pExprTranslator = new fx.ExprTemplateTranslator(sTranslationExpr);
                var pSystemFunctions = this._pSystemFunctionsMap;
                var pTypes = null;
                var sFunctionHash = "";
                var pReturnType = null;
                var pFunction = null;
                if (!((pTemplateTypes) === null)) {
                    for(var i = 0; i < pTemplateTypes.length; i++) {
                        pTypes = [];
                        sFunctionHash = sName + "(";
                        pReturnType = (sReturnTypeName === "template") ? Effect.getSystemType(pTemplateTypes[i]) : Effect.getSystemType(sReturnTypeName);
                        for(var j = 0; j < pArgumentsTypes.length; j++) {
                            if (pArgumentsTypes[j] === "template") {
                                pTypes.push(Effect.getSystemType(pTemplateTypes[i]));
                                sFunctionHash += pTemplateTypes[i] + ",";
                            } else {
                                pTypes.push(Effect.getSystemType(pArgumentsTypes[j]));
                                sFunctionHash += pArgumentsTypes[j] + ",";
                            }
                        }
                        sFunctionHash += ")";
                        if (this._pSystemFunctionHashMap[sFunctionHash]) {
                            this._error(2248, {
                                funcName: sFunctionHash
                            });
                        }
                        pFunction = new fx.SystemFunctionInstruction(sName, pReturnType, pExprTranslator, pTypes);
                        if (!((pSystemFunctions[sName]) !== undefined)) {
                            pSystemFunctions[sName] = [];
                        }
                        (pFunction._bForVertex = (isForVertex));
                        (pFunction._bForPixel = (isForPixel));
                        pSystemFunctions[sName].push(pFunction);
                        pFunction.setBuiltIn(true);
                    }
                } else {
                    if (sReturnTypeName === "template") {
                        akra.logger.criticalError("Bad return type(TEMPLATE_TYPE) for system function '" + sName + "'.");
                    }
                    pReturnType = Effect.getSystemType(sReturnTypeName);
                    pTypes = [];
                    sFunctionHash = sName + "(";
                    for(var i = 0; i < pArgumentsTypes.length; i++) {
                        if (pArgumentsTypes[i] === "template") {
                            akra.logger.criticalError("Bad argument type(TEMPLATE_TYPE) for system function '" + sName + "'.");
                        } else {
                            pTypes.push(Effect.getSystemType(pArgumentsTypes[i]));
                            sFunctionHash += pArgumentsTypes[i] + ",";
                        }
                    }
                    sFunctionHash += ")";
                    if (this._pSystemFunctionHashMap[sFunctionHash]) {
                        this._error(2248, {
                            funcName: sFunctionHash
                        });
                    }
                    pFunction = new fx.SystemFunctionInstruction(sName, pReturnType, pExprTranslator, pTypes);
                    (pFunction._bForVertex = (isForVertex));
                    (pFunction._bForPixel = (isForPixel));
                    if (!((pSystemFunctions[sName]) !== undefined)) {
                        pSystemFunctions[sName] = [];
                    }
                    pSystemFunctions[sName].push(pFunction);
                    pFunction.setBuiltIn(true);
                }
            };
            Effect.prototype.generateSystemMacros = function (sMacrosName, sMacrosCode) {
                if (((this._pSystemMacros[sMacrosName]) !== undefined)) {
                    return;
                }
                var pMacros = new fx.SimpleInstruction(sMacrosCode);
                this._pSystemMacros[sMacrosName] = pMacros;
            };
            Effect.prototype.generateNotBuiltInSystemFuction = function (sName, sDefenition, sImplementation, sReturnType, pUsedTypes, pUsedFunctions, pUsedMacros) {
                if (((this._pSystemFunctionsMap[sName]) !== undefined)) {
                    return;
                }
                var pReturnType = Effect.getSystemType(sReturnType);
                var pFunction = new fx.SystemFunctionInstruction(sName, pReturnType, null, null);
                pFunction.setDeclCode(sDefenition, sImplementation);
                var pUsedExtSystemTypes = [];
                var pUsedExtSystemFunctions = [];
                var pUsedExtSystemMacros = [];
                if (!((pUsedTypes) === null)) {
                    for(var i = 0; i < pUsedTypes.length; i++) {
                        var pTypeDecl = ((Effect.getSystemType(pUsedTypes[i]))._pParentInstruction);
                        if (!((pTypeDecl) === null)) {
                            pUsedExtSystemTypes.push(pTypeDecl);
                        }
                    }
                }
                if (!((pUsedMacros) === null)) {
                    for(var i = 0; i < pUsedMacros.length; i++) {
                        pUsedExtSystemMacros.push(Effect.getSystemMacros(pUsedMacros[i]));
                    }
                }
                if (!((pUsedFunctions) === null)) {
                    for(var i = 0; i < pUsedFunctions.length; i++) {
                        var pFindFunction = Effect.findSystemFunction(pUsedFunctions[i], null);
                        pUsedExtSystemFunctions.push(pFindFunction);
                    }
                }
                pFunction.setUsedSystemData(pUsedExtSystemTypes, pUsedExtSystemFunctions, pUsedExtSystemMacros);
                pFunction.closeSystemDataInfo();
                pFunction.setBuiltIn(false);
                this._pSystemFunctionsMap[sName] = [
                    pFunction
                ];
            };
            Effect.prototype.generateSystemType = function (sName, sRealName, iSize, isArray, pElementType, iLength) {
                if (typeof iSize === "undefined") { iSize = 1; }
                if (typeof isArray === "undefined") { isArray = false; }
                if (typeof pElementType === "undefined") { pElementType = null; }
                if (typeof iLength === "undefined") { iLength = 1; }
                if (((this._pSystemTypes[sName]) !== undefined)) {
                    return null;
                }
                var pSystemType = new fx.SystemTypeInstruction();
                (pSystemType._sName = (sName));
                (pSystemType._sRealName = (sRealName));
                (pSystemType._iSize = (iSize));
                if (isArray) {
                    pSystemType.addIndex(pElementType, iLength);
                }
                this._pSystemTypes[sName] = pSystemType;
                pSystemType.setBuiltIn(true);
                return pSystemType;
            };
            Effect.prototype.generateNotBuildtInSystemType = function (sName, sRealName, sDeclString, iSize, isArray, pElementType, iLength) {
                if (typeof iSize === "undefined") { iSize = 1; }
                if (typeof isArray === "undefined") { isArray = false; }
                if (typeof pElementType === "undefined") { pElementType = null; }
                if (typeof iLength === "undefined") { iLength = 1; }
                if (((this._pSystemTypes[sName]) !== undefined)) {
                    return null;
                }
                var pSystemType = new fx.SystemTypeInstruction();
                (pSystemType._sName = (sName));
                (pSystemType._sRealName = (sRealName));
                (pSystemType._iSize = (iSize));
                pSystemType.setDeclString(sDeclString);
                if (isArray) {
                    pSystemType.addIndex(pElementType, iLength);
                }
                this._pSystemTypes[sName] = pSystemType;
                pSystemType.setBuiltIn(false);
                var pSystemTypeDecl = new fx.TypeDeclInstruction();
                pSystemTypeDecl.push(pSystemType, true);
                pSystemTypeDecl.setBuiltIn(false);
                return pSystemType;
            };
            Effect.prototype.addSystemTypeScalar = function () {
                this.generateSystemType("void", "void", 0);
                this.generateSystemType("int", "int", 1);
                this.generateSystemType("bool", "bool", 1);
                this.generateSystemType("float", "float", 1);
                this.generateSystemType("ptr", "float", 1);
                this.generateSystemType("string", "", 0);
                this.generateSystemType("texture", "", 0);
                this.generateSystemType("sampler", "sampler2D", 1);
                this.generateSystemType("sampler2D", "sampler2D", 1);
                this.generateSystemType("samplerCUBE", "samplerCube", 1);
                this.generateSystemType("video_buffer", "sampler2D", 1);
                this.generateNotBuildtInSystemType("video_buffer_header", "A_TextureHeader", "struct A_TextureHeader { float width; float height; float stepX; float stepY; }");
            };
            Effect.prototype.addSystemTypeVector = function () {
                var pXYSuffix = {};
                var pXYZSuffix = {};
                var pXYZWSuffix = {};
                var pRGSuffix = {};
                var pRGBSuffix = {};
                var pRGBASuffix = {};
                var pSTSuffix = {};
                var pSTPSuffix = {};
                var pSTPQSuffix = {};
                this.generateSuffixLiterals([
                    "x", 
                    "y"
                ], pXYSuffix);
                this.generateSuffixLiterals([
                    "x", 
                    "y", 
                    "z"
                ], pXYZSuffix);
                this.generateSuffixLiterals([
                    "x", 
                    "y", 
                    "z", 
                    "w"
                ], pXYZWSuffix);
                this.generateSuffixLiterals([
                    "r", 
                    "g"
                ], pRGSuffix);
                this.generateSuffixLiterals([
                    "r", 
                    "g", 
                    "b"
                ], pRGBSuffix);
                this.generateSuffixLiterals([
                    "r", 
                    "g", 
                    "b", 
                    "a"
                ], pRGBASuffix);
                this.generateSuffixLiterals([
                    "s", 
                    "t"
                ], pSTSuffix);
                this.generateSuffixLiterals([
                    "s", 
                    "t", 
                    "p"
                ], pSTPSuffix);
                this.generateSuffixLiterals([
                    "s", 
                    "t", 
                    "p", 
                    "q"
                ], pSTPQSuffix);
                var pFloat = Effect.getSystemType("float");
                var pInt = Effect.getSystemType("int");
                var pBool = Effect.getSystemType("bool");
                var pFloat2 = this.generateSystemType("float2", "vec2", 0, true, pFloat, 2);
                var pFloat3 = this.generateSystemType("float3", "vec3", 0, true, pFloat, 3);
                var pFloat4 = this.generateSystemType("float4", "vec4", 0, true, pFloat, 4);
                var pInt2 = this.generateSystemType("int2", "ivec2", 0, true, pInt, 2);
                var pInt3 = this.generateSystemType("int3", "ivec3", 0, true, pInt, 3);
                var pInt4 = this.generateSystemType("int4", "ivec4", 0, true, pInt, 4);
                var pBool2 = this.generateSystemType("bool2", "bvec2", 0, true, pBool, 2);
                var pBool3 = this.generateSystemType("bool3", "bvec3", 0, true, pBool, 3);
                var pBool4 = this.generateSystemType("bool4", "bvec4", 0, true, pBool, 4);
                this.addFieldsToVectorFromSuffixObject(pXYSuffix, pFloat2, "float");
                this.addFieldsToVectorFromSuffixObject(pRGSuffix, pFloat2, "float");
                this.addFieldsToVectorFromSuffixObject(pSTSuffix, pFloat2, "float");
                this.addFieldsToVectorFromSuffixObject(pXYZSuffix, pFloat3, "float");
                this.addFieldsToVectorFromSuffixObject(pRGBSuffix, pFloat3, "float");
                this.addFieldsToVectorFromSuffixObject(pSTPSuffix, pFloat3, "float");
                this.addFieldsToVectorFromSuffixObject(pXYZWSuffix, pFloat4, "float");
                this.addFieldsToVectorFromSuffixObject(pRGBASuffix, pFloat4, "float");
                this.addFieldsToVectorFromSuffixObject(pSTPQSuffix, pFloat4, "float");
                this.addFieldsToVectorFromSuffixObject(pXYSuffix, pInt2, "int");
                this.addFieldsToVectorFromSuffixObject(pRGSuffix, pInt2, "int");
                this.addFieldsToVectorFromSuffixObject(pSTSuffix, pInt2, "int");
                this.addFieldsToVectorFromSuffixObject(pXYZSuffix, pInt3, "int");
                this.addFieldsToVectorFromSuffixObject(pRGBSuffix, pInt3, "int");
                this.addFieldsToVectorFromSuffixObject(pSTPSuffix, pInt3, "int");
                this.addFieldsToVectorFromSuffixObject(pXYZWSuffix, pInt4, "int");
                this.addFieldsToVectorFromSuffixObject(pRGBASuffix, pInt4, "int");
                this.addFieldsToVectorFromSuffixObject(pSTPQSuffix, pInt4, "int");
                this.addFieldsToVectorFromSuffixObject(pXYSuffix, pBool2, "bool");
                this.addFieldsToVectorFromSuffixObject(pRGSuffix, pBool2, "bool");
                this.addFieldsToVectorFromSuffixObject(pSTSuffix, pBool2, "bool");
                this.addFieldsToVectorFromSuffixObject(pXYZSuffix, pBool3, "bool");
                this.addFieldsToVectorFromSuffixObject(pRGBSuffix, pBool3, "bool");
                this.addFieldsToVectorFromSuffixObject(pSTPSuffix, pBool3, "bool");
                this.addFieldsToVectorFromSuffixObject(pXYZWSuffix, pBool4, "bool");
                this.addFieldsToVectorFromSuffixObject(pRGBASuffix, pBool4, "bool");
                this.addFieldsToVectorFromSuffixObject(pSTPQSuffix, pBool4, "bool");
            };
            Effect.prototype.addSystemTypeMatrix = function () {
                var pFloat2 = Effect.getSystemType("float2");
                var pFloat3 = Effect.getSystemType("float3");
                var pFloat4 = Effect.getSystemType("float4");
                var pInt2 = Effect.getSystemType("int2");
                var pInt3 = Effect.getSystemType("int3");
                var pInt4 = Effect.getSystemType("int4");
                var pBool2 = Effect.getSystemType("bool2");
                var pBool3 = Effect.getSystemType("bool3");
                var pBool4 = Effect.getSystemType("bool4");
                this.generateSystemType("float2x2", "mat2", 0, true, pFloat2, 2);
                this.generateSystemType("float2x3", "mat2x3", 0, true, pFloat2, 3);
                this.generateSystemType("float2x4", "mat2x4", 0, true, pFloat2, 4);
                this.generateSystemType("float3x2", "mat3x2", 0, true, pFloat3, 2);
                this.generateSystemType("float3x3", "mat3", 0, true, pFloat3, 3);
                this.generateSystemType("float3x4", "mat3x4", 0, true, pFloat3, 4);
                this.generateSystemType("float4x2", "mat4x2", 0, true, pFloat4, 2);
                this.generateSystemType("float4x3", "mat4x3", 0, true, pFloat4, 3);
                this.generateSystemType("float4x4", "mat4", 0, true, pFloat4, 4);
                this.generateSystemType("int2x2", "imat2", 0, true, pInt2, 2);
                this.generateSystemType("int2x3", "imat2x3", 0, true, pInt2, 3);
                this.generateSystemType("int2x4", "imat2x4", 0, true, pInt2, 4);
                this.generateSystemType("int3x2", "imat3x2", 0, true, pInt3, 2);
                this.generateSystemType("int3x3", "imat3", 0, true, pInt3, 3);
                this.generateSystemType("int3x4", "imat3x4", 0, true, pInt3, 4);
                this.generateSystemType("int4x2", "imat4x2", 0, true, pInt4, 2);
                this.generateSystemType("int4x3", "imat4x3", 0, true, pInt4, 3);
                this.generateSystemType("int4x4", "imat4", 0, true, pInt4, 4);
                this.generateSystemType("bool2x2", "bmat2", 0, true, pBool2, 2);
                this.generateSystemType("bool2x3", "bmat2x3", 0, true, pBool2, 3);
                this.generateSystemType("bool2x4", "bmat2x4", 0, true, pBool2, 4);
                this.generateSystemType("bool3x2", "bmat3x2", 0, true, pBool3, 2);
                this.generateSystemType("bool3x3", "bmat3", 0, true, pBool3, 3);
                this.generateSystemType("bool3x4", "bmat3x4", 0, true, pBool3, 4);
                this.generateSystemType("bool4x2", "bmat4x2", 0, true, pBool4, 2);
                this.generateSystemType("bool4x3", "bmat4x3", 0, true, pBool4, 3);
                this.generateSystemType("bool4x4", "bmat4", 0, true, pBool4, 4);
            };
            Effect.prototype.addFieldsToVectorFromSuffixObject = function (pSuffixMap, pType, sBaseType) {
                var sSuffix = null;
                for(sSuffix in pSuffixMap) {
                    var sFieldTypeName = sBaseType + ((sSuffix.length > 1) ? sSuffix.length.toString() : "");
                    var pFieldType = Effect.getSystemType(sFieldTypeName);
                    (pType).addField(sSuffix, pFieldType, pSuffixMap[sSuffix]);
                }
            };
            Effect.prototype.getVariable = /** @inline */function (sName) {
                return Effect.getSystemVariable(sName) || this._pEffectScope.getVariable(sName);
            };
            Effect.prototype.hasVariable = /** @inline */function (sName) {
                return this._pEffectScope.hasVariable(sName);
            };
            Effect.prototype.getType = function (sTypeName) {
                return Effect.getSystemType(sTypeName) || this._pEffectScope.getType(sTypeName);
            };
            Effect.prototype.isSystemFunction = function (pFunction) {
                return false;
            };
            Effect.prototype.isSystemVariable = function (pVariable) {
                return false;
            };
            Effect.prototype.isSystemType = function (pType) {
                return false;
            };
            Effect.prototype._errorFromInstruction = /** @inline */function (pError) {
                this._error(pError.code, ((pError.info) === null) ? {} : pError.info);
            };
            Effect.prototype._error = function (eCode, pInfo) {
                if (typeof pInfo === "undefined") { pInfo = {}; }
                var sFileName = this._sAnalyzedFileName;
                var pLocation = {
                    file: this._sAnalyzedFileName,
                    line: 0
                };
                var pLineColumn = this.getNodeSourceLocation(((this)._pAnalyzedNode));
                switch(eCode) {
                    default:
                        pInfo.line = pLineColumn.line + 1;
                        pInfo.column = pLineColumn.column + 1;
                        pLocation.line = pLineColumn.line + 1;
                        break;
                }
                var pLogEntity = {
                    code: eCode,
                    info: pInfo,
                    location: pLocation
                };
                akra.logger["error"](pLogEntity);
                throw new Error(eCode.toString());
            };
            Effect.prototype.setAnalyzedNode = /** @inline */function (pNode) {
                // if(this._pAnalyzedNode !== pNode){
                // 	// debug_print("Analyze node: ", pNode);
                // 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
                // }
                this._pAnalyzedNode = pNode;
            };
            Effect.prototype.getAnalyzedNode = /** @inline */function () {
                return this._pAnalyzedNode;
            };
            Effect.prototype.isStrictMode = /** @inline */function () {
                return this._pEffectScope.isStrictMode();
            };
            Effect.prototype.setStrictModeOn = /** @inline */function () {
                return this._pEffectScope.setStrictModeOn();
            };
            Effect.prototype.newScope = /** @inline */function (eScopeType) {
                if (typeof eScopeType === "undefined") { eScopeType = fx.EScopeType.k_Default; }
                this._pEffectScope.newScope(eScopeType);
            };
            Effect.prototype.resumeScope = /** @inline */function () {
                this._pEffectScope.resumeScope();
            };
            Effect.prototype.getScope = /** @inline */function () {
                return this._pEffectScope.getScope();
            };
            Effect.prototype.setScope = /** @inline */function (iScope) {
                this._pEffectScope.setScope(iScope);
            };
            Effect.prototype.endScope = /** @inline */function () {
                this._pEffectScope.endScope();
            };
            Effect.prototype.getScopeType = /** @inline */function () {
                return ((this._pEffectScope)._pScopeMap[(this._pEffectScope)._iCurrentScope].type);
            };
            Effect.prototype.setCurrentAnalyzedFunction = /** @inline */function (pFunction) {
                this._pCurrentFunction = pFunction;
            };
            Effect.prototype.getCurrentAnalyzedFunction = /** @inline */function () {
                return this._pCurrentFunction;
            };
            Effect.prototype.isAnalzeInPass = /** @inline */function () {
                return this._isAnalyzeInPass;
            };
            Effect.prototype.setAnalyzeInPass = /** @inline */function (isInPass) {
                this._isAnalyzeInPass = isInPass;
            };
            Effect.prototype.setOperator = /** @inline */function (sOperator) {
                if (!((this._pCurrentInstruction) === null)) {
                    this._pCurrentInstruction.setOperator(sOperator);
                }
            };
            Effect.prototype.clearPointersForExtract = /** @inline */function () {
                this._pPointerForExtractionList.length = 0;
            };
            Effect.prototype.addPointerForExtract = /** @inline */function (pPointer) {
                this._pPointerForExtractionList.push(pPointer);
            };
            Effect.prototype.getPointerForExtractList = /** @inline */function () {
                return this._pPointerForExtractionList;
            };
            Effect.prototype.findFunction = function (sFunctionName, pArguments) {
                return Effect.findSystemFunction(sFunctionName, pArguments) || this._pEffectScope.getFunction(sFunctionName, pArguments);
            };
            Effect.prototype.findConstructor = function (pType, pArguments) {
                var pVariableType = new fx.VariableTypeInstruction();
                pVariableType.pushType(pType);
                return pVariableType;
            };
            Effect.prototype.findShaderFunction = function (sFunctionName, pArguments) {
                return this._pEffectScope.getShaderFunction(sFunctionName, pArguments);
            };
            Effect.prototype.findFunctionByDef = function (pDef) {
                return this.findFunction((pDef._pFunctionName.getName()), (pDef._pParameterList));
            };
            Effect.prototype.addVariableDecl = // private addVariable(pVariable: IAFXVariable): void {
            // }
            function (pVariable) {
                if (this.isSystemVariable(pVariable)) {
                    this._error(2235, {
                        varName: pVariable.getName()
                    });
                }
                var isVarAdded = this._pEffectScope.addVariable(pVariable);
                if (!isVarAdded) {
                    var eScopeType = ((((this)._pEffectScope)._pScopeMap[((this)._pEffectScope)._iCurrentScope].type));
                    switch(eScopeType) {
                        case fx.EScopeType.k_Default:
                            this._error(2234, {
                                varName: pVariable.getName()
                            });
                            break;
                        case fx.EScopeType.k_Struct:
                            this._error(2242, {
                                fieldName: pVariable.getName()
                            });
                            break;
                        case fx.EScopeType.k_Annotation:
                            this._error(2244, {
                                varName: pVariable.getName()
                            });
                            break;
                    }
                }
                if (pVariable.getName() === "Out" && !((((this)._pCurrentFunction)) === null)) {
                    var isOk = ((this)._pCurrentFunction)._addOutVariable(pVariable);
                    if (!isOk) {
                        this._error(2266);
                    }
                }
            };
            Effect.prototype.addTypeDecl = function (pType) {
                if (this.isSystemType(pType)) {
                    this._error(2201, {
                        typeName: pType.getName()
                    });
                }
                var isTypeAdded = this._pEffectScope.addType(pType);
                if (!isTypeAdded) {
                    this._error(2202, {
                        typeName: pType.getName()
                    });
                }
            };
            Effect.prototype.addFunctionDecl = function (pFunction) {
                if (this.isSystemFunction(pFunction)) {
                    this._error(2237, {
                        funcName: pFunction.getName()
                    });
                }
                var isFunctionAdded = this._pEffectScope.addFunction(pFunction);
                if (!isFunctionAdded) {
                    this._error(2236, {
                        funcName: pFunction.getName()
                    });
                }
            };
            Effect.prototype.addTechnique = function (pTechnique) {
                var sName = pTechnique.getName();
                if (((this._pTechniqueMap[sName]) !== undefined)) {
                    this._error(2252, {
                        techName: sName
                    });
                    return;
                }
                this._pTechniqueMap[sName] = pTechnique;
                this._pTechniqueList.push(pTechnique);
            };
            Effect.prototype.addExternalSharedVariable = function (pVariable, eShaderType) {
                var isVarAdded = this._pEffectScope.addVariable(pVariable);
                if (!isVarAdded) {
                    this._error(2278, {
                        varName: pVariable.getName()
                    });
                    return;
                }
            };
            Effect.prototype.analyzeGlobalUseDecls = function () {
                var pChildren = this._pParseTree.root.children;
                var i = 0;
                for(i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "UseDecl") {
                        this.analyzeUseDecl(pChildren[i]);
                    }
                }
            };
            Effect.prototype.analyzeGlobalProvideDecls = function () {
                var pChildren = this._pParseTree.root.children;
                var i = 0;
                for(i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "ProvideDecl") {
                        this.analyzeProvideDecl(pChildren[i]);
                    }
                }
            };
            Effect.prototype.analyzeGlobalTypeDecls = function () {
                var pChildren = this._pParseTree.root.children;
                var i = 0;
                for(i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "TypeDecl") {
                        this.analyzeTypeDecl(pChildren[i]);
                    }
                }
            };
            Effect.prototype.analyzeFunctionDefinitions = function () {
                var pChildren = this._pParseTree.root.children;
                var i = 0;
                for(i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "FunctionDecl") {
                        this.analyzeFunctionDeclOnlyDefinition(pChildren[i]);
                    }
                }
            };
            Effect.prototype.analyzeGlobalImports = function () {
                var pChildren = this._pParseTree.root.children;
                var i = 0;
                for(i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "ImportDecl") {
                        this.analyzeImportDecl(pChildren[i], null);
                    }
                }
            };
            Effect.prototype.analyzeTechniqueImports = function () {
                var pChildren = this._pParseTree.root.children;
                var i = 0;
                for(i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "TechniqueDecl") {
                        this.analyzeTechniqueForImport(pChildren[i]);
                    }
                }
            };
            Effect.prototype.analyzeVariableDecls = function () {
                var pChildren = this._pParseTree.root.children;
                var i = 0;
                for(i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "VariableDecl") {
                        this.analyzeVariableDecl(pChildren[i]);
                    } else if (pChildren[i].name === "VarStructDecl") {
                        this.analyzeVarStructDecl(pChildren[i]);
                    }
                }
            };
            Effect.prototype.analyzeFunctionDecls = function () {
                for(var i = 0; i < this._pFunctionWithImplementationList.length; i++) {
                    this.resumeFunctionAnalysis(this._pFunctionWithImplementationList[i]);
                }
                this.checkFunctionsForRecursion();
                this.checkFunctionForCorrectUsage();
                this.generateInfoAboutUsedData();
                this.generateShadersFromFunctions();
            };
            Effect.prototype.analyzeTechniques = function () {
                for(var i = 0; i < this._pTechniqueList.length; i++) {
                    this.resumeTechniqueAnalysis(this._pTechniqueList[i]);
                }
            };
            Effect.prototype.checkFunctionsForRecursion = function () {
                var pFunctionList = this._pFunctionWithImplementationList;
                var isNewAdd = true;
                var isNewDelete = true;
                while(isNewAdd || isNewDelete) {
                    isNewAdd = false;
                    isNewDelete = false;
                    mainFor:
for(var i = 0; i < pFunctionList.length; i++) {
                        var pTestedFunction = pFunctionList[i];
                        var pUsedFunctionList = pTestedFunction._getUsedFunctionList();
                        if (!pTestedFunction._isUsed()) {
                            //WARNING("Unused function '" + pTestedFunction._getStringDef() + "'.");
                            continue mainFor;
                        }
                        if (pTestedFunction._isBlackListFunction()) {
                            continue mainFor;
                        }
                        if (((pUsedFunctionList) === null)) {
                            continue mainFor;
                        }
                        for(var j = 0; j < pUsedFunctionList.length; j++) {
                            var pAddedUsedFunctionList = pUsedFunctionList[j]._getUsedFunctionList();
                            if (((pAddedUsedFunctionList) === null)) {
                                continue;
                            }
                            for(var k = 0; k < pAddedUsedFunctionList.length; k++) {
                                var pAddedFunction = pAddedUsedFunctionList[k];
                                if (pTestedFunction === pAddedFunction) {
                                    pTestedFunction._addToBlackList();
                                    isNewDelete = true;
                                    this._error(2255, {
                                        funcDef: pTestedFunction._getStringDef()
                                    });
                                    continue mainFor;
                                }
                                if (pAddedFunction._isBlackListFunction() || !pAddedFunction._canUsedAsFunction()) {
                                    pTestedFunction._addToBlackList();
                                    this._error(2256, {
                                        funcDef: pTestedFunction._getStringDef()
                                    });
                                    isNewDelete = true;
                                    continue mainFor;
                                }
                                if (pTestedFunction._addUsedFunction(pAddedFunction)) {
                                    isNewAdd = true;
                                }
                            }
                        }
                    }
                }
            };
            Effect.prototype.checkFunctionForCorrectUsage = function () {
                var pFunctionList = this._pFunctionWithImplementationList;
                var isNewUsageSet = true;
                var isNewDelete = true;
                while(isNewUsageSet || isNewDelete) {
                    isNewUsageSet = false;
                    isNewDelete = false;
                    mainFor:
for(var i = 0; i < pFunctionList.length; i++) {
                        var pTestedFunction = pFunctionList[i];
                        var pUsedFunctionList = pTestedFunction._getUsedFunctionList();
                        if (!pTestedFunction._isUsed()) {
                            //WARNING("Unused function '" + pTestedFunction._getStringDef() + "'.");
                            continue mainFor;
                        }
                        if (pTestedFunction._isBlackListFunction()) {
                            continue mainFor;
                        }
                        if (!pTestedFunction._checkVertexUsage()) {
                            this._error(2257, {
                                funcDef: pTestedFunction._getStringDef()
                            });
                            pTestedFunction._addToBlackList();
                            isNewDelete = true;
                            continue mainFor;
                        }
                        if (!pTestedFunction._checkPixelUsage()) {
                            this._error(2258, {
                                funcDef: pTestedFunction._getStringDef()
                            });
                            pTestedFunction._addToBlackList();
                            isNewDelete = true;
                            continue mainFor;
                        }
                        if (((pUsedFunctionList) === null)) {
                            continue mainFor;
                        }
                        for(var j = 0; j < pUsedFunctionList.length; j++) {
                            var pUsedFunction = pUsedFunctionList[j];
                            if (pTestedFunction._isUsedInVertex()) {
                                if (!pUsedFunction._isForVertex()) {
                                    this._error(2257, {
                                        funcDef: pTestedFunction._getStringDef()
                                    });
                                    pTestedFunction._addToBlackList();
                                    isNewDelete = true;
                                    continue mainFor;
                                }
                                if (!pUsedFunction._isUsedInVertex()) {
                                    pUsedFunction._markUsedInVertex();
                                    isNewUsageSet = true;
                                }
                            }
                            if (pTestedFunction._isUsedInPixel()) {
                                if (!pUsedFunction._isForPixel()) {
                                    this._error(2258, {
                                        funcDef: pTestedFunction._getStringDef()
                                    });
                                    pTestedFunction._addToBlackList();
                                    isNewDelete = true;
                                    continue mainFor;
                                }
                                if (!pUsedFunction._isUsedInPixel()) {
                                    pUsedFunction._markUsedInPixel();
                                    isNewUsageSet = true;
                                }
                            }
                        }
                    }
                }
                return;
            };
            Effect.prototype.generateInfoAboutUsedData = function () {
                var pFunctionList = this._pFunctionWithImplementationList;
                for(var i = 0; i < pFunctionList.length; i++) {
                    pFunctionList[i]._generateInfoAboutUsedData();
                }
            };
            Effect.prototype.generateShadersFromFunctions = function () {
                var pFunctionList = this._pFunctionWithImplementationList;
                for(var i = 0; i < pFunctionList.length; i++) {
                    var pShader = null;
                    if (pFunctionList[i]._isUsedAsVertex()) {
                        pShader = pFunctionList[i]._convertToVertexShader();
                    }
                    if (pFunctionList[i]._isUsedAsPixel()) {
                        pShader = pFunctionList[i]._convertToPixelShader();
                    }
                }
            };
            Effect.prototype.analyzeVariableDecl = function (pNode, pInstruction) {
                if (typeof pInstruction === "undefined") { pInstruction = null; }
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pGeneralType = null;
                var pVariable = null;
                var i = 0;
                pGeneralType = this.analyzeUsageType(pChildren[pChildren.length - 1]);
                for(i = pChildren.length - 2; i >= 1; i--) {
                    if (pChildren[i].name === "Variable") {
                        pVariable = this.analyzeVariable(pChildren[i], pGeneralType);
                        if (!((pInstruction) === null)) {
                            pInstruction.push(pVariable, true);
                            if (pInstruction._getInstructionType() === akra.EAFXInstructionTypes.k_DeclStmtInstruction) {
                                var pVariableSubDecls = pVariable.getSubVarDecls();
                                if (!((pVariableSubDecls) === null)) {
                                    for(var j = 0; j < pVariableSubDecls.length; j++) {
                                        pInstruction.push(pVariableSubDecls[j], false);
                                    }
                                }
                            }
                        }
                    }
                }
            };
            Effect.prototype.analyzeUsageType = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var i = 0;
                var pType = new fx.VariableTypeInstruction();
                for(i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "Type") {
                        var pMainType = this.analyzeType(pChildren[i]);
                        pType.pushType(pMainType);
                    } else if (pChildren[i].name === "Usage") {
                        var sUsage = this.analyzeUsage(pChildren[i]);
                        pType.addUsage(sUsage);
                    }
                }
                if (!pType.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error((pType.getLastError()).code, (((pType.getLastError()).info) === null) ? {} : (pType.getLastError()).info));
                }
                ;
                return pType;
            };
            Effect.prototype.analyzeType = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pType = null;
                switch(pNode.name) {
                    case "T_TYPE_ID":
                        pType = this.getType(pNode.value);
                        if (((pType) === null)) {
                            this._error(2250, {
                                typeName: pNode.value
                            });
                        }
                        break;
                    case "Struct":
                        pType = this.analyzeStruct(pNode);
                        break;
                    case "T_KW_VOID":
                        pType = Effect.getSystemType("void");
                        break;
                    case "ScalarType":
                    case "ObjectType":
                        pType = this.getType(pChildren[pChildren.length - 1].value);
                        if (((pType) === null)) {
                            this._error(2250, {
                                typeName: pChildren[pChildren.length - 1].value
                            });
                        }
                        break;
                    case "VectorType":
                    case "MatrixType":
                        this._error(2251);
                        break;
                    case "BaseType":
                    case "Type":
                        return this.analyzeType(pChildren[0]);
                }
                return pType;
            };
            Effect.prototype.analyzeUsage = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                pNode = pNode.children[0];
                return pNode.value;
            };
            Effect.prototype.analyzeVariable = function (pNode, pGeneralType) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pVarDecl = new fx.VariableDeclInstruction();
                var pVariableType = new fx.VariableTypeInstruction();
                var pAnnotation = null;
                var sSemantic = "";
                var pInitExpr = null;
                pVarDecl.push(pVariableType, true);
                pVariableType.pushType(pGeneralType);
                pVarDecl._setScope(((this)._pEffectScope.getScope()));
                this.analyzeVariableDim(pChildren[pChildren.length - 1], pVarDecl);
                var i = 0;
                for(i = pChildren.length - 2; i >= 0; i--) {
                    if (pChildren[i].name === "Annotation") {
                        pAnnotation = this.analyzeAnnotation(pChildren[i]);
                        pVarDecl.setAnnotation(pAnnotation);
                    } else if (pChildren[i].name === "Semantic") {
                        sSemantic = this.analyzeSemantic(pChildren[i]);
                        pVarDecl.setSemantic(sSemantic);
                        pVarDecl.getNameId().setRealName(sSemantic);
                    } else if (pChildren[i].name === "Initializer") {
                        pInitExpr = this.analyzeInitializer(pChildren[i]);
                        if (!pInitExpr.optimizeForVariableType(pVariableType)) {
                            this._error(2269, {
                                varName: pVarDecl.getName()
                            });
                            return null;
                        }
                        pVarDecl.push(pInitExpr, true);
                    }
                }
                if (!pVarDecl.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error((pVarDecl.getLastError()).code, (((pVarDecl.getLastError()).info) === null) ? {} : (pVarDecl.getLastError()).info));
                }
                ;
                this.addVariableDecl(pVarDecl);
                return pVarDecl;
            };
            Effect.prototype.analyzeVariableDim = function (pNode, pVariableDecl) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pVariableType = pVariableDecl.getType();
                if (pChildren.length === 1) {
                    var pName = new fx.IdInstruction();
                    pName.setName(pChildren[0].value);
                    pVariableDecl.push(pName, true);
                    return;
                }
                this.analyzeVariableDim(pChildren[pChildren.length - 1], pVariableDecl);
                if (pChildren.length === 3) {
                    pVariableType.addPointIndex(true);
                } else if (pChildren.length === 4 && pChildren[0].name === "FromExpr") {
                    var pBuffer = this.analyzeFromExpr(pChildren[0]);
                    pVariableType.addPointIndex(true);
                    pVariableType.setVideoBuffer(pBuffer);
                } else {
                    if (pVariableType.isPointer()) {
                        //TODO: add support for v[][10]
                        this._error(2300);
                    }
                    var pIndexExpr = this.analyzeExpr(pChildren[pChildren.length - 3]);
                    pVariableType.addArrayIndex(pIndexExpr);
                }
            };
            Effect.prototype.analyzeAnnotation = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                return null;
            };
            Effect.prototype.analyzeSemantic = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var sSemantic = pNode.children[0].value;
                // var pDecl: IAFXDeclInstruction = <IAFXDeclInstruction>this._pCurrentInstruction;
                // pDecl.setSemantic(sSemantic);
                return sSemantic;
            };
            Effect.prototype.analyzeInitializer = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pInitExpr = new fx.InitExprInstruction();
                if (pChildren.length === 2) {
                    pInitExpr.push(this.analyzeExpr(pChildren[0]), true);
                } else {
                    for(var i = pChildren.length - 3; i >= 1; i--) {
                        if (pChildren[i].name === "InitExpr") {
                            pInitExpr.push(this.analyzeInitExpr(pChildren[i]), true);
                        }
                    }
                }
                return pInitExpr;
            };
            Effect.prototype.analyzeFromExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pBuffer = null;
                if (pChildren[1].name === "T_NON_TYPE_ID") {
                    pBuffer = (Effect.getSystemVariable((pChildren[1].value)) || (this)._pEffectScope.getVariable((pChildren[1].value)));
                } else {
                    pBuffer = (this.analyzeMemExpr(pChildren[1])).getBuffer();
                }
                return pBuffer;
            };
            Effect.prototype.analyzeInitExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pInitExpr = new fx.InitExprInstruction();
                if (pChildren.length === 1) {
                    pInitExpr.push(this.analyzeExpr(pChildren[0]), true);
                } else {
                    for(var i = 0; i < pChildren.length; i++) {
                        if (pChildren[i].name === "InitExpr") {
                            pInitExpr.push(this.analyzeInitExpr(pChildren[i]), true);
                        }
                    }
                }
                return pInitExpr;
            };
            Effect.prototype.analyzeExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var sName = pNode.name;
                switch(sName) {
                    case "ObjectExpr":
                        return this.analyzeObjectExpr(pNode);
                    case "ComplexExpr":
                        return this.analyzeComplexExpr(pNode);
                    case "PrimaryExpr":
                        return this.analyzePrimaryExpr(pNode);
                    case "PostfixExpr":
                        return this.analyzePostfixExpr(pNode);
                    case "UnaryExpr":
                        return this.analyzeUnaryExpr(pNode);
                    case "CastExpr":
                        return this.analyzeCastExpr(pNode);
                    case "ConditionalExpr":
                        return this.analyzeConditionalExpr(pNode);
                    case "MulExpr":
                    case "AddExpr":
                        return this.analyzeArithmeticExpr(pNode);
                    case "RelationalExpr":
                    case "EqualityExpr":
                        return this.analyzeRelationExpr(pNode);
                    case "AndExpr":
                    case "OrExpr":
                        return this.analyzeLogicalExpr(pNode);
                    case "AssignmentExpr":
                        return this.analyzeAssignmentExpr(pNode);
                    case "T_NON_TYPE_ID":
                        return this.analyzeIdExpr(pNode);
                    case "T_STRING":
                    case "T_UINT":
                    case "T_FLOAT":
                    case "T_KW_TRUE":
                    case "T_KW_FALSE":
                        return this.analyzeSimpleExpr(pNode);
                    case "MemExpr":
                        return this.analyzeMemExpr(pNode);
                    default:
                        this._error(2204, {
                            exprName: sName
                        });
                        break;
                }
                return null;
            };
            Effect.prototype.analyzeObjectExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var sName = pNode.children[pNode.children.length - 1].name;
                switch(sName) {
                    case "T_KW_COMPILE":
                        return this.analyzeCompileExpr(pNode);
                    case "T_KW_SAMPLER_STATE":
                        return this.analyzeSamplerStateBlock(pNode);
                }
            };
            Effect.prototype.analyzeCompileExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pExpr = new fx.CompileExprInstruction();
                var pExprType;
                var pArguments = null;
                var sShaderFuncName = pChildren[pChildren.length - 2].value;
                var pShaderFunc = null;
                var i = 0;
                pArguments = [];
                if (pChildren.length > 4) {
                    var pArgumentExpr;
                    for(i = pChildren.length - 3; i > 0; i--) {
                        if (pChildren[i].value !== ",") {
                            pArgumentExpr = this.analyzeExpr(pChildren[i]);
                            pArguments.push(pArgumentExpr);
                        }
                    }
                }
                pShaderFunc = this.findShaderFunction(sShaderFuncName, pArguments);
                if (((pShaderFunc) === null)) {
                    this._error(2226, {
                        funcName: sShaderFuncName
                    });
                    return null;
                }
                pExprType = (pShaderFunc.getType()).wrap();
                pExpr.setType(pExprType);
                (pExpr._sOperatorName = ("complile"));
                pExpr.push(pShaderFunc.getNameId(), false);
                if (!((pArguments) === null)) {
                    for(i = 0; i < pArguments.length; i++) {
                        pExpr.push(pArguments[i], true);
                    }
                }
                if (!pExpr.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pExpr._pLastError)).code, ((((pExpr._pLastError)).info) === null) ? {} : ((pExpr._pLastError)).info));
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeSamplerStateBlock = function (pNode) {
                pNode = pNode.children[0];
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pExpr = new fx.SamplerStateBlockInstruction();
                var i = 0;
                (pExpr._sOperatorName = ("sample_state"));
                for(i = pChildren.length - 2; i >= 1; i--) {
                    this.analyzeSamplerState(pChildren[i], pExpr);
                }
                if (!pExpr.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pExpr._pLastError)).code, ((((pExpr._pLastError)).info) === null) ? {} : ((pExpr._pLastError)).info));
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeSamplerState = function (pNode, pSamplerStates) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                if (pChildren[pChildren.length - 2].name === "StateIndex") {
                    this._error(2270);
                    return;
                }
                var pStateExprNode = pChildren[pChildren.length - 3];
                var pSubStateExprNode = pStateExprNode.children[pStateExprNode.children.length - 1];
                var sStateType = pChildren[pChildren.length - 1].value.toUpperCase();
                var sStateValue = "";
                var isTexture = false;
                if (((pSubStateExprNode.value) === null)) {
                    this._error(2271);
                    return;
                }
                var pTexture = null;
                switch(sStateType) {
                    case "TEXTURE":
                        var pTexture = null;
                        if (pStateExprNode.children.length !== 3 || pSubStateExprNode.value === "{") {
                            this._error(2271);
                            return;
                        }
                        var sTextureName = pStateExprNode.children[1].value;
                        if (((sTextureName) === null) || !((this)._pEffectScope.hasVariable((sTextureName)))) {
                            this._error(2271);
                            return;
                        }
                        pTexture = (Effect.getSystemVariable((sTextureName)) || (this)._pEffectScope.getVariable((sTextureName)));
                        sStateValue = sTextureName;
                        break;
                        /* WRAP_S */
                                            case "ADDRESSU":
                        /* WRAP_T */
                                            case "ADDRESSV":
                        sStateValue = pSubStateExprNode.value.toUpperCase();
                        switch(sStateValue) {
                            case "WRAP":
                            case "CLAMP":
                            case "MIRROR":
                                break;
                            default:
 {
                                    akra.logger.setSourceLocation("fx/Effect.ts", 2080);
                                    akra.logger.warning("Webgl don`t support this wrapmode: " + sStateValue);
                                }
                                ;
                                return;
                        }
                        break;
                    case "MAGFILTER":
                    case "MINFILTER":
                        sStateValue = pSubStateExprNode.value.toUpperCase();
                        switch(sStateValue) {
                            case "POINT":
                                sStateValue = "NEAREST";
                                break;
                            case "POINT_MIPMAP_POINT":
                                sStateValue = "NEAREST_MIPMAP_NEAREST";
                                break;
                            case "LINEAR_MIPMAP_POINT":
                                sStateValue = "LINEAR_MIPMAP_NEAREST";
                                break;
                            case "POINT_MIPMAP_LINEAR":
                                sStateValue = "NEAREST_MIPMAP_LINEAR";
                                break;
                            case "NEAREST":
                            case "LINEAR":
                            case "NEAREST_MIPMAP_NEAREST":
                            case "LINEAR_MIPMAP_NEAREST":
                            case "NEAREST_MIPMAP_LINEAR":
                            case "LINEAR_MIPMAP_LINEAR":
                                break;
                            default:
 {
                                    akra.logger.setSourceLocation("fx/Effect.ts", 2110);
                                    akra.logger.warning("Webgl don`t support this texture filter: " + sStateValue);
                                }
                                ;
                                return;
                        }
                        break;
                    default:
 {
                            akra.logger.setSourceLocation("fx/Effect.ts", 2116);
                            akra.logger.warning("Don`t support this texture param: " + sStateType);
                        }
                        ;
                        return;
                }
                if (sStateType !== "TEXTURE") {
                    pSamplerStates.addState(sStateType, sStateValue);
                } else {
                    pSamplerStates.setTexture(pTexture);
                }
            };
            Effect.prototype.analyzeComplexExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var sFirstNodeName = pChildren[pChildren.length - 1].name;
                switch(sFirstNodeName) {
                    case "T_NON_TYPE_ID":
                        return this.analyzeFunctionCallExpr(pNode);
                    case "BaseType":
                    case "T_TYPE_ID":
                        return this.analyzeConstructorCallExpr(pNode);
                    default:
                        return this.analyzeSimpleComplexExpr(pNode);
                }
            };
            Effect.prototype.analyzeFunctionCallExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pExpr = null;
                var pExprType = null;
                var pArguments = null;
                var sFuncName = pChildren[pChildren.length - 1].value;
                var pFunction = null;
                var pFunctionId = null;
                var i = 0;
                var pCurrentAnalyzedFunction = ((this)._pCurrentFunction);
                if (pChildren.length > 3) {
                    var pArgumentExpr;
                    pArguments = [];
                    for(i = pChildren.length - 3; i > 0; i--) {
                        if (pChildren[i].value !== ",") {
                            pArgumentExpr = this.analyzeExpr(pChildren[i]);
                            pArguments.push(pArgumentExpr);
                        }
                    }
                }
                pFunction = this.findFunction(sFuncName, pArguments);
                if (((pFunction) === null)) {
                    this._error(2223, {
                        funcName: sFuncName
                    });
                    return null;
                }
                if (!((pFunction) !== undefined)) {
                    this._error(2246, {
                        funcName: sFuncName
                    });
                    return null;
                }
                if (!((pCurrentAnalyzedFunction) === null)) {
                    if (!pFunction._isForPixel()) {
                        pCurrentAnalyzedFunction._setForPixel(false);
                    }
                    if (!pFunction._isForVertex()) {
                        pCurrentAnalyzedFunction._setForVertex(false);
                    }
                }
                if (pFunction._getInstructionType() === akra.EAFXInstructionTypes.k_FunctionDeclInstruction) {
                    var pFunctionCallExpr = new fx.FunctionCallInstruction();
                    pFunctionId = new fx.IdExprInstruction();
                    pFunctionId.push(pFunction.getNameId(), false);
                    pExprType = (pFunction.getType()).wrap();
                    pFunctionCallExpr.setType(pExprType);
                    pFunctionCallExpr.push(pFunctionId, true);
                    if (!((pArguments) === null)) {
                        for(i = 0; i < pArguments.length; i++) {
                            pFunctionCallExpr.push(pArguments[i], true);
                        }
                        var pFunctionArguments = (pFunction).getArguments();
                        for(i = 0; i < pArguments.length; i++) {
                            if (pFunctionArguments[i].getType().hasUsage("out")) {
                                if (!pArguments[i].getType().isWritable()) {
                                    this._error(2267);
                                    return null;
                                }
                                if (pArguments[i].getType().isStrongEqual(Effect.getSystemType("ptr"))) {
                                    ((this)._pPointerForExtractionList.push((pArguments[i].getType()._getParentVarDecl())));
                                }
                            } else if (pFunctionArguments[i].getType().hasUsage("inout")) {
                                if (!pArguments[i].getType().isWritable()) {
                                    this._error(2267);
                                    return null;
                                }
                                if (!pArguments[i].getType().isReadable()) {
                                    this._error(2268);
                                    return null;
                                }
                                if (pArguments[i].getType().isStrongEqual(Effect.getSystemType("ptr"))) {
                                    ((this)._pPointerForExtractionList.push((pArguments[i].getType()._getParentVarDecl())));
                                }
                            } else {
                                if (!pArguments[i].getType().isReadable()) {
                                    this._error(2268);
                                    return null;
                                }
                            }
                        }
                        for(i = pArguments.length; i < pFunctionArguments.length; i++) {
                            pFunctionCallExpr.push(pFunctionArguments[i].getInitializeExpr(), false);
                        }
                    }
                    if (!((pCurrentAnalyzedFunction) === null)) {
                        pCurrentAnalyzedFunction._addUsedFunction(pFunction);
                    }
                    pFunction._markUsedAs(akra.EFunctionType.k_Function);
                    pExpr = pFunctionCallExpr;
                } else {
                    var pSystemCallExpr = new fx.SystemCallInstruction();
                    pSystemCallExpr.setSystemCallFunction(pFunction);
                    pSystemCallExpr.fillByArguments(pArguments);
                    if (!((pCurrentAnalyzedFunction) === null)) {
                        for(i = 0; i < pArguments.length; i++) {
                            if (!pArguments[i].getType().isReadable()) {
                                this._error(2268);
                                return null;
                            }
                        }
                    }
                    pExpr = pSystemCallExpr;
                    if (!pFunction.isBuiltIn() && !((pCurrentAnalyzedFunction) === null)) {
                        pCurrentAnalyzedFunction._addUsedFunction(pFunction);
                    }
                }
                if (!pExpr.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error((pExpr.getLastError()).code, (((pExpr.getLastError()).info) === null) ? {} : (pExpr.getLastError()).info));
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeConstructorCallExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pExpr = new fx.ConstructorCallInstruction();
                var pExprType = null;
                var pArguments = null;
                var pConstructorType = null;
                var i = 0;
                pConstructorType = this.analyzeType(pChildren[pChildren.length - 1]);
                if (((pConstructorType) === null)) {
                    this._error(2224);
                    return null;
                }
                if (pChildren.length > 3) {
                    var pArgumentExpr = null;
                    pArguments = [];
                    for(i = pChildren.length - 3; i > 0; i--) {
                        if (pChildren[i].value !== ",") {
                            pArgumentExpr = this.analyzeExpr(pChildren[i]);
                            pArguments.push(pArgumentExpr);
                        }
                    }
                }
                pExprType = this.findConstructor(pConstructorType, pArguments);
                if (((pExprType) === null)) {
                    this._error(2225, {
                        typeName: pConstructorType.toString()
                    });
                    return null;
                }
                pExpr.setType(pExprType);
                pExpr.push(pConstructorType, false);
                if (!((pArguments) === null)) {
                    for(i = 0; i < pArguments.length; i++) {
                        if (!pArguments[i].getType().isReadable()) {
                            this._error(2268);
                            return null;
                        }
                        pExpr.push(pArguments[i], true);
                    }
                }
                if (!pExpr.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pExpr._pLastError)).code, ((((pExpr._pLastError)).info) === null) ? {} : ((pExpr._pLastError)).info));
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeSimpleComplexExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pExpr = new fx.ComplexExprInstruction();
                var pComplexExpr;
                var pExprType;
                pComplexExpr = this.analyzeExpr(pChildren[1]);
                pExprType = pComplexExpr.getType();
                pExpr.setType(pExprType);
                pExpr.push(pComplexExpr, true);
                if (!pExpr.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pExpr._pLastError)).code, ((((pExpr._pLastError)).info) === null) ? {} : ((pExpr._pLastError)).info));
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzePrimaryExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pExpr = new fx.PrimaryExprInstruction();
                var pPrimaryExpr;
                var pPointer = null;
                var pPrimaryExprType;
                pPrimaryExpr = this.analyzeExpr(pChildren[0]);
                pPrimaryExprType = pPrimaryExpr.getType();
                pPointer = pPrimaryExprType.getPointer();
                if (((pPointer) === null)) {
                    this._error(2222, {
                        typeName: pPrimaryExprType.getHash()
                    });
                    return null;
                }
                var pPointerVarType = pPrimaryExprType.getParent();
                if (!pPrimaryExprType.isStrictPointer()) {
                    ((this)._pCurrentFunction)._setForPixel(false);
                    ((this)._pCurrentFunction)._notCanUsedAsFunction();
                    pPrimaryExprType._setPointerToStrict();
                }
                pExpr.setType(pPointer.getType());
                (pExpr._sOperatorName = ("@"));
                pExpr.push(pPointer.getNameId(), false);
                if (!pExpr.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pExpr._pLastError)).code, ((((pExpr._pLastError)).info) === null) ? {} : ((pExpr._pLastError)).info));
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzePostfixExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var sSymbol = pChildren[pChildren.length - 2].value;
                switch(sSymbol) {
                    case "[":
                        return this.analyzePostfixIndex(pNode);
                    case ".":
                        return this.analyzePostfixPoint(pNode);
                    case "++":
                    case "--":
                        return this.analyzePostfixArithmetic(pNode);
                }
            };
            Effect.prototype.analyzePostfixIndex = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pExpr = new fx.PostfixIndexInstruction();
                var pPostfixExpr = null;
                var pIndexExpr = null;
                var pExprType = null;
                var pPostfixExprType = null;
                var pIndexExprType = null;
                var pIntType = null;
                pPostfixExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pPostfixExprType = pPostfixExpr.getType();
                if (!pPostfixExprType.isArray()) {
                    this._error(2217, {
                        typeName: pPostfixExprType.toString()
                    });
                    return null;
                }
                pIndexExpr = this.analyzeExpr(pChildren[pChildren.length - 3]);
                pIndexExprType = pIndexExpr.getType();
                pIntType = Effect.getSystemType("int");
                if (!pIndexExprType.isEqual(pIntType)) {
                    this._error(2218, {
                        typeName: pIndexExprType.toString()
                    });
                    return null;
                }
                pExprType = (pPostfixExprType.getArrayElementType());
                pExpr.setType(pExprType);
                pExpr.push(pPostfixExpr, true);
                pExpr.push(pIndexExpr, true);
                if (!pExpr.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pExpr._pLastError)).code, ((((pExpr._pLastError)).info) === null) ? {} : ((pExpr._pLastError)).info));
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzePostfixPoint = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pExpr = new fx.PostfixPointInstruction();
                var pPostfixExpr = null;
                var sFieldName = "";
                var pFieldNameExpr = null;
                var pExprType = null;
                var pPostfixExprType = null;
                pPostfixExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pPostfixExprType = pPostfixExpr.getType();
                sFieldName = pChildren[pChildren.length - 3].value;
                pFieldNameExpr = pPostfixExprType.getFieldExpr(sFieldName);
                if (((pFieldNameExpr) === null)) {
                    this._error(2219, {
                        typeName: pPostfixExprType.toString(),
                        fieldName: sFieldName
                    });
                    return null;
                }
                pExprType = pFieldNameExpr.getType();
                if (pChildren.length === 4) {
                    if (!pExprType.isPointer()) {
                        this._error(2220, {
                            typeName: pExprType.toString()
                        });
                        return null;
                    }
                    var pBuffer = this.analyzeFromExpr(pChildren[0]);
                    pExprType.setVideoBuffer(pBuffer);
                }
                pExpr.setType(pExprType);
                pExpr.push(pPostfixExpr, true);
                pExpr.push(pFieldNameExpr, true);
                if (!pExpr.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pExpr._pLastError)).code, ((((pExpr._pLastError)).info) === null) ? {} : ((pExpr._pLastError)).info));
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzePostfixArithmetic = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var sOperator = pChildren[0].value;
                var pExpr = new fx.PostfixArithmeticInstruction();
                var pPostfixExpr;
                var pExprType;
                var pPostfixExprType;
                pPostfixExpr = this.analyzeExpr(pChildren[1]);
                pPostfixExprType = pPostfixExpr.getType();
                pExprType = this.checkOneOperandExprType(sOperator, pPostfixExprType);
                if (((pExprType) === null)) {
                    this._error(2221, {
                        operator: sOperator,
                        typeName: pPostfixExprType.toString()
                    });
                    return null;
                }
                pExpr.setType(pExprType);
                (pExpr._sOperatorName = (sOperator));
                pExpr.push(pPostfixExpr, true);
                if (!pExpr.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pExpr._pLastError)).code, ((((pExpr._pLastError)).info) === null) ? {} : ((pExpr._pLastError)).info));
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeUnaryExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var sOperator = pChildren[1].value;
                var pExpr = new fx.UnaryExprInstruction();
                var pUnaryExpr;
                var pExprType;
                var pUnaryExprType;
                pUnaryExpr = this.analyzeExpr(pChildren[0]);
                pUnaryExprType = pUnaryExpr.getType();
                pExprType = this.checkOneOperandExprType(sOperator, pUnaryExprType);
                if (((pExprType) === null)) {
                    this._error(2216, {
                        operator: sOperator,
                        tyepName: pUnaryExprType.toString()
                    });
                    return null;
                }
                (pExpr._sOperatorName = (sOperator));
                pExpr.setType(pExprType);
                pExpr.push(pUnaryExpr, true);
                if (!pExpr.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pExpr._pLastError)).code, ((((pExpr._pLastError)).info) === null) ? {} : ((pExpr._pLastError)).info));
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeCastExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pExpr = new fx.CastExprInstruction();
                var pExprType;
                var pCastedExpr;
                pExprType = this.analyzeConstTypeDim(pChildren[2]);
                pCastedExpr = this.analyzeExpr(pChildren[0]);
                if (!(pCastedExpr.getType()).isReadable()) {
                    this._error(2268);
                    return null;
                }
                pExpr.setType(pExprType);
                pExpr.push(pExprType, true);
                pExpr.push(pCastedExpr, true);
                if (!pExpr.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pExpr._pLastError)).code, ((((pExpr._pLastError)).info) === null) ? {} : ((pExpr._pLastError)).info));
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeConditionalExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pExpr = new fx.ConditionalExprInstruction();
                var pConditionExpr;
                var pTrueExpr;
                var pFalseExpr;
                var pConditionType;
                var pTrueExprType;
                var pFalseExprType;
                var pExprType;
                var pBoolType;
                pConditionExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pTrueExpr = this.analyzeExpr(pChildren[pChildren.length - 3]);
                pFalseExpr = this.analyzeExpr(pChildren[0]);
                pConditionType = pConditionExpr.getType();
                pTrueExprType = pTrueExpr.getType();
                pFalseExprType = pFalseExpr.getType();
                pBoolType = Effect.getSystemType("bool");
                if (!pConditionType.isEqual(pBoolType)) {
                    this._error(2211, {
                        typeName: pConditionType.toString()
                    });
                    return null;
                }
                if (!pTrueExprType.isEqual(pFalseExprType)) {
                    this._error(2212, {
                        leftTypeName: pTrueExprType.toString(),
                        rightTypeName: pFalseExprType.toString()
                    });
                    return null;
                }
                if (!pConditionType.isReadable()) {
                    this._error(2268);
                    return null;
                }
                if (!pTrueExprType.isReadable()) {
                    this._error(2268);
                    return null;
                }
                if (!pFalseExprType.isReadable()) {
                    this._error(2268);
                    return null;
                }
                pExpr.setType(pTrueExprType);
                pExpr.push(pConditionExpr, true);
                pExpr.push(pTrueExpr, true);
                pExpr.push(pFalseExpr, true);
                if (!pExpr.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pExpr._pLastError)).code, ((((pExpr._pLastError)).info) === null) ? {} : ((pExpr._pLastError)).info));
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeArithmeticExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var sOperator = pNode.children[1].value;
                var pExpr = new fx.ArithmeticExprInstruction();
                var pLeftExpr = null;
                var pRightExpr = null;
                var pLeftType = null;
                var pRightType = null;
                var pExprType = null;
                pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pRightExpr = this.analyzeExpr(pChildren[0]);
                pLeftType = pLeftExpr.getType();
                pRightType = pRightExpr.getType();
                pExprType = this.checkTwoOperandExprTypes(sOperator, pLeftType, pRightType);
                if (((pExprType) === null)) {
                    this._error(2206, {
                        operator: sOperator,
                        leftTypeName: pLeftType.toString(),
                        rightTypeName: pRightType.toString()
                    });
                    return null;
                }
                (pExpr._sOperatorName = (sOperator));
                pExpr.setType(pExprType);
                pExpr.push(pLeftExpr, true);
                pExpr.push(pRightExpr, true);
                if (!pExpr.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pExpr._pLastError)).code, ((((pExpr._pLastError)).info) === null) ? {} : ((pExpr._pLastError)).info));
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeRelationExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var sOperator = pNode.children[1].value;
                var pExpr = new fx.RelationalExprInstruction();
                var pLeftExpr;
                var pRightExpr;
                var pLeftType;
                var pRightType;
                var pExprType;
                pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pRightExpr = this.analyzeExpr(pChildren[0]);
                pLeftType = pLeftExpr.getType();
                pRightType = pRightExpr.getType();
                pExprType = this.checkTwoOperandExprTypes(sOperator, pLeftType, pRightType);
                if (((pExprType) === null)) {
                    this._error(2209, {
                        operator: sOperator,
                        leftTypeName: pLeftType.getHash(),
                        rightTypeName: pRightType.getHash()
                    });
                    return null;
                }
                (pExpr._sOperatorName = (sOperator));
                pExpr.setType(pExprType);
                pExpr.push(pLeftExpr, true);
                pExpr.push(pRightExpr, true);
                if (!pExpr.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pExpr._pLastError)).code, ((((pExpr._pLastError)).info) === null) ? {} : ((pExpr._pLastError)).info));
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeLogicalExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var sOperator = pNode.children[1].value;
                var pExpr = new fx.LogicalExprInstruction();
                var pLeftExpr;
                var pRightExpr;
                var pLeftType;
                var pRightType;
                var pBoolType;
                pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pRightExpr = this.analyzeExpr(pChildren[0]);
                pLeftType = pLeftExpr.getType();
                pRightType = pRightExpr.getType();
                pBoolType = Effect.getSystemType("bool");
                if (!pLeftType.isEqual(pBoolType)) {
                    this._error(2210, {
                        operator: sOperator,
                        typeName: pLeftType.toString()
                    });
                    return null;
                }
                if (!pRightType.isEqual(pBoolType)) {
                    this._error(2210, {
                        operator: sOperator,
                        typeName: pRightType.toString()
                    });
                    return null;
                }
                if (!pLeftType.isReadable()) {
                    this._error(2268);
                    return null;
                }
                if (!pRightType.isReadable()) {
                    this._error(2268);
                    return null;
                }
                (pExpr._sOperatorName = (sOperator));
                pExpr.setType((((pBoolType))._pWrapVariableType));
                pExpr.push(pLeftExpr, true);
                pExpr.push(pRightExpr, true);
                if (!pExpr.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pExpr._pLastError)).code, ((((pExpr._pLastError)).info) === null) ? {} : ((pExpr._pLastError)).info));
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeAssignmentExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var sOperator = pChildren[1].value;
                var pExpr = new fx.AssignmentExprInstruction();
                var pLeftExpr;
                var pRightExpr;
                var pLeftType;
                var pRightType;
                var pExprType;
                pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pRightExpr = this.analyzeExpr(pChildren[0]);
                pLeftType = pLeftExpr.getType();
                pRightType = pRightExpr.getType();
                if (sOperator !== "=") {
                    pExprType = this.checkTwoOperandExprTypes(sOperator, pLeftType, pRightType);
                    if (((pExprType) === null)) {
                        this._error(2207, {
                            operator: sOperator,
                            leftTypeName: pLeftType.getHash(),
                            rightTypeName: pRightType.getHash()
                        });
                    }
                } else {
                    pExprType = pRightType;
                }
                pExprType = this.checkTwoOperandExprTypes("=", pLeftType, pExprType);
                if (((pExprType) === null)) {
                    this._error(2208, {
                        leftTypeName: pLeftType.getHash(),
                        rightTypeName: pRightType.getHash()
                    });
                }
                (pExpr._sOperatorName = (sOperator));
                pExpr.setType(pExprType);
                pExpr.push(pLeftExpr, true);
                pExpr.push(pRightExpr, true);
                if (!pExpr.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pExpr._pLastError)).code, ((((pExpr._pLastError)).info) === null) ? {} : ((pExpr._pLastError)).info));
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeIdExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var sName = pNode.value;
                var pVariable = (Effect.getSystemVariable((sName)) || (this)._pEffectScope.getVariable((sName)));
                if (((pVariable) === null)) {
                    this._error(2205, {
                        varName: sName
                    });
                    return null;
                }
                if (pVariable.getType()._isUnverifiable() && !((this)._isAnalyzeInPass)) {
                    this._error(2276);
                    return null;
                }
                if (!((((this)._pCurrentFunction)) === null)) {
                    if (!pVariable._isForPixel()) {
                        ((this)._pCurrentFunction)._setForPixel(false);
                    }
                    if (!pVariable._isForVertex()) {
                        ((this)._pCurrentFunction)._setForVertex(false);
                    }
                }
                var pVarId = new fx.IdExprInstruction();
                pVarId.push(pVariable.getNameId(), false);
                if (!pVarId.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pVarId._pLastError)).code, ((((pVarId._pLastError)).info) === null) ? {} : ((pVarId._pLastError)).info));
                }
                ;
                return pVarId;
            };
            Effect.prototype.analyzeSimpleExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pInstruction = null;
                var sName = pNode.name;
                var sValue = pNode.value;
                switch(sName) {
                    case "T_UINT":
                        pInstruction = new fx.IntInstruction();
                        pInstruction.setValue((sValue) * 1);
                        break;
                    case "T_FLOAT":
                        pInstruction = new fx.FloatInstruction();
                        pInstruction.setValue((sValue) * 1.0);
                        break;
                    case "T_STRING":
                        pInstruction = new fx.StringInstruction();
                        pInstruction.setValue(sValue);
                        break;
                    case "T_KW_TRUE":
                        pInstruction = new fx.BoolInstruction();
                        pInstruction.setValue(true);
                        break;
                    case "T_KW_FALSE":
                        pInstruction = new fx.BoolInstruction();
                        pInstruction.setValue(false);
                        break;
                }
                return pInstruction;
            };
            Effect.prototype.analyzeMemExpr = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pMemExpr = new fx.MemExprInstruction();
                var pPostfixExpr = this.analyzeExpr(pChildren[0]);
                var pPostfixExprType = pPostfixExpr.getType();
                if (!pPostfixExprType.isFromVariableDecl()) {
                    this._error(2253);
                    return null;
                }
                var pBuffer = pPostfixExprType.getVideoBuffer();
                if (((pBuffer) === null)) {
                    this._error(2254);
                }
                if (!pPostfixExprType.isStrictPointer() && !((((this)._pCurrentFunction)) === null)) {
                    ((this)._pCurrentFunction)._setForPixel(false);
                    ((this)._pCurrentFunction)._notCanUsedAsFunction();
                    pPostfixExprType._setPointerToStrict();
                }
                pMemExpr.setBuffer(pBuffer);
                return pMemExpr;
            };
            Effect.prototype.analyzeConstTypeDim = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                if (pChildren.length > 1) {
                    this._error(2213);
                    return null;
                }
                var pType;
                pType = (this.analyzeType(pChildren[0]));
                if (!pType.isBase()) {
                    this._error(2214, {
                        typeName: pType.toString()
                    });
                }
                if (!pType.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error((pType.getLastError()).code, (((pType.getLastError()).info) === null) ? {} : (pType.getLastError()).info));
                }
                ;
                return pType;
            };
            Effect.prototype.analyzeVarStructDecl = function (pNode, pInstruction) {
                if (typeof pInstruction === "undefined") { pInstruction = null; }
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pUsageType = null;
                var pVariable = null;
                var i = 0;
                pUsageType = this.analyzeUsageStructDecl(pChildren[pChildren.length - 1]);
                for(i = pChildren.length - 2; i >= 1; i--) {
                    if (pChildren[i].name === "Variable") {
                        pVariable = this.analyzeVariable(pChildren[i], pUsageType);
                        if (!((pInstruction) === null)) {
                            pInstruction.push(pVariable, true);
                        }
                    }
                }
            };
            Effect.prototype.analyzeUsageStructDecl = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var i = 0;
                var pType = new fx.VariableTypeInstruction();
                for(i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "StructDecl") {
                        var pMainType = this.analyzeStructDecl(pChildren[i]);
                        pType.pushType(pMainType);
                        var pTypeDecl = new fx.TypeDeclInstruction();
                        pTypeDecl.push(pMainType, true);
                        this.addTypeDecl(pTypeDecl);
                    } else if (pChildren[i].name === "Usage") {
                        var sUsage = this.analyzeUsage(pChildren[i]);
                        pType.addUsage(sUsage);
                    }
                }
                if (!pType.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error((pType.getLastError()).code, (((pType.getLastError()).info) === null) ? {} : (pType.getLastError()).info));
                }
                ;
                return pType;
            };
            Effect.prototype.analyzeTypeDecl = function (pNode, pParentInstruction) {
                if (typeof pParentInstruction === "undefined") { pParentInstruction = null; }
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pTypeDeclInstruction = new fx.TypeDeclInstruction();
                if (pChildren.length === 2) {
                    var pStructInstruction = this.analyzeStructDecl(pChildren[1]);
                    pTypeDeclInstruction.push(pStructInstruction, true);
                } else {
                    this._error(2203);
                }
                if (!pTypeDeclInstruction.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error((pTypeDeclInstruction.getLastError()).code, (((pTypeDeclInstruction.getLastError()).info) === null) ? {} : (pTypeDeclInstruction.getLastError()).info));
                }
                ;
                this.addTypeDecl(pTypeDeclInstruction);
                pNode.isAnalyzed = true;
                if (!((pParentInstruction) === null)) {
                    pParentInstruction.push(pTypeDeclInstruction, true);
                }
                return pTypeDeclInstruction;
            };
            Effect.prototype.analyzeStructDecl = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pStruct = new fx.ComplexTypeInstruction();
                var pFieldCollector = new fx.InstructionCollector();
                var sName = pChildren[pChildren.length - 2].value;
                /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/pStruct.setName(sName);
                ((this)._pEffectScope.newScope((/*checked (origin: fx)>>*/akra.fx.EScopeType.k_Struct)));
                var i = 0;
                for(i = pChildren.length - 4; i >= 1; i--) {
                    if (pChildren[i].name === "VariableDecl") {
                        this.analyzeVariableDecl(pChildren[i], pFieldCollector);
                    }
                }
                ((this)._pEffectScope.endScope());
                pStruct.addFields(pFieldCollector, true);
                if (!pStruct.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pStruct._pLastError)).code, ((((pStruct._pLastError)).info) === null) ? {} : ((pStruct._pLastError)).info));
                }
                ;
                return pStruct;
            };
            Effect.prototype.analyzeStruct = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pStruct = new fx.ComplexTypeInstruction();
                var pFieldCollector = new fx.InstructionCollector();
                ((this)._pEffectScope.newScope((/*checked (origin: fx)>>*/akra.fx.EScopeType.k_Struct)));
                var i = 0;
                for(i = pChildren.length - 4; i >= 1; i--) {
                    if (pChildren[i].name === "VariableDecl") {
                        this.analyzeVariableDecl(pChildren[i], pFieldCollector);
                    }
                }
                ((this)._pEffectScope.endScope());
                pStruct.addFields(pFieldCollector, true);
                if (!pStruct.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pStruct._pLastError)).code, ((((pStruct._pLastError)).info) === null) ? {} : ((pStruct._pLastError)).info));
                }
                ;
                return pStruct;
            };
            Effect.prototype.analyzeFunctionDeclOnlyDefinition = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pFunction = null;
                var pFunctionDef = null;
                var pStmtBlock = null;
                var pAnnotation = null;
                var sLastNodeValue = pChildren[0].value;
                var bNeedAddFunction = false;
                pFunctionDef = this.analyzeFunctionDef(pChildren[pChildren.length - 1]);
                pFunction = this.findFunctionByDef(pFunctionDef);
                if (!((pFunction) !== undefined)) {
                    this._error(2246, {
                        funcName: (((pFunction._pFunctionDefenition)._pFunctionName)).toString()
                    });
                    return null;
                }
                if (!((pFunction) === null) && (!((pFunction._pImplementation) === null) || !((pFunction._pParseNode) === null))) {
                    this._error(2227, {
                        funcName: (((pFunction._pFunctionDefenition)._pFunctionName)).toString()
                    });
                    return null;
                }
                if (((pFunction) === null)) {
                    pFunction = new fx.FunctionDeclInstruction();
                    bNeedAddFunction = true;
                } else {
                    if (!(((pFunction._pFunctionDefenition)._pReturnType)).isEqual((pFunctionDef._pReturnType))) {
                        this._error(2247, {
                            funcName: (((pFunction._pFunctionDefenition)._pFunctionName)).toString()
                        });
                        return null;
                    }
                    bNeedAddFunction = false;
                }
                pFunction.setFunctionDef(pFunctionDef);
                ((this)._pEffectScope.resumeScope());
                if (pChildren.length === 3) {
                    pAnnotation = this.analyzeAnnotation(pChildren[1]);
                    pFunction.setAnnotation(pAnnotation);
                }
                if (sLastNodeValue !== ";") {
                    (pFunction._pParseNode = (pNode));
                    (pFunction._iImplementationScope = (((this)._pEffectScope.getScope())));
                    this._pFunctionWithImplementationList.push(pFunction);
                }
                ((this)._pEffectScope.endScope());
                if (bNeedAddFunction) {
                    this.addFunctionDecl(pFunction);
                }
            };
            Effect.prototype.resumeFunctionAnalysis = function (pAnalzedFunction) {
                var pFunction = pAnalzedFunction;
                var pNode = (pFunction._pParseNode);
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                ((this)._pEffectScope.setScope(((pFunction._iImplementationScope))));
                var pChildren = pNode.children;
                var pStmtBlock = null;
                ((this)._pCurrentFunction = (pFunction));
                // LOG("-----Analyze function '" + pFunction.getName() + "'------");
                pStmtBlock = this.analyzeStmtBlock(pChildren[0]);
                pFunction.setImplementation(pStmtBlock);
                ((this)._pCurrentFunction = (null));
                ((this)._pEffectScope.endScope());
                if (!pFunction.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pFunction._pLastError)).code, ((((pFunction._pLastError)).info) === null) ? {} : ((pFunction._pLastError)).info));
                }
                ;
            };
            Effect.prototype.analyzeFunctionDef = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pFunctionDef = new fx.FunctionDefInstruction();
                var pReturnType = null;
                var pFuncName = null;
                var pArguments = null;
                var sFuncName = pChildren[pChildren.length - 2].value;
                pReturnType = this.analyzeUsageType(pChildren[pChildren.length - 1]);
                if (pReturnType.isPointer() || pReturnType._containSampler() || pReturnType._containPointer()) {
                    this._error(2264, {
                        funcName: sFuncName
                    });
                    return null;
                }
                pFuncName = new fx.IdInstruction();
                pFuncName.setName(sFuncName);
                /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/pFunctionDef.setReturnType(pReturnType);
                /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/pFunctionDef.setFunctionName(pFuncName);
                if (pChildren.length === 4) {
                    var sSemantic = this.analyzeSemantic(pChildren[0]);
                    pFunctionDef.setSemantic(sSemantic);
                }
                ((this)._pEffectScope.newScope((/*checked (origin: fx)>>*/akra.fx.EScopeType.k_Default)));
                this.analyzeParamList(pChildren[pChildren.length - 3], pFunctionDef);
                ((this)._pEffectScope.endScope());
                if (!pFunctionDef.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pFunctionDef._pLastError)).code, ((((pFunctionDef._pLastError)).info) === null) ? {} : ((pFunctionDef._pLastError)).info));
                }
                ;
                return pFunctionDef;
            };
            Effect.prototype.analyzeParamList = function (pNode, pFunctionDef) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pParameter;
                var i = 0;
                for(i = pChildren.length - 2; i >= 1; i--) {
                    if (pChildren[i].name === "ParameterDecl") {
                        pParameter = this.analyzeParameterDecl(pChildren[i]);
                        pParameter._setScope(((this)._pEffectScope.getScope()));
                        pFunctionDef.addParameter(pParameter, ((this)._pEffectScope.isStrictMode()));
                    }
                }
            };
            Effect.prototype.analyzeParameterDecl = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pType = null;
                var pParameter = null;
                pType = this.analyzeParamUsageType(pChildren[1]);
                pParameter = this.analyzeVariable(pChildren[0], pType);
                return pParameter;
            };
            Effect.prototype.analyzeParamUsageType = function (pNode) {
                var pChildren = pNode.children;
                var i = 0;
                var pType = new fx.VariableTypeInstruction();
                for(i = pChildren.length - 1; i >= 0; i--) {
                    if (pChildren[i].name === "Type") {
                        var pMainType = this.analyzeType(pChildren[i]);
                        pType.pushType(pMainType);
                    } else if (pChildren[i].name === "ParamUsage") {
                        var sUsage = this.analyzeUsage(pChildren[i]);
                        pType.addUsage(sUsage);
                    }
                }
                if (!pType.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error((pType.getLastError()).code, (((pType.getLastError()).info) === null) ? {} : (pType.getLastError()).info));
                }
                ;
                return pType;
            };
            Effect.prototype.analyzeStmtBlock = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pStmtBlock = new fx.StmtBlockInstruction();
                var pStmt;
                var i = 0;
                (pStmtBlock._iScope = (((this)._pEffectScope.getScope())));
                ((this)._pEffectScope.newScope((/*checked (origin: fx)>>*/akra.fx.EScopeType.k_Default)));
                for(i = pChildren.length - 2; i > 0; i--) {
                    pStmt = this.analyzeStmt(pChildren[i]);
                    if (!((pStmt) === null)) {
                        pStmtBlock.push(pStmt);
                    }
                    this.addExtactionStmts(pStmtBlock);
                }
                ((this)._pEffectScope.endScope());
                if (!pStmtBlock.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pStmtBlock._pLastError)).code, ((((pStmtBlock._pLastError)).info) === null) ? {} : ((pStmtBlock._pLastError)).info));
                }
                ;
                return pStmtBlock;
            };
            Effect.prototype.analyzeStmt = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var sFirstNodeName = pChildren[pChildren.length - 1].name;
                switch(sFirstNodeName) {
                    case "SimpleStmt":
                        return this.analyzeSimpleStmt(pChildren[0]);
                    case "UseDecl":
                        this.analyzeUseDecl(pChildren[0]);
                        return null;
                    case "T_KW_WHILE":
                        return this.analyzeWhileStmt(pNode);
                    case "T_KW_FOR":
                        return this.analyzeForStmt(pNode);
                    case "T_KW_IF":
                        return this.analyzeIfStmt(pNode);
                }
            };
            Effect.prototype.analyzeSimpleStmt = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var sFirstNodeName = pChildren[pChildren.length - 1].name;
                switch(sFirstNodeName) {
                    case "T_KW_RETURN":
                        return this.analyzeReturnStmt(pNode);
                    case "T_KW_DO":
                        return this.analyzeWhileStmt(pNode);
                    case "StmtBlock":
                        return this.analyzeStmtBlock(pChildren[0]);
                    case "T_KW_DISCARD":
                    case "T_KW_BREAK":
                    case "T_KW_CONTINUE":
                        return this.analyzeBreakStmt(pNode);
                    case "TypeDecl":
                    case "VariableDecl":
                    case "VarStructDecl":
                        return this.analyzeDeclStmt(pChildren[0]);
                    default:
                        if (pChildren.length === 2) {
                            return this.analyzeExprStmt(pNode);
                        } else {
                            return (new fx.SemicolonStmtInstruction());
                        }
                }
            };
            Effect.prototype.analyzeReturnStmt = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pReturnStmtInstruction = new fx.ReturnStmtInstruction();
                var pFunctionReturnType = ((this)._pCurrentFunction).getReturnType();
                if (pFunctionReturnType.isEqual(Effect.getSystemType("void")) && pChildren.length === 3) {
                    this._error(2261);
                    return null;
                } else if (!pFunctionReturnType.isEqual(Effect.getSystemType("void")) && pChildren.length === 2) {
                    this._error(2262);
                    return null;
                }
                if (pChildren.length === 3) {
                    var pExprInstruction = this.analyzeExpr(pChildren[1]);
                    var pOutVar = ((this)._pCurrentFunction)._getOutVariable();
                    if (!((pOutVar) === null) && pOutVar.getType() !== pExprInstruction.getType()) {
                        this._error(2263);
                        return null;
                    }
                    if (!pFunctionReturnType.isEqual(pExprInstruction.getType())) {
                        this._error(2263);
                        return null;
                    }
                    pReturnStmtInstruction.push(pExprInstruction, true);
                }
                if (!pReturnStmtInstruction.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pReturnStmtInstruction._pLastError)).code, ((((pReturnStmtInstruction._pLastError)).info) === null) ? {} : ((pReturnStmtInstruction._pLastError)).info));
                }
                ;
                return pReturnStmtInstruction;
            };
            Effect.prototype.analyzeBreakStmt = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pBreakStmtInstruction = new fx.BreakStmtInstruction();
                var sOperatorName = pChildren[1].value;
                (pBreakStmtInstruction._sOperatorName = (sOperatorName));
                if (sOperatorName === "discard" && !((((this)._pCurrentFunction)) === null)) {
                    ((this)._pCurrentFunction)._setForVertex(false);
                }
                if (!pBreakStmtInstruction.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pBreakStmtInstruction._pLastError)).code, ((((pBreakStmtInstruction._pLastError)).info) === null) ? {} : ((pBreakStmtInstruction._pLastError)).info));
                }
                ;
                return pBreakStmtInstruction;
            };
            Effect.prototype.analyzeDeclStmt = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var sNodeName = pNode.name;
                var pDeclStmtInstruction = new fx.DeclStmtInstruction();
                switch(sNodeName) {
                    case "TypeDecl":
                        this.analyzeTypeDecl(pNode, pDeclStmtInstruction);
                        break;
                    case "VariableDecl":
                        this.analyzeVariableDecl(pNode, pDeclStmtInstruction);
                        break;
                    case "VarStructDecl":
                        this.analyzeVarStructDecl(pNode, pDeclStmtInstruction);
                        break;
                }
                if (!pDeclStmtInstruction.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pDeclStmtInstruction._pLastError)).code, ((((pDeclStmtInstruction._pLastError)).info) === null) ? {} : ((pDeclStmtInstruction._pLastError)).info));
                }
                ;
                return pDeclStmtInstruction;
            };
            Effect.prototype.analyzeExprStmt = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pExprStmtInstruction = new fx.ExprStmtInstruction();
                var pExprInstruction = this.analyzeExpr(pChildren[1]);
                pExprStmtInstruction.push(pExprInstruction, true);
                if (!pExprStmtInstruction.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pExprStmtInstruction._pLastError)).code, ((((pExprStmtInstruction._pLastError)).info) === null) ? {} : ((pExprStmtInstruction._pLastError)).info));
                }
                ;
                return pExprStmtInstruction;
            };
            Effect.prototype.analyzeWhileStmt = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var isDoWhile = (pChildren[pChildren.length - 1].value === "do");
                var isNonIfStmt = (pNode.name === "NonIfStmt") ? true : false;
                var pWhileStmt = new fx.WhileStmtInstruction();
                var pCondition = null;
                var pConditionType = null;
                var pBoolType = Effect.getSystemType("bool");
                var pStmt = null;
                if (isDoWhile) {
                    (pWhileStmt._sOperatorName = ("do_while"));
                    pCondition = this.analyzeExpr(pChildren[2]);
                    pConditionType = pCondition.getType();
                    if (!pConditionType.isEqual(pBoolType)) {
                        this._error(2229, {
                            typeName: pConditionType.toString()
                        });
                        return null;
                    }
                    pStmt = this.analyzeStmt(pChildren[0]);
                } else {
                    (pWhileStmt._sOperatorName = ("while"));
                    pCondition = this.analyzeExpr(pChildren[2]);
                    pConditionType = pCondition.getType();
                    if (!pConditionType.isEqual(pBoolType)) {
                        this._error(2228, {
                            typeName: pConditionType.toString()
                        });
                        return null;
                    }
                    if (isNonIfStmt) {
                        pStmt = this.analyzeNonIfStmt(pChildren[0]);
                    } else {
                        pStmt = this.analyzeStmt(pChildren[0]);
                    }
                    pWhileStmt.push(pCondition, true);
                    pWhileStmt.push(pStmt, true);
                }
                if (!pWhileStmt.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pWhileStmt._pLastError)).code, ((((pWhileStmt._pLastError)).info) === null) ? {} : ((pWhileStmt._pLastError)).info));
                }
                ;
                return pWhileStmt;
            };
            Effect.prototype.analyzeIfStmt = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var isIfElse = (pChildren.length === 7);
                var pIfStmtInstruction = new fx.IfStmtInstruction();
                var pCondition = this.analyzeExpr(pChildren[pChildren.length - 3]);
                var pConditionType = pCondition.getType();
                var pBoolType = Effect.getSystemType("bool");
                var pIfStmt = null;
                var pElseStmt = null;
                if (!pConditionType.isEqual(pBoolType)) {
                    this._error(2230, {
                        typeName: pConditionType.toString()
                    });
                    return null;
                }
                pIfStmtInstruction.push(pCondition, true);
                if (isIfElse) {
                    (pIfStmtInstruction._sOperatorName = ("if_else"));
                    pIfStmt = this.analyzeNonIfStmt(pChildren[2]);
                    pElseStmt = this.analyzeStmt(pChildren[0]);
                    pIfStmtInstruction.push(pIfStmt, true);
                    pIfStmtInstruction.push(pElseStmt, true);
                } else {
                    (pIfStmtInstruction._sOperatorName = ("if"));
                    pIfStmt = this.analyzeNonIfStmt(pChildren[0]);
                    pIfStmtInstruction.push(pIfStmt, true);
                }
                if (!pIfStmtInstruction.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pIfStmtInstruction._pLastError)).code, ((((pIfStmtInstruction._pLastError)).info) === null) ? {} : ((pIfStmtInstruction._pLastError)).info));
                }
                ;
                return pIfStmtInstruction;
            };
            Effect.prototype.analyzeNonIfStmt = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var sFirstNodeName = pChildren[pChildren.length - 1].name;
                switch(sFirstNodeName) {
                    case "SimpleStmt":
                        return this.analyzeSimpleStmt(pChildren[0]);
                    case "T_KW_WHILE":
                        return this.analyzeWhileStmt(pNode);
                    case "T_KW_FOR":
                        return this.analyzeForStmt(pNode);
                }
            };
            Effect.prototype.analyzeForStmt = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var isNonIfStmt = (pNode.name === "NonIfStmt");
                var pForStmtInstruction = new fx.ForStmtInstruction();
                var pStmt = null;
                ((this)._pEffectScope.newScope((/*checked (origin: fx)>>*/akra.fx.EScopeType.k_Default)));
                this.analyzeForInit(pChildren[pChildren.length - 3], pForStmtInstruction);
                this.analyzeForCond(pChildren[pChildren.length - 4], pForStmtInstruction);
                if (pChildren.length === 7) {
                    this.analyzeForStep(pChildren[2], pForStmtInstruction);
                } else {
                    pForStmtInstruction.push(null);
                }
                if (isNonIfStmt) {
                    pStmt = this.analyzeNonIfStmt(pChildren[0]);
                } else {
                    pStmt = this.analyzeStmt(pChildren[0]);
                }
                pForStmtInstruction.push(pStmt, true);
                ((this)._pEffectScope.endScope());
                if (!pForStmtInstruction.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                    ((this)._error(((pForStmtInstruction._pLastError)).code, ((((pForStmtInstruction._pLastError)).info) === null) ? {} : ((pForStmtInstruction._pLastError)).info));
                }
                ;
                return pForStmtInstruction;
            };
            Effect.prototype.analyzeForInit = function (pNode, pForStmtInstruction) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var sFirstNodeName = pChildren[pChildren.length - 1].name;
                switch(sFirstNodeName) {
                    case "VariableDecl":
                        this.analyzeVariableDecl(pChildren[0], pForStmtInstruction);
                        break;
                    case "Expr":
                        var pExpr = this.analyzeExpr(pChildren[0]);
                        pForStmtInstruction.push(pExpr, true);
                        break;
                    default:
                        // ForInit : ';'
                        pForStmtInstruction.push(null);
                        break;
                }
                return;
            };
            Effect.prototype.analyzeForCond = function (pNode, pForStmtInstruction) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                if (pChildren.length === 1) {
                    pForStmtInstruction.push(null);
                    return;
                }
                var pConditionExpr = this.analyzeExpr(pChildren[1]);
                pForStmtInstruction.push(pConditionExpr, true);
                return;
            };
            Effect.prototype.analyzeForStep = function (pNode, pForStmtInstruction) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pStepExpr = this.analyzeExpr(pChildren[0]);
                pForStmtInstruction.push(pStepExpr, true);
                return;
            };
            Effect.prototype.analyzeUseDecl = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                ((this)._pEffectScope.setStrictModeOn());
            };
            Effect.prototype.analyzeTechniqueForImport = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pTechnique = new fx.TechniqueInstruction();
                var sTechniqueName = this.analyzeComplexName(pChildren[pChildren.length - 2]);
                var isComplexName = pChildren[pChildren.length - 2].children.length !== 1;
                pTechnique.setName(sTechniqueName, isComplexName);
                for(var i = pChildren.length - 3; i >= 0; i--) {
                    if (pChildren[i].name === "Annotation") {
                        var pAnnotation = this.analyzeAnnotation(pChildren[i]);
                        pTechnique.setAnnotation(pAnnotation);
                    } else if (pChildren[i].name === "Semantic") {
                        var sSemantic = this.analyzeSemantic(pChildren[i]);
                        pTechnique.setSemantic(sSemantic);
                    } else {
                        this.analyzeTechniqueBodyForImports(pChildren[i], pTechnique);
                    }
                }
                this.addTechnique(pTechnique);
            };
            Effect.prototype.analyzeComplexName = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var sName = "";
                for(var i = pChildren.length - 1; i >= 0; i--) {
                    sName += pChildren[i].value;
                }
                return sName;
            };
            Effect.prototype.analyzeTechniqueBodyForImports = function (pNode, pTechnique) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                for(var i = pChildren.length - 2; i >= 1; i--) {
                    this.analyzePassDeclForImports(pChildren[i], pTechnique);
                }
            };
            Effect.prototype.analyzePassDeclForImports = function (pNode, pTechnique) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                if (pChildren[0].name === "ImportDecl") {
                    this.analyzeImportDecl(pChildren[0], pTechnique);
                } else if (pChildren.length > 1) {
                    var pPass = new fx.PassInstruction();
                    //TODO: add annotation and id
                    this.analyzePassStateBlockForShaders(pChildren[0], pPass);
                    pPass._setParseNode(pNode);
                    pTechnique.addPass(pPass);
                }
            };
            Effect.prototype.analyzePassStateBlockForShaders = function (pNode, pPass) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                for(var i = pChildren.length - 2; i >= 1; i--) {
                    this.analyzePassStateForShader(pChildren[i], pPass);
                }
            };
            Effect.prototype.analyzePassStateForShader = function (pNode, pPass) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                if (pChildren.length === 1) {
                    pPass._markAsComplex(true);
                    if (pChildren[0].name === "StateIf") {
                        this.analyzePassStateIfForShader(pChildren[0], pPass);
                    } else if (pChildren[0].name === "StateSwitch") {
                        this.analyzePassStateSwitchForShader(pChildren[0], pPass);
                    }
                    return;
                }
                var sType = pChildren[pChildren.length - 1].value.toUpperCase();
                var eShaderType = akra.EFunctionType.k_Vertex;
                if (sType === "VERTEXSHADER") {
                    eShaderType = akra.EFunctionType.k_Vertex;
                } else if (sType === "PIXELSHADER") {
                    eShaderType = akra.EFunctionType.k_Pixel;
                } else {
                    return;
                }
                pNode.isAnalyzed = true;
                var pStateExprNode = pChildren[pChildren.length - 3];
                var pExprNode = pStateExprNode.children[pStateExprNode.children.length - 1];
                var pCompileExpr = this.analyzeExpr(pExprNode);
                var pShaderFunc = (pCompileExpr._pInstructionList[0].getParent().getParent());
                if (eShaderType === akra.EFunctionType.k_Vertex) {
                    if (!pShaderFunc._checkDefenitionForVertexUsage()) {
                        this._error(2259, {
                            funcDef: pShaderFunc._getStringDef()
                        });
                    }
                } else {
                    if (!pShaderFunc._checkDefenitionForPixelUsage()) {
                        this._error(2260, {
                            funcDef: pShaderFunc._getStringDef()
                        });
                    }
                }
                pShaderFunc._markUsedAs(eShaderType);
                pPass._addFoundFunction(pNode, pShaderFunc, eShaderType);
            };
            Effect.prototype.analyzePassStateIfForShader = function (pNode, pPass) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                if (pChildren.length === 5) {
                    this.analyzePassStateBlockForShaders(pChildren[0], pPass);
                } else if (pChildren.length === 7 && pChildren[0].name === "PassStateBlock") {
                    this.analyzePassStateBlockForShaders(pChildren[2], pPass);
                    this.analyzePassStateBlockForShaders(pChildren[0], pPass);
                } else {
                    this.analyzePassStateBlockForShaders(pChildren[2], pPass);
                    this.analyzePassStateIfForShader(pChildren[0], pPass);
                }
            };
            Effect.prototype.analyzePassStateSwitchForShader = function (pNode, pPass) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                this.analyzePassCaseBlockForShader(pChildren[0], pPass);
            };
            Effect.prototype.analyzePassCaseBlockForShader = function (pNode, pPass) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                for(var i = pChildren.length - 2; i >= 1; i--) {
                    if (pChildren[i].name === "CaseState") {
                        this.analyzePassCaseStateForShader(pChildren[i], pPass);
                    } else if (pChildren[i].name === "DefaultState") {
                        this.analyzePassDefaultStateForShader(pChildren[i], pPass);
                    }
                }
            };
            Effect.prototype.analyzePassCaseStateForShader = function (pNode, pPass) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                for(var i = pChildren.length - 4; i >= 0; i--) {
                    if (pChildren[i].name === "PassState") {
                        this.analyzePassStateForShader(pChildren[i], pPass);
                    }
                }
            };
            Effect.prototype.analyzePassDefaultStateForShader = function (pNode, pPass) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                for(var i = pChildren.length - 3; i >= 0; i--) {
                    if (pChildren[i].name === "PassState") {
                        this.analyzePassStateForShader(pChildren[i], pPass);
                    }
                }
            };
            Effect.prototype.resumeTechniqueAnalysis = function (pTechnique) {
                var pPassList = pTechnique.getPassList();
                for(var i = 0; i < pPassList.length; i++) {
                    this.resumePassAnalysis(pPassList[i]);
                }
                if (!pTechnique.checkForCorrectImports()) {
                    this._error(2275, {
                        techniqueName: pTechnique.getName()
                    });
                    return;
                }
                pTechnique.finalizeTechnique(this._sProvideNameSpace, this._pGlobalComponentList, this._pGlobalComponetShiftList);
            };
            Effect.prototype.resumePassAnalysis = function (pPass) {
                var pNode = pPass._getParseNode();
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                ((this)._isAnalyzeInPass = (true));
                this.analyzePassStateBlock(pChildren[0], pPass);
                ((this)._isAnalyzeInPass = (false));
                pPass.finalizePass();
            };
            Effect.prototype.analyzePassStateBlock = function (pNode, pPass) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                pPass._addCodeFragment("{");
                for(var i = pChildren.length - 2; i >= 1; i--) {
                    this.analyzePassState(pChildren[i], pPass);
                }
                pPass._addCodeFragment("}");
            };
            Effect.prototype.analyzePassState = function (pNode, pPass) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                if (pChildren.length === 1) {
                    if (pChildren[0].name === "StateIf") {
                        this.analyzePassStateIf(pChildren[0], pPass);
                    } else if (pChildren[0].name === "StateSwitch") {
                        this.analyzePassStateSwitch(pChildren[0], pPass);
                    }
                    return;
                }
                if (pNode.isAnalyzed) {
                    var pFunc = pPass._getFoundedFunction(pNode);
                    var eShaderType = pPass._getFoundedFunctionType(pNode);
                    var pShader = null;
                    if (eShaderType === akra.EFunctionType.k_Vertex) {
                        pShader = pFunc._getVertexShader();
                    } else {
                        pShader = pFunc._getPixelShader();
                    }
                    pPass.addShader(pShader);
                } else {
                    var sType = pChildren[pChildren.length - 1].value.toUpperCase();
                    var pStateExprNode = pChildren[pChildren.length - 3];
                    var pExprNode = pStateExprNode.children[pStateExprNode.children.length - 1];
                    switch(sType) {
                        case "ZENABLE":
                        case "ZWRITEENABLE":
                        case "SRCBLEND":
                        case "DESTBLEND":
                        case "CULLMODE":
                        case "ZFUNC":
                        case "DITHERENABLE":
                        case "ALPHABLENDENABLE":
                        case "ALPHATESTENABLE":
                            break;
                        default:
 {
                                akra.logger.setSourceLocation("fx/Effect.ts", 3914);
                                akra.logger.warning("Unsupported render state type used: " + sType + ". WebGl...");
                            }
                            ;
                            return;
                    }
                    if (pExprNode.value === "{" || pExprNode.value === "<" || ((pExprNode.value) === null)) {
 {
                            akra.logger.setSourceLocation("fx/Effect.ts", 3920);
                            akra.logger.warning("So pass state are incorrect");
                        }
                        ;
                        return;
                    }
                    var sValue = pExprNode.value.toUpperCase();
                    switch(sType) {
                        case "ALPHABLENDENABLE":
                        case "ALPHATESTENABLE":
 {
                                akra.logger.setSourceLocation("fx/Effect.ts", 3928);
                                akra.logger.warning("ALPHABLENDENABLE/ALPHATESTENABLE not supported in WebGL.");
                            }
                            ;
                            return;
                        case "DITHERENABLE":
                        case "ZENABLE":
                        case "ZWRITEENABLE":
                            switch(sValue) {
                                case "TRUE":
                                case "FALSE":
                                    break;
                                default:
 {
                                        akra.logger.setSourceLocation("fx/Effect.ts", 3941);
                                        akra.logger.warning("Unsupported render state ALPHABLENDENABLE/ZENABLE/ZWRITEENABLE/DITHERENABLE value used: " + sValue + ".");
                                    }
                                    ;
                                    return;
                            }
                            break;
                        case "SRCBLEND":
                        case "DESTBLEND":
                            switch(sValue) {
                                case "ZERO":
                                case "ONE":
                                case "SRCCOLOR":
                                case "INVSRCCOLOR":
                                case "SRCALPHA":
                                case "INVSRCALPHA":
                                case "DESTALPHA":
                                case "INVDESTALPHA":
                                case "DESTCOLOR":
                                case "INVDESTCOLOR":
                                case "SRCALPHASAT":
                                    break;
                                default:
 {
                                        akra.logger.setSourceLocation("fx/Effect.ts", 3963);
                                        akra.logger.warning("Unsupported render state SRCBLEND/DESTBLEND value used: " + sValue + ".");
                                    }
                                    ;
                                    return;
                            }
                            break;
                        case "CULLMODE":
                            switch(sValue) {
                                case "NONE":
                                case "CW":
                                case "CCW":
                                case "FRONT_AND_BACK":
                                    break;
                                default:
 {
                                        akra.logger.setSourceLocation("fx/Effect.ts", 3976);
                                        akra.logger.warning("Unsupported render state SRCBLEND/DESTBLEND value used: " + sValue + ".");
                                    }
                                    ;
                                    return;
                            }
                            break;
                        case "ZFUNC":
                            switch(sValue) {
                                case "NEVER":
                                case "LESS":
                                case "EQUAL":
                                case "LESSEQUAL":
                                case "GREATER":
                                case "NOTEQUAL":
                                case "GREATEREQUAL":
                                case "ALWAYS":
                                    break;
                                default:
 {
                                        akra.logger.setSourceLocation("fx/Effect.ts", 3994);
                                        akra.logger.warning("Unsupported render state ZFUNC value used: " + sValue + ".");
                                    }
                                    ;
                                    return;
                            }
                            break;
                    }
                    pPass.setState(sType, sValue);
                }
            };
            Effect.prototype.analyzePassStateIf = function (pNode, pPass) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pIfExpr = this.analyzeExpr(pChildren[pChildren.length - 3]);
                pIfExpr.prepareFor(akra.EFunctionType.k_PassFunction);
                pPass._addCodeFragment("if(" + pIfExpr.toFinalCode() + ")");
                this.analyzePassStateBlock(pChildren[pChildren.length - 5], pPass);
                if (pChildren.length > 5) {
                    pPass._addCodeFragment("else");
                    if (pChildren[0].name === "PassStateBlock") {
                        this.analyzePassStateBlock(pChildren[0], pPass);
                    } else {
                        pPass._addCodeFragment(" ");
                        this.analyzePassStateIf(pChildren[0], pPass);
                    }
                }
            };
            Effect.prototype.analyzePassStateSwitch = function (pNode, pPass) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var sCodeFragment = "switch";
                var pSwitchExpr = this.analyzeExpr(pChildren[pChildren.length - 3]);
                pSwitchExpr.prepareFor(akra.EFunctionType.k_PassFunction);
                pPass._addCodeFragment("(" + pSwitchExpr.toFinalCode() + ")");
                this.analyzePassCaseBlock(pChildren[0], pPass);
            };
            Effect.prototype.analyzePassCaseBlock = function (pNode, pPass) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                pPass._addCodeFragment("{");
                for(var i = pChildren.length - 2; i >= 1; i--) {
                    if (pChildren[i].name === "CaseState") {
                        this.analyzePassCaseState(pChildren[i], pPass);
                    } else if (pChildren[i].name === "DefaultState") {
                        this.analyzePassDefault(pChildren[i], pPass);
                    }
                }
                pPass._addCodeFragment("}");
            };
            Effect.prototype.analyzePassCaseState = function (pNode, pPass) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var pCaseStateExpr = this.analyzeExpr(pChildren[pChildren.length - 2]);
                pCaseStateExpr.prepareFor(akra.EFunctionType.k_PassFunction);
                pPass._addCodeFragment("case " + pCaseStateExpr.toFinalCode() + ": ");
                for(var i = pChildren.length - 4; i >= 0; i--) {
                    if (pChildren[i].name === "PassState") {
                        this.analyzePassStateForShader(pChildren[i], pPass);
                    } else {
                        pPass._addCodeFragment(pChildren[i].value);
                    }
                }
            };
            Effect.prototype.analyzePassDefault = function (pNode, pPass) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                pPass._addCodeFragment("default: ");
                for(var i = pChildren.length - 3; i >= 0; i--) {
                    if (pChildren[i].name === "PassState") {
                        this.analyzePassStateForShader(pChildren[i], pPass);
                    } else {
                        pPass._addCodeFragment(pChildren[i].value);
                    }
                }
            };
            Effect.prototype.analyzeImportDecl = function (pNode, pTechnique) {
                if (typeof pTechnique === "undefined") { pTechnique = null; }
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var sComponentName = this.analyzeComplexName(pChildren[pChildren.length - 2]);
                var iShift = 0;
                if (pChildren[0].name === "ExtOpt") {
 {
                        akra.logger.setSourceLocation("fx/Effect.ts", 4108);
                        akra.logger.warning("We don`t suppor ext-commands for import");
                    }
                    ;
                }
                if (pChildren.length !== 2) {
                    iShift = this.analyzeShiftOpt(pChildren[0]);
                }
                var pComponent = this._pComposer.getComponentByName(sComponentName);
                if (!pComponent) {
                    this._error(2277, {
                        componentName: sComponentName
                    });
                    return;
                }
                this.addComponent(pComponent, iShift, pTechnique);
            };
            Effect.prototype.analyzeProvideDecl = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                if (pChildren.length === 2) {
                    this._sProvideNameSpace = this.analyzeComplexName(pChildren[0]);
                } else {
                    this._error(2303);
                    return;
                }
            };
            Effect.prototype.analyzeShiftOpt = function (pNode) {
                (// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode);
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
(this)._pAnalyzedNode = (pNode));
                var pChildren = pNode.children;
                var iShift = (pChildren[0].value);
                if (pChildren.length === 2) {
                    iShift *= 1;
                } else {
                    iShift *= -1;
                }
                return iShift;
            };
            Effect.prototype.addComponent = function (pComponent, iShift, pTechnique) {
                if (!((pTechnique) === null)) {
                    pTechnique.addComponent(pComponent, iShift);
                } else {
                    if (((this._pGlobalComponentList) === null)) {
                        this._pGlobalComponentList = [];
                        this._pGlobalComponetShiftList = [];
                    }
                    this._pGlobalComponentList.push(pComponent);
                    this._pGlobalComponetShiftList.push(iShift);
                }
                //TODO: add correct add of compnent, not global
                var pComponentTechnique = pComponent.getTechnique();
                if (this.isAddedTechnique(pComponentTechnique)) {
                    return;
                }
                var pSharedListV = pComponentTechnique.getSharedVariablesForVertex();
                var pSharedListP = pComponentTechnique.getSharedVariablesForPixel();
                for(var i = 0; i < pSharedListV.length; i++) {
                    this.addExternalSharedVariable(pSharedListV[i], akra.EFunctionType.k_Vertex);
                }
                for(var i = 0; i < pSharedListP.length; i++) {
                    this.addExternalSharedVariable(pSharedListP[i], akra.EFunctionType.k_Pixel);
                }
                if (((this._pAddedTechniqueList) === null)) {
                    this._pAddedTechniqueList = [];
                }
                this._pAddedTechniqueList.push(pTechnique);
            };
            Effect.prototype.isAddedTechnique = function (pTechnique) {
                if (((this._pAddedTechniqueList) === null)) {
                    return false;
                }
                for(var i = 0; i < this._pAddedTechniqueList.length; i++) {
                    if (this._pAddedTechniqueList[i] === pTechnique) {
                        return true;
                    }
                }
                return false;
            };
            Effect.prototype.checkTwoOperandExprTypes = /**
            * Проверят возможность использования оператора между двумя типами.
            * Возращает тип получаемый в результате приминения опрератора, или, если применить его невозможно - null.
            *
            * @sOperator {string} Один из операторов: + - * / % += -= *= /= %= = < > <= >= == != =
            * @pLeftType {IAFXVariableTypeInstruction} Тип левой части выражения
            * @pRightType {IAFXVariableTypeInstruction} Тип правой части выражения
            */
            function (sOperator, pLeftType, pRightType) {
                if (pLeftType._isUnverifiable()) {
                    return pLeftType;
                }
                if (pRightType._isUnverifiable()) {
                    return pRightType;
                }
                var isComplex = pLeftType.isComplex() || pRightType.isComplex();
                var isArray = pLeftType.isNotBaseArray() || pRightType.isNotBaseArray();
                var isSampler = Effect.isSamplerType(pLeftType) || Effect.isSamplerType(pRightType);
                var pBoolType = ((Effect.getSystemType("bool"))._pWrapVariableType);
                if (isArray || isSampler) {
                    return null;
                }
                if (sOperator === "%" || sOperator === "%=") {
                    return null;
                }
                if (this.isAssignmentOperator(sOperator)) {
                    if (!pLeftType.isWritable()) {
                        this._error(2267);
                        return null;
                    }
                    if (pLeftType.isStrongEqual(Effect.getSystemType("ptr"))) {
                        ((this)._pPointerForExtractionList.push((pLeftType._getParentVarDecl())));
                    }
                    if (!pRightType.isReadable()) {
                        this._error(2268);
                        return null;
                    }
                    if (sOperator !== "=" && !pLeftType.isReadable()) {
                        this._error(2268);
                    }
                } else {
                    if (!pLeftType.isReadable()) {
                        this._error(2268);
                        return null;
                    }
                    if (!pRightType.isReadable()) {
                        this._error(2268);
                        return null;
                    }
                }
                if (isComplex) {
                    if (sOperator === "=" && pLeftType.isEqual(pRightType)) {
                        return pLeftType;
                    } else if (this.isEqualOperator(sOperator) && !pLeftType._containArray() && !pLeftType._containSampler()) {
                        return pBoolType;
                    } else {
                        return null;
                    }
                }
                var pReturnType = null;
                var pLeftBaseType = (((pLeftType.getBaseType()))._pWrapVariableType);
                var pRightBaseType = (((pRightType.getBaseType()))._pWrapVariableType);
                if (pLeftType.isConst() && this.isAssignmentOperator(sOperator)) {
                    return null;
                }
                if (pLeftType.isEqual(pRightType)) {
                    if (this.isArithmeticalOperator(sOperator)) {
                        if (!Effect.isMatrixType(pLeftType) || (sOperator !== "/" && sOperator !== "/=")) {
                            return pLeftBaseType;
                        } else {
                            return null;
                        }
                    } else if (this.isRelationalOperator(sOperator)) {
                        if (Effect.isScalarType(pLeftType)) {
                            return pBoolType;
                        } else {
                            return null;
                        }
                    } else if (this.isEqualOperator(sOperator)) {
                        return pBoolType;
                    } else if (sOperator === "=") {
                        return pLeftBaseType;
                    } else {
                        return null;
                    }
                }
                if (this.isArithmeticalOperator(sOperator)) {
                    if (Effect.isBoolBasedType(pLeftType) || Effect.isBoolBasedType(pRightType) || Effect.isFloatBasedType(pLeftType) !== Effect.isFloatBasedType(pRightType) || Effect.isIntBasedType(pLeftType) !== Effect.isIntBasedType(pRightType)) {
                        return null;
                    }
                    if (Effect.isScalarType(pLeftType)) {
                        return pRightBaseType;
                    }
                    if (Effect.isScalarType(pRightType)) {
                        return pLeftBaseType;
                    }
                    if (sOperator === "*" || sOperator === "*=") {
                        if (Effect.isMatrixType(pLeftType) && Effect.isVectorType(pRightType) && pLeftType.getLength() === pRightType.getLength()) {
                            return pRightBaseType;
                        } else if (Effect.isMatrixType(pRightType) && Effect.isVectorType(pLeftType) && pLeftType.getLength() === pRightType.getLength()) {
                            return pLeftBaseType;
                        } else {
                            return null;
                        }
                    }
                }
                return null;
            };
            Effect.prototype.checkOneOperandExprType = /**
            * Проверят возможность использования оператора к типу данных.
            * Возращает тип получаемый в результате приминения опрератора, или, если применить его невозможно - null.
            *
            * @sOperator {string} Один из операторов: + - ! ++ --
            * @pLeftType {IAFXVariableTypeInstruction} Тип операнда
            */
            function (sOperator, pType) {
                if (pType._isUnverifiable === undefined) {
 {
                        akra.logger.setSourceLocation("fx/Effect.ts", 4366);
                        akra.logger.log(pType);
                    }
                    ;
                }
                if (pType._isUnverifiable()) {
                    return pType;
                }
                var isComplex = pType.isComplex();
                var isArray = pType.isNotBaseArray();
                var isSampler = Effect.isSamplerType(pType);
                if (isComplex || isArray || isSampler) {
                    return null;
                }
                if (!pType.isReadable()) {
                    this._error(2268);
                    return null;
                }
                if (sOperator === "++" || sOperator === "--") {
                    if (!pType.isWritable()) {
                        this._error(2267);
                        return null;
                    }
                    if (pType.isStrongEqual(Effect.getSystemType("ptr"))) {
                        ((this)._pPointerForExtractionList.push((pType._getParentVarDecl())));
                    }
                    return pType;
                }
                if (sOperator === "!") {
                    var pBoolType = ((Effect.getSystemType("bool"))._pWrapVariableType);
                    if (pType.isEqual(pBoolType)) {
                        return pBoolType;
                    } else {
                        return null;
                    }
                } else {
                    if (Effect.isBoolBasedType(pType)) {
                        return null;
                    } else {
                        return (((pType.getBaseType()))._pWrapVariableType);
                    }
                }
                //return null;
                            };
            Effect.prototype.isAssignmentOperator = function (sOperator) {
                return sOperator === "+=" || sOperator === "-=" || sOperator === "*=" || sOperator === "/=" || sOperator === "%=" || sOperator === "=";
            };
            Effect.prototype.isArithmeticalOperator = function (sOperator) {
                return sOperator === "+" || sOperator === "+=" || sOperator === "-" || sOperator === "-=" || sOperator === "*" || sOperator === "*=" || sOperator === "/" || sOperator === "/=";
            };
            Effect.prototype.isRelationalOperator = function (sOperator) {
                return sOperator === ">" || sOperator === ">=" || sOperator === "<" || sOperator === "<=";
            };
            Effect.prototype.isEqualOperator = function (sOperator) {
                return sOperator === "==" || sOperator === "!=";
            };
            Effect.prototype.addExtactionStmts = function (pStmt) {
                var pPointerList = ((this)._pPointerForExtractionList);
                for(var i = 0; i < pPointerList.length; i++) {
                    this.generateExtractStmtFromPointer(pPointerList[i], pStmt);
                }
                ((this)._pPointerForExtractionList.length = 0);
            };
            Effect.prototype.generateExtractStmtFromPointer = function (pPointer, pParentStmt) {
                var pPointerType = pPointer.getType();
                var pWhatExtracted = pPointerType._getDownPointer();
                var pWhatExtractedType = null;
                var pFunction = ((this)._pCurrentFunction);
                while(!((pWhatExtracted) === null)) {
                    pWhatExtractedType = pWhatExtracted.getType();
                    if (!pWhatExtractedType.isComplex()) {
                        var pSingleExtract = new fx.ExtractStmtInstruction();
                        pSingleExtract.generateStmtForBaseType(pWhatExtracted, pWhatExtractedType.getPointer(), pWhatExtractedType.getVideoBuffer(), 0, null);
                        if (!pSingleExtract.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                            ((this)._error(((pSingleExtract._pLastError)).code, ((((pSingleExtract._pLastError)).info) === null) ? {} : ((pSingleExtract._pLastError)).info));
                        }
                        ;
                        pParentStmt.push(pSingleExtract, true);
                        if (!((pFunction) === null)) {
                            pFunction._addUsedFunction(pSingleExtract.getExtractFunction());
                        }
                    } else {
                        this.generateExtractStmtForComplexVar(pWhatExtracted, pParentStmt, pWhatExtractedType.getPointer(), pWhatExtractedType.getVideoBuffer(), 0);
                    }
                    pWhatExtracted = pWhatExtractedType._getDownPointer();
                }
                return pParentStmt;
            };
            Effect.prototype.generateExtractStmtForComplexVar = function (pVarDecl, pParentStmt, pPointer, pBuffer, iPadding) {
                var pVarType = pVarDecl.getType();
                var pFieldNameList = pVarType.getFieldNameList();
                var pField = null;
                var pFieldType = null;
                var pSingleExtract = null;
                var pFunction = ((this)._pCurrentFunction);
                for(var i = 0; i < pFieldNameList.length; i++) {
                    pField = pVarType.getField(pFieldNameList[i]);
                    if (((pField) === null)) {
                        continue;
                    }
                    pFieldType = pField.getType();
                    if (pFieldType.isPointer()) {
                        var pFieldPointer = pFieldType._getMainPointer();
                        pSingleExtract = new fx.ExtractStmtInstruction();
                        pSingleExtract.generateStmtForBaseType(pFieldPointer, pPointer, pFieldType.getVideoBuffer(), iPadding + pFieldType.getPadding(), null);
                        if (!pSingleExtract.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                            ((this)._error(((pSingleExtract._pLastError)).code, ((((pSingleExtract._pLastError)).info) === null) ? {} : ((pSingleExtract._pLastError)).info));
                        }
                        ;
                        pParentStmt.push(pSingleExtract, true);
                        this.generateExtractStmtFromPointer(pFieldPointer, pParentStmt);
                        if (!((pFunction) === null)) {
                            pFunction._addUsedFunction(pSingleExtract.getExtractFunction());
                        }
                    } else if (pFieldType.isComplex()) {
                        this.generateExtractStmtForComplexVar(pField, pParentStmt, pPointer, pBuffer, iPadding + pFieldType.getPadding());
                    } else {
                        pSingleExtract = new fx.ExtractStmtInstruction();
                        pSingleExtract.generateStmtForBaseType(pField, pPointer, pBuffer, iPadding + pFieldType.getPadding(), null);
                        if (!pSingleExtract.check(akra.ECheckStage.CODE_TARGET_SUPPORT)) {
                            ((this)._error(((pSingleExtract._pLastError)).code, ((((pSingleExtract._pLastError)).info) === null) ? {} : ((pSingleExtract._pLastError)).info));
                        }
                        ;
                        pParentStmt.push(pSingleExtract, true);
                        if (!((pFunction) === null)) {
                            pFunction._addUsedFunction(pSingleExtract.getExtractFunction());
                        }
                    }
                }
            };
            Effect.prototype.getNodeSourceLocation = function (pNode) {
                if (((pNode.line) !== undefined)) {
                    return {
                        line: pNode.line,
                        column: pNode.start
                    };
                } else {
                    return this.getNodeSourceLocation(pNode.children[pNode.children.length - 1]);
                }
            };
            return Effect;
        })();
        fx.Effect = Effect;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        var TexcoordSwapper = (function () {
            function TexcoordSwapper() {
                /**@protected*/ this._pTmpToTex = null;
                /**@protected*/ this._pTexToTmp = null;
                /**@protected*/ this._pTexcoords = null;
                /**@protected*/ this._sTmpToTexCode = "";
                /**@protected*/ this._sTexToTmpCode = "";
                /**@protected*/ this._iMaxTexcoords = 0;
                this._iMaxTexcoords = akra.core.pool.resources.SurfaceMaterial.MAX_TEXTURES_PER_SURFACE;
                this._pTmpToTex = new Array(this._iMaxTexcoords);
                this._pTexToTmp = new Array(this._iMaxTexcoords);
                this._pTexcoords = new Array(this._iMaxTexcoords);
            }
            TexcoordSwapper.prototype.getTmpDeclCode = /** @inline */function () {
                return this._sTexToTmpCode;
            };
            TexcoordSwapper.prototype.getTecoordSwapCode = /** @inline */function () {
                return this._sTmpToTexCode;
            };
            TexcoordSwapper.prototype.clear = function () {
                for(var i = 0; i < this._iMaxTexcoords; i++) {
                    this._pTmpToTex[i] = "";
                    this._pTexToTmp[i] = "";
                    this._pTexcoords[i] = 0;
                }
                this._sTmpToTexCode = "";
                this._sTexToTmpCode = "";
            };
            TexcoordSwapper.prototype.generateSwapCode = function (pMaterial, pAttrConatiner) {
                this.clear();
                if (((pMaterial) === null)) {
                    return;
                }
                //TODO: do it faster in one for
                var pTexcoords = this._pTexcoords;
                for(var i = 0; i < this._iMaxTexcoords; i++) {
                    var iTexcoord = (pMaterial._pTexcoords[(i)]);
                    if (iTexcoord !== i && (((pAttrConatiner).hasVariableWithName((/*checked (origin: akra)>>*/akra.DeclUsages.TEXCOORD + (i).toString()))))) {
                        var pAttr = (((pAttrConatiner).hasVariableWithName((/*checked (origin: akra)>>*/akra.DeclUsages.TEXCOORD + (i).toString())) ? (pAttrConatiner)._pVarListMap[(/*checked (origin: akra)>>*/akra.DeclUsages.TEXCOORD + (i).toString())][0] : null));
                        this._pTexToTmp[i] = pAttr.getType().getBaseType().getRealName() + " " + "T" + i.toString() + "=" + pAttr.getRealName() + ";";
                        this._sTexToTmpCode += this._pTexToTmp[i] + "\n";
                    }
                    if (!(((pAttrConatiner).hasVariableWithName((/*checked (origin: akra)>>*/akra.DeclUsages.TEXCOORD + (iTexcoord).toString()))))) {
                        pTexcoords[iTexcoord] = 0;
                    } else {
                        pTexcoords[iTexcoord] = iTexcoord;
                    }
                }
                for(var i = 0; i < this._iMaxTexcoords; i++) {
                    if (pTexcoords[i] !== i && (((pAttrConatiner).hasVariableWithName((/*checked (origin: akra)>>*/akra.DeclUsages.TEXCOORD + (i).toString()))))) {
                        var pAttr = (((pAttrConatiner).hasVariableWithName((/*checked (origin: akra)>>*/akra.DeclUsages.TEXCOORD + (i).toString())) ? (pAttrConatiner)._pVarListMap[(/*checked (origin: akra)>>*/akra.DeclUsages.TEXCOORD + (i).toString())][0] : null));
                        if (this._pTexToTmp[pTexcoords[i]] !== "") {
                            this._pTmpToTex[i] = pAttr.getRealName() + "=" + this._pTexToTmp[pTexcoords[i]] + ";";
                        } else {
                            this._pTmpToTex[i] = pAttr.getRealName() + "=" + (((pAttrConatiner).hasVariableWithName((/*checked (origin: akra)>>*/akra.DeclUsages.TEXCOORD + (pTexcoords[i]).toString())) ? (pAttrConatiner)._pVarListMap[(/*checked (origin: akra)>>*/akra.DeclUsages.TEXCOORD + (pTexcoords[i]).toString())][0] : null)).getRealName() + ";";
                        }
                        this._sTmpToTexCode += this._pTmpToTex[i] + "\n";
                    }
                }
            };
            return TexcoordSwapper;
        })();
        fx.TexcoordSwapper = TexcoordSwapper;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        function createShaderUniformInfo(sName, iLocation, pWebGLLocation) {
            return {
                name: sName,
                location: iLocation,
                webGLLocation: pWebGLLocation,
                type: akra.EAFXShaderVariableType.k_NotVar,
                length: 0,
                applyFunction: null,
                defaultValue: null
            };
        }
        function createShaderAttrInfo(sName, iLocation) {
            return {
                name: sName,
                location: iLocation,
                semantic: "",
                isMappable: false,
                isComplex: false,
                vertexTextureInfo: null,
                offsets: null
            };
        }
        function createShaderAttrOffsetInfo(sSemantic, pShaderUniformInfo, fDefault) {
            return {
                semantic: sSemantic,
                shaderVarInfo: pShaderUniformInfo,
                defaultValue: fDefault
            };
        }
        function createInputUniformInfo(sName, pShaderUniformInfo, isComplex) {
            return {
                name: sName,
                isComplex: isComplex,
                isCollapsedArray: false,
                shaderVarInfo: pShaderUniformInfo,
                structVarInfo: null
            };
        }
        // function createUniformStructFieldInfo(sName: string, sShaderName: string,
        // 							  eType: EAFXShaderVariableType, iLength: uint): IUniformStructInfo {
        // 	return <IUniformStructInfo>{
        // 		name: sName,
        // 		shaderName: sShaderName,
        // 		type: eType,
        // 		length: iLength
        // 	};
        // }
        function createUniformStructFieldInfo(sName, isComplex, isArray) {
            return {
                name: sName,
                isComplex: isComplex,
                isArray: isArray,
                index: -1,
                fields: null,
                shaderVarInfo: null
            };
        }
        var Maker = (function () {
            function Maker(pComposer, pPassBlend) {
                /**@protected*/ this._iGuid = akra.sid();
                this._pComposer = null;
                this._pPassBlend = null;
                this._pShaderProgram = null;
                this._pRealUniformNameList = null;
                this._pRealAttrNameList = null;
                // is really exists uniform & attr?
                this._pUniformExistMap = {};
                this._pAttrExistMap = {};
                this._isUsedZero2D = false;
                this._isUsedZeroCube = false;
                // private _pAttrContainer: AttributeBlendContainer = null;
                //стек объектов храняих все юниформы и аттрибуты
                this._pDataPoolArray = new akra.util.ObjectArray();
                this._pShaderUniformInfoMap = null;
                this._pShaderAttrInfoMap = null;
                this._pShaderUniformInfoList = null;
                this._pShaderAttrInfoList = null;
                this._pInputUniformInfoList = null;
                this._pInputSamplerInfoList = null;
                this._pInputSamplerArrayInfoList = null;
                this._pUnifromInfoForStructFieldMap = null;
                this._pComposer = pComposer;
                this._pPassBlend = pPassBlend;
            }
            Maker.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            Maker.prototype.isArray = /** @inline */function (sName) {
                return ((this)._pShaderUniformInfoMap[(sName)].length) > 0;
            };
            Maker.prototype.getType = /** @inline */function (sName) {
                return this._pShaderUniformInfoMap[sName].type;
            };
            Maker.prototype.getLength = /** @inline */function (sName) {
                return this._pShaderUniformInfoMap[sName].length;
            };
            Object.defineProperty(Maker.prototype, "shaderProgram", {
                get: /** @inline */function () {
                    return this._pShaderProgram;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Maker.prototype, "attributeInfo", {
                get: /** @inline */function () {
                    return this._pShaderAttrInfoList;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Maker.prototype, "uniformNames", {
                get: /** @inline */function () {
                    return this._pRealUniformNameList;
                },
                enumerable: true,
                configurable: true
            });
            Maker.prototype._create = function (sVertex, sPixel) {
                var pRmgr = this._pComposer.getEngine().getResourceManager();
                // LOG(this, sVertex, sPixel);
                var pProgram = pRmgr.createShaderProgram(".shader-prorgam-" + ((this)._iGuid).toString());
                if (!pProgram.create(sVertex, sPixel)) {
                    return false;
                }
                this._pRealUniformNameList = (Object.keys(pProgram._pWebGLUniformLocations));
                this._pRealAttrNameList = (Object.keys(pProgram._pWebGLAttributeLocations));
                this._pShaderUniformInfoList = new Array(this._pRealUniformNameList.length);
                this._pShaderAttrInfoList = new Array(this._pRealAttrNameList.length);
                this._pShaderUniformInfoMap = {};
                this._pShaderAttrInfoMap = {};
                this._pShaderProgram = pProgram;
                for(var i = 0; i < this._pRealUniformNameList.length; i++) {
                    var sUniformName = this._pRealUniformNameList[i];
                    var pUniformInfo = createShaderUniformInfo(sUniformName, i, /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/pProgram.getWebGLUniformLocation(sUniformName));
                    this._pUniformExistMap[sUniformName] = true;
                    this._pShaderUniformInfoList[i] = pUniformInfo;
                    this._pShaderUniformInfoMap[sUniformName] = pUniformInfo;
                }
                for(var i = 0; i < this._pRealAttrNameList.length; i++) {
                    var sAttrName = this._pRealAttrNameList[i];
                    var pAttrInfo = createShaderAttrInfo(sAttrName, i);
                    this._pAttrExistMap[sAttrName] = true;
                    this._pShaderAttrInfoList[i] = pAttrInfo;
                    this._pShaderAttrInfoMap[sAttrName] = pAttrInfo;
                }
                this._pUnifromInfoForStructFieldMap = {};
                this["sVertex"] = sVertex;
                this["sPixel"] = sPixel;
                // LOG(sVertex, sPixel);
                return true;
            };
            Maker.prototype._getShaderInput = /** @inline */function () {
                return ((this._pDataPoolArray)._iLength) > 0 ? /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this._pDataPoolArray.pop() : this._createDataPool();
            };
            Maker.prototype._releaseShaderInput = /** @inline */function (pPool) {
                /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this._pDataPoolArray.push(pPool);
            };
            Maker.prototype.isUniformExists = /** @inline */function (sName) {
                return this._pUniformExistMap[sName] ? true : this._pUniformExistMap[sName] = false;
            };
            Maker.prototype.isAttrExists = /** @inline */function (sName) {
                return this._pAttrExistMap[sName] ? true : this._pAttrExistMap[sName] = false;
            };
            Maker.prototype._createDataPool = function () {
                var pInput = {
                    uniforms: {},
                    attrs: {}
                };
                //assume, that attr & uniform never have same names!!!
                for(var i = 0; i < this._pShaderUniformInfoList.length; i++) {
                    var pUniformInfo = this._pShaderUniformInfoList[i];
                    pInput.uniforms[i] = null;
                    if ((pUniformInfo.type === akra.EAFXShaderVariableType.k_Sampler2D || pUniformInfo.type === akra.EAFXShaderVariableType.k_SamplerCUBE)) {
                        if (pUniformInfo.length > 0) {
                            pInput.uniforms[i] = new Array(pUniformInfo.length);
                            for(var j = 0; j < pUniformInfo.length; j++) {
                                pInput.uniforms[i][j] = ({
textureName: "",
texture: null,
wrap_s: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
wrap_t: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
mag_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR,
min_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR
});
                            }
                        } else {
                            pInput.uniforms[i] = ({
textureName: "",
texture: null,
wrap_s: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
wrap_t: /*checked (origin: akra)>>*/akra.ETextureWrapModes.CLAMP_TO_EDGE,
mag_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR,
min_filter: /*checked (origin: akra)>>*/akra.ETextureFilters.LINEAR
});
                        }
                    }
                }
                for(var i = 0; i < this._pShaderAttrInfoList.length; i++) {
                    pInput.attrs[i] = null;
                }
                return pInput;
            };
            Maker.prototype.setUniform = function (iLocation, pValue) {
                if (this._pShaderUniformInfoList[iLocation].type !== akra.EAFXShaderVariableType.k_NotVar) {
                    this._pShaderUniformInfoList[iLocation].applyFunction.call(this._pShaderProgram, this._pShaderUniformInfoList[iLocation].webGLLocation, pValue || this._pShaderUniformInfoList[iLocation].defaultValue);
                }
            };
            Maker.prototype._initInput = function (pPassInput, pBlend, pAttrs) {
                /* Initialize info about uniform variables(not samplers and video buffers) */
                var pUniformKeys = pPassInput.uniformKeys;
                this._pInputUniformInfoList = [];
                for(var i = 0; i < pUniformKeys.length; i++) {
                    var sName = pUniformKeys[i];
                    var eType = pPassInput._getUniformType(sName);
                    var iLength = pPassInput._getUnifromLength(sName);
                    var isArray = (iLength > 0);
                    var pInputUniformInfo = null;
                    if (eType === akra.EAFXShaderVariableType.k_Complex) {
                        var pStructInfo = this.expandStructUniforms(pPassInput._getAFXUniformVar(sName));
                        if (!((pStructInfo) === null)) {
                            pInputUniformInfo = createInputUniformInfo(sName, null, true);
                            pInputUniformInfo.structVarInfo = pStructInfo;
                            this._pInputUniformInfoList.push(pInputUniformInfo);
                        }
                    } else {
                        var sShaderName = isArray ? (sName + "[0]") : sName;
                        if (!((this)._pUniformExistMap[(sShaderName)] ? true : (this)._pUniformExistMap[(sShaderName)] = false)) {
                            continue;
                        }
                        var pShaderUniformInfo = this._pShaderUniformInfoMap[sShaderName];
                        pShaderUniformInfo.type = eType;
                        pShaderUniformInfo.length = iLength;
                        pInputUniformInfo = createInputUniformInfo(sName, pShaderUniformInfo, false);
                        this._pInputUniformInfoList.push(pInputUniformInfo);
                    }
                }
                /* Initialize info about samplers*/
                var iTotalSamplerSlots = (pBlend._nActiveSlots);
                this._pInputSamplerInfoList = [];
                for(var i = 0; i < iTotalSamplerSlots; i++) {
                    var pShaderUniformInfo = null;
                    var pInputUniformInfo = null;
                    if (i === 0) {
                        this._isUsedZero2D = ((this)._pUniformExistMap[("as0")] ? true : (this)._pUniformExistMap[("as0")] = false);
                        this._isUsedZeroCube = ((this)._pUniformExistMap[("asc0")] ? true : (this)._pUniformExistMap[("asc0")] = false);
                        if (this._isUsedZero2D) {
                            pShaderUniformInfo = this._pShaderUniformInfoMap["as0"];
                            pShaderUniformInfo.type = akra.EAFXShaderVariableType.k_Int;
                            pShaderUniformInfo.length = 0;
                        }
                        if (this._isUsedZeroCube) {
                            pShaderUniformInfo = this._pShaderUniformInfoMap["asc0"];
                            pShaderUniformInfo.type = akra.EAFXShaderVariableType.k_Int;
                            pShaderUniformInfo.length = 0;
                        }
                        continue;
                    }
                    var sRealSamplerName = "as" + i.toString();
                    if (!((this)._pUniformExistMap[(sRealSamplerName)] ? true : (this)._pUniformExistMap[(sRealSamplerName)] = false)) {
                        continue;
                    }
                    var pSampler = (((((pBlend)._pSlotList)[(i)]))._pData[(0)]);
                    var sSampler = pSampler.getSemantic() || pSampler.getName();
                    var eType = pSampler.getType().isSampler2D() ? akra.EAFXShaderVariableType.k_Sampler2D : akra.EAFXShaderVariableType.k_SamplerCUBE;
                    pShaderUniformInfo = this._pShaderUniformInfoMap[sRealSamplerName];
                    pShaderUniformInfo.type = eType;
                    pShaderUniformInfo.length = 0;
                    pInputUniformInfo = createInputUniformInfo(sSampler, pShaderUniformInfo, false);
                    pInputUniformInfo.isCollapsedArray = (pSampler.getType().getLength() > 0);
                    this._pInputSamplerInfoList.push(pInputUniformInfo);
                }
                /* Initialize info about array of samplers */
                var pSamplerArrayKeys = pPassInput.samplerArrayKeys;
                this._pInputSamplerArrayInfoList = [];
                for(var i = 0; i < pSamplerArrayKeys.length; i++) {
                    var sName = pSamplerArrayKeys[i];
                    var eType = pPassInput._getUniformType(sName);
                    var iLength = pPassInput._getUnifromLength(sName);
                    var sShaderName = sName + "[0]";
                    var pInputUniformInfo = null;
                    if (!((this)._pUniformExistMap[(sShaderName)] ? true : (this)._pUniformExistMap[(sShaderName)] = false)) {
                        continue;
                    }
                    var pShaderUniformInfo = this._pShaderUniformInfoMap[sShaderName];
                    pShaderUniformInfo.type = eType;
                    pShaderUniformInfo.length = iLength;
                    pInputUniformInfo = createInputUniformInfo(sName, pShaderUniformInfo, false);
                    this._pInputSamplerArrayInfoList.push(pInputUniformInfo);
                }
                var pSemantics = (((pAttrs)._pVarKeys));
                var nPreparedAttrs = -1;
                var nPreparedBuffers = -1;
                for(var i = 0; i < pSemantics.length; i++) {
                    var sSemantic = pSemantics[i];
                    var iSlot = (pAttrs._pSlotBySemanticIndex[((pAttrs)._pKeyToIndexMap[((sSemantic))])]);
                    if (iSlot === -1) {
                        continue;
                    }
                    var iBufferSlot = (pAttrs._pBufferSlotBySlots[((pAttrs)._pSlotBySemanticIndex[(((pAttrs))._pKeyToIndexMap[(((sSemantic)))])])]);
                    // is it not initied attr?
                    if (iSlot > nPreparedAttrs) {
                        var sAttrName = "aa" + iSlot.toString();
                        var sBufferName = "abs" + iBufferSlot.toString();
                        if (!((this)._pAttrExistMap[(sAttrName)] ? true : (this)._pAttrExistMap[(sAttrName)] = false)) {
                            continue;
                        }
                        var pShaderAttrInfo = this._pShaderAttrInfoMap[sAttrName];
                        var isMappable = iBufferSlot >= 0;
                        var pVertexTextureInfo = isMappable ? this._pShaderUniformInfoMap[sBufferName] : null;
                        var isComplex = (((pAttrs)._pVarBlendTypeMap[((sSemantic))])).isComplex();
                        // need to init buffer
                        if (iBufferSlot > nPreparedBuffers) {
                            if (!((this)._pUniformExistMap[(sBufferName)] ? true : (this)._pUniformExistMap[(sBufferName)] = false)) {
 {
                                    akra.logger.setSourceLocation("fx/Maker.ts", 510);
                                    akra.logger.error("This erroer must not be happen");
                                }
                                ;
                                continue;
                            }
                            pVertexTextureInfo.type = akra.EAFXShaderVariableType.k_SamplerVertexTexture;
                            pVertexTextureInfo.length = 0;
                        }
                        pShaderAttrInfo.semantic = sSemantic;
                        pShaderAttrInfo.isMappable = isMappable;
                        pShaderAttrInfo.isComplex = isComplex;
                        pShaderAttrInfo.vertexTextureInfo = pVertexTextureInfo;
                        nPreparedAttrs++;
                    }
                    //add offset uniforms
                    var pOffsetVars = (pAttrs._pOffsetVarsBySemanticMap[(sSemantic)]);
                    if (!((pOffsetVars) === null)) {
                        var pShaderAttrInfo = this._pShaderAttrInfoList[iSlot];
                        var pOffsetInfoList = pShaderAttrInfo.offsets || new Array();
                        for(var j = 0; j < pOffsetVars.length; j++) {
                            var sOffsetSemantic = pOffsetVars[j].getSemantic();
                            var sOffsetName = pOffsetVars[j].getRealName();
                            if (((this)._pUniformExistMap[(sOffsetName)] ? true : (this)._pUniformExistMap[(sOffsetName)] = false)) {
                                var pOffsetUniformInfo = this._pShaderUniformInfoMap[sOffsetName];
                                var fDefaultValue = (pAttrs._pOffsetDefaultMap[(sOffsetName)]);
                                pOffsetUniformInfo.type = akra.EAFXShaderVariableType.k_Float;
                                pOffsetUniformInfo.length = 0;
                                pOffsetInfoList.push(createShaderAttrOffsetInfo(sOffsetSemantic, pOffsetUniformInfo, fDefaultValue));
                            }
                        }
                        pShaderAttrInfo.offsets = pOffsetInfoList;
                    }
                }
                /* Prepare funtions to set uniform value in real shader progrham */
                for(var i = 0; i < this._pShaderUniformInfoList.length; i++) {
                    this.prepareApplyFunctionForUniform(this._pShaderUniformInfoList[i]);
                }
                return true;
            };
            Maker.prototype._make = function (pPassInput, pBufferMap) {
                var pUniforms = pPassInput.uniforms;
                var pTextures = pPassInput.textures;
                var pSamplers = pPassInput.samplers;
                var pSamplerArrays = pPassInput.samplerArrays;
                var pInput = ((((this)._pDataPoolArray)._iLength) > 0 ? /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/(this)._pDataPoolArray.pop() : (this)._createDataPool());
                for(var i = 0; i < this._pInputUniformInfoList.length; i++) {
                    var pInfo = this._pInputUniformInfoList[i];
                    if (pInfo.isComplex) {
                        this.applyStructUniform(pInfo.structVarInfo, pUniforms[pInfo.name], pInput);
                    } else {
                        pInput.uniforms[pInfo.shaderVarInfo.location] = pUniforms[pInfo.name];
                    }
                }
                for(var i = 0; i < this._pInputSamplerInfoList.length; i++) {
                    var pInfo = this._pInputSamplerInfoList[i];
                    var pState = null;
                    var pTexture = null;
                    if (pInfo.isCollapsedArray) {
                        pState = pSamplerArrays[pInfo.name][0];
                    } else {
                        pState = pPassInput._getSamplerState(pInfo.name);
                    }
                    // if(!isDef(pState)){
                    // 	LOG("Bad");
                    // }
                    pTexture = pPassInput._getTextureForSamplerState(pState);
                    this.setSamplerState(pInput.uniforms[pInfo.shaderVarInfo.location], pTexture, pState);
                }
                for(var i = 0; i < this._pInputSamplerArrayInfoList.length; i++) {
                    var pInfo = this._pInputSamplerArrayInfoList[i];
                    var pSamplerStates = pSamplerArrays[pInfo.name];
                    var pInputStates = pInput.uniforms[pInfo.shaderVarInfo.location];
                    for(var j = 0; j < pInfo.shaderVarInfo.length; j++) {
                        var pTexture = pPassInput._getTextureForSamplerState(pSamplerStates[j]);
                        this.setSamplerState(pInputStates[j], pTexture, pSamplerStates[j]);
                    }
                }
                for(var i = 0; i < this._pShaderAttrInfoList.length; i++) {
                    var pAttrInfo = this._pShaderAttrInfoList[i];
                    var pFlow = pAttrInfo.isComplex ? pBufferMap.findFlow(pAttrInfo.semantic) || pBufferMap.getFlowBySemantic(pAttrInfo.semantic) : pBufferMap.getFlowBySemantic(pAttrInfo.semantic);
                    // pBufferMap.findFlow(pAttrInfo.semantic) || pBufferMap.getFlow(pAttrInfo.semantic, true):
                    // pBufferMap.getFlow(pAttrInfo.semantic, true);
                    pInput.attrs[pAttrInfo.location] = pFlow;
                    if (pAttrInfo.isMappable) {
                        pInput.uniforms[pAttrInfo.vertexTextureInfo.location] = pFlow.data.buffer;
                        if (!((pAttrInfo.offsets) === null)) {
                            var pVertexDecl = pFlow.data.getVertexDeclaration();
                            for(var j = 0; j < pAttrInfo.offsets.length; j++) {
                                var pOffsetInfo = pAttrInfo.offsets[j];
                                var pElement = pVertexDecl.findElement(pOffsetInfo.semantic);
                                if (((pElement) === null)) {
                                    pInput.uniforms[pOffsetInfo.shaderVarInfo.location] = pOffsetInfo.defaultValue;
                                } else {
                                    /* offset in float */
                                    pInput.uniforms[pOffsetInfo.shaderVarInfo.location] = pElement.offset / 4.;
                                }
                            }
                        }
                    }
                }
                if (this._isUsedZero2D) {
                    pInput.uniforms[this._pShaderUniformInfoMap["as0"].location] = 19;
                }
                if (this._isUsedZeroCube) {
                    pInput.uniforms[this._pShaderUniformInfoMap["asc0"].location] = 19;
                }
                return pInput;
            };
            Maker.prototype.prepareApplyFunctionForUniform = function (pUniform) {
                if (pUniform.type !== akra.EAFXShaderVariableType.k_NotVar) {
                    pUniform.applyFunction = this.getUniformApplyFunction(pUniform.type, (pUniform.length > 0));
                    pUniform.defaultValue = this.getUnifromDefaultValue(pUniform.type, (pUniform.length > 0));
                }
            };
            Maker.prototype.getUniformApplyFunction = function (eType, isArray) {
                if (isArray) {
                    switch(eType) {
                        case akra.EAFXShaderVariableType.k_Float:
                            return this._pShaderProgram._setFloat32Array;
                        case akra.EAFXShaderVariableType.k_Int:
                            return this._pShaderProgram._setInt32Array;
                        case akra.EAFXShaderVariableType.k_Bool:
                            return this._pShaderProgram._setInt32Array;
                        case akra.EAFXShaderVariableType.k_Float2:
                            return this._pShaderProgram._setVec2Array;
                        case akra.EAFXShaderVariableType.k_Int2:
                            return this._pShaderProgram._setVec2iArray;
                            // case EAFXShaderVariableType.k_Bool2:
                            // 	return this._pShaderProgram._setBool2Array;
                                                    case akra.EAFXShaderVariableType.k_Float3:
                            return this._pShaderProgram._setVec3Array;
                        case akra.EAFXShaderVariableType.k_Int3:
                            return this._pShaderProgram._setVec3iArray;
                            // case EAFXShaderVariableType.k_Bool3:
                            // 	return this._pShaderProgram._setBool3Array;
                                                    case akra.EAFXShaderVariableType.k_Float4:
                            return this._pShaderProgram._setVec4Array;
                        case akra.EAFXShaderVariableType.k_Int4:
                            return this._pShaderProgram._setVec4iArray;
                            // case EAFXShaderVariableType.k_Bool4:
                            // 	return this._pShaderProgram._setBool4Array;
                            // case EAFXShaderVariableType.k_Float2x2:
                            // 	return this._pShaderProgram._setMat2Array;
                                                    case akra.EAFXShaderVariableType.k_Float3x3:
                            return this._pShaderProgram._setMat3Array;
                        case akra.EAFXShaderVariableType.k_Float4x4:
                            return this._pShaderProgram._setMat4Array;
                        case akra.EAFXShaderVariableType.k_Sampler2D:
                            return this._pShaderProgram._setSamplerArray;
                        case akra.EAFXShaderVariableType.k_SamplerCUBE:
                            return this._pShaderProgram._setSamplerArray;
                        default:
 {
                                akra.logger.setSourceLocation("fx/Maker.ts", 708);
                                akra.logger.criticalError("Wrong uniform array type (" + eType + ")");
                            }
                            ;
                    }
                } else {
                    switch(eType) {
                        case akra.EAFXShaderVariableType.k_Float:
                            return this._pShaderProgram._setFloat;
                        case akra.EAFXShaderVariableType.k_Int:
                            return this._pShaderProgram._setInt;
                        case akra.EAFXShaderVariableType.k_Bool:
                            return this._pShaderProgram._setInt;
                        case akra.EAFXShaderVariableType.k_Float2:
                            return this._pShaderProgram._setVec2;
                        case akra.EAFXShaderVariableType.k_Int2:
                            return this._pShaderProgram._setVec2i;
                            // case EAFXShaderVariableType.k_Bool2:
                            // 	return this._pShaderProgram._setBool2
                                                    case akra.EAFXShaderVariableType.k_Float3:
                            return this._pShaderProgram._setVec3;
                        case akra.EAFXShaderVariableType.k_Int3:
                            return this._pShaderProgram._setVec3i;
                            // case EAFXShaderVariableType.k_Bool3:
                            // 	return this._pShaderProgram._setBool3
                                                    case akra.EAFXShaderVariableType.k_Float4:
                            return this._pShaderProgram._setVec4;
                        case akra.EAFXShaderVariableType.k_Int4:
                            return this._pShaderProgram._setVec4i;
                            // case EAFXShaderVariableType.k_Bool4:
                            // 	return this._pShaderProgram._setBool4
                            // case EAFXShaderVariableType.k_Float2x2:
                            // 	return this._pShaderProgram._setMat2
                                                    case akra.EAFXShaderVariableType.k_Float3x3:
                            return this._pShaderProgram._setMat3;
                        case akra.EAFXShaderVariableType.k_Float4x4:
                            return this._pShaderProgram._setMat4;
                        case akra.EAFXShaderVariableType.k_Sampler2D:
                            return this._pShaderProgram._setSampler;
                        case akra.EAFXShaderVariableType.k_SamplerCUBE:
                            return this._pShaderProgram._setSampler;
                        case akra.EAFXShaderVariableType.k_SamplerVertexTexture:
                            return this._pShaderProgram._setVertexBuffer;
                        default:
 {
                                akra.logger.setSourceLocation("fx/Maker.ts", 755);
                                akra.logger.criticalError("Wrong uniform type (" + eType + ")");
                            }
                            ;
                    }
                }
            };
            Maker.prototype.getUnifromDefaultValue = function (eType, isArray) {
                if (isArray) {
                    return null;
                } else {
                    switch(eType) {
                        case akra.EAFXShaderVariableType.k_Float:
                            return 0.;
                        case akra.EAFXShaderVariableType.k_Int:
                            return 0;
                        case akra.EAFXShaderVariableType.k_Bool:
                            return 0;
                        case akra.EAFXShaderVariableType.k_Float2:
                            return new akra.Vec2(0);
                        case akra.EAFXShaderVariableType.k_Int2:
                            return new akra.Vec2(0);
                        case akra.EAFXShaderVariableType.k_Bool2:
                            return new akra.Vec2(0);
                        case akra.EAFXShaderVariableType.k_Float3:
                            return new akra.Vec3(0);
                        case akra.EAFXShaderVariableType.k_Int3:
                            return new akra.Vec3(0);
                        case akra.EAFXShaderVariableType.k_Bool3:
                            return new akra.Vec3(0);
                        case akra.EAFXShaderVariableType.k_Float4:
                            return new akra.Vec4(0);
                        case akra.EAFXShaderVariableType.k_Int4:
                            return new akra.Vec4(0);
                        case akra.EAFXShaderVariableType.k_Bool4:
                            return new akra.Vec4(0);
                            // case EAFXShaderVariableType.k_Float2x2:
                            // 	return new Mat2(0);
                                                    case akra.EAFXShaderVariableType.k_Float3x3:
                            return new akra.Mat3(0);
                        case akra.EAFXShaderVariableType.k_Float4x4:
                            return new akra.Mat4(0);
                        case akra.EAFXShaderVariableType.k_Sampler2D:
                            return null;
                        case akra.EAFXShaderVariableType.k_SamplerCUBE:
                            return null;
                        case akra.EAFXShaderVariableType.k_SamplerVertexTexture:
                            return null;
                        default:
 {
                                akra.logger.setSourceLocation("fx/Maker.ts", 903);
                                akra.logger.criticalError("Wrong uniform type (" + eType + ")");
                            }
                            ;
                    }
                }
            };
            Maker.prototype.setSamplerState = function (pOut, pTexture, pFrom) {
                pOut.texture = pTexture;
                pOut.wrap_s = pFrom.wrap_s;
                pOut.wrap_t = pFrom.wrap_t;
                pOut.mag_filter = pFrom.mag_filter;
                pOut.min_filter = pFrom.min_filter;
            };
            Maker.prototype.expandStructUniforms = function (pVariable, sPrevName) {
                if (typeof sPrevName === "undefined") { sPrevName = ""; }
                var sRealName = pVariable.getRealName();
                if (sPrevName !== "") {
                    sPrevName += "." + sRealName;
                } else {
                    if (!this._pPassBlend._hasUniformWithName(sRealName)) {
                        return null;
                    }
                    sPrevName = sRealName;
                }
                var pVarType = pVariable.getType();
                var pFieldNameList = pVarType.getFieldNameList();
                var isArray = pVarType.isNotBaseArray();
                var iLength = isArray ? pVarType.getLength() : 1;
                if (isArray && (iLength === 0xffffff || iLength === 0)) {
 {
                        akra.logger.setSourceLocation("fx/Maker.ts", 936);
                        akra.logger.warning("Length of struct '" + sRealName + "' can not be undefined");
                    }
                    ;
                    return null;
                }
                var pStructInfo = createUniformStructFieldInfo(sRealName, true, isArray);
                pStructInfo.fields = new Array();
                var sFieldPrevName = "";
                var pFieldInfoList = null;
                for(var i = 0; i < iLength; i++) {
                    if (isArray) {
                        pFieldInfoList = new Array();
                        sFieldPrevName = sPrevName + "[" + i + "]";
                    } else {
                        pFieldInfoList = pStructInfo.fields;
                        sFieldPrevName = sPrevName;
                    }
                    for(var j = 0; j < pFieldNameList.length; j++) {
                        var sFieldName = pFieldNameList[j];
                        var pField = pVarType.getField(sFieldName);
                        var pFieldInfo = null;
                        if (pField.getType().isComplex()) {
                            pFieldInfo = this.expandStructUniforms(pField, sFieldPrevName);
                        } else {
                            var sFieldRealName = sFieldPrevName + "." + pField.getRealName();
                            var eFieldType = fx.PassInputBlend.getVariableType(pField);
                            var iFieldLength = pField.getType().getLength();
                            var isFieldArray = pField.getType().isNotBaseArray();
                            var sFieldShaderName = sFieldRealName;
                            if (isFieldArray) {
                                sFieldShaderName += "[0]";
                            }
                            if (!((this)._pUniformExistMap[(sFieldShaderName)] ? true : (this)._pUniformExistMap[(sFieldShaderName)] = false)) {
                                continue;
                            }
                            var pShaderUniformInfo = this._pShaderUniformInfoMap[sFieldShaderName];
                            pShaderUniformInfo.type = eFieldType;
                            pShaderUniformInfo.length = iFieldLength;
                            pFieldInfo = createUniformStructFieldInfo(pField.getRealName(), false, isFieldArray);
                            pFieldInfo.shaderVarInfo = pShaderUniformInfo;
                        }
                        if (!((pFieldInfo) === null)) {
                            pFieldInfoList.push(pFieldInfo);
                        }
                    }
                    if (isArray && pFieldInfoList.length > 0) {
                        var pArrayElementInfo = createUniformStructFieldInfo(sRealName, true, false);
                        pArrayElementInfo.index = i;
                        pArrayElementInfo.fields = pFieldInfoList;
                        pStructInfo.fields.push(pArrayElementInfo);
                    }
                }
                if (pStructInfo.fields.length > 0) {
                    return pStructInfo;
                } else {
                    return null;
                }
            };
            Maker.prototype.applyStructUniform = function (pStructInfo, pValue, pInput) {
                if (!((pValue) != null)) {
                    return;
                }
                if (pStructInfo.isArray) {
                    for(var i = 0; i < pStructInfo.fields.length; i++) {
                        var pFieldInfo = pStructInfo.fields[i];
                        if (((pValue[pFieldInfo.index]) !== undefined)) {
                            this.applyStructUniform(pFieldInfo, pValue[pFieldInfo.index], pInput);
                        }
                    }
                } else {
                    for(var i = 0; i < pStructInfo.fields.length; i++) {
                        var pFieldInfo = pStructInfo.fields[i];
                        var pFieldValue = pValue[pFieldInfo.name];
                        if (((pFieldValue) !== undefined)) {
                            if (pFieldInfo.isComplex) {
                                this.applyStructUniform(pFieldInfo, pFieldValue, pInput);
                            } else {
                                pInput.uniforms[pFieldInfo.shaderVarInfo.location] = pFieldValue;
                            }
                        }
                    }
                }
            };
            Maker.prototype.applyUnifromArray = function (sName, eType, pValue) {
                switch(eType) {
                    case akra.EAFXShaderVariableType.k_Float:
                        ((this._pShaderProgram)._pWebGLContext.uniform1fv((this._pShaderProgram)._pWebGLUniformLocations[(sName)], (pValue)));
                        break;
                    case akra.EAFXShaderVariableType.k_Int:
                        ((this._pShaderProgram)._pWebGLContext.uniform1iv((this._pShaderProgram)._pWebGLUniformLocations[(sName)], (pValue)));
                        break;
                        // case EAFXShaderVariableType.k_Bool:
                        // 	this._pShaderProgram.setBoolArray(sName, pValue);
                        // 	break;
                                            case akra.EAFXShaderVariableType.k_Float2:
                        /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this._pShaderProgram.setVec2Array(sName, pValue);
                        break;
                    case akra.EAFXShaderVariableType.k_Int2:
                        /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this._pShaderProgram.setVec2iArray(sName, pValue);
                        break;
                        // case EAFXShaderVariableType.k_Bool2:
                        // 	this._pShaderProgram.setBool2Array(sName, pValue);
                        // 	break;
                                            case akra.EAFXShaderVariableType.k_Float3:
                        /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this._pShaderProgram.setVec3Array(sName, pValue);
                        break;
                    case akra.EAFXShaderVariableType.k_Int3:
                        /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this._pShaderProgram.setVec3iArray(sName, pValue);
                        break;
                        // case EAFXShaderVariableType.k_Bool3:
                        // 	this._pShaderProgram.setBool3Array(sName, pValue);
                        // 	break;
                                            case akra.EAFXShaderVariableType.k_Float4:
                        /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this._pShaderProgram.setVec4Array(sName, pValue);
                        break;
                    case akra.EAFXShaderVariableType.k_Int4:
                        /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this._pShaderProgram.setVec4iArray(sName, pValue);
                        break;
                        // case EAFXShaderVariableType.k_Bool4:
                        // 	this._pShaderProgram.setBool4Array(sName, pValue);
                        // 	break;
                        // case EAFXShaderVariableType.k_Float2x2:
                        // 	this._pShaderProgram.setMat2Array(sName, pValue);
                        // 	break;
                                            case akra.EAFXShaderVariableType.k_Float3x3:
                        /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this._pShaderProgram.setMat3Array(sName, pValue);
                        break;
                    case akra.EAFXShaderVariableType.k_Float4x4:
                        /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this._pShaderProgram.setMat4Array(sName, pValue);
                        break;
                    case akra.EAFXShaderVariableType.k_Sampler2D:
                        /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this._pShaderProgram.setSamplerArray(sName, pValue);
                        break;
                    case akra.EAFXShaderVariableType.k_SamplerCUBE:
                        /*not inlined, because supportes only single statement functions(cur. st. count: 4)*/this._pShaderProgram.setSamplerArray(sName, pValue);
                        break;
                    default:
 {
                            akra.logger.setSourceLocation("fx/Maker.ts", 1099);
                            akra.logger.criticalError("Wrong uniform array type (" + eType + ") with name " + sName);
                        }
                        ;
                }
            };
            Maker.prototype.applyUniform = function (sName, eType, pValue) {
                switch(eType) {
                    case akra.EAFXShaderVariableType.k_Float:
                        ((this._pShaderProgram)._pWebGLContext.uniform1f((this._pShaderProgram)._pWebGLUniformLocations[(sName)], (pValue || 0.)));
                        break;
                    case akra.EAFXShaderVariableType.k_Int:
                        ((this._pShaderProgram)._pWebGLContext.uniform1i((this._pShaderProgram)._pWebGLUniformLocations[(sName)], (pValue || 0)));
                        break;
                    case akra.EAFXShaderVariableType.k_Bool:
                        ((this._pShaderProgram)._pWebGLContext.uniform1i((this._pShaderProgram)._pWebGLUniformLocations[(sName)], (pValue ? 1 : 0)));
                        break;
                    case akra.EAFXShaderVariableType.k_Float2:
                        this._pShaderProgram.setVec2(sName, pValue || akra.Vec2.stackCeil.set(0));
                        break;
                    case akra.EAFXShaderVariableType.k_Int2:
                        this._pShaderProgram.setVec2i(sName, pValue || akra.Vec2.stackCeil.set(0));
                        break;
                        // case EAFXShaderVariableType.k_Bool2:
                        // 	this._pShaderProgram.setBool2(sName, pValue);
                        // 	break;
                                            case akra.EAFXShaderVariableType.k_Float3:
                        this._pShaderProgram.setVec3(sName, pValue || akra.Vec3.stackCeil.set(0));
                        break;
                    case akra.EAFXShaderVariableType.k_Int3:
                        this._pShaderProgram.setVec3i(sName, pValue || akra.Vec3.stackCeil.set(0));
                        break;
                        // case EAFXShaderVariableType.k_Bool3:
                        // 	this._pShaderProgram.setBool3(sName, pValue);
                        // 	break;
                                            case akra.EAFXShaderVariableType.k_Float4:
                        this._pShaderProgram.setVec4(sName, pValue || akra.Vec4.stackCeil.set(0));
                        break;
                    case akra.EAFXShaderVariableType.k_Int4:
                        this._pShaderProgram.setVec4i(sName, pValue || akra.Vec4.stackCeil.set(0));
                        break;
                        // case EAFXShaderVariableType.k_Bool4:
                        // 	this._pShaderProgram.setBool4(sName, pValue);
                        // 	break;
                        // case EAFXShaderVariableType.k_Float2x2:
                        // 	this._pShaderProgram.setMat2(sName, pValue);
                        // 	break;
                                            case akra.EAFXShaderVariableType.k_Float3x3:
                        ((this._pShaderProgram)._pWebGLContext.uniformMatrix3fv((this._pShaderProgram)._pWebGLUniformLocations[(sName)], false, (pValue || /*checked (origin: akra)>>*/akra.Mat3.stackCeil.set(0)).data));
                        break;
                    case akra.EAFXShaderVariableType.k_Float4x4:
                        this._pShaderProgram.setMat4(sName, pValue || akra.Mat4.stackCeil.set(0));
                        break;
                    case akra.EAFXShaderVariableType.k_Sampler2D:
                        /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this._pShaderProgram.setSampler(sName, pValue);
                        break;
                    case akra.EAFXShaderVariableType.k_SamplerCUBE:
                        /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this._pShaderProgram.setSampler(sName, pValue);
                        break;
                    case akra.EAFXShaderVariableType.k_SamplerVertexTexture:
                        /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this._pShaderProgram.setVertexBuffer(sName, pValue);
                        break;
                    default:
 {
                            akra.logger.setSourceLocation("fx/Maker.ts", 1165);
                            akra.logger.criticalError("Wrong uniform type (" + eType + ") with name " + sName);
                        }
                        ;
                }
            };
            return Maker;
        })();
        fx.Maker = Maker;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        var PassBlend = (function () {
            function PassBlend(pComposer) {
                /**@protected*/ this._iGuid = akra.sid();
                this._pComposer = null;
                this._pFXMakerByHashMap = null;
                this._pExtSystemDataV = null;
                this._pComplexTypeContainerV = null;
                this._pForeignContainerV = null;
                this._pUniformContainerV = null;
                this._pSharedContainerV = null;
                this._pGlobalContainerV = null;
                this._pAttributeContainerV = null;
                this._pVaryingContainerV = null;
                this._pVertexOutType = null;
                this._pUsedFunctionListV = null;
                this._pPassFunctionListV = null;
                this._pTextureMapV = null;
                this._pExtSystemDataP = null;
                this._pComplexTypeContainerP = null;
                this._pForeignContainerP = null;
                this._pUniformContainerP = null;
                this._pSharedContainerP = null;
                this._pGlobalContainerP = null;
                this._pVaryingContainerP = null;
                this._pUsedFunctionListP = null;
                this._pPassFunctionListP = null;
                this._pTextureMapP = null;
                this._hasEmptyVertex = true;
                this._hasEmptyPixel = true;
                //Code fragments
                // private _isZeroSampler2dV: bool = false;
                // private _isZeroSamplerCubeV: bool = false;
                this._sUniformSamplerCodeV = "";
                this._sAttrBufferDeclCode = "";
                this._sAttrDeclCode = "";
                this._sAFXAttrDeclCode = "";
                this._sAttrBufferInitCode = "";
                this._sAFXAttrInitCode = "";
                this._sSystemExtBlockCodeV = "";
                this._sFunctionDefCodeV = "";
                this._sSharedVarCodeV = "";
                this._sVaryingDeclCodeV = "";
                this._sVertexOutDeclCode = "";
                this._sVertexOutToVaryingCode = "";
                this._sPassFunctionCallCodeV = "";
                // private _isZeroSampler2dP: bool = false;
                // private _isZeroSamplerCubeP: bool = false;
                this._sUniformSamplerCodeP = "";
                this._sSystemExtBlockCodeP = "";
                this._sFunctionDefCodeP = "";
                this._sSharedVarCodeP = "";
                this._sVaryingDeclCodeP = "";
                this._sPassFunctionCallCodeP = "";
                this._sVertexCode = "";
                this._sPixelCode = "";
                this._pDefaultSamplerBlender = null;
                this._pTexcoordSwapper = null;
                //For speed-up
                this._pSamplerByIdMap = null;
                this._pSamplerIdList = null;
                this._pSamplerArrayByIdMap = null;
                this._pSamplerArrayIdList = null;
                this._pComposer = pComposer;
                this._pFXMakerByHashMap = {};
                this._pExtSystemDataV = new fx.ExtSystemDataContainer();
                this._pComplexTypeContainerV = new fx.ComplexTypeBlendContainer();
                this._pForeignContainerV = new fx.VariableBlendContainer();
                this._pUniformContainerV = new fx.VariableBlendContainer();
                this._pSharedContainerV = new fx.VariableBlendContainer();
                this._pGlobalContainerV = new fx.VariableBlendContainer();
                this._pAttributeContainerV = new fx.AttributeBlendContainer();
                this._pVaryingContainerV = new fx.VariableBlendContainer();
                this._pVertexOutType = fx.Effect.getBaseVertexOutType();
                this._pUsedFunctionListV = [];
                this._pPassFunctionListV = [];
                this._pTextureMapV = {};
                this._pExtSystemDataP = new fx.ExtSystemDataContainer();
                this._pComplexTypeContainerP = new fx.ComplexTypeBlendContainer();
                this._pForeignContainerP = new fx.VariableBlendContainer();
                this._pUniformContainerP = new fx.VariableBlendContainer();
                this._pSharedContainerP = new fx.VariableBlendContainer();
                this._pGlobalContainerP = new fx.VariableBlendContainer();
                this._pVaryingContainerP = new fx.VariableBlendContainer();
                this._pUsedFunctionListP = [];
                this._pPassFunctionListP = [];
                this._pTextureMapP = {};
                this._pDefaultSamplerBlender = fx.Composer.pDefaultSamplerBlender;
                if (((PassBlend.texcoordSwapper) === null)) {
                    PassBlend.texcoordSwapper = new fx.TexcoordSwapper();
                }
                this._pTexcoordSwapper = PassBlend.texcoordSwapper;
            }
            PassBlend.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            PassBlend.texcoordSwapper = null;
            PassBlend.prototype.initFromPassList = function (pPassList) {
                for(var i = 0; i < pPassList.length; i++) {
                    if (!this.addPass(pPassList[i])) {
                        return false;
                    }
                }
                if (!this.finalizeBlend()) {
                    return false;
                }
                return true;
            };
            PassBlend.prototype.generateFXMaker = function (pPassInput, pSurfaceMaterial, pBuffer) {
                pPassInput.setSurfaceMaterial(pSurfaceMaterial);
                var sForeignPartHash = this.prepareForeigns(pPassInput);
                var sSamplerPartHash = this.prepareSamplers(pPassInput);
                var sMaterialPartHash = ((((pSurfaceMaterial)) === null) ? "" : (pSurfaceMaterial)._getHash());
                var sBufferPartHash = this.prepareBufferMap(pBuffer);
                var sTotalHash = sForeignPartHash + "|" + sSamplerPartHash + "|" + sMaterialPartHash + "|" + sBufferPartHash;
                var pMaker = ((this)._pFXMakerByHashMap[(sTotalHash)]);
                if (!((pMaker) !== undefined)) {
                    this.applyForeigns(pPassInput);
                    ((this)._pTexcoordSwapper.generateSwapCode((pSurfaceMaterial), (this)._pAttributeContainerV));
                    /*not inlined, because supportes only single statement functions(cur. st. count: 7)*/this.generateShaderCode();
                    this.resetForeigns();
                    pMaker = new fx.Maker(this._pComposer, this);
                    // LOG(this, pMaker);
                    var isCreate = pMaker._create(this._sVertexCode, this._sPixelCode);
                    if (!isCreate) {
 {
                            akra.logger.setSourceLocation("fx/PassBlend.ts", 176);
                            akra.logger.criticalError("Can not create fx.Maker");
                        }
                        ;
                        return null;
                    }
                    pMaker._initInput(pPassInput, this._pDefaultSamplerBlender, this._pAttributeContainerV);
                    this._pFXMakerByHashMap[sTotalHash] = pMaker;
                }
                this._pDefaultSamplerBlender.clear();
                return pMaker;
            };
            PassBlend.prototype._hasUniformWithName = /** @inline */function (sName) {
                return ((this)._pUniformContainerV.hasVariableWithName((sName)) || (this)._pUniformContainerP.hasVariableWithName((sName)));
            };
            PassBlend.prototype.getMakerByHash = /** @inline */function (sHash) {
                return this._pFXMakerByHashMap[sHash];
            };
            PassBlend.prototype.finalizeBlend = function () {
                if (!this.finalizeBlendForVertex()) {
                    return false;
                }
                if (!this.finalizeBlendForPixel()) {
                    return false;
                }
                this.prepareFastObjects();
                return true;
            };
            PassBlend.prototype.addPass = function (pPass) {
                var pVertex = pPass.getVertexShader();
                var pPixel = pPass.getPixelShader();
                var pForeignMap = null;
                var pGlobalMap = null;
                var pSharedMap = null;
                var pUniformMap = null;
                var pTextureMap = null;
                var pAttributeMap = null;
                var pVaryingMap = null;
                var pComplexTypeMap = null;
                var pForeignKeys = null;
                var pGlobalKeys = null;
                var pSharedKeys = null;
                var pUniformKeys = null;
                var pTextureKeys = null;
                var pAttributeKeys = null;
                var pVaryingKeys = null;
                var pComplexTypeKeys = null;
                var pForeign = null;
                var pGlobal = null;
                var pShared = null;
                var pUniform = null;
                var pTexture = null;
                var pAttribute = null;
                var pVarying = null;
                var pComplexType = null;
                var pUsedFunctionList = null;
                var pUsedFunction = null;
                if (!((pVertex) === null)) {
                    this._hasEmptyVertex = false;
                    //blend system data
                    this._pExtSystemDataV.addFromFunction(pVertex);
                    //blend foreigns
                    pForeignMap = pVertex._getForeignVariableMap();
                    pForeignKeys = pVertex._getForeignVariableKeys();
                    if (!((pForeignKeys) === null)) {
                        for(var i = 0; i < pForeignKeys.length; i++) {
                            pForeign = pForeignMap[pForeignKeys[i]];
                            if (!this._pForeignContainerV.addVariable(pForeign, akra.EAFXBlendMode.k_Foreign)) {
 {
                                    akra.logger.setSourceLocation("fx/PassBlend.ts", 262);
                                    akra.logger.error("Could not add foreign variable");
                                }
                                ;
                                return false;
                            }
                        }
                    }
                    //blend globals
                    pGlobalMap = pVertex._getGlobalVariableMap();
                    pGlobalKeys = pVertex._getGlobalVariableKeys();
                    if (!((pGlobalKeys) === null)) {
                        for(var i = 0; i < pGlobalKeys.length; i++) {
                            pGlobal = pGlobalMap[pGlobalKeys[i]];
                            if (!this._pGlobalContainerV.addVariable(pGlobal, akra.EAFXBlendMode.k_Global)) {
 {
                                    akra.logger.setSourceLocation("fx/PassBlend.ts", 277);
                                    akra.logger.error("Could not add global variable");
                                }
                                ;
                                return false;
                            }
                        }
                    }
                    //blend shareds
                    pSharedMap = pVertex._getSharedVariableMap();
                    pSharedKeys = pVertex._getSharedVariableKeys();
                    if (!((pSharedKeys) === null)) {
                        for(var i = 0; i < pSharedKeys.length; i++) {
                            pShared = pSharedMap[pSharedKeys[i]];
                            if (!this._pSharedContainerV.addVariable(pShared, akra.EAFXBlendMode.k_Shared)) {
 {
                                    akra.logger.setSourceLocation("fx/PassBlend.ts", 292);
                                    akra.logger.error("Could not add shared variable");
                                }
                                ;
                                return false;
                            }
                        }
                    }
                    //TODO: blend uniforms
                    pUniformMap = pVertex._getUniformVariableMap();
                    pUniformKeys = pVertex._getUniformVariableKeys();
                    if (!((pUniformKeys) === null)) {
                        for(var i = 0; i < pUniformKeys.length; i++) {
                            pUniform = pUniformMap[pUniformKeys[i]];
                            if (((pUniform) === null)) {
                                continue;
                            }
                            if (!this._pUniformContainerV.addVariable(pUniform, akra.EAFXBlendMode.k_Uniform)) {
 {
                                    akra.logger.setSourceLocation("fx/PassBlend.ts", 311);
                                    akra.logger.error("Could not add uniform variable");
                                }
                                ;
                                return false;
                            }
                        }
                    }
                    //TODO: blend textures
                    pTextureMap = pVertex._getTextureVariableMap();
                    pTextureKeys = pVertex._getTextureVariableKeys();
                    if (!((pTextureKeys) === null)) {
                        for(var i = 0; i < pTextureKeys.length; i++) {
                            pTexture = pTextureMap[pTextureKeys[i]];
                            if (((pTexture) === null)) {
                                continue;
                            }
                            this._pTextureMapV[pTexture.getRealName()] = true;
                        }
                    }
                    //TODO: blend attributes
                    pAttributeMap = pVertex._getAttributeVariableMap();
                    pAttributeKeys = pVertex._getAttributeVariableKeys();
                    if (!((pAttributeKeys) === null)) {
                        for(var i = 0; i < pAttributeKeys.length; i++) {
                            pAttribute = pAttributeMap[pAttributeKeys[i]];
                            if (!((this._pAttributeContainerV).addVariable((pAttribute), /*checked (origin: akra)>>*/akra.EAFXBlendMode.k_Attribute))) {
 {
                                    akra.logger.setSourceLocation("fx/PassBlend.ts", 343);
                                    akra.logger.error("Could not add attribute variable");
                                }
                                ;
                                return false;
                            }
                        }
                    }
                    //TODO: blend varyings
                    pVaryingMap = pVertex._getVaryingVariableMap();
                    pVaryingKeys = pVertex._getVaryingVariableKeys();
                    if (!((pVaryingKeys) === null)) {
                        for(var i = 0; i < pVaryingKeys.length; i++) {
                            pVarying = pVaryingMap[pVaryingKeys[i]];
                            if (!this._pVaryingContainerV.addVariable(pVarying, akra.EAFXBlendMode.k_Varying)) {
 {
                                    akra.logger.setSourceLocation("fx/PassBlend.ts", 358);
                                    akra.logger.error("Could not add varying variable");
                                }
                                ;
                                return false;
                            }
                        }
                    }
                    //blend used type
                    pComplexTypeMap = pVertex._getUsedComplexTypeMap();
                    pComplexTypeKeys = pVertex._getUsedComplexTypeKeys();
                    if (!((pComplexTypeKeys) === null)) {
                        for(var i = 0; i < pComplexTypeKeys.length; i++) {
                            pComplexType = pComplexTypeMap[pComplexTypeKeys[i]];
                            if (!this._pComplexTypeContainerV.addComplexType(pComplexType)) {
 {
                                    akra.logger.setSourceLocation("fx/PassBlend.ts", 373);
                                    akra.logger.error("Could not add type declaration");
                                }
                                ;
                                return false;
                            }
                        }
                    }
                    //blend used functions
                    pUsedFunctionList = pVertex._getUsedFunctionList();
                    if (!((pUsedFunctionList) === null)) {
                        for(var i = 0; i < pUsedFunctionList.length; i++) {
                            pUsedFunction = pUsedFunctionList[i];
                            if (this._pUsedFunctionListV.indexOf(pUsedFunction) === -1) {
                                this._pUsedFunctionListV.push(pUsedFunction);
                            }
                        }
                    }
                    var pVertexOut = pVertex.getReturnType().getBaseType();
                    if (pVertexOut.isComplex()) {
                        this._pVertexOutType = this._pVertexOutType.blend(pVertexOut, akra.EAFXBlendMode.k_VertexOut);
                    }
                    this._pPassFunctionListV.push(pVertex);
                }
                if (!((pPixel) === null)) {
                    this._hasEmptyPixel = false;
                    //blend system data
                    this._pExtSystemDataP.addFromFunction(pPixel);
                    //blend foreigns
                    pForeignMap = pPixel._getForeignVariableMap();
                    pForeignKeys = pPixel._getForeignVariableKeys();
                    if (!((pForeignKeys) === null)) {
                        for(var i = 0; i < pForeignKeys.length; i++) {
                            pForeign = pForeignMap[pForeignKeys[i]];
                            if (!this._pForeignContainerP.addVariable(pForeign, akra.EAFXBlendMode.k_Foreign)) {
 {
                                    akra.logger.setSourceLocation("fx/PassBlend.ts", 414);
                                    akra.logger.error("Could not add foreign variable");
                                }
                                ;
                                return false;
                            }
                        }
                    }
                    //blend globals
                    pGlobalMap = pPixel._getGlobalVariableMap();
                    pGlobalKeys = pPixel._getGlobalVariableKeys();
                    if (!((pGlobalKeys) === null)) {
                        for(var i = 0; i < pGlobalKeys.length; i++) {
                            pGlobal = pGlobalMap[pGlobalKeys[i]];
                            if (!this._pGlobalContainerP.addVariable(pGlobal, akra.EAFXBlendMode.k_Global)) {
 {
                                    akra.logger.setSourceLocation("fx/PassBlend.ts", 429);
                                    akra.logger.error("Could not add global variable");
                                }
                                ;
                                return false;
                            }
                        }
                    }
                    //blend shareds
                    pSharedMap = pPixel._getSharedVariableMap();
                    pSharedKeys = pPixel._getSharedVariableKeys();
                    if (!((pSharedKeys) === null)) {
                        for(var i = 0; i < pSharedKeys.length; i++) {
                            pShared = pSharedMap[pSharedKeys[i]];
                            if (!this._pSharedContainerP.addVariable(pShared, akra.EAFXBlendMode.k_Shared)) {
 {
                                    akra.logger.setSourceLocation("fx/PassBlend.ts", 444);
                                    akra.logger.error("Could not add shared variable");
                                }
                                ;
                                return false;
                            }
                        }
                    }
                    //TODO: blend uniforms
                    pUniformMap = pPixel._getUniformVariableMap();
                    pUniformKeys = pPixel._getUniformVariableKeys();
                    if (!((pUniformKeys) === null)) {
                        for(var i = 0; i < pUniformKeys.length; i++) {
                            pUniform = pUniformMap[pUniformKeys[i]];
                            if (((pUniform) === null)) {
                                continue;
                            }
                            if (!this._pUniformContainerP.addVariable(pUniform, akra.EAFXBlendMode.k_Uniform)) {
 {
                                    akra.logger.setSourceLocation("fx/PassBlend.ts", 463);
                                    akra.logger.error("Could not add uniform variable");
                                }
                                ;
                                return false;
                            }
                        }
                    }
                    //TODO: blend textures
                    pTextureMap = pPixel._getTextureVariableMap();
                    pTextureKeys = pPixel._getTextureVariableKeys();
                    if (!((pTextureKeys) === null)) {
                        for(var i = 0; i < pTextureKeys.length; i++) {
                            pTexture = pTextureMap[pTextureKeys[i]];
                            if (((pTexture) === null)) {
                                continue;
                            }
                            this._pTextureMapP[pTexture.getRealName()] = true;
                        }
                    }
                    //TODO: blend varyings
                    pVaryingMap = pPixel._getVaryingVariableMap();
                    pVaryingKeys = pPixel._getVaryingVariableKeys();
                    if (!((pVaryingKeys) === null)) {
                        for(var i = 0; i < pVaryingKeys.length; i++) {
                            pVarying = pVaryingMap[pVaryingKeys[i]];
                            if (!this._pVaryingContainerP.addVariable(pVarying, akra.EAFXBlendMode.k_Varying)) {
 {
                                    akra.logger.setSourceLocation("fx/PassBlend.ts", 494);
                                    akra.logger.error("Could not add varying variable");
                                }
                                ;
                                return false;
                            }
                        }
                    }
                    //blend used type
                    pComplexTypeMap = pPixel._getUsedComplexTypeMap();
                    pComplexTypeKeys = pPixel._getUsedComplexTypeKeys();
                    if (!((pComplexTypeKeys) === null)) {
                        for(var i = 0; i < pComplexTypeKeys.length; i++) {
                            pComplexType = pComplexTypeMap[pComplexTypeKeys[i]];
                            if (!this._pComplexTypeContainerP.addComplexType(pComplexType)) {
 {
                                    akra.logger.setSourceLocation("fx/PassBlend.ts", 509);
                                    akra.logger.error("Could not add type declaration");
                                }
                                ;
                                return false;
                            }
                        }
                    }
                    //blend used functions
                    pUsedFunctionList = pPixel._getUsedFunctionList();
                    if (!((pUsedFunctionList) === null)) {
                        for(var i = 0; i < pUsedFunctionList.length; i++) {
                            pUsedFunction = pUsedFunctionList[i];
                            if (this._pUsedFunctionListP.indexOf(pUsedFunction) === -1) {
                                this._pUsedFunctionListP.push(pUsedFunction);
                            }
                        }
                    }
                    this._pPassFunctionListP.push(pPixel);
                }
                return true;
            };
            PassBlend.prototype.finalizeBlendForVertex = function () {
                if (this._hasEmptyVertex) {
                    return true;
                }
                if (!this.finalizeComplexTypeForShader(akra.EFunctionType.k_Vertex)) {
                    return false;
                }
                this._pAttributeContainerV.finalize();
                this._pAttributeContainerV.generateOffsetMap();
                return true;
            };
            PassBlend.prototype.finalizeBlendForPixel = function () {
                if (this._hasEmptyPixel) {
                    return true;
                }
                if (!this.finalizeComplexTypeForShader(akra.EFunctionType.k_Pixel)) {
                    return false;
                }
                return true;
            };
            PassBlend.prototype.enableVaringPrefixes = function (eType, bEnabled) {
                var pVars = null;
                if (eType === akra.EFunctionType.k_Vertex) {
                    pVars = this._pVaryingContainerV;
                } else {
                    pVars = this._pVaryingContainerP;
                }
                var pKeys = (pVars._pVarKeys);
                for(var i = 0; i < pKeys.length; i++) {
                    var sName = pKeys[i];
                    var pVarList = (pVars._pVarListMap[(sName)]);
                    for(var j = 0; j < pVarList.length; j++) {
                        pVarList[j]._markAsVarying(bEnabled);
                    }
                }
            };
            PassBlend.prototype.finalizeComplexTypeForShader = function (eType) {
                var pTypeContainer = null;
                var pUniformContainer = null;
                var pGlobalContainer = null;
                var pSharedContainer = null;
                var pUsedFunctions = null;
                var pAttributeContainer = null;
                if (eType === akra.EFunctionType.k_Vertex) {
                    pTypeContainer = this._pComplexTypeContainerV;
                    pUniformContainer = this._pUniformContainerV;
                    pGlobalContainer = this._pGlobalContainerV;
                    pSharedContainer = this._pSharedContainerV;
                    pUsedFunctions = this._pUsedFunctionListV;
                    pAttributeContainer = this._pAttributeContainerV;
                } else if (eType === akra.EFunctionType.k_Pixel) {
                    pTypeContainer = this._pComplexTypeContainerP;
                    pUniformContainer = this._pUniformContainerP;
                    pGlobalContainer = this._pGlobalContainerP;
                    pSharedContainer = this._pSharedContainerP;
                    pUsedFunctions = this._pUsedFunctionListP;
                }
                if (!pTypeContainer.addFromVarConatiner(pUniformContainer) || !pTypeContainer.addFromVarConatiner(pGlobalContainer) || !pTypeContainer.addFromVarConatiner(pSharedContainer) || !pTypeContainer.addFromVarConatiner(pAttributeContainer)) {
                    return false;
                }
                // if(eType === EFunctionType.k_Vertex){
                // 	pTypeContainer.addComplexType(this._pVertexOutType);
                // }
                for(var i = 0; i < pUsedFunctions.length; i++) {
                    var pReturnBaseType = pUsedFunctions[i].getReturnType().getBaseType();
                    if (pReturnBaseType.isComplex()) {
                        if (!pTypeContainer.addComplexType(pReturnBaseType)) {
                            return false;
                        }
                    }
                }
                return true;
            };
            PassBlend.prototype.hasUniform = /** @inline */function (pVar) {
                return ((this)._pUniformContainerV.hasVariableWithName((pVar.getRealName())) || (this)._pUniformContainerP.hasVariableWithName((pVar.getRealName())));
            };
            PassBlend.prototype.hasUniformWithName = /** @inline */function (sName) {
                return this._pUniformContainerV.hasVariableWithName(sName) || this._pUniformContainerP.hasVariableWithName(sName);
            };
            PassBlend.prototype.getUniformByName = /** @inline */function (sName) {
                return ((this._pUniformContainerV).hasVariableWithName((sName)) ? (this._pUniformContainerV)._pVarListMap[(sName)][0] : null) || ((this._pUniformContainerP).hasVariableWithName((sName)) ? (this._pUniformContainerP)._pVarListMap[(sName)][0] : null);
            };
            PassBlend.prototype.prepareForeigns = function (pPassInput) {
                var pForeignValues = pPassInput.foreigns;
                var sHash = "";
                var pKeys = ((this._pForeignContainerV)._pVarKeys);
                for(var i = 0; i < pKeys.length; i++) {
                    var sName = pKeys[i];
                    if (!((pForeignValues[sName]) !== undefined)) {
 {
                            akra.logger.setSourceLocation("fx/PassBlend.ts", 655);
                            akra.logger.log("V", sName, pForeignValues, pKeys, this);
                        }
                        ;
                    }
                    sHash += pForeignValues[sName].toString() + "%";
                }
                pKeys = ((this._pForeignContainerP)._pVarKeys);
                for(var i = 0; i < pKeys.length; i++) {
                    var sName = pKeys[i];
                    if (!((pForeignValues[sName]) !== undefined)) {
 {
                            akra.logger.setSourceLocation("fx/PassBlend.ts", 665);
                            akra.logger.log("P", sName, pForeignValues, pKeys, this);
                        }
                        ;
                    }
                    sHash += pForeignValues[sName].toString() + "%";
                }
                return sHash;
            };
            PassBlend.prototype.prepareSamplers = function (pPassInput) {
                var pBlender = this._pDefaultSamplerBlender;
                //Gum samplers
                var pSamplers = pPassInput.samplers;
                var pSamplersId = this._pSamplerIdList;
                for(var i = 0; i < pSamplersId.length; i++) {
                    var pSampler = this._pSamplerByIdMap[pSamplersId[i]];
                    var sName = pSampler.getRealName();
                    var pSamplerState = pSamplers[sName];
                    var pTexture = pPassInput._getTextureForSamplerState(pSamplerState);
                    if (((pTexture) === null)) {
                        (/*not inlined, because supportes only single statement functions(cur. st. count: 4)*/pBlender._pSlotList[pBlender._pIdToSlotMap[(0)]].push((pSampler)));
                    } else {
                        pBlender.addTextureSlot(pTexture.getGuid());
                        (/*not inlined, because supportes only single statement functions(cur. st. count: 4)*/pBlender._pSlotList[pBlender._pIdToSlotMap[(pTexture.getGuid())]].push((pSampler)));
                    }
                }
                //Gum sampler arrays
                var pSamplerArrays = pPassInput.samplerArrays;
                var pSamplerArraysId = this._pSamplerArrayIdList;
                for(var i = 0; i < pSamplerArraysId.length; i++) {
                    var pSamplerArray = this._pSamplerArrayByIdMap[pSamplerArraysId[i]];
                    var sName = pSamplerArray.getRealName();
                    var pSamplerStateList = pSamplerArrays[sName];
                    var isNeedToCollapse = true;
                    var pTexture = null;
                    var iLength = pPassInput.samplerArrayLength[sName];
                    for(var j = 0; j < iLength; j++) {
                        if (j === 0) {
                            pTexture = pPassInput._getTextureForSamplerState(pSamplerStateList[j]);
                        } else {
                            if (pTexture !== pPassInput._getTextureForSamplerState(pSamplerStateList[j])) {
                                isNeedToCollapse = false;
                            }
                        }
                    }
                    if (isNeedToCollapse) {
                        pSamplerArray._setCollapsed(true);
                        if (((pTexture) === null)) {
                            (/*not inlined, because supportes only single statement functions(cur. st. count: 4)*/pBlender._pSlotList[pBlender._pIdToSlotMap[(0)]].push((pSamplerArray)));
                        } else {
                            pBlender.addTextureSlot(pTexture.getGuid());
                            (/*not inlined, because supportes only single statement functions(cur. st. count: 4)*/pBlender._pSlotList[pBlender._pIdToSlotMap[(pTexture.getGuid())]].push((pSamplerArray)));
                        }
                    } else {
                        pSamplerArray._setCollapsed(false);
                    }
                }
                return pBlender.getHash();
            };
            PassBlend.prototype.prepareSurfaceMaterial = /** @inline */function (pMaterial) {
                return ((pMaterial) === null) ? "" : pMaterial._getHash();
            };
            PassBlend.prototype.prepareBufferMap = function (pMap) {
                this._pAttributeContainerV.initFromBufferMap(pMap);
                return ((this._pAttributeContainerV)._sHash);
            };
            PassBlend.prototype.swapTexcoords = /** @inline */function (pMaterial) {
                this._pTexcoordSwapper.generateSwapCode(pMaterial, this._pAttributeContainerV);
            };
            PassBlend.prototype.isSamplerUsedInShader = function (pSampler, eType) {
                return (eType === akra.EFunctionType.k_Vertex && ((this._pUniformContainerV).hasVariableWithName((pSampler).getRealName()))) || (eType === akra.EFunctionType.k_Pixel && ((this._pUniformContainerP).hasVariableWithName((pSampler).getRealName())));
            };
            PassBlend.prototype.applyForeigns = function (pPassInput) {
                var pForeignValues = pPassInput.foreigns;
                var pKeys = pPassInput.foreignKeys;
                var pForeignsV = this._pForeignContainerV;
                var pForeignsP = this._pForeignContainerP;
                for(var i = 0; i < pKeys.length; i++) {
                    var sName = pKeys[i];
                    var pVarList = null;
                    if (pForeignsV.hasVariableWithName(sName)) {
                        pVarList = (pForeignsV._pVarListMap[(sName)]);
                        for(var j = 0; j < pVarList.length; j++) {
                            pVarList[j].setValue(pForeignValues[sName] || 1);
                        }
                    }
                    if (pForeignsP.hasVariableWithName(sName)) {
                        pVarList = (pForeignsP._pVarListMap[(sName)]);
                        for(var j = 0; j < pVarList.length; j++) {
                            pVarList[j].setValue(pForeignValues[sName] || 1);
                        }
                    }
                }
            };
            PassBlend.prototype.resetForeigns = function () {
                var pForeignsV = this._pForeignContainerV;
                var pForeignsP = this._pForeignContainerP;
                var pKeys = (pForeignsV._pVarKeys);
                for(var i = 0; i < pKeys.length; i++) {
                    var sName = pKeys[i];
                    var pVarList = null;
                    pVarList = (pForeignsV._pVarListMap[(sName)]);
                    for(var j = 0; j < pVarList.length; j++) {
                        pVarList[j].setRealName(sName);
                    }
                }
                var pKeys = (pForeignsP._pVarKeys);
                for(var i = 0; i < pKeys.length; i++) {
                    var sName = pKeys[i];
                    var pVarList = null;
                    pVarList = (pForeignsP._pVarListMap[(sName)]);
                    for(var j = 0; j < pVarList.length; j++) {
                        pVarList[j].setRealName(sName);
                    }
                }
            };
            PassBlend.prototype.generateShaderCode = /** @inline */function () {
                this.clearCodeFragments();
                this.reduceSamplers();
                this.reduceAttributes();
                this._sVertexCode = this.generateCodeForVertex();
                this._sPixelCode = this.generateCodeForPixel();
                this.resetSamplerVarsToDefault();
            };
            PassBlend.prototype.generateCodeForVertex = function () {
                var sCode = "";
                var eType = akra.EFunctionType.k_Vertex;
                sCode = this.generateSystemExtBlock(eType) + "\n" + this.generateTypeDels(eType) + "\n" + this.generateFunctionDefenitions(eType) + "\n" + this.generateSharedVars(eType) + "\n" + this.generateVertexOut() + "\n";
                this.enableVaringPrefixes(eType, true);
                sCode += this.generateVaryings(eType) + "\n";
                this.enableVaringPrefixes(eType, false);
                sCode += this.generateUniformSamplers(eType) + "\n" + this.generateUniformVars(eType) + "\n" + ((this)._sAttrBufferDeclCode) + "\n" + this.generateGlobalVars(eType) + "\n" + this.generateFunctions(eType) + "\n" + ((this)._sAttrDeclCode) + "\n" + ((this)._sAFXAttrDeclCode) + "\n" + this.generatePassFunctions(eType) + "\n" + "void main() {\n" + ((this)._sAttrBufferInitCode) + "\n" + ((this)._sAFXAttrInitCode) + "\n" + ((((this)._pTexcoordSwapper)._sTexToTmpCode) + "\n" + (((this)._pTexcoordSwapper)._sTmpToTexCode)) + "\n" + /*not inlined, because supportes only single statement functions(cur. st. count: 7)*/this.generatePassFunctionCall(eType) + "\n" + this.generateVertexOutToVaryings() + "\n" + "}";
                return sCode;
            };
            PassBlend.prototype.generateCodeForPixel = function () {
                if (this._hasEmptyPixel) {
                    return "void main(){}";
                }
                var sCode = "";
                var eType = akra.EFunctionType.k_Pixel;
                this.enableVaringPrefixes(eType, true);
                /*"#define while(expr) for(int _i = 0; _i < 1; _i--) if(!(expr)) break; else" + "\n" +*/
                sCode = this.generateSystemExtBlock(eType) + "\n" + "vec4 resultAFXColor;" + "\n" + this.generateTypeDels(eType) + "\n" + this.generateFunctionDefenitions(eType) + "\n" + this.generateSharedVars(eType) + "\n" + this.generateVaryings(eType) + "\n" + this.generateUniformSamplers(eType) + "\n" + this.generateUniformVars(eType) + "\n" + this.generateGlobalVars(eType) + "\n" + this.generateFunctions(eType) + "\n" + this.generatePassFunctions(eType) + "\n" + "void main() {\n" + /*not inlined, because supportes only single statement functions(cur. st. count: 7)*/this.generatePassFunctionCall(eType) + "\n" + "gl_FragColor = resultAFXColor;" + "\n" + "}";
                this.enableVaringPrefixes(eType, false);
                return sCode;
            };
            PassBlend.prototype.clearCodeFragments = function () {
                this._sUniformSamplerCodeV = "";
                this._sAttrBufferDeclCode = "";
                this._sAttrDeclCode = "";
                this._sAFXAttrDeclCode = "";
                this._sAttrBufferInitCode = "";
                this._sAFXAttrInitCode = "";
                this._sUniformSamplerCodeP = "";
            };
            PassBlend.prototype.reduceSamplers = function () {
                var pSamplerBlender = this._pDefaultSamplerBlender;
                var iTotalSlots = (pSamplerBlender._nActiveSlots);
                var sUniformSamplerCodeV = "";
                var sUniformSamplerCodeP = "";
                var isZeroSampler2DV = false;
                var isZeroSamplerCubeV = false;
                var isZeroSampler2DP = false;
                var isZeroSamplerCubeP = false;
                var isInVertex = false;
                var isInPixel = false;
                var sSamplerName = "";
                for(var i = 0; i < iTotalSlots; i++) {
                    var pSamplers = (((pSamplerBlender)._pSlotList)[(i)]);
                    isInVertex = false;
                    isInPixel = false;
                    sSamplerName = "as" + i.toString();
                    for(var j = 0; j < (pSamplers._iLength); j++) {
                        var pSampler = (pSamplers._pData[(j)]);
                        var sRealSamplerName = pSampler.getRealName();
                        if (i === 0) {
                            if (this.isSamplerUsedInShader(pSampler, akra.EFunctionType.k_Vertex)) {
                                this._pUniformContainerV.forEach(sRealSamplerName, PassBlend.fnSamplerReducer);
                                if (pSampler.getType().isSampler2D()) {
                                    isZeroSampler2DV = true;
                                } else {
                                    isZeroSamplerCubeV = true;
                                    sSamplerName = "asc0";
                                }
                            }
                            if (this.isSamplerUsedInShader(pSampler, akra.EFunctionType.k_Pixel)) {
                                this._pUniformContainerP.forEach(sRealSamplerName, PassBlend.fnSamplerReducer);
                                if (pSampler.getType().isSampler2D()) {
                                    isZeroSampler2DP = true;
                                } else {
                                    isZeroSamplerCubeP = true;
                                    sSamplerName = "asc0";
                                }
                            }
                        } else {
                            if (this.isSamplerUsedInShader(pSampler, akra.EFunctionType.k_Vertex)) {
                                isInVertex = true;
                            }
                            if (this.isSamplerUsedInShader(pSampler, akra.EFunctionType.k_Pixel)) {
                                isInPixel = true;
                            }
                        }
                        this._pUniformContainerV.setNameForEach(sRealSamplerName, sSamplerName);
                        this._pUniformContainerP.setNameForEach(sRealSamplerName, sSamplerName);
                    }
                    if (i === 0) {
                        if (isZeroSampler2DV) {
                            sUniformSamplerCodeV += "uniform sampler2D as0;";
                        }
                        if (isZeroSamplerCubeV) {
                            sUniformSamplerCodeV += "uniform samplerCube asc0;";
                        }
                        if (isZeroSampler2DP) {
                            sUniformSamplerCodeP += "uniform sampler2D as0;";
                        }
                        if (isZeroSamplerCubeP) {
                            sUniformSamplerCodeP += "uniform samplerCube asc0;";
                        }
                    } else {
                        if (isInVertex) {
                            sUniformSamplerCodeV += "uniform " + (pSamplers._pData[(0)]).getType().getBaseType().getRealName() + " " + sSamplerName + ";";
                        }
                        if (isInPixel) {
                            sUniformSamplerCodeP += "uniform " + (pSamplers._pData[(0)]).getType().getBaseType().getRealName() + " " + sSamplerName + ";";
                        }
                    }
                }
                this._sUniformSamplerCodeV = sUniformSamplerCodeV;
                this._sUniformSamplerCodeP = sUniformSamplerCodeP;
            };
            PassBlend.prototype.resetSamplerVarsToDefault = function () {
                var pSamplerBlender = this._pDefaultSamplerBlender;
                var iTotalSlots = (pSamplerBlender._nActiveSlots);
                pSamplerBlender.clearSamplerNames();
                for(var i = 0; i < iTotalSlots; i++) {
                    var pSamplers = (((pSamplerBlender)._pSlotList)[(i)]);
                    for(var j = 0; j < (pSamplers._iLength); j++) {
                        var pSampler = (pSamplers._pData[(j)]);
                        var sRealSamplerName = pSampler.getRealName();
                        this._pUniformContainerV.forEach(sRealSamplerName, PassBlend.fnResetDefaultSamplerParams);
                    }
                }
            };
            PassBlend.fnSamplerReducer = function fnSamplerReducer(pSamplerVar) {
                pSamplerVar.defineByZero(true);
            };
            PassBlend.fnResetDefaultSamplerParams = function fnResetDefaultSamplerParams(pSamplerVar) {
                pSamplerVar.defineByZero(false);
                pSamplerVar.setRealName(pSamplerVar.getSemantic() || pSamplerVar.getName());
            };
            PassBlend.prototype.reduceAttributes = function () {
                var pAttributeContainer = this._pAttributeContainerV;
                var pSemantics = (((pAttributeContainer)._pVarKeys));
                var nPreparedBufferSlots = -1;
                var nPreparedAttributeSlots = -1;
                for(var i = 0; i < pSemantics.length; i++) {
                    var sSemantic = pSemantics[i];
                    // var pFlow: IDataFlow = pAttributeContainer.getFlowBySemantic(sSemantic);
                    var pAttributes = (((pAttributeContainer)._pVarListMap[((sSemantic))]));
                    var iBufferSlot = -1;
                    var iSlot = (pAttributeContainer._pSlotBySemanticIndex[((pAttributeContainer)._pKeyToIndexMap[((sSemantic))])]);
                    var sAttrName = "";
                    //1) set buffer maps for shader attribures
                    if (iSlot === -1) {
                        for(var j = 0; j < pAttributes.length; j++) {
                            if (pAttributes[j].getType().isStrictPointer()) {
                                pAttributes[j].getType().getVideoBuffer().defineByZero(true);
                            }
                        }
                    } else {
                        //iSlot = pAttributeContainer.getSlotBySemantic(sSemantic);
                        iBufferSlot = (pAttributeContainer._pBufferSlotBySlots[((pAttributeContainer)._pSlotBySemanticIndex[(((pAttributeContainer))._pKeyToIndexMap[(((sSemantic)))])])]);
                        sAttrName = "aa" + iSlot.toString();
                        if (iBufferSlot >= 0) {
                            var sSamplerBufferName = "abs" + iBufferSlot.toString();
                            var sHeaderBufferName = "abh" + iBufferSlot.toString();
                            var pBufferVar = null;
                            for(var j = 0; j < pAttributes.length; j++) {
                                pBufferVar = pAttributes[j].getType().getVideoBuffer();
                                pBufferVar.setVideoBufferRealName(sSamplerBufferName, sHeaderBufferName);
                            }
                            if (iBufferSlot > nPreparedBufferSlots) {
                                var pBufferVar = pAttributes[0].getType().getVideoBuffer();
                                this._sAttrBufferDeclCode = pBufferVar.toFinalCode() + ";\n";
                                this._sAttrBufferInitCode = pBufferVar._getVideoBufferInitExpr().toFinalCode() + ";\n";
                                nPreparedBufferSlots++;
                            }
                        }
                        //2) gnerate real attrs
                        if (iSlot > nPreparedAttributeSlots) {
                            this._sAttrDeclCode += "attribute " + (pAttributeContainer._pIsPointerBySlot[((pAttributeContainer)._pSlotBySemanticIndex[(((pAttributeContainer))._pKeyToIndexMap[(((sSemantic)))])])] ? /*checked (origin: fx)>>*/akra.fx.Effect.getSystemType("ptr") : ((((pAttributeContainer))._pVarBlendTypeMap[(((sSemantic)))])).getBaseType()).toFinalCode() + " " + sAttrName + ";\n";
                            nPreparedAttributeSlots++;
                        }
                    }
                    // 3) add afx attributes
                    var pAttribute = (((pAttributeContainer).hasVariableWithName(((sSemantic))) ? (pAttributeContainer)._pVarListMap[((sSemantic))][0] : null));
                    var pAttributeType = pAttribute.getType();
                    this._sAFXAttrDeclCode += pAttribute.toFinalCode() + ";\n";
                    if (pAttributeType.isStrictPointer() || (pAttributeType.isPointer() && iBufferSlot >= 0)) {
                        var pAttrSubDecls = pAttribute.getSubVarDecls();
                        for(var j = 0; j < pAttrSubDecls.length; j++) {
                            this._sAFXAttrDeclCode += pAttrSubDecls[j].toFinalCode() + ";\n";
                        }
                    }
                    if (iSlot >= 0) {
                        if (iBufferSlot >= 0) {
                            this._sAFXAttrInitCode += pAttributeType._getMainPointer().getRealName() + "=" + sAttrName + ";";
                            this._sAFXAttrInitCode += pAttribute._getAttrExtractionBlock().toFinalCode();
                        } else {
                            this._sAFXAttrInitCode += pAttribute.getRealName() + "=" + sAttrName + ";";
                        }
                    }
                }
            };
            PassBlend.prototype.generateSystemExtBlock = function (eType) {
                var pExtBlock = null;
                if (eType === akra.EFunctionType.k_Vertex) {
                    pExtBlock = this._pExtSystemDataV;
                    if (this._sSystemExtBlockCodeV !== "") {
                        return this._sSystemExtBlockCodeV;
                    }
                } else {
                    pExtBlock = this._pExtSystemDataP;
                    if (this._sSystemExtBlockCodeP !== "") {
                        return this._sSystemExtBlockCodeP;
                    }
                }
                var sCode = "";
                var pMacroses = (pExtBlock._pExtSystemMacrosList);
                var pTypes = (pExtBlock._pExtSystemTypeList);
                var pFunctions = (pExtBlock._pExtSystemFunctionList);
                for(var i = 0; i < pMacroses.length; i++) {
                    sCode += pMacroses[i].toFinalCode() + "\n";
                }
                for(var i = 0; i < pTypes.length; i++) {
                    sCode += pTypes[i].toFinalCode() + "\n";
                }
                for(var i = 0; i < pFunctions.length; i++) {
                    sCode += pFunctions[i].toFinalCode() + "\n";
                }
                if (eType === akra.EFunctionType.k_Vertex) {
                    this._sSystemExtBlockCodeV = sCode;
                } else {
                    sCode = "#define AKRA_FRAGMENT 1\n" + "#ifdef GL_ES\nprecision highp float;\n#endif\n" + "#extension GL_OES_standard_derivatives : enable\n";
                    sCode;
                    this._sSystemExtBlockCodeP = sCode;
                }
                return sCode;
            };
            PassBlend.prototype.generateTypeDels = function (eType) {
                var pTypeBlock = null;
                if (eType === akra.EFunctionType.k_Vertex) {
                    pTypeBlock = this._pComplexTypeContainerV;
                } else {
                    pTypeBlock = this._pComplexTypeContainerP;
                }
                var sCode = "";
                var pKeys = (pTypeBlock._pTypeKeys);
                var pTypes = (pTypeBlock._pTypeListMap);
                for(var i = 0; i < pKeys.length; i++) {
                    sCode += pTypes[pKeys[i]]._toDeclString() + ";\n";
                }
                return sCode;
            };
            PassBlend.prototype.generateFunctionDefenitions = function (eType) {
                var pFunctions = null;
                if (eType === akra.EFunctionType.k_Vertex) {
                    pFunctions = this._pUsedFunctionListV;
                    if (this._sFunctionDefCodeV !== "") {
                        return this._sFunctionDefCodeV;
                    }
                } else {
                    pFunctions = this._pUsedFunctionListP;
                    if (this._sFunctionDefCodeP !== "") {
                        return this._sFunctionDefCodeP;
                    }
                }
                var sCode = "";
                for(var i = 0; i < pFunctions.length; i++) {
                    sCode += pFunctions[i].toFinalDefCode() + ";\n";
                }
                if (eType === akra.EFunctionType.k_Vertex) {
                    this._sFunctionDefCodeV = sCode;
                } else {
                    this._sFunctionDefCodeP = sCode;
                }
                return sCode;
            };
            PassBlend.prototype.generateSharedVars = function (eType) {
                var pVars = null;
                if (eType === akra.EFunctionType.k_Vertex) {
                    pVars = this._pSharedContainerV;
                    if (this._sSharedVarCodeV !== "") {
                        return this._sSharedVarCodeV;
                    }
                } else {
                    pVars = this._pSharedContainerP;
                    if (this._sSharedVarCodeP !== "") {
                        return this._sSharedVarCodeP;
                    }
                }
                var sCode = "";
                var pKeys = (pVars._pVarKeys);
                for(var i = 0; i < pKeys.length; i++) {
                    sCode += /*not inlined, because supportes only single statement functions(cur. st. count: 8)*/pVars.getDeclCodeForVar(pKeys[i], true) + ";\n";
                }
                if (eType === akra.EFunctionType.k_Vertex) {
                    this._sSharedVarCodeV = sCode;
                } else {
                    this._sSharedVarCodeP = sCode;
                }
                return sCode;
            };
            PassBlend.prototype.generateVertexOut = function () {
                if (this._sVertexOutDeclCode === "") {
                    this._sVertexOutDeclCode = this._pVertexOutType._toDeclString() + " Out;\n";
                }
                return this._sVertexOutDeclCode;
            };
            PassBlend.prototype.generateVaryings = function (eType) {
                var pVars = null;
                if (eType === akra.EFunctionType.k_Vertex) {
                    pVars = this._pVaryingContainerV;
                    if (this._sVaryingDeclCodeV !== "") {
                        return this._sVaryingDeclCodeV;
                    }
                } else {
                    pVars = this._pVaryingContainerP;
                    if (this._sVaryingDeclCodeP !== "") {
                        return this._sVaryingDeclCodeP;
                    }
                }
                var sCode = "";
                var pKeys = (pVars._pVarKeys);
                for(var i = 0; i < pKeys.length; i++) {
                    sCode += "varying " + /*not inlined, because supportes only single statement functions(cur. st. count: 8)*/pVars.getDeclCodeForVar(pKeys[i], false) + ";\n";
                }
                if (eType === akra.EFunctionType.k_Vertex) {
                    this._sVaryingDeclCodeV = sCode;
                } else {
                    this._sVaryingDeclCodeP = sCode;
                }
                return sCode;
            };
            PassBlend.prototype.generateUniformSamplers = function (eType) {
                if (eType === akra.EFunctionType.k_Vertex) {
                    return this._sUniformSamplerCodeV;
                } else {
                    return this._sUniformSamplerCodeP;
                }
            };
            PassBlend.prototype.generateUniformVars = function (eType) {
                var pVars = null;
                if (eType === akra.EFunctionType.k_Vertex) {
                    pVars = this._pUniformContainerV;
                } else {
                    pVars = this._pUniformContainerP;
                }
                var sCode = "";
                var pKeys = (pVars._pVarKeys);
                for(var i = 0; i < pKeys.length; i++) {
                    var pVar = (pVars.hasVariableWithName((pKeys[i])) ? pVars._pVarListMap[(pKeys[i])][0] : null);
                    var pType = (pVars._pVarBlendTypeMap[(pKeys[i])]);
                    if (pType.isSampler() && (!pType.isArray() || pVar.isDefinedByZero() || pVar._isCollapsed())) {
                        continue;
                    }
                    sCode += "uniform " + /*not inlined, because supportes only single statement functions(cur. st. count: 8)*/pVars.getDeclCodeForVar(pKeys[i], false) + ";\n";
                }
                return sCode;
            };
            PassBlend.prototype.generateAttrBuffers = /** @inline */function () {
                return this._sAttrBufferDeclCode;
            };
            PassBlend.prototype.generateGlobalVars = function (eType) {
                var pVars = null;
                if (eType === akra.EFunctionType.k_Vertex) {
                    pVars = this._pGlobalContainerV;
                } else {
                    pVars = this._pGlobalContainerP;
                }
                var sCode = "";
                var pKeys = (pVars._pVarKeys);
                for(var i = 0; i < pKeys.length; i++) {
                    sCode += /*not inlined, because supportes only single statement functions(cur. st. count: 8)*/pVars.getDeclCodeForVar(pKeys[i], true) + ";\n";
                }
                return sCode;
            };
            PassBlend.prototype.generateFunctions = function (eType) {
                var pFunctions = null;
                if (eType === akra.EFunctionType.k_Vertex) {
                    pFunctions = this._pUsedFunctionListV;
                } else {
                    pFunctions = this._pUsedFunctionListP;
                }
                var sCode = "";
                for(var i = 0; i < pFunctions.length; i++) {
                    sCode += pFunctions[i].toFinalCode() + "\n";
                }
                return sCode;
            };
            PassBlend.prototype.generatePassFunctions = function (eType) {
                var pFunctions = null;
                if (eType === akra.EFunctionType.k_Vertex) {
                    pFunctions = this._pPassFunctionListV;
                } else {
                    pFunctions = this._pPassFunctionListP;
                }
                var sCode = "";
                for(var i = 0; i < pFunctions.length; i++) {
                    sCode += pFunctions[i].toFinalCode() + "\n";
                }
                return sCode;
            };
            PassBlend.prototype.generateRealAttrs = /** @inline */function () {
                return this._sAttrDeclCode;
            };
            PassBlend.prototype.generateAFXAttrs = /** @inline */function () {
                return this._sAFXAttrDeclCode;
            };
            PassBlend.prototype.generateAttrBufferInit = /** @inline */function () {
                return this._sAttrBufferInitCode;
            };
            PassBlend.prototype.generateAFXAttrInit = /** @inline */function () {
                return this._sAFXAttrInitCode;
            };
            PassBlend.prototype.generateTexcoordSwap = /** @inline */function () {
                return ((this._pTexcoordSwapper)._sTexToTmpCode) + "\n" + ((this._pTexcoordSwapper)._sTmpToTexCode);
            };
            PassBlend.prototype.generatePassFunctionCall = /** @inline */function (eType) {
                var pFunctions = null;
                if (eType === akra.EFunctionType.k_Vertex) {
                    pFunctions = this._pPassFunctionListV;
                    if (this._sPassFunctionCallCodeV !== "") {
                        return this._sPassFunctionCallCodeV;
                    }
                } else {
                    pFunctions = this._pPassFunctionListP;
                    if (this._sPassFunctionCallCodeP !== "") {
                        return this._sPassFunctionCallCodeP;
                    }
                }
                var sCode = "";
                for(var i = 0; i < pFunctions.length; i++) {
                    sCode += pFunctions[i].getRealName() + "();\n";
                }
                if (eType === akra.EFunctionType.k_Vertex) {
                    this._sPassFunctionCallCodeV = sCode;
                } else {
                    this._sPassFunctionCallCodeP = sCode;
                }
                return sCode;
            };
            PassBlend.prototype.generateVertexOutToVaryings = function () {
                if (this._sVertexOutToVaryingCode !== "") {
                    return this._sVertexOutToVaryingCode;
                }
                var pVars = this._pVaryingContainerV;
                var pKeys = (pVars._pVarKeys);
                var sCode = "";
                sCode += "gl_Position=Out.POSITION;\ngl_PointSize=Out.PSIZE;\n";
                for(var i = 0; i < pKeys.length; i++) {
                    var sName = pKeys[i];
                    if (sName !== "POSITION" && sName !== "PSIZE") {
                        sCode += "V_" + sName + "=" + "Out." + sName + ";\n";
                    }
                }
                this._sVertexOutToVaryingCode = sCode;
                return this._sVertexOutToVaryingCode;
            };
            PassBlend.prototype.prepareFastObjects = function () {
                this.prepareFastSamplers(akra.EFunctionType.k_Vertex);
                this.prepareFastSamplers(akra.EFunctionType.k_Pixel);
            };
            PassBlend.prototype.prepareFastSamplers = function (eType) {
                if (((this._pSamplerByIdMap) === null)) {
                    this._pSamplerByIdMap = {};
                    this._pSamplerIdList = [];
                    this._pSamplerArrayByIdMap = {};
                    this._pSamplerArrayIdList = [];
                }
                var pContainer = eType === akra.EFunctionType.k_Vertex ? this._pUniformContainerV : this._pUniformContainerP;
                var pKeys = (pContainer._pVarKeys);
                for(var i = 0; i < pKeys.length; i++) {
                    var pVar = (pContainer.hasVariableWithName((pKeys[i])) ? pContainer._pVarListMap[(pKeys[i])][0] : null);
                    if (pVar.getType().isSampler()) {
                        var id = pVar._getInstructionID();
                        if (!pVar.getType().isArray() && !((this._pSamplerByIdMap[id]) !== undefined)) {
                            this._pSamplerByIdMap[id] = pVar;
                            this._pSamplerIdList.push(id);
                        } else if (pVar.getType().isArray() && !((this._pSamplerArrayByIdMap[id]) !== undefined)) {
                            this._pSamplerArrayByIdMap[id] = pVar;
                            this._pSamplerArrayIdList.push(id);
                        }
                    }
                }
            };
            return PassBlend;
        })();
        fx.PassBlend = PassBlend;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        var ComponentBlend = (function () {
            function ComponentBlend(pComposer) {
                /**@protected*/ this._iGuid = akra.sid();
                this._pComposer = null;
                this._isReady = false;
                this._sHash = "";
                this._bNeedToUpdateHash = false;
                this._pComponentHashMap = null;
                this._pComponentList = null;
                this._pComponentShiftList = null;
                this._pComponentPassIdList = null;
                this._iShiftMin = 0;
                this._iShiftMax = 0;
                this._pPassesDList = null;
                this._pComponentInputVarBlend = null;
                this._pComposer = pComposer;
                this._pComponentHashMap = {};
                this._pComponentList = [];
                this._pComponentShiftList = [];
                this._pComponentPassIdList = [];
            }
            ComponentBlend.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            ComponentBlend.prototype.isReadyToUse = /** @inline */function () {
                return this._isReady;
            };
            ComponentBlend.prototype.isEmpty = /** @inline */function () {
                return this._pComponentList.length === 0;
            };
            ComponentBlend.prototype.getComponentCount = /** @inline */function () {
                return this._pComponentList.length;
            };
            ComponentBlend.prototype.getTotalPasses = /** @inline */function () {
                return !((this._pPassesDList) === null) ? this._pPassesDList.length : 0;
            };
            ComponentBlend.prototype.getHash = function () {
                if (this._bNeedToUpdateHash) {
                    this._sHash = this.calcHash();
                    this._bNeedToUpdateHash = false;
                }
                return this._sHash;
            };
            ComponentBlend.prototype.containComponent = function (pComponent, iShift, iPass) {
                if (iShift !== 0xfffffe && iPass !== 0xfffffe) {
                    return (((this)._pComponentHashMap[(pComponent.getHash(iShift, iPass))]));
                } else {
                    for(var i = 0; i < this._pComponentList.length; i++) {
                        if (this._pComponentList[i] === pComponent) {
                            if (iShift === 0xfffffe && iPass === 0xfffffe) {
                                return true;
                            } else if (iShift === 0xfffffe && this._pComponentPassIdList[i] === iPass) {
                                return true;
                            } else if (iPass === 0xfffffe && this._pComponentShiftList[i] === iShift) {
                                return true;
                            }
                        }
                    }
                    return false;
                }
            };
            ComponentBlend.prototype.containComponentHash = /** @inline */function (sComponentHash) {
                return (this._pComponentHashMap[sComponentHash]);
            };
            ComponentBlend.prototype.addComponent = function (pComponent, iShift, iPass) {
                var sComponentHash = pComponent.getHash(iShift, iPass);
                var iPassCount = pComponent.getTotalPasses();
                if (iPass === 0xffffff) {
                    for(var i = 0; i < iPassCount; i++) {
                        this.addComponent(pComponent, iShift + i, i);
                    }
                    return;
                } else if (iPass < 0 || iPass >= iPassCount) {
                    return;
                }
                var sComponentHash = pComponent.getHash(iShift, iPass);
                if ((((this)._pComponentHashMap[(sComponentHash)]))) {
 {
                        akra.logger.setSourceLocation("fx/ComponentBlend.ts", 112);
                        akra.logger.warning("You try to add already used component '" + sComponentHash + "' in blend.");
                    }
                    ;
                    return;
                }
                if (iShift < this._iShiftMin) {
                    this._iShiftMin = iShift;
                }
                if (iShift > this._iShiftMax) {
                    this._iShiftMax = iShift;
                }
                this._pComponentHashMap[sComponentHash] = true;
                this._pComponentList.push(pComponent);
                this._pComponentShiftList.push(iShift);
                this._pComponentPassIdList.push(iPass);
                this._isReady = false;
                this._bNeedToUpdateHash = true;
            };
            ComponentBlend.prototype.removeComponent = function (pComponent, iShift, iPass) {
                var sComponentHash = pComponent.getHash(iShift, iPass);
                var iPassCount = pComponent.getTotalPasses();
                if (!(((this)._pComponentHashMap[(sComponentHash)]))) {
 {
                        akra.logger.setSourceLocation("fx/ComponentBlend.ts", 139);
                        akra.logger.warning("You try to remove not used component '" + sComponentHash + "' from blend.");
                    }
                    ;
                    return;
                }
                if (iPass === 0xffffff) {
                    for(var i = 0; i < iPassCount; i++) {
                        this.removeComponent(pComponent, iShift + i, i);
                    }
                    return;
                } else if (iPass < 0 || iPass >= iPassCount) {
                    return;
                }
                this._pComponentHashMap[sComponentHash] = false;
                for(var i = 0; i < this._pComponentList.length; i++) {
                    if (this._pComponentList[i] === pComponent && this._pComponentShiftList[i] === iShift && this._pComponentPassIdList[i] === iPass) {
                        this._pComponentList.splice(i, 1);
                        this._pComponentShiftList.splice(i, 1);
                        this._pComponentPassIdList.splice(i, 1);
                        break;
                    }
                }
                if (this._iShiftMin === iShift && this._iShiftMax === iShift) {
                    this._iShiftMax = 0;
                    this._iShiftMin = 0;
                    for(var i = 0; i < this._pComponentShiftList.length; i++) {
                        if (this._pComponentShiftList[i] < this._iShiftMin) {
                            this._iShiftMin = this._pComponentShiftList[i];
                        }
                        if (this._pComponentShiftList[i] > this._iShiftMax) {
                            this._iShiftMax = this._pComponentShiftList[i];
                        }
                    }
                }
                this._isReady = false;
                this._bNeedToUpdateHash = true;
            };
            ComponentBlend.prototype.finalizeBlend = function () {
                if (this._isReady) {
                    return true;
                }
                this._pPassesDList = [];
                this._pComponentInputVarBlend = [];
                for(var i = 0; i < this._pComponentList.length; i++) {
                    var pComponentTechnique = this._pComponentList[i].getTechnique();
                    var iShift = this._pComponentShiftList[i] - this._iShiftMin;
                    var iPass = this._pComponentPassIdList[i];
                    var pPass = pComponentTechnique.getPass(iPass);
                    if (!((this._pPassesDList[iShift]) !== undefined)) {
                        this._pPassesDList[iShift] = [];
                        this._pComponentInputVarBlend[iShift] = new ComponentPassInputBlend();
                    }
                    this._pPassesDList[iShift].push(pPass);
                    this._pComponentInputVarBlend[iShift].addDataFromPass(pPass);
                }
                for(var i = 0; i < this._pComponentInputVarBlend.length; i++) {
                    if (((this._pComponentInputVarBlend[i]) !== undefined)) {
                        this._pComponentInputVarBlend[i].finalizeInput();
                    } else {
                        this._pComponentInputVarBlend[i] = null;
                        this._pPassesDList[i] = null;
                    }
                }
                this._isReady = true;
                return true;
            };
            ComponentBlend.prototype.getPassInputForPass = function (iPass) {
                if (!this._isReady) {
                    return null;
                }
                if (iPass < 0 || iPass > (!(((this)._pPassesDList) === null) ? (this)._pPassesDList.length : 0) || ((this._pComponentInputVarBlend[iPass]) === null)) {
                    return null;
                }
                return this._pComponentInputVarBlend[iPass].getPassInput();
            };
            ComponentBlend.prototype.getPassListAtPass = function (iPass) {
                if (!this._isReady) {
                    return null;
                }
                if (iPass < 0 || iPass > (!(((this)._pPassesDList) === null) ? (this)._pPassesDList.length : 0)) {
                    return null;
                }
                return this._pPassesDList[iPass];
            };
            ComponentBlend.prototype.clone = function () {
                var pClone = new ComponentBlend(this._pComposer);
                pClone._setDataForClone(this._pComponentList, this._pComponentShiftList, this._pComponentPassIdList, this._pComponentHashMap, this._iShiftMin, this._iShiftMax);
                return pClone;
            };
            ComponentBlend.prototype._getComponentList = /** @inline */function () {
                return this._pComponentList;
            };
            ComponentBlend.prototype._getComponentShiftList = /** @inline */function () {
                return this._pComponentShiftList;
            };
            ComponentBlend.prototype._getComponentPassIdList = /** @inline */function () {
                return this._pComponentPassIdList;
            };
            ComponentBlend.prototype._setDataForClone = function (pComponentList, pComponentShiftList, pComponentPassNumnerList, pComponentHashMap, iShiftMin, iShiftMax) {
                for(var i = 0; i < pComponentList.length; i++) {
                    this._pComponentList.push(pComponentList[i]);
                    this._pComponentShiftList.push(pComponentShiftList[i]);
                    this._pComponentPassIdList.push(pComponentPassNumnerList[i]);
                    var sComponentHash = pComponentList[i].getHash(pComponentShiftList[i], pComponentPassNumnerList[i]);
                    this._pComponentHashMap[sComponentHash] = pComponentHashMap[sComponentHash];
                }
                this._iShiftMin = iShiftMin;
                this._iShiftMax = iShiftMax;
                this._bNeedToUpdateHash = true;
            };
            ComponentBlend.prototype.calcHash = function () {
                var sHash = "";
                if (((this)._pComponentList.length === 0)) {
                    return "EMPTY_BLEND";
                }
                for(var i = 0; i < this._pComponentList.length; i++) {
                    var sComponentHash = this._pComponentList[i].getHash(this._pComponentShiftList[i], this._pComponentPassIdList[i]);
                    sHash += sComponentHash + ":";
                }
                return sHash;
            };
            return ComponentBlend;
        })();
        fx.ComponentBlend = ComponentBlend;        
        var ComponentPassInputBlend = (function () {
            function ComponentPassInputBlend() {
                this._pUniformNameToRealMap = null;
                this._pUniformByRealNameMap = null;
                this._pUniformDefaultValueMap = null;
                this._pTextureNameToRealMap = null;
                this._pTextureByRealNameMap = null;
                this._pForeignByNameMap = null;
                this._pUniformRealNameList = null;
                this._pUniformNameList = null;
                this._pTextureRealNameList = null;
                this._pTextureNameList = null;
                this._pForeignNameList = null;
                this._pFreePassInputBlendList = null;
                this._pUniformNameToRealMap = {};
                this._pUniformByRealNameMap = {};
                this._pUniformDefaultValueMap = {};
                this._pTextureNameToRealMap = {};
                this._pTextureByRealNameMap = {
                    TEXTURE0: null,
                    TEXTURE1: null,
                    TEXTURE2: null,
                    TEXTURE3: null,
                    TEXTURE4: null,
                    TEXTURE5: null,
                    TEXTURE6: null,
                    TEXTURE7: null,
                    TEXTURE8: null,
                    TEXTURE9: null,
                    TEXTURE10: null,
                    TEXTURE11: null,
                    TEXTURE12: null,
                    TEXTURE13: null,
                    TEXTURE14: null,
                    TEXTURE15: null
                };
                this._pForeignByNameMap = {};
            }
            Object.defineProperty(ComponentPassInputBlend.prototype, "uniformNameToReal", {
                get: /** @inline */function () {
                    return this._pUniformNameToRealMap;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ComponentPassInputBlend.prototype, "uniformByRealName", {
                get: /** @inline */function () {
                    return this._pUniformByRealNameMap;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ComponentPassInputBlend.prototype, "uniformDefaultValue", {
                get: /** @inline */function () {
                    return this._pUniformDefaultValueMap;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ComponentPassInputBlend.prototype, "textureNameToReal", {
                get: /** @inline */function () {
                    return this._pTextureNameToRealMap;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ComponentPassInputBlend.prototype, "textureByRealName", {
                get: /** @inline */function () {
                    return this._pTextureByRealNameMap;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ComponentPassInputBlend.prototype, "foreignByName", {
                get: /** @inline */function () {
                    return this._pForeignByNameMap;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ComponentPassInputBlend.prototype, "uniformNameList", {
                get: /** @inline */function () {
                    return this._pUniformNameList;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ComponentPassInputBlend.prototype, "uniformRealNameList", {
                get: /** @inline */function () {
                    return this._pUniformRealNameList;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ComponentPassInputBlend.prototype, "textureNameList", {
                get: /** @inline */function () {
                    return this._pTextureNameList;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ComponentPassInputBlend.prototype, "textureRealNameList", {
                get: /** @inline */function () {
                    return this._pTextureRealNameList;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ComponentPassInputBlend.prototype, "foreignNameList", {
                get: /** @inline */function () {
                    return this._pForeignNameList;
                },
                enumerable: true,
                configurable: true
            });
            ComponentPassInputBlend.prototype.addDataFromPass = function (pPass) {
                var pUniformMap = pPass._getFullUniformMap();
                var pForeignMap = pPass._getFullForeignMap();
                var pTextureMap = pPass._getFullTextureMap();
                var pVar = null;
                for(var i in pForeignMap) {
                    pVar = pForeignMap[i];
                    this._pForeignByNameMap[pVar.getName()] = pVar;
                }
                for(var i in pTextureMap) {
                    pVar = pTextureMap[i];
                    this._pTextureNameToRealMap[pVar.getName()] = pVar.getRealName();
                    this._pTextureByRealNameMap[pVar.getRealName()] = pVar;
                }
                for(var i in pUniformMap) {
                    pVar = pUniformMap[i];
                    this.addUniformVariable(pVar, "", "");
                }
            };
            ComponentPassInputBlend.prototype.finalizeInput = function () {
                this._pUniformNameList = Object.keys(this._pUniformNameToRealMap);
                this._pUniformRealNameList = Object.keys(this._pUniformByRealNameMap);
                this._pTextureNameList = Object.keys(this._pTextureNameToRealMap);
                this._pTextureRealNameList = Object.keys(this._pTextureByRealNameMap);
                this._pForeignNameList = Object.keys(this._pForeignByNameMap);
                this._pFreePassInputBlendList = [];
                this.generateNewPassInputs();
            };
            ComponentPassInputBlend.prototype.getPassInput = function () {
                if (this._pFreePassInputBlendList.length === 0) {
                    this.generateNewPassInputs();
                }
                return this._pFreePassInputBlendList.pop();
            };
            ComponentPassInputBlend.prototype.releasePassInput = function (pInput) {
                this._pFreePassInputBlendList.push(pInput);
            };
            ComponentPassInputBlend.prototype.addUniformVariable = function (pVariable, sPrevName, sPrevRealName) {
                var sName = "";
                var sRealName = "";
                // if(sPrevName !== ""){
                // 	sName = sPrevName + "." + pVariable.getName();
                // }
                // else {
                // 	sName = pVariable.getName();
                // }
                // if(sPrevRealName !== ""){
                // 	sRealName = sPrevRealName + "." + pVariable.getRealName();
                // }
                // else {
                // 	sRealName = pVariable.getRealName();
                // }
                sName = pVariable.getName();
                sRealName = pVariable.getRealName();
                var pHasVar = this._pUniformByRealNameMap[sRealName];
                if (((pHasVar) !== undefined) && !pHasVar.getType().isEqual(pVariable.getType())) {
 {
                        akra.logger.setSourceLocation("fx/ComponentBlend.ts", 481);
                        akra.logger.warning("You used uniforms with the same real-names. Now we don`t work very well with that.");
                    }
                    ;
                    return;
                }
                var pVariableType = pVariable.getType();
                // if(!pVariableType.isComplex()) {
                // 	this._pUniformNameToRealMap[sName] = sRealName;
                // 	this._pUniformByRealNameMap[sRealName] = pVariable;
                // 	this._pUniformDefaultValueMap[sRealName] = pVariable.getDefaultValue();
                // }
                // else {
                // 	var pFieldNameList: string[] = pVariableType.getFieldNameList();
                // 	for(var i: uint = 0; i < pFieldNameList.length; i++){
                // 		this.addUniformVariable(pVariableType.getField(pFieldNameList[i]), sName, sRealName);
                // 	}
                // }
                this._pUniformNameToRealMap[sName] = sRealName;
                this._pUniformByRealNameMap[sRealName] = pVariable;
                this._pUniformDefaultValueMap[sRealName] = pVariable.getDefaultValue();
            };
            ComponentPassInputBlend.prototype.generateNewPassInputs = function (nCount) {
                if (typeof nCount === "undefined") { nCount = 5; }
                for(var i = 0; i < nCount; i++) {
                    var pPassInput = new fx.PassInputBlend(this);
                    this._pFreePassInputBlendList.push(pPassInput);
                }
            };
            return ComponentPassInputBlend;
        })();
        fx.ComponentPassInputBlend = ComponentPassInputBlend;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        var Blender = (function () {
            function Blender(pComposer) {
                this._pComposer = null;
                this._pComponentBlendByHashMap = null;
                this._pBlendWithComponentMap = null;
                this._pBlendWithBlendMap = null;
                this._pPassBlendByHashMap = null;
                this._pPassBlendByIdMap = null;
                this._pComposer = pComposer;
                this._pComponentBlendByHashMap = {};
                this._pBlendWithComponentMap = {};
                this._pBlendWithBlendMap = {};
                this._pPassBlendByHashMap = {};
                this._pPassBlendByIdMap = {};
            }
            Blender.prototype.addComponentToBlend = function (pComponentBlend, pComponent, iShift, iPass) {
                var sBlendPartHash = ((pComponentBlend) != null) ? pComponentBlend.getGuid().toString() : "";
                var sComponentPartHash = pComponent.getHash(iShift, iPass);
                var sShortHash = sBlendPartHash + "+" + sComponentPartHash;
                if (!((pComponentBlend) === null) && pComponentBlend.containComponentHash(sComponentPartHash)) {
 {
                        akra.logger.setSourceLocation("fx/Blender.ts", 42);
                        akra.logger.warning("You try to add already used component '" + sComponentPartHash + "' in blend.");
                    }
                    ;
                    return pComponentBlend;
                }
                if (((this._pBlendWithComponentMap[sShortHash]) !== undefined)) {
                    return this._pBlendWithComponentMap[sShortHash];
                }
                var pNewBlend = null;
                if (((pComponentBlend) === null)) {
                    pNewBlend = new fx.ComponentBlend(this._pComposer);
                } else {
                    pNewBlend = pComponentBlend.clone();
                }
                var pTechnique = pComponent.getTechnique();
                var pTechComponentList = pTechnique.getFullComponentList();
                var pTechComponentShiftList = pTechnique.getFullComponentShiftList();
                if (iPass === 0xffffff) {
                    if (!((pTechComponentList) === null)) {
                        for(var i = 0; i < pTechComponentList.length; i++) {
                            pNewBlend.addComponent(pTechComponentList[i], pTechComponentShiftList[i] + iShift, 0xffffff);
                        }
                    }
                    pNewBlend.addComponent(pComponent, iShift, 0xffffff);
                } else {
                    if (!((pTechComponentList) === null)) {
                        for(var i = 0; i < pTechComponentList.length; i++) {
                            pNewBlend.addComponent(pTechComponentList[i], pTechComponentShiftList[i] + iShift, iPass - pTechComponentShiftList[i]);
                        }
                    }
                    pNewBlend.addComponent(pComponent, iShift, iPass);
                }
                this._pBlendWithComponentMap[sShortHash] = pNewBlend;
                var sNewBlendHash = pNewBlend.getHash();
                if (((this._pComponentBlendByHashMap[sNewBlendHash]) !== undefined)) {
                    return this._pComponentBlendByHashMap[sNewBlendHash];
                } else {
                    this._pComponentBlendByHashMap[sNewBlendHash] = pNewBlend;
                }
                return pNewBlend;
            };
            Blender.prototype.removeComponentFromBlend = function (pComponentBlend, pComponent, iShift, iPass) {
                if (((pComponentBlend) === null)) {
 {
                        akra.logger.setSourceLocation("fx/Blender.ts", 100);
                        akra.logger.warning("You try to remove component '" + pComponent.getName() + "' with shift " + iShift.toString() + "from empty blend.");
                    }
                    ;
                    return null;
                }
                var sBlendPartHash = ((pComponentBlend) != null) ? pComponentBlend.getGuid().toString() : "";
                var sComponentPartHash = pComponent.getHash(iShift, iPass);
                var sShortHash = sBlendPartHash + "-" + sComponentPartHash;
                if (((this._pBlendWithComponentMap[sShortHash]) !== undefined)) {
                    return this._pBlendWithComponentMap[sShortHash];
                }
                if (!pComponentBlend.containComponentHash(sComponentPartHash)) {
 {
                        akra.logger.setSourceLocation("fx/Blender.ts", 114);
                        akra.logger.warning("You try to remove component '" + pComponent.getName() + "' with shift " + iShift.toString() + "from blend that not contain it.");
                    }
                    ;
                    return null;
                }
                var pNewBlend = pComponentBlend.clone();
                var pTechnique = pComponent.getTechnique();
                var pTechComponentList = pTechnique.getFullComponentList();
                var pTechComponentShiftList = pTechnique.getFullComponentShiftList();
                if (iPass === 0xffffff) {
                    if (!((pTechComponentList) === null)) {
                        for(var i = 0; i < pTechComponentList.length; i++) {
                            pNewBlend.removeComponent(pTechComponentList[i], pTechComponentShiftList[i] + iShift, 0xffffff);
                        }
                    }
                    pNewBlend.removeComponent(pComponent, iShift, 0xffffff);
                } else {
                    if (!((pTechComponentList) === null)) {
                        for(var i = 0; i < pTechComponentList.length; i++) {
                            pNewBlend.removeComponent(pTechComponentList[i], pTechComponentShiftList[i] + iShift, iPass - pTechComponentShiftList[i]);
                        }
                    }
                    pNewBlend.removeComponent(pComponent, iShift, iPass);
                }
                this._pBlendWithComponentMap[sShortHash] = pNewBlend;
                var sNewBlendHash = pNewBlend.getHash();
                if (((this._pComponentBlendByHashMap[sNewBlendHash]) !== undefined)) {
                    return this._pComponentBlendByHashMap[sNewBlendHash];
                } else {
                    this._pComponentBlendByHashMap[sNewBlendHash] = pNewBlend;
                }
                return pNewBlend;
            };
            Blender.prototype.addBlendToBlend = function (pComponentBlend, pAddBlend, iShift) {
                if (((pComponentBlend) === null)) {
                    return pAddBlend;
                }
                if (((pAddBlend) === null)) {
                    return pComponentBlend;
                }
                var sShortHash = pComponentBlend.getGuid().toString() + "+" + pAddBlend.getGuid().toString();
                if (((this._pBlendWithBlendMap[sShortHash]) !== undefined)) {
                    return this._pBlendWithBlendMap[sShortHash];
                }
                var pNewBlend = pComponentBlend.clone();
                var pAddComponentList = pAddBlend._getComponentList();
                var pAddComponentShiftList = pAddBlend._getComponentShiftList();
                var pAddComponentPassIdList = pAddBlend._getComponentPassIdList();
                for(var i = 0; i < pAddComponentList.length; i++) {
                    pNewBlend.addComponent(pAddComponentList[i], pAddComponentShiftList[i] + iShift, pAddComponentPassIdList[i]);
                }
                this._pBlendWithBlendMap[sShortHash] = pNewBlend;
                var sNewBlendHash = pNewBlend.getHash();
                if (((this._pComponentBlendByHashMap[sNewBlendHash]) !== undefined)) {
                    return this._pComponentBlendByHashMap[sNewBlendHash];
                } else {
                    this._pComponentBlendByHashMap[sNewBlendHash] = pNewBlend;
                }
                return pNewBlend;
            };
            Blender.prototype.generatePassBlend = function (pPassList, pStates, pForeigns, pUniforms) {
                var sPassBlendHash = "";
                for(var i = 0; i < pPassList.length; i++) {
                    var pPass = pPassList[i];
                    pPass.evaluate(pStates, pForeigns, pUniforms);
                    var pVertexShader = pPass.getVertexShader();
                    var pPixelShader = pPass.getPixelShader();
                    if (!((pVertexShader) === null)) {
                        sPassBlendHash += pVertexShader.getGuid().toString() + ":";
                    } else {
                        sPassBlendHash += "E:";
                    }
                    if (!((pPixelShader) === null)) {
                        sPassBlendHash += pPixelShader.getGuid().toString() + ":";
                    } else {
                        sPassBlendHash += "E:";
                    }
                }
                if (((this._pPassBlendByHashMap[sPassBlendHash]) !== undefined)) {
                    return this._pPassBlendByHashMap[sPassBlendHash];
                }
                var pNewPassBlend = new fx.PassBlend(this._pComposer);
                var isOk = pNewPassBlend.initFromPassList(pPassList);
                if (!isOk) {
                    return null;
                }
                this._pPassBlendByHashMap[sPassBlendHash] = pNewPassBlend;
                this._pPassBlendByIdMap[pNewPassBlend.getGuid()] = pNewPassBlend;
                return pNewPassBlend;
            };
            Blender.prototype.getPassBlendById = /** @inline */function (id) {
                return this._pPassBlendByIdMap[id] || null;
            };
            return Blender;
        })();
        fx.Blender = Blender;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var BufferMap = (function (_super) {
            __extends(BufferMap, _super);
            function BufferMap(pEngine) {
                        _super.call(this);
                this._pFlows = null;
                this._pMappers = null;
                this._pIndex = null;
                this._nLength = 0;
                this._pCompleteFlows = null;
                this._nCompleteFlows = 0;
                this._nCompleteVideoBuffers = 0;
                this._pCompleteVideoBuffers = null;
                this._nUsedFlows = 0;
                this._pEngine = null;
                this._nStartIndex = 0;
                this._pBuffersCompatibleMap = null;
                this._pSemanticsMap = null;
                this._pEngine = pEngine;
                this.reset();
            }
            Object.defineProperty(BufferMap.prototype, "primType", {
                get: /** @inline */function () {
                    return this._pIndex ? this._pIndex.getPrimitiveType() : this._ePrimitiveType;
                },
                set: /** @inline */function (eType) {
                    this._ePrimitiveType = eType;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "primCount", {
                get: /** @inline */function () {
                    return akra.data.IndexData.getPrimitiveCount(((this)._pIndex ? (this)._pIndex.getPrimitiveType() : (this)._ePrimitiveType), (((this)._pIndex ? (this)._pIndex.length : (this)._nLength)));
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "index", {
                get: /** @inline */function () {
                    return this._pIndex;
                },
                set: /** @inline */function (pIndexData) {
                    if (this._pIndex === pIndexData) {
                        return;
                    }
                    this._pIndex = pIndexData;
                    this.update();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "limit", {
                get: /** @inline */function () {
                    return this._pFlows.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "length", {
                get: /** @inline */function () {
                    return (this._pIndex ? this._pIndex.length : this._nLength);
                },
                set: /** @inline */function (nLength) {
                    this._nLength = Math.min(this._nLength, nLength);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "_length", {
                set: /** @inline */function (nLength) {
                    this._nLength = nLength;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "startIndex", {
                get: /** @inline */function () {
                    return this._nStartIndex;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "size", {
                get: /** @inline */function () {
                    return this._nCompleteFlows;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "flows", {
                get: /** @inline */function () {
                    return this._pCompleteFlows;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "mappers", {
                get: /** @inline */function () {
                    return this._pMappers;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "offset", {
                get: /** @inline */function () {
                    return (this._pIndex ? this._pIndex.byteOffset : 0);
                },
                enumerable: true,
                configurable: true
            });
            BufferMap.prototype._draw = function () {
                // this._pEngine.getComposer().applyBufferMap(this);
                // this._pEngine.getRenderer().getActiveProgram().applyBufferMap(this);
                ((this._pIndex) === null) ? (((((this)._pEngine.getRenderer()))._pWebGLContext).drawArrays(/*checked (origin: akra)>>*/akra.webgl.getWebGLPrimitiveType((this)._ePrimitiveType), // GL_POINTS,
(this)._nStartIndex, (this)._nLength)) : (((((this)._pEngine.getRenderer()))._pWebGLContext).drawElements(/*checked (origin: akra)>>*/akra.webgl.getWebGLPrimitiveType((this)._ePrimitiveType), (this)._pIndex.getPrimitiveCount(), /*checked (origin: akra)>>*/akra.webgl.getWebGLPrimitiveType((this)._pIndex.getPrimitiveType()), (this)._pIndex.byteOffset / 4));
            };
            BufferMap.prototype.drawArrays = /** @inline */function () {
                (((this._pEngine.getRenderer()))._pWebGLContext).drawArrays(akra.webgl.getWebGLPrimitiveType(this._ePrimitiveType), // GL_POINTS,
                this._nStartIndex, this._nLength);
            };
            BufferMap.prototype.drawElements = /** @inline */function () {
                (((this._pEngine.getRenderer()))._pWebGLContext).drawElements(akra.webgl.getWebGLPrimitiveType(this._ePrimitiveType), this._pIndex.getPrimitiveCount(), akra.webgl.getWebGLPrimitiveType(this._pIndex.getPrimitiveType()), this._pIndex.byteOffset / 4);
                //FIXME: offset of drawElement() in Glintptr = long long = 32 byte???
                            };
            BufferMap.prototype.getFlow = function (iFlow, bComplete) {
                if (typeof bComplete === "undefined") { bComplete = true; }
                if ((typeof (arguments[0]) === "string")) {
                    var nTotal;
                    var pFlows;
                    if (bComplete) {
                        pFlows = this._pCompleteFlows;
                        nTotal = this._nCompleteFlows;
                    } else {
                        pFlows = this._pFlows;
                        nTotal = this._pFlows.length;
                    }
                    for(var i = 0; i < nTotal; ++i) {
                        if (!pFlows[i].data) {
                            continue;
                        }
                        if (pFlows[i].data.hasSemantics(arguments[0])) {
                            return pFlows[i];
                        }
                    }
                    return null;
                }
                if (bComplete) {
                    for(var i = 0, pFlows = this._pCompleteFlows; i < this._nCompleteFlows; ++i) {
                        if (pFlows[i].flow == iFlow) {
                            return pFlows[i];
                        }
                    }
                    return null;
                }
                return this._pFlows[iFlow];
            };
            BufferMap.prototype.getFlowBySemantic = //TODO: It is temp method for test deoptimozation of code
            function (sSemantics) {
                for(var i = 0; i < this._nCompleteFlows; ++i) {
                    if (this._pCompleteFlows[i].data.hasSemantics(sSemantics)) {
                        return this._pCompleteFlows[i];
                    }
                }
                return null;
            };
            BufferMap.prototype.reset = function () {
                this._pIndex = null;
                this._ePrimitiveType = akra.EPrimitiveTypes.TRIANGLELIST;
                var nFlowLimit = 16;
                /*webgl.maxVertexTextureImageUnits*/
                nFlowLimit = Math.min(16, akra.webgl.maxVertexAttributes);
                this._pMappers = [];
                this._pFlows = new Array(nFlowLimit);
                for(var i = 0; i < nFlowLimit; i++) {
                    this._pFlows[i] = {
                        flow: i,
                        data: null,
                        type: akra.EDataFlowTypes.UNMAPPABLE,
                        mapper: null
                    };
                }
                this._nLength = akra.MAX_INT32;
                this._pCompleteFlows = new Array(nFlowLimit);
                this._nCompleteFlows = 0;
                this._nStartIndex = akra.MAX_INT32;
                this._pBuffersCompatibleMap = {};
                this._pCompleteVideoBuffers = new Array(nFlowLimit);
                this._nCompleteVideoBuffers = 0;
                this._nUsedFlows = 0;
                this._pSemanticsMap = {};
            };
            BufferMap.prototype.flow = function (iFlow, pData) {
                var pFlow = null;
                var pVertexData = null;
                var isOk;
                if (arguments.length < 2) {
                    pVertexData = arguments[0];
                    iFlow = (this._nUsedFlows++);
                } else {
                    iFlow = arguments[0];
                    pVertexData = arguments[1];
                }
                pFlow = this._pFlows[iFlow];
 {
                    util.logger.setSourceLocation("util/BufferMap.ts", 251);
                    util.logger.assert(iFlow < ((this)._pFlows.length), 'Invalid strem. Maximum allowable number of stream ' + ((this)._pFlows.length) + '.');
                }
                ;
                if (!pVertexData || pFlow.data === pVertexData) {
 {
                        util.logger.setSourceLocation("util/BufferMap.ts", 255);
                        util.logger.warning("BufferMap::flow(", iFlow, pVertexData, ") failed.", ((pVertexData) === null) ? "vertex data is null" : "flow.data alreay has same vertex data");
                    }
                    ;
                    return -1;
                }
                if (((pVertexData.buffer).type === /*checked (origin: akra)>>*/akra.EVertexBufferTypes.VBO)) {
                    pFlow.type = akra.EDataFlowTypes.UNMAPPABLE;
                    ((this)._nLength = Math.min((this)._nLength, (pVertexData.length)));
                    //this.startIndex = pVertexData.getStartIndex();
                    isOk = this.checkData(pVertexData);
 {
                        util.logger.setSourceLocation("util/BufferMap.ts", 264);
                        util.logger.assert(isOk, 'You can use several unmappable data flows from one buffer.');
                    }
                    ;
                    ((this)._pBuffersCompatibleMap[(pVertexData).getBufferHandle()] = (pVertexData));
                } else {
                    pFlow.type = akra.EDataFlowTypes.MAPPABLE;
                }
                pFlow.data = pVertexData;
                return this.update() ? iFlow : -1;
            };
            BufferMap.prototype.clearLinks = function () {
                for(var sSemantics in this._pSemanticsMap) {
                    this._pSemanticsMap[sSemantics] = null;
                }
            };
            BufferMap.prototype.linkFlow = function (pFlow) {
                var pDecl = pFlow.data.getVertexDeclaration();
                for(var i = 0; i < (pDecl._pElements.length); ++i) {
                    var pElement = (pDecl._pElements[(i)] || null);
                    var sSemantics = pElement.semantics;
                    if ((pElement.semantics === /*checked (origin: akra)>>*/akra.DeclUsages.END)) {
                        continue;
                    }
                    var isSemanticsExists = ((this._pSemanticsMap[sSemantics]) != null);
 {
                        util.logger.setSourceLocation("util/BufferMap.ts", 297);
                        util.logger.assert(!isSemanticsExists, "overwrited semantics: " + sSemantics);
                    }
                    ;
                    if (!isSemanticsExists) {
                        this._pSemanticsMap[sSemantics] = pFlow;
                    }
                }
                if (pFlow.type === akra.EDataFlowTypes.MAPPABLE) {
                    var sSemantics = pFlow.mapper.semantics;
                    var isSemanticsExists = ((this._pSemanticsMap[sSemantics]) != null);
 {
                        util.logger.setSourceLocation("util/BufferMap.ts", 308);
                        util.logger.assert(!isSemanticsExists, "overwrited semantics(MAPPER!): " + sSemantics);
                    }
                    ;
                    if (!isSemanticsExists) {
                        this._pSemanticsMap[sSemantics] = pFlow;
                    }
                }
            };
            BufferMap.prototype.checkData = function (pData) {
                var pEtalon = this._pBuffersCompatibleMap[pData.getBufferHandle()];
                if (!pEtalon || pEtalon.byteOffset === pData.byteOffset) {
                    return true;
                }
                return false;
            };
            BufferMap.prototype.findMapping = /**@protected*/ function (pMap, eSemantics, iAddition) {
                var isOk = this.checkData(pMap);
 {
                    util.logger.setSourceLocation("util/BufferMap.ts", 326);
                    util.logger.assert(isOk, 'You can use several different maps from one buffer.');
                }
                ;
                for(var i = 0, pMappers = this._pMappers, pExistsMap; i < pMappers.length; i++) {
                    pExistsMap = pMappers[i].data;
                    if (pExistsMap === pMap) {
                        //если уже заданные маппинг менял свой стартовый индекс(например при расширении)
                        //то необходимо сменить стартовый индекс на новый
                        if (pMappers[i].semantics === eSemantics && pMappers[i].addition == iAddition) {
                            return pMappers[i];
                        }
                    } else {
 {
                            util.logger.setSourceLocation("util/BufferMap.ts", 339);
                            util.logger.assert(pExistsMap.getStartIndex() === pMap.getStartIndex(), 'You can not use maps with different indexing');
                        }
                        ;
                    }
                }
                return null;
            };
            BufferMap.prototype.mapping = function (iFlow, pMap, eSemantics, iAddition) {
                if (typeof iAddition === "undefined") { iAddition = 0; }
                var pMapper = this.findMapping(pMap, eSemantics, iAddition);
                var pFlow = this._pFlows[iFlow];
 {
                    util.logger.setSourceLocation("util/BufferMap.ts", 351);
                    util.logger.assert(((pFlow.data) != null) && (pFlow.type === akra.EDataFlowTypes.MAPPABLE), 'Cannot mapping empty/unmappable flow.');
                }
                ;
 {
                    util.logger.setSourceLocation("util/BufferMap.ts", 352);
                    util.logger.assert(((pMap) !== undefined), 'Passed empty mapper.');
                }
                ;
                if (!eSemantics) {
                    eSemantics = pMap.getVertexDeclaration()[0].eUsage;
                } else if (pMap.hasSemantics(eSemantics) === false) {
 {
                        util.logger.setSourceLocation("util/BufferMap.ts", 358);
                        util.logger.error('Passed mapper does not have semantics: ' + eSemantics + '.');
                    }
                    ;
                    return false;
                }
                if (pMapper) {
                    if (pFlow.mapper === pMapper) {
                        return pMapper.semantics === eSemantics && pMapper.addition === iAddition ? true : false;
                    }
                } else {
                    pMapper = {
                        data: pMap,
                        semantics: eSemantics,
                        addition: iAddition
                    };
                    this._pMappers.push(pMapper);
                    ((this)._nLength = Math.min((this)._nLength, (pMap.length)));
                    //this.startIndex = pMap.getStartIndex();
                    ((this)._pBuffersCompatibleMap[(pMap).getBufferHandle()] = (pMap));
                }
                pFlow.mapper = pMapper;
                return this.update();
            };
            BufferMap.prototype.pushEtalon = /** @inline */function (pData) {
                this._pBuffersCompatibleMap[pData.getBufferHandle()] = pData;
            };
            BufferMap.prototype.update = function () {
                var pFlows = this._pFlows;
                var pFlow;
                var pMapper;
                var isMappable = false;
                var pCompleteFlows = this._pCompleteFlows;
                var nCompleteFlows = 0;
                var pCompleteVideoBuffers = this._pCompleteVideoBuffers;
                var nCompleteVideoBuffers = 0;
                var nUsedFlows = 0;
                var pVideoBuffer;
                var isVideoBufferAdded = false;
                var nStartIndex = akra.MAX_INT32, nCurStartIndex;
                this.clearLinks();
                for(var i = 0; i < pFlows.length; i++) {
                    pFlow = pFlows[i];
                    pMapper = pFlow.mapper;
                    isMappable = (pFlow.type === akra.EDataFlowTypes.MAPPABLE);
                    if (pFlow.data) {
                        nUsedFlows++;
                    }
                    if (pFlow.data === null || (isMappable && pMapper === null)) {
                        continue;
                    }
                    pCompleteFlows[nCompleteFlows++] = pFlow;
                    this.linkFlow(pFlow);
                    if (isMappable) {
                        nCurStartIndex = pMapper.data.startIndex;
                        pVideoBuffer = pFlow.data.buffer;
                        for(var j = 0; j < nCompleteVideoBuffers; j++) {
                            if (pCompleteVideoBuffers[j] === pVideoBuffer) {
                                isVideoBufferAdded = true;
                                break;
                            }
                        }
                        if (!isVideoBufferAdded) {
                            pCompleteVideoBuffers[nCompleteVideoBuffers++] = pVideoBuffer;
                        }
                    } else {
                        nCurStartIndex = pFlow.data.startIndex;
                    }
                    if (nStartIndex === akra.MAX_INT32) {
                        nStartIndex = nCurStartIndex;
                        continue;
                    }
 {
                        util.logger.setSourceLocation("util/BufferMap.ts", 441);
                        util.logger.assert(nStartIndex == nCurStartIndex, 'You can not use a maps or unmappable buffers having different starting index.');
                    }
                    ;
                }
                this._nStartIndex = nStartIndex;
                this._nCompleteFlows = nCompleteFlows;
                this._nCompleteVideoBuffers = nCompleteVideoBuffers;
                this._nUsedFlows = nUsedFlows;
                // LOG(this.toString());
                // LOG("\n" + JSON.stringify(Object.keys(this._pSemanticsMap), null, "\t"))
                return true;
            };
            BufferMap.prototype.findFlow = function (sSemantics) {
                return !((this._pSemanticsMap[sSemantics]) !== undefined) ? (this._pSemanticsMap[sSemantics] = null) : this._pSemanticsMap[sSemantics];
            };
            BufferMap.prototype.clone = function (bWithMapping) {
                if (typeof bWithMapping === "undefined") { bWithMapping = true; }
                var pMap = this._pEngine.createBufferMap();
                for(var i = 0, pFlows = this._pFlows; i < pFlows.length; ++i) {
                    if (pFlows[i].data === null) {
                        continue;
                    }
                    if (pMap.flow(pFlows[i].flow, pFlows[i].data) < 0) {
                        pMap = null;
 {
                            util.logger.setSourceLocation("util/BufferMap.ts", 470);
                            util.logger.log("BufferMap::clone() failed on", pFlows[i].flow, pFlows[i].data);
                        }
                        ;
                        return null;
                    }
                    if (!bWithMapping) {
                        continue;
                    }
                    if (pFlows[i].mapper) {
                        pMap.mapping(pFlows[i].flow, pFlows[i].mapper.data, pFlows[i].mapper.semantics, pFlows[i].mapper.addition);
                    }
                }
                return pMap;
            };
            BufferMap.prototype.toString = function (bListAll) {
                if (typeof bListAll === "undefined") { bListAll = false; }
                function _an(sValue, n, bBackward) {
                    sValue = String(sValue);
                    bBackward = bBackward || false;
                    if (sValue.length < n) {
                        for(var i = 0, l = sValue.length; i < n - l; ++i) {
                            if (!bBackward) {
                                sValue += ' ';
                            } else {
                                sValue = ' ' + sValue;
                            }
                        }
                    }
                    return sValue;
                }
                var s = '\n\n', t;
                s += '      $1 Flows     : OFFSET / SIZE   |   BUFFER / OFFSET   :      Mapping  / Shift    : OFFSET |    Additional    \n';
                s = s.replace("$1", bListAll ? "   Total" : "Complete");
                t = '-------------------------:-----------------+---------------------:--------------------------:--------+------------------\n';
                // = '#%1 [ %2 ]           :     %6 / %7     |       %3 / %4       :         %5       :        |                  \n';
                // = '#%1 [ %2 ]           :     %6 / %7     |       %3 / %4       :         %5       :        |                  \n';
                s += t;
                var pFlows = bListAll ? this._pFlows : this._pCompleteFlows;
                var nFlows = bListAll ? this._nUsedFlows : this._nCompleteFlows;
                for(var i = 0; i < nFlows; ++i) {
                    var pFlow = pFlows[i];
                    var pMapper = pFlow.mapper;
                    var pVertexData = pFlow.data;
                    var pDecl = pVertexData.getVertexDeclaration();
                    //trace(pMapper); window['pMapper'] = pMapper;
                    s += '#' + _an(pFlow.flow, 2) + ' ' + _an('[ ' + ((pDecl._pElements[(0)] || null).usage !== akra.DeclUsages.END ? (pDecl._pElements[(0)] || null).usage : '<end>') + ' ]', 20) + ' : ' + _an((pDecl._pElements[(0)] || null).offset, 6, true) + ' / ' + _an((pDecl._pElements[(0)] || null).size, 6) + ' | ' + _an(pVertexData.getBufferHandle(), 8, true) + ' / ' + _an(pVertexData.byteOffset, 8) + ' : ' + (pMapper ? _an(pMapper.semantics, 15, true) + ' / ' + _an(pMapper.addition, 7) + ': ' + _an(pMapper.data.getVertexDeclaration().findElement(pMapper.semantics).offset, 6) : _an('-----', 25) + ': ' + _an('-----', 6)) + ' |                  \n';
                    for(var j = 1; j < (pDecl._pElements.length); ++j) {
                        s += '    ' + _an('[ ' + ((pDecl._pElements[(j)] || null).usage !== akra.DeclUsages.END ? (pDecl._pElements[(j)] || null).usage : '<end>') + ' ]', 20) + ' : ' + _an((pDecl._pElements[(j)] || null).offset, 6, true) + ' / ' + _an((pDecl._pElements[(j)] || null).size, 6) + ' |                     :                          :        |                  \n';
                    }
                    s += t;
                }
                ;
                s += '=================================================================\n';
                s += '      PRIMITIVE TYPE : ' + '0x' + Number(((this)._pIndex ? (this)._pIndex.getPrimitiveType() : (this)._ePrimitiveType)).toString(16) + '\n';
                s += '     PRIMITIVE COUNT : ' + (/*checked (origin: akra)>>*/akra.data.IndexData.getPrimitiveCount((((this))._pIndex ? ((this))._pIndex.getPrimitiveType() : ((this))._ePrimitiveType), (this).length)) + '\n';
                s += '         START INDEX : ' + ((this)._nStartIndex) + '\n';
                s += '              LENGTH : ' + this.length + '\n';
                s += '  USING INDEX BUFFER : ' + (((this)._pIndex) ? 'TRUE' : 'FALSE') + '\n';
                s += '=================================================================\n';
                return s + '\n\n';
            };
            return BufferMap;
        })(util.ReferenceCounter);
        util.BufferMap = BufferMap;        
        function createBufferMap(pEngine) {
            return new BufferMap(pEngine);
        }
        util.createBufferMap = createBufferMap;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        var Composer = (function () {
            function Composer(pEngine) {
                this._pEngine = null;
                this._pTechniqueToBlendMap = null;
                this._pTechniqueToOwnBlendMap = null;
                this._pTechniqueLastGlobalBlendMap = null;
                this._pTechniqueNeedUpdateMap = null;
                this._pEffectResourceToComponentBlendMap = null;
                this._pBlender = null;
                this._pGlobalEffectResorceIdStack = null;
                // private _pGlobalEffectResorceShiftStack: int[] = null;
                this._pGlobalComponentBlendStack = null;
                this._pGlobalComponentBlend = null;
                //Data for render
                this._pCurrentSceneObject = null;
                this._pCurrentViewport = null;
                this._pCurrentRenderable = null;
                this._pCurrentBufferMap = null;
                this._pCurrentSurfaceMaterial = null;
                this._pComposerState = {
                    mesh: {
                        isSkinned: false,
                        isOptimizedSkinned: false
                    },
                    terrain: {
                        isROAM: false
                    },
                    renderable: {
                        isAdvancedIndex: false
                    }
                };
                /** Render targets for global-post effects */
                this._pRenderTargetA = null;
                this._pRenderTargetB = null;
                this._pLastRenderTarget = null;
                this._pPostEffectTextureA = null;
                this._pPostEffectTextureB = null;
                this._pPostEffectDepthBuffer = null;
                //render id data
                this._pRidTable = {};
                this._pRidMap = {};
                this._nRidSO = 0;
                this._nRidRE = 0;
                /**@protected*/ this.bNormalFix = true;
                /**@protected*/ this.bUseNormalMap = true;
                /**@protected*/ this.bIsDebug = false;
                /**@protected*/ this.bIsRealNormal = false;
                /**@protected*/ this.bTerrainBlackSectors = false;
                /**@protected*/ this.bShowTriangles = false;
                this._pEngine = pEngine;
                this._pBlender = new fx.Blender(this);
                this._pTechniqueToBlendMap = {};
                this._pTechniqueToOwnBlendMap = {};
                this._pTechniqueLastGlobalBlendMap = {};
                this._pTechniqueNeedUpdateMap = {};
                this._pEffectResourceToComponentBlendMap = {};
                this._pGlobalEffectResorceIdStack = [];
                this._pGlobalComponentBlendStack = [];
                this._pGlobalComponentBlend = null;
                this.initPostEffectTextures();
                if (((Composer.pDefaultSamplerBlender) === null)) {
                    Composer.pDefaultSamplerBlender = new fx.SamplerBlender();
                }
            }
            Composer.pDefaultSamplerBlender = null;
            Composer.prototype.getComponentByName = function (sComponentName) {
                return this._pEngine.getResourceManager().componentPool.findResource(sComponentName);
            };
            Composer.prototype.getEngine = /** @inline */function () {
                return this._pEngine;
            };
            Composer.prototype.getComponentCountForEffect = //-----------------------------------------------------------------------------//
            //-----------------------------API for Effect-resource-------------------------//
            //-----------------------------------------------------------------------------//
            function (pEffectResource) {
                var id = pEffectResource.resourceHandle;
                if (((this._pEffectResourceToComponentBlendMap[id]) !== undefined)) {
                    return this._pEffectResourceToComponentBlendMap[id].getComponentCount();
                } else {
                    return 0;
                }
            };
            Composer.prototype.getTotalPassesForEffect = function (pEffectResource) {
                var id = pEffectResource.resourceHandle;
                if (((this._pEffectResourceToComponentBlendMap[id]) !== undefined)) {
                    return this._pEffectResourceToComponentBlendMap[id].getTotalPasses();
                } else {
                    return 0;
                }
            };
            Composer.prototype.addComponentToEffect = function (pEffectResource, pComponent, iShift, iPass) {
                var id = pEffectResource.resourceHandle;
                var pCurrentBlend = null;
                if (((this._pEffectResourceToComponentBlendMap[id]) !== undefined)) {
                    pCurrentBlend = this._pEffectResourceToComponentBlendMap[id];
                }
                var pNewBlend = this._pBlender.addComponentToBlend(pCurrentBlend, pComponent, iShift, iPass);
                if (((pNewBlend) === null)) {
                    return false;
                }
                this._pEffectResourceToComponentBlendMap[id] = pNewBlend;
                return true;
            };
            Composer.prototype.removeComponentFromEffect = function (pEffectResource, pComponent, iShift, iPass) {
                var id = pEffectResource.resourceHandle;
                var pCurrentBlend = null;
                if (((this._pEffectResourceToComponentBlendMap[id]) !== undefined)) {
                    pCurrentBlend = this._pEffectResourceToComponentBlendMap[id];
                }
                var pNewBlend = this._pBlender.removeComponentFromBlend(pCurrentBlend, pComponent, iShift, iPass);
                if (((pNewBlend) === null)) {
                    return false;
                }
                this._pEffectResourceToComponentBlendMap[id] = pNewBlend;
                return true;
            };
            Composer.prototype.hasComponentForEffect = function (pEffectResource, pComponent, iShift, iPass) {
                var id = pEffectResource.resourceHandle;
                var pCurrentBlend = null;
                if (((this._pEffectResourceToComponentBlendMap[id]) !== undefined)) {
                    pCurrentBlend = this._pEffectResourceToComponentBlendMap[id];
                }
                if (((pCurrentBlend) === null)) {
                    return false;
                }
                return pCurrentBlend.containComponent(pComponent, iShift, iPass);
            };
            Composer.prototype.activateEffectResource = function (pEffectResource, iShift) {
                var id = pEffectResource.resourceHandle;
                var pComponentBlend = this._pEffectResourceToComponentBlendMap[id];
                if (!((pComponentBlend) !== undefined)) {
                    return false;
                }
                var pNewGlobalBlend = null;
                if (((this._pGlobalComponentBlend) === null)) {
                    pNewGlobalBlend = pComponentBlend;
                } else {
                    pNewGlobalBlend = this._pBlender.addBlendToBlend(this._pGlobalComponentBlend, pComponentBlend, iShift);
                }
                if (((pNewGlobalBlend) === null)) {
                    return false;
                }
                this._pGlobalEffectResorceIdStack.push(id);
                this._pGlobalComponentBlendStack.push(pNewGlobalBlend);
                this._pGlobalComponentBlend = pNewGlobalBlend;
                return true;
            };
            Composer.prototype.deactivateEffectResource = function (pEffectResource) {
                var id = pEffectResource.resourceHandle;
                var iStackLength = this._pGlobalEffectResorceIdStack.length;
                if (iStackLength === 0) {
                    return false;
                }
                var iLastId = this._pGlobalEffectResorceIdStack[iStackLength - 1];
                if (iLastId !== id) {
                    return false;
                }
                this._pGlobalEffectResorceIdStack.splice(iStackLength - 1, 1);
                this._pGlobalComponentBlendStack.splice(iStackLength - 1, 1);
                if (iStackLength > 1) {
                    this._pGlobalComponentBlend = this._pGlobalComponentBlendStack[iStackLength - 2];
                } else {
                    this._pGlobalComponentBlend = null;
                }
                return true;
            };
            Composer.prototype.getTotalPassesForTechnique = //-----------------------------------------------------------------------------//
            //----------------------------API for RenderTechnique--------------------------//
            //-----------------------------------------------------------------------------//
            function (pRenderTechnique) {
                this.prepareTechniqueBlend(pRenderTechnique);
                var id = pRenderTechnique.getGuid();
                if (((this._pTechniqueToBlendMap[id]) != null)) {
                    return this._pTechniqueToBlendMap[id].getTotalPasses();
                } else {
                    return 0;
                }
            };
            Composer.prototype.addOwnComponentToTechnique = function (pRenderTechnique, pComponent, iShift, iPass) {
                var id = pRenderTechnique.getGuid();
                var pCurrentBlend = null;
                if (((this._pTechniqueToOwnBlendMap[id]) !== undefined)) {
                    pCurrentBlend = this._pTechniqueToOwnBlendMap[id];
                }
                var pNewBlend = this._pBlender.addComponentToBlend(pCurrentBlend, pComponent, iShift, iPass);
                if (((pNewBlend) === null)) {
                    return false;
                }
                this._pTechniqueToOwnBlendMap[id] = pNewBlend;
                this._pTechniqueNeedUpdateMap[id] = true;
                return true;
            };
            Composer.prototype.removeOwnComponentToTechnique = function (pRenderTechnique, pComponent, iShift, iPass) {
                var id = pRenderTechnique.getGuid();
                var pCurrentBlend = null;
                if (((this._pTechniqueToOwnBlendMap[id]) !== undefined)) {
                    pCurrentBlend = this._pTechniqueToOwnBlendMap[id];
                }
                var pNewBlend = this._pBlender.removeComponentFromBlend(pCurrentBlend, pComponent, iShift, iPass);
                if (((pNewBlend) === null)) {
                    return false;
                }
                this._pTechniqueToOwnBlendMap[id] = pNewBlend;
                this._pTechniqueNeedUpdateMap[id] = true;
                return true;
            };
            Composer.prototype.hasOwnComponentInTechnique = function (pRenderTechnique, pComponent, iShift, iPass) {
                var id = pRenderTechnique.getGuid();
                var pCurrentBlend = null;
                if (((this._pTechniqueToOwnBlendMap[id]) !== undefined)) {
                    pCurrentBlend = this._pTechniqueToOwnBlendMap[id];
                }
                if (((pCurrentBlend) === null)) {
                    return false;
                }
                return pCurrentBlend.containComponent(pComponent, iShift, iPass);
            };
            Composer.prototype.prepareTechniqueBlend = function (pRenderTechnique) {
                if (pRenderTechnique.isFreeze()) {
                    return true;
                }
                var id = pRenderTechnique.getGuid();
                var isTechniqueUpdate = !!(this._pTechniqueNeedUpdateMap[id]);
                var isUpdateGlobalBlend = (this._pGlobalComponentBlend !== this._pTechniqueLastGlobalBlendMap[id]);
                var isNeedToUpdatePasses = false;
                if (isTechniqueUpdate || isUpdateGlobalBlend) {
                    var iEffect = pRenderTechnique.getMethod().effect.resourceHandle;
                    var pEffectBlend = this._pEffectResourceToComponentBlendMap[iEffect] || null;
                    var pTechniqueBlend = this._pTechniqueToOwnBlendMap[id] || null;
                    var pNewBlend = null;
                    pNewBlend = this._pBlender.addBlendToBlend(this._pGlobalComponentBlend, pEffectBlend, 0);
                    pNewBlend = this._pBlender.addBlendToBlend(pNewBlend, pTechniqueBlend, 0);
                    if (this._pTechniqueToBlendMap[id] !== pNewBlend) {
                        isNeedToUpdatePasses = true;
                    }
                    this._pTechniqueToBlendMap[id] = pNewBlend;
                    this._pTechniqueNeedUpdateMap[id] = false;
                    this._pTechniqueLastGlobalBlendMap[id] = this._pGlobalComponentBlend;
                }
                var pBlend = this._pTechniqueToBlendMap[id];
                if (((pBlend) != null)) {
                    if (!pBlend.isReadyToUse()) {
                        isNeedToUpdatePasses = true;
                    }
                    if (!pBlend.finalizeBlend()) {
                        return false;
                    }
                    if (isNeedToUpdatePasses) {
                        pRenderTechnique.updatePasses(isTechniqueUpdate);
                    }
                } else {
                    return false;
                }
            };
            Composer.prototype.markTechniqueAsNeedUpdate = function (pRenderTechnique) {
                this._pTechniqueNeedUpdateMap[pRenderTechnique.getGuid()] = true;
            };
            Composer.prototype.getPassInputBlend = function (pRenderTechnique, iPass) {
                var id = pRenderTechnique.getGuid();
                if (!((this._pTechniqueToBlendMap[id]) !== undefined)) {
                    return null;
                }
                return this._pTechniqueToBlendMap[id].getPassInputForPass(iPass);
            };
            Composer.prototype.applyBufferMap = //-----------------------------------------------------------------------------//
            //---------------------------------API for render------------------------------//
            //-----------------------------------------------------------------------------//
            function (pMap) {
                this._pCurrentBufferMap = pMap;
                return true;
                // var pBufferMap: util.BufferMap = <util.BufferMap>pMap;
                // var pState: IPreRenderState = this._pPreRenderState;
                // if(pState.isClear){
                // 	pState.primType = pBufferMap.primType;
                // 	pState.offset = pBufferMap.offset;
                // 	pState.length = pBufferMap.length;
                // 	pState.index = pBufferMap.index;
                // }
                // else if(pState.primType !== pBufferMap.primType ||
                // 		pState.offset !== pBufferMap.offset ||
                // 		pState.length !== pBufferMap.length ||
                // 		pState.index !== pBufferMap.index) {
                // 	ERROR("Could not blend buffer maps");
                // 	return false;
                // }
                // var pFlows: IDataFlow[] = pBufferMap.flows;
                // for(var i: uint = 0; i < pFlows.length; i++){
                // 	pState.flows.push(pFlows[i]);
                // }
                // pState.isClear = false;
                            };
            Composer.prototype.applySurfaceMaterial = function (pSurfaceMaterial) {
                this._pCurrentSurfaceMaterial = pSurfaceMaterial;
                return true;
            };
            Composer.prototype._setCurrentSceneObject = /** @inline */function (pSceneObject) {
                this._pCurrentSceneObject = pSceneObject;
            };
            Composer.prototype._setCurrentViewport = /** @inline */function (pViewport) {
                this._pCurrentViewport = pViewport;
            };
            Composer.prototype._setCurrentRenderableObject = /** @inline */function (pRenderable) {
                this._pCurrentRenderable = pRenderable;
            };
            Composer.prototype._getCurrentSceneObject = /** @inline */function () {
                return this._pCurrentSceneObject;
            };
            Composer.prototype._getCurrentViewport = /** @inline */function () {
                return this._pCurrentViewport;
            };
            Composer.prototype._getCurrentRenderableObject = /** @inline */function () {
                return this._pCurrentRenderable;
            };
            Composer.prototype._setDefaultCurrentState = function () {
                ((this)._pCurrentViewport = (null));
                ((this)._pCurrentRenderable = (null));
                ((this)._pCurrentSceneObject = (null));
            };
            Composer.prototype.renderTechniquePass = function (pRenderTechnique, iPass) {
                // if(true){
                // 	return;
                // }
                var pPass = pRenderTechnique.getPass(iPass);
                var pPassInput = pPass.getPassInput();
                var pPassBlend = null;
                var pMaker = null;
                this.applySystemUnifoms(pPassInput);
                if (!pPassInput._isNeedToCalcShader()) {
                    //TODO: set pShader to shader program by id
                                    } else {
                    if (!pPassInput._isNeedToCalcBlend()) {
                        pPassBlend = this._pBlender.getPassBlendById(pPassInput._getLastPassBlendId());
                    } else {
                        var id = pRenderTechnique.getGuid();
                        var pComponentBlend = this._pTechniqueToBlendMap[id];
                        var pPassInstructionList = pComponentBlend.getPassListAtPass(iPass);
                        this.prepareComposerState();
                        pPassBlend = this._pBlender.generatePassBlend(pPassInstructionList, this._pComposerState, pPassInput.foreigns, pPassInput.uniforms);
                    }
                    if (((pPassBlend) === null)) {
 {
                            akra.logger.setSourceLocation("fx/Composer.ts", 493);
                            akra.logger.error("Could not render. Error with generation pass-blend.");
                        }
                        ;
                        return;
                    }
                    pMaker = pPassBlend.generateFXMaker(pPassInput, this._pCurrentSurfaceMaterial, this._pCurrentBufferMap);
                    if (((pMaker) === null)) {
                        return;
                    }
                }
                //TODO: generate input from PassInputBlend to correct unifoms and attributes list
                //TODO: generate RenderEntry
                //this.clearPreRenderState();
                var pInput = pMaker._make(pPassInput, this._pCurrentBufferMap);
                var pRenderer = this._pEngine.getRenderer();
                var pEntry = pRenderer.createEntry();
                pEntry.maker = pMaker;
                pEntry.input = pInput;
                pEntry.viewport = this._pCurrentViewport;
                pEntry.bufferMap = this._pCurrentBufferMap;
                this.prepareRenderTarget(pEntry, pRenderTechnique, iPass);
                pRenderer.pushEntry(pEntry);
            };
            Composer.prototype._loadEffectFromSyntaxTree = //-----------------------------------------------------------------------------//
            //-----------------------API for load components/AFXEffects--------------------//
            //-----------------------------------------------------------------------------//
            function (pTree, sFileName) {
                var pEffect = new akra.fx.Effect(this);
                // LOG(sFileName, pTree);
                pEffect.setAnalyzedFileName(sFileName);
                // LOG("\n\n\n-------------------------Try to analyze '" + sFileName + "'-------------");
                var isOk = pEffect.analyze(pTree);
                if (isOk) {
                    // LOG("------ANALYZE IS GOOD '" + sFileName + "'.")
                    var pTechniqueList = pEffect.getTechniqueList();
                    for(var i = 0; i < pTechniqueList.length; i++) {
                        isOk = this.initComponent(pTechniqueList[i]);
                        if (!isOk) {
 {
                                akra.logger.setSourceLocation("fx/Composer.ts", 542);
                                akra.logger.warning("Cannot initialize fx-component from technique '" + pTechniqueList[i].getName() + "'.");
                            }
                            ;
                            return false;
                        }
                    }
                } else {
 {
                        akra.logger.setSourceLocation("fx/Composer.ts", 548);
                        akra.logger.warning("Error are occured during analyze of effect file '" + sFileName + "'.");
                    }
                    ;
                    return false;
                }
                return true;
            };
            Composer.prototype._loadEffectFromBinary = function (pData, sFileName) {
                return false;
            };
            Composer.prototype.initComponent = function (pTechnique) {
                var sTechniqueName = pTechnique.getName();
                var pComponentPool = this._pEngine.getResourceManager().componentPool;
                if (!((pComponentPool.findResource(sTechniqueName)) === null)) {
                    return false;
                }
                var pComponent = pComponentPool.createResource(sTechniqueName);
                pComponent.create();
                pComponent.setTechnique(pTechnique);
                return true;
            };
            Composer.prototype.clearPreRenderState = function () {
                // this._pPreRenderState.primType = 0;
                // this._pPreRenderState.offset = 0;
                // this._pPreRenderState.length = 0;
                // this._pPreRenderState.index = null;
                // this._pPreRenderState.flows.clear(false);
                // this._pPreRenderState.isClear = true;
                            };
            Composer.prototype._calcRenderID = function (pSceneObject, pRenderable, bCreateIfNotExists) {
                if (typeof bCreateIfNotExists === "undefined") { bCreateIfNotExists = false; }
                //assume, that less than 1024 draw calls may be & less than 1024 scene object will be rendered.
                //beacause only 1024
                var iSceneObjectGuid = ((pSceneObject) === null) ? 0 : pSceneObject.getGuid();
                var iRenderableObjectGuid = ((pRenderable) === null) ? akra.MAX_UINT32 : pRenderable.getGuid();
                if (this._nRidSO === 1024 || this._nRidRE === 1024) {
                    this._pRidTable = {};
                    this._nRidRE = 0;
                    this._nRidSO = 0;
                }
                var pRidTable = this._pRidTable;
                var pRidMap = this._pRidMap;
                var pRidByRenderable = pRidTable[iSceneObjectGuid];
                var pRidPair;
                var iRid = 0;
                if (!((pRidByRenderable) != null)) {
                    if (!bCreateIfNotExists) {
                        return 0;
                    }
                    pRidByRenderable = pRidTable[iSceneObjectGuid] = {};
                    pRidByRenderable[0] = this._nRidSO++;
                }
                iRid = pRidByRenderable[iRenderableObjectGuid];
                if (!((iRid) != null)) {
                    if (!bCreateIfNotExists) {
                        // LOG("here...")
                        return 1 + pRidByRenderable[0] * 1024;
                    }
                    pRidByRenderable[iRenderableObjectGuid] = iRid = 1 + pRidByRenderable[0] * 1024 + this._nRidRE;
                    pRidPair = pRidMap[iRid];
                    if (!((pRidPair) != null)) {
                        pRidPair = pRidMap[iRid] = {
                            renderable: null,
                            object: null
                        };
                    }
                    // LOG("render pair created with id: ", iRid, "roid(", iRenderableObjectGuid, "): ", this._nRidRE, "soid(", iSceneObjectGuid,"): ", pRidByRenderable[0]);
                    pRidPair.renderable = pRenderable;
                    pRidPair.object = pSceneObject;
                    this._nRidRE++;
                }
                return iRid;
            };
            Composer.prototype._getRenderableByRid = /** @inline */function (iRid) {
                var pRidPair = this._pRidMap[iRid];
                return ((pRidPair) != null) ? pRidPair.renderable : null;
            };
            Composer.prototype._getObjectByRid = /** @inline */function (iRid) {
                var pRidPair = this._pRidMap[iRid];
                return ((pRidPair) != null) ? pRidPair.object : null;
            };
            Composer.prototype.applySystemUnifoms = function (pPassInput) {
                var pSceneObject = ((this)._pCurrentSceneObject);
                var pViewport = ((this)._pCurrentViewport);
                var pRenderable = ((this)._pCurrentRenderable);
                var iRenderableID = this._calcRenderID(pSceneObject, pRenderable, true);
                if (!((pSceneObject) === null)) {
                    if (pPassInput.hasUniform("MODEL_MATRIX")) {
                        pPassInput.uniforms["MODEL_MATRIX"] = pSceneObject.worldMatrix;
                    }
                    ;
                }
                if (!((pViewport) === null)) {
                    if (pPassInput.hasUniform("FRAMEBUFFER_SIZE")) {
                        pPassInput.uniforms["FRAMEBUFFER_SIZE"] = akra.Vec2.stackCeil.set(pViewport.width, pViewport.height);
                    }
                    ;
                    var pCamera = pViewport.getCamera();
                    if (!((pCamera) === null)) {
                        if (pPassInput.hasUniform("VIEW_MATRIX")) {
                            pPassInput.uniforms["VIEW_MATRIX"] = pCamera.viewMatrix;
                        }
                        ;
                        if (pPassInput.hasUniform("PROJ_MATRIX")) {
                            pPassInput.uniforms["PROJ_MATRIX"] = pCamera.projectionMatrix;
                        }
                        ;
                        if (pPassInput.hasUniform("INV_VIEW_CAMERA_MAT")) {
                            pPassInput.uniforms["INV_VIEW_CAMERA_MAT"] = pCamera.worldMatrix;
                        }
                        ;
                        if (pPassInput.hasUniform("CAMERA_POSITION")) {
                            pPassInput.uniforms["CAMERA_POSITION"] = pCamera.worldPosition;
                        }
                        ;
                        if (pCamera.type === akra.EEntityTypes.SHADOW_CASTER) {
                            if (pPassInput.hasUniform("OPTIMIZED_PROJ_MATRIX")) {
                                pPassInput.uniforms["OPTIMIZED_PROJ_MATRIX"] = (pCamera).optimizedProjection;
                            }
                            ;
                        }
                    }
                }
                if (!((pRenderable) === null)) {
                    if (((pRenderable).type === /*checked (origin: akra)>>*/akra.ERenderDataTypes.MESH_SUBSET) && (pRenderable).isSkinned()) {
                        if (pPassInput.hasUniform("BIND_SHAPE_MATRIX")) {
                            pPassInput.uniforms["BIND_SHAPE_MATRIX"] = (pRenderable).skin.getBindMatrix();
                        }
                        ;
                    }
                    if (pPassInput.hasUniform("RENDER_OBJECT_ID")) {
                        pPassInput.uniforms["RENDER_OBJECT_ID"] = iRenderableID;
                    }
                    ;
                }
                if (!((this._pLastRenderTarget) === null)) {
                    var pLastTexture = this._pLastRenderTarget === this._pRenderTargetA ? this._pPostEffectTextureA : this._pPostEffectTextureB;
                    pPassInput.setTexture("INPUT_TEXTURE", pLastTexture);
                    pPassInput.setSamplerTexture("INPUT_SAMPLER", pLastTexture);
                    if (pPassInput.hasUniform("INPUT_TEXTURE_SIZE")) {
                        pPassInput.uniforms["INPUT_TEXTURE_SIZE"] = akra.Vec2.stackCeil.set(pLastTexture.width, pLastTexture.height);
                    }
                    ;
                    if (pPassInput.hasUniform("INPUT_TEXTURE_RATIO")) {
                        pPassInput.uniforms["INPUT_TEXTURE_RATIO"] = akra.Vec2.stackCeil.set(this._pCurrentViewport.actualWidth / pLastTexture.width, this._pCurrentViewport.actualHeight / pLastTexture.height);
                    }
                    ;
                }
                if (pPassInput.hasUniform("useNormal")) {
                    pPassInput.uniforms["useNormal"] = this.bUseNormalMap;
                }
                ;
                if (pPassInput.hasUniform("isDebug")) {
                    pPassInput.uniforms["isDebug"] = this.bIsDebug;
                }
                ;
                if (pPassInput.hasUniform("isRealNormal")) {
                    pPassInput.uniforms["isRealNormal"] = this.bIsRealNormal;
                }
                ;
                if (pPassInput.hasUniform("normalFix")) {
                    pPassInput.uniforms["normalFix"] = this.bNormalFix;
                }
                ;
                if (pPassInput.hasUniform("isWithBalckSectors")) {
                    pPassInput.uniforms["isWithBalckSectors"] = this.bTerrainBlackSectors;
                }
                ;
                if (pPassInput.hasUniform("showTriangles")) {
                    pPassInput.uniforms["showTriangles"] = this.bShowTriangles;
                }
                ;
                if (pPassInput.hasUniform("u1")) {
                    pPassInput.uniforms["u1"] = 64;
                }
                ;
            };
            Composer.prototype.prepareComposerState = function () {
                if (!((this._pCurrentRenderable) === null)) {
                    this._pComposerState.renderable.isAdvancedIndex = this._pCurrentRenderable.data.useAdvancedIndex();
                    if (((this._pCurrentRenderable).type === /*checked (origin: akra)>>*/akra.ERenderDataTypes.MESH_SUBSET) && (this._pCurrentRenderable).isSkinned()) {
                        this._pComposerState.mesh.isSkinned = true;
                        if ((this._pCurrentRenderable).isOptimizedSkinned()) {
                            this._pComposerState.mesh.isOptimizedSkinned = true;
                        } else {
                            this._pComposerState.mesh.isOptimizedSkinned = false;
                        }
                        // this._pComposerState.mesh.isOptimizedSkinned = false;
                                            } else {
                        this._pComposerState.mesh.isSkinned = false;
                        this._pComposerState.mesh.isOptimizedSkinned = false;
                    }
                }
                if (!((this._pCurrentSceneObject) === null)) {
                    if (this._pCurrentSceneObject.type === akra.EEntityTypes.TERRAIN_ROAM) {
                        this._pComposerState.terrain.isROAM = true;
                    } else {
                        this._pComposerState.terrain.isROAM = false;
                    }
                }
            };
            Composer.prototype.initPostEffectTextures = function () {
                var pRmgr = this._pEngine.getResourceManager();
                this._pPostEffectTextureA = pRmgr.createTexture(".global-post-effect-texture-A");
                this._pPostEffectTextureB = pRmgr.createTexture(".global-post-effect-texture-B");
                this._pPostEffectTextureA.create(512, 512, 1, null, akra.ETextureFlags.RENDERTARGET, 0, 0, akra.ETextureTypes.TEXTURE_2D, akra.EPixelFormats.R8G8B8A8);
                this._pPostEffectTextureB.create(512, 512, 1, null, akra.ETextureFlags.RENDERTARGET, 0, 0, akra.ETextureTypes.TEXTURE_2D, akra.EPixelFormats.R8G8B8A8);
                // this._pPostEffectTextureA.notifyLoaded();
                // this._pPostEffectTextureB.notifyLoaded();
                this._pRenderTargetA = this._pPostEffectTextureA.getBuffer().getRenderTarget();
                this._pRenderTargetB = this._pPostEffectTextureB.getBuffer().getRenderTarget();
                this._pPostEffectDepthBuffer = pRmgr.renderBufferPool.createResource(".global-post-effect-depth");
                (this._pPostEffectDepthBuffer).create(0x1902, 512, 512, false);
                this._pRenderTargetA.attachDepthPixelBuffer(this._pPostEffectDepthBuffer);
            };
            Composer.prototype.resizePostEffectTextures = function (iWidth, iHeight) {
                iWidth = akra.math.ceilingPowerOfTwo(iWidth);
                iHeight = akra.math.ceilingPowerOfTwo(iHeight);
                this._pPostEffectTextureA.reset(iWidth, iHeight);
                this._pPostEffectTextureB.reset(iWidth, iHeight);
            };
            Composer.prototype.prepareRenderTarget = function (pEntry, pRenderTechnique, iPass) {
                var pRenderer = this._pEngine.getRenderer();
                if (pRenderTechnique.hasGlobalPostEffect()) {
                    if (!pRenderTechnique.isFirstPass(iPass)) {
                        pRenderer._setDepthBufferParams(false, false, 0);
                        pRenderer._setRenderTarget(this._pRenderTargetA);
                        pRenderer.clearFrameBuffer(akra.EFrameBufferTypes.COLOR | akra.EFrameBufferTypes.DEPTH, akra.Color.ZERO, 1., 0);
                        if (pEntry.viewport.getClearEveryFrame()) {
                            var pViewportState = pEntry.viewport._getViewportState();
                            pRenderer.clearFrameBuffer(pViewportState.clearBuffers, pViewportState.clearColor, pViewportState.clearDepth, 0);
                        }
                    }
                    if (pEntry.viewport.actualWidth > this._pRenderTargetA.width || pEntry.viewport.actualHeight > this._pRenderTargetA.height) {
                        this.resizePostEffectTextures(pEntry.viewport.actualWidth, pEntry.viewport.actualHeight);
                    }
                    if (!pRenderTechnique.isPostEffectPass(iPass)) {
                        this._pLastRenderTarget = this._pRenderTargetA;
                        pEntry.renderTarget = this._pRenderTargetA;
                    } else {
                        if (pRenderTechnique.isLastPass(iPass)) {
                            this._pLastRenderTarget = null;
                            // pEntry.renderTarget = null;
                                                    } else {
                            if (this._pLastRenderTarget === this._pRenderTargetA) {
                                pEntry.renderTarget = this._pRenderTargetB;
                                this._pLastRenderTarget = this._pRenderTargetB;
                            } else {
                                pEntry.renderTarget = this._pRenderTargetA;
                                this._pLastRenderTarget = this._pRenderTargetA;
                            }
                        }
                    }
                }
            };
            return Composer;
        })();
        fx.Composer = Composer;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
//  DDS_header.dwFlags
//  DDS_header.ddspf.dwFlags
//  DDS_header.dwCaps2
//DDS_header10.dwMiscFlag
//  DD_Sheader.ddspf.dwFourCC
var akra;
(function (akra) {
    var DDSCodec = (function (_super) {
        __extends(DDSCodec, _super);
        function DDSCodec() {
            _super.apply(this, arguments);

            this._sType = "dds";
        }
        DDSCodec._pInstance = null;
        DDSCodec.prototype.magicNumberToFileExt = function (pMagicNumber) {
            var dwMagic4 = (new Uint32Array(pMagicNumber.buffer, 0, 1))[0];
            if (0x20534444 == dwMagic4) {
                return "dds";
            }
            return null;
        };
        DDSCodec.startup = /// Static method to startup and register the DDS codec
        function startup() {
            if (!((this._pInstance) != null)) {
 {
                    akra.logger.setSourceLocation("pixelUtil/DDSCodec.ts", 163);
                    akra.logger.log("DDS codec registering ...");
                }
                ;
                this._pInstance = new DDSCodec();
                akra.Codec.registerCodec(this._pInstance);
            }
        };
        DDSCodec.shutdown = /// Static method to shutdown and unregister the DDS codec
        function shutdown() {
            if (((this._pInstance) !== undefined)) {
                akra.Codec.unRegisterCodec(this._pInstance);
                this._pInstance = undefined;
            }
        };
        DDSCodec.prototype.getType = function () {
            return this._sType;
        };
        DDSCodec.prototype.decode = function (pData, pImgData) {
            var iOffset = 0;
            var dwMagic4 = (new Uint32Array(pData.buffer, pData.byteOffset, 1))[0];
            if (dwMagic4 !== 0x20534444) {
 {
                    akra.logger.setSourceLocation("pixelUtil/DDSCodec.ts", 190);
                    akra.logger.criticalError("This is not a DDS file! DDSCodec.decode");
                }
                ;
            }
            //Считываем dds header
            /*typedef struct {
            DWORD           dwSize;
            DWORD           dwFlags;
            DWORD           dwHeight;
            DWORD           dwWidth;
            DWORD           dwPitchOrLinearSize;
            DWORD           dwDepth;
            DWORD           dwMipMapCount;
            DWORD           dwReserved1[11];
            DDS_PIXELFORMAT ddspf;
            DWORD           dwCaps;
            DWORD           dwCaps2;
            DWORD           dwCaps3;
            DWORD           dwCaps4;
            DWORD           dwReserved2;
            } DDS_HEADER;*/
            var pDDSHeader = new Uint32Array(pData.buffer, pData.byteOffset + 4, 31);
            var pHeader = {};
            pHeader.dwSize = pDDSHeader[0];
            pHeader.dwFlags = pDDSHeader[1];
            pHeader.dwHeight = pDDSHeader[2];
            pHeader.dwWidth = pDDSHeader[3];
            pHeader.dwPitchOrLinearSize = pDDSHeader[4];
            pHeader.dwDepth = pDDSHeader[5];
            pHeader.dwMipMapCount = pDDSHeader[6];
            pHeader.dwReserved1 = [];
            pHeader.dwReserved1[0] = pDDSHeader[7];
            pHeader.dwReserved1[1] = pDDSHeader[8];
            pHeader.dwReserved1[2] = pDDSHeader[9];
            pHeader.dwReserved1[3] = pDDSHeader[10];
            pHeader.dwReserved1[4] = pDDSHeader[11];
            pHeader.dwReserved1[5] = pDDSHeader[12];
            pHeader.dwReserved1[6] = pDDSHeader[13];
            pHeader.dwReserved1[7] = pDDSHeader[14];
            pHeader.dwReserved1[8] = pDDSHeader[15];
            pHeader.dwReserved1[9] = pDDSHeader[16];
            pHeader.dwReserved1[10] = pDDSHeader[17];
            /*struct DDS_PIXELFORMAT {
            DWORD dwSize;
            DWORD dwFlags;
            DWORD dwFourCC;
            DWORD dwRGBBitCount;
            DWORD dwRBitMask;
            DWORD dwGBitMask;
            DWORD dwBBitMask;
            DWORD dwABitMask;
            };*/
            pHeader.ddspf = {};
            pHeader.ddspf.dwSize = pDDSHeader[18];
            pHeader.ddspf.dwFlags = pDDSHeader[19];
            pHeader.ddspf.dwFourCC = pDDSHeader[20];
            pHeader.ddspf.dwRGBBitCount = pDDSHeader[21];
            pHeader.ddspf.dwRBitMask = pDDSHeader[22];
            pHeader.ddspf.dwGBitMask = pDDSHeader[23];
            pHeader.ddspf.dwBBitMask = pDDSHeader[24];
            pHeader.ddspf.dwABitMask = pDDSHeader[25];
            pHeader.dwCaps = pDDSHeader[26];
            pHeader.dwCaps2 = pDDSHeader[27];
            pHeader.dwCaps3 = pDDSHeader[28];
            pHeader.dwCaps4 = pDDSHeader[29];
            pHeader.dwReserved2 = pDDSHeader[30];
            iOffset += 128;
            if (pHeader.dwSize != 124) {
 {
                    akra.logger.setSourceLocation("pixelUtil/DDSCodec.ts", 259);
                    akra.logger.error("Размер заголовка DDS всегда должэен равняться 124");
                }
                ;
            }
            if (pHeader.ddspf.dwSize != 32) {
 {
                    akra.logger.setSourceLocation("pixelUtil/DDSCodec.ts", 262);
                    akra.logger.error("Размер DDS_PIXELFORMAT всегда должен равняться 32");
                }
                ;
            }
            if (!(pHeader.dwFlags & 0x00000001)) {
 {
                    akra.logger.setSourceLocation("pixelUtil/DDSCodec.ts", 265);
                    akra.logger.error("Флаг DDSD_CAPS в заголовке DDS всегда должен быть");
                }
                ;
            }
            if (!(pHeader.dwFlags & 0x00000002)) {
 {
                    akra.logger.setSourceLocation("pixelUtil/DDSCodec.ts", 268);
                    akra.logger.error("Флаг DDSD_HEIGHT в заголовке DDS всегда должен быть");
                }
                ;
            }
            if (!(pHeader.dwFlags & 0x00000004)) {
 {
                    akra.logger.setSourceLocation("pixelUtil/DDSCodec.ts", 271);
                    akra.logger.error("Флаг DDSD_WIDTH в заголовке DDS всегда должен быть");
                }
                ;
            }
            if (!(pHeader.dwFlags & 0x00001000)) {
 {
                    akra.logger.setSourceLocation("pixelUtil/DDSCodec.ts", 274);
                    akra.logger.error("Флаг DDSD_PIXELFORMAT в заголовке DDS всегда должен быть");
                }
                ;
            }
            pImgData.width = pHeader.dwWidth;
            pImgData.height = pHeader.dwHeight;
            pImgData.depth = 1;
            var nFace = 1;
            pImgData.flags = 0;
            if (pHeader.dwCaps2 & 0x200) {
                pImgData.flags |= akra.EImageFlags.CUBEMAP;
                nFace = 0;
                if (pHeader.dwCaps2 & 0x400) {
                    nFace++;
                    pImgData.cubeFlags |= akra.EImageCubeFlags.POSITIVE_X;
                }
                if (pHeader.dwCaps2 & 0x800) {
                    nFace++;
                    pImgData.cubeFlags |= akra.EImageCubeFlags.NEGATIVE_X;
                }
                if (pHeader.dwCaps2 & 0x1000) {
                    nFace++;
                    pImgData.cubeFlags |= akra.EImageCubeFlags.POSITIVE_Y;
                }
                if (pHeader.dwCaps2 & 0x2000) {
                    nFace++;
                    pImgData.cubeFlags |= akra.EImageCubeFlags.NEGATIVE_Y;
                }
                if (pHeader.dwCaps2 & 0x4000) {
                    nFace++;
                    pImgData.cubeFlags |= akra.EImageCubeFlags.POSITIVE_Z;
                }
                if (pHeader.dwCaps2 & 0x8000) {
                    nFace++;
                    pImgData.cubeFlags |= akra.EImageCubeFlags.NEGATIVE_Z;
                }
                if (nFace == 0) {
 {
                        akra.logger.setSourceLocation("pixelUtil/DDSCodec.ts", 314);
                        akra.logger.warning("Выставлен фдлаг с кубической текстурой, а самих текстур нету");
                    }
                    ;
                }
            }
            if (pHeader.dwCaps2 & 0x200000) {
                pImgData.flags |= akra.EImageFlags.TEXTURE_3D;
                pImgData.depth = pHeader.dwDepth;
            }
            var eSourceFormat = akra.EPixelFormats.UNKNOWN;
            if (pHeader.ddspf.dwFlags & 0x00000004) {
                if (pHeader.ddspf.dwFourCC == 0x31545844) {
                    eSourceFormat = akra.EPixelFormats.DXT1;
                } else if (pHeader.ddspf.dwFourCC == 0x32545844) {
                    eSourceFormat = akra.EPixelFormats.DXT1;
                } else if (pHeader.ddspf.dwFourCC == 0x33545844) {
                    eSourceFormat = akra.EPixelFormats.DXT3;
                } else if (pHeader.ddspf.dwFourCC == 0x34545844) {
                    eSourceFormat = akra.EPixelFormats.DXT4;
                } else if (pHeader.ddspf.dwFourCC == 0x35545844) {
                    eSourceFormat = akra.EPixelFormats.DXT5;
                } else if (pHeader.ddspf.dwFourCC == 0x30315844) {
                    var pDDS10Header = new Uint32Array(pData.buffer, pData.byteOffset + 128, 5);
                    var header10 = {};
                    header10.dxgiFormat = pDDS10Header[0];
                    header10.resourceDimension = pDDS10Header[1];
                    header10.miscFlag = pDDS10Header[2];
                    header10.arraySize = pDDS10Header[3];
                    header10.reserved = pDDS10Header[4];
 {
                        akra.logger.setSourceLocation("pixelUtil/DDSCodec.ts", 351);
                        akra.logger.criticalError("Формат D3DFMT_DX10 не поддерживается");
                    }
                    ;
                    /*console.log("dxgiFormat",header10.dxgiFormat);
                    console.log("resourceDimension",header10.resourceDimension);
                    nCubeMap=1;
                    if(header10.miscFlag&RESOURCE_MISC_TEXTURECUBE)
                    {
                    nCubeMap=header10.arraySize;
                    }
                    
                    if(nCubeMap!=6)
                    {
                    warning("Количество частей кубической текстуру не равно 6",nCubeMap);
                    }*/
                    iOffset += 20;
                } else if (pHeader.ddspf.dwFourCC == 0x0000006F) {
                    eSourceFormat = akra.EPixelFormats.FLOAT16_R;
                } else if (pHeader.ddspf.dwFourCC == 0x00000070) {
                    eSourceFormat = akra.EPixelFormats.FLOAT16_GR;
                } else if (pHeader.ddspf.dwFourCC == 0x00000071) {
                    eSourceFormat = akra.EPixelFormats.FLOAT16_RGBA;
                } else if (pHeader.ddspf.dwFourCC == 0x00000072) {
                    eSourceFormat = akra.EPixelFormats.FLOAT32_R;
                } else if (pHeader.ddspf.dwFourCC == 0x00000073) {
                    eSourceFormat = akra.EPixelFormats.FLOAT32_GR;
                } else if (pHeader.ddspf.dwFourCC == 0x00000074) {
                    eSourceFormat = akra.EPixelFormats.FLOAT32_RGBA;
                } else {
 {
                        akra.logger.setSourceLocation("pixelUtil/DDSCodec.ts", 391);
                        akra.logger.criticalError("Флаг DDPF_FOURCC стоит, а подходящего dwFourCC нет");
                    }
                    ;
                }
            } else {
                var iAMask = pHeader.ddspf.dwFlags & 0x00000001 ? pHeader.ddspf.dwABitMask : 0;
                var ePF;
                for(ePF = akra.EPixelFormats.UNKNOWN + 1; ePF < akra.EPixelFormats.TOTAL; ePF++) {
                    if ((!!(pHeader.ddspf.dwFlags & 0x00020000)) != (((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor(((ePF))).flags) & /*checked (origin: akra)>>*/akra.EPixelFormatFlags.LUMINANCE) > 0)) {
                        continue;
                    }
                    if ((!!(pHeader.ddspf.dwFlags & 0x00000001)) != (((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor(((ePF))).flags) & /*checked (origin: akra)>>*/akra.EPixelFormatFlags.HASALPHA) > 0)) {
                        continue;
                    }
                    if ((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor((ePF)).elemBytes * 8) == pHeader.ddspf.dwRGBBitCount) {
                        var pTestMasks = akra.pixelUtil.getBitMasks(ePF);
                        var pTestBits = akra.pixelUtil.getBitDepths(ePF);
                        if (pTestMasks[0] == pHeader.ddspf.dwRBitMask && pTestMasks[1] == pHeader.ddspf.dwGBitMask && pTestMasks[2] == pHeader.ddspf.dwBBitMask && // for alpha, deal with 'X8' formats by checking bit counts
                        (pTestMasks[3] == iAMask || (iAMask == 0 && pTestBits[3] == 0))) {
                            break;
                        }
                    }
                }
                if (ePF == akra.EPixelFormats.TOTAL) {
 {
                        akra.logger.setSourceLocation("pixelUtil/DDSCodec.ts", 430);
                        akra.logger.criticalError("Cannot determine pixel format. DDSCodec.decode");
                    }
                    ;
                } else {
                    eSourceFormat = ePF;
                }
            }
            /*if (pixelUtil.isCompressed(eSourceFormat))
            {
            pImgData.flags |= EImageFlags.COMPRESSED;
            if (!(pHeader.dwFlags & DDSD_LINEARSIZE)) {
            CRITICAL_ERROR("У сжатой текстуры не выставлен флаг DDS_HEADER_FLAGS_LINEARSIZE в заголовке");
            }
            }
            else
            {
            if (pHeader.dwFlags & DDSD_LINEARSIZE) {
            CRITICAL_ERROR("У несжатой текстуры выставлен флаг DDS_HEADER_FLAGS_LINEARSIZE в заголовке");
            }
            }*/
            pImgData.format = eSourceFormat;
            if (pHeader.dwFlags & 0x00020000) {
                pImgData.numMipMaps = pHeader.dwMipMapCount - 1;
                if (pImgData.numMipMaps != akra.core.pool.resources.Img.getMaxMipmaps(pImgData.width, pImgData.height, pImgData.depth, pImgData.format)) {
 {
                        akra.logger.setSourceLocation("pixelUtil/DDSCodec.ts", 460);
                        akra.logger.warning("Number of mipmaps are not to degrease image size to 1x1 " + pHeader.dwMipMapCount + "," + pHeader.dwWidth + "x" + pHeader.dwHeight + ")");
                    }
                    ;
                }
            } else {
                pImgData.numMipMaps = 0;
            }
            var pOutput = new Uint8Array(pImgData.size);
            var iOutputOffset = 0;
            for(var i = 0; i < nFace; i++) {
                var iWidth = pImgData.width;
                var iHeight = pImgData.height;
                var iDepth = pImgData.depth;
                for(var iMip = 0; iMip <= pImgData.numMipMaps; iMip++) {
                    if ((((/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor(((pImgData.format))).flags) & /*checked (origin: akra)>>*/akra.EPixelFormatFlags.COMPRESSED) > 0)) {
                        var iDXTSize = akra.pixelUtil.getMemorySize(iWidth, iHeight, iDepth, pImgData.format);
                        for(var a = 0; a < iDXTSize; a++) {
                            pOutput[a + iOutputOffset] = pData[iOffset + a];
                        }
                        iOffset += iDXTSize;
                        iOutputOffset += iDXTSize;
                    } else {
                        var iDstPitch = iWidth * (/*not inlined, because supportes only single statement functions(cur. st. count: 5)*//*checked (origin: pixelUtil)>>*/akra.pixelUtil.getDescriptionFor((pImgData.format)).elemBytes);
                        var iSrcPitch = 0;
                        if (pHeader.dwFlags & 0x00000008) {
                            iSrcPitch = pHeader.dwPitchOrLinearSize / Math.max(1, iMip * 2);
                        } else {
                            // assume same as final pitch
                            iSrcPitch = iDstPitch;
                        }
                        if (iSrcPitch < iDstPitch) {
 {
                                akra.logger.setSourceLocation("pixelUtil/DDSCodec.ts", 507);
                                akra.logger.warning("Странный размер питча у картинки");
                            }
                        }
                        for(var z = 0; z < pImgData.depth; z++) {
                            for(var y = 0; y < pImgData.height; y++) {
                                for(var a = 0; a < iDstPitch; a++) {
                                    pOutput[a + iOutputOffset] = pData[iOffset + a];
                                }
                                iOutputOffset = iOutputOffset + iDstPitch;
                                iOffset = iOffset + iSrcPitch;
                            }
                        }
                    }
                    if (iWidth != 1) {
                        iWidth = Math.floor(iWidth / 2);
                    }
                    if (iHeight != 1) {
                        iHeight = Math.floor(iHeight / 2);
                    }
                    if (iDepth != 1) {
                        iDepth = Math.floor(iDepth / 2);
                    }
                }
            }
            return pOutput;
        };
        return DDSCodec;
    })(akra.ImgCodec);
    akra.DDSCodec = DDSCodec;    
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        (function (EDepsManagerStates) {
            EDepsManagerStates._map = [];
            EDepsManagerStates._map[0] = "IDLE";
            EDepsManagerStates.IDLE = 0;
            EDepsManagerStates._map[1] = "LOADING";
            EDepsManagerStates.LOADING = 1;
        })(util.EDepsManagerStates || (util.EDepsManagerStates = {}));
        var EDepsManagerStates = util.EDepsManagerStates;
        var DepsManager = (function () {
            // protected _iTotalBytesLoaded: uint = 0;
            // protected _iTotalDepth: uint = 0;
            function DepsManager(pEngine) {
                /**@protected*/ this._eState = EDepsManagerStates.IDLE;
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
                this._pEngine = pEngine;
            }
            DepsManager.prototype.getEngine = /** @inline */function () {
                return this._pEngine;
            };
            DepsManager.prototype.load = function (pDeps, sRoot) {
                if (typeof sRoot === "undefined") { sRoot = null; }
                if (!((pDeps) != null)) {
                    return false;
                }
                if (this._eState === EDepsManagerStates.LOADING) {
 {
                        util.logger.setSourceLocation("util/DepsManager.ts", 36);
                        util.logger.warning("deps manager in loading state");
                    }
                    ;
                    return false;
                }
                this.generateDepInfo(pDeps);
                this.normalizeDepsPaths(pDeps, pDeps.root || sRoot);
                this.createDepsResources(pDeps);
                this.loadDeps(pDeps);
                return true;
            };
            DepsManager.prototype.walk = function (pDeps, fn, iDepth) {
                if (typeof iDepth === "undefined") { iDepth = 0; }
                var pFiles = pDeps.files;
                if (((pFiles) != null)) {
                    //normilize pathes to deps
                    for(var i = 0; i < pFiles.length; ++i) {
                        fn.call(this, pDeps, i, iDepth);
                    }
                }
                if (((pDeps.deps) != null)) {
                    this.walk(pDeps.deps, fn, ++iDepth);
                }
            };
            DepsManager.prototype.generateDepInfo = function (pDeps) {
                var pCurr = pDeps;
                var pInfo = [];
                while(((pCurr) != null)) {
                    pInfo.push(pCurr.files ? pCurr.files.length : 0);
                    pCurr = pCurr.deps;
                }
                this.beforeLoad(pInfo);
            };
            DepsManager.prototype.normalizeDepsPaths = function (pDeps, sRoot) {
                this.walk(pDeps, function (pDeps, i) {
                    pDeps.files[i].path = akra.util.URI.resolve(pDeps.files[i].path, sRoot || document.location.pathname);
                });
            };
            DepsManager.prototype.createDepsResources = function (pDeps) {
                var pRmgr = ((this)._pEngine).getResourceManager();
                this.walk(pDeps, function (pDeps, i, iDepth) {
                    var pFiles = pDeps.files;
                    var sResource = pFiles[i].name || pFiles[i].path;
                    switch(util.pathinfo(pFiles[i].path).ext.toLowerCase()) {
                        case "fx":
                        case "afx":
                            if (!pRmgr.effectDataPool.findResource(sResource)) {
                                pRmgr.effectDataPool.createResource(sResource);
                            }
                            break;
                        case "jpg":
                        case "jpeg":
                        case "png":
                        case "bmp":
                        case "gif":
                        case "dds":
                            if (!pRmgr.imagePool.findResource(sResource)) {
                                pRmgr.imagePool.createResource(sResource);
                            }
                            break;
                        case "dae":
                            if (!pRmgr.colladaPool.findResource(sResource)) {
                                pRmgr.colladaPool.createResource(sResource);
                            }
                            break;
                    }
                });
            };
            DepsManager.prototype.loadDeps = function (pDeps, iDepth) {
                if (typeof iDepth === "undefined") { iDepth = 0; }
                var _this = this;
                var pRmgr = ((this)._pEngine).getResourceManager();
                //if got empty dependency.
                if (!akra.isArray(pDeps.files) || pDeps.files.length === 0) {
                    /*, 0*/
                    this._onDependencyLoad(pDeps, iDepth, -1);
                }
                //walk single deps level
                this.walk({
                    files: pDeps.files
                }, function (pDep, i, iDepth) {
                    var pFiles = pDeps.files;
                    var pManager = _this;
                    var pRes;
                    if (((pDep.type) != null)) {
                        if (pDep.type == "text" && (/*checked (origin: akra)>>*/akra.typeOf((pDep.loader)) === "function")) {
                            var pFile = akra.io.fopen(pFiles[i].path, "r");
                            pFile.read(function (pErr, sData) {
                                if (!((pErr) === null)) {
                                    pManager.error(pErr);
                                }
                                pDep.loader(pDep, sData);
                                /*, pFile.byteLength*/
                                pManager._onDependencyLoad(pDeps, iDepth, i);
                            });
                        }
                    }
                    var sResource = pFiles[i].name || pFiles[i].path;
                    switch(util.pathinfo(pFiles[i].path).ext.toLowerCase()) {
                        case "gr":
                            var pGrammar = akra.io.fopen(pFiles[i].path, "r");
                            pGrammar.read(function (pErr, sData) {
                                if (!((pErr) === null)) {
                                    pManager.error(pErr);
                                }
                                //WARNING: only for HLSL grammar files.
                                akra.util.initAFXParser(sData);
                                /*, pGrammar.byteLength*/
                                pManager._onDependencyLoad(pDeps, iDepth, i);
                            });
                            break;
                        case "fx":
                        case "afx":
                            pRes = pRmgr.effectDataPool.findResource(sResource);
                            if (pRes.loadResource(pFiles[i].path)) {
                                pManager._handleResourceEventOnce(pRes, "loaded", function (pItem) {
                                    /*, (<core.pool.resources.EffectData>pItem).byteLength*/
                                    pManager._onDependencyLoad(pDeps, iDepth, i);
                                });
                            } else {
                                _this.error(new Error("could not load resource: " + pFiles[i].path));
                            }
                            break;
                        case "jpeg":
                        case "jpg":
                        case "png":
                        case "gif":
                        case "bmp":
                        case "dds":
                            pRes = pRmgr.imagePool.findResource(sResource);
                            if (pRes.loadResource(pFiles[i].path)) {
                                pManager._handleResourceEventOnce(pRes, "loaded", function (pItem) {
                                    /*, (<IImg>pItem).byteLength*/
                                    pManager._onDependencyLoad(pDeps, iDepth, i);
                                });
                            } else {
                                _this.error(new Error("could not load resource: " + pFiles[i].path));
                            }
                            break;
                        case "dae":
                            pRes = pRmgr.colladaPool.findResource(sResource);
                            if (pRes.loadResource(pFiles[i].path)) {
                                pManager._handleResourceEventOnce(pRes, "loaded", /*, (<IModel>pItem).byteLength*/
                                function (pItem) {
                                    pManager._onDependencyLoad(pDeps, iDepth, i);
                                });
                            } else {
                                _this.error(new Error("could not load resource: " + pFiles[i].path));
                            }
                            break;
                        default:
 {
                                util.logger.setSourceLocation("util/DepsManager.ts", 203);
                                util.logger.warning("dependence " + pFiles[i].path + " unknown, and will be skipped.");
                            }
                            ;
                    }
                }, iDepth);
            };
            DepsManager.prototype._handleResourceEventOnce = function (pRsc, sSignal, fnHandler) {
                var fn;
                fn = function (pItem) {
                    fnHandler(pItem);
                    pRsc.unbind(sSignal, fn);
                };
                pRsc.bind(sSignal, fn);
            };
            DepsManager.prototype._onDependencyLoad = /*, iByteLength: uint*/
            function (pDeps, iDepth, n) {
                // debug_assert(isDefAndNotNull(pDeps.files) && isString(pDeps.files[i]), "something going wrong...");
                if (n != -1) {
                    // console.log(pDeps.files[n].path, iByteLength);
                    // this._iTotalBytesLoaded += (iByteLength);
                    pDeps.files[n] = null;
                }
                var nRestDepsInLevel = 0;
                var nLoadedDepsInLevel = 0;
                var nTotalDepsInLevel = 0;
                if (akra.isArray(pDeps.files)) {
                    for(var i = 0; i < pDeps.files.length; ++i) {
                        if (!((pDeps.files[i]) === null)) {
                            // console.log("wait for: ", pDeps.files[i].path);
                            nRestDepsInLevel++;
                        }
                    }
                    ;
                    nTotalDepsInLevel = pDeps.files.length;
                    nLoadedDepsInLevel = nTotalDepsInLevel - nRestDepsInLevel;
                }
                // LOG("lvl: ", iDepth, "loaded", nLoadedDepsInLevel, "/", nTotalDepsInLevel, "total mb - ", (this._iTotalBytesLoaded / (1024 * 1024)).toFixed(2));
                this.loadedDep(iDepth, nLoadedDepsInLevel, nTotalDepsInLevel);
                if (nRestDepsInLevel > 0) {
                    return;
                }
                if (((pDeps.deps) != null)) {
                    this.loadDeps(pDeps.deps, iDepth + 1);
                } else {
                    this.loaded(pDeps);
                }
            };
            DepsManager.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            DepsManager._pEventTable = new akra.events.EventTable();
            DepsManager.prototype.getEventTable = /** @inline */function () {
                return DepsManager._pEventTable;
            };
            DepsManager.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            DepsManager.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            DepsManager.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (DepsManager._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            DepsManager.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (DepsManager._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            DepsManager.prototype._syncTable = /** @inline */function (pFrom) {
                (DepsManager._pEventTable)._sync(this, pFrom);
            };
            DepsManager.prototype.loaded = function (deps) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((DepsManager._pEventTable))).broadcast[(this._iGuid)] = (((DepsManager._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).loaded;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, deps) : _broadcast[i].listener(_recivier, deps);
                    }
                }
            };
            DepsManager.prototype.beforeLoad = function (info) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((DepsManager._pEventTable))).broadcast[(this._iGuid)] = (((DepsManager._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).beforeLoad;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, info) : _broadcast[i].listener(_recivier, info);
                    }
                }
            };
            DepsManager.prototype.loadedDep = function (depth, loaded, total) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((DepsManager._pEventTable))).broadcast[(this._iGuid)] = (((DepsManager._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).loadedDep;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, depth, loaded, total) : _broadcast[i].listener(_recivier, depth, loaded, total);
                    }
                }
            };
            DepsManager.prototype.error = // BROADCAST(error, CALL(pErr));
            function (pErr) {
                if (true) {
                    throw pErr;
                }
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((DepsManager._pEventTable))).broadcast[(this._iGuid)] = (((DepsManager._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).error;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pErr) : _broadcast[i].listener(_recivier, pErr);
                    }
                }
                ;
            };
            return DepsManager;
        })();        
        function createDepsManager(pEngine) {
 {
                util.logger.setSourceLocation("util/DepsManager.ts", 275);
                util.logger.assert(((pEngine) != null));
            }
            ;
            return new DepsManager(pEngine);
        }
        util.createDepsManager = createDepsManager;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EGamepadCodes) {
        EGamepadCodes._map = [];
        /*Face (main) buttons*/
        EGamepadCodes.FACE_1 = 0;
        EGamepadCodes.FACE_2 = 1;
        EGamepadCodes.FACE_3 = 2;
        EGamepadCodes.FACE_4 = 3;
        /*Top shoulder buttons*/
        EGamepadCodes.LEFT_SHOULDER = 4;
        EGamepadCodes.RIGHT_SHOULDER = 5;
        /*Bottom shoulder buttons*/
        EGamepadCodes.LEFT_SHOULDER_BOTTOM = 6;
        EGamepadCodes.RIGHT_SHOULDER_BOTTOM = 7;
        EGamepadCodes.SELECT = 8;
        EGamepadCodes.START = 9;
        /*Analogue sticks (if depressible)*/
        EGamepadCodes.LEFT_ANALOGUE_STICK = 10;
        EGamepadCodes.RIGHT_ANALOGUE_STICK = 11;
        /*Directional (discrete) pad*/
        EGamepadCodes.PAD_TOP = 12;
        EGamepadCodes.PAD_BOTTOM = 13;
        EGamepadCodes.PAD_LEFT = 14;
        EGamepadCodes.PAD_RIGHT = 15;
    })(akra.EGamepadCodes || (akra.EGamepadCodes = {}));
    var EGamepadCodes = akra.EGamepadCodes;
    (function (EGamepadAxis) {
        EGamepadAxis._map = [];
        EGamepadAxis.LEFT_ANALOGUE_HOR = 0;
        EGamepadAxis.LEFT_ANALOGUE_VERT = 1;
        EGamepadAxis.RIGHT_ANALOGUE_HOR = 2;
        EGamepadAxis.RIGHT_ANALOGUE_VERT = 3;
    })(akra.EGamepadAxis || (akra.EGamepadAxis = {}));
    var EGamepadAxis = akra.EGamepadAxis;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (controls) {
        var GamepadMap = (function () {
            function GamepadMap() {
                this._bTicking = false;
                this._pCollection = new akra.util.ObjectArray();
                this._pPrevRawGamepadTypes = [
                    null, 
                    null, 
                    null, 
                    null
                ];
                this._pPrevTimestamps = [
                    0, 
                    0, 
                    0, 
                    0
                ];
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
            }
            GamepadMap.prototype.init = function () {
                if (!akra.info.api.gamepad) {
 {
                        akra.logger.setSourceLocation("controls/GamepadMap.ts", 21);
                        akra.logger.warning("Gamepad API is unsupported.");
                    }
                    ;
                    return false;
                }
                var pMap = this;
                var pCollection = this._pCollection;
                window.addEventListener('MozGamepadConnected', function (e) {
                    pCollection.push(e.gamepad);
                    pMap.connected(e.gamepad);
                    /*not inlined, because first statement is not return/call/dot(cur st.: If)*/pMap._startPolling();
                }, false);
                window.addEventListener('MozGamepadDisconnected', function (e) {
                    for(var i = 0; i < pCollection.length; ++i) {
                        if (pCollection.value(i).index == e.gamepad.index) {
                            pMap.disconnected(pCollection.takeAt(i));
                            break;
                        }
                    }
                    if (pCollection.length == 0) {
                        (pMap._bTicking = false);
                    }
                }, false);
                if (!!navigator.gamepads || !!navigator.getGamepads) {
                    /*not inlined, because first statement is not return/call/dot(cur st.: If)*/this._startPolling();
                    return true;
                }
                return false;
            };
            GamepadMap.prototype.isActive = /** @inline */function () {
                return this._bTicking;
            };
            GamepadMap.prototype.find = function (id) {
                var sID = null;
                var i = 0;
                if (arguments.length) {
                    if ((typeof (arguments[0]) === "string")) {
                        sID = arguments[0];
                    } else if ((typeof (arguments[0]) === "number")) {
                        i = arguments[0];
                    }
                }
                if (!((sID) === null)) {
                    for(i = 0; i < this._pCollection.length; ++i) {
                        if (this._pCollection.value(i).id == sID) {
                            return this._pCollection.value(i);
                        }
                    }
                }
                return this._pCollection.value(i);
            };
            GamepadMap.prototype._startPolling = /** @inline */function () {
                if (!this._bTicking) {
                    this._bTicking = true;
                    ((this).pollStatus());
                }
            };
            GamepadMap.prototype._stopPolling = /** @inline */function () {
                this._bTicking = false;
            };
            GamepadMap.prototype.update = /** @inline */function () {
                this.pollStatus();
            };
            GamepadMap.prototype.pollStatus = function () {
                if (!this._bTicking) {
                    return;
                }
                this.pollGamepads();
                for(var i = 0; i < this._pCollection.length; ++i) {
                    var pGamepad = this._pCollection.value(i);
                    if (pGamepad.timestamp && (pGamepad.timestamp == this._pPrevTimestamps[i])) {
                        continue;
                    }
                    this._pPrevTimestamps[i] = pGamepad.timestamp;
                }
            };
            GamepadMap.prototype.pollGamepads = function () {
                var pRawGamepads = (navigator.getGamepads && navigator.getGamepads()) || navigator.gamepads;
                if (((pRawGamepads) != null)) {
                    //debug_print("get raw gamepads");
                    this._pCollection.clear();
                    var isGamepadsChanged = false;
                    for(var i = 0; i < pRawGamepads.length; i++) {
                        if (typeof pRawGamepads[i] != this._pPrevRawGamepadTypes[i]) {
                            isGamepadsChanged = true;
                            this._pPrevRawGamepadTypes[i] = typeof pRawGamepads[i];
                            if (((pRawGamepads[i]) != null)) {
 {
                                    akra.logger.setSourceLocation("controls/GamepadMap.ts", 135);
                                    akra.logger.log("gamepad " + i + " updated: " + pRawGamepads[i].id);
                                }
                                ;
                                this.updated(pRawGamepads[i]);
                            }
                        }
                        if (((pRawGamepads[i]) != null)) {
                            this._pCollection.push(pRawGamepads[i]);
                        }
                    }
                    //if (isGamepadsChanged) {
                    //todo: collection changed...
                    //}
                                    }
            };
            GamepadMap.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            GamepadMap._pEventTable = new akra.events.EventTable();
            GamepadMap.prototype.getEventTable = /** @inline */function () {
                return GamepadMap._pEventTable;
            };
            GamepadMap.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            GamepadMap.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            GamepadMap.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (GamepadMap._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            GamepadMap.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (GamepadMap._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            GamepadMap.prototype._syncTable = /** @inline */function (pFrom) {
                (GamepadMap._pEventTable)._sync(this, pFrom);
            };
            GamepadMap.prototype.connected = function (pGamepad) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((GamepadMap._pEventTable))).broadcast[(this._iGuid)] = (((GamepadMap._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).connected;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pGamepad) : _broadcast[i].listener(_recivier, pGamepad);
                    }
                }
            };
            GamepadMap.prototype.disconnected = function (pGamepad) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((GamepadMap._pEventTable))).broadcast[(this._iGuid)] = (((GamepadMap._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).disconnected;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pGamepad) : _broadcast[i].listener(_recivier, pGamepad);
                    }
                }
            };
            GamepadMap.prototype.updated = function (pGamepad) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((GamepadMap._pEventTable))).broadcast[(this._iGuid)] = (((GamepadMap._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).updated;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pGamepad) : _broadcast[i].listener(_recivier, pGamepad);
                    }
                }
            };
            return GamepadMap;
        })();        
        function createGamepadMap() {
            return new GamepadMap();
        }
        controls.createGamepadMap = createGamepadMap;
    })(akra.controls || (akra.controls = {}));
    var controls = akra.controls;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EKeyCodes) {
        EKeyCodes._map = [];
        EKeyCodes.BACKSPACE = 8;
        EKeyCodes.TAB = 9;
        EKeyCodes.ENTER = 13;
        EKeyCodes.SHIFT = 16;
        EKeyCodes._map[17] = "CTRL";
        EKeyCodes.CTRL = 17;
        EKeyCodes._map[18] = "ALT";
        EKeyCodes.ALT = 18;
        EKeyCodes.PAUSE = 19;
        EKeyCodes.BREAK = 19;
        EKeyCodes.CAPSLOCK = 20;
        EKeyCodes.ESCAPE = 27;
        EKeyCodes.SPACE = 32;
        EKeyCodes.PAGEUP = 33;
        EKeyCodes._map[34] = "PAGEDOWN";
        EKeyCodes.PAGEDOWN = 34;
        EKeyCodes.END = 35;
        EKeyCodes._map[36] = "HOME";
        EKeyCodes.HOME = 36;
        EKeyCodes.LEFT = 37;
        EKeyCodes._map[38] = "UP";
        EKeyCodes.UP = 38;
        EKeyCodes._map[39] = "RIGHT";
        EKeyCodes.RIGHT = 39;
        EKeyCodes._map[40] = "DOWN";
        EKeyCodes.DOWN = 40;
        EKeyCodes.INSERT = 45;
        EKeyCodes._map[46] = "DELETE";
        EKeyCodes.DELETE = 46;
        EKeyCodes.N0 = 48;
        EKeyCodes._map[49] = "N1";
        EKeyCodes.N1 = 49;
        EKeyCodes._map[50] = "N2";
        EKeyCodes.N2 = 50;
        EKeyCodes._map[51] = "N3";
        EKeyCodes.N3 = 51;
        EKeyCodes._map[52] = "N4";
        EKeyCodes.N4 = 52;
        EKeyCodes._map[53] = "N5";
        EKeyCodes.N5 = 53;
        EKeyCodes._map[54] = "N6";
        EKeyCodes.N6 = 54;
        EKeyCodes._map[55] = "N7";
        EKeyCodes.N7 = 55;
        EKeyCodes._map[56] = "N8";
        EKeyCodes.N8 = 56;
        EKeyCodes._map[57] = "N9";
        EKeyCodes.N9 = 57;
        EKeyCodes.A = 65;
        EKeyCodes._map[66] = "B";
        EKeyCodes.B = 66;
        EKeyCodes._map[67] = "C";
        EKeyCodes.C = 67;
        EKeyCodes._map[68] = "D";
        EKeyCodes.D = 68;
        EKeyCodes._map[69] = "E";
        EKeyCodes.E = 69;
        EKeyCodes._map[70] = "F";
        EKeyCodes.F = 70;
        EKeyCodes._map[71] = "G";
        EKeyCodes.G = 71;
        EKeyCodes._map[72] = "H";
        EKeyCodes.H = 72;
        EKeyCodes._map[73] = "I";
        EKeyCodes.I = 73;
        EKeyCodes._map[74] = "J";
        EKeyCodes.J = 74;
        EKeyCodes._map[75] = "K";
        EKeyCodes.K = 75;
        EKeyCodes._map[76] = "L";
        EKeyCodes.L = 76;
        EKeyCodes._map[77] = "M";
        EKeyCodes.M = 77;
        EKeyCodes._map[78] = "N";
        EKeyCodes.N = 78;
        EKeyCodes._map[79] = "O";
        EKeyCodes.O = 79;
        EKeyCodes._map[80] = "P";
        EKeyCodes.P = 80;
        EKeyCodes._map[81] = "Q";
        EKeyCodes.Q = 81;
        EKeyCodes._map[82] = "R";
        EKeyCodes.R = 82;
        EKeyCodes._map[83] = "S";
        EKeyCodes.S = 83;
        EKeyCodes._map[84] = "T";
        EKeyCodes.T = 84;
        EKeyCodes._map[85] = "U";
        EKeyCodes.U = 85;
        EKeyCodes._map[86] = "V";
        EKeyCodes.V = 86;
        EKeyCodes._map[87] = "W";
        EKeyCodes.W = 87;
        EKeyCodes._map[88] = "X";
        EKeyCodes.X = 88;
        EKeyCodes._map[89] = "Y";
        EKeyCodes.Y = 89;
        EKeyCodes._map[90] = "Z";
        EKeyCodes.Z = 90;
        EKeyCodes.LEFTWINDOWKEY = 91;
        EKeyCodes._map[92] = "RIGHTWINDOWKEY";
        EKeyCodes.RIGHTWINDOWKEY = 92;
        EKeyCodes._map[93] = "SELECTKEY";
        EKeyCodes.SELECTKEY = 93;
        EKeyCodes.NUMPAD0 = 96;
        EKeyCodes._map[97] = "NUMPAD1";
        EKeyCodes.NUMPAD1 = 97;
        EKeyCodes._map[98] = "NUMPAD2";
        EKeyCodes.NUMPAD2 = 98;
        EKeyCodes._map[99] = "NUMPAD3";
        EKeyCodes.NUMPAD3 = 99;
        EKeyCodes._map[100] = "NUMPAD4";
        EKeyCodes.NUMPAD4 = 100;
        EKeyCodes._map[101] = "NUMPAD5";
        EKeyCodes.NUMPAD5 = 101;
        EKeyCodes._map[102] = "NUMPAD6";
        EKeyCodes.NUMPAD6 = 102;
        EKeyCodes._map[103] = "NUMPAD7";
        EKeyCodes.NUMPAD7 = 103;
        EKeyCodes._map[104] = "NUMPAD8";
        EKeyCodes.NUMPAD8 = 104;
        EKeyCodes._map[105] = "NUMPAD9";
        EKeyCodes.NUMPAD9 = 105;
        EKeyCodes.MULTIPLY = 106;
        EKeyCodes._map[107] = "ADD";
        EKeyCodes.ADD = 107;
        EKeyCodes.SUBTRACT = 109;
        EKeyCodes._map[110] = "DECIMALPOINT";
        EKeyCodes.DECIMALPOINT = 110;
        EKeyCodes._map[111] = "DIVIDE";
        EKeyCodes.DIVIDE = 111;
        EKeyCodes.F1 = 112;
        EKeyCodes._map[113] = "F2";
        EKeyCodes.F2 = 113;
        EKeyCodes._map[114] = "F3";
        EKeyCodes.F3 = 114;
        EKeyCodes._map[115] = "F4";
        EKeyCodes.F4 = 115;
        EKeyCodes._map[116] = "F5";
        EKeyCodes.F5 = 116;
        EKeyCodes._map[117] = "F6";
        EKeyCodes.F6 = 117;
        EKeyCodes._map[118] = "F7";
        EKeyCodes.F7 = 118;
        EKeyCodes._map[119] = "F8";
        EKeyCodes.F8 = 119;
        EKeyCodes._map[120] = "F9";
        EKeyCodes.F9 = 120;
        EKeyCodes._map[121] = "F10";
        EKeyCodes.F10 = 121;
        EKeyCodes._map[122] = "F11";
        EKeyCodes.F11 = 122;
        EKeyCodes._map[123] = "F12";
        EKeyCodes.F12 = 123;
        EKeyCodes.NUMLOCK = 144;
        EKeyCodes._map[145] = "SCROLLLOCK";
        EKeyCodes.SCROLLLOCK = 145;
        EKeyCodes.SEMICOLON = 186;
        EKeyCodes._map[187] = "EQUALSIGN";
        EKeyCodes.EQUALSIGN = 187;
        EKeyCodes._map[188] = "COMMA";
        EKeyCodes.COMMA = 188;
        EKeyCodes._map[189] = "DASH";
        EKeyCodes.DASH = 189;
        EKeyCodes._map[190] = "PERIOD";
        EKeyCodes.PERIOD = 190;
        EKeyCodes._map[191] = "FORWARDSLASH";
        EKeyCodes.FORWARDSLASH = 191;
        EKeyCodes._map[192] = "GRAVEACCENT";
        EKeyCodes.GRAVEACCENT = 192;
        EKeyCodes.OPENBRACKET = 219;
        EKeyCodes._map[220] = "BACKSLASH";
        EKeyCodes.BACKSLASH = 220;
        EKeyCodes._map[221] = "CLOSEBRACKET";
        EKeyCodes.CLOSEBRACKET = 221;
        EKeyCodes._map[222] = "SINGLEQUOTE";
        EKeyCodes.SINGLEQUOTE = 222;
        EKeyCodes.TOTAL = 256;
    })(akra.EKeyCodes || (akra.EKeyCodes = {}));
    var EKeyCodes = akra.EKeyCodes;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (controls) {
        var KeyMap = (function () {
            function KeyMap(pTarget) {
                this._pMap = new Array(akra.EKeyCodes.TOTAL);
                this._pCallbackMap = {};
                this._bMouseDown = false;
                this._v2iMousePosition = new akra.Vec2();
                this._v2iMousePrevPosition = new akra.Vec2();
                this._v2iMouseShift = new akra.Vec2();
                for(var i = akra.EKeyCodes.TOTAL; i--; ) {
                    this._pMap[i] = false;
                }
                if (((pTarget) != null)) {
                    this.capture(pTarget);
                }
            }
            KeyMap.prototype.bind = function (sCombination, fn) {
                var pKeys = sCombination.replace(/[\s]+/g, "").split("+");
                var pCodes = [];
                for(var i = 0; i < pKeys.length; ++i) {
                    var iCode = akra.EKeyCodes[pKeys[i].toUpperCase()];
                    if (!((iCode) !== undefined)) {
                        return false;
                    }
                    pCodes.push(iCode);
                }
                var sHash = " " + pCodes.sort().join(' ');
                var pFuncList = this._pCallbackMap[sHash];
                if (!((pFuncList) != null)) {
                    pFuncList = this._pCallbackMap[sHash] = [];
                }
                if (pFuncList.indexOf(fn) === -1) {
                    pFuncList.push(fn);
                }
                return true;
            };
            KeyMap.prototype.capture = function (pTarget) {
                this.captureMouse(pTarget);
                this.captureKeyboard(pTarget);
            };
            KeyMap.prototype.captureMouse = function (pTarget) {
                var pKeys = this;
                var fn = function (e) {
                    pKeys.dispatch(e);
                };
                if (pTarget.addEventListener) {
                    pTarget.addEventListener("mousemove", fn, true);
                    pTarget.addEventListener("mouseup", fn, true);
                    pTarget.addEventListener("mousedown", fn, true);
                } else if (pTarget.attachEvent) {
                    pTarget.attachEvent("onmousemove", fn);
                    pTarget.attachEvent("onmouseup", fn);
                    pTarget.attachEvent("onmousedown", fn);
                } else {
                    pTarget.onmousemove = pTarget.onmouseup = pTarget.onmousedown = fn;
                }
            };
            KeyMap.prototype.captureKeyboard = function (pTarget) {
                var pKeys = this;
                var fn = function (e) {
                    pKeys.dispatch(e);
                };
                if (pTarget.addEventListener) {
                    pTarget.addEventListener("keydown", fn, false);
                    pTarget.addEventListener("keyup", fn, false);
                } else if (pTarget.attachEvent) {
                    pTarget.attachEvent("onkeydown", fn);
                    pTarget.attachEvent("onkeyup", fn);
                } else {
                    pTarget.onkeydown = pTarget.onkeyup = fn;
                }
            };
            KeyMap.prototype.dispatch = function (e) {
                if (typeof e === "undefined") { e = window.event; }
                var iCode = (e).keyCode;
                if (e.type == "keydown") {
                    this._pMap[iCode] = true;
                    if (e.altKey) {
                        this._pMap[akra.EKeyCodes.ALT] = true;
                    }
                    if (e.ctrlKey) {
                        this._pMap[akra.EKeyCodes.CTRL] = true;
                    }
                    if (e.shiftKey) {
                        this._pMap[akra.EKeyCodes.SHIFT] = true;
                    }
                    // if (e.altKey || e.ctrlKey || e.shiftKey) {
                    //     this._pMap.splice(0);
                    // }
                                    } else if (e.type == "keyup") {
                    this.callListeners();
                    this._pMap[iCode] = false;
                    if (iCode == akra.EKeyCodes.ALT) {
                        this._pMap[akra.EKeyCodes.ALT] = false;
                    }
                    if (iCode == akra.EKeyCodes.CTRL) {
                        this._pMap[akra.EKeyCodes.CTRL] = false;
                    }
                    if (iCode == akra.EKeyCodes.SHIFT) {
                        this._pMap[akra.EKeyCodes.SHIFT] = false;
                    }
                }
                if (e.type == "mousemove") {
                    this._v2iMousePosition.x = (e).offsetX;
                    this._v2iMousePosition.y = (e).offsetY;
                } else if (e.type == "mouseup") {
                    // LOG(e);
                    this._bMouseDown = false;
                } else if (e.type == "mousedown") {
                    e.preventDefault();
                    this._v2iMousePrevPosition.x = (e).offsetX;
                    this._v2iMousePrevPosition.y = (e).offsetY;
                    this._bMouseDown = true;
                }
            };
            KeyMap.prototype.callListeners = function () {
                var sHash = "";
                for(var i = 0; i < this._pMap.length; ++i) {
                    if (this._pMap[i]) {
                        sHash += " " + i;
                    }
                }
                var pFuncList = this._pCallbackMap[sHash];
                if (((pFuncList) != null)) {
                    for(var i = 0; i < pFuncList.length; ++i) {
                        pFuncList[i]();
                    }
                }
            };
            KeyMap.prototype.isKeyPress = /** @inline */function (iCode) {
                return this._pMap[iCode];
            };
            KeyMap.prototype.getMouse = /** @inline */function () {
                return this._v2iMousePosition;
            };
            KeyMap.prototype.getMouseShift = /** @inline */function () {
                return this._v2iMouseShift.set(this._v2iMousePosition.x - this._v2iMousePrevPosition.x, this._v2iMousePosition.y - this._v2iMousePrevPosition.y);
            };
            KeyMap.prototype.isMouseMoved = function () {
                return this._v2iMousePosition.x != this._v2iMousePrevPosition.x || this._v2iMousePosition.y != this._v2iMousePrevPosition.y;
            };
            KeyMap.prototype.isMousePress = function () {
                return this._bMouseDown;
            };
            KeyMap.prototype.update = function () {
                this._v2iMousePrevPosition.set(this._v2iMousePosition);
            };
            return KeyMap;
        })();
        controls.KeyMap = KeyMap;        
                        function createKeymap(target) {
            return new KeyMap(target);
        }
        controls.createKeymap = createKeymap;
    })(akra.controls || (akra.controls = {}));
    var controls = akra.controls;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
                                function createSceneSurface(pScene, nCellW, nCellH) {
            if (typeof nCellW === "undefined") { nCellW = 10; }
            if (typeof nCellH === "undefined") { nCellH = nCellW; }
            if (nCellW % 2 === 0) {
                nCellW += 1;
            }
            if (nCellH % 2 === 0) {
                nCellH += 1;
            }
            var nScaleX = nCellW - 1;
            var nScaleY = nCellH - 1;
            var pMesh = null, pSubMesh = null;
            var iPos = 0;
            var pVerticesData = new Float32Array((nCellW + nCellH) * 6);
            var fStepX = 1.0 / (nCellW - 1);
            var fStepY = 1.0 / (nCellH - 1);
            var n = 0;
            for(var z = 0; z < nCellH; ++z) {
                pVerticesData[n] = (-.5) * nScaleX;
                pVerticesData[n + 2] = (z * fStepY - .5) * nScaleY;
                n += 3;
                pVerticesData[n] = (.5) * nScaleX;
                pVerticesData[n + 2] = (z * fStepY - .5) * nScaleY;
                n += 3;
            }
            for(var x = 0; x < nCellW; ++x) {
                pVerticesData[n] = (x * fStepX - .5) * nScaleX;
                pVerticesData[n + 2] = (-.5) * nScaleY;
                n += 3;
                pVerticesData[n] = (x * fStepX - .5) * nScaleX;
                pVerticesData[n + 2] = (.5) * nScaleY;
                n += 3;
            }
            var pVertexIndicesData = new Float32Array((nCellW + nCellH) * 2);
            n = 0;
            for(var z = 0; z < nCellH; ++z) {
                pVertexIndicesData[n++] = z * 2;
                pVertexIndicesData[n++] = z * 2 + 1;
            }
            ;
            for(var x = 0; x < nCellW; ++x) {
                pVertexIndicesData[n++] = nCellH * 2 + x * 2;
                pVertexIndicesData[n++] = nCellH * 2 + x * 2 + 1;
            }
            ;
            var pEngine = pScene.getManager().getEngine();
            pMesh = akra.model.createMesh(pEngine, 'scene-surface', akra.EMeshOptions.HB_READABLE);
            pSubMesh = pMesh.createSubset('scene-surface::main', akra.EPrimitiveTypes.LINELIST);
            pSubMesh.data.allocateData([
                (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (('POSITION')),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
            ], pVerticesData);
            pSubMesh.data.allocateIndex([
                (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (('INDEX_POSITION')),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
            ], pVertexIndicesData);
            pSubMesh.data.index('POSITION', 'INDEX_POSITION');
            pSubMesh.hasShadow = false;
            if ((((pEngine))._isDepsLoaded)) {
                pSubMesh.renderMethod.effect.addComponent("akra.system.plane");
            } else {
                pScene.getManager().getEngine().bind("depsLoaded", /** @inline */function () {
                    pSubMesh.renderMethod.effect.addComponent("akra.system.plane");
                });
            }
            var pSceneModel = pScene.createModel("scene-surface");
            pSceneModel.mesh = pMesh;
            return pSceneModel;
        }
        util.createSceneSurface = createSceneSurface;
        function createQuad(pScene, fSize) {
            if (typeof fSize === "undefined") { fSize = 20.; }
            var pMesh = null, pSubMesh = null;
            var pVerticesData = new Float32Array([
                -fSize, 
                0., 
                -fSize, 
                fSize, 
                0., 
                -fSize, 
                -fSize, 
                0., 
                fSize, 
                fSize, 
                0., 
                fSize
            ]);
            var pNormalsData = new Float32Array([
                0., 
                1., 
                0.
            ]);
            var pVertexIndicesData = new Float32Array([
                0., 
                1., 
                2., 
                3.
            ]);
            var pNormalIndicesData = new Float32Array([
                0., 
                0., 
                0., 
                0.
            ]);
            var iPos = 0, iNorm = 0;
            var pEngine = pScene.getManager().getEngine();
            pMesh = akra.model.createMesh(pEngine, 'quad', akra.EMeshOptions.HB_READABLE);
            pSubMesh = pMesh.createSubset('quad::main', akra.EPrimitiveTypes.TRIANGLESTRIP);
            iPos = pSubMesh.data.allocateData([
                (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (('POSITION')),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
            ], pVerticesData);
            pSubMesh.data.allocateIndex([
                (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (('INDEX0')),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
            ], pVertexIndicesData);
            pSubMesh.data.index('POSITION', 'INDEX0');
            iNorm = pSubMesh.data.allocateData([
                (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (('NORMAL')),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
            ], pNormalsData);
            pSubMesh.data.allocateIndex([
                (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (('INDEX1')),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
            ], pNormalIndicesData);
            pSubMesh.data.index('NORMAL', 'INDEX1');
            pSubMesh.hasShadow = false;
            if ((((pEngine))._isDepsLoaded)) {
                pSubMesh.renderMethod.effect.addComponent("akra.system.mesh_texture");
            } else {
                pScene.getManager().getEngine().bind("depsLoaded", /** @inline */function () {
                    pSubMesh.renderMethod.effect.addComponent("akra.system.mesh_texture");
                });
            }
            var pMatrial = pSubMesh.renderMethod.surfaceMaterial.material;
            pMatrial.diffuse = util.Color.LIGHT_GRAY;
            pMatrial.ambient = new util.Color(0.7, 0.7, 0.7, 1.);
            pMatrial.specular = new util.Color(0.7, 0.7, 0.7, 1);
            pMatrial.emissive = new util.Color(0., 0., 0., 1.);
            pMatrial.shininess = 30.;
            var pSceneModel = pScene.createModel("quad");
            pSceneModel.mesh = pMesh;
            return pSceneModel;
        }
        util.createQuad = createQuad;
        function basis(pScene, eOptions) {
            var pMesh, pSubMesh, pMaterial;
            var iPos, iNorm;
            var pEngine = pScene.getManager().getEngine();
            pMesh = akra.model.createMesh(pEngine, "basis", eOptions || akra.EMeshOptions.HB_READABLE);
            iNorm = pMesh.data.allocateData([
                (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("NORMAL")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
            ], new Float32Array([
                1, 
                0, 
                0
            ]));
            function createAxis(sName, pCoords, pColor) {
                pSubMesh = pMesh.createSubset(sName, akra.EPrimitiveTypes.LINELIST);
                iPos = pSubMesh.data.allocateData([
                    (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("POSITION")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                ], pCoords);
                pSubMesh.data.allocateIndex([
                    (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("INDEX0")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                ], new Float32Array([
                    0, 
                    1
                ]));
                pSubMesh.data.allocateIndex([
                    (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("INDEX1")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                ], new Float32Array([
                    0, 
                    0
                ]));
                pSubMesh.data.index(iPos, "INDEX0");
                pSubMesh.data.index(iNorm, "INDEX1");
                //pSubMesh.applyFlexMaterial(sName + '-color');
                //pSubMesh.getFlexMaterial(sName + '-color');
                pMaterial = pSubMesh.material;
                pMaterial.emissive = pColor;
                pMaterial.ambient = pColor;
                pMaterial.diffuse = pColor;
                pMaterial.shininess = 100.;
                pSubMesh.hasShadow = false;
                if ((((pEngine))._isDepsLoaded)) {
                    pSubMesh.effect.addComponent("akra.system.mesh_texture");
                } else {
                    pScene.getManager().getEngine().bind("depsLoaded", /** @inline */function () {
                        pSubMesh.effect.addComponent("akra.system.mesh_texture");
                    });
                }
            }
            createAxis('basis::X-axis', new Float32Array([
                0, 
                0, 
                0, 
                1, 
                0, 
                0
            ]), util.Color.RED);
            createAxis('basis::Y-axis', new Float32Array([
                0, 
                0, 
                0, 
                0, 
                1, 
                0
            ]), util.Color.GREEN);
            createAxis('basis::Z-axis', new Float32Array([
                0, 
                0, 
                0, 
                0, 
                0, 
                1
            ]), util.Color.BLUE);
            var pSceneModel = pScene.createModel("basis");
            pSceneModel.mesh = pMesh;
            return pSceneModel;
        }
        util.basis = basis;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    //#define SKY_GPU
    (function (model) {
        // core.Engine.depends("effects/sky.fx");
        var Sky = (function () {
            function Sky(_pEngine, nCols, nRows, fR) {
                this._pEngine = _pEngine;
                this.skyDome = null;
                this.sun = null;
                this._v3fSunDir = new akra.Vec3();
                this._v3fInvWavelength4 = new akra.Vec3();
                this._v3fHG = new akra.Vec3();
                this._v3fEye = new akra.Vec3();
                this._v3fGroundc0 = new akra.Vec3();
                this._v3fGroundc1 = new akra.Vec3();
                this._pSkyBlitBox = null;
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
 {
                    akra.logger.setSourceLocation("model/Sky.ts", 65);
                    akra.logger.assert(nCols > 2);
                }
                ;
 {
                    akra.logger.setSourceLocation("model/Sky.ts", 66);
                    akra.logger.assert(nRows > 1);
                }
                ;
 {
                    akra.logger.setSourceLocation("model/Sky.ts", 67);
                    akra.logger.assert(nCols * nRows < 65535);
                }
                ;
                this._fInnerRadius = fR;
                this._init();
                this.init();
                this.createBuffers();
                var pDomeMesh = this.createDome(nCols, nRows);
                var pSceneModel = _pEngine.getScene().createModel("dome" + ((this)._iGuid));
                pSceneModel.mesh = pDomeMesh;
                pSceneModel.accessLocalBounds().set(akra.MAX_UINT32, akra.MAX_UINT32, akra.MAX_UINT32);
                // pSceneModel.scale(this._fOuterRadius);
                this.skyDome = pSceneModel;
                this.sun = _pEngine.getScene().createLightPoint(akra.ELightTypes.SUN, false, 0);
                this.sun.attachToParent(this.skyDome);
                this.sun.skyDome = this.skyDome;
            }
            Sky.prototype.getEngine = /** @inline */function () {
                return this._pEngine;
            };
            Sky.prototype.scale = /** @inline */function (fCos) {
                var x = 1.0 - fCos;
                return this._fRayleighScaleDepth * akra.math.exp(-0.00287 + x * (0.459 + x * (3.83 + x * (-6.80 + x * 5.25))));
            };
            Sky.prototype.expv = /** @inline */function (v) {
                return akra.Vec3.stackCeil.set(akra.math.exp(v.x), akra.math.exp(v.y), akra.math.exp(v.z));
            };
            Sky.prototype._init = function () {
                /*Higher, Better, More CPU/GPU*/
                this._nSize = 32;
                /*Higher, Better, More CPU/GPU*/
                this._nSamples = 5;
                this._fKr = 0.0025;
                this._fKm = 0.0010;
                this._fESun = 20.0;
                this._fg = -0.990;
                this._fExposure = -2.0;
                this._fRayleighScaleDepth = 0.25;
                this._fMieScaleDepth = 0.1;
            };
            Sky.prototype.init = function () {
                // this._nSize = 32;
                // this._nSamples = 5;
                // this._fKr = 0.0025;
                this._fKr4PI = this._fKr * 4.0 * akra.math.PI;
                // this._fKm = 0.0010;
                this._fKm4PI = this._fKm * 4.0 * akra.math.PI;
                // this._fESun = 20.0;
                this._fKrESun = this._fESun * this._fKr;
                this._fKmESun = this._fESun * this._fKm;
                // this._fg = -0.990;
                this._fg2 = this._fg * this._fg;
                // this._fExposure = -2.0;
                this._fInnerRadius2 = this._fInnerRadius * this._fInnerRadius;
                this._fOuterRadius = this._fInnerRadius * 1.025;
                this._fOuterRadius2 = this._fOuterRadius * this._fOuterRadius;
                this._fScale = 1.0 / (this._fOuterRadius - this._fInnerRadius);
                // this._fRayleighScaleDepth = 0.25;
                // this._fMieScaleDepth = 0.1;
                this._fScaleOverScaleDepth = this._fScale / this._fRayleighScaleDepth;
                this._v3fInvWavelength4.x = 1.0 / akra.math.pow(0.650, 4.0);
                this._v3fInvWavelength4.y = 1.0 / akra.math.pow(0.570, 4.0);
                this._v3fInvWavelength4.z = 1.0 / akra.math.pow(0.475, 4.0);
                this._v3fHG.x = 1.5 * ((1.0 - this._fg2) / (2.0 + this._fg2));
                this._v3fHG.y = 1.0 + this._fg2;
                this._v3fHG.z = 2.0 * this._fg;
                this._v3fEye.x = 0.0;
                this._v3fEye.y = this._fInnerRadius + 1.0e-6;
                this._v3fEye.z = 0.0;
                // this._bSkyBuffer = false;
                            };
            Sky.prototype.createBuffers = function () {
                var pEngine = ((this)._pEngine);
                var pRsmgr = pEngine.getResourceManager();
                this._pSkyBuffer = pRsmgr.createTexture("sky_buffer" + ((this)._iGuid));
                // this._pSkyBackBuffer = pRsmgr.createTexture("sky_back_buffer" + this.getGuid());
                this._pSkyBuffer.create(this._nSize, this._nSize, 1, null, akra.ETextureFlags.RENDERTARGET, 0, 0, akra.ETextureTypes.TEXTURE_2D, akra.EPixelFormats.FLOAT32_RGBA);
                // this._pSkyBackBuffer.create(this._nSize, this._nSize, 1, null, ETextureFlags.RENDERTARGET, 0, 0, ETextureTypes.TEXTURE_2D, EPixelFormats.FLOAT32_RGBA);
                this._pSkyBlitBox = new akra.pixelUtil.PixelBox(this._nSize, this._nSize, 1, akra.EPixelFormats.FLOAT32_RGBA, new Uint8Array(this._pSkyBuffer.byteLength));
            };
            Sky.prototype.getWrite = function () {
                /*if (this._bSkyBuffer)*/
                return this._pSkyBuffer;
                /*return this._pSkyBackBuffer;*/
                            };
            Sky.prototype.getRead = function () {
                /*if (!this._bSkyBuffer) */
                return this._pSkyBuffer;
                /*return this._pSkyBackBuffer;*/
                            };
            Sky.prototype.updateSkyBuffer = function () {
                var pPixelBuffer = this.getWrite().getBuffer();
                // var pBox: IBox = geometry.box(0, 0, 0, this._nSize, this._nSize, 1);
                // var pRect: IPixelBox = pPixelBuffer.lock(pBox, ELockFlags.WRITE);
                // debug_assert(!isNull(pRect), "cannot lock texture");
                // var pBuffer: Float32Array = new Float32Array(pRect.data.buffer);
                var pBuffer = new Float32Array(this._pSkyBlitBox.data.buffer);
                var nIndex = 0;
                for(var x = 0; x < this._nSize; x++) {
                    var fCosxz = akra.math.cos(1.0) * x / (this._nSize - 1.0);
                    for(var y = 0; y < this._nSize; y++) {
                        var fCosy = (akra.math.PI * 2.0) * y / (this._nSize - 1.0);
                        var vVecPos = akra.Vec3.stackCeil.set();
                        var vEye = akra.Vec3.stackCeil.set(0.0, this._fInnerRadius + 1e-6, 0.0);
                        vVecPos.x = akra.math.sin(fCosxz) * akra.math.cos(fCosy) * this._fOuterRadius;
                        vVecPos.y = akra.math.cos(fCosxz) * this._fOuterRadius;
                        vVecPos.z = akra.math.sin(fCosxz) * akra.math.sin(fCosy) * this._fOuterRadius;
                        var v3Pos = akra.Vec3.stackCeil.set(vVecPos);
                        var v3Ray = v3Pos.subtract(vEye, akra.Vec3.stackCeil.set());
                        var fFar = v3Ray.length();
                        v3Ray.scale(1. / fFar);
                        // Calculate the ray's starting position, then calculate its scattering offset
                        var v3Start = akra.Vec3.stackCeil.set(vEye);
                        var fHeight = v3Start.length();
                        var fDepth = akra.math.exp(this._fScaleOverScaleDepth * (this._fInnerRadius - vEye.y));
                        var fStartAngle = v3Ray.dot(v3Start) / fHeight;
                        var fStartOffset = fDepth * /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.scale(fStartAngle);
                        // Initialize the scattering loop variables
                        var fSampleLength = fFar / this._nSamples;
                        var fScaledLength = fSampleLength * this._fScale;
                        var v3SampleRay = v3Ray.scale(fSampleLength, akra.Vec3.stackCeil.set());
                        var v3SamplePoint = v3SampleRay.scale(0.5, akra.Vec3.stackCeil.set()).add(v3Start);
                        // Now loop through the sample rays
                        var v3FrontColor = akra.Vec3.stackCeil.set(0.0);
                        for(var i = 0; i < this._nSamples; i++) {
                            var fHeight = v3SamplePoint.length();
                            var fDepth = akra.math.exp(this._fScaleOverScaleDepth * (this._fInnerRadius - fHeight));
                            var fLightAngle = this._v3fSunDir.dot(v3SamplePoint) / fHeight;
                            var fCameraAngle = v3Ray.dot(v3SamplePoint) / fHeight;
                            var fScatter = (fStartOffset + fDepth * (/*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.scale(fLightAngle) - /*not inlined, because supportes only single statement functions(cur. st. count: 3)*/this.scale(fCameraAngle)));
                            var v3Attenuate = (/*checked (origin: akra)>>*/akra.Vec3.stackCeil.set(/*checked (origin: akra)>>*/akra.math.exp(((this._v3fInvWavelength4.scale(this._fKr4PI, /*checked (origin: akra)>>*/akra.Vec3.stackCeil.set()).add(/*checked (origin: akra)>>*/akra.Vec3.stackCeil.set(this._fKm4PI))).scale(-fScatter)).x), /*checked (origin: akra)>>*/akra.math.exp(((this._v3fInvWavelength4.scale(this._fKr4PI, /*checked (origin: akra)>>*/akra.Vec3.stackCeil.set()).add(/*checked (origin: akra)>>*/akra.Vec3.stackCeil.set(this._fKm4PI))).scale(-fScatter)).y), /*checked (origin: akra)>>*/akra.math.exp(((this._v3fInvWavelength4.scale(this._fKr4PI, /*checked (origin: akra)>>*/akra.Vec3.stackCeil.set()).add(/*checked (origin: akra)>>*/akra.Vec3.stackCeil.set(this._fKm4PI))).scale(-fScatter)).z)));
                            v3FrontColor.add(v3Attenuate.scale(fDepth * fScaledLength, akra.Vec3.stackCeil.set()));
                            v3SamplePoint.add(v3SampleRay);
                        }
                        //D3DXVECTOR3 V = vEye - vVecPos;
                        //D3DXVec3Normalize( &V, &V );
                        pBuffer[nIndex * 4 + 0] = akra.math.min(v3FrontColor.x, 6.5519996e4);
                        pBuffer[nIndex * 4 + 1] = akra.math.min(v3FrontColor.y, 6.5519996e4);
                        pBuffer[nIndex * 4 + 2] = akra.math.min(v3FrontColor.z, 6.5519996e4);
                        pBuffer[nIndex * 4 + 3] = 0.0;
                        nIndex++;
                    }
                }
                var HorizonSamples = akra.Vec3.stackCeil.set(0.);
                for(var x = 0; x < this._nSize; x++) {
                    HorizonSamples.add(akra.Vec3.stackCeil.set(pBuffer[((this._nSize - 1) * this._nSize + x) * 4 + 0], pBuffer[((this._nSize - 1) * this._nSize + x) * 4 + 1], pBuffer[((this._nSize - 1) * this._nSize + x) * 4 + 2]));
                }
                HorizonSamples.scale(1. / this._nSize);
                this._v3fGroundc0.set(HorizonSamples);
                this._v3fGroundc1.set(HorizonSamples);
                this._v3fGroundc0.x *= this._v3fInvWavelength4.x * this._fKrESun;
                this._v3fGroundc0.y *= this._v3fInvWavelength4.y * this._fKrESun;
                this._v3fGroundc0.z *= this._v3fInvWavelength4.z * this._fKrESun;
                this._v3fGroundc1.scale(this._fKmESun);
                pPixelBuffer.blitFromMemory(this._pSkyBlitBox);
                // pPixelBuffer.unlock();
                // this._bSkyBuffer = !this._bSkyBuffer;
                if (this.sun) {
                    this.sun.params.groundC0.set(this._v3fGroundc0);
                    this.sun.params.groundC1.set(this._v3fGroundc1);
                    this.sun.params.eyePosition.set(this._v3fEye);
                    this.sun.params.sunDir.set(this._v3fSunDir);
                    this.sun.params.hg.set(this._v3fHG);
 {
                        akra.logger.setSourceLocation("model/Sky.ts", 334);
                        akra.logger.log(this._v3fGroundc0.toString(), this._v3fGroundc1.toString());
                    }
                }
            };
            Sky.prototype.createDome = function (Cols, Rows) {
                var DVSize = Cols * Rows;
                var DISize = (Cols - 1) * (Rows - 1) * 2;
                var pDome = ((this)._pEngine).createMesh("dome", akra.EMeshOptions.HB_READABLE);
                // Fill the Vertices Buffer
                var pVertices = new Float32Array(DVSize * 3 + DVSize * 2);
                var DomeIndex = 0;
                for(var i = 0; i < Cols; i++) {
                    var MoveXZ = akra.math.cos(1.0) * i / (Cols - 1);
                    for(var j = 0; j < Rows; j++) {
                        var MoveY = (akra.math.PI * 2.0) * j / (Rows - 1);
                        pVertices[DomeIndex * 5 + 0] = akra.math.sin(MoveXZ) * akra.math.cos(MoveY);
                        pVertices[DomeIndex * 5 + 1] = akra.math.cos(MoveXZ);
                        pVertices[DomeIndex * 5 + 2] = akra.math.sin(MoveXZ) * akra.math.sin(MoveY);
                        pVertices[DomeIndex * 5 + 3] = j / (Rows - 1.0);
                        pVertices[DomeIndex * 5 + 4] = i / (Cols - 1.0);
                        DomeIndex++;
                    }
                }
                // console.log(pVertices);
                // Fill the Indices Buffer
                var pIndices = new Float32Array(DISize * 3);
                DomeIndex = 0;
                for(var i = 0; i < Rows - 1; i++) {
                    for(var j = 0; j < Cols - 1; j++) {
                        pIndices[DomeIndex++] = i * Rows + j;
                        pIndices[DomeIndex++] = (i + 1) * Rows + j;
                        pIndices[DomeIndex++] = (i + 1) * Rows + j + 1;
                        pIndices[DomeIndex++] = (i + 1) * Rows + j + 1;
                        pIndices[DomeIndex++] = i * Rows + j + 1;
                        pIndices[DomeIndex++] = i * Rows + j;
                    }
                }
                var pSubMesh = pDome.createSubset("main", akra.EPrimitiveTypes.TRIANGLELIST);
                var e = pSubMesh.data.allocateData([
                    (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("POSITION")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
})), 
                    (({
count: (2),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("TEXCOORD0")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                ], pVertices);
                pSubMesh.data.allocateIndex([
                    (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("INDEX0")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}))
                ], pIndices);
                pSubMesh.data.index(e, "INDEX0");
                pSubMesh.hasShadow = false;
                var pMatrial = pSubMesh.renderMethod.surfaceMaterial.material;
                pMatrial.diffuse = akra.Color.LIGHT_GRAY;
                pMatrial.ambient = new akra.Color(0.7, 0.7, 0.7, 1.);
                pMatrial.specular = new akra.Color(0.7, 0.7, 0.7, 1);
                pMatrial.emissive = new akra.Color(0., 0., 0., 1.);
                pMatrial.shininess = 30.;
                if ((((((this)._pEngine)))._isDepsLoaded)) {
                    pSubMesh.renderMethod.effect.addComponent("akra.system.sky");
                } else {
                    ((this)._pEngine).bind("depsLoaded", /** @inline */function () {
                        pSubMesh.renderMethod.effect.addComponent("akra.system.sky");
                    });
                }
                ((pSubMesh.getTechnique()).getEventTable().addDestination(((((pSubMesh.getTechnique())))._iGuid), ("render"), (this), ("_onDomeRender"), (undefined)));
                return pDome;
            };
            Sky.prototype.update = // update(pModelView: IMat4, pProjection: IMat4, pPass: IRenderPass): void {
            function (pSceneObject, pCamera, pPass) {
                var pProjection = pCamera.projectionMatrix;
                var m4fModel = akra.Mat4.stackCeil.set(pSceneObject.worldMatrix);
                // pModelView.data[__41] = 0.0;
                // pModelView.data[__42] = 0.0;
                // pModelView.data[__43] = 0.0;
                m4fModel.setTranslation(akra.Vec3.stackCeil.set(0.0, -this._fInnerRadius - 1.0e-6, 0.0).add(pCamera.worldPosition));
                m4fModel.scaleRight(akra.Vec3.stackCeil.set(this._fOuterRadius));
                var pModelView = pCamera.viewMatrix.multiply(m4fModel, akra.Mat4.stackCeil.set());
                // var m4fTranslation: IMat4 = mat4(1.).setTranslation(vec3(0.0, -this._fInnerRadius - 1.0e-6, 0.0));
                // pModelView.multiply(m4fTranslation);
                var MP = pProjection.multiply(pModelView, akra.Mat4.stackCeil.set());
                pPass.setUniform("WorldViewProjection", MP);
                pPass.setUniform("fKrESun", this._fKrESun);
                pPass.setUniform("fKmESun", this._fKmESun);
                var v2fTemp = akra.Vec2.stackCeil.set(this._nSize, 1.0 / this._nSize);
                pPass.setUniform("Tex", v2fTemp);
                pPass.setUniform("vSunPos", this._v3fSunDir);
                pPass.setUniform("vHG", this._v3fHG);
                pPass.setUniform("vInvWavelength", this._v3fInvWavelength4);
                pPass.setUniform("vEye", this._v3fEye);
                pPass.setUniform("fOuterRadius", this._fOuterRadius);
                pPass.setTexture("tSkyBuffer", this.getRead());
            };
            Sky.prototype.setTime = function (T) {
                var time = T;
                var meridian = 1.3788101;
                var longitude = 1.3852096;
                var latitude = 0.762127107;
                var day = 172;
                var t, delta;
                var A, B, C, D, E, F;
                A = 4 * akra.math.PI * (day - 80) / 373;
                B = 2 * akra.math.PI * (day - 8) / 355;
                C = 2 * akra.math.PI * (day - 81) / 368;
                t = time + 0.170 * akra.math.sin(A) - 0.129 * akra.math.sin(B) + 12 * (meridian - longitude) / akra.math.PI;
                delta = 0.4093 * akra.math.sin(C);
                D = akra.math.PI * t / 12;
                E = akra.math.sin(latitude) * akra.math.sin(delta) - akra.math.cos(latitude) * akra.math.cos(delta) * akra.math.cos(D);
                F = (-akra.math.cos(delta) * akra.math.sin(D)) / (akra.math.cos(latitude) * akra.math.sin(delta) - akra.math.sin(latitude) * akra.math.cos(delta) * akra.math.cos(D));
                this._fSunTheta = akra.math.PI * 0.5 - akra.math.asin(E);
                this._fSunPhi = akra.math.atan(F);
                /*
                vSunDir.x = math.cos(this._fSunPhi) * math.sin(this._fSunTheta);
                vSunDir.y = math.sin(this._fSunPhi) * math.sin(this._fSunTheta);
                vSunDir.z = math.cos(this._fSunTheta);
                */
                this._v3fSunDir.x = 0.0;
                this._v3fSunDir.y = akra.math.cos(T * 0.1);
                this._v3fSunDir.z = akra.math.sin(T * 0.1);
                var Zenith = akra.Vec3.stackCeil.set(0, 1, 0);
                this._fSunTheta = akra.math.acos(this._v3fSunDir.dot(Zenith));
                this._v3fSunDir.normalize();
                this.updateSkyBuffer();
            };
            Sky.prototype._onDomeRender = function (pTechnique, iPass, pRenderable, pSceneObject, pViewport) {
                var pPass = pTechnique.getPass(iPass);
                var pCamera = pViewport.getCamera();
                this.update(pSceneObject, pCamera, pPass);
            };
            Sky.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            Sky._pEventTable = new akra.events.EventTable();
            Sky.prototype.getEventTable = /** @inline */function () {
                return Sky._pEventTable;
            };
            Sky.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Sky.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Sky.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (Sky._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Sky.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (Sky._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Sky.prototype._syncTable = /** @inline */function (pFrom) {
                (Sky._pEventTable)._sync(this, pFrom);
            };
            return Sky;
        })();
        model.Sky = Sky;        
    })(akra.model || (akra.model = {}));
    var model = akra.model;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        var Engine = (function () {
            function Engine(pOptions) {
                if (typeof pOptions === "undefined") { pOptions = null; }
                this._iAppPausedCount = 0;
                /** is paused? */
                this._isActive = false;
                /** frame rendering sync / render next frame? */
                this._isFrameMoving = true;
                /** is all needed files loaded */
                this._isDepsLoaded = false;
                this._pGamepads = null;
                this._fElapsedAppTime = 0.0;
                /**@protected*/ this._iGuid = akra.sid();
                /**@protected*/ this._pUnicastSlotMap = null;
                /**@protected*/ this._pBroadcastSlotList = null;
                this._pResourceManager = new core.pool.ResourcePoolManager(this);
                if (!this._pResourceManager.initialize()) {
 {
                        akra.logger.setSourceLocation("core/Engine.ts", 88);
                        akra.logger.error('cannot initialize ResourcePoolManager');
                    }
                    ;
                }
                this._pSceneManager = new akra.scene.SceneManager(this);
                if (!this._pSceneManager.initialize()) {
 {
                        akra.logger.setSourceLocation("core/Engine.ts", 94);
                        akra.logger.error("cannot initialize SceneManager");
                    }
                    ;
                }
                this._pParticleManager = null;
                this._pTimer = akra.util.UtilTimer.start();
                var pRendererOptions = pOptions ? pOptions.renderer : null;
                this._pRenderer = new akra.webgl.WebGLRenderer(this, pRendererOptions);
                this._pComposer = new akra.fx.Composer(this);
                // Register image codecs
                akra.DDSCodec.startup();
                this.pause(false);
                this.parseOptions(pOptions);
            }
            Object.defineProperty(Engine.prototype, "time", {
                get: /** @inline */function () {
                    return ((this._pTimer).execCommand(/*checked (origin: akra)>>*/akra.EUtilTimerCommands.TIMER_GET_APP_TIME));
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Engine.prototype, "elapsedTime", {
                get: /** @inline */function () {
                    return this._fElapsedAppTime;
                },
                enumerable: true,
                configurable: true
            });
            Engine.prototype.enableGamepads = function () {
                if (!((this._pGamepads) === null)) {
                    return true;
                }
                var pGamepads = akra.controls.createGamepadMap();
                if (pGamepads.init()) {
                    this._pGamepads = pGamepads;
                    return true;
                }
                return false;
            };
            Engine.prototype.getGamepads = function () {
                if (this.enableGamepads()) {
                    return this._pGamepads;
                }
                return null;
            };
            Engine.prototype.parseOptions = function (pOptions) {
                //== Depends Managment ====================================
                var pDeps = Engine.DEPS;
                var sDepsRoot = Engine.DEPS_ROOT;
                var pDepsManager = this._pDepsManager = akra.util.createDepsManager(this);
                //read options
                if (!((pOptions) === null)) {
                    sDepsRoot = pOptions.depsRoot || Engine.DEPS_ROOT;
                    //default deps has higher priority!
                    if (((pOptions.deps) != null)) {
                        Engine.depends(pOptions.deps);
                    }
                    if (pOptions.gamepads === true) {
                        this.enableGamepads();
                    }
                }
                //get loaded signal
                ((pDepsManager).getEventTable().addDestination(((((pDepsManager)))._iGuid), ("loaded"), (this), ("_depsLoaded"), (undefined)));
                if (((pOptions.loader) != null)) {
                    var fnBefore = pOptions.loader.before;
                    var fnOnload = pOptions.loader.onload;
                    var fnLoaded = pOptions.loader.loaded;
                    if ((/*checked (origin: akra)>>*/akra.typeOf((fnBefore)) === "function")) {
                        pDepsManager.bind("beforeLoad", fnBefore);
                    }
                    if ((/*checked (origin: akra)>>*/akra.typeOf((fnOnload)) === "function")) {
                        pDepsManager.bind("loadedDep", fnOnload);
                    }
                    if ((/*checked (origin: akra)>>*/akra.typeOf((fnLoaded)) === "function")) {
                        pDepsManager.bind("loaded", fnLoaded);
                    }
                }
                //load depends!
                if (!pDepsManager.load(pDeps, sDepsRoot)) {
 {
                        akra.logger.setSourceLocation("core/Engine.ts", 183);
                        akra.logger.criticalError("load dependencies are not started.");
                    }
                    ;
                }
                //===========================================================
                            };
            Engine.prototype.getDepsManager = /** @inline */function () {
                return this._pDepsManager;
            };
            Engine.prototype.getScene = /** @inline */function () {
                return this._pSceneManager.getScene3D(0);
            };
            Engine.prototype.getSceneManager = /** @inline */function () {
                return this._pSceneManager;
            };
            Engine.prototype.getParticleManager = /** @inline */function () {
                return null;
            };
            Engine.prototype.getResourceManager = /** @inline */function () {
                return this._pResourceManager;
            };
            Engine.prototype.getRenderer = /** @inline */function () {
                return this._pRenderer;
            };
            Engine.prototype.getComposer = /** @inline */function () {
                return this._pComposer;
            };
            Engine.prototype.isActive = /** @inline */function () {
                return this._isActive;
            };
            Engine.prototype.isDepsLoaded = /** @inline */function () {
                return this._isDepsLoaded;
            };
            Engine.prototype.exec = // _nCountFrame: uint = 0;
            function (bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                var pRenderer = this._pRenderer;
                var pEngine = this;
                // var pCanvas: HTMLCanvasElement = null;
                // pCanvas = (<IWebGLRenderer>pRenderer).getHTMLCanvas();
                 {
                    akra.logger.setSourceLocation("core/Engine.ts", 236);
                    akra.logger.assert(!((pRenderer) === null));
                }
                ;
                pRenderer._initRenderTargets();
                // Infinite loop, until broken out of by frame listeners
                // or break out by calling queueEndRendering()
                bValue ? this.active() : this.inactive();
                function render(iTime) {
                    if (!pRenderer.isValid()) {
 {
                            akra.logger.setSourceLocation("core/Engine.ts", 248);
                            akra.logger.error(pRenderer.getError());
                        }
                        ;
                    }
                    if ((pEngine._isActive) && (pEngine._isDepsLoaded)) {
                        if (!pEngine.renderFrame()) {
 {
                                akra.logger.setSourceLocation("core/Engine.ts", 253);
                                akra.logger.error("Engine::exec() error.");
                            }
                            ;
                            return;
                        }
                        // pEngine._nCountFrame++;
                        // if(pEngine._nCountFrame === 1000){
                        // 	pEngine.pause();
                        // }
                                            }
                    /*, pCanvas*/
                    requestAnimationFrame(render);
                }
                render(0);
            };
            Engine.prototype.getTimer = /** @inline */function () {
                return this._pTimer;
            };
            Engine.prototype.renderFrame = function () {
                this._fElapsedAppTime = ((this._pTimer).execCommand(/*checked (origin: akra)>>*/akra.EUtilTimerCommands.TIMER_GET_ELAPSED_TIME));
                if (0. == this._fElapsedAppTime && this._isFrameMoving) {
                    return true;
                }
                // FrameMove (animate) the scene
                if (this._isFrameMoving) {
                    if (!((this._pGamepads) === null)) {
                        this._pGamepads.update();
                    }
                    this._pSceneManager.update();
                }
                // Render the scene as normal
                this.frameStarted();
                this._pRenderer._updateAllRenderTargets();
                this.frameEnded();
                // this._pSceneManager.preUpdate();
                // LOG("frame rendered();");
                return true;
            };
            Engine.prototype.play = function () {
                if (!((this)._isActive)) {
                    this._iAppPausedCount = 0;
                    this.active();
                    if (this._isFrameMoving) {
                        ((this._pTimer).execCommand(/*checked (origin: akra)>>*/akra.EUtilTimerCommands.TIMER_START) === 0);
                    }
                }
                return ((this)._isActive);
            };
            Engine.prototype.pause = function (isPause) {
                if (typeof isPause === "undefined") { isPause = false; }
                this._iAppPausedCount += (isPause ? +1 : -1);
                (this._iAppPausedCount ? this.inactive() : this.active());
                // Handle the first pause request (of many, nestable pause requests)
                if (isPause && (1 == this._iAppPausedCount)) {
                    // Stop the scene from animating
                    if (this._isFrameMoving) {
                        ((this._pTimer).execCommand(/*checked (origin: akra)>>*/akra.EUtilTimerCommands.TIMER_STOP) === 0);
                    }
                }
                if (0 == this._iAppPausedCount) {
                    // Restart the timers
                    if (this._isFrameMoving) {
                        ((this._pTimer).execCommand(/*checked (origin: akra)>>*/akra.EUtilTimerCommands.TIMER_START) === 0);
                    }
                }
                return !((this)._isActive);
            };
            Engine.prototype.createMesh = /** @inline */function (sName, eOptions, pDataBuffer) {
                if (typeof sName === "undefined") { sName = null; }
                if (typeof eOptions === "undefined") { eOptions = 0; }
                if (typeof pDataBuffer === "undefined") { pDataBuffer = null; }
                return akra.model.createMesh(this, sName, eOptions, pDataBuffer);
            };
            Engine.prototype.createRenderDataCollection = /** @inline */function (iOptions) {
                if (typeof iOptions === "undefined") { iOptions = 0; }
                return akra.render.createRenderDataCollection(this, iOptions);
            };
            Engine.prototype.createBufferMap = /** @inline */function () {
                return akra.util.createBufferMap(this);
            };
            Engine.prototype.createAnimationController = /** @inline */function (sName, iOptions) {
                return akra.animation.createController(this, sName, iOptions);
            };
            Engine.prototype._depsLoaded = function (pLoader, pDeps) {
 {
                    akra.logger.setSourceLocation("core/Engine.ts", 350);
                    akra.logger.log("[ALL DEPTS LOADED]");
                }
                ;
                this._isDepsLoaded = true;
                this.depsLoaded(pDeps);
            };
            Engine.depends = function depends(pData) {
                var pDeps = Engine.DEPS;
                while(((pDeps.files) != null)) {
                    if (!((pDeps.deps) != null)) {
                        pDeps.deps = {
                            files: null,
                            deps: null
                        };
                    }
                    pDeps = pDeps.deps;
                }
                if ((typeof (pData) === "string")) {
                    pDeps.files = [
                        {
                            path: pData
                        }
                    ];
                } else {
                    pDeps.deps = pData;
                }
            };
            Engine.DEPS_ROOT = akra.DATA;
            Engine.DEPS = {
                files: [
                    {
                        path: "grammars/HLSL.gr"
                    }
                ],
                deps: {
                    files: [
                        {
                            path: "effects/SystemEffects.afx"
                        }, 
                        {
                            path: "effects/Plane.afx"
                        }, 
                        {
                            path: "effects/fxaa.afx"
                        }, 
                        {
                            path: "effects/skybox.afx"
                        }, 
                        {
                            path: "effects/TextureToScreen.afx"
                        }, 
                        {
                            path: "effects/mesh_geometry.afx"
                        }, 
                        {
                            path: "effects/prepare_shadows.afx"
                        }, 
                        {
                            path: "effects/terrain.afx"
                        }, 
                        {
                            path: "effects/prepareDeferredShading.afx"
                        }, 
                        {
                            path: "effects/generate_normal_map.afx"
                        }, 
                        {
                            path: "effects/sky.afx"
                        }
                    ],
                    deps: {
                        files: [
                            {
                                path: "effects/mesh_texture.afx"
                            }, 
                            {
                                path: "effects/deferredShading.afx"
                            }, 
                            {
                                path: "effects/apply_lights_and_shadows.afx"
                            }, 
                            
                        ],
                        deps: {
                            files: [
                                {
                                    path: "effects/color_maps.afx"
                                }
                            ]
                        }
                    }
                }
            };
            Engine.prototype.getGuid = /** @inline */function () {
                return this._iGuid;
            };
            Engine._pEventTable = new akra.events.EventTable();
            Engine.prototype.getEventTable = /** @inline */function () {
                return Engine._pEventTable;
            };
            Engine.prototype.connect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Engine.prototype.disconnect = /** @inline */function (pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination((((pSender))._iGuid), sSignal, this, sSlot, eType);
            };
            Engine.prototype.bind = /** @inline */function (sSignal, fnListener, eType) {
                return (Engine._pEventTable).addListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Engine.prototype.unbind = /** @inline */function (sSignal, fnListener, eType) {
                return (Engine._pEventTable).removeListener(((this)._iGuid), sSignal, fnListener, eType);
            };
            Engine.prototype._syncTable = /** @inline */function (pFrom) {
                (Engine._pEventTable)._sync(this, pFrom);
            };
            Engine.prototype.frameStarted = function () {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Engine._pEventTable))).broadcast[(this._iGuid)] = (((Engine._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).frameStarted;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            Engine.prototype.frameEnded = function () {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Engine._pEventTable))).broadcast[(this._iGuid)] = (((Engine._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).frameEnded;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            Engine.prototype.depsLoaded = function (deps) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Engine._pEventTable))).broadcast[(this._iGuid)] = (((Engine._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).depsLoaded;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, deps) : _broadcast[i].listener(_recivier, deps);
                    }
                }
            };
            Engine.prototype.inactive = function () {
                this._isActive = false;
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Engine._pEventTable))).broadcast[(this._iGuid)] = (((Engine._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).inactive;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
                ;
            };
            Engine.prototype.active = function () {
                this._isActive = true;
                this._pBroadcastSlotList = this._pBroadcastSlotList || (((((Engine._pEventTable))).broadcast[(this._iGuid)] = (((Engine._pEventTable))).broadcast[(this._iGuid)] || {}));
                var _broadcast = (this._pBroadcastSlotList).active;
                var _recivier = this;
                if (((_broadcast) !== undefined)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
                ;
            };
            return Engine;
        })();
        core.Engine = Engine;        
        // BROADCAST(inactive, VOID);
        // BROADCAST(active, VOID);
            })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.createEngine = function (pOptions) {
        return new akra.core.Engine(pOptions);
    };
})(akra || (akra = {}));
/*
private initDefaultStates(): bool {
this.pRenderState = {
mesh            : {
isSkinning : false
},
isAdvancedIndex : false,
lights          : {
omni : 0,
project : 0,
omniShadows : 0,
projectShadows : 0
}
};

return true;
}
*/
// #include "util/ObjectArray.ts"
// #include "util/ObjectList.ts"
var akra;
(function (akra) {
    var pEngine = akra.createEngine();
    var pResourcePool = pEngine.getResourceManager();
    if (pEngine.getRenderer().debug(true, true)) {
 {
            akra.logger.setSourceLocation("C:/WebServers/home/akra/www/akra-engine-core/src2/tests/common/buffers/buffers.ts", 9);
            akra.logger.log("context debugging enabled");
        }
        ;
    }
    test("VertexDeclaration tests", /** @inline */function () {
        var pVertexBuffer = pResourcePool.createVertexBuffer('test-vertex-buffer' + akra.sid());
        pVertexBuffer.create(0, akra.EHardwareBufferFlags.BACKUP_COPY);
        var pDecl = new akra.data.VertexDeclaration();
        var pVE = new akra.data.VertexElement(2, akra.EDataTypes.FLOAT, akra.DeclarationUsages.NORMAL);
        var pVE2 = (({
count: (2),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.BINORMAL)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}));
        var pVE3 = (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.POSITION)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}));
        shouldBeTrue("add single vertex element: NORMAL");
        check(pDecl.append(pVE));
        shouldBeTrue("add multiple vertex elements: BINORMAL, POSITION");
        check(pDecl.append(pVE2, pVE3));
        shouldBe("check stride", 20);
        check(pDecl.stride);
        shouldBe("check offsets: NORMAL", 0);
        check(pDecl.findElement(akra.DeclarationUsages.NORMAL).offset);
        shouldBe("check offsets: BINORMAL", 8);
        check(pDecl.findElement(akra.DeclarationUsages.BINORMAL).offset);
        shouldBe("check offsets: POSITION", 16);
        check(pDecl.findElement(akra.DeclarationUsages.POSITION).offset);
        shouldBeNotNull("get empty vertex data");
        check(pVertexBuffer.getEmptyVertexData(3, pDecl));
    });
    test("VertexBuffer tests<br/>" + "Declaration: NORMAL(FLOAT2), BINORMAL(FLOAT2), POSITION(FLOAT)", /** @inline */function () {
        var pVertexBuffer = pResourcePool.createVertexBuffer('test-vertex-buffer' + akra.sid());
        pVertexBuffer.create(0, akra.EHardwareBufferFlags.BACKUP_COPY);
        var pDecl = new akra.data.VertexDeclaration();
        var pVE = new akra.data.VertexElement(2, akra.EDataTypes.FLOAT, akra.DeclarationUsages.NORMAL);
        var pVE2 = (({
count: (2),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.BINORMAL)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}));
        var pVE3 = (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.POSITION)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}));
        pDecl.append(pVE, pVE2, pVE3);
        var pData = pVertexBuffer.getEmptyVertexData(3, pDecl);
        var pArray = new Float32Array([
            1, 
            2, 
            3, 
            4
        ]);
        shouldBeTrue("VertexData setData(ArrayBufferView)");
        check(pData.setData(pArray));
        shouldBeArray("readData(NORMAL, 0, 2)", pArray);
        check(new Float32Array(pData.getData(akra.DeclarationUsages.NORMAL, 0, 2)));
        shouldBeArray("readData(NORMAL, 1, 2)", new Float32Array([
            3, 
            4, 
            0, 
            0
        ]));
        check(new Float32Array(pData.getData(akra.DeclarationUsages.NORMAL, 1, 2)));
        shouldBeArray("getTypedData(NORMAL)", new Float32Array([
            1, 
            2, 
            3, 
            4, 
            0, 
            0
        ]));
        check(pData.getTypedData(akra.DeclarationUsages.NORMAL));
        shouldBeArray("getTypedData(NORMAL, 1, 1)", new Float32Array([
            3, 
            4
        ]));
        check(pData.getTypedData(akra.DeclarationUsages.NORMAL, 1, 1));
        shouldBeTrue("set data to element: POSITION");
        check(pData.setData(new Float32Array([
            134
        ]), "POSITION", 4, 2, 1));
        shouldBeArray("check data: POSITION", new Float32Array([
            0, 
            0, 
            134
        ]));
        check(pData.getTypedData("POSITION"));
    });
    test("VertexBuffer, VertexDeclaration with overlap<br/>" + "Declaration: POSITION(FLOAT2), POSITION_X(FLOAT), POSITION_Y(FLOAT)", /** @inline */function () {
        var pVertexBuffer = pResourcePool.createVertexBuffer('test-vertex-buffer' + akra.sid());
        pVertexBuffer.create(0, akra.EHardwareBufferFlags.BACKUP_COPY);
        var pDecl = new akra.data.VertexDeclaration();
        var pVE = new akra.data.VertexElement(2, akra.EDataTypes.FLOAT, akra.DeclarationUsages.POSITION);
        var pVE2 = (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("POSITION_X")),
offset: ((0))
}));
        var pVE3 = (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("POSITION_Y")),
offset: ((4))
}));
        pDecl.append(pVE, pVE2, pVE3);
        shouldBe("check stride", 8);
        check(pDecl.stride);
        shouldBe("check offset: POSITION_X", 0);
        check(pDecl.findElement("POSITION_X").offset);
        shouldBe("check offset: POSITION_Y", 4);
        check(pDecl.findElement("POSITION_Y").offset);
        var pData = pVertexBuffer.getEmptyVertexData(2, pDecl);
        var pArray = new Float32Array([
            1, 
            2, 
            3, 
            4
        ]);
        pData.setData(pArray, 'POSITION');
        shouldBeArray("set to POSITION read POSITION_X", new Float32Array([
            1, 
            3
        ]));
        check(pData.getTypedData("POSITION_X"));
        shouldBeArray("set to POSITION read POSITION_Y", new Float32Array([
            2, 
            4
        ]));
        check(pData.getTypedData("POSITION_Y"));
        shouldBeTrue("set data to POSITION_X");
        check(pData.setData(new Float32Array([
            5, 
            6
        ]), 'POSITION_X'));
        shouldBeTrue("set data to POSITION_Y");
        check(pData.setData(new Float32Array([
            42, 
            34
        ]), 'POSITION_Y'));
        shouldBeArray("read data: POSITION", new Float32Array([
            5, 
            42, 
            6, 
            34
        ]));
        check(pData.getTypedData("POSITION"));
        shouldBeTrue("set element to POSITION");
        check(pData.setData(new Float32Array([
            77.3, 
            44.2
        ]), "POSITION", 8, 1, 1));
        shouldBeArray('read element: POSITION_X', new Float32Array([
            77.3
        ]));
        check(pData.getTypedData("POSITION_X", 1, 1));
        shouldBeArray('read element: POSITION_Y', new Float32Array([
            44.2
        ]));
        check(pData.getTypedData("POSITION_Y", 1, 1));
    });
    test("VertexBuffer, VertexDeclaration with overlap and different types<br/>" + "Declaration: TEST(FLOAT), TEST_XYZW(UINT8 4)", /** @inline */function () {
        var pVertexBuffer = pResourcePool.createVertexBuffer('test-vertex-buffer' + akra.sid());
        pVertexBuffer.create(0, akra.EHardwareBufferFlags.BACKUP_COPY);
        var pDecl = new akra.data.VertexDeclaration();
        var pVE = new akra.data.VertexElement(1, akra.EDataTypes.FLOAT, "TEST");
        var pVE2 = new akra.data.VertexElement(4, akra.EDataTypes.BYTE, "TEST_XYZW", 0);
        pDecl.append(pVE, pVE2);
        shouldBe("check stride", 4);
        check(pDecl.stride);
        shouldBe("check TEST offset", 0);
        check(pDecl.findElement("TEST").offset);
        shouldBe("check TEST_XYZW offset", 0);
        check(pDecl.findElement("TEST_XYZW").offset);
        var pData = pVertexBuffer.getEmptyVertexData(2, pDecl);
        var pU8 = new Uint8Array([
            1, 
            2, 
            3, 
            4, 
            5, 
            6, 
            7, 
            8
        ]);
        var pF32 = new Float32Array(pU8.buffer);
        shouldBeTrue("set data into TEST");
        check(pData.setData(pF32, "TEST"));
        shouldBeArray("check data TEST_XYZW", pU8);
        check(pData.getTypedData("TEST_XYZW"));
        pU8 = new Uint8Array([
            1, 
            2, 
            3, 
            4
        ]);
        pF32 = new Float32Array(pU8.buffer);
        shouldBeTrue("set into element TEST_XYZW");
        check(pData.setData(pU8, "TEST_XYZW", 4, 1, 1));
        shouldBeArray("check element TEST", pF32);
        check(pData.getTypedData("TEST", 1, 1));
    });
    test("VertexBuffer, VertexDeclaration with VE_END<br/>" + "Declaration: POSITION(FLOAT3), VE_END()", /** @inline */function () {
        var pVertexBuffer = pResourcePool.createVertexBuffer('test-vertex-buffer' + akra.sid());
        pVertexBuffer.create(0, akra.EHardwareBufferFlags.BACKUP_COPY);
        var pDecl = new akra.data.VertexDeclaration();
        var pVE = (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("POSITION")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}));
        var pVE2 = (({
count: (0),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.UNSIGNED_BYTE),
usage: (/*checked (origin: akra)>>*/akra.DeclUsages.END),
offset: ((16))
}));
        pDecl.append(pVE, pVE2);
        shouldBe("check stride", 16);
        check(pDecl.stride);
        shouldBe("check POSITION offset", 0);
        check(pDecl.findElement("POSITION").offset);
        var pData = pVertexBuffer.getEmptyVertexData(2, pDecl);
        var pArray = new Float32Array([
            1, 
            2, 
            3, 
            4, 
            5, 
            6
        ]);
        shouldBeTrue("write data to POSITION");
        check(pData.setData(pArray, "POSITION"));
        shouldBeArray("check data POSITION", pArray);
        check(pData.getTypedData("POSITION"));
    });
    test("VideoBuffer tests<br/>" + "Declaration: NORMAL(FLOAT2), BINORMAL(FLOAT2), POSITION(FLOAT)", /** @inline */function () {
        var pVideoBuffer = pResourcePool.createVideoBuffer('test-video-buffer' + akra.sid());
        pVideoBuffer.create(0, akra.EHardwareBufferFlags.BACKUP_COPY);
        var pDecl = new akra.data.VertexDeclaration();
        var pVE = new akra.data.VertexElement(2, akra.EDataTypes.FLOAT, akra.DeclarationUsages.NORMAL);
        var pVE2 = (({
count: (2),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.BINORMAL)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}));
        var pVE3 = (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: ((/*checked (origin: akra)>>*/akra.DeclarationUsages.POSITION)),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}));
        pDecl.append(pVE, pVE2, pVE3);
        var pData = pVideoBuffer.getEmptyVertexData(3, pDecl);
        var pArray = new Float32Array([
            1, 
            2, 
            3, 
            4
        ]);
        shouldBeTrue("VertexData setData(ArrayBufferView)");
        check(pData.setData(pArray));
        shouldBeArray("readData(NORMAL, 0, 2)", pArray);
        check(new Float32Array(pData.getData(akra.DeclarationUsages.NORMAL, 0, 2)));
        shouldBeArray("readData(NORMAL, 1, 2)", new Float32Array([
            3, 
            4, 
            0, 
            0
        ]));
        check(new Float32Array(pData.getData(akra.DeclarationUsages.NORMAL, 1, 2)));
        shouldBeArray("getTypedData(NORMAL)", new Float32Array([
            1, 
            2, 
            3, 
            4, 
            0, 
            0
        ]));
        check(pData.getTypedData(akra.DeclarationUsages.NORMAL));
        shouldBeArray("getTypedData(NORMAL, 1, 1)", new Float32Array([
            3, 
            4
        ]));
        check(pData.getTypedData(akra.DeclarationUsages.NORMAL, 1, 1));
        shouldBeTrue("set data to element: POSITION");
        check(pData.setData(new Float32Array([
            134
        ]), "POSITION", 4, 2, 1));
        shouldBeArray("check data: POSITION", new Float32Array([
            0, 
            0, 
            134
        ]));
        check(pData.getTypedData("POSITION"));
    });
    test("VideoBuffer, VertexDeclaration with overlap<br/>" + "Declaration: POSITION(FLOAT2), POSITION_X(FLOAT), POSITION_Y(FLOAT)", /** @inline */function () {
        var pVideoBuffer = pResourcePool.createVideoBuffer('test-video-buffer' + akra.sid());
        pVideoBuffer.create(0, akra.EHardwareBufferFlags.BACKUP_COPY);
        var pDecl = new akra.data.VertexDeclaration();
        var pVE = new akra.data.VertexElement(2, akra.EDataTypes.FLOAT, akra.DeclarationUsages.POSITION);
        var pVE2 = (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("POSITION_X")),
offset: ((0))
}));
        var pVE3 = (({
count: (1),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("POSITION_Y")),
offset: ((4))
}));
        pDecl.append(pVE, pVE2, pVE3);
        shouldBe("check stride", 8);
        check(pDecl.stride);
        shouldBe("check offset: POSITION_X", 0);
        check(pDecl.findElement("POSITION_X").offset);
        shouldBe("check offset: POSITION_Y", 4);
        check(pDecl.findElement("POSITION_Y").offset);
        var pData = pVideoBuffer.getEmptyVertexData(2, pDecl);
        var pArray = new Float32Array([
            1, 
            2, 
            3, 
            4
        ]);
        pData.setData(pArray, 'POSITION');
        shouldBeArray("set to POSITION read POSITION_X", new Float32Array([
            1, 
            3
        ]));
        check(pData.getTypedData("POSITION_X"));
        shouldBeArray("set to POSITION read POSITION_Y", new Float32Array([
            2, 
            4
        ]));
        check(pData.getTypedData("POSITION_Y"));
        shouldBeTrue("set data to POSITION_X");
        check(pData.setData(new Float32Array([
            5, 
            6
        ]), 'POSITION_X'));
        shouldBeTrue("set data to POSITION_Y");
        check(pData.setData(new Float32Array([
            42, 
            34
        ]), 'POSITION_Y'));
        shouldBeArray("read data: POSITION", new Float32Array([
            5, 
            42, 
            6, 
            34
        ]));
        check(pData.getTypedData("POSITION"));
        shouldBeTrue("set element to POSITION");
        check(pData.setData(new Float32Array([
            77.3, 
            44.2
        ]), "POSITION", 8, 1, 1));
        shouldBeArray('read element: POSITION_X', new Float32Array([
            77.3
        ]));
        check(pData.getTypedData("POSITION_X", 1, 1));
        shouldBeArray('read element: POSITION_Y', new Float32Array([
            44.2
        ]));
        check(pData.getTypedData("POSITION_Y", 1, 1));
    });
    test("VideoBuffer, VertexDeclaration with overlap and different types<br/>" + "Declaration: TEST(FLOAT), TEST_XYZW(UINT8 4)", /** @inline */function () {
        var pVideoBuffer = pResourcePool.createVideoBuffer('test-video-buffer' + akra.sid());
        pVideoBuffer.create(0, akra.EHardwareBufferFlags.BACKUP_COPY);
        var pDecl = new akra.data.VertexDeclaration();
        var pVE = new akra.data.VertexElement(1, akra.EDataTypes.FLOAT, "TEST");
        var pVE2 = new akra.data.VertexElement(4, akra.EDataTypes.BYTE, "TEST_XYZW", 0);
        pDecl.append(pVE, pVE2);
        shouldBe("check stride", 4);
        check(pDecl.stride);
        shouldBe("check TEST offset", 0);
        check(pDecl.findElement("TEST").offset);
        shouldBe("check TEST_XYZW offset", 0);
        check(pDecl.findElement("TEST_XYZW").offset);
        var pData = pVideoBuffer.getEmptyVertexData(2, pDecl);
        var pU8 = new Uint8Array([
            1, 
            2, 
            3, 
            4, 
            5, 
            6, 
            7, 
            8
        ]);
        var pF32 = new Float32Array(pU8.buffer);
        shouldBeTrue("set data into TEST");
        check(pData.setData(pF32, "TEST"));
        shouldBeArray("check data TEST_XYZW", pU8);
        check(pData.getTypedData("TEST_XYZW"));
        pU8 = new Uint8Array([
            1, 
            2, 
            3, 
            4
        ]);
        pF32 = new Float32Array(pU8.buffer);
        shouldBeTrue("set into element TEST_XYZW");
        check(pData.setData(pU8, "TEST_XYZW", 4, 1, 1));
        shouldBeArray("check element TEST", pF32);
        check(pData.getTypedData("TEST", 1, 1));
    });
    test("VideoBuffer, VertexDeclaration with VE_END<br/>" + "Declaration: POSITION(FLOAT3), VE_END()", /** @inline */function () {
        var pVideoBuffer = pResourcePool.createVideoBuffer('test-video-buffer' + akra.sid());
        pVideoBuffer.create(0, akra.EHardwareBufferFlags.BACKUP_COPY);
        var pDecl = new akra.data.VertexDeclaration();
        var pVE = (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("POSITION")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}));
        var pVE2 = (({
count: (0),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.UNSIGNED_BYTE),
usage: (/*checked (origin: akra)>>*/akra.DeclUsages.END),
offset: ((16))
}));
        pDecl.append(pVE, pVE2);
        shouldBe("check stride", 16);
        check(pDecl.stride);
        shouldBe("check POSITION offset", 0);
        check(pDecl.findElement("POSITION").offset);
        var pData = pVideoBuffer.getEmptyVertexData(2, pDecl);
        var pArray = new Float32Array([
            1, 
            2, 
            3, 
            4, 
            5, 
            6
        ]);
        shouldBeTrue("write data to POSITION");
        check(pData.setData(pArray, "POSITION"));
        shouldBeArray("check data POSITION", pArray);
        check(pData.getTypedData("POSITION"));
    });
    test("IndexBuffer tests", /** @inline */function () {
        var pIndexBuffer = pResourcePool.createIndexBuffer('test-index-buffer' + akra.sid());
        pIndexBuffer.create(0, akra.EHardwareBufferFlags.BACKUP_COPY);
        var pData = pIndexBuffer.getEmptyIndexData(10, akra.EPrimitiveTypes.TRIANGLELIST, akra.EDataTypes.UNSIGNED_SHORT);
        shouldBeNotNull("try receive indexData");
        check(pData);
        shouldBeTrue("set data");
        check(pData.setData(new Uint16Array([
            1, 
            2, 
            3, 
            4
        ])));
        shouldBeArray("read data", new Uint16Array([
            1, 
            2, 
            3, 
            4
        ]));
        check(new Uint16Array(pData.getData(0, 8)));
        shouldBeTrue("set data to element");
        check(pData.setData(new Uint16Array([
            7
        ]), 7));
        shouldBeArray("read element", new Uint16Array([
            7
        ]));
        check(new Uint16Array(pData.getData(14, 2)));
        shouldBeTrue("set data");
        check(pData.setData(new Uint16Array([
            3, 
            4
        ]), 5));
        shouldBeArray("read typed array", new Uint16Array([
            3, 
            4
        ]));
        check(pData.getTypedData(5, 2));
    });
    test("bufferMap test unmappable flow", /** @inline */function () {
        var pMap = akra.util.createBufferMap(pEngine);
        var pVertexBuffer = pResourcePool.createVertexBuffer('test-vertex-buffer' + akra.sid());
        pVertexBuffer.create(0, akra.EHardwareBufferFlags.BACKUP_COPY);
        var pDecl = new akra.data.VertexDeclaration();
        var pVE = (({
count: (4),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("POSITION")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}));
        pDecl.append(pVE);
        var pVertexData = pVertexBuffer.getEmptyVertexData(4, pDecl);
        var pArr1 = new Float32Array([
            1, 
            2, 
            3, 
            4, 
            5, 
            6, 
            7, 
            8, 
            9, 
            10, 
            11, 
            12, 
            13, 
            14, 
            15, 
            16
        ]);
        pVertexData.setData(pArr1, "POSITION");
        var pIndexBuffer = pResourcePool.createIndexBuffer('test-index-buffer' + akra.sid());
        pIndexBuffer.create(0, akra.EHardwareBufferFlags.BACKUP_COPY);
        var pIndexData = pIndexBuffer.getEmptyIndexData(15, akra.EPrimitiveTypes.TRIANGLESTRIP, akra.EDataTypes.UNSIGNED_SHORT);
        var pArr2 = new Uint16Array([
            0, 
            1, 
            2, 
            3, 
            0, 
            2, 
            1, 
            3, 
            0, 
            1, 
            2, 
            3, 
            0, 
            2, 
            3
        ]);
        pIndexData.setData(pArr2);
        var iFlow;
        shouldBe("set vertexData from vertexBuffer, check flow", 0);
        check(iFlow = pMap.flow(pVertexData));
        pMap.index = pIndexData;
        shouldBe("set indexData, test prim type", akra.EPrimitiveTypes.TRIANGLESTRIP);
        check(pMap.primType);
        shouldBe("test primitive count", 13);
        check(pMap.primCount);
    });
    test("bufferMap test mappable flow", /** @inline */function () {
        var pMap = akra.util.createBufferMap(pEngine);
        var pVideoBuffer = pResourcePool.createVideoBuffer('test-video-buffer' + akra.sid());
        pVideoBuffer.create(0, akra.EHardwareBufferFlags.BACKUP_COPY);
        var pDecl1 = new akra.data.VertexDeclaration();
        var pDecl2 = new akra.data.VertexDeclaration();
        var pVE1 = (({
count: (4),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("POSITION")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}));
        var pVE2 = (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("NORMAL")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}));
        var pVE3 = (({
count: (3),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("BINORMAL")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}));
        var pVE4 = (({
count: (0),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.UNSIGNED_BYTE),
usage: (/*checked (origin: akra)>>*/akra.DeclUsages.END),
offset: ((32))
}));
        pDecl1.append(pVE1);
        pDecl2.append(pVE2, pVE3, pVE4);
        var pVertexData1 = pVideoBuffer.getEmptyVertexData(4, pDecl1);
        var pVertexData2 = pVideoBuffer.getEmptyVertexData(4, pDecl2);
        var pArr1 = new Float32Array([
            1, 
            2, 
            3, 
            4, 
            5, 
            6, 
            7, 
            8, 
            9, 
            10, 
            11, 
            12, 
            13, 
            14, 
            15, 
            16
        ]);
        var pArr2 = new Float32Array([
            1, 
            2, 
            3, 
            4, 
            5, 
            6, 
            7, 
            8, 
            9, 
            10, 
            11, 
            12
        ]);
        var pArr3 = new Float32Array([
            -1, 
            -2, 
            -3, 
            -4, 
            -5, 
            -6, 
            -7, 
            -8, 
            -9, 
            -10, 
            -11, 
            -12
        ]);
        pVertexData1.setData(pArr1, "POSITION");
        pVertexData2.setData(pArr2, "NORMAL");
        pVertexData2.setData(pArr3, "BINORMAL");
        var pMapBuffer = pResourcePool.createVertexBuffer('test-vertex-buffer' + akra.sid());
        pMapBuffer.create(0, akra.EHardwareBufferFlags.BACKUP_COPY);
        var pDeclMap = new akra.data.VertexDeclaration();
        var pVE1Index = ({
count: (6),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.UNSIGNED_SHORT),
usage: ("INDEX_POSITION"),
offset: (/*checked (origin: akra)>>*/akra.MAX_INT32)
});
        var pVE2Index = ({
count: (6),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.UNSIGNED_SHORT),
usage: ("INDEX_NORMAL"),
offset: (/*checked (origin: akra)>>*/akra.MAX_INT32)
});
        pDeclMap.append(pVE1Index, pVE2Index);
        var pIndex1 = new Uint16Array([
            1, 
            2, 
            3, 
            2, 
            3, 
            1
        ]);
        var pIndex2 = new Uint16Array([
            3, 
            2, 
            0, 
            0, 
            1, 
            3
        ]);
        var pMapData = pVideoBuffer.getEmptyVertexData(6, pDeclMap);
        pMapData.setData(pIndex1, "INDEX_POSITION");
        pMapData.setData(pIndex2, "INDEX_NORMAL");
        var iFlow1;
        var iFlow2;
        shouldBe("set vertexData from videoBuffer, check flow", 0);
        check(iFlow1 = pMap.flow(pVertexData1));
        shouldBe("set vertexData from videoBuffer, check flow", 1);
        check(iFlow2 = pMap.flow(pVertexData2));
        shouldBeTrue("try mapping first vertexData");
        check(pMap.mapping(iFlow1, pMapData, "INDEX_POSITION"));
        shouldBeTrue("try mapping second vertexData");
        check(pMap.mapping(iFlow2, pMapData, "INDEX_NORMAL"));
        shouldBe("test primitive count", 2);
        check(pMap.primCount);
        pMap.primType = akra.EPrimitiveTypes.TRIANGLEFAN;
        shouldBe("change primitive type, check polygon count", 4);
        check(pMap.primCount);
        var pIndexBuffer = pResourcePool.createIndexBuffer('test-index-buffer' + akra.sid());
        pIndexBuffer.create(0, akra.EHardwareBufferFlags.BACKUP_COPY);
        var pIndexData = pIndexBuffer.getEmptyIndexData(15, akra.EPrimitiveTypes.POINTLIST, akra.EDataTypes.UNSIGNED_SHORT);
        var pIndexArr = new Uint16Array([
            0, 
            1, 
            2, 
            3, 
            0, 
            2, 
            1, 
            3, 
            0, 
            1, 
            2, 
            3, 
            0, 
            2, 
            3
        ]);
        pIndexData.setData(pIndexArr);
        pMap.index = pIndexData;
        shouldBe("set index, check primitive type", akra.EPrimitiveTypes.POINTLIST);
        check(pMap.primType);
        shouldBe("check primitive count", 15);
        check(pMap.primCount);
    });
    var pContext = (pEngine.getRenderer())._pWebGLContext;
    var sVertexShader = "attribute float position;\n	   	\n		uniform sampler2D texture1;\n		uniform sampler2D texture2;\n		\n		uniform vec2 textureSize1;\n		uniform vec2 textureSize2;\n		uniform vec2 resultTextureSize;\n		\n		varying vec4 v4fResult;\n		\n		void main(void){\n			vec2 v2fPosition1 = vec2((mod(position,textureSize1.x) + 0.5)/textureSize1.x, (floor(position/textureSize1.x) + 0.5)/textureSize1.y);\n			vec2 v2fPosition2 = vec2((mod(position,textureSize2.x) + 0.5)/textureSize2.x, (floor(position/textureSize2.x) + 0.5)/textureSize2.y);\n			vec2 v2fResultPosition = vec2((mod(position,resultTextureSize.x) + 0.5)/resultTextureSize.x, (floor(position/resultTextureSize.x) + 0.5)/resultTextureSize.y);\n			\n			vec4 v4fColor1 = texture2D(texture1, v2fPosition1);\n			vec4 v4fColor2 = texture2D(texture2, v2fPosition2);\n			\n			v4fResult.x = (v4fColor1.x == v4fColor2.x) ? 1. : 0.;\n			v4fResult.y = (v4fColor1.y == v4fColor2.y) ? 1. : 0.;\n			v4fResult.z = (v4fColor1.z == v4fColor2.z) ? 1. : 0.;\n			v4fResult.w = (v4fColor1.w == v4fColor2.w) ? 1. : 0.;\n			\n			gl_PointSize = 1.;\n			gl_Position = vec4(v2fResultPosition * 2. - 1., 0. ,1.);\n		}\n		";
    var sFragmentShader = "#ifdef GL_ES                        				\n	   		precision highp float;\n	   	#endif\n	   	\n	   	varying vec4 v4fResult;\n	   	\n	   	void main(void){\n	   		gl_FragColor = v4fResult;\n	   	}\n	   ";
    var pVertexShader = pContext.createShader(pContext.VERTEX_SHADER);
    pContext.shaderSource(pVertexShader, sVertexShader);
    pContext.compileShader(pVertexShader);
    if (!pContext.getShaderParameter(pVertexShader, pContext.COMPILE_STATUS)) {
        alert(pContext.getShaderInfoLog(pVertexShader));
 {
            akra.logger.setSourceLocation("C:/WebServers/home/akra/www/akra-engine-core/src2/tests/common/buffers/buffers.ts", 579);
            akra.logger.criticalError("can not compile vertex shader");
        }
        ;
    }
    var pFragmentShader = pContext.createShader(pContext.FRAGMENT_SHADER);
    pContext.shaderSource(pFragmentShader, sFragmentShader);
    pContext.compileShader(pFragmentShader);
    if (!pContext.getShaderParameter(pFragmentShader, pContext.COMPILE_STATUS)) {
        alert(pContext.getShaderInfoLog(pFragmentShader));
 {
            akra.logger.setSourceLocation("C:/WebServers/home/akra/www/akra-engine-core/src2/tests/common/buffers/buffers.ts", 589);
            akra.logger.criticalError("can not compile fragment shader");
        }
        ;
    }
    var pPerPixelTextureComparison = pContext.createProgram();
    pContext.attachShader(pPerPixelTextureComparison, pVertexShader);
    pContext.attachShader(pPerPixelTextureComparison, pFragmentShader);
    pContext.linkProgram(pPerPixelTextureComparison);
    if (!pContext.getProgramParameter(pPerPixelTextureComparison, pContext.LINK_STATUS)) {
 {
            akra.logger.setSourceLocation("C:/WebServers/home/akra/www/akra-engine-core/src2/tests/common/buffers/buffers.ts", 600);
            akra.logger.criticalError("Could not initialise shaders");
        }
        ;
    }
    pContext.useProgram(pPerPixelTextureComparison);
    pPerPixelTextureComparison.position = pContext.getAttribLocation(pPerPixelTextureComparison, "position");
    pContext.enableVertexAttribArray(pPerPixelTextureComparison.position);
    pPerPixelTextureComparison.texture1 = pContext.getUniformLocation(pPerPixelTextureComparison, "texture1");
    pPerPixelTextureComparison.texture2 = pContext.getUniformLocation(pPerPixelTextureComparison, "texture2");
    pPerPixelTextureComparison.textureSize1 = pContext.getUniformLocation(pPerPixelTextureComparison, "textureSize1");
    pPerPixelTextureComparison.textureSize2 = pContext.getUniformLocation(pPerPixelTextureComparison, "textureSize2");
    pPerPixelTextureComparison.resultTextureSize = pContext.getUniformLocation(pPerPixelTextureComparison, "resultTextureSize");
    test("resize videobuffers with backup copy", /** @inline */function () {
        var pVideoBuffer1 = pResourcePool.createVideoBuffer('test-video-buffer' + akra.sid());
        pVideoBuffer1.create(0, akra.EHardwareBufferFlags.BACKUP_COPY);
        var pVideoBuffer2 = pResourcePool.createVideoBuffer('test-video-buffer' + akra.sid());
        pVideoBuffer2.create(0, akra.EHardwareBufferFlags.BACKUP_COPY);
        var pDecl = new akra.data.VertexDeclaration();
        var pVE = (({
count: (4),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("POSITION")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}));
        var pVE = (({
count: (2),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("NORMAL")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}));
        pDecl.append(pVE);
        var pData1 = pVideoBuffer1.getEmptyVertexData(50, pDecl);
        var pData2 = pVideoBuffer2.getEmptyVertexData(50, pDecl);
        var pArray1 = new Float32Array(200);
        var pArray2 = new Float32Array(100);
        for(var i = 0; i < 50; i++) {
            pArray1[4 * i + 0] = akra.math.random() * 20 - 10.;
            pArray1[4 * i + 1] = akra.math.random() * 20 - 10.;
            pArray1[4 * i + 2] = akra.math.random() * 20 - 10.;
            pArray1[4 * i + 3] = akra.math.random() * 20 - 10.;
            pArray2[2 * i + 0] = akra.math.random() * 20 - 10.;
            pArray2[2 * i + 1] = akra.math.random() * 20 - 10.;
        }
        pData1.setData(pArray1, 'POSITION');
        pData1.setData(pArray2, 'NORMAL');
        pData2.setData(pArray1, 'POSITION');
        pData2.setData(pArray2, 'NORMAL');
        shouldBeTrue("try resize videobuffer");
        check(pVideoBuffer2.resize(32628));
        var pTexture1 = (pVideoBuffer1)._pWebGLTexture;
        var pTexture2 = (pVideoBuffer2)._pWebGLTexture;
        /*4 - float; 4 - pixel */
        var iMaxIndex = akra.math.ceil(50 * pDecl.stride / 4 / 4);
        var pIndex = new Float32Array(iMaxIndex);
        for(var i = 0; i < iMaxIndex; i++) {
            /*texture header*/
            pIndex[i] = i + 2;
        }
        ;
        pContext.useProgram(pPerPixelTextureComparison);
        var pDrawBuffer = pContext.createBuffer();
        pContext.bindBuffer(pContext.ARRAY_BUFFER, pDrawBuffer);
        pContext.bufferData(pContext.ARRAY_BUFFER, pIndex, pContext.STATIC_DRAW);
        var pTestTextureSize = akra.math.calcPOTtextureSize(iMaxIndex + 2);
        var iTestSizeX = pTestTextureSize[0];
        var iTestSizeY = pTestTextureSize[1];
        pContext.activeTexture(pContext.TEXTURE0);
        var pResultTexture = pContext.createTexture();
        pContext.bindTexture(pContext.TEXTURE_2D, pResultTexture);
        pContext.texImage2D(pContext.TEXTURE_2D, 0, pContext.RGBA, iTestSizeX, iTestSizeY, 0, pContext.RGBA, pContext.UNSIGNED_BYTE, null);
        pContext.texParameterf(pContext.TEXTURE_2D, pContext.TEXTURE_MAG_FILTER, pContext.LINEAR);
        pContext.texParameterf(pContext.TEXTURE_2D, pContext.TEXTURE_MIN_FILTER, pContext.LINEAR);
        pContext.texParameterf(pContext.TEXTURE_2D, pContext.TEXTURE_WRAP_S, pContext.CLAMP_TO_EDGE);
        pContext.texParameterf(pContext.TEXTURE_2D, pContext.TEXTURE_WRAP_T, pContext.CLAMP_TO_EDGE);
        var pFrameBuffer = pContext.createFramebuffer();
        pContext.bindFramebuffer(pContext.FRAMEBUFFER, pFrameBuffer);
        pContext.framebufferTexture2D(pContext.FRAMEBUFFER, pContext.COLOR_ATTACHMENT0, pContext.TEXTURE_2D, pResultTexture, 0);
        pContext.activeTexture(pContext.TEXTURE0);
        pContext.bindTexture(pContext.TEXTURE_2D, pResultTexture);
        pContext.activeTexture(pContext.TEXTURE1);
        pContext.bindTexture(pContext.TEXTURE_2D, pTexture1);
        pContext.activeTexture(pContext.TEXTURE2);
        pContext.bindTexture(pContext.TEXTURE_2D, pTexture2);
        pContext.enableVertexAttribArray(pPerPixelTextureComparison.position);
        pContext.vertexAttribPointer(pPerPixelTextureComparison.position, 1, pContext.FLOAT, false, 0, 0);
        pContext.uniform1i(pPerPixelTextureComparison.texture1, 1);
        pContext.uniform1i(pPerPixelTextureComparison.texture2, 2);
        pContext.uniform2f(pPerPixelTextureComparison.textureSize1, (pVideoBuffer1)._iWidth, (pVideoBuffer1)._iHeight);
        pContext.uniform2f(pPerPixelTextureComparison.textureSize2, (pVideoBuffer2)._iWidth, (pVideoBuffer2)._iHeight);
        pContext.uniform2f(pPerPixelTextureComparison.resultTextureSize, iTestSizeX, iTestSizeY);
        pContext.viewport(0, 0, iTestSizeX, iTestSizeY);
        pContext.bindFramebuffer(pContext.FRAMEBUFFER, pFrameBuffer);
        pContext.drawArrays(pContext.POINTS, 0, iMaxIndex);
        pContext.flush();
        pContext.finish();
        var pPixelsResult = new Uint8Array(iTestSizeX * iTestSizeY * 4);
        pContext.readPixels(0, 0, iTestSizeX, iTestSizeY, pContext.RGBA, pContext.UNSIGNED_BYTE, pPixelsResult);
        pContext.bindFramebuffer(pContext.FRAMEBUFFER, null);
        var iResult = 0;
        for(var i = 2; i < iMaxIndex + 2; i++) {
            var iIndex = 4 * i;
            iResult += (pPixelsResult[iIndex + 0] != 0) ? 1 : 0;
            iResult += (pPixelsResult[iIndex + 1] != 0) ? 1 : 0;
            iResult += (pPixelsResult[iIndex + 2] != 0) ? 1 : 0;
            iResult += (pPixelsResult[iIndex + 3] != 0) ? 1 : 0;
        }
        shouldBe("test data in texture after resize", 4 * iMaxIndex);
        check(iResult);
    });
    test("resize videobuffers without backup copy", /** @inline */function () {
        var pVideoBuffer1 = pResourcePool.createVideoBuffer('test-video-buffer' + akra.sid());
        pVideoBuffer1.create(0, akra.EHardwareBufferFlags.BACKUP_COPY);
        var pVideoBuffer2 = pResourcePool.createVideoBuffer('test-video-buffer' + akra.sid());
        pVideoBuffer2.create(0, akra.EHardwareBufferFlags.STATIC);
        var pDecl = new akra.data.VertexDeclaration();
        var pVE = (({
count: (4),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("POSITION")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}));
        var pVE = (({
count: (2),
type: (/*checked (origin: akra)>>*/akra.EDataTypes.FLOAT),
usage: (("NORMAL")),
offset: ((/*checked (origin: akra)>>*/akra.MAX_INT32))
}));
        pDecl.append(pVE);
        var pData1 = pVideoBuffer1.getEmptyVertexData(50, pDecl);
        var pData2 = pVideoBuffer2.getEmptyVertexData(50, pDecl);
        var pArray1 = new Float32Array(200);
        var pArray2 = new Float32Array(100);
        for(var i = 0; i < 50; i++) {
            pArray1[4 * i + 0] = akra.math.random() * 20 - 10.;
            pArray1[4 * i + 1] = akra.math.random() * 20 - 10.;
            pArray1[4 * i + 2] = akra.math.random() * 20 - 10.;
            pArray1[4 * i + 3] = akra.math.random() * 20 - 10.;
            pArray2[2 * i + 0] = akra.math.random() * 20 - 10.;
            pArray2[2 * i + 1] = akra.math.random() * 20 - 10.;
        }
        pData1.setData(pArray1, 'POSITION');
        pData1.setData(pArray2, 'NORMAL');
        pData2.setData(pArray1, 'POSITION');
        pData2.setData(pArray2, 'NORMAL');
        shouldBeTrue("try resize videobuffer");
        check(pVideoBuffer2.resize(32628));
        var pTexture1 = (pVideoBuffer1)._pWebGLTexture;
        var pTexture2 = (pVideoBuffer2)._pWebGLTexture;
        /*4 - float; 4 - pixel */
        var iMaxIndex = akra.math.ceil(50 * pDecl.stride / 4 / 4);
        var pIndex = new Float32Array(iMaxIndex);
        for(var i = 0; i < iMaxIndex; i++) {
            /*texture header*/
            pIndex[i] = i + 2;
        }
        ;
        pContext.useProgram(pPerPixelTextureComparison);
        var pDrawBuffer = pContext.createBuffer();
        pContext.bindBuffer(pContext.ARRAY_BUFFER, pDrawBuffer);
        pContext.bufferData(pContext.ARRAY_BUFFER, pIndex, pContext.STATIC_DRAW);
        var pTestTextureSize = akra.math.calcPOTtextureSize(iMaxIndex + 2);
        var iTestSizeX = pTestTextureSize[0];
        var iTestSizeY = pTestTextureSize[1];
        pContext.activeTexture(pContext.TEXTURE0);
        var pResultTexture = pContext.createTexture();
        pContext.bindTexture(pContext.TEXTURE_2D, pResultTexture);
        pContext.texImage2D(pContext.TEXTURE_2D, 0, pContext.RGBA, iTestSizeX, iTestSizeY, 0, pContext.RGBA, pContext.UNSIGNED_BYTE, null);
        pContext.texParameterf(pContext.TEXTURE_2D, pContext.TEXTURE_MAG_FILTER, pContext.LINEAR);
        pContext.texParameterf(pContext.TEXTURE_2D, pContext.TEXTURE_MIN_FILTER, pContext.LINEAR);
        pContext.texParameterf(pContext.TEXTURE_2D, pContext.TEXTURE_WRAP_S, pContext.CLAMP_TO_EDGE);
        pContext.texParameterf(pContext.TEXTURE_2D, pContext.TEXTURE_WRAP_T, pContext.CLAMP_TO_EDGE);
        var pFrameBuffer = pContext.createFramebuffer();
        pContext.bindFramebuffer(pContext.FRAMEBUFFER, pFrameBuffer);
        pContext.framebufferTexture2D(pContext.FRAMEBUFFER, pContext.COLOR_ATTACHMENT0, pContext.TEXTURE_2D, pResultTexture, 0);
        pContext.activeTexture(pContext.TEXTURE0);
        pContext.bindTexture(pContext.TEXTURE_2D, pResultTexture);
        pContext.activeTexture(pContext.TEXTURE1);
        pContext.bindTexture(pContext.TEXTURE_2D, pTexture1);
        pContext.activeTexture(pContext.TEXTURE2);
        pContext.bindTexture(pContext.TEXTURE_2D, pTexture2);
        pContext.enableVertexAttribArray(pPerPixelTextureComparison.position);
        pContext.vertexAttribPointer(pPerPixelTextureComparison.position, 1, pContext.FLOAT, false, 0, 0);
        pContext.uniform1i(pPerPixelTextureComparison.texture1, 1);
        pContext.uniform1i(pPerPixelTextureComparison.texture2, 2);
        pContext.uniform2f(pPerPixelTextureComparison.textureSize1, (pVideoBuffer1)._iWidth, (pVideoBuffer1)._iHeight);
        pContext.uniform2f(pPerPixelTextureComparison.textureSize2, (pVideoBuffer2)._iWidth, (pVideoBuffer2)._iHeight);
        pContext.uniform2f(pPerPixelTextureComparison.resultTextureSize, iTestSizeX, iTestSizeY);
        pContext.viewport(0, 0, iTestSizeX, iTestSizeY);
        pContext.bindFramebuffer(pContext.FRAMEBUFFER, pFrameBuffer);
        pContext.drawArrays(pContext.POINTS, 0, iMaxIndex);
        pContext.flush();
        pContext.finish();
        var pPixelsResult = new Uint8Array(iTestSizeX * iTestSizeY * 4);
        pContext.readPixels(0, 0, iTestSizeX, iTestSizeY, pContext.RGBA, pContext.UNSIGNED_BYTE, pPixelsResult);
        pContext.bindFramebuffer(pContext.FRAMEBUFFER, null);
        var iResult = 0;
        for(var i = 2; i < iMaxIndex + 2; i++) {
            var iIndex = 4 * i;
            iResult += (pPixelsResult[iIndex + 0] != 0) ? 1 : 0;
            iResult += (pPixelsResult[iIndex + 1] != 0) ? 1 : 0;
            iResult += (pPixelsResult[iIndex + 2] != 0) ? 1 : 0;
            iResult += (pPixelsResult[iIndex + 3] != 0) ? 1 : 0;
        }
        shouldBe("test data in texture after resize", 4 * iMaxIndex);
        check(iResult);
    });
})(akra || (akra = {}));
