// #include "scene/OcTree.ts"
// #include "ISceneManager.ts"
// #include "core/Engine.ts"
















//#define readonly  
//#define protected
//#define struct class
//#define const var










module akra {

	export enum ELogLevel {
        NONE = 0x0000,
        LOG = 0x0001,
        INFORMATION = 0x0002,
        WARNING = 0x0004,
        ERROR = 0x0008,
        CRITICAL = 0x0010,
        ALL = 0x001F
    }

    export interface ILogRoutineFunc {
        (pEntity: ILoggerEntity): void;
    }

    export interface ISourceLocation {
        file: string;
        line:  number ;
    }

    export interface ILoggerEntity {
        code:  number ;
        location: ISourceLocation;
        message?: string;
        info: any;
    }

    export interface ILogger {

///**
//* For plugin api:
//* Load file with custom user codes and three messages 
//*/
//loadManifestFile(): bool;

        init(): bool;

        setLogLevel(eLevel: ELogLevel): void;
        getLogLevel(): ELogLevel;

        registerCode(eCode:  number , sMessage?: string): bool;
        setUnknownCode(eCode:  number , sMessage: string): void;

        registerCodeFamily(eCodeMin:  number , eCodeMax:  number , sFamilyName?: string): bool;

        getFamilyName(eCode:  number ): string;

        setCodeFamilyRoutine(eCodeFromFamily:  number , fnLogRoutine: ILogRoutineFunc, eLevel: ELogLevel): bool;
        setCodeFamilyRoutine(sFamilyName: string, fnLogRoutine: ILogRoutineFunc, eLevel: ELogLevel): bool;

        setLogRoutine(fnLogRoutine: ILogRoutineFunc, eLevel: ELogLevel): void;

        setSourceLocation(sFile: string, iLine:  number ): void;
        setSourceLocation(pLocation: ISourceLocation): void;

// Print messages methods

        log(...pArgs: any[]);

        info(pEntity: ILoggerEntity): void;
        info(eCode:  number , ...pArgs: any[]): void;
        info(...pArgs: any[]): void;

        warning(pEntity: ILoggerEntity): void;
        warning(eCode:  number , ...pArgs: any[]): void;
        warning(...pArgs: any[]): void;

        error(pEntity: ILoggerEntity): void;
        error(eCode:  number , ...pArgs: any[]): void;
        error(...pArgs: any[]): void;

        criticalError(pEntity: ILoggerEntity): void;
        criticalError(eCode:  number , ...pArgs: any[]): void;
        criticalError(...pArgs: any[]):void;

        assert(bCondition: bool, pEntity: ILoggerEntity): void;
        assert(bCondition: bool, eCode:  number , ...pArgs: any[]): void;
        assert(bCondition: bool, ...pArgs: any[]):void;

    }
}






















/*I ## */
/*I ## */
/*I ## */
/*I ## */


module akra {


    export var  DEBUG : bool = true;


    export var logger: ILogger;
    export var typeOf: (x: any) => string;

    typeOf = function typeOf(x: any): string {
        var s: string = typeof x;

        if (s === "object") {
            if (x) {

                if (x instanceof Array) {
                    return 'array';
                } else if (x instanceof Object) {
                    return s;
                }

                var sClassName = Object.prototype.toString.call(x);

                if (sClassName == '[object Window]') {
                    return 'object';
                }

                if ((sClassName == '[object Array]' ||
                     typeof x.length == 'number' &&
                     typeof x.splice != 'undefined' &&
                     typeof x.propertyIsEnumerable != 'undefined' &&
                     !x.propertyIsEnumerable('splice')

                    )) {
                    return 'array';
                }

                if ((sClassName == '[object Function]' ||
                    typeof x.call != 'undefined' &&
                    typeof x.propertyIsEnumerable != 'undefined' &&
                    !x.propertyIsEnumerable('call'))) {
                    return 'function';
                }

            } else {
                return 'null';
            }

        } else if (s == 'function' && typeof x.call == 'undefined') {
            return 'object';
        }
        return s;
    };


/** @inline */

    export var isDef = (x: any): bool =>  x !== undefined;
/** @inline */

    export var isEmpty = (x: any): bool =>  x.length == 0;

// Note that undefined == null.
/** @inline */

    export var isDefAndNotNull = (x: any): bool =>  x != null;

/** @inline */

    export var isNull = (x: any): bool =>  x === null;

/** @inline */

    export var isBoolean = (x: any): bool => typeof x === "boolean";

/** @inline */

    export var isString = (x: any): bool => typeof x === "string";

/** @inline */

    export var isNumber = (x: any): bool => typeof x === "number";
/** @inline */

    export var isFloat = isNumber;
/** @inline */

    export var isInt = isNumber;

/** @inline */

    export var isFunction = (x: any): bool => typeOf(x) === "function";

/** @inline */

    export var isObject = (x: any): bool => {
        var type = typeOf(x);
        return type == "object" || type == "array" || type == "function";
    };

    export var isArrayBuffer = (x: any): bool => x instanceof ArrayBuffer;

    export var isTypedArray = (x: any): bool => typeof x === "object" && typeof x.byteOffset === "number";

/** @inline */

    export var isArray = (x: any): bool => {
        return typeOf(x) == "array";
    };

    export interface Pair {
        first: any;
        second: any;
    };

// if (!isDef(console.assert)) {
//     console.assert = function (isOK?: bool, ...pParams: any[]): void {
//         if (!isOK) {
//             trace('---------------------------');
//             trace.apply(null, pParams);
//             throw new Error("[assertion failed]");
//         }
//     }
// }

// export var trace = console.log.bind(console);
// export var assert = console.assert.bind(console);
// export var warning = console.warn.bind(console);
// export var error = console.error.bind(console); 









// export var debug_print = (pArg:any, ...pParams: any[]): void => {
//         trace.apply(null, arguments);
// }

// export var debug_assert = (isOK: bool, ...pParams: any[]): void => {
//         assert.apply(null, arguments);
// }

// export var debug_warning = (pArg:any, ...pParams: any[]): void => {
//         warning.apply(null, arguments);
// }

// export var debug_error = (pArg:any, ...pParams: any[]): void => {
//         error.apply(null, arguments);
// }




    export function genArray(pType: any, nSize:  number ) {
        var tmp = new Array(nSize);

        for (var i:  number  = 0; i < nSize; ++i) {
            tmp[i] = (pType? new pType: null);
        }

        return tmp;
    }


    export  /**@const*/var  INVALID_INDEX:  number  =  0xffff;

// (-2147483646);
    export  /**@const*/var  MIN_INT32:  number  = 0xffffffff;
// ( 2147483647);
    export  /**@const*/var  MAX_INT32:  number  = 0x7fffffff;
// (-32768);
    export  /**@const*/var  MIN_INT16:  number  = 0xffff;
// ( 32767);  
    export  /**@const*/var  MAX_INT16:  number  = 0x7fff;
// (-128);
    export  /**@const*/var  MIN_INT8:  number  = 0xff;
// ( 127);        
    export  /**@const*/var  MAX_INT8:  number  = 0x7f;
    export  /**@const*/var  MIN_UINT32:  number  = 0;
    export  /**@const*/var  MAX_UINT32:  number  = 0xffffffff;
    export  /**@const*/var  MIN_UINT16:  number  = 0;
    export  /**@const*/var  MAX_UINT16:  number  = 0xffff;
    export  /**@const*/var  MIN_UINT8:  number  = 0;
    export  /**@const*/var  MAX_UINT8:  number  = 0xff;


    export  /**@const*/var  SIZE_FLOAT64:  number  = 8;
    export  /**@const*/var  SIZE_REAL64:  number  = 8;
    export  /**@const*/var  SIZE_FLOAT32:  number  = 4;
    export  /**@const*/var  SIZE_REAL32:  number  = 4;
    export  /**@const*/var  SIZE_INT32:  number  = 4;
    export  /**@const*/var  SIZE_UINT32:  number  = 4;
    export  /**@const*/var  SIZE_INT16:  number  = 2;
    export  /**@const*/var  SIZE_UINT16:  number  = 2;
    export  /**@const*/var  SIZE_INT8:  number  = 1;
    export  /**@const*/var  SIZE_UINT8:  number  = 1;
    export  /**@const*/var  SIZE_BYTE:  number  = 1;
    export  /**@const*/var  SIZE_UBYTE:  number  = 1;

//1.7976931348623157e+308
    export  /**@const*/var  MAX_FLOAT64:  number  = Number.MAX_VALUE;
//-1.7976931348623157e+308
    export  /**@const*/var  MIN_FLOAT64:  number  = -Number.MAX_VALUE;
//5e-324
    export  /**@const*/var  TINY_FLOAT64:  number  = Number.MIN_VALUE;

//    export const MAX_REAL64: number = Number.MAX_VALUE;   //1.7976931348623157e+308
//    export const MIN_REAL64: number = -Number.MAX_VALUE;  //-1.7976931348623157e+308
//    export const TINY_REAL64: number = Number.MIN_VALUE;  //5e-324


//3.4e38
    export  /**@const*/var  MAX_FLOAT32:  number  = 3.4e38;
//-3.4e38
    export  /**@const*/var  MIN_FLOAT32:  number  = -3.4e38;
//1.5e-45  
    export  /**@const*/var  TINY_FLOAT32:  number  = 1.5e-45;

//    export const MAX_REAL32: number = 3.4e38;     //3.4e38
//    export const MIN_REAL32: number = -3.4e38;    //-3.4e38
//    export const TINY_REAL32: number = 1.5e-45;   //1.5e-45

    export  /**@const*/var  DEFAULT_MATERIAL_NAME: string =  "default" ;

    export enum EDataTypes {
        BYTE = 0x1400,
        UNSIGNED_BYTE = 0x1401,
        SHORT = 0x1402,
        UNSIGNED_SHORT = 0x1403,
        INT = 0x1404,
        UNSIGNED_INT = 0x1405,
        FLOAT = 0x1406
    };

    export enum EDataTypeSizes {
        BYTES_PER_BYTE = 1,
        BYTES_PER_UNSIGNED_BYTE = 1,
        BYTES_PER_UBYTE = 1,

        BYTES_PER_SHORT = 2,
        BYTES_PER_UNSIGNED_SHORT = 2,
        BYTES_PER_USHORT = 2,

        BYTES_PER_INT = 4,
        BYTES_PER_UNSIGNED_INT = 4,
        BYTES_PER_UINT = 4,

        BYTES_PER_FLOAT = 4
    };

/*
    export enum EResourceTypes {
        SURFACE = 1,
        VOLUME,
        TEXTURE,   
        VOLUMETEXTURE,
        CUBETEXTURE,
        VERTEXBUFFER,
        INDEXBUFFER,
        FORCE_DWORD = 0x7fffffff
    };

*/


    export interface StringMap {
        [index: string]: string;
        [index: number]: string;
    };

    export interface IntMap {
        [index: string]:  number ;
        [index: number]:  number ;
    };

    export interface UintMap {
        [index: string]:  number ;
        [index: number]:  number ;
    };

    export interface FloatMap {
        [index: string]:  number ;
        [index: number]:  number ;
    };

    export interface BoolMap {
        [index: string]: bool;
        [index: number]: bool;
    };

    export interface BoolDMap{
        [index: string]: BoolMap;
        [index: number]: BoolMap;
    };

    export interface StringDMap{
        [index: string]: StringMap;
        [index: number]: StringMap;
    }

/**
     * Возвращет размер типа в байтах
     **/

//export function getTypeSize(eType: EImageTypes): uint;
    export function getTypeSize(eType: EDataTypes):  number ;
    export function getTypeSize(eType):  number  {
        switch (eType) {
            case EDataTypes.BYTE:
            case EDataTypes.UNSIGNED_BYTE:
                return 1;
            case EDataTypes.SHORT:
            case EDataTypes.UNSIGNED_SHORT:
//case EImageTypes.UNSIGNED_SHORT_4_4_4_4:
//case EImageTypes.UNSIGNED_SHORT_5_5_5_1:
//case EImageTypes.UNSIGNED_SHORT_5_6_5:
                return 2;
            case EDataTypes.INT:
            case EDataTypes.UNSIGNED_INT:
            case EDataTypes.FLOAT:
                return 4;
            default:
                logger.setSourceLocation( "common.ts" , 397 ); logger.error('unknown data/image type used'); ;
        }

        return 0;
    }


    export var sid = ():  number  => (++ sid._iTotal);
    sid._iTotal = 0;


    export function now():  number  {
        return (new Date).getTime();
    }



    export  /**@inline*/  function memcpy(pDst: ArrayBuffer, iDstOffset:  number , pSrc: ArrayBuffer, iSrcOffset:  number , nLength:  number ) {
      var dstU8 = new Uint8Array(pDst, iDstOffset, nLength);
      var srcU8 = new Uint8Array(pSrc, iSrcOffset, nLength);
      dstU8.set(srcU8);
    };


//export function 

	(<any>window).URL = (<any>window).URL ? (<any>window).URL : (<any>window).webkitURL ? (<any>window).webkitURL : null;
	(<any>window).BlobBuilder = (<any>window).WebKitBlobBuilder || (<any>window).MozBlobBuilder || (<any>window).BlobBuilder;
	(<any>window).requestFileSystem = (<any>window).requestFileSystem || (<any>window).webkitRequestFileSystem;
	(<any>window).requestAnimationFrame = (<any>window).requestAnimationFrame || (<any>window).webkitRequestAnimationFrame ||
		(<any>window).mozRequestAnimationFrame;
	(<any>window).WebSocket = (<any>window).WebSocket || (<any>window).MozWebSocket;
    (<any>window).storageInfo = (<any>window).storageInfo || (<any>window).webkitStorageInfo;
    Worker.prototype.postMessage = (<any>Worker).prototype.webkitPostMessage || Worker.prototype.postMessage;
};






function utf8_encode (argString: string): string {
// Encodes an ISO-8859-1 string to UTF-8  
// 
// version: 1109.2015
// discuss at: http://phpjs.org/functions/utf8_encode
// +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
// +   improved by: sowberry
// +    tweaked by: Jack
// +   bugfixed by: Onno Marsman
// +   improved by: Yves Sucaet
// +   bugfixed by: Onno Marsman
// +   bugfixed by: Ulrich
// +   bugfixed by: Rafal Kukawski
// *     example 1: utf8_encode('Kevin van Zonneveld');
// *     returns 1: 'Kevin van Zonneveld'
    if (argString === null || typeof argString === "undefined") {
        return "";
    }
// .replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    var string = (argString + "");
    var utftext = "",
        start, end, stringl = 0;

    start = end = 0;
    stringl = string.length;
    for (var n = 0; n < stringl; n++) {
        var c1 = string.charCodeAt(n);
        var enc = null;

        if (c1 < 128) {
            end++;
        } else if (c1 > 127 && c1 < 2048) {
            enc = String.fromCharCode((c1 >> 6) | 192) + String.fromCharCode((c1 & 63) | 128);
        }
        else {
            enc = String.fromCharCode((c1 >> 12) | 224) + String.fromCharCode(((c1 >> 6) & 63) | 128)
                + String.fromCharCode((c1 & 63) | 128);
        }
        if (enc !== null) {
            if (end > start) {
                utftext += string.slice(start, end);
            }
            utftext += enc;
            start = end = n + 1;
        }
    }

    if (end > start) {
        utftext += string.slice(start, stringl);
    }

    return utftext;
}


function utf8_decode (str_data: string): string {
// http://kevin.vanzonneveld.net
// +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
// +      input by: Aman Gupta
// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
// +   improved by: Norman "zEh" Fuchs
// +   bugfixed by: hitwork
// +   bugfixed by: Onno Marsman
// +      input by: Brett Zamir (http://brett-zamir.me)
// +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
// *     example 1: utf8_decode('Kevin van Zonneveld');
// *     returns 1: 'Kevin van Zonneveld'
    var tmp_arr = [],
        i = 0,
        ac = 0,
        c1 = 0,
        c2 = 0,
        c3 = 0;

    str_data += "";

    while (i < str_data.length) {
        c1 = str_data.charCodeAt(i);
        if (c1 < 128) {
            tmp_arr[ac++] = String.fromCharCode(c1);
            i++;
        } else if (c1 > 191 && c1 < 224) {
            c2 = str_data.charCodeAt(i + 1);
            tmp_arr[ac++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
            i += 2;
        }
        else {
            c2 = str_data.charCodeAt(i + 1);
            c3 = str_data.charCodeAt(i + 2);
            tmp_arr[ac++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
            i += 3;
        }
    }

    return tmp_arr.join("");
}

function crc32 (str: string): string {
// http://kevin.vanzonneveld.net
// +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
// +   improved by: T0bsn
// -    depends on: utf8_encode
// *     example 1: crc32('Kevin van Zonneveld');
// *     returns 1: 1249991249
    str = utf8_encode(str);
    var table = "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D";

    var crc = 0;
    var x = 0;
    var y = 0;

    crc = crc ^ (-1);
    for (var i = 0, iTop = str.length; i < iTop; i++) {
        y = (crc ^ str.charCodeAt(i)) & 0xFF;
        x = parseInt("0x" + table.substr(y * 9, 8));
        crc = (crc >>> 8) ^ x;
    }

    return String(crc ^ (-1));
}

function md5 (str) {
// http://kevin.vanzonneveld.net
// +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
// + namespaced by: Michael White (http://getsprink.com)
// +    tweaked by: Jack
// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
// +      input by: Brett Zamir (http://brett-zamir.me)
// +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
// -    depends on: utf8_encode
// *     example 1: md5('Kevin van Zonneveld');
// *     returns 1: '6e658d4bfcb59cc13f96c14450ac40b9'


    var xl, a, b, c ,d ,e;

    var rotateLeft = function (lValue, iShiftBits) {
        return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
    };

    var addUnsigned = function (lX, lY) {
        var lX4, lY4, lX8, lY8, lResult;
        lX8 = (lX & 0x80000000);
        lY8 = (lY & 0x80000000);
        lX4 = (lX & 0x40000000);
        lY4 = (lY & 0x40000000);
        lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
        if (lX4 & lY4) {
            return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
        }
        if (lX4 | lY4) {
            if (lResult & 0x40000000) {
                return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
            }
            else {
                return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
            }
        }
        else {
            return (lResult ^ lX8 ^ lY8);
        }
    };

    var _F = function (x, y, z) {
        return (x & y) | ((~x) & z);
    };
    var _G = function (x, y, z) {
        return (x & z) | (y & (~z));
    };
    var _H = function (x, y, z) {
        return (x ^ y ^ z);
    };
    var _I = function (x, y, z) {
        return (y ^ (x | (~z)));
    };

    var _FF = function (a, b, c, d, x, s, ac) {
        a = addUnsigned(a, addUnsigned(addUnsigned(_F(b, c, d), x), ac));
        return addUnsigned(rotateLeft(a, s), b);
    };

    var _GG = function (a, b, c, d, x, s, ac) {
        a = addUnsigned(a, addUnsigned(addUnsigned(_G(b, c, d), x), ac));
        return addUnsigned(rotateLeft(a, s), b);
    };

    var _HH = function (a, b, c, d, x, s, ac) {
        a = addUnsigned(a, addUnsigned(addUnsigned(_H(b, c, d), x), ac));
        return addUnsigned(rotateLeft(a, s), b);
    };

    var _II = function (a, b, c, d, x, s, ac) {
        a = addUnsigned(a, addUnsigned(addUnsigned(_I(b, c, d), x), ac));
        return addUnsigned(rotateLeft(a, s), b);
    };

    var convertToWordArray = function (str) {
        var lWordCount;
        var lMessageLength = str.length;
        var lNumberOfWords_temp1 = lMessageLength + 8;
        var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
        var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
        var lWordArray = new Array(lNumberOfWords - 1);
        var lBytePosition = 0;
        var lByteCount = 0;
        while (lByteCount < lMessageLength) {
            lWordCount = (lByteCount - (lByteCount % 4)) / 4;
            lBytePosition = (lByteCount % 4) * 8;
            lWordArray[lWordCount] = (lWordArray[lWordCount] | (str.charCodeAt(lByteCount) << lBytePosition));
            lByteCount++;
        }
        lWordCount = (lByteCount - (lByteCount % 4)) / 4;
        lBytePosition = (lByteCount % 4) * 8;
        lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
        lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
        lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
        return lWordArray;
    };

    var wordToHex = function (lValue) {
        var wordToHexValue = "",
            wordToHexValue_temp = "",
            lByte, lCount;
        for (lCount = 0; lCount <= 3; lCount++) {
            lByte = (lValue >>> (lCount * 8)) & 255;
            wordToHexValue_temp = "0" + lByte.toString(16);
            wordToHexValue = wordToHexValue + wordToHexValue_temp.substr(wordToHexValue_temp.length - 2, 2);
        }
        return wordToHexValue;
    };

    var x = [],
        k, AA, BB, CC, DD, a, b, c, d, S11 = 7,
        S12 = 12,
        S13 = 17,
        S14 = 22,
        S21 = 5,
        S22 = 9,
        S23 = 14,
        S24 = 20,
        S31 = 4,
        S32 = 11,
        S33 = 16,
        S34 = 23,
        S41 = 6,
        S42 = 10,
        S43 = 15,
        S44 = 21;

    str = utf8_encode(str);
    x = convertToWordArray(str);
    a = 0x67452301;
    b = 0xEFCDAB89;
    c = 0x98BADCFE;
    d = 0x10325476;

    xl = x.length;
    for (k = 0; k < xl; k += 16) {
        AA = a;
        BB = b;
        CC = c;
        DD = d;
        a = _FF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
        d = _FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
        c = _FF(c, d, a, b, x[k + 2], S13, 0x242070DB);
        b = _FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
        a = _FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
        d = _FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
        c = _FF(c, d, a, b, x[k + 6], S13, 0xA8304613);
        b = _FF(b, c, d, a, x[k + 7], S14, 0xFD469501);
        a = _FF(a, b, c, d, x[k + 8], S11, 0x698098D8);
        d = _FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
        c = _FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
        b = _FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
        a = _FF(a, b, c, d, x[k + 12], S11, 0x6B901122);
        d = _FF(d, a, b, c, x[k + 13], S12, 0xFD987193);
        c = _FF(c, d, a, b, x[k + 14], S13, 0xA679438E);
        b = _FF(b, c, d, a, x[k + 15], S14, 0x49B40821);
        a = _GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
        d = _GG(d, a, b, c, x[k + 6], S22, 0xC040B340);
        c = _GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
        b = _GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
        a = _GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
        d = _GG(d, a, b, c, x[k + 10], S22, 0x2441453);
        c = _GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
        b = _GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
        a = _GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
        d = _GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
        c = _GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
        b = _GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
        a = _GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
        d = _GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
        c = _GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
        b = _GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
        a = _HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
        d = _HH(d, a, b, c, x[k + 8], S32, 0x8771F681);
        c = _HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
        b = _HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
        a = _HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
        d = _HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
        c = _HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
        b = _HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
        a = _HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
        d = _HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
        c = _HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
        b = _HH(b, c, d, a, x[k + 6], S34, 0x4881D05);
        a = _HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
        d = _HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
        c = _HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
        b = _HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
        a = _II(a, b, c, d, x[k + 0], S41, 0xF4292244);
        d = _II(d, a, b, c, x[k + 7], S42, 0x432AFF97);
        c = _II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
        b = _II(b, c, d, a, x[k + 5], S44, 0xFC93A039);
        a = _II(a, b, c, d, x[k + 12], S41, 0x655B59C3);
        d = _II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
        c = _II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
        b = _II(b, c, d, a, x[k + 1], S44, 0x85845DD1);
        a = _II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
        d = _II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
        c = _II(c, d, a, b, x[k + 6], S43, 0xA3014314);
        b = _II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
        a = _II(a, b, c, d, x[k + 4], S41, 0xF7537E82);
        d = _II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
        c = _II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
        b = _II(b, c, d, a, x[k + 9], S44, 0xEB86D391);
        a = addUnsigned(a, AA);
        b = addUnsigned(b, BB);
        c = addUnsigned(c, CC);
        d = addUnsigned(d, DD);
    }

    var temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);

    return temp.toLowerCase();
}

function sha1 (str: string): string {
// http://kevin.vanzonneveld.net
// +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
// + namespaced by: Michael White (http://getsprink.com)
// +      input by: Brett Zamir (http://brett-zamir.me)
// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
// -    depends on: utf8_encode
// *     example 1: sha1('Kevin van Zonneveld');
// *     returns 1: '54916d2e62f65b3afa6e192e6a601cdbe5cb5897'
    var rotate_left = function (n, s) {
        var t4 = (n << s) | (n >>> (32 - s));
        return t4;
    };

/*var lsb_hex = function (val) { // Not in use; needed?
     var str="";
     var i;
     var vh;
     var vl;

     for ( i=0; i<=6; i+=2 ) {
     vh = (val>>>(i*4+4))&0x0f;
     vl = (val>>>(i*4))&0x0f;
     str += vh.toString(16) + vl.toString(16);
     }
     return str;
     };*/


    var cvt_hex = function (val) {
        var str = "";
        var i;
        var v;

        for (i = 7; i >= 0; i--) {
            v = (val >>> (i * 4)) & 0x0f;
            str += v.toString(16);
        }
        return str;
    };

    var blockstart;
    var i, j;
    var W = new Array(80);
    var H0 = 0x67452301;
    var H1 = 0xEFCDAB89;
    var H2 = 0x98BADCFE;
    var H3 = 0x10325476;
    var H4 = 0xC3D2E1F0;
    var A, B, C, D, E;
    var temp;

    str = utf8_encode(str);
    var str_len = str.length;

    var word_array = [];
    for (i = 0; i < str_len - 3; i += 4) {
        j = str.charCodeAt(i) << 24 | str.charCodeAt(i + 1) << 16 | str.charCodeAt(i + 2) << 8 | str.charCodeAt(i + 3);
        word_array.push(j);
    }

    switch (str_len % 4) {
        case 0:
            i = 0x080000000;
            break;
        case 1:
            i = str.charCodeAt(str_len - 1) << 24 | 0x0800000;
            break;
        case 2:
            i = str.charCodeAt(str_len - 2) << 24 | str.charCodeAt(str_len - 1) << 16 | 0x08000;
            break;
        case 3:
            i = str.charCodeAt(str_len - 3) << 24 | str.charCodeAt(str_len - 2) << 16 | str.charCodeAt(str_len - 1) << 8
                | 0x80;
            break;
    }

    word_array.push(i);

    while ((word_array.length % 16) != 14) {
        word_array.push(0);
    }

    word_array.push(str_len >>> 29);
    word_array.push((str_len << 3) & 0x0ffffffff);

    for (blockstart = 0; blockstart < word_array.length; blockstart += 16) {
        for (i = 0; i < 16; i++) {
            W[i] = word_array[blockstart + i];
        }
        for (i = 16; i <= 79; i++) {
            W[i] = rotate_left(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
        }


        A = H0;
        B = H1;
        C = H2;
        D = H3;
        E = H4;

        for (i = 0; i <= 19; i++) {
            temp = (rotate_left(A, 5) + ((B & C) | (~B & D)) + E + W[i] + 0x5A827999) & 0x0ffffffff;
            E = D;
            D = C;
            C = rotate_left(B, 30);
            B = A;
            A = temp;
        }

        for (i = 20; i <= 39; i++) {
            temp = (rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 0x6ED9EBA1) & 0x0ffffffff;
            E = D;
            D = C;
            C = rotate_left(B, 30);
            B = A;
            A = temp;
        }

        for (i = 40; i <= 59; i++) {
            temp = (rotate_left(A, 5) + ((B & C) | (B & D) | (C & D)) + E + W[i] + 0x8F1BBCDC) & 0x0ffffffff;
            E = D;
            D = C;
            C = rotate_left(B, 30);
            B = A;
            A = temp;
        }

        for (i = 60; i <= 79; i++) {
            temp = (rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 0xCA62C1D6) & 0x0ffffffff;
            E = D;
            D = C;
            C = rotate_left(B, 30);
            B = A;
            A = temp;
        }

        H0 = (H0 + A) & 0x0ffffffff;
        H1 = (H1 + B) & 0x0ffffffff;
        H2 = (H2 + C) & 0x0ffffffff;
        H3 = (H3 + D) & 0x0ffffffff;
        H4 = (H4 + E) & 0x0ffffffff;
    }

    temp = cvt_hex(H0) + cvt_hex(H1) + cvt_hex(H2) + cvt_hex(H3) + cvt_hex(H4);
    return temp.toLowerCase();
}

interface String {
    toUTF8(): string;
    fromUTF8(): string;

    md5(): string;
    sha1(): string;
    crc32(): string;
    replaceAt(n:  number , s: string);
}

interface Array {
    last: any;
    first: any;
    el(i : number ): any;
    clear(): any[];
    swap(i:  number , j:  number ): any[];
    insert(elements: any[]): any[];
    find(pElement: any): bool;
}

interface Number {
    toHex(length:  number ): string;
    printBinary(isPretty?: bool);
}

module akra.libs {
/**
     * Encodes an ISO-8859-1 string to UTF-8
     * @treturn String
     */

    String.prototype.toUTF8 = function () {
        return utf8_encode(this);
    };

/**
     * Converts a UTF-8 encoded string to ISO-8859-1
     * @treturn String
     */

    String.prototype.fromUTF8 = function () {
        return utf8_decode(this);
    };

    String.prototype.md5 = function () {
        return md5(this);
    };

    String.prototype.sha1 = function () {
        return sha1(this);
    };

    String.prototype.crc32 = function () {
        return crc32(this);
    };

    String.prototype.replaceAt = function (n, chr) {
        return this.substr(0, n) + chr + this.substr(n + chr.length);
    };


    Object.defineProperty(Array.prototype, 'first', {
        enumerable: false,
        configurable: true,
        get: function() {
            return this[0];
        }
    });

    Object.defineProperty(Array.prototype, 'last', {
        enumerable: false,
        configurable: true,
        get: function() {
            return this[this.length - 1];
        }
    });

    Object.defineProperty(Array.prototype, 'el', {
        enumerable: false,
        configurable: true,
        value: function (i) {i = i || 0; return this[i < 0? this.length + i: i];}
    });

    Object.defineProperty(Array.prototype, 'clear', {
        enumerable: false,
        configurable: true,
        value: function () {this.length = 0;}
    });

    Object.defineProperty(Array.prototype, 'swap', {
        enumerable: false,
        configurable: true,
        value: function (i, j) {
            if (i < this.length && j < this.length) {
                var t = this[i]; this[i] = this[j]; this[j] = t;
            }
        }
    });

    Object.defineProperty(Array.prototype, 'insert', {
        enumerable: false,
        configurable: true,
        value: function (pElement) {
            if (typeof pElement.length === 'number') {
                for (var i = 0, n = pElement.length; i < n; ++ i) {
                    this.push(pElement[i]);
                };
            }
            else {
                this.push(pElement);
            }

            return this;
        }
    });

    Number.prototype.toHex = function (iLength:  number ): string {
        var sValue = this.toString(16);

        for (var i = 0; i < iLength - sValue.length; ++ i) {
            sValue = '0' + sValue;
        }

        return sValue;
    };

    Number.prototype.printBinary = function (isPretty: bool = true): string {
        var res: string = "";
        for (var i = 0; i < 32; ++i) {
            if (i && (i % 4) == 0 && isPretty) {
                res = ' ' + res;
            }
            (this >> i & 0x1 ? res = '1' + res : res = '0' + res);
        }
        return res;
    };
}
















/**
 * FLAG(x)
 * Сдвиг единицы на @a x позиций влево.
 */



/**
 * TEST_BIT(value, bit)
 * Проверка того что у @a value бит под номером @a bit равен единице.
 */



/**
 * TEST_ALL(value, set)
 * Проверка того что у @a value равны единице все биты,
 * которые равны единице у @a set.
 */



/**
 * TEST_ANY(value, set)
 * Проверка того что у @a value равны единице хотя бы какие то из битов,
 * которые равны единице у @a set.
 */



/**
 * SET_BIT(value, bit)
 * Выставляет бит под номером @a bit у числа @a value равным единице
 */






/**
 * CLEAR_BIT(value, bit)
 * Выставляет бит под номером @a bit у числа @a value равным нулю
 */



/**
 * SET_ALL(value, set)
 * Выставляет все биты у числа @a value равными единице,
 * которые равны единице у числа @a set
 */



/**
 * CLEAR_ALL(value, set)
 * Выставляет все биты у числа @a value равными нулю,
 * которые равны единице у числа @a set
 */



//#define SET_ALL(value, set, setting) (setting ? SET_ALL(value, set) : CLEAR_ALL(value, set))



module akra.bf {
/**
	 * Сдвиг единицы на @a x позиций влево.
	 * @inline
	 */

	export var flag = (x:  number ) => (1 << (x));
/**
	 * Проверка того что у @a value бит под номером @a bit равен единице.
	 * @inline
	 */

	export var testBit = (value:  number , bit:  number ) => ((value & flag(bit)) != 0);
/**
	 * Проверка того что у @a value равны единице все биты,
 	 * которые равны единице у @a set.
	 * @inline
	 */

	export var testAll = (value:  number , set:  number ) => (((value) & (set)) == (set));
/**
	 * Проверка того что у @a value равны единице хотя бы какие то из битов,
 	 * которые равны единице у @a set.
	 * @inline
	 */

	export var testAny = (value:  number , set:  number ) => (((value) & (set)) != 0);
/**
	 * Выставляет бит под номером @a bit у числа @a value равным единице
	 * @inline
	 */

	export var setBit = (value:  number , bit:  number , setting: bool = true) => (setting ? ((value) |= flag((bit))) : clearBit(value, bit));
/**
	 * 
	 * @inline
	 */

	export var clearBit = (value:  number , bit:  number ) => ((value) &= ~flag((bit)));
/**
	 * Выставляет бит под номером @a bit у числа @a value равным нулю
	 * @inline
	 */

	export var setAll = (value:  number , set:  number , setting: bool = true) => (setting ? setAll(value, set) : clearAll(value, set));
/**
	 * Выставляет все биты у числа @a value равными единице,
 	 * которые равны единице у числа @a set
	 * @inline
	 */

	export var clearAll = (value:  number , set:  number ) => ((value) &= ~(set));
/**
	 * Выставляет все биты у числа @a value равными нулю,
 	 * которые равны единице у числа @a set
	 * @inline
	 */

	export var equal = (value:  number , src:  number ) => { value = src; };
/**
	 * Прирасваивает числу @a value число @a src
	 * @inline
	 */

	export var isEqual = (value:  number , src:  number ) => value == src;
/**
	 * Если число @a value равно числу @a src возвращается true
	 * @inline
	 */

	export var isNotEqaul = (value:  number , src:  number ) => value != src;
/**
	 * Прирасваивает числу @a value число @a src
	 * @inline
	 */

	export var set = (value:  number , src:  number ) => { value = src; };
/**
	 * Обнуляет число @a value
	 * @inline
	 */

	export var clear = (value:  number ) => { value = 0; };
/**
	 * Выставляет все биты у числа @a value равными единице,
 	 * которые равны единице у числа @a src
	 * @inline
	 */

	export var setFlags = (value:  number , src:  number ) => (value |= src);
/**
	 * Выставляет все биты у числа @a value равными нулю,
 	 * которые равны единице у числа @a src
	 * @inline
	 */

	export var clearFlags = (value:  number , src:  number ) => value &= ~src;
/**
	 * Проверяет равно ли число @a value нулю. Если равно возвращает true.
 	 * Если не равно возвращает false.
	 * @inline
	 */

	export var isEmpty = (value:  number ) => (value == 0);
/**
	 * Возвращает общее количество бит числа @a value.
 	 * На самом деле возвращает всегда 32.
	 * @inline
	 */

	export var totalBits = (value:  number ) => 32;
/**
	 * Возвращает общее количество ненулевых бит числа @a value.
	 * @inline
	 */

	export var totalSet = (value:  number ):  number  => {
		var count:  number  = 0;
        var total:  number  = totalBits(value);

        for (var i:  number  = total; i; --i) {
            count += (value & 1);
            value >>= 1;
        }

        return(count);
	}

/**
     * Convert N bit colour channel value to P bits. It fills P bits with the
     * bit pattern repeated. (this is /((1<<n)-1) in fixed point)
     */

    export  /**@inline*/  function fixedToFixed(value:  number , n:  number , p:  number ):  number  {
        if(n > p) {
// Less bits required than available; this is easy
            value >>= n-p;
        }
        else if(n < p) {
// More bits required than are there, do the fill
// Use old fashioned division, probably better than a loop
            if(value == 0)
                    value = 0;
            else if(value == (< number >(1)<<n)-1)
                    value = (1<<p)-1;
            else    value = value*(1<<p)/((1<<n)-1);
        }
        return value;
    }

/**
     * Convert floating point colour channel value between 0.0 and 1.0 (otherwise clamped) 
     * to integer of a certain number of bits. Works for any value of bits between 0 and 31.
     */

    export  /**@inline*/  function floatToFixed(value:  number , bits:  number ):  number  {
        if(value <= 0.0) return 0;
        else if (value >= 1.0) return (1<<bits)-1;
        else return < number >(value * (1<<bits));
    }

/**
     * Fixed point to float
     */

    export  /**@inline*/  function fixedToFloat(value:  number , bits:  number ):  number  {
        return < number >value/< number >((1<<bits)-1);
    }

/**
     * Write a n*8 bits integer value to memory in native endian.
     */

    export  /**@inline*/  function intWrite(pDest: Uint8Array, n:  number , value:  number ): void {
        switch(n) {
            case 1:
                pDest[0] = value;
                break;
            case 2:
                pDest[1] = ((value >> 8) & 0xFF);
                pDest[0] = (value & 0xFF);
                break;
            case 3:
                pDest[2] = ((value >> 16) & 0xFF);
                pDest[1] = ((value >> 8) & 0xFF);
                pDest[0] = (value & 0xFF);
                break;
            case 4:
                pDest[3] = ((value >> 24) & 0xFF);
                pDest[2] = ((value >> 16) & 0xFF);
                pDest[1] = ((value >> 8) & 0xFF);
                pDest[0] = (value & 0xFF);
                break;
        }
    }

/**
     * Read a n*8 bits integer value to memory in native endian.
     */

    export  /**@inline*/  function intRead(pSrc: Uint8Array, n:  number ):  number  {
        switch(n) {
            case 1:
                return pSrc[0];
            case 2:
                return pSrc[0] | pSrc[1]<<8;
            case 3:
                return pSrc[0] | pSrc[1]<<8 | pSrc[2]<<16;
            case 4:
                return pSrc[0] | pSrc[1]<<8 | pSrc[2]<<16 | pSrc[3]<<32;
        }
        return 0;
    }

    export function floatToHalfI(i:  number ):  number ;

//float32/uint32 union
    var _u32 = new Uint32Array(1);
    var _f32 = new Float32Array(_u32.buffer);

    export  /**@inline*/  function floatToHalf(f:  number ) {
    	_f32[0] = f;
    	return floatToHalfI(_u32[0]);
    }
    export  /**@inline*/  function floatToHalfI(i:  number ):  number  {

        var s:  number  =  (i >> 16) & 0x00008000;
        var e:  number  = ((i >> 23) & 0x000000ff) - (127 - 15);
        var m:  number  =   i        & 0x007fffff;

        if (e <= 0) {
            if (e < -10)
            {
                return 0;
            }
            m = (m | 0x00800000) >> (1 - e);

            return < number >(s | (m >> 13));
        }
        else if (e == 0xff - (127 - 15)) {
// Inf            if (m == 0)
            {
                return < number >(s | 0x7c00);
            }
// NAN            else
            {
                m >>= 13;
                return < number >(s | 0x7c00 | m | < number ><any>(m == 0));
            }
        }
        else {
// Overflow            if (e > 30)
            {
                return < number >(s | 0x7c00);
            }

            return < number >(s | (e << 10) | (m >> 13));
        }
    }

/**
     * Convert a float16 (NV_half_float) to a float32
     * Courtesy of OpenEXR
     */

    export  /**@inline*/  function halfToFloat(y:  number ):  number  {
        _u32[0] = halfToFloatI(y);
        return _f32[0];
    }

/** Converts a half in uint16 format to a float
	 	in uint32 format
	 */

    export  /**@inline*/  function halfToFloatI(y:  number ):  number  {
        var s:  number  = (y >> 15) & 0x00000001;
        var e:  number  = (y >> 10) & 0x0000001f;
        var m:  number  =  y        & 0x000003ff;

        if (e == 0) {
// Plus or minus zero
            if (m == 0)  {
                return s << 31;
            }
// Denormalized number -- renormalize it
            else {
                while (!(m & 0x00000400)) {
                    m <<= 1;
                    e -=  1;
                }

                e += 1;
                m &= ~0x00000400;
            }
        }
        else if (e == 31) {
//Inf
            if (m == 0) {
                return (s << 31) | 0x7f800000;
            }
//NaN
            else {
                return (s << 31) | 0x7f800000 | (m << 13);
            }
        }

        e = e + (127 - 15);
        m = m << 13;

        return (s << 31) | (e << 23) | m;
    }

}


// #include "Singleton.ts"

module akra.util {

    export interface ILogRoutineMap {
        [eLogLevel:  number ]: ILogRoutineFunc;
    }

    export  interface ICodeFamily {
        familyName: string;
        codeMin:  number ;
        codeMax:  number ;
    }

    export  interface ICodeFamilyMap{
        [familyName: string]: ICodeFamily;
    }

    export interface ICodeInfo{
        code:  number ;
        message: string;
        familyName: string;
    }

    export interface ICodeInfoMap{
        [code:  number ] : ICodeInfo;
    }

    export interface ICodeFamilyRoutineDMap{
        [familyName: string]: ILogRoutineMap;
    }

/* extends Singleton*/
    export class Logger                       implements ILogger {
        private _eLogLevel: ELogLevel;
        private _pGeneralRoutineMap: ILogRoutineMap;

        private _pCurrentSourceLocation: ISourceLocation;
        private _pLastLogEntity: ILoggerEntity;

        private _pCodeFamilyList: ICodeFamily[];
        private _pCodeFamilyMap: ICodeFamilyMap;
        private _pCodeInfoMap: ICodeInfoMap;

        private _pCodeFamilyRoutineDMap: ICodeFamilyRoutineDMap;

        private _nFamilyGenerator:  number ;
        static private _sDefaultFamilyName: string = "CodeFamily";

        private _eUnknownCode:  number ;
        private _sUnknownMessage: string;

        constructor () {
//super();

            this._eUnknownCode = 0;
            this._sUnknownMessage = "Unknown code";

            this._eLogLevel = ELogLevel.ALL;
            this._pGeneralRoutineMap = <ILogRoutineMap>{};

            this._pCurrentSourceLocation = <ISourceLocation>{
                                            file: "",
                                            line: 0
                                        };

            this._pLastLogEntity = <ILoggerEntity>{
                                    code: this._eUnknownCode,
                                    location: this._pCurrentSourceLocation,
                                    message: this._sUnknownMessage,
                                    info: null,
                                   };

            this._pCodeFamilyMap = <ICodeFamilyMap>{};
            this._pCodeFamilyList = <ICodeFamily[]>[];
            this._pCodeInfoMap = <ICodeInfoMap>{};

            this._pCodeFamilyRoutineDMap = <ICodeFamilyRoutineDMap>{};

            this._nFamilyGenerator = 0;


        }

        init(): bool {
//TODO: Load file
            return true;
        }

        setLogLevel(eLevel: ELogLevel): void {
            this._eLogLevel = eLevel;
        }

        getLogLevel(): ELogLevel {
            return this._eLogLevel;
        }

        registerCode(eCode:  number , sMessage?: string = this._sUnknownMessage): bool{
            if(this.isUsedCode(eCode)){
                return false;
            }

            var sFamilyName: string = this.getFamilyName(eCode);
            if(isNull(sFamilyName)){
                return false;
            }

            var pCodeInfo: ICodeInfo = <ICodeInfo>{
                                            code: eCode,
                                            message: sMessage,
                                            familyName: sFamilyName
                                            };

            this._pCodeInfoMap[eCode] = pCodeInfo;

            return true;
        }

        setUnknownCode(eCode:  number , sMessage: string):void{
            this._eUnknownCode = eCode;
            this._sUnknownMessage = sMessage;
        }

        registerCodeFamily(eCodeMin:  number , eCodeMax:  number , sFamilyName?: string): bool{
            if(!isDef(sFamilyName)){
                sFamilyName = this.generateFamilyName();
            }

            if(this.isUsedFamilyName(sFamilyName)){
                return false;
            }

            if(!this.isValidCodeInterval(eCodeMin, eCodeMax)){
                return false;
            }

            var pCodeFamily: ICodeFamily = <ICodeFamily>{
                                                    familyName: sFamilyName,
                                                    codeMin: eCodeMin,
                                                    codeMax: eCodeMax
                                                    };

            this._pCodeFamilyMap[sFamilyName] = pCodeFamily;
            this._pCodeFamilyList.push(pCodeFamily);

            return true;
        }

        getFamilyName(eCode): string{
            var i:  number  = 0;
            var pCodeFamilyList: ICodeFamily[] = this._pCodeFamilyList;
            var pCodeFamily: ICodeFamily;

            for(i = 0; i < pCodeFamilyList.length; i++){
                pCodeFamily = pCodeFamilyList[i];

                if(pCodeFamily.codeMin <= eCode && pCodeFamily.codeMax >= eCode){
                    return pCodeFamily.familyName;
                }
            }

            return null;
        }

        setCodeFamilyRoutine(eCodeFromFamily:  number , fnLogRoutine: ILogRoutineFunc, eLevel: ELogLevel): bool;
        setCodeFamilyRoutine(sFamilyName: string, fnLogRoutine: ILogRoutineFunc, eLevel: ELogLevel): bool;
        setCodeFamilyRoutine():bool {
            var sFamilyName: string;
            var fnLogRoutine: ILogRoutineFunc;
            var eLevel:ELogLevel;

            if(isInt(arguments[0])){
                sFamilyName = this.getFamilyName(arguments[0]);
                fnLogRoutine = arguments[1];
                eLevel = arguments[2];

                if(isNull(sFamilyName)){
                    return false;
                }
            }
            else if(isString(arguments[0])){
                sFamilyName = arguments[0];
                fnLogRoutine = arguments[1];
                eLevel = arguments[2];
            }

            if(!this.isUsedFamilyName(sFamilyName)){
                return false;
            }

            var pCodeFamilyRoutineMap: ILogRoutineMap = this._pCodeFamilyRoutineDMap[sFamilyName];

            if(!isDef(pCodeFamilyRoutineMap)){
                pCodeFamilyRoutineMap = this._pCodeFamilyRoutineDMap[sFamilyName] = <ILogRoutineMap>{};
            }

            if (bf.testAll(eLevel, ELogLevel.LOG)) {
               pCodeFamilyRoutineMap[ELogLevel.LOG] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.INFORMATION)) {
               pCodeFamilyRoutineMap[ELogLevel.INFORMATION] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.WARNING)) {
               pCodeFamilyRoutineMap[ELogLevel.WARNING] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.ERROR)) {
               pCodeFamilyRoutineMap[ELogLevel.ERROR] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.CRITICAL)) {
               pCodeFamilyRoutineMap[ELogLevel.CRITICAL] = fnLogRoutine;
            }

            return true;
        }

        setLogRoutine(fnLogRoutine: ILogRoutineFunc, eLevel: ELogLevel): void {

            if (bf.testAll(eLevel, ELogLevel.LOG)) {
               this._pGeneralRoutineMap[ELogLevel.LOG] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.INFORMATION)) {
               this._pGeneralRoutineMap[ELogLevel.INFORMATION] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.WARNING)) {
               this._pGeneralRoutineMap[ELogLevel.WARNING] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.ERROR)) {
               this._pGeneralRoutineMap[ELogLevel.ERROR] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.CRITICAL)) {
               this._pGeneralRoutineMap[ELogLevel.CRITICAL] = fnLogRoutine;
            }
        }

        setSourceLocation(sFile: string, iLine:  number ): void;
        setSourceLocation(pLocation: ISourceLocation): void;
        setSourceLocation(): void {
            var sFile: string;
            var iLine:  number ;

            if(arguments.length === 2){
                sFile = arguments[0];
                iLine = arguments[1];
            }
            else {
                if(isDef(arguments[0]) && !(isNull(arguments[0]))){
                    sFile = arguments[0].file;
                    iLine = arguments[0].line;
                }
                else{
                    sFile = "";
                    iLine = 0;
                }
            }

            this._pCurrentSourceLocation.file = sFile;
            this._pCurrentSourceLocation.line = iLine;
        }


        log(...pArgs: any[]): void {
            if(!bf.testAll(this._eLogLevel, ELogLevel.LOG)){
                return;
            }

            var fnLogRoutine:ILogRoutineFunc = this._pGeneralRoutineMap[ELogLevel.LOG];
            if(!isDef(fnLogRoutine)){
                return;
            }

            var pLogEntity: ILoggerEntity = this._pLastLogEntity;

            pLogEntity.code = this._eUnknownCode;
            pLogEntity.location = this._pCurrentSourceLocation;
            pLogEntity.info = pArgs;
            pLogEntity.message = this._sUnknownMessage;

            fnLogRoutine.call(null, pLogEntity);
        }

        info(pEntity: ILoggerEntity): void;
        info(eCode:  number , ...pArgs: any[]): void;
        info(...pArgs: any[]): void;
        info(): void {
            if(!bf.testAll(this._eLogLevel, ELogLevel.INFORMATION)){
                return;
            }

            var pLogEntity: ILoggerEntity;
            var fnLogRoutine: ILogRoutineFunc;

            pLogEntity = this.prepareLogEntity.apply(this, arguments);
            fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, ELogLevel.INFORMATION);

            if(isNull(fnLogRoutine)){
                return;
            }

            fnLogRoutine.call(null, pLogEntity);
        }

        warning(pEntity: ILoggerEntity): void;
        warning(eCode:  number , ...pArgs: any[]): void;
        warning(...pArgs: any[]): void;
        warning(): void {
            if(!bf.testAll(this._eLogLevel, ELogLevel.WARNING)){
                return;
            }

            var pLogEntity: ILoggerEntity;
            var fnLogRoutine: ILogRoutineFunc;

            pLogEntity = this.prepareLogEntity.apply(this, arguments);
            fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, ELogLevel.WARNING);

            if(isNull(fnLogRoutine)){
                return;
            }

            fnLogRoutine.call(null, pLogEntity);
        }

        error(pEntity: ILoggerEntity): void;
        error(eCode:  number , ...pArgs: any[]): void;
        error(...pArgs: any[]): void;
        error(): void {
            if(!bf.testAll(this._eLogLevel, ELogLevel.ERROR)){
                return;
            }

            var pLogEntity: ILoggerEntity;
            var fnLogRoutine: ILogRoutineFunc;

            pLogEntity = this.prepareLogEntity.apply(this, arguments);
            fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, ELogLevel.ERROR);

            if(isNull(fnLogRoutine)){
                return;
            }

            fnLogRoutine.call(null, pLogEntity);
        }

        criticalError(pEntity: ILoggerEntity): void;
        criticalError(eCode:  number , ...pArgs: any[]): void;
        criticalError(...pArgs: any[]):void;
        criticalError():void {

            var pLogEntity: ILoggerEntity;
            var fnLogRoutine: ILogRoutineFunc;

            pLogEntity = this.prepareLogEntity.apply(this, arguments);
            fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, ELogLevel.CRITICAL);

            var sSystemMessage: string = "A Critical error has occured! Code: " + pLogEntity.code.toString();

            if(bf.testAll(this._eLogLevel, ELogLevel.CRITICAL) && !isNull(fnLogRoutine)){
                fnLogRoutine.call(null, pLogEntity);
            }

            alert(sSystemMessage);
            throw new Error(sSystemMessage);
        }

        assert(bCondition: bool, pEntity: ILoggerEntity): void;
        assert(bCondition: bool, eCode:  number , ...pArgs: any[]): void;
        assert(bCondition: bool, ...pArgs: any[]):void;
        assert():void{
            var bCondition: bool = <bool> arguments[0];

            if(!bCondition){
                var pLogEntity: ILoggerEntity;
                var fnLogRoutine: ILogRoutineFunc;

                var pArgs: any[] = [];

                for(var i = 1; i < arguments.length; i++){
                    pArgs[i - 1] = arguments[i];
                }

                pLogEntity = this.prepareLogEntity.apply(this, pArgs);
                fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, ELogLevel.CRITICAL);

                var sSystemMessage: string = "A error has occured! Code: " + pLogEntity.code.toString() +
                                             "\n Accept to exit, refuse to continue.";

                if(bf.testAll(this._eLogLevel, ELogLevel.CRITICAL) && !isNull(fnLogRoutine)){
                    fnLogRoutine.call(null, pLogEntity);
                }

                if(confirm(sSystemMessage)){
                    throw new Error(sSystemMessage);
                }
            }
        }


        private generateFamilyName(): string {
            var sSuffix: string = <string><any>(this._nFamilyGenerator++);
            var sName: string = Logger._sDefaultFamilyName + sSuffix;

            if(this.isUsedFamilyName(sName)){
                return this.generateFamilyName();
            }
            else {
                return sName;
            }
        }

        private isValidCodeInterval(eCodeMin:  number , eCodeMax:  number ): bool{
            if(eCodeMin > eCodeMax){
                return false;
            }

            var i:  number  = 0;
            var pCodeFamilyList: ICodeFamily[] = this._pCodeFamilyList;
            var pCodeFamily: ICodeFamily;

            for(i = 0; i < pCodeFamilyList.length; i++){
                pCodeFamily = pCodeFamilyList[i];

                if((pCodeFamily.codeMin <= eCodeMin && pCodeFamily.codeMax >= eCodeMin) ||
                   (pCodeFamily.codeMin <= eCodeMax && pCodeFamily.codeMax >= eCodeMax)){

                    return false;
                }
            }

            return true;
        }

        private  /**@inline*/  isUsedFamilyName(sFamilyName: string): bool{
            return isDef(this._pCodeFamilyMap[sFamilyName]);
        }

        private  /**@inline*/  isUsedCode(eCode:  number ): bool{
            return isDef(this._pCodeInfoMap[eCode]);
        }

        private isLogEntity(pObj:any):bool {
            if(isObject(pObj) && isDef(pObj.code) && isDef(pObj.location)){
                return true;
            }

            return false;
        }

        private  /**@inline*/  isLogCode(eCode:any):bool {
            return isInt(eCode);
        }

        private prepareLogEntity(pEntity: ILoggerEntity): void;
        private prepareLogEntity(eCode:  number , ...pArgs: any[]): void;
        private prepareLogEntity(pArgs:any[]): ILoggerEntity;
        private prepareLogEntity(): ILoggerEntity{
            var eCode:  number  = this._eUnknownCode;
            var sMessage:string = this._sUnknownMessage;
            var pInfo: any = null;

            if(arguments.length === 1 && this.isLogEntity(arguments[0])){
                var pEntity: ILoggerEntity = arguments[0];

                eCode = pEntity.code;
                pInfo = pEntity.info;
                this.setSourceLocation(pEntity.location);

                if(!isDef(pEntity.message)){
                    var pCodeInfo: ICodeInfo = this._pCodeInfoMap[eCode];
                    if(isDef(pCodeInfo)){
                        sMessage = pCodeInfo.message;
                    }
                }

            }
            else {
                if(this.isLogCode(arguments[0])){
                    eCode = < number >arguments[0];
                    if(arguments.length > 1){
                        pInfo = new Array(arguments.length - 1);
                        var i:  number  = 0;

                        for(i = 0; i < pInfo.length; i++){
                            pInfo[i] = arguments[i+1];
                        }
                    }
                }
                else {
                    eCode = this._eUnknownCode;
                    if(arguments.length > 0){
                        pInfo = new Array(arguments.length);
                        var i:  number  = 0;

                        for(i = 0; i < pInfo.length; i++){
                            pInfo[i] = arguments[i];
                        }
                    }
                    else {
                        pInfo = null;
                    }
                }

                var pCodeInfo: ICodeInfo = this._pCodeInfoMap[eCode];
                if(isDef(pCodeInfo)){
                    sMessage = pCodeInfo.message;
                }
            }

            var pLogEntity: ILoggerEntity = this._pLastLogEntity;

            pLogEntity.code = eCode;
            pLogEntity.location = this._pCurrentSourceLocation;
            pLogEntity.message = sMessage;
            pLogEntity.info = pInfo;

            return pLogEntity;
        }

        private getCodeRoutineFunc(eCode:  number , eLevel: ELogLevel): ILogRoutineFunc{
            var pCodeInfo: ICodeInfo = this._pCodeInfoMap[eCode];
            var fnLogRoutine: ILogRoutineFunc;

            if(!isDef(pCodeInfo)){
                fnLogRoutine = this._pGeneralRoutineMap[eLevel];
                return isDef(fnLogRoutine) ? fnLogRoutine : null;
            }

            var pCodeFamilyRoutineMap: ILogRoutineMap = this._pCodeFamilyRoutineDMap[pCodeInfo.familyName];

            if(!isDef(pCodeFamilyRoutineMap) || !isDef(pCodeFamilyRoutineMap[eLevel])) {
                fnLogRoutine = this._pGeneralRoutineMap[eLevel];
                return isDef(fnLogRoutine) ? fnLogRoutine : null;
            }

            fnLogRoutine = pCodeFamilyRoutineMap[eLevel];

            return fnLogRoutine;
        }

    }
}

module akra.util {
    export var logger: ILogger = new Logger();

    logger.init();
    logger.setUnknownCode( 0 ,  "Unknown code." );
    logger.setLogLevel(ELogLevel.ALL);

//Default code families

    logger.registerCodeFamily(0, 100, "SystemCodes");
    logger.registerCodeFamily(2000, 2199, "ParserSyntaxErrors");
    logger.registerCodeFamily(2200, 2500, "EffectSyntaxErrors");

//Default log routines

    function sourceLocationToString(pLocation: ISourceLocation): string {
        var sLocation:string = "[" + pLocation.file + ":" + pLocation.line.toString() + "]: ";
        return sLocation;
    }

    function logRoutine(pLogEntity: ILoggerEntity): void{
        var pArgs:any[] = pLogEntity.info;

        pArgs.unshift(sourceLocationToString(pLogEntity.location));
        console["log"].apply(console, pArgs);
    }

    function warningRoutine(pLogEntity: ILoggerEntity): void{
        var pArgs:any[] = pLogEntity.info;

        pArgs.unshift("Code: " + pLogEntity.code.toString());
        pArgs.unshift(sourceLocationToString(pLogEntity.location));

        console["warn"].apply(console, pArgs);
    }

    function errorRoutine(pLogEntity: ILoggerEntity): void{
        var pArgs:any[] = pLogEntity.info;

        pArgs.unshift(pLogEntity.message);
        pArgs.unshift("Error code: " + pLogEntity.code.toString() + ".");
        pArgs.unshift(sourceLocationToString(pLogEntity.location));

        console["error"].apply(console, pArgs);
    }


    logger.setLogRoutine(logRoutine, ELogLevel.LOG | ELogLevel.INFORMATION);
    logger.setLogRoutine(warningRoutine, ELogLevel.WARNING);
    logger.setLogRoutine(errorRoutine, ELogLevel.ERROR | ELogLevel.CRITICAL);
}

module akra {
    logger = util.logger;
}














module akra {

	export interface IObjectArray {} ;

	export interface IDisplayList extends IEventProvider {
		 name: string;
//если используется <quick search>, то в случае если узлы сцены не были изменены, выдается null.
		_findObjects(pCamera: ICamera, bQuickSearch?: bool): IObjectArray;
		_setup(pScene: IScene3d): void;
	}
}



module akra {

	export interface IRect3d {} ;
	export interface IOcTreeNode {} ;
	export interface ISceneObject {} ;
	export interface IOcTreeRect {} ;
	export interface IVec3 {} ;

	export interface IOcTree extends IDisplayList {

		 depth:  number ;
		 worldScale: IVec3;
		 worldOffset: IVec3;

		create(pWorldBoundingBox: IRect3d, iDepth:  number , nNode?:  number ): void;
		isReady(): bool;
		findTreeNode(pObject: ISceneObject): IOcTreeNode;
		findTreeNodeByRect(iX0:  number , iX1:  number , iY0:  number , iY1:  number , iZ0:  number , iZ1:  number ): IOcTreeNode;
		getAndSetFreeNode(iLevel:  number , iComposedIndex:  number , pParentNode: IOcTreeNode): IOcTreeNode;
		deleteNodeFromTree(pNode: IOcTreeNode): void;

		_buildSearchResults(pSearchRect: IRect3d, pOptionalFrustum?: IFrustum): IObjectArray;

//debug metod
		_toSimpleObject(pNode?: IOcTreeNode): any;

//getAndSetFreeNode(iLevel: int, iX: int, iY: int, iZ: int, iIndex: int): IOcTreeNode;
//getNodeFromLevelXYZ(iLevel: int, iIndex: int): IOcTreeNode;
//destroy(): void;
//findTreeNode(iX0: int, iX1: int, iY0: int, iY1: int, iZ0: int, iZ1: int): IOcTreeNode;
//buildByteRect(pWorldRect: IRect3d, pWorldByteRect: IOcTreeRect): void;
//addOrUpdateSceneObject(pNewNode: ISceneObject): IOcTreeNode;
	}
}























module akra {
	export interface IEventTable {} ;

	export enum EEventTypes {
		BROADCAST,
		UNICAST
	};

	export interface IEventProvider {
		getGuid():  number ;
		getEventTable(): IEventTable;
		connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool;
		disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool;																														bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool;																															unbind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool;
	}
}



module akra {
	export enum ESceneTypes {
		TYPE_3D,
		TYPE_2D
	}

	export interface IScene extends IEventProvider {
		type: ESceneTypes;
	}
}






module akra {
	export interface ISceneNode {} ;
	export interface ISceneModel {} ;
	export interface ILightPoint {} ;
	export interface ISprite {} ;
	export interface IJoint {} ;
	export interface IText3d {} ;
	export interface IDisplayList {} ;



	export interface IScene3d extends IScene {
		totalDL:  number ;

		getRootNode(): ISceneNode;

		recursivePreUpdate(): void;
		updateCamera(): bool;
		updateScene(): bool;
		recursiveUpdate(): void;

		isUpdated(): bool;

		createNode(sName?: string): ISceneNode;
		createModel(sName?: string): ISceneModel;
		createCamera(sName?: string): ICamera;
		createLightPoint(sName?: string): ILightPoint;
		createSprite(sName?: string): ISprite;
		createJoint(sName?: string): IJoint;
		createText3d(sName?: string): IText3d;

		getDisplayList(index:  number ): IDisplayList;
		getDisplayListByName(csName: string):  number ;
		addDisplayList(pList: IDisplayList):  number ;
		delDisplayList(index:  number ): bool;

		 nodeAttachment(pNode: ISceneNode): void;
		 nodeDetachment(pNode: ISceneNode): void;

		 displayListAdded(pList: IDisplayList, index:  number ): void;
		 displayListRemoved(pList: IDisplayList, index:  number ): void;

		_render(pCamera: ICamera, pViewport: IViewport): void;
	}
}


















module akra {

	export interface IExplorerFunc {} ;
	export interface IReferenceCounter {} ;

	export enum  EEntityTypes {
		UNKNOWN,
		NODE,

		JOINT,

		SCENE_NODE,

		CAMERA,

		LIGHT_PROJECT = 37,
		LIGHT_OMNI_DIRECTIONAL,

		SCENE_OBJECT = 64,

		MODEL,
		TERRAIN_SECTION,
		TEXT3D,
		SPRITE,
		EMITTER,

		OBJECTS_LIMIT = 128
	}

	export interface IEntity extends IEventProvider, IReferenceCounter {
		name: string;

		parent: IEntity;
		sibling: IEntity;
		child: IEntity;

		 type: EEntityTypes;

		 depth:  number ;
		 root: IEntity;

		create(): bool;
		destroy(): void;

		findEntity(sName: string): IEntity;
		explore(fn: IExplorerFunc): void;
		childOf(pParent: IEntity): bool;
		siblingCount():  number ;
		childCount():  number ;

		update(): bool;
		recursiveUpdate(): bool;
		recursivePreUpdate(): void;
		prepareForUpdate(): void;

		hasParent(): bool;
		hasChild(): bool;
		hasSibling(): bool;

		isASibling(pSibling: IEntity): bool;
		isAChild(pChild: IEntity): bool;
		isInFamily(pEntity: IEntity, bSearchEntireTree?: bool): bool;

//обновлен ли сам узел
		isUpdated(): bool;
//есть ли обновления среди потомков?
		hasUpdatedSubNodes(): bool;


		addSibling(pSibling: IEntity): IEntity;
		addChild(pChild: IEntity): IEntity;
		removeChild(pChild: IEntity): IEntity;
		removeAllChildren(): void;

		attachToParent(pParent: IEntity): bool;
		detachFromParent(): bool;

		promoteChildren(): void;
		relocateChildren(pParent: IEntity): void;

		toString(isRecursive?: bool, iDepth?:  number ): string;

		 attached();
		 detached();
	}

}



module akra {

	export interface IVec3 {} ;
	export interface IMat3 {} ;
	export interface IMat4 {} ;
	export interface IQuat4 {} ;

	export enum ENodeInheritance {
//inheritance only position
		POSITION = 0,
//inheritance rotation and scale only
        ROTSCALE,
//inheritance all
    	ALL
	};

	export interface INodeMap{
		[index: string]: INode;
	}

	export interface INode extends IEntity {
		localOrientation: IQuat4;
		localPosition: IVec3;
		localScale: IVec3;
		localMatrix: IMat4;

		 worldMatrix: IMat4;
		 worldPosition: IVec3;

		 inverseWorldMatrix: IMat4;
		 normalMatrix: IMat3;

		setInheritance(eInheritance: ENodeInheritance);
		getInheritance(): ENodeInheritance;

		isWorldMatrixNew(): bool;
		isLocalMatrixNew(): bool;

//recalcWorldMatrix(): bool;

		setPosition(v3fPosition: IVec3): void;
		setPosition(fX:  number , fY:  number , fZ:  number ): void;

		addPosition(v3fPosition: IVec3): void;
		addPosition(fX:  number , fY:  number , fZ:  number ): void;
		addRelPosition(v3fPosition: IVec3): void;
		addRelPosition(fX:  number , fY:  number , fZ:  number ): void;

		setRotationByMatrix(m3fRotation: IMat3): void;
		setRotationByMatrix(m4fRotation: IMat4): void;
		setRotationByAxisAngle(v3fAxis: IVec3, fAngle:  number ): void;
		setRotationByForwardUp(v3fForward: IVec3, v3fUp: IVec3): void;
		setRotationByEulerAngles(fYaw:  number , fPitch:  number , fRoll:  number ): void;
		setRotationByXYZAxis(fX:  number , fY:  number , fZ:  number ): void;
		setRotation(q4fRotation: IQuat4): void;

		addRelRotationByMatrix(m4fRotation: IMat4): void;
		addRelRotationByMatrix(m3fRotation: IMat3): void;
		addRelRotationByAxisAngle(v3fAxis: IVec3, fAngle:  number ): void;
		addRelRotationByForwardUp(v3fForward: IVec3, v3fUp: IVec3): void;
		addRelRotationByEulerAngles(fYaw:  number , fPitch:  number , fRoll:  number ): void;
		addRelRotationByXYZAxis(fX:  number , fY:  number , fZ:  number ): void;
		addRelRotation(q4fRotation: IQuat4): void;

		addRotationByMatrix(m4fRotation: IMat4): void;
		addRotationByMatrix(m3fRotation: IMat3): void;
		addRotationByAxisAngle(v3fAxis: IVec3, fAngle:  number ): void;
		addRotationByForwardUp(v3fForward: IVec3, v3fUp: IVec3): void;
		addRotationByEulerAngles(fYaw:  number , fPitch:  number , fRoll:  number ): void;
		addRotationByXYZAxis(fX:  number , fY:  number , fZ:  number ): void;
		addRotation(q4fRotation: IQuat4): void;

		scale(fScale:  number ): void;
		scale(fX:  number , fY:  number , fZ:  number ): void;
	}
}



module akra {
    export interface ISceneNodeMap {
        [index: string]: ISceneNode;
    }

    export interface ISceneNode extends INode {
    	scene: IScene3d;

/** @deprecated */

    	render(): void;
/** @deprecated */

    	prepareForRender(): void;
/** @deprecated */

    	recursiveRender(): void;
    }
}



module akra {
    export interface IRect3d {} ;
	export interface IRenderableObject {} ;

    export interface ISceneObject extends ISceneNode {
    	worldBounds: IRect3d;
    	totalRenderable:  number ;

    	 localBounds: IRect3d;

        getRenderable(i?:  number ): IRenderableObject;
    	getObjectFlags():  number ;

    	accessLocalBounds(): IRect3d;
    	isWorldBoundsNew(): bool;
// recalcWorldBounds(): void;

    	hasShadows(): bool;
    	setShadows(bValue?: bool): void;

         worldBoundsUpdated(): void;
    }
}









module akra {
	export interface IViewport {} ;
	export interface IVec3 {} ;
	export interface IMat4 {} ;
	export interface IRect3d {} ;
	export interface IFrustum {} ;
    export interface ISceneBuilder {} ;
    export interface IObjectArray {} ;

	export enum ECameraParameters {
        CONST_ASPECT = 1
	}

    export enum ECameraTypes {
        PERSPECTIVE,
        ORTHO,
        OFFSET_ORTHO
    }



    export interface ICamera extends ISceneNode {
    	 viewMatrix: IMat4;
    	 projectionMatrix: IMat4;
    	 projViewMatrix: IMat4;
    	 internalProjectionMatrix: IMat4;
    	 internalViewProjMatrix: IMat4;
    	 targetPos: IVec3;

        fov:  number ;
    	aspect:  number ;
    	nearPlane:  number ;
    	farPlane:  number ;

    	 viewDistance:  number ;
    	 searchRect: IRect3d;
    	 frustum: IFrustum;



    	setParameter(eParam: ECameraParameters, pValue: any): void;
    	isConstantAspect(): bool;

    	setProjParams(fFOV:  number , fAspect:  number , fNearPlane:  number , fFarPlane:  number ): void;
    	setOrthoParams(fWidth:  number , fHeight:  number , fNearPlane:  number , fFarPlane:  number ): void;
    	setOffsetOrthoParams(fMinX:  number , fMaxX:  number , fMinY:  number , fMaxY:  number , fNearPlane:  number , fFarPlane:  number ): void;

//moved to private.
// recalcMatrices(): void;

    	applyRenderStageBias(iStage:  number ): void;

    	lookAt(v3fFrom: IVec3, v3fCenter: IVec3, v3fUp?: IVec3);
    	lookAt(v3fCenter: IVec3, v3fUp?: IVec3);

//display via display list with name <csList>
        display(iList?:  number ): IObjectArray;

    	_renderScene(pViewport: IViewport): void;
    	_keepLastViewport(pViewport: IViewport): void;
    	_getLastViewport(): IViewport;
    	_getNumRenderedFaces():  number ;
        _notifyRenderedFaces(nFaces:  number ): void;
    }
}










module akra {
	export interface IEventSlot {
		target: any;
		callback: string;
		listener: Function;
	}

	export interface IEventSlotListMap {
		[index: string]: IEventSlot[];
	}
	export interface IEventSlotMap {
		[index: string]: IEventSlot;
	}

	export interface IEventSlotTable {
		[index: number]: IEventSlotListMap;
		[index: string]: IEventSlotListMap;
	}

	export interface IEventSlotList {
		[index: number]: IEventSlotMap;
		[index: string]: IEventSlotMap;
	}

	export interface IEventTable {
		broadcast: IEventSlotTable;
		unicast: IEventSlotList;

		addDestination(iGuid:  number , sSignal: string, pTarget: IEventProvider, sSlot: string, eType?: EEventTypes): bool;
		removeDestination(iGuid:  number , sSignal: string, pTarget: IEventProvider, sSlot: string, eType?: EEventTypes): bool;
		addListener(iGuid:  number , sSignal: string, fnListener: Function, eType?: EEventTypes): bool;
		removeListener(iGuid:  number , sSignal: string, fnListener: Function, eType?: EEventTypes): bool;

		findUnicastList(iGuid:  number ): IEventSlotMap;
		findBroadcastList(iGuid:  number ): IEventSlotListMap;
	}
}







/*console.error(this.getEventTable());*/











/**event, signal, slot*/


/**event, signal, slot*/










module akra.events {
	export class EventTable implements IEventTable {
		broadcast: IEventSlotTable = <IEventSlotTable>{};
		unicast: IEventSlotList = <IEventSlotList>{};

		addDestination(iGuid:  number , sSignal: string, pTarget: IEventProvider, sSlot: string, eType: EEventTypes = EEventTypes.BROADCAST): bool {
			if (eType === EEventTypes.BROADCAST) {
				this.findBroadcastSignalMap(iGuid, sSignal).push({target: pTarget, callback: sSlot, listener: null});
				return true;
			}
			else {
				this.unicast[iGuid] = this.unicast[iGuid] || {};
//console.log(iGuid, sSignal, pTarget, sSlot, eType);
//console.warn(this.unicast);
				if (!isDef(this.unicast[iGuid][sSignal])) {
					this.unicast[iGuid][sSignal] = {target: pTarget, callback: sSlot, listener: null};
					return true;
				}
			}
			return false;
		}

		removeDestination(iGuid:  number , sSignal: string, pTarget: IEventProvider, sSlot: string, eType: EEventTypes = EEventTypes.BROADCAST): bool {
			if (eType === EEventTypes.BROADCAST) {
				var pList: IEventSlot[] = this.findBroadcastSignalMap(iGuid, sSignal);
				for (var i:  number  = 0; i < pList.length; ++ i) {
					if (pList[i].target === pTarget && pList[i].callback === sSlot) {
						pList.splice(i, 1);
						return true;
					}
				}
			}
			else {
				if (this.unicast[iGuid] && this.unicast[iGuid][sSignal]) {
					delete this.unicast[iGuid][sSignal];
					return true;
				}
			}
			logger.setSourceLocation( "events/events.ts" , 109 ); logger.warning("cannot remove destination for GUID <%s> with signal <%s>", iGuid, sSignal); ;
			return false;
		}

		addListener(iGuid:  number , sSignal: string, fnListener: Function, eType: EEventTypes = EEventTypes.BROADCAST): bool {
			if (eType === EEventTypes.BROADCAST) {
				this.findBroadcastSignalMap(iGuid, sSignal).push({target: null, callback: null, listener: fnListener});
				return true;
			}
			else {
				this.unicast[iGuid] = this.unicast[iGuid] || {};
				if (!isDef(this.unicast[iGuid][sSignal])) {
					this.unicast[iGuid][sSignal] = {target: null, callback: null, listener: fnListener};
					return true;
				}
			}
			logger.setSourceLocation( "events/events.ts" , 125 ); logger.warning("cannot add listener for GUID <%s> with signal <%s>", iGuid, sSignal); ;
			return false;
		}

		removeListener(iGuid:  number , sSignal: string, fnListener: Function, eType: EEventTypes = EEventTypes.BROADCAST): bool {
			if (eType === EEventTypes.BROADCAST) {
				var pList: IEventSlot[] = this.findBroadcastSignalMap(iGuid, sSignal);
				for (var i:  number  = 0; i < pList.length; ++ i) {
					if (pList[i].listener === fnListener) {
						pList.splice(i, 1);
						return true;
					}
				}
			}
			else {
				if (this.unicast[iGuid] && this.unicast[iGuid][sSignal]) {
					delete this.unicast[iGuid][sSignal];
					return true;
				}
			}
			return false;
		}

		findBroadcastList(iGuid:  number ): IEventSlotListMap {
			this.broadcast[iGuid] = this.broadcast[iGuid] || {};
			return this.broadcast[iGuid];
		}

		findUnicastList(iGuid:  number ): IEventSlotMap {
//console.error(iGuid,this.unicast[iGuid]);

			this.unicast[iGuid] = this.unicast[iGuid] || {};
			return this.unicast[iGuid];
		}

		private findBroadcastSignalMap(iGuid:  number , sSignal: string): IEventSlot[] {
			this.broadcast[iGuid] = this.broadcast[iGuid] || {};
			this.broadcast[iGuid][sSignal] = this.broadcast[iGuid][sSignal] || [];
			return this.broadcast[iGuid][sSignal];
		}

		private
	}
}

















module akra {

	export interface ISceneManager {} ;
	export interface IParticleManager {} ;
	export interface IResourcePoolManager {} ;
    export interface IRenderer {} ;
	export interface IUtilTimer {} ;
    export interface IMesh {} ;
    export interface IRenderDataCollection {} ;
    export interface IBufferMap {} ;
    export interface IAnimationController {} ;
    export interface ISkeleton {} ;

    export interface IEngine extends IEventProvider {
        getSceneManager(): ISceneManager;
        getParticleManager(): IParticleManager;
        getResourceManager(): IResourcePoolManager;

        getRenderer(): IRenderer;

        pause(): bool;
        play(): bool;

/** Render one frame. */

        renderFrame(): bool;

/** Start exucution(rendering loop). */

        exec(): void;
/** Определяет, находитсяли Engine в цикле рендеринга */

        isActive(): bool;

        getTimer(): IUtilTimer;

        createMesh(sName?: string, eOptions?:  number , pDataBuffer?: IRenderDataCollection): IMesh;

        createRenderDataCollection(iOptions?:  number ): IRenderDataCollection;
        createBufferMap(): IBufferMap;

        createAnimationController(iOptions?:  number ): IAnimationController;


    };

    export var createEngine: () => IEngine;
}























module akra {

	export interface IEntity {} ;

	export interface IExplorerFunc {
		(pEntity: IEntity): bool;
	}
}












module akra {
	export interface IReferenceCounter {
/**
		 * Текущее количесвто ссылок  на объект
		 **/

		referenceCount():  number ;

/** Предупреждает если объект еще используется */

		destructor(): void;


/**
		 * Добаволение ссылки  на объект, увеличивает внутренний счетчки на 1,
		 * проверяет не достигнуто ли максимальное количесвто
		 **/

		addRef():  number ;

/**
		 * Уведомление об удалении ссылки  на объект, уменьшает внутренний счетчки на 1,
		 * проверяет есть ли ее объекты
		 **/

		release():  number ;


/** 
		 * Данная функция нужна чтобы обеспечить наследникам ее возможность,
		 * само количестdо ссылок не копируется
		 */

		eq(pSrc: IReferenceCounter): IReferenceCounter;
	}
}



module akra.util {
	export class ReferenceCounter implements IReferenceCounter {
		private nReferenceCount:  number  = 0;

/** Выстанавливает чило ссылок  на объект в ноль */

		constructor ();
/** 
		 * Выстанавливает чило ссылок  на объект в ноль
 		 * количесвто ссылок привязаны к конкретному экземпляру, поэтому никогда не копируются 
 		 */

		constructor (pSrc: IReferenceCounter);
		constructor (pSrc?) {}

/** @inline */

		referenceCount():  number  {
			return this.nReferenceCount;
		}

/** @inline */

		destructor(): void {
			logger.setSourceLocation( "util/ReferenceCounter.ts" , 26 ); logger.assert(this.nReferenceCount === 0, 'object is used'); ;
		}

		release():  number  {
			logger.setSourceLocation( "util/ReferenceCounter.ts" , 30 ); logger.assert(this.nReferenceCount > 0, 'object is used'); ;
		    this.nReferenceCount--;
		    return this.nReferenceCount;
		}

		addRef():  number  {
			logger.setSourceLocation( "util/ReferenceCounter.ts" , 36 ); logger.assert(this.nReferenceCount != MIN_INT32, 'reference fail'); ;

    		this.nReferenceCount ++;

			return this.nReferenceCount;
		}

/** @inline */

		eq (pSrc: IReferenceCounter): IReferenceCounter {
		    return this;
		};
	}
}



module akra.util {
	export enum EEntityStates {
//обновился ли сам узел?
		k_Updated = 0x01,
//есть ли среди потомков обновленные узлы
		k_DescendantsUpdtated = 0x02,
//если ли обновленные узлы среди братьев или их потомках
		k_SiblingsUpdated = 0x04
	}

	export class Entity extends ReferenceCounter implements IEntity {
		/**@protected*/  _sName: string = null;
		/**@protected*/  _pParent: IEntity = null;
		/**@protected*/  _pSibling: IEntity = null;
		/**@protected*/  _pChild: IEntity = null;
		/**@protected*/  _eType: EEntityTypes = EEntityTypes.UNKNOWN;
		/**@protected*/  _iStateFlags:  number  = 0;

		/**@inline*/  get name(): string { return this._sName; }
		/**@inline*/  set name(sName: string) { this._sName = sName; }

		/**@inline*/  get parent(): IEntity { return this._pParent; }
		/**@inline*/  set parent(pParent: IEntity) { this.attachToParent(pParent); }

		/**@inline*/  get sibling(): IEntity { return this._pSibling; }
		/**@inline*/  set sibling(pSibling: IEntity) { this._pSibling = pSibling; }

		/**@inline*/  get child(): IEntity { return this._pChild; }
		/**@inline*/  set child(pChild: IEntity) { this._pChild = pChild; }

		/**@inline*/  get type(): EEntityTypes { return this._eType; }

		get depth():  number  {
			var iDepth:  number  = -1;
	        for (var pEntity: IEntity = this; pEntity; pEntity = pEntity.parent, ++ iDepth){};
	        return iDepth;
		}

		get root(): IEntity {
	        for (var pEntity: IEntity = this, iDepth:  number  = -1; pEntity.parent; pEntity = pEntity.parent, ++ iDepth){};
	        return pEntity;
		}


		create(): bool {
			return true;
		}

		destroy(): void {
// destroy anything attached to this node
//	destroySceneObject();
// promote any children up to our parent
		    this.promoteChildren();
// now remove ourselves from our parent
		    this.detachFromParent();
// we should now be removed from the tree, and have no dependants
		    logger.setSourceLocation( "util/Entity.ts" , 65 ); logger.assert(this.referenceCount() == 0, "Attempting to delete a scene node which is still in use"); ;
		    logger.setSourceLocation( "util/Entity.ts" , 66 ); logger.assert(this._pSibling == null, "Failure Destroying Node"); ;
		    logger.setSourceLocation( "util/Entity.ts" , 67 ); logger.assert(this._pChild == null, "Failure Destroying Node"); ;
		}

		findEntity(sName: string): IEntity {
			 var pEntity: IEntity = null;

		    if (this._sName === sName) {
		        return this;
		    }

		    if (this._pSibling) {
		        pEntity = this._pSibling.findEntity(sName);
		    }

		    if (pEntity == null && this._pChild) {
		        pEntity = this._pChild.findEntity(sName);
		    }

		    return pEntity;
		}

		explore(fn: IExplorerFunc): void {
			if (fn(this) === false) {
		        return;
		    }

		    if (this._pSibling) {
		        this._pSibling.explore(fn);
		    }

		    if (this._pChild) {
		        this._pChild.explore(fn);
		    }
		}


		childOf(pParent: IEntity): bool {
			for (var pEntity: IEntity = this; pEntity; pEntity = pEntity.parent) {
		        if (pEntity.parent === pParent) {
		            return true;
		        }
		    }

		    return false;
		}


/**
		 * Returns the current number of siblings of this object.
		 */

		siblingCount():  number  {
			var iCount:  number  = 0;

		    if (this._pParent) {
		        var pNextSibling = this._pParent.child;
		        if (pNextSibling) {
		            while (pNextSibling) {
		                pNextSibling = pNextSibling.sibling;
		                ++ iCount;
		            }
		        }
		    }

		    return iCount;
		}


/**
		 * Returns the current number of children of this object
		 */

		childCount():  number  {
			var iCount:  number  = 0;

		    var pNextChild: IEntity = this.child;

		    if (pNextChild) {
		        ++ iCount;
		        while (pNextChild) {
		            pNextChild = pNextChild.sibling;
		            ++ iCount;
		        }
		    }
		    return iCount;
		}

		/**@inline*/  isUpdated(): bool {
			return  ((this._iStateFlags & (1 << (EEntityStates.k_Updated)) ) != 0) ;
		}

		/**@inline*/  hasUpdatedSubNodes(): bool {
			return  ((this._iStateFlags & (1 << (EEntityStates.k_DescendantsUpdtated)) ) != 0) ;
		}

		recursiveUpdate(): bool {
// var bUpdated: bool = false;
// update myself
		    if (this.update()) {
		    	((this._iStateFlags) |= (EEntityStates.k_Updated)) ;
// bUpdated = true;
		    }
// update my sibling
		    if (this._pSibling && this._pSibling.recursiveUpdate()) {
		        ((this._iStateFlags) |= (EEntityStates.k_SiblingsUpdated)) ;
// bUpdated = true;
		    }
// update my child
		    if (this._pChild && this._pChild.recursiveUpdate()) {
		        ((this._iStateFlags) |= (EEntityStates.k_DescendantsUpdtated)) ;
// bUpdated = true;
		    }

/*bUpdated*/
/* */
		    return (this._iStateFlags != 0);
		}

		recursivePreUpdate(): void {
// clear the flags from the previous update
		    this.prepareForUpdate();

// update my sibling
		    if (this._pSibling) {
		        this._pSibling.recursivePreUpdate();
		    }
// update my child
		    if (this._pChild) {
		        this._pChild.recursivePreUpdate();
		    }
		}


		prepareForUpdate(): void {
//this._iStateFlags = 0;
		};

/** Parent is not undef */

		/**@inline*/  hasParent(): bool {
		    return isDefAndNotNull(this._pParent);
		}

/** Child is not undef*/

		/**@inline*/  hasChild(): bool {
		    return isDefAndNotNull(this._pChild);
		}

/** Sibling is not undef */

		/**@inline*/  hasSibling(): bool {
			return isDefAndNotNull(this._pSibling);
		}

/**
		 * Checks to see if the provided item is a sibling of this object
		 */

		isASibling(pSibling: IEntity): bool {
			if (!pSibling) {
		        return false;
		    }
// if the sibling we are looking for is me, or my FirstSibling, return true
		    if (this == pSibling || this._pSibling == pSibling) {
		        return true;
		    }
// if we have a sibling, continue searching
		    if (this._pSibling) {
		        return this._pSibling.isASibling(pSibling);
		    }
// it's not us, and we have no sibling to check. This is not a sibling of ours.
		    return false;
		}

/** Checks to see if the provided item is a child of this object. (one branch depth only) */

		isAChild(pChild: IEntity): bool {
			if (!pChild) {
		        return (false);
		    }
// if the sibling we are looking for is my FirstChild return true
		    if (this._pChild == pChild) {
		        return (true);
		    }
// if we have a child, continue searching
		    if (this._pChild) {
		        return (this._pChild.isASibling(pChild));
		    }
// it's not us, and we have no child to check. This is not a sibling of ours.
		    return (false);
		}

/**
		 * Checks to see if the provided item is a child or sibling of this object. If SearchEntireTree
		 * is TRUE, the check is done recursivly through all siblings and children. SearchEntireTree
		 * is FALSE by default.
		 */

		isInFamily(pEntity: IEntity, bSearchEntireTree?: bool): bool {
			if (!pEntity) {
		        return (false);
		    }
// if the model we are looking for is me or my immediate family, return true
		    if (this == pEntity || this._pChild == pEntity || this._pSibling == pEntity) {
		        return (true);
		    }
// if not set to seach entire tree, just check my siblings and kids
		    if (!bSearchEntireTree) {
		        if (this.isASibling(pEntity)) {
		            return (true);
		        }
		        if (this._pChild && this._pChild.isASibling(pEntity)) {
		            return (true);
		        }
		    }
// seach entire Tree!!!
		    else {
		        if (this._pSibling && this._pSibling.isInFamily(pEntity, bSearchEntireTree)) {
		            return (true);
		        }

		        if (this._pChild && this._pChild.isInFamily(pEntity, bSearchEntireTree)) {
		            return (true);
		        }
		    }

		    return (false);
		}

/**
		 * Adds the provided ModelSpace object to the descendant list of this object. The provided
		 * ModelSpace object is removed from any parent it may already belong to.
		 */

		addSibling(pSibling: IEntity): IEntity {
			if (pSibling) {
// replace objects current sibling pointer with this new one
		        pSibling.sibling = this._pSibling;
		        this.sibling = pSibling;
		    }

		    return pSibling;
		}

/**
		 * Adds the provided ModelSpace object to the descendant list of this object. The provided
		 * ModelSpace object is removed from any parent it may already belong to.
		 */

		addChild(pChild: IEntity): IEntity {
			if (pChild) {
// Replace the new child's sibling pointer with our old first child.
		        pChild.sibling = this._pChild;
// the new child becomes our first child pointer.
		        this._pChild = pChild;
    		}

    		return pChild;
		}

/**
		 * Removes a specified child object from this parent object. If the child is not the
		 * FirstChild of this object, all of the Children are searched to find the object to remove.
		 */

		removeChild(pChild: IEntity): IEntity {
			if (this._pChild && pChild) {
		        if (this._pChild == pChild) {
		            this._pChild = pChild.sibling;
		            pChild.sibling  = null;
		        }
		        else {
		            var pTempNode: IEntity = this._pChild;
// keep searching until we find the node who's sibling is our target
// or we reach the end of the sibling chain
		            while (pTempNode && (pTempNode.sibling != pChild)) {
		                pTempNode = pTempNode.sibling;
		            }
// if we found the proper item, set it's FirstSibling to be the FirstSibling of the child
// we are removing
		            if (pTempNode) {
		                pTempNode.sibling = pChild.sibling;
		                pChild.sibling = null;
		            }
		        }
	    	}

	    	return pChild;
		}

/** Removes all Children from this parent object */

		removeAllChildren(): void {
// keep removing children until end of chain is reached
		    while (!isNull(this._pChild)) {
		        var pNextSibling = this._pChild.sibling;
		        this._pChild.detachFromParent();
		        this._pChild = pNextSibling;
		    }
		}

/** Attaches this object ot a new parent. Same as calling the parent's addChild() routine. */

		attachToParent(pParent: IEntity): bool {
			if (pParent != this._pParent) {

		        this.detachFromParent();

		        if (pParent) {
		            this._pParent = pParent;
		            this._pParent.addChild(this);
		            this._pParent.addRef();
		            this.attached();
		            return true;
		        }
	    	}

	    	return false;
		}

		detachFromParent(): bool {
// tell our current parent to release us
		    if (this._pParent) {
		        this._pParent.removeChild(this);
//TODO: разобраться что за херня!!!!
		        if (this._pParent) {
		            this._pParent.release();
		        }

		        this._pParent = null;
// my world matrix is now my local matrix
		        this.detached();
		        return true;
		    }

		    return false;
		}

/**
		 * Attaches this object's children to it's parent, promoting them up the tree
		 */

		promoteChildren(): void {
// Do I have any children to promote?
		    while (!isNull(this._pChild)) {
		        var pNextSibling: IEntity = this._pChild.sibling;
		        this._pChild.attachToParent(this._pParent);
		        this._pChild = pNextSibling;
		    }
		}

		relocateChildren(pParent: IEntity): void {
			if (pParent != this) {
// Do I have any children to relocate?
		        while (!isNull(this._pChild)) {
		            var pNextSibling: IEntity = this._pChild.sibling;
		            this._pChild.attachToParent(pParent);
		            this._pChild = pNextSibling;
		        }
		    }
		}

		update(): bool { return false; }

		toString(isRecursive: bool = false, iDepth:  number  = 0): string {

		    if (!isRecursive) {
		        return '<entity' + (this._sName? ' ' + this._sName: "") + '>';
		    }

		    var pSibling: IEntity = this.sibling;
		    var pChild: IEntity = this.child;
		    var s: string = "";

		    for (var i = 0; i < iDepth; ++ i) {
		        s += ':  ';
		    }

		    s += '+----[depth: ' + this.depth + ']' + this.toString() + '\n';

		    if (pChild) {
		        s += pChild.toString(true, iDepth + 1);
		    }

		    if (pSibling) {
		        s += pSibling.toString(true, iDepth);
		    }

		    return s;


		}

		private _iGuid: number = eval("this._iGuid || akra.sid()"); private _pUnicastSlotMap: IEventSlotMap = null; private _pBroadcastSlotList: IEventSlotListMap = null; private static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable {return Entity._pEventTable; } getGuid(): number {return this._iGuid < 0? (this._iGuid = sid()): this._iGuid; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
			attached (): void { var _recivier: any = this; this._pUnicastSlotMap = this._pUnicastSlotMap || this.getEventTable().findUnicastList(this._iGuid); var _unicast: IEventSlot = (<any>this._pUnicastSlotMap).attached; if(isDef(_unicast)){ _unicast.target? _unicast.target[_unicast.callback] (_recivier) : _unicast.listener (_recivier) ; } } ; ;
			detached (): void { var _recivier: any = this; this._pUnicastSlotMap = this._pUnicastSlotMap || this.getEventTable().findUnicastList(this._iGuid); var _unicast: IEventSlot = (<any>this._pUnicastSlotMap).detached; if(isDef(_unicast)){ _unicast.target? _unicast.target[_unicast.callback] (_recivier) : _unicast.listener (_recivier) ; } } ; ;
		;

	}
}















module akra {

	export interface IVec2Constructor {
        ();
        (fValue:  number );
        (v2fVec: IVec2);
        (pArray:  number []);
        (fValue1:  number , fValue2:  number );
    }


	export interface IVec2 {
		x:  number ;
		y:  number ;


/*represents two-component vector from original vector*/

xx: IVec2;
/*represents two-component vector from original vector*/

xy: IVec2;
/*represents two-component vector from original vector*/

yx: IVec2;
/*represents two-component vector from original vector*/

yy: IVec2;

		set(): IVec2;
		set(fValue:  number ): IVec2;
		set(v2fVec: IVec2): IVec2;
		set(pArray:  number []): IVec2;
		set(fValue1:  number , fValue2:  number ): IVec2;

		clear(): IVec2;

		add(v2fVec: IVec2, v2fDestination?: IVec2): IVec2;
		subtract(v2fVec: IVec2, v2fDestination?: IVec2): IVec2;
		dot(v2fVec: IVec2):  number ;

		isEqual(v2fVec: IVec2, fEps?:  number ): bool;
		isClear(fEps?:  number ): bool;

		negate(v2fDestination?: IVec2): IVec2;
		scale(fScale:  number , v2fDestination?: IVec2): IVec2;
		normalize(v2fDestination?: IVec2): IVec2;
		length():  number ;
		lengthSquare():  number ;


		direction(v2fVec: IVec2, v2fDestination?: IVec2): IVec2;

		mix(v2fVec: IVec2, fA:  number , v2fDestination?: IVec2): IVec2;

		toString(): string;
	};
};



module akra.math {

    export class Vec2 implements IVec2{
        x:  number  = 0.;
        y:  number  = 0.;



get xx(): IVec2{
	return vec2(this.x, this.x);
};
set xx(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.x = v2fVec.y;
};

get xy(): IVec2{
	return vec2(this.x, this.y);
};
set xy(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.y = v2fVec.y;
};

get yx(): IVec2{
	return vec2(this.y, this.x);
};
set yx(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.x = v2fVec.y;
};

get yy(): IVec2{
	return vec2(this.y, this.y);
};
set yy(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.y = v2fVec.y;
};

        constructor();
        constructor(fValue:  number );
        constructor(v2fVec: IVec2);
        constructor(pArray:  number []);
        constructor(fValue1:  number , fValue2:  number );
        constructor(fValue1?, fValue2?){
            var nArgumentsLength:  number  = arguments.length;

            var v2fVec: IVec2 = this;

// if (<any>this === window || <any>this === akra || <any>this === akra.math) {
//     v2fVec = Vec2.stack[Vec2.stackPosition ++];

//     if(Vec2.stackPosition == Vec2.stackSize){
//         Vec2.stackPosition = 0;
//     }
// }

            switch(nArgumentsLength){
                case 1:
                    v2fVec.set(arguments[0]);
                    break;
                case 2:
                    v2fVec.set(arguments[0], arguments[1]);
                    break;
                default:
                    v2fVec.x = v2fVec.y = 0.;
                    break;
            }

        };

        set(): IVec2;
        set(fValue:  number ): IVec2;
        set(v2fVec: IVec2): IVec2;
        set(pArray:  number []): IVec2;
        set(fValue1:  number , fValue2:  number ): IVec2;
        set(fValue1?, fValue2?): IVec2{
            var nArgumentsLength:  number  = arguments.length;

            switch(nArgumentsLength){
                case 0:
                    this.x = this.y = 0.;
                    break;
                case 1:
                    if(isFloat(arguments[0])){
                        this.x = this.y = arguments[0];
                    }
                    else if(arguments[0] instanceof Vec2){
                        var v2fVec: IVec2 = arguments[0];

                        this.x = v2fVec.x;
                        this.y = v2fVec.y;
                    }
                    else{
                        var pArray:  number [] = arguments[0];

                        this.x = pArray[0];
                        this.y = pArray[1];
                    }
                    break;
                case 2:
                    this.x = arguments[0];
                    this.y = arguments[1];
                    break;
            };

            return this;
        };

        /**@inline*/  clear(): IVec2{
            this.x = this.y = 0.;
            return this;
        };

        add(v2fVec: IVec2, v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            v2fDestination.x = this.x + v2fVec.x;
            v2fDestination.y = this.y + v2fVec.y;

            return v2fDestination;
        };

        subtract(v2fVec: IVec2, v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            v2fDestination.x = this.x - v2fVec.x;
            v2fDestination.y = this.y - v2fVec.y;

            return v2fDestination;
        };

        /**@inline*/  dot(v2fVec: IVec2):  number {
            return this.x*v2fVec.x + this.y*v2fVec.y;
        };

        isEqual(v2fVec: IVec2, fEps:  number  = 0.): bool{
            if(fEps === 0.){
                if(    this.x != v2fVec.x
                    || this.y != v2fVec.y){

                    return false;
                }
            }
            else{
                if(    abs(this.x - v2fVec.x) > fEps
                    || abs(this.y - v2fVec.y) > fEps){

                    return false;
                }
            }

            return true;
        };

        isClear(fEps:  number  = 0.): bool{
            if(fEps === 0.){
                if(    this.x != 0.
                    || this.y != 0.){

                    return false;
                }
            }
            else{
                if(    abs(this.x) > fEps
                    || abs(this.y) > fEps){

                    return false;
                }
            }

            return true;
        };

        negate(v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            v2fDestination.x = -this.x;
            v2fDestination.y = -this.y;

            return v2fDestination;
        };

        scale(fScale:  number , v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            v2fDestination.x = this.x*fScale;
            v2fDestination.y = this.y*fScale;

            return v2fDestination;
        };

        normalize(v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            var x:  number  = this.x, y:  number  = this.y;
            var fLength:  number  = sqrt(x*x + y*y);

            if(fLength !== 0.){
                var fInvLength:  number  = 1./fLength;

                x *= fInvLength;
                y *= fInvLength;
            }

            v2fDestination.x = x;
            v2fDestination.y = y;

            return v2fDestination;
        };

        /**@inline*/  length():  number {
            var x:  number  = this.x, y:  number  = this.y;
            return sqrt(x*x + y*y);
        };

        /**@inline*/  lengthSquare():  number {
            var x:  number  = this.x, y:  number  = this.y;
            return x*x + y*y;
        };

        direction(v2fVec: IVec2, v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            var x:  number  = v2fVec.x - this.x;
            var y:  number  = v2fVec.y - this.y;

            var fLength:  number  = sqrt(x*x + y*y);

            if(fLength !== 0.){
                var fInvLength:  number  = 1./fLength;

                x *= fInvLength;
                y *= fInvLength;
            }

            v2fDestination.x = x;
            v2fDestination.y = y;

            return v2fDestination;
        };

        mix(v2fVec: IVec2, fA:  number , v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            fA = clamp(fA,0.,1.);

            var fA1:  number  = 1. - fA;
            var fA2:  number  = fA;

            v2fDestination.x = fA1*this.x + fA2*v2fVec.x;
            v2fDestination.y = fA1*this.y + fA2*v2fVec.y;

            return v2fDestination;
        };

        /**@inline*/  toString(): string{
            return "[x: " + this.x + ", y: " + this.y + "]";
        };

        static get stackCeil(): Vec2 { Vec2.stackPosition = Vec2.stackPosition === Vec2.stackSize - 1? 0: Vec2.stackPosition; return Vec2.stack[Vec2.stackPosition ++]; } static stackSize: number = 100; static stackPosition: number = 0; static stack: Vec2[] = (function(): Vec2[]{ var pStack: Vec2[] = new Array(Vec2.stackSize); for(var i: number = 0; i<Vec2.stackSize; i++){ pStack[i] = new Vec2(); } return pStack})();
   }
}












module akra {

	export interface IVec2 {} ;
	export interface IMat4 {} ;

	export interface IVec3Constructor {
        ();
        (fValue:  number );
        (v3fVec: IVec3);
        (pArray:  number []);
        (fValue:  number , v2fVec: IVec2);
        (v2fVec: IVec2, fValue:  number );
        (fValue1:  number , fValue2:  number , fValue3:  number );
    }


	export interface IVec3 {
		x:  number ;
		y:  number ;
		z:  number ;


/*represents two-component vector from original vector*/

xx: IVec2;
/*represents two-component vector from original vector*/

xy: IVec2;
/*represents two-component vector from original vector*/

xz: IVec2;
/*represents two-component vector from original vector*/

yx: IVec2;
/*represents two-component vector from original vector*/

yy: IVec2;
/*represents two-component vector from original vector*/

yz: IVec2;
/*represents two-component vector from original vector*/

zx: IVec2;
/*represents two-component vector from original vector*/

zy: IVec2;
/*represents two-component vector from original vector*/

zz: IVec2;

/*represents three-component vector from original vector*/

xxx: IVec3;
/*represents three-component vector from original vector*/

xxy: IVec3;
/*represents three-component vector from original vector*/

xxz: IVec3;
/*represents three-component vector from original vector*/

xyx: IVec3;
/*represents three-component vector from original vector*/

xyy: IVec3;
/*represents three-component vector from original vector*/

xyz: IVec3;
/*represents three-component vector from original vector*/

xzx: IVec3;
/*represents three-component vector from original vector*/

xzy: IVec3;
/*represents three-component vector from original vector*/

xzz: IVec3;
/*represents three-component vector from original vector*/

yxx: IVec3;
/*represents three-component vector from original vector*/

yxy: IVec3;
/*represents three-component vector from original vector*/

yxz: IVec3;
/*represents three-component vector from original vector*/

yyx: IVec3;
/*represents three-component vector from original vector*/

yyy: IVec3;
/*represents three-component vector from original vector*/

yyz: IVec3;
/*represents three-component vector from original vector*/

yzx: IVec3;
/*represents three-component vector from original vector*/

yzy: IVec3;
/*represents three-component vector from original vector*/

yzz: IVec3;
/*represents three-component vector from original vector*/

zxx: IVec3;
/*represents three-component vector from original vector*/

zxy: IVec3;
/*represents three-component vector from original vector*/

zxz: IVec3;
/*represents three-component vector from original vector*/

zyx: IVec3;
/*represents three-component vector from original vector*/

zyy: IVec3;
/*represents three-component vector from original vector*/

zyz: IVec3;
/*represents three-component vector from original vector*/

zzx: IVec3;
/*represents three-component vector from original vector*/

zzy: IVec3;
/*represents three-component vector from original vector*/

zzz: IVec3;

		set(): IVec3;
		set(fValue:  number ): IVec3;
		set(v3fVec: IVec3): IVec3;
		set(pArray:  number []): IVec3;
		set(fValue:  number , v2fVec: IVec2): IVec3;
		set(v2fVec: IVec2, fValue:  number ): IVec3;
		set(fValue1:  number , fValue2:  number , fValue3:  number ): IVec3;

		clear(): IVec3;

		add(v3fVec: IVec3, v3fDestination?: IVec3): IVec3;
		subtract(v3fVec: IVec3, v3fDestination?: IVec3): IVec3;
		dot(v3fVec: IVec3):  number ;
		cross(v3fVec: IVec3, v3fDestination?: IVec3): IVec3;

		isEqual(v3fVec: IVec3, fEps?:  number ): bool;
		isClear(fEps?:  number ): bool;

		negate(v3fDestination?: IVec3): IVec3;
		scale(fScale:  number , v3fDestination?: IVec3): IVec3;
		scale(v3fScale: IVec3, v3fDestination?: IVec3): IVec3;
		normalize(v3fDestination?: IVec3): IVec3;
		length():  number ;
		lengthSquare():  number ;

		direction(v3fVec: IVec3, v3fDestination?: IVec3): IVec3;

		mix(v3fVec: IVec3, fA:  number , v3fDestination?: IVec3): IVec3;

		toString(): string;
		toTranslationMatrix(m4fDestination?: IMat4);

		vec3TransformCoord(m4fTransformation: IMat4, v3fDestination?: IVec3): IVec3;
	};
};






/**
 * @important Если внезапно задумаем перейти обратно на 
 * хранение данных в матрицах по строкам, как собственно и было в начале,
 * то необходимо раскомментить definы и переписать метод set, 
 * так как он ложит по столбцам
 */


// #define __11 0
// #define __12 1
// #define __13 2
// #define __14 3
// #define __21 4
// #define __22 5
// #define __23 6
// #define __24 7
// #define __31 8
// #define __32 9
// #define __33 10
// #define __34 11
// #define __41 12
// #define __42 13
// #define __43 14
// #define __44 15


















module akra {

	export interface IVec3 {} ;
	export interface IVec4 {} ;
	export interface IMat3 {} ;
	export interface IQuat4 {} ;

	export interface IMat4Constructor {
		();
		(fValue:  number );
		(v4fVec: IVec4);
		(m4fMat: IMat4);
		(pArray:  number []);
		(m3fMat: IMat3, v3fTranslation?: IVec3);
		(pArray: Float32Array, bFlag: bool);
		(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number );
		(v4fVec1: IVec4, v4fVec2: IVec4, v4fVec3: IVec4, v4fVec4: IVec4);
		(pArray1:  number [], pArray2:  number [], pArray3:  number [], pArray4:  number []);
		(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ,
				fValue5:  number , fValue6:  number , fValue7:  number , fValue8:  number ,
				fValue9:  number , fValue10:  number , fValue11:  number , fValue12:  number ,
				fValue13:  number , fValue14:  number , fValue15:  number , fValue16:  number );
	}

	export interface IMat4 {
		data: Float32Array;

		set(): IMat4;
		set(fValue:  number ): IMat4;
		set(v4fVec: IVec4): IMat4;
		set(m3fMat: IMat3, v3fTranslation?: IVec3): IMat4;
		set(m4fMat: IMat4): IMat4;
		set(pArray:  number []): IMat4;
		set(fValue1:  number , fValue2:  number ,
			fValue3:  number , fValue4:  number ): IMat4;
		set(v4fVec1: IVec4, v4fVec2: IVec4,
			v4fVec3: IVec4, v4fVec4: IVec4): IMat4;
		set(pArray1:  number [], pArray2:  number [],
			pArray3:  number [], pArray4:  number []): IMat4;
		set(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ,
			fValue5:  number , fValue6:  number , fValue7:  number , fValue8:  number ,
			fValue9:  number , fValue10:  number , fValue11:  number , fValue12:  number ,
			fValue13:  number , fValue14:  number , fValue15:  number , fValue16:  number ): IMat4;

		identity(): IMat4;

		add(m4fMat: IMat4, m4fDestination?: IMat4): IMat4;
		subtract(m4fMat: IMat4, m4fDestination?: IMat4): IMat4;
		multiply(m4fMat: IMat4, m4fDestination?: IMat4): IMat4;
		multiplyLeft(m4fMat: IMat4, m4fDestination?: IMat4): IMat4;
		multiplyVec4(v4fVec: IVec4, v4fDestination?: IVec4): IVec4;

		transpose(m4fDestination?: IMat4): IMat4;
		determinant():  number ;
		inverse(m4fDestination?: IMat4): IMat4;
		trace():  number ;

		isEqual(m4fMat: IMat4, fEps?:  number ): bool;
		isDiagonal(fEps?:  number ): bool;

		toMat3(m3fDestination?: IMat3): IMat3;
		toQuat4(q4fDestination?: IQuat4): IQuat4;
		toRotationMatrix(m4fDestination?: IMat4): IMat4;
		toString(): string;

		rotateRight(fAngle:  number , v3fAxis: IVec3, m4fDestination?: IMat4): IMat4;
		rotateLeft(fAngle:  number , v3fAxis: IVec3, m4fDestination?: IMat4): IMat4;

//rotateXRight(fAngle: float, m4fDestination?: IMat4): IMat4;
//rotateXLeft(fAngle: float, m4fDestination?: IMat4): IMat4;
//rotateYRight(fAngle: float, m4fDestination?: IMat4): IMat4;
//rotateYLeft(fAngle: float, m4fDestination?: IMat4): IMat4;
//rotateZRight(fAngle: float, m4fDestination?: IMat4): IMat4;
//rotateZLeft(fAngle: float, m4fDestination?: IMat4): IMat4;

		setTranslation(v3fTranslation: IVec3): IMat4;
		getTranslation(v3fTranslation?: IVec3): IVec3;

		translateRight(v3fTranslation: IVec3, m4fDestination?: IMat4): IMat4;
		translateLeft(v3fTranslation: IVec3, m4fDestination?: IMat4): IMat4;

		scaleRight(v3fScale: IVec3, m4fDestination?: IMat4): IMat4;
		scaleLeft(v3fScale: IVec3, m4fDestination?: IMat4): IMat4;

		decompose(q4fRotation: IQuat4, v3fScale: IVec3, v3fTranslation: IVec3): bool;

		row(iRow:  number , v4fDestination?: IVec4): IVec4;
		column(iColumn:  number , v4fDestination?: IVec4): IVec4;

/*v3fScreen - coordinates in screen space from -1 to 1
		* returns vec4(wsCoord,1.), where wsCoord - coordinates in world space
		* use with projection matrix only
		*/

		unproj(v3fScreen: IVec3, v4fDestination?: IVec4): IVec4;
		unproj(v4fScreen: IVec4, v4fDestination?: IVec4): IVec4;
	};
};



module akra.math {

    export class Vec3 {
        x:  number ;
        y:  number ;
        z:  number ;


get xx(): IVec2{
	return vec2(this.x, this.x);
};
set xx(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.x = v2fVec.y;
};

get xy(): IVec2{
	return vec2(this.x, this.y);
};
set xy(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.y = v2fVec.y;
};

get xz(): IVec2{
	return vec2(this.x, this.z);
};
set xz(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.z = v2fVec.y;
};

get yx(): IVec2{
	return vec2(this.y, this.x);
};
set yx(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.x = v2fVec.y;
};

get yy(): IVec2{
	return vec2(this.y, this.y);
};
set yy(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.y = v2fVec.y;
};

get yz(): IVec2{
	return vec2(this.y, this.z);
};
set yz(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.z = v2fVec.y;
};

get zx(): IVec2{
	return vec2(this.z, this.x);
};
set zx(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.x = v2fVec.y;
};

get zy(): IVec2{
	return vec2(this.z, this.y);
};
set zy(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.y = v2fVec.y;
};

get zz(): IVec2{
	return vec2(this.z, this.z);
};
set zz(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.z = v2fVec.y;
};


get xxx(): IVec3{
	return vec3(this.x, this.x, this.x);
};
set xxx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get xxy(): IVec3{
	return vec3(this.x, this.x, this.y);
};
set xxy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get xxz(): IVec3{
	return vec3(this.x, this.x, this.z);
};
set xxz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get xyx(): IVec3{
	return vec3(this.x, this.y, this.x);
};
set xyx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get xyy(): IVec3{
	return vec3(this.x, this.y, this.y);
};
set xyy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get xyz(): IVec3{
	return vec3(this.x, this.y, this.z);
};
set xyz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get xzx(): IVec3{
	return vec3(this.x, this.z, this.x);
};
set xzx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get xzy(): IVec3{
	return vec3(this.x, this.z, this.y);
};
set xzy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get xzz(): IVec3{
	return vec3(this.x, this.z, this.z);
};
set xzz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

get yxx(): IVec3{
	return vec3(this.y, this.x, this.x);
};
set yxx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get yxy(): IVec3{
	return vec3(this.y, this.x, this.y);
};
set yxy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get yxz(): IVec3{
	return vec3(this.y, this.x, this.z);
};
set yxz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get yyx(): IVec3{
	return vec3(this.y, this.y, this.x);
};
set yyx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get yyy(): IVec3{
	return vec3(this.y, this.y, this.y);
};
set yyy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get yyz(): IVec3{
	return vec3(this.y, this.y, this.z);
};
set yyz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get yzx(): IVec3{
	return vec3(this.y, this.z, this.x);
};
set yzx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get yzy(): IVec3{
	return vec3(this.y, this.z, this.y);
};
set yzy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get yzz(): IVec3{
	return vec3(this.y, this.z, this.z);
};
set yzz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

get zxx(): IVec3{
	return vec3(this.z, this.x, this.x);
};
set zxx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get zxy(): IVec3{
	return vec3(this.z, this.x, this.y);
};
set zxy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get zxz(): IVec3{
	return vec3(this.z, this.x, this.z);
};
set zxz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get zyx(): IVec3{
	return vec3(this.z, this.y, this.x);
};
set zyx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get zyy(): IVec3{
	return vec3(this.z, this.y, this.y);
};
set zyy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get zyz(): IVec3{
	return vec3(this.z, this.y, this.z);
};
set zyz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get zzx(): IVec3{
	return vec3(this.z, this.z, this.x);
};
set zzx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get zzy(): IVec3{
	return vec3(this.z, this.z, this.y);
};
set zzy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get zzz(): IVec3{
	return vec3(this.z, this.z, this.z);
};
set zzz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

        constructor();
        constructor(fValue:  number );
        constructor(v3fVec: IVec3);
        constructor(pArray:  number []);
        constructor(fValue:  number , v2fVec: IVec2);
        constructor(v2fVec: IVec2, fValue:  number );
        constructor(fValue1:  number , fValue2:  number , fValue3:  number );
        constructor(fValue1?, fValue2?, fValue3?){
            var nArgumentsLength:  number  = arguments.length;


            switch(nArgumentsLength){
                case 1:
                    this.set(arguments[0]);
                    break;
                case 2:
                    this.set(arguments[0], arguments[1]);
                    break;
                case 3:
                    this.set(arguments[0], arguments[1], arguments[2]);
                    break;
                default:
                    this.x = this.y = this.z = 0.;
                    break;
            }
        };

        set(): IVec3;
        set(fValue:  number ): IVec3;
        set(v3fVec: IVec3): IVec3;
        set(pArray:  number []): IVec3;
        set(fValue:  number , v2fVec: IVec2): IVec3;
        set(v2fVec: IVec2, fValue:  number ): IVec3;
        set(fValue1:  number , fValue2:  number , fValue3:  number ): IVec3;
        set(fValue1?, fValue2?, fValue3?): IVec3{
            var nArgumentsLength = arguments.length;

            switch(nArgumentsLength){
                case 0:
                    this.x = this.y = this.z = 0.;
                    break;
                case 1:
                    if(isFloat(arguments[0])){
                        this.x = this.y = this.z = arguments[0];
                    }
                    else if(arguments[0] instanceof Vec3){
                        var v3fVec: IVec3 = arguments[0];

                        this.x = v3fVec.x;
                        this.y = v3fVec.y;
                        this.z = v3fVec.z;
                    }
                    else{
                        var pArray:  number [] = arguments[0];

                        this.x = pArray[0];
                        this.y = pArray[1];
                        this.z = pArray[2];
                    }
                    break;
                case 2:
                    if(isFloat(arguments[0])){
                        var fValue:  number  = arguments[0];
                        var v2fVec: IVec2 = arguments[1];

                        this.x = fValue;
                        this.y = v2fVec.x;
                        this.z = v2fVec.y;
                    }
                    else{
                        var v2fVec: IVec2 = arguments[0];
                        var fValue:  number  = arguments[1];

                        this.x = v2fVec.x;
                        this.y = v2fVec.y;
                        this.z = fValue;
                    }
                    break;
                case 3:
                    this.x = arguments[0];
                    this.y = arguments[1];
                    this.z = arguments[2];
                    break;
            }

            return this;
        };

        /**@inline*/  clear(): IVec3{
            this.x = this.y = this.z = 0.;
            return this;
        };


        add(v3fVec: IVec3, v3fDestination?: IVec3): IVec3{
            if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            v3fDestination.x = this.x + v3fVec.x;
            v3fDestination.y = this.y + v3fVec.y;
            v3fDestination.z = this.z + v3fVec.z;

            return v3fDestination;
        };


        subtract(v3fVec: IVec3, v3fDestination?: IVec3): IVec3{
            if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            v3fDestination.x = this.x - v3fVec.x;
            v3fDestination.y = this.y - v3fVec.y;
            v3fDestination.z = this.z - v3fVec.z;

            return v3fDestination;
        };

        /**@inline*/  dot(v3fVec: IVec3):  number {
            return this.x*v3fVec.x + this.y*v3fVec.y + this.z*v3fVec.z;
        };


        cross(v3fVec: IVec3, v3fDestination?: IVec3): IVec3{
            if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            var x1:  number  = this.x, y1:  number  = this.y, z1:  number  = this.z;
            var x2:  number  = v3fVec.x, y2:  number  = v3fVec.y, z2:  number  = v3fVec.z;

            v3fDestination.x = y1*z2 - z1*y2;
            v3fDestination.y = z1*x2 - x1*z2;
            v3fDestination.z = x1*y2 - y1*x2;

            return v3fDestination;
        };

        isEqual(v3fVec: IVec3, fEps:  number  = 0.): bool{
            if(fEps === 0.){
                if(    this.x != v3fVec.x
                    || this.y != v3fVec.y
                    || this.z != v3fVec.z){

                    return false;
                }
            }
            else{
                if(    abs(this.x - v3fVec.x) > fEps
                    || abs(this.y - v3fVec.y) > fEps
                    || abs(this.z - v3fVec.z) > fEps){

                    return false;
                }
            }
            return true;
        };


        isClear(fEps:  number  = 0.): bool{
            if(fEps === 0.){
                if(    this.x != 0.
                    || this.y != 0.
                    || this.z != 0.) {

                    return false;
                }
            }
            else{
                if(    abs(this.x) > fEps
                    || abs(this.y) > fEps
                    || abs(this.z) > fEps){

                    return false;
                }
            }

            return true;
        };

        negate(v3fDestination?: IVec3): IVec3{
            if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            v3fDestination.x = -this.x;
            v3fDestination.y = -this.y;
            v3fDestination.z = -this.z;

            return v3fDestination;
        };

        scale(v3fScale: IVec3, v3fDestination?: IVec3): IVec3;
        scale(fScale:  number , v3fDestination?: IVec3): IVec3;
        scale(fScale?, v3fDestination?): IVec3{
            if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            if(isNumber(arguments[0])){
                var fScale:  number  = arguments[0];
                v3fDestination.x = this.x*fScale;
                v3fDestination.y = this.y*fScale;
                v3fDestination.z = this.z*fScale;
            }
            else{
                var v3fScale: IVec3 = arguments[0];
                v3fDestination.x = this.x*v3fScale.x;
                v3fDestination.y = this.y*v3fScale.y;
                v3fDestination.z = this.z*v3fScale.z;
            }

            return v3fDestination;
        };

        normalize(v3fDestination?: IVec3): IVec3{
            if(!v3fDestination){
                v3fDestination = this;
            }

            var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z;
            var fLength:  number  = sqrt(x*x + y*y + z*z);

            if(fLength !== 0.){
                var fInvLength:  number  = 1./fLength;

                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;
            }

            v3fDestination.x = x;
            v3fDestination.y = y;
            v3fDestination.z = z;

            return v3fDestination;
        };

        /**@inline*/  length():  number {
            var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z;
            return sqrt(x*x + y*y + z*z);
        };

        /**@inline*/  lengthSquare():  number {
            var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z;
            return x*x + y*y + z*z;
        };

        direction(v3fVec: IVec3, v3fDestination?: IVec3): IVec3{
            if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            var x:  number  = v3fVec.x - this.x;
            var y:  number  = v3fVec.y - this.y;
            var z:  number  = v3fVec.z - this.z;

            var fLength:  number  = sqrt(x*x + y*y + z*z);

            if(fLength !== 0.){
                var fInvLength = 1./fLength;

                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;
            }

            v3fDestination.x = x;
            v3fDestination.y = y;
            v3fDestination.z = z;

            return v3fDestination;
        };

        mix(v3fVec: IVec3, fA:  number , v3fDestination?: IVec3): IVec3{
           if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            fA = clamp(fA,0.,1.);

            var fA1:  number  = 1. - fA;
            var fA2:  number  = fA;

            v3fDestination.x = fA1*this.x + fA2*v3fVec.x;
            v3fDestination.y = fA1*this.y + fA2*v3fVec.y;
            v3fDestination.z = fA1*this.z + fA2*v3fVec.z;

            return v3fDestination;
        };

        /**@inline*/  toString(): string{
            return "[x: " + this.x + " ,y: " + this.y + ", z: " + this.z + "]";
        };

        toTranslationMatrix(m4fDestination?: IMat4): IMat4{
            if(!isDef(m4fDestination)){
                m4fDestination = new Mat4(1.);
            }
            else{
                m4fDestination.set(1.);
            }

            var pData: Float32Array = m4fDestination.data;

            pData[ 12 ] = this.x;
            pData[ 13 ] = this.y;
            pData[ 14 ] = this.z;

            return m4fDestination;
        };

        vec3TransformCoord(m4fTransformation: IMat4, v3fDestination?: IVec3): IVec3{
            if(!v3fDestination){
                v3fDestination = this;
            }

            var pData: Float32Array = m4fTransformation.data;

            var x:  number  = this.x;
            var y:  number  = this.y;
            var z:  number  = this.z;
            var w:  number ;

            x = pData[ 0 ]*x + pData[ 4 ]*y + pData[ 8 ]*z + pData[ 12 ];
            y = pData[ 1 ]*x + pData[ 5 ]*y + pData[ 9 ]*z + pData[ 13 ];
            z = pData[ 2 ]*x + pData[ 6 ]*y + pData[ 10 ]*z + pData[ 14 ];
            w = pData[ 2 ]*x + pData[ 7 ]*y + pData[ 11 ]*z + pData[ 15 ];

            var fInvW:  number  = 1./w;

            v3fDestination.x = x*fInvW;
            v3fDestination.y = y*fInvW;
            v3fDestination.z = z*fInvW;

            return v3fDestination;
        };

        static get stackCeil(): Vec3 { Vec3.stackPosition = Vec3.stackPosition === Vec3.stackSize - 1? 0: Vec3.stackPosition; return Vec3.stack[Vec3.stackPosition ++]; } static stackSize: number = 100; static stackPosition: number = 0; static stack: Vec3[] = (function(): Vec3[]{ var pStack: Vec3[] = new Array(Vec3.stackSize); for(var i: number = 0; i<Vec3.stackSize; i++){ pStack[i] = new Vec3(); } return pStack})();

/*get xy(): Vec2  { return new Vec2(this.x, this.y); }
        get xz(): Vec2  { return new Vec2(this.x, this.z); }
        get yx(): Vec2  { return new Vec2(this.y, this.x); }
        get yz(): Vec2  { return new Vec2(this.y, this.z); }
        get zx(): Vec2  { return new Vec2(this.z, this.x); }
        get zy(): Vec2  { return new Vec2(this.z, this.y); }
        get xyz(): Vec3 { return new Vec3(this.x, this.y, this.z); }*/

    }
}











module akra.math {

    export class Vec4 implements IVec4{
        x:  number ;
        y:  number ;
        z:  number ;
        w:  number ;


get xx(): IVec2{
	return vec2(this.x, this.x);
};
set xx(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.x = v2fVec.y;
};

get xy(): IVec2{
	return vec2(this.x, this.y);
};
set xy(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.y = v2fVec.y;
};

get xz(): IVec2{
	return vec2(this.x, this.z);
};
set xz(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.z = v2fVec.y;
};

get xw(): IVec2{
	return vec2(this.x, this.w);
};
set xw(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.w = v2fVec.y;
};

get yx(): IVec2{
	return vec2(this.y, this.x);
};
set yx(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.x = v2fVec.y;
};

get yy(): IVec2{
	return vec2(this.y, this.y);
};
set yy(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.y = v2fVec.y;
};

get yz(): IVec2{
	return vec2(this.y, this.z);
};
set yz(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.z = v2fVec.y;
};

get yw(): IVec2{
	return vec2(this.y, this.w);
};
set yw(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.w = v2fVec.y;
};

get zx(): IVec2{
	return vec2(this.z, this.x);
};
set zx(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.x = v2fVec.y;
};

get zy(): IVec2{
	return vec2(this.z, this.y);
};
set zy(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.y = v2fVec.y;
};

get zz(): IVec2{
	return vec2(this.z, this.z);
};
set zz(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.z = v2fVec.y;
};

get zw(): IVec2{
	return vec2(this.z, this.w);
};
set zw(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.w = v2fVec.y;
};

get wx(): IVec2{
	return vec2(this.w, this.x);
};
set wx(v2fVec: IVec2){
	this.w = v2fVec.x; 	this.x = v2fVec.y;
};

get wy(): IVec2{
	return vec2(this.w, this.y);
};
set wy(v2fVec: IVec2){
	this.w = v2fVec.x; 	this.y = v2fVec.y;
};

get wz(): IVec2{
	return vec2(this.w, this.z);
};
set wz(v2fVec: IVec2){
	this.w = v2fVec.x; 	this.z = v2fVec.y;
};

get ww(): IVec2{
	return vec2(this.w, this.w);
};
set ww(v2fVec: IVec2){
	this.w = v2fVec.x; 	this.w = v2fVec.y;
};


get xxx(): IVec3{
	return vec3(this.x, this.x, this.x);
};
set xxx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get xxy(): IVec3{
	return vec3(this.x, this.x, this.y);
};
set xxy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get xxz(): IVec3{
	return vec3(this.x, this.x, this.z);
};
set xxz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get xxw(): IVec3{
	return vec3(this.x, this.x, this.w);
};
set xxw(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.w = v3fVec.z;
};

get xyx(): IVec3{
	return vec3(this.x, this.y, this.x);
};
set xyx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get xyy(): IVec3{
	return vec3(this.x, this.y, this.y);
};
set xyy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get xyz(): IVec3{
	return vec3(this.x, this.y, this.z);
};
set xyz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get xyw(): IVec3{
	return vec3(this.x, this.y, this.w);
};
set xyw(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.w = v3fVec.z;
};

get xzx(): IVec3{
	return vec3(this.x, this.z, this.x);
};
set xzx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get xzy(): IVec3{
	return vec3(this.x, this.z, this.y);
};
set xzy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get xzz(): IVec3{
	return vec3(this.x, this.z, this.z);
};
set xzz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

get xzw(): IVec3{
	return vec3(this.x, this.z, this.w);
};
set xzw(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.w = v3fVec.z;
};

get xwx(): IVec3{
	return vec3(this.x, this.w, this.x);
};
set xwx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.w = v3fVec.y; 	this.x = v3fVec.z;
};

get xwy(): IVec3{
	return vec3(this.x, this.w, this.y);
};
set xwy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.w = v3fVec.y; 	this.y = v3fVec.z;
};

get xwz(): IVec3{
	return vec3(this.x, this.w, this.z);
};
set xwz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.w = v3fVec.y; 	this.z = v3fVec.z;
};

get xww(): IVec3{
	return vec3(this.x, this.w, this.w);
};
set xww(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.w = v3fVec.y; 	this.w = v3fVec.z;
};

get yxx(): IVec3{
	return vec3(this.y, this.x, this.x);
};
set yxx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get yxy(): IVec3{
	return vec3(this.y, this.x, this.y);
};
set yxy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get yxz(): IVec3{
	return vec3(this.y, this.x, this.z);
};
set yxz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get yxw(): IVec3{
	return vec3(this.y, this.x, this.w);
};
set yxw(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.w = v3fVec.z;
};

get yyx(): IVec3{
	return vec3(this.y, this.y, this.x);
};
set yyx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get yyy(): IVec3{
	return vec3(this.y, this.y, this.y);
};
set yyy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get yyz(): IVec3{
	return vec3(this.y, this.y, this.z);
};
set yyz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get yyw(): IVec3{
	return vec3(this.y, this.y, this.w);
};
set yyw(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.w = v3fVec.z;
};

get yzx(): IVec3{
	return vec3(this.y, this.z, this.x);
};
set yzx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get yzy(): IVec3{
	return vec3(this.y, this.z, this.y);
};
set yzy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get yzz(): IVec3{
	return vec3(this.y, this.z, this.z);
};
set yzz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

get yzw(): IVec3{
	return vec3(this.y, this.z, this.w);
};
set yzw(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.w = v3fVec.z;
};

get ywx(): IVec3{
	return vec3(this.y, this.w, this.x);
};
set ywx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.w = v3fVec.y; 	this.x = v3fVec.z;
};

get ywy(): IVec3{
	return vec3(this.y, this.w, this.y);
};
set ywy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.w = v3fVec.y; 	this.y = v3fVec.z;
};

get ywz(): IVec3{
	return vec3(this.y, this.w, this.z);
};
set ywz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.w = v3fVec.y; 	this.z = v3fVec.z;
};

get yww(): IVec3{
	return vec3(this.y, this.w, this.w);
};
set yww(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.w = v3fVec.y; 	this.w = v3fVec.z;
};

get zxx(): IVec3{
	return vec3(this.z, this.x, this.x);
};
set zxx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get zxy(): IVec3{
	return vec3(this.z, this.x, this.y);
};
set zxy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get zxz(): IVec3{
	return vec3(this.z, this.x, this.z);
};
set zxz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get zxw(): IVec3{
	return vec3(this.z, this.x, this.w);
};
set zxw(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.w = v3fVec.z;
};

get zyx(): IVec3{
	return vec3(this.z, this.y, this.x);
};
set zyx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get zyy(): IVec3{
	return vec3(this.z, this.y, this.y);
};
set zyy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get zyz(): IVec3{
	return vec3(this.z, this.y, this.z);
};
set zyz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get zyw(): IVec3{
	return vec3(this.z, this.y, this.w);
};
set zyw(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.w = v3fVec.z;
};

get zzx(): IVec3{
	return vec3(this.z, this.z, this.x);
};
set zzx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get zzy(): IVec3{
	return vec3(this.z, this.z, this.y);
};
set zzy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get zzz(): IVec3{
	return vec3(this.z, this.z, this.z);
};
set zzz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

get zzw(): IVec3{
	return vec3(this.z, this.z, this.w);
};
set zzw(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.w = v3fVec.z;
};

get zwx(): IVec3{
	return vec3(this.z, this.w, this.x);
};
set zwx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.w = v3fVec.y; 	this.x = v3fVec.z;
};

get zwy(): IVec3{
	return vec3(this.z, this.w, this.y);
};
set zwy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.w = v3fVec.y; 	this.y = v3fVec.z;
};

get zwz(): IVec3{
	return vec3(this.z, this.w, this.z);
};
set zwz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.w = v3fVec.y; 	this.z = v3fVec.z;
};

get zww(): IVec3{
	return vec3(this.z, this.w, this.w);
};
set zww(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.w = v3fVec.y; 	this.w = v3fVec.z;
};

get wxx(): IVec3{
	return vec3(this.w, this.x, this.x);
};
set wxx(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get wxy(): IVec3{
	return vec3(this.w, this.x, this.y);
};
set wxy(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get wxz(): IVec3{
	return vec3(this.w, this.x, this.z);
};
set wxz(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get wxw(): IVec3{
	return vec3(this.w, this.x, this.w);
};
set wxw(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.x = v3fVec.y; 	this.w = v3fVec.z;
};

get wyx(): IVec3{
	return vec3(this.w, this.y, this.x);
};
set wyx(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get wyy(): IVec3{
	return vec3(this.w, this.y, this.y);
};
set wyy(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get wyz(): IVec3{
	return vec3(this.w, this.y, this.z);
};
set wyz(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get wyw(): IVec3{
	return vec3(this.w, this.y, this.w);
};
set wyw(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.y = v3fVec.y; 	this.w = v3fVec.z;
};

get wzx(): IVec3{
	return vec3(this.w, this.z, this.x);
};
set wzx(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get wzy(): IVec3{
	return vec3(this.w, this.z, this.y);
};
set wzy(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get wzz(): IVec3{
	return vec3(this.w, this.z, this.z);
};
set wzz(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

get wzw(): IVec3{
	return vec3(this.w, this.z, this.w);
};
set wzw(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.z = v3fVec.y; 	this.w = v3fVec.z;
};

get wwx(): IVec3{
	return vec3(this.w, this.w, this.x);
};
set wwx(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.w = v3fVec.y; 	this.x = v3fVec.z;
};

get wwy(): IVec3{
	return vec3(this.w, this.w, this.y);
};
set wwy(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.w = v3fVec.y; 	this.y = v3fVec.z;
};

get wwz(): IVec3{
	return vec3(this.w, this.w, this.z);
};
set wwz(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.w = v3fVec.y; 	this.z = v3fVec.z;
};

get www(): IVec3{
	return vec3(this.w, this.w, this.w);
};
set www(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.w = v3fVec.y; 	this.w = v3fVec.z;
};


get xxxx(): IVec4{
	return vec4(this.x, this.x, this.x, this.x);
};
set xxxx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get xxxy(): IVec4{
	return vec4(this.x, this.x, this.x, this.y);
};
set xxxy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get xxxz(): IVec4{
	return vec4(this.x, this.x, this.x, this.z);
};
set xxxz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get xxxw(): IVec4{
	return vec4(this.x, this.x, this.x, this.w);
};
set xxxw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get xxyx(): IVec4{
	return vec4(this.x, this.x, this.y, this.x);
};
set xxyx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get xxyy(): IVec4{
	return vec4(this.x, this.x, this.y, this.y);
};
set xxyy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get xxyz(): IVec4{
	return vec4(this.x, this.x, this.y, this.z);
};
set xxyz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get xxyw(): IVec4{
	return vec4(this.x, this.x, this.y, this.w);
};
set xxyw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get xxzx(): IVec4{
	return vec4(this.x, this.x, this.z, this.x);
};
set xxzx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get xxzy(): IVec4{
	return vec4(this.x, this.x, this.z, this.y);
};
set xxzy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get xxzz(): IVec4{
	return vec4(this.x, this.x, this.z, this.z);
};
set xxzz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get xxzw(): IVec4{
	return vec4(this.x, this.x, this.z, this.w);
};
set xxzw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get xxwx(): IVec4{
	return vec4(this.x, this.x, this.w, this.x);
};
set xxwx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get xxwy(): IVec4{
	return vec4(this.x, this.x, this.w, this.y);
};
set xxwy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get xxwz(): IVec4{
	return vec4(this.x, this.x, this.w, this.z);
};
set xxwz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get xxww(): IVec4{
	return vec4(this.x, this.x, this.w, this.w);
};
set xxww(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get xyxx(): IVec4{
	return vec4(this.x, this.y, this.x, this.x);
};
set xyxx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get xyxy(): IVec4{
	return vec4(this.x, this.y, this.x, this.y);
};
set xyxy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get xyxz(): IVec4{
	return vec4(this.x, this.y, this.x, this.z);
};
set xyxz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get xyxw(): IVec4{
	return vec4(this.x, this.y, this.x, this.w);
};
set xyxw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get xyyx(): IVec4{
	return vec4(this.x, this.y, this.y, this.x);
};
set xyyx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get xyyy(): IVec4{
	return vec4(this.x, this.y, this.y, this.y);
};
set xyyy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get xyyz(): IVec4{
	return vec4(this.x, this.y, this.y, this.z);
};
set xyyz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get xyyw(): IVec4{
	return vec4(this.x, this.y, this.y, this.w);
};
set xyyw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get xyzx(): IVec4{
	return vec4(this.x, this.y, this.z, this.x);
};
set xyzx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get xyzy(): IVec4{
	return vec4(this.x, this.y, this.z, this.y);
};
set xyzy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get xyzz(): IVec4{
	return vec4(this.x, this.y, this.z, this.z);
};
set xyzz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get xyzw(): IVec4{
	return vec4(this.x, this.y, this.z, this.w);
};
set xyzw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get xywx(): IVec4{
	return vec4(this.x, this.y, this.w, this.x);
};
set xywx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get xywy(): IVec4{
	return vec4(this.x, this.y, this.w, this.y);
};
set xywy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get xywz(): IVec4{
	return vec4(this.x, this.y, this.w, this.z);
};
set xywz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get xyww(): IVec4{
	return vec4(this.x, this.y, this.w, this.w);
};
set xyww(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get xzxx(): IVec4{
	return vec4(this.x, this.z, this.x, this.x);
};
set xzxx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get xzxy(): IVec4{
	return vec4(this.x, this.z, this.x, this.y);
};
set xzxy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get xzxz(): IVec4{
	return vec4(this.x, this.z, this.x, this.z);
};
set xzxz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get xzxw(): IVec4{
	return vec4(this.x, this.z, this.x, this.w);
};
set xzxw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get xzyx(): IVec4{
	return vec4(this.x, this.z, this.y, this.x);
};
set xzyx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get xzyy(): IVec4{
	return vec4(this.x, this.z, this.y, this.y);
};
set xzyy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get xzyz(): IVec4{
	return vec4(this.x, this.z, this.y, this.z);
};
set xzyz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get xzyw(): IVec4{
	return vec4(this.x, this.z, this.y, this.w);
};
set xzyw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get xzzx(): IVec4{
	return vec4(this.x, this.z, this.z, this.x);
};
set xzzx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get xzzy(): IVec4{
	return vec4(this.x, this.z, this.z, this.y);
};
set xzzy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get xzzz(): IVec4{
	return vec4(this.x, this.z, this.z, this.z);
};
set xzzz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get xzzw(): IVec4{
	return vec4(this.x, this.z, this.z, this.w);
};
set xzzw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get xzwx(): IVec4{
	return vec4(this.x, this.z, this.w, this.x);
};
set xzwx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get xzwy(): IVec4{
	return vec4(this.x, this.z, this.w, this.y);
};
set xzwy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get xzwz(): IVec4{
	return vec4(this.x, this.z, this.w, this.z);
};
set xzwz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get xzww(): IVec4{
	return vec4(this.x, this.z, this.w, this.w);
};
set xzww(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get xwxx(): IVec4{
	return vec4(this.x, this.w, this.x, this.x);
};
set xwxx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get xwxy(): IVec4{
	return vec4(this.x, this.w, this.x, this.y);
};
set xwxy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get xwxz(): IVec4{
	return vec4(this.x, this.w, this.x, this.z);
};
set xwxz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get xwxw(): IVec4{
	return vec4(this.x, this.w, this.x, this.w);
};
set xwxw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get xwyx(): IVec4{
	return vec4(this.x, this.w, this.y, this.x);
};
set xwyx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get xwyy(): IVec4{
	return vec4(this.x, this.w, this.y, this.y);
};
set xwyy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get xwyz(): IVec4{
	return vec4(this.x, this.w, this.y, this.z);
};
set xwyz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get xwyw(): IVec4{
	return vec4(this.x, this.w, this.y, this.w);
};
set xwyw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get xwzx(): IVec4{
	return vec4(this.x, this.w, this.z, this.x);
};
set xwzx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get xwzy(): IVec4{
	return vec4(this.x, this.w, this.z, this.y);
};
set xwzy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get xwzz(): IVec4{
	return vec4(this.x, this.w, this.z, this.z);
};
set xwzz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get xwzw(): IVec4{
	return vec4(this.x, this.w, this.z, this.w);
};
set xwzw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get xwwx(): IVec4{
	return vec4(this.x, this.w, this.w, this.x);
};
set xwwx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get xwwy(): IVec4{
	return vec4(this.x, this.w, this.w, this.y);
};
set xwwy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get xwwz(): IVec4{
	return vec4(this.x, this.w, this.w, this.z);
};
set xwwz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get xwww(): IVec4{
	return vec4(this.x, this.w, this.w, this.w);
};
set xwww(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get yxxx(): IVec4{
	return vec4(this.y, this.x, this.x, this.x);
};
set yxxx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get yxxy(): IVec4{
	return vec4(this.y, this.x, this.x, this.y);
};
set yxxy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get yxxz(): IVec4{
	return vec4(this.y, this.x, this.x, this.z);
};
set yxxz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get yxxw(): IVec4{
	return vec4(this.y, this.x, this.x, this.w);
};
set yxxw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get yxyx(): IVec4{
	return vec4(this.y, this.x, this.y, this.x);
};
set yxyx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get yxyy(): IVec4{
	return vec4(this.y, this.x, this.y, this.y);
};
set yxyy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get yxyz(): IVec4{
	return vec4(this.y, this.x, this.y, this.z);
};
set yxyz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get yxyw(): IVec4{
	return vec4(this.y, this.x, this.y, this.w);
};
set yxyw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get yxzx(): IVec4{
	return vec4(this.y, this.x, this.z, this.x);
};
set yxzx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get yxzy(): IVec4{
	return vec4(this.y, this.x, this.z, this.y);
};
set yxzy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get yxzz(): IVec4{
	return vec4(this.y, this.x, this.z, this.z);
};
set yxzz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get yxzw(): IVec4{
	return vec4(this.y, this.x, this.z, this.w);
};
set yxzw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get yxwx(): IVec4{
	return vec4(this.y, this.x, this.w, this.x);
};
set yxwx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get yxwy(): IVec4{
	return vec4(this.y, this.x, this.w, this.y);
};
set yxwy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get yxwz(): IVec4{
	return vec4(this.y, this.x, this.w, this.z);
};
set yxwz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get yxww(): IVec4{
	return vec4(this.y, this.x, this.w, this.w);
};
set yxww(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get yyxx(): IVec4{
	return vec4(this.y, this.y, this.x, this.x);
};
set yyxx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get yyxy(): IVec4{
	return vec4(this.y, this.y, this.x, this.y);
};
set yyxy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get yyxz(): IVec4{
	return vec4(this.y, this.y, this.x, this.z);
};
set yyxz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get yyxw(): IVec4{
	return vec4(this.y, this.y, this.x, this.w);
};
set yyxw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get yyyx(): IVec4{
	return vec4(this.y, this.y, this.y, this.x);
};
set yyyx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get yyyy(): IVec4{
	return vec4(this.y, this.y, this.y, this.y);
};
set yyyy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get yyyz(): IVec4{
	return vec4(this.y, this.y, this.y, this.z);
};
set yyyz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get yyyw(): IVec4{
	return vec4(this.y, this.y, this.y, this.w);
};
set yyyw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get yyzx(): IVec4{
	return vec4(this.y, this.y, this.z, this.x);
};
set yyzx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get yyzy(): IVec4{
	return vec4(this.y, this.y, this.z, this.y);
};
set yyzy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get yyzz(): IVec4{
	return vec4(this.y, this.y, this.z, this.z);
};
set yyzz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get yyzw(): IVec4{
	return vec4(this.y, this.y, this.z, this.w);
};
set yyzw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get yywx(): IVec4{
	return vec4(this.y, this.y, this.w, this.x);
};
set yywx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get yywy(): IVec4{
	return vec4(this.y, this.y, this.w, this.y);
};
set yywy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get yywz(): IVec4{
	return vec4(this.y, this.y, this.w, this.z);
};
set yywz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get yyww(): IVec4{
	return vec4(this.y, this.y, this.w, this.w);
};
set yyww(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get yzxx(): IVec4{
	return vec4(this.y, this.z, this.x, this.x);
};
set yzxx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get yzxy(): IVec4{
	return vec4(this.y, this.z, this.x, this.y);
};
set yzxy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get yzxz(): IVec4{
	return vec4(this.y, this.z, this.x, this.z);
};
set yzxz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get yzxw(): IVec4{
	return vec4(this.y, this.z, this.x, this.w);
};
set yzxw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get yzyx(): IVec4{
	return vec4(this.y, this.z, this.y, this.x);
};
set yzyx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get yzyy(): IVec4{
	return vec4(this.y, this.z, this.y, this.y);
};
set yzyy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get yzyz(): IVec4{
	return vec4(this.y, this.z, this.y, this.z);
};
set yzyz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get yzyw(): IVec4{
	return vec4(this.y, this.z, this.y, this.w);
};
set yzyw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get yzzx(): IVec4{
	return vec4(this.y, this.z, this.z, this.x);
};
set yzzx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get yzzy(): IVec4{
	return vec4(this.y, this.z, this.z, this.y);
};
set yzzy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get yzzz(): IVec4{
	return vec4(this.y, this.z, this.z, this.z);
};
set yzzz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get yzzw(): IVec4{
	return vec4(this.y, this.z, this.z, this.w);
};
set yzzw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get yzwx(): IVec4{
	return vec4(this.y, this.z, this.w, this.x);
};
set yzwx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get yzwy(): IVec4{
	return vec4(this.y, this.z, this.w, this.y);
};
set yzwy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get yzwz(): IVec4{
	return vec4(this.y, this.z, this.w, this.z);
};
set yzwz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get yzww(): IVec4{
	return vec4(this.y, this.z, this.w, this.w);
};
set yzww(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get ywxx(): IVec4{
	return vec4(this.y, this.w, this.x, this.x);
};
set ywxx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get ywxy(): IVec4{
	return vec4(this.y, this.w, this.x, this.y);
};
set ywxy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get ywxz(): IVec4{
	return vec4(this.y, this.w, this.x, this.z);
};
set ywxz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get ywxw(): IVec4{
	return vec4(this.y, this.w, this.x, this.w);
};
set ywxw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get ywyx(): IVec4{
	return vec4(this.y, this.w, this.y, this.x);
};
set ywyx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get ywyy(): IVec4{
	return vec4(this.y, this.w, this.y, this.y);
};
set ywyy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get ywyz(): IVec4{
	return vec4(this.y, this.w, this.y, this.z);
};
set ywyz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get ywyw(): IVec4{
	return vec4(this.y, this.w, this.y, this.w);
};
set ywyw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get ywzx(): IVec4{
	return vec4(this.y, this.w, this.z, this.x);
};
set ywzx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get ywzy(): IVec4{
	return vec4(this.y, this.w, this.z, this.y);
};
set ywzy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get ywzz(): IVec4{
	return vec4(this.y, this.w, this.z, this.z);
};
set ywzz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get ywzw(): IVec4{
	return vec4(this.y, this.w, this.z, this.w);
};
set ywzw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get ywwx(): IVec4{
	return vec4(this.y, this.w, this.w, this.x);
};
set ywwx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get ywwy(): IVec4{
	return vec4(this.y, this.w, this.w, this.y);
};
set ywwy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get ywwz(): IVec4{
	return vec4(this.y, this.w, this.w, this.z);
};
set ywwz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get ywww(): IVec4{
	return vec4(this.y, this.w, this.w, this.w);
};
set ywww(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get zxxx(): IVec4{
	return vec4(this.z, this.x, this.x, this.x);
};
set zxxx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get zxxy(): IVec4{
	return vec4(this.z, this.x, this.x, this.y);
};
set zxxy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get zxxz(): IVec4{
	return vec4(this.z, this.x, this.x, this.z);
};
set zxxz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get zxxw(): IVec4{
	return vec4(this.z, this.x, this.x, this.w);
};
set zxxw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get zxyx(): IVec4{
	return vec4(this.z, this.x, this.y, this.x);
};
set zxyx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get zxyy(): IVec4{
	return vec4(this.z, this.x, this.y, this.y);
};
set zxyy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get zxyz(): IVec4{
	return vec4(this.z, this.x, this.y, this.z);
};
set zxyz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get zxyw(): IVec4{
	return vec4(this.z, this.x, this.y, this.w);
};
set zxyw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get zxzx(): IVec4{
	return vec4(this.z, this.x, this.z, this.x);
};
set zxzx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get zxzy(): IVec4{
	return vec4(this.z, this.x, this.z, this.y);
};
set zxzy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get zxzz(): IVec4{
	return vec4(this.z, this.x, this.z, this.z);
};
set zxzz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get zxzw(): IVec4{
	return vec4(this.z, this.x, this.z, this.w);
};
set zxzw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get zxwx(): IVec4{
	return vec4(this.z, this.x, this.w, this.x);
};
set zxwx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get zxwy(): IVec4{
	return vec4(this.z, this.x, this.w, this.y);
};
set zxwy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get zxwz(): IVec4{
	return vec4(this.z, this.x, this.w, this.z);
};
set zxwz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get zxww(): IVec4{
	return vec4(this.z, this.x, this.w, this.w);
};
set zxww(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get zyxx(): IVec4{
	return vec4(this.z, this.y, this.x, this.x);
};
set zyxx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get zyxy(): IVec4{
	return vec4(this.z, this.y, this.x, this.y);
};
set zyxy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get zyxz(): IVec4{
	return vec4(this.z, this.y, this.x, this.z);
};
set zyxz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get zyxw(): IVec4{
	return vec4(this.z, this.y, this.x, this.w);
};
set zyxw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get zyyx(): IVec4{
	return vec4(this.z, this.y, this.y, this.x);
};
set zyyx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get zyyy(): IVec4{
	return vec4(this.z, this.y, this.y, this.y);
};
set zyyy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get zyyz(): IVec4{
	return vec4(this.z, this.y, this.y, this.z);
};
set zyyz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get zyyw(): IVec4{
	return vec4(this.z, this.y, this.y, this.w);
};
set zyyw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get zyzx(): IVec4{
	return vec4(this.z, this.y, this.z, this.x);
};
set zyzx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get zyzy(): IVec4{
	return vec4(this.z, this.y, this.z, this.y);
};
set zyzy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get zyzz(): IVec4{
	return vec4(this.z, this.y, this.z, this.z);
};
set zyzz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get zyzw(): IVec4{
	return vec4(this.z, this.y, this.z, this.w);
};
set zyzw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get zywx(): IVec4{
	return vec4(this.z, this.y, this.w, this.x);
};
set zywx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get zywy(): IVec4{
	return vec4(this.z, this.y, this.w, this.y);
};
set zywy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get zywz(): IVec4{
	return vec4(this.z, this.y, this.w, this.z);
};
set zywz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get zyww(): IVec4{
	return vec4(this.z, this.y, this.w, this.w);
};
set zyww(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get zzxx(): IVec4{
	return vec4(this.z, this.z, this.x, this.x);
};
set zzxx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get zzxy(): IVec4{
	return vec4(this.z, this.z, this.x, this.y);
};
set zzxy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get zzxz(): IVec4{
	return vec4(this.z, this.z, this.x, this.z);
};
set zzxz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get zzxw(): IVec4{
	return vec4(this.z, this.z, this.x, this.w);
};
set zzxw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get zzyx(): IVec4{
	return vec4(this.z, this.z, this.y, this.x);
};
set zzyx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get zzyy(): IVec4{
	return vec4(this.z, this.z, this.y, this.y);
};
set zzyy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get zzyz(): IVec4{
	return vec4(this.z, this.z, this.y, this.z);
};
set zzyz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get zzyw(): IVec4{
	return vec4(this.z, this.z, this.y, this.w);
};
set zzyw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get zzzx(): IVec4{
	return vec4(this.z, this.z, this.z, this.x);
};
set zzzx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get zzzy(): IVec4{
	return vec4(this.z, this.z, this.z, this.y);
};
set zzzy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get zzzz(): IVec4{
	return vec4(this.z, this.z, this.z, this.z);
};
set zzzz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get zzzw(): IVec4{
	return vec4(this.z, this.z, this.z, this.w);
};
set zzzw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get zzwx(): IVec4{
	return vec4(this.z, this.z, this.w, this.x);
};
set zzwx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get zzwy(): IVec4{
	return vec4(this.z, this.z, this.w, this.y);
};
set zzwy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get zzwz(): IVec4{
	return vec4(this.z, this.z, this.w, this.z);
};
set zzwz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get zzww(): IVec4{
	return vec4(this.z, this.z, this.w, this.w);
};
set zzww(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get zwxx(): IVec4{
	return vec4(this.z, this.w, this.x, this.x);
};
set zwxx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get zwxy(): IVec4{
	return vec4(this.z, this.w, this.x, this.y);
};
set zwxy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get zwxz(): IVec4{
	return vec4(this.z, this.w, this.x, this.z);
};
set zwxz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get zwxw(): IVec4{
	return vec4(this.z, this.w, this.x, this.w);
};
set zwxw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get zwyx(): IVec4{
	return vec4(this.z, this.w, this.y, this.x);
};
set zwyx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get zwyy(): IVec4{
	return vec4(this.z, this.w, this.y, this.y);
};
set zwyy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get zwyz(): IVec4{
	return vec4(this.z, this.w, this.y, this.z);
};
set zwyz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get zwyw(): IVec4{
	return vec4(this.z, this.w, this.y, this.w);
};
set zwyw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get zwzx(): IVec4{
	return vec4(this.z, this.w, this.z, this.x);
};
set zwzx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get zwzy(): IVec4{
	return vec4(this.z, this.w, this.z, this.y);
};
set zwzy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get zwzz(): IVec4{
	return vec4(this.z, this.w, this.z, this.z);
};
set zwzz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get zwzw(): IVec4{
	return vec4(this.z, this.w, this.z, this.w);
};
set zwzw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get zwwx(): IVec4{
	return vec4(this.z, this.w, this.w, this.x);
};
set zwwx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get zwwy(): IVec4{
	return vec4(this.z, this.w, this.w, this.y);
};
set zwwy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get zwwz(): IVec4{
	return vec4(this.z, this.w, this.w, this.z);
};
set zwwz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get zwww(): IVec4{
	return vec4(this.z, this.w, this.w, this.w);
};
set zwww(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get wxxx(): IVec4{
	return vec4(this.w, this.x, this.x, this.x);
};
set wxxx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get wxxy(): IVec4{
	return vec4(this.w, this.x, this.x, this.y);
};
set wxxy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get wxxz(): IVec4{
	return vec4(this.w, this.x, this.x, this.z);
};
set wxxz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get wxxw(): IVec4{
	return vec4(this.w, this.x, this.x, this.w);
};
set wxxw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get wxyx(): IVec4{
	return vec4(this.w, this.x, this.y, this.x);
};
set wxyx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get wxyy(): IVec4{
	return vec4(this.w, this.x, this.y, this.y);
};
set wxyy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get wxyz(): IVec4{
	return vec4(this.w, this.x, this.y, this.z);
};
set wxyz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get wxyw(): IVec4{
	return vec4(this.w, this.x, this.y, this.w);
};
set wxyw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get wxzx(): IVec4{
	return vec4(this.w, this.x, this.z, this.x);
};
set wxzx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get wxzy(): IVec4{
	return vec4(this.w, this.x, this.z, this.y);
};
set wxzy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get wxzz(): IVec4{
	return vec4(this.w, this.x, this.z, this.z);
};
set wxzz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get wxzw(): IVec4{
	return vec4(this.w, this.x, this.z, this.w);
};
set wxzw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get wxwx(): IVec4{
	return vec4(this.w, this.x, this.w, this.x);
};
set wxwx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get wxwy(): IVec4{
	return vec4(this.w, this.x, this.w, this.y);
};
set wxwy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get wxwz(): IVec4{
	return vec4(this.w, this.x, this.w, this.z);
};
set wxwz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get wxww(): IVec4{
	return vec4(this.w, this.x, this.w, this.w);
};
set wxww(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get wyxx(): IVec4{
	return vec4(this.w, this.y, this.x, this.x);
};
set wyxx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get wyxy(): IVec4{
	return vec4(this.w, this.y, this.x, this.y);
};
set wyxy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get wyxz(): IVec4{
	return vec4(this.w, this.y, this.x, this.z);
};
set wyxz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get wyxw(): IVec4{
	return vec4(this.w, this.y, this.x, this.w);
};
set wyxw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get wyyx(): IVec4{
	return vec4(this.w, this.y, this.y, this.x);
};
set wyyx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get wyyy(): IVec4{
	return vec4(this.w, this.y, this.y, this.y);
};
set wyyy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get wyyz(): IVec4{
	return vec4(this.w, this.y, this.y, this.z);
};
set wyyz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get wyyw(): IVec4{
	return vec4(this.w, this.y, this.y, this.w);
};
set wyyw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get wyzx(): IVec4{
	return vec4(this.w, this.y, this.z, this.x);
};
set wyzx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get wyzy(): IVec4{
	return vec4(this.w, this.y, this.z, this.y);
};
set wyzy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get wyzz(): IVec4{
	return vec4(this.w, this.y, this.z, this.z);
};
set wyzz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get wyzw(): IVec4{
	return vec4(this.w, this.y, this.z, this.w);
};
set wyzw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get wywx(): IVec4{
	return vec4(this.w, this.y, this.w, this.x);
};
set wywx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get wywy(): IVec4{
	return vec4(this.w, this.y, this.w, this.y);
};
set wywy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get wywz(): IVec4{
	return vec4(this.w, this.y, this.w, this.z);
};
set wywz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get wyww(): IVec4{
	return vec4(this.w, this.y, this.w, this.w);
};
set wyww(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get wzxx(): IVec4{
	return vec4(this.w, this.z, this.x, this.x);
};
set wzxx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get wzxy(): IVec4{
	return vec4(this.w, this.z, this.x, this.y);
};
set wzxy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get wzxz(): IVec4{
	return vec4(this.w, this.z, this.x, this.z);
};
set wzxz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get wzxw(): IVec4{
	return vec4(this.w, this.z, this.x, this.w);
};
set wzxw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get wzyx(): IVec4{
	return vec4(this.w, this.z, this.y, this.x);
};
set wzyx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get wzyy(): IVec4{
	return vec4(this.w, this.z, this.y, this.y);
};
set wzyy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get wzyz(): IVec4{
	return vec4(this.w, this.z, this.y, this.z);
};
set wzyz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get wzyw(): IVec4{
	return vec4(this.w, this.z, this.y, this.w);
};
set wzyw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get wzzx(): IVec4{
	return vec4(this.w, this.z, this.z, this.x);
};
set wzzx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get wzzy(): IVec4{
	return vec4(this.w, this.z, this.z, this.y);
};
set wzzy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get wzzz(): IVec4{
	return vec4(this.w, this.z, this.z, this.z);
};
set wzzz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get wzzw(): IVec4{
	return vec4(this.w, this.z, this.z, this.w);
};
set wzzw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get wzwx(): IVec4{
	return vec4(this.w, this.z, this.w, this.x);
};
set wzwx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get wzwy(): IVec4{
	return vec4(this.w, this.z, this.w, this.y);
};
set wzwy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get wzwz(): IVec4{
	return vec4(this.w, this.z, this.w, this.z);
};
set wzwz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get wzww(): IVec4{
	return vec4(this.w, this.z, this.w, this.w);
};
set wzww(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get wwxx(): IVec4{
	return vec4(this.w, this.w, this.x, this.x);
};
set wwxx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get wwxy(): IVec4{
	return vec4(this.w, this.w, this.x, this.y);
};
set wwxy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get wwxz(): IVec4{
	return vec4(this.w, this.w, this.x, this.z);
};
set wwxz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get wwxw(): IVec4{
	return vec4(this.w, this.w, this.x, this.w);
};
set wwxw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get wwyx(): IVec4{
	return vec4(this.w, this.w, this.y, this.x);
};
set wwyx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get wwyy(): IVec4{
	return vec4(this.w, this.w, this.y, this.y);
};
set wwyy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get wwyz(): IVec4{
	return vec4(this.w, this.w, this.y, this.z);
};
set wwyz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get wwyw(): IVec4{
	return vec4(this.w, this.w, this.y, this.w);
};
set wwyw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get wwzx(): IVec4{
	return vec4(this.w, this.w, this.z, this.x);
};
set wwzx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get wwzy(): IVec4{
	return vec4(this.w, this.w, this.z, this.y);
};
set wwzy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get wwzz(): IVec4{
	return vec4(this.w, this.w, this.z, this.z);
};
set wwzz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get wwzw(): IVec4{
	return vec4(this.w, this.w, this.z, this.w);
};
set wwzw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get wwwx(): IVec4{
	return vec4(this.w, this.w, this.w, this.x);
};
set wwwx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get wwwy(): IVec4{
	return vec4(this.w, this.w, this.w, this.y);
};
set wwwy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get wwwz(): IVec4{
	return vec4(this.w, this.w, this.w, this.z);
};
set wwwz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get wwww(): IVec4{
	return vec4(this.w, this.w, this.w, this.w);
};
set wwww(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

        constructor();
        constructor(fValue:  number );
        constructor(v4fVec: IVec4);
        constructor(pArray:  number []);
        constructor(fValue:  number , v3fVec: IVec3);
        constructor(v2fVec1: IVec2, v2fVec2: IVec2);
        constructor(v3fVec: IVec3, fValue:  number );
        constructor(fValue1:  number , fValue2:  number , v2fVec: IVec2);
        constructor(fValue1:  number , v2fVec: IVec2, fValue2:  number );
        constructor(v2fVec: IVec2 ,fValue1:  number , fValue2:  number );
        constructor(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number );
        constructor(fValue1?, fValue2?, fValue3?, fValue4?){
            var nArgumentsLength:  number  = arguments.length;
            var v4fVec: IVec4 = this;

// if (<any>this === window || <any>this === akra || <any>this === akra.math) {
//     v4fVec = Vec4.stack[Vec4.stackPosition ++];

//     if(Vec4.stackPosition == Vec4.stackSize){
//         Vec4.stackPosition = 0;
//     }
// }

            switch(nArgumentsLength) {
                case 1:
                    v4fVec.set(arguments[0]);
                    break;
                case 2:
                    v4fVec.set(arguments[0],arguments[1]);
                    break;
                case 3:
                    v4fVec.set(arguments[0],arguments[1], arguments[2]);
                    break;
                case 4:
                    v4fVec.set(arguments[0],arguments[1], arguments[2], arguments[3]);
                    break;
                default:
                    v4fVec.x = v4fVec.y = v4fVec.z = v4fVec.w = 0.;
                    break;
            }
        };

        set(): IVec4;
        set(fValue:  number ): IVec4;
        set(v4fVec: IVec4): IVec4;
        set(c4fColor: IColorValue): IVec4;
        set(pArray:  number []): IVec4;
        set(fValue:  number , v3fVec: IVec3): IVec4;
        set(v2fVec1: IVec2, v2fVec2: IVec2): IVec4;
        set(v3fVec: IVec3, fValue:  number ): IVec4;
        set(fValue1:  number , fValue2:  number , v2fVec: IVec2): IVec4;
        set(fValue1:  number , v2fVec: IVec2, fValue2:  number ): IVec4;
        set(v2fVec: IVec2, fValue1:  number , fValue2:  number ): IVec4;
        set(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ): IVec4;
        set(fValue1?, fValue2?, fValue3?, fValue4?): IVec4{
            var nArgumentsLength:  number  = arguments.length;

            switch(nArgumentsLength){
                case 0:
                    this.x = this.y = this.z = this.w = 0.;
                    break;
                case 1:
                    if(isFloat(arguments[0])){
                        this.x = this.y = this.z = this.w = arguments[0];
                    }
                    else if(arguments[0] instanceof Vec4){
                        var v4fVec: IVec4 = arguments[0];

                        this.x = v4fVec.x;
                        this.y = v4fVec.y;
                        this.z = v4fVec.z;
                        this.w = v4fVec.w;
                    }
//color
                    else if (isDef(arguments[0].r)) {
                        this.x = arguments[0].r;
                        this.y = arguments[0].g;
                        this.z = arguments[0].b;
                        this.w = arguments[0].a;
                    }
                    else{
//array
                        var pArray:  number [] = arguments[0];

                        this.x = pArray[0];
                        this.y = pArray[1];
                        this.z = pArray[2];
                        this.w = pArray[3];
                    }
                    break;
                case 2:
                    if(isFloat(arguments[0])){
                        var fValue:  number  = arguments[0];
                        var v3fVec: IVec3 = arguments[1];

                        this.x = fValue;
                        this.y = v3fVec.x;
                        this.z = v3fVec.y;
                        this.w = v3fVec.z;
                    }
                    else if(arguments[0] instanceof Vec2){
                        var v2fVec1: IVec2 = arguments[0];
                        var v2fVec2: IVec2 = arguments[1];

                        this.x = v2fVec1.x;
                        this.y = v2fVec1.y;
                        this.z = v2fVec2.x;
                        this.w = v2fVec2.y;
                    }
                    else{
                        var v3fVec: IVec3 = arguments[0];
                        var fValue:  number  = arguments[1];

                        this.x = v3fVec.x;
                        this.y = v3fVec.y;
                        this.z = v3fVec.z;
                        this.w = fValue;
                    }
                    break;
                case 3:
                    if(isFloat(arguments[0])){
                        var fValue1:  number  = arguments[0];

                        if(isFloat(arguments[1])){
                            var fValue2:  number  = arguments[1];
                            var v2fVec: IVec2 = arguments[2];

                            this.x = fValue1;
                            this.y = fValue2;
                            this.z = v2fVec.x;
                            this.w = v2fVec.y;
                        }
                        else{
                            var v2fVec: IVec2 = arguments[1];
                            var fValue2:  number  = arguments[2];

                            this.x = fValue1;
                            this.y = v2fVec.x;
                            this.z = v2fVec.y;
                            this.w = fValue2;
                        }
                    }
                    else{
                        var v2fVec: IVec2 = arguments[0];
                        var fValue1:  number  = arguments[1];
                        var fValue2:  number  = arguments[2];

                        this.x = v2fVec.x;
                        this.y = v2fVec.y;
                        this.z = fValue1;
                        this.w = fValue2;
                    }
                    break;
                case 4:
                    this.x = arguments[0];
                    this.y = arguments[1];
                    this.z = arguments[2];
                    this.w = arguments[3];
                    break;
            }

            return this;
        };

        /**@inline*/  clear(): IVec4{
            this.x = this.y = this.z = this.w = 0.;
            return this;
        };

        add(v4fVec: IVec4, v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            v4fDestination.x = this.x + v4fVec.x;
            v4fDestination.y = this.y + v4fVec.y;
            v4fDestination.z = this.z + v4fVec.z;
            v4fDestination.w = this.w + v4fVec.w;

            return v4fDestination;
        };

        subtract(v4fVec: IVec4, v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            v4fDestination.x = this.x - v4fVec.x;
            v4fDestination.y = this.y - v4fVec.y;
            v4fDestination.z = this.z - v4fVec.z;
            v4fDestination.w = this.w - v4fVec.w;

            return v4fDestination;
        };

        /**@inline*/  dot(v4fVec: IVec4):  number {
            return this.x*v4fVec.x + this.y*v4fVec.y + this.z*v4fVec.z + this.w*v4fVec.w;
        };

        isEqual(v4fVec: IVec4, fEps:  number  = 0.): bool{
            if(fEps === 0.){
                if(    this.x != v4fVec.x
                    || this.y != v4fVec.y
                    || this.z != v4fVec.z
                    || this.w != v4fVec.w){

                    return false;
                }
            }
            else{
                if(    abs(this.x - v4fVec.x) > fEps
                    || abs(this.y - v4fVec.y) > fEps
                    || abs(this.z - v4fVec.z) > fEps
                    || abs(this.w - v4fVec.w) > fEps){

                    return false;
                }
            }
            return true;
        };

        isClear(fEps:  number  = 0.): bool{

            if(fEps === 0.){
                if(    this.x != 0.
                    || this.y != 0.
                    || this.z != 0.
                    || this.w != 0.){

                    return false;
                }
            }
            else{
                if(    abs(this.x) > fEps
                    || abs(this.y) > fEps
                    || abs(this.z) > fEps
                    || abs(this.w) > fEps){

                    return false;
                }
            }
            return true;
        };

        negate(v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            v4fDestination.x = -this.x;
            v4fDestination.y = -this.y;
            v4fDestination.z = -this.z;
            v4fDestination.w = -this.w;

            return v4fDestination;
        };

        scale(fScale:  number , v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            v4fDestination.x = this.x*fScale;
            v4fDestination.y = this.y*fScale;
            v4fDestination.z = this.z*fScale;
            v4fDestination.w = this.w*fScale;

            return v4fDestination;
        };

        normalize(v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;
            var fLength:  number  = sqrt(x*x + y*y +z*z + w*w);

            if(fLength !== 0.){
                var fInvLength:  number  = 1./fLength;

                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;
                w *= fInvLength;
            }

            v4fDestination.x = x;
            v4fDestination.y = y;
            v4fDestination.z = z;
            v4fDestination.w = w;

            return v4fDestination;
        };

        /**@inline*/  length():  number {
            var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;
            return sqrt(x*x + y*y + z*z + w*w);
        };

        /**@inline*/  lengthSquare():  number {
            var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;
            return x*x + y*y + z*z + w*w;
        };

        direction(v4fVec: IVec4, v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            var x:  number  = v4fVec.x - this.x;
            var y:  number  = v4fVec.y - this.y;
            var z:  number  = v4fVec.z - this.z;
            var w:  number  = v4fVec.w - this.w;

            var fLength:  number  = sqrt(x*x + y*y + z*z + w*w);

            if(fLength !== 0.){
                var fInvLength = 1./fLength;

                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;
                w *= fInvLength;
            }

            v4fDestination.x = x;
            v4fDestination.y = y;
            v4fDestination.z = z;
            v4fDestination.w = w;

            return v4fDestination;
        };

        mix(v4fVec: IVec4, fA:  number , v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            fA = clamp(fA,0.,1.);

            var fA1:  number  = 1. - fA;
            var fA2:  number  = fA;

            v4fDestination.x = fA1*this.x + fA2*v4fVec.x;
            v4fDestination.y = fA1*this.y + fA2*v4fVec.y;
            v4fDestination.z = fA1*this.z + fA2*v4fVec.z;
            v4fDestination.w = fA1*this.w + fA2*v4fVec.w;

            return v4fDestination;
        };

        /**@inline*/  toString(): string{
            return "[x: " + this.x + ", y: " + this.y
                        + ", z: " + this.z + ", w: " + this.w + "]";
        };

        static get stackCeil(): Vec4 { Vec4.stackPosition = Vec4.stackPosition === Vec4.stackSize - 1? 0: Vec4.stackPosition; return Vec4.stack[Vec4.stackPosition ++]; } static stackSize: number = 100; static stackPosition: number = 0; static stack: Vec4[] = (function(): Vec4[]{ var pStack: Vec4[] = new Array(Vec4.stackSize); for(var i: number = 0; i<Vec4.stackSize; i++){ pStack[i] = new Vec4(); } return pStack})();

    }
}





// module akra.math {
//     export class Mat2 {
//         private pData: Float32Array = new Float32Array(4);

//         constructor ();
//         constructor (m2f: Mat2);
//         constructor (f11: float, f12: float, f21: float, f22: float);
//         constructor (f11? , f12? , f21? , f22? ) {
//             switch (arguments.length) {
//                 case 1:
//                     this.set(f11);
//                     break;
//                 case 4:
//                     this.set(f11, f12, f21, f22);
//                     break;
//             }
//         }

//         set(): Mat2;
//         set(m2f: Mat2): Mat2;
//         set(f11: float, f12: float, f21: float, f22: float): Mat2;
//         set(f11? , f12? , f21? , f22? ): Mat2 {

//             var pData: Float32Array = this.pData;

//             switch (arguments.length) {
//                 case 1:
//                     if (isFloat(f11)) {
//                         pData[0] = pData[1] = pData[2] = pData[3] = f11;
//                     }
//                     else {
//                         //pData.set(f11.pData);
//                     }
//                     break;
//                 case 4:
//                     pData[0] = f11;
//                     pData[1] = f21;
//                     pData[2] = f12;
//                     pData[3] = f22;
//                     break;
//             }
//             return this;
//         }
//     }
// }









/**
 * @important Если внезапно задумаем перейти обратно на 
 * хранение данных в матрицах по строкам, как собственно и было в начале,
 * то необходимо раскомментить definы и переписать метод set, 
 * так как он ложит по столбцам
 */


// #define __a11 0
// #define __a12 1
// #define __a13 2
// #define __a21 3
// #define __a22 4
// #define __a23 5
// #define __a31 6
// #define __a32 7
// #define __a33 8











module akra {
	export interface IMat4 {} ;
	export interface IVec3 {} ;
	export interface IQuat4 {} ;

	export interface IMat3Constructor {
		();
		(fValue:  number );
		(v3fVec: IVec3);
		(m3fMat: IMat3);
		(m4fMat: IMat4);
		(pArray:  number []);
		(fValue1:  number , fValue2:  number , fValue3:  number );
		(v3fVec1: IVec3, v3fVec2: IVec3, v3fVec3: IVec3);
		(pArray1:  number [], pArray2:  number [], pArray3:  number []);
		(fValue1:  number , fValue2:  number , fValue3:  number ,
					fValue4:  number , fValue5:  number , fValue6:  number ,
					fValue7:  number , fValue8:  number , fValue9:  number );
	}

	export interface IMat3 {
		data: Float32Array;

		set(): IMat3;
		set(fValue:  number ): IMat3;
		set(v3fVec: IVec3): IMat3;
		set(m3fMat: IMat3): IMat3;
		set(m4fMat: IMat4): IMat3;
		set(pArray:  number []): IMat3;
		set(fValue1:  number , fValue2:  number , fValue3:  number ): IMat3;
		set(v3fVec1: IVec3, v3fVec2: IVec3, v3fVec3: IVec3): IMat3;
		set(pArray1:  number [], pArray2:  number [], pArray3:  number []): IMat3;
		set(fValue1:  number , fValue2:  number , fValue3:  number ,
			fValue4:  number , fValue5:  number , fValue6:  number ,
			fValue7:  number , fValue8:  number , fValue9:  number ): IMat3;

		identity(): IMat3;

		add(m3fMat: IMat3, m3fDestination?: IMat3): IMat3;
		subtract(m3fMat: IMat3, m3fDestination?: IMat3): IMat3;
		multiply(m3fMat: IMat3, m3fDestination?: IMat3): IMat3;
		multiplyVec3(v3fVec: IVec3, v3fDestination?: IVec3): IVec3;

		transpose(m3fDestination?: IMat3): IMat3;
		determinant():  number ;
		inverse(m3fDestination?: IMat3): IMat3;

		isEqual(m3fMat: IMat3, fEps?:  number ): bool;
		isDiagonal(fEps?:  number ) : bool;

		toMat4(m4fDestination?: IMat4): IMat4;
		toQuat4(q4fDestination?: IQuat4): IQuat4;
		toString(): string;

		decompose(q4fRotation: IQuat4, v3fScale: IVec3): bool;
		row(iRow:  number , v3fDestination?: IVec3): IVec3;
		column(iColumn:  number , v3fDestination?: IVec3): IVec3;
	};
};










module akra {

	export interface IVec3 {} ;
	export interface IMat3 {} ;
	export interface IMat4 {} ;

	export interface IQuat4Constructor {
		();
    	(q4fQuat: IQuat4);
    	(pArray:  number []);
    	(fValue:  number , fW:  number );
    	(v3fValue: IVec3, fW:  number );
    	(fX:  number , fY:  number , fZ:  number , fW:  number );
	}

	export interface IQuat4 {
		x:  number ;
		y:  number ;
		z:  number ;
		w:  number ;

		set(): IQuat4;
		set(q4fQuat: IQuat4): IQuat4;
		set(pArray:  number []): IQuat4;
		set(fValue:  number , fW:  number ): IQuat4;
		set(v3fValue: IVec3, fW:  number ): IQuat4;
		set(fX:  number , fY:  number , fZ:  number , fW:  number ): IQuat4;

		multiply(q4fQuat: IQuat4, q4fDestination?: IQuat4): IQuat4;
		multiplyVec3(v3fVec: IVec3, v3fDestination?: IVec3): IVec3;

		conjugate(q4fDestination?: IQuat4): IQuat4;
		inverse(q4fDestination?: IQuat4): IQuat4;

		length():  number ;
		normalize(q4fDestination?: IQuat4): IQuat4;

		calculateW(q4fDestination?: IQuat4): IQuat4;

		isEqual(q4fQuat: IQuat4, fEps?:  number , asMatrix?: bool): bool;

		getYaw():  number ;
		getPitch():  number ;
		getRoll():  number ;
		toYawPitchRoll(v3fDestination?: IVec3): IVec3;

		toMat3(m3fDestination?: IMat3): IMat3;
		toMat4(m4fDestination?: IMat4): IMat4;
		toString(): string;

		mix(q4fQuat: IQuat4, fA:  number , q4fDestination?: IQuat4, bShortestPath?: bool);
		smix(q4fQuat: IQuat4, fA:  number , q4fDestination?: IQuat4, bShortestPath?: bool);
	};
};



module akra.math {

    export class Mat3 {
	    data : Float32Array;

	    constructor();
		constructor(fValue:  number );
		constructor(v3fVec: IVec3);
		constructor(m3fMat: IMat3);
		constructor(m4fMat: IMat4);
		constructor(pArray:  number []);
		constructor(fValue1:  number , fValue2:  number , fValue3:  number );
		constructor(v3fVec1: IVec3, v3fVec2: IVec3, v3fVec3: IVec3);
		constructor(pArray1:  number [], pArray2:  number [], pArray3:  number []);
		constructor(fValue1:  number , fValue2:  number , fValue3:  number ,
					fValue4:  number , fValue5:  number , fValue6:  number ,
					fValue7:  number , fValue8:  number , fValue9:  number );

		constructor(fValue1?, fValue2?, fValue3?,
					fValue4?, fValue5?, fValue6?,
					fValue7?, fValue8?, fValue9?){


			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					this.set(arguments[0]);
					break;
				case 3:
					this.set(arguments[0], arguments[1], arguments[2]);
					break;
				case 9:
					this.set(arguments[0], arguments[1], arguments[2],
							 arguments[3], arguments[4], arguments[5],
							 arguments[6], arguments[7], arguments[8]);
					break;
				default:
					break;
			}
		};

		set(): IMat3;
		set(fValue:  number ): IMat3;
		set(v3fVec: IVec3): IMat3;
		set(m3fMat: IMat3): IMat3;
		set(m4fMat: IMat4): IMat3;
		set(pArray:  number []): IMat3;
		set(fValue1:  number , fValue2:  number , fValue3:  number ): IMat3;
		set(v3fVec1: IVec3, v3fVec2: IVec3, v3fVec3: IVec3): IMat3;
		set(pArray1:  number [], pArray2:  number [], pArray3:  number []): IMat3;
		set(fValue1:  number , fValue2:  number , fValue3:  number ,
			fValue4:  number , fValue5:  number , fValue6:  number ,
			fValue7:  number , fValue8:  number , fValue9:  number ): IMat3;

		set(fValue1?, fValue2?, fValue3?,
			fValue4?, fValue5?, fValue6?,
			fValue7?, fValue8?, fValue9?): IMat3{

			this.data = this.data || new Float32Array(9);

			var pData: Float32Array = this.data;

//без аргументов инициализируется нулями

		    var nArgumentsLength:  number  = arguments.length;
		    if(nArgumentsLength == 0){
		        pData[ 0 ] = pData[ 3 ] = pData[ 6 ] = 0;
		        pData[ 1 ] = pData[ 4 ] = pData[ 7 ] = 0;
		        pData[ 2 ] = pData[ 5 ] = pData[ 8 ] = 0;
		    }
		    if(nArgumentsLength == 1){
		        if(isFloat(arguments[0])){
		            var nValue:  number  = arguments[0];

		            pData[ 0 ] = nValue;
		            pData[ 3 ] = 0;
		            pData[ 6 ] = 0;

		            pData[ 1 ] = 0;
		            pData[ 4 ] = nValue;
		            pData[ 7 ] = 0;

		            pData[ 2 ] = 0;
		            pData[ 5 ] = 0;
		            pData[ 8 ] = nValue;
		        }

		        else if(isDef(arguments[0].data)){
		            var pElements: Float32Array = arguments[0].data;

		            if(pElements.length === 9){
//Mat3
			            pData[ 0 ] = pElements[ 0 ];
			            pData[ 3 ] = pElements[ 3 ];
			            pData[ 6 ] = pElements[ 6 ];

			            pData[ 1 ] = pElements[ 1 ];
			            pData[ 4 ] = pElements[ 4 ];
			            pData[ 7 ] = pElements[ 7 ];

			            pData[ 2 ] = pElements[ 2 ];
			            pData[ 5 ] = pElements[ 5 ];
			            pData[ 8 ] = pElements[ 8 ];
		        	}
		        	else{
//Mat4
		        		pData[ 0 ] = pElements[ 0 ];
			            pData[ 3 ] = pElements[ 4 ];
			            pData[ 6 ] = pElements[ 8 ];

			            pData[ 1 ] = pElements[ 1 ];
			            pData[ 4 ] = pElements[ 5 ];
			            pData[ 7 ] = pElements[ 9 ];

			            pData[ 2 ] = pElements[ 2 ];
			            pData[ 5 ] = pElements[ 6 ];
			            pData[ 8 ] = pElements[ 10 ];
		        	}
		        }
		        else if(arguments[0] instanceof Vec3){
		            var v3fVec: IVec3 = arguments[0];

//диагональ

		            pData[ 0 ] = v3fVec.x;
		            pData[ 3 ] = 0;
		            pData[ 6 ] = 0;

		            pData[ 1 ] = 0;
		            pData[ 4 ] = v3fVec.y;
		            pData[ 7 ] = 0;

		            pData[ 2 ] = 0;
		            pData[ 5 ] = 0;
		            pData[ 8 ] = v3fVec.z;
		        }
		        else{
		            var pElements:  number [] = arguments[0];

		            if(pElements.length == 3){
//ложим диагональ
		                pData[ 0 ] = pElements[0];
		                pData[ 3 ] = 0;
		                pData[ 6 ] = 0;

		                pData[ 1 ] = 0;
		                pData[ 4 ] = pElements[1];
		                pData[ 7 ] = 0;

		                pData[ 2 ] = 0;
		                pData[ 5 ] = 0;
		                pData[ 8 ] = pElements[2];
		            }
		            else{
		                pData[ 0 ] = pElements[ 0 ];
		                pData[ 3 ] = pElements[ 3 ];
		                pData[ 6 ] = pElements[ 6 ];

		                pData[ 1 ] = pElements[ 1 ];
		                pData[ 4 ] = pElements[ 4 ];
		                pData[ 7 ] = pElements[ 7 ];

		                pData[ 2 ] = pElements[ 2 ];
		                pData[ 5 ] = pElements[ 5 ];
		                pData[ 8 ] = pElements[ 8 ];
		            }
		        }
		    }
		    else if(nArgumentsLength == 3){
		        if(isFloat(arguments[0])){
//выставляем диагональ
		            pData[ 0 ] = arguments[0];
		            pData[ 3 ] = 0;
		            pData[ 6 ] = 0;

		            pData[ 1 ] = 0;
		            pData[ 4 ] = arguments[1];
		            pData[ 7 ] = 0;

		            pData[ 2 ] = 0;
		            pData[ 5 ] = 0;
		            pData[ 8 ] = arguments[2];
		        }
		        else{
		            var pData1,pData2,pData3;
		            if(arguments[0] instanceof Vec3){

		                var v3fVec1: IVec3 = arguments[0];
		                var v3fVec2: IVec3 = arguments[1];
		                var v3fVec3: IVec3 = arguments[2];

//ложим по столбцам

		                pData[ 0 ] = v3fVec1.x;
		                pData[ 3 ] = v3fVec2.x;
		                pData[ 6 ] = v3fVec3.x;

		                pData[ 1 ] = v3fVec1.y;
		                pData[ 4 ] = v3fVec2.y;
		                pData[ 7 ] = v3fVec3.y;

		                pData[ 2 ] = v3fVec1.z;
		                pData[ 5 ] = v3fVec2.z;
		                pData[ 8 ] = v3fVec3.z;
		            }
		            else{

		                var v3fVec1:  number [] = arguments[0];
		                var v3fVec2:  number [] = arguments[1];
		                var v3fVec3:  number [] = arguments[2];

//ложим по столбцам

		                pData[ 0 ] = v3fVec1[0];
		                pData[ 3 ] = v3fVec2[0];
		                pData[ 6 ] = v3fVec3[0];

		                pData[ 1 ] = v3fVec1[1];
		                pData[ 4 ] = v3fVec2[1];
		                pData[ 7 ] = v3fVec3[1];

		                pData[ 2 ] = v3fVec1[2];
		                pData[ 5 ] = v3fVec2[2];
		                pData[ 8 ] = v3fVec3[2];
		            }
		        }
		    }
		    else if(nArgumentsLength == 9){
//просто числа
		        pData[ 0 ] = arguments[ 0 ];
		        pData[ 3 ] = arguments[ 3 ];
		        pData[ 6 ] = arguments[ 6 ];

		        pData[ 1 ] = arguments[ 1 ];
		        pData[ 4 ] = arguments[ 4 ];
		        pData[ 7 ] = arguments[ 7 ];

		        pData[ 2 ] = arguments[ 2 ];
		        pData[ 5 ] = arguments[ 5 ];
		        pData[ 8 ] = arguments[ 8 ];
		    }

		    return this;
		};

		identity(): IMat3{
			var pData: Float32Array = this.data;

		    pData[ 0 ] = 1.;
		    pData[ 3 ] = 0.;
		    pData[ 6 ] = 0.;

		    pData[ 1 ] = 0.;
		    pData[ 4 ] = 1.;
		    pData[ 7 ] = 0.;

		    pData[ 2 ] = 0.;
		    pData[ 5 ] = 0.;
		    pData[ 8 ] = 1.;

		    return this;
		};

		add(m3fMat: IMat3, m3fDestination?: IMat3): IMat3{
			if(!isDef(m3fDestination)){
		        m3fDestination = this;
		    }

		    var pData1: Float32Array = this.data;
		    var pData2: Float32Array = m3fMat.data;
		    var pDataDestination: Float32Array = m3fDestination.data;

		    pDataDestination[ 0 ] = pData1[ 0 ] + pData2[ 0 ];
		    pDataDestination[ 3 ] = pData1[ 3 ] + pData2[ 3 ];
		    pDataDestination[ 6 ] = pData1[ 6 ] + pData2[ 6 ];

		    pDataDestination[ 1 ] = pData1[ 1 ] + pData2[ 1 ];
		    pDataDestination[ 4 ] = pData1[ 4 ] + pData2[ 4 ];
		    pDataDestination[ 7 ] = pData1[ 7 ] + pData2[ 7 ];

		    pDataDestination[ 2 ] = pData1[ 2 ] + pData2[ 2 ];
		    pDataDestination[ 5 ] = pData1[ 5 ] + pData2[ 5 ];
		    pDataDestination[ 8 ] = pData1[ 8 ] + pData2[ 8 ];

		    return m3fDestination;
		};

		subtract(m3fMat: IMat3, m3fDestination?: IMat3): IMat3{
			if(!isDef(m3fDestination)){
		        m3fDestination = this;
		    }

		    var pData1: Float32Array = this.data;
		    var pData2: Float32Array = m3fMat.data;
		    var pDataDestination: Float32Array = m3fDestination.data;

		    pDataDestination[ 0 ] = pData1[ 0 ] - pData2[ 0 ];
		    pDataDestination[ 3 ] = pData1[ 3 ] - pData2[ 3 ];
		    pDataDestination[ 6 ] = pData1[ 6 ] - pData2[ 6 ];

		    pDataDestination[ 1 ] = pData1[ 1 ] - pData2[ 1 ];
		    pDataDestination[ 4 ] = pData1[ 4 ] - pData2[ 4 ];
		    pDataDestination[ 7 ] = pData1[ 7 ] - pData2[ 7 ];

		    pDataDestination[ 2 ] = pData1[ 2 ] - pData2[ 2 ];
		    pDataDestination[ 5 ] = pData1[ 5 ] - pData2[ 5 ];
		    pDataDestination[ 8 ] = pData1[ 8 ] - pData2[ 8 ];

		    return m3fDestination;
		};

		multiply(m3fMat: IMat3, m3fDestination?: IMat3): IMat3{
			var pData1: Float32Array = this.data;
	        var pData2: Float32Array = m3fMat.data;

	        if(!isDef(m3fDestination)){
	            m3fDestination = this;
	        }
	        var pDataDestination = m3fDestination.data;

// Cache the matrix values (makes for huge speed increases!)
	        var a11:  number  = pData1[ 0 ], a12:  number  = pData1[ 3 ], a13:  number  = pData1[ 6 ];
	        var a21:  number  = pData1[ 1 ], a22:  number  = pData1[ 4 ], a23:  number  = pData1[ 7 ];
	        var a31:  number  = pData1[ 2 ], a32:  number  = pData1[ 5 ], a33:  number  = pData1[ 8 ];

	        var b11:  number  = pData2[ 0 ], b12:  number  = pData2[ 3 ], b13:  number  = pData2[ 6 ];
	        var b21:  number  = pData2[ 1 ], b22:  number  = pData2[ 4 ], b23:  number  = pData2[ 7 ];
	        var b31:  number  = pData2[ 2 ], b32:  number  = pData2[ 5 ], b33:  number  = pData2[ 8 ];

	        pDataDestination[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
	        pDataDestination[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
	        pDataDestination[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

	        pDataDestination[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
	        pDataDestination[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
	        pDataDestination[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

	        pDataDestination[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
	        pDataDestination[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
	        pDataDestination[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		    return m3fDestination;
		};

		multiplyVec3(v3fVec: IVec3, v3fDestination?: IVec3): IVec3{
			var pData: Float32Array = this.data;

	        if(!isDef(v3fDestination)){
	            v3fDestination = new Vec3();
	        }

	        var x:  number  = v3fVec.x, y:  number  = v3fVec.y, z:  number  = v3fVec.z;

	        v3fDestination.x = pData[ 0 ] * x + pData[ 3 ] * y + pData[ 6 ] * z;
	        v3fDestination.y = pData[ 1 ] * x + pData[ 4 ] * y + pData[ 7 ] * z;
	        v3fDestination.z = pData[ 2 ] * x + pData[ 5 ] * y + pData[ 8 ] * z;

		    return v3fDestination;
		};

		transpose(m3fDestination?: IMat3): IMat3{
			var pData: Float32Array = this.data;
		    if(!isDef(m3fDestination)){
//быстрее будет явно обработать оба случая
		        var a12:  number  = pData[ 3 ], a13:  number  = pData[ 6 ], a23:  number  = pData[ 7 ];

		        pData[ 3 ] = pData[ 1 ];
		        pData[ 6 ] = pData[ 2 ];

		        pData[ 1 ] = a12;
		        pData[ 7 ] = pData[ 5 ];

		        pData[ 2 ] = a13;
		        pData[ 5 ] = a23;

		        return this;
		    }

		    var pDataDestination: Float32Array = m3fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ];
		    pDataDestination[ 3 ] = pData[ 1 ];
		    pDataDestination[ 6 ] = pData[ 2 ];

		    pDataDestination[ 1 ] = pData[ 3 ];
		    pDataDestination[ 4 ] = pData[ 4 ];
		    pDataDestination[ 7 ] = pData[ 5 ];

		    pDataDestination[ 2 ] = pData[ 6 ];
		    pDataDestination[ 5 ] = pData[ 7 ];
		    pDataDestination[ 8 ] = pData[ 8 ];

		    return m3fDestination;
		};

		determinant():  number {
			var pData: Float32Array = this.data;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 3 ], a13:  number  = pData[ 6 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 4 ], a23:  number  = pData[ 7 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 5 ], a33:  number  = pData[ 8 ];

		    return  a11 * (a22 * a33 - a23 * a32)
		            - a12 * (a21 * a33 - a23 * a31)
		            + a13 * (a21 * a32 - a22 * a31);
		};

		inverse(m3fDestination?: IMat3): IMat3{
			if(!isDef(m3fDestination)){
		        m3fDestination = this;
		    }

		    var pData: Float32Array = this.data;
		    var pDataDestination: Float32Array = m3fDestination.data;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 3 ], a13:  number  = pData[ 6 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 4 ], a23:  number  = pData[ 7 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 5 ], a33:  number  = pData[ 8 ];

		    var A11:  number  = a22 * a33 - a23 * a32;
		    var A12:  number  = a21 * a33 - a23 * a31;
		    var A13:  number  = a21 * a32 - a22 * a31;

		    var A21:  number  = a12 * a33 - a13 * a32;
		    var A22:  number  = a11 * a33 - a13 * a31;
		    var A23:  number  = a11 * a32 - a12 * a31;

		    var A31:  number  = a12 * a23 - a13 * a22;
		    var A32:  number  = a11 * a23 - a13 * a21;
		    var A33:  number  = a11 * a22 - a12 * a21;

		    var fDeterminant:  number  = a11*A11 - a12 * A12 + a13 * A13;

		    if(fDeterminant == 0.){
		        logger.setSourceLocation( "Mat3.ts" , 445 ); logger.error("обращение матрицы с нулевым детеминантом:\n", this.toString());
                                      ;

		        return m3fDestination.set(1.);
//чтоб все не навернулось
		    }

		    var fInverseDeterminant:  number  = 1./fDeterminant;

		    pDataDestination[ 0 ] = A11 * fInverseDeterminant;
		    pDataDestination[ 3 ] = -A21 * fInverseDeterminant;
		    pDataDestination[ 6 ] = A31 * fInverseDeterminant;

		    pDataDestination[ 1 ] = -A12 * fInverseDeterminant;
		    pDataDestination[ 4 ] = A22 * fInverseDeterminant;
		    pDataDestination[ 7 ] = -A32 * fInverseDeterminant;

		    pDataDestination[ 2 ] = A13 * fInverseDeterminant;
		    pDataDestination[ 5 ] = -A23 * fInverseDeterminant;
		    pDataDestination[ 8 ] = A33 * fInverseDeterminant;

		    return m3fDestination;
		};

		isEqual(m3fMat: IMat3, fEps:  number  = 0.): bool{
			var pData1: Float32Array = this.data;
		    var pData2: Float32Array = m3fMat.data;

		    if(fEps == 0){
		        if(    pData1[ 0 ] != pData2[ 0 ]
		            || pData1[ 3 ] != pData2[ 3 ]
		            || pData1[ 6 ] != pData2[ 6 ]
		            || pData1[ 1 ] != pData2[ 1 ]
		            || pData1[ 4 ] != pData2[ 4 ]
		            || pData1[ 7 ] != pData2[ 7 ]
		            || pData1[ 2 ] != pData2[ 2 ]
		            || pData1[ 5 ] != pData2[ 5 ]
		            || pData1[ 8 ] != pData2[ 8 ]){

		            return false;
		        }
		    }
		    else{
		        if(    Math.abs(pData1[ 0 ] - pData2[ 0 ]) > fEps
		            || Math.abs(pData1[ 3 ] - pData2[ 3 ]) > fEps
		            || Math.abs(pData1[ 6 ] - pData2[ 6 ]) > fEps
		            || Math.abs(pData1[ 1 ] - pData2[ 1 ]) > fEps
		            || Math.abs(pData1[ 4 ] - pData2[ 4 ]) > fEps
		            || Math.abs(pData1[ 7 ] - pData2[ 7 ]) > fEps
		            || Math.abs(pData1[ 2 ] - pData2[ 2 ]) > fEps
		            || Math.abs(pData1[ 5 ] - pData2[ 5 ]) > fEps
		            || Math.abs(pData1[ 8 ] - pData2[ 8 ]) > fEps){

		            return false;
		        }
		    }
		    return true;
		};

		isDiagonal(fEps:  number  = 0.) : bool{
			var pData: Float32Array = this.data;

		    if(fEps == 0){
		        if(    pData[ 3 ] != 0 || pData[ 6 ] != 0
		            || pData[ 1 ] != 0 || pData[ 7 ] != 0
		            || pData[ 2 ] != 0 || pData[ 5 ] != 0){

		            return false;
		        }
		    }
		    else{
		        if(    Math.abs(pData[ 3 ]) > fEps || Math.abs(pData[ 6 ]) > fEps
		            || Math.abs(pData[ 1 ]) > fEps || Math.abs(pData[ 7 ]) > fEps
		            || Math.abs(pData[ 2 ]) > fEps || Math.abs(pData[ 5 ]) > fEps){

		            return false;
		        }
		    }

		    return true;
		};

		toMat4(m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4();
		    }

		    var pData: Float32Array = this.data;
		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ];
		    pDataDestination[ 4 ] = pData[ 3 ];
		    pDataDestination[ 8 ] = pData[ 6 ];
		    pDataDestination[ 12 ] = 0;

		    pDataDestination[ 1 ] = pData[ 1 ];
		    pDataDestination[ 5 ] = pData[ 4 ];
		    pDataDestination[ 9 ] = pData[ 7 ];
		    pDataDestination[ 13 ] = 0;

		    pDataDestination[ 2 ] = pData[ 2 ];
		    pDataDestination[ 6 ] = pData[ 5 ];
		    pDataDestination[ 10 ] = pData[ 8 ];
		    pDataDestination[ 14 ] = 0;

		    pDataDestination[ 3 ] = 0;
		    pDataDestination[ 7 ] = 0;
		    pDataDestination[ 11 ] = 0;
		    pDataDestination[ 15 ] = 1;

		    return m4fDestination;
		};

		toQuat4(q4fDestination?: IQuat4): IQuat4{
			if(!isDef(q4fDestination)){
		        q4fDestination = new Quat4();
		    }

		    var pData: Float32Array = this.data;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 3 ], a13:  number  = pData[ 6 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 4 ], a23:  number  = pData[ 7 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 5 ], a33:  number  = pData[ 8 ];

/*x^2*/
		    var x2:  number  = ((a11 - a22 - a33) + 1)/4;
/*y^2*/
		    var y2:  number  = ((a22 - a11 - a33) + 1)/4;
/*z^2*/
		    var z2:  number  = ((a33 - a11 - a22) + 1)/4;
/*w^2*/
		    var w2:  number  = ((a11 + a22 + a33) + 1)/4;

		    var fMax:  number  = Math.max(x2,Math.max(y2,Math.max(z2,w2)));

		    if(fMax == x2){
//максимальная компонента берется положительной
		        var x:  number  = Math.sqrt(x2);

		        q4fDestination.x = x;
		        q4fDestination.y = (a21 + a12)/4/x;
		        q4fDestination.z = (a31 + a13)/4/x;
		        q4fDestination.w = (a32 - a23)/4/x;
		    }
		    else if(fMax == y2){
//максимальная компонента берется положительной
		        var y:  number  = Math.sqrt(y2); x

		        q4fDestination.x = (a21 + a12)/4/y;
		        q4fDestination.y = y;
		        q4fDestination.z = (a32 + a23)/4/y;
		        q4fDestination.w = (a13 - a31)/4/y;
		    }
		    else if(fMax == z2){
//максимальная компонента берется положительной
		        var z:  number  = Math.sqrt(z2);

		        q4fDestination.x = (a31 + a13)/4/z;
		        q4fDestination.y = (a32 + a23)/4/z;
		        q4fDestination.z = z;
		        q4fDestination.w = (a21 - a12)/4/z;
		    }
		    else{
//максимальная компонента берется положительной
		        var w:  number  = Math.sqrt(w2);

		        q4fDestination.x = (a32 - a23)/4/w;
		        q4fDestination.y = (a13 - a31)/4/w;
		        q4fDestination.z = (a21 - a12)/4/w;
		        q4fDestination.w = w;
		    }

		    return q4fDestination;
		};

		toString(): string{
			var pData = this.data;
		    return '[' + pData[ 0 ] + ', ' + pData[ 3 ] + ', ' + pData[ 6 ] + ',\n' +
		               + pData[ 1 ] + ', ' + pData[ 4 ] + ', ' + pData[ 7 ] + ',\n' +
		               + pData[ 2 ] + ', ' + pData[ 5 ] + ', ' + pData[ 8 ] + ']';
		};

		decompose(q4fRotation: IQuat4, v3fScale: IVec3): bool{
//изначально предполагаем, что порядок умножения был rot * scale
			var m3fRotScale: IMat3 = this;
			var m3fRotScaleTransposed: IMat3 = this.transpose(mat3());
			var isRotScale: bool = true;

//понадобятся если порядок умножения был другим
		    var m3fScaleRot: IMat3, m3fScaleRotTransposed: IMat3;

//было отражение или нет
    		var scaleSign:  number  = (m3fRotScale.determinant() >= 0.) ? 1 : -1;

    		var m3fResult: IMat3 = mat3();

//first variant rot * scale
// (rot * scale)T * (rot * scale) = 
// scaleT * rotT * rot * scale = scaleT *rot^-1 * rot * scale = 
// scaleT * scale
		    m3fRotScaleTransposed.multiply(m3fRotScale, m3fResult);
		   	if(!m3fResult.isDiagonal(1e-4)){
//предположение было неверным
		   		isRotScale = false;
//просто переобозначения чтобы не было путаницы
		        m3fScaleRot = m3fRotScale;
		        m3fScaleRotTransposed = m3fRotScaleTransposed;

//second variant scale * rot
// (scale * rot) * (scale * rot)T = 
// scale * rot * rotT * scaleT = scale *rot * rot^-1 * scaleT = 
// scale * scaleT

		        m3fScaleRot.multiply(m3fScaleRotTransposed,m3fResult);
		   	}

		   	var pResultData: Float32Array = m3fResult.data;

		   	var x:  number  = sqrt(pResultData[ 0 ]);
/*если было отражение, считается что оно было по y*/
		   	var y:  number  = sqrt(pResultData[ 4 ])*scaleSign;
		   	var z:  number  = sqrt(pResultData[ 8 ]);

		   	v3fScale.x = x;
		   	v3fScale.y = y;
		   	v3fScale.z = z;

		   	var m3fInverseScale: IMat3 = mat3(1./x,1./y,1./z);

		   	if(isRotScale){
		   		m3fRotScale.multiply(m3fInverseScale,mat3()).toQuat4(q4fRotation);
		   		return true;
		   	}
		   	else{
		   		m3fInverseScale.multiply(m3fScaleRot,mat3()).toQuat4(q4fRotation);
		   		logger.setSourceLocation( "Mat3.ts" , 674 ); logger.assert(false,"порядок умножения scale rot в данный момент не поддерживается"); ;
		   		return false;
		   	}
		};

		row(iRow:  number , v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			var pData: Float32Array = this.data;

			switch(iRow){
				case 1:
					v3fDestination.x = pData[ 0 ];
					v3fDestination.y = pData[ 3 ];
					v3fDestination.z = pData[ 6 ];
					break;
				case 2:
					v3fDestination.x = pData[ 1 ];
					v3fDestination.y = pData[ 4 ];
					v3fDestination.z = pData[ 7 ];
					break;
				case 3:
					v3fDestination.x = pData[ 2 ];
					v3fDestination.y = pData[ 5 ];
					v3fDestination.z = pData[ 8 ];
					break;
			}

			return v3fDestination;
		};

		column(iColumn:  number , v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			var pData: Float32Array = this.data;

			switch(iColumn){
				case 1:
					v3fDestination.x = pData[ 0 ];
					v3fDestination.y = pData[ 1 ];
					v3fDestination.z = pData[ 2 ];
					break;
				case 2:
					v3fDestination.x = pData[ 3 ];
					v3fDestination.y = pData[ 4 ];
					v3fDestination.z = pData[ 5 ];
					break;
				case 3:
					v3fDestination.x = pData[ 6 ];
					v3fDestination.y = pData[ 7 ];
					v3fDestination.z = pData[ 8 ];
					break;
			}

			return v3fDestination;
		};

		static fromYawPitchRoll(fYaw:  number , fPitch:  number , fRoll:  number , m3fDestination?: IMat3): IMat3;
		static fromYawPitchRoll(v3fAngles: IVec3, m3fDestination?: IMat3): IMat3;
		static fromYawPitchRoll(fYaw?,fPitch?,fRoll?,m3fDestination?): IMat3{
			if(arguments.length <= 2){
//Vec3 + m3fDestination
		        var v3fVec: IVec3 = arguments[0];

		        fYaw   = v3fVec.x;
		        fPitch = v3fVec.y;
		        fRoll  = v3fVec.z;

		        m3fDestination = arguments[1];
		    }

		    if(!isDef(m3fDestination)){
		        m3fDestination = new Mat3();
		    }

		    var pDataDestination: Float32Array = m3fDestination.data;

		    var fSin1:  number  = Math.sin(fYaw);
		    var fSin2:  number  = Math.sin(fPitch);
		    var fSin3:  number  = Math.sin(fRoll);

		    var fCos1:  number  = Math.cos(fYaw);
		    var fCos2:  number  = Math.cos(fPitch);
		    var fCos3:  number  = Math.cos(fRoll);

		    pDataDestination[ 0 ] = fCos1 * fCos3 + fSin1 * fSin2 * fSin3;
		    pDataDestination[ 3 ] = fCos3 * fSin1 * fSin2 - fCos1 * fSin3;
		    pDataDestination[ 6 ] = fCos2 * fSin1;

		    pDataDestination[ 1 ] = fCos2 * fSin3;
		    pDataDestination[ 4 ] = fCos2 * fCos3;
		    pDataDestination[ 7 ] = -fSin2;

		    pDataDestination[ 2 ] = fCos1 * fSin2 * fSin3 - fCos3 * fSin1;
		    pDataDestination[ 5 ] = fSin1 * fSin3 + fCos1 * fCos3 * fSin2;
		    pDataDestination[ 8 ] = fCos1 * fCos2;

		    return m3fDestination;
		};

		static fromXYZ(fX:  number , fY:  number , fZ:  number , m3fDestination?: IMat3): IMat3;
		static fromXYZ(v3fAngles: IVec3, m3fDestination?: IMat3): IMat3;
		static fromXYZ(fX?, fY?, fZ?, m3fDestination?) : IMat3{
			if(arguments.length <= 2){
//Vec3 + m3fDestination
				var v3fVec: IVec3 = arguments[0];
				return Mat3.fromYawPitchRoll(v3fVec.y,v3fVec.x,v3fVec.z,arguments[1]);
			}
			else{
//fX fY fZ m3fDestination
				var fX:  number  = arguments[0];
				var fY:  number  = arguments[1];
				var fZ:  number  = arguments[2];

				return Mat3.fromYawPitchRoll(fY, fX, fZ, arguments[3]);
			}
		};

		static get stackCeil(): Mat3 { Mat3.stackPosition = Mat3.stackPosition === Mat3.stackSize - 1? 0: Mat3.stackPosition; return Mat3.stack[Mat3.stackPosition ++]; } static stackSize: number = 100; static stackPosition: number = 0; static stack: Mat3[] = (function(): Mat3[]{ var pStack: Mat3[] = new Array(Mat3.stackSize); for(var i: number = 0; i<Mat3.stackSize; i++){ pStack[i] = new Mat3(); } return pStack})(); ;
    };
};
















module akra {

	export interface IVec2 {} ;
	export interface IVec3 {} ;
	export interface IColorValue {} ;

	export interface IVec4Constructor {
        ();
        (fValue:  number );
        (v4fVec: IVec4);
        (pArray:  number []);
        (fValue:  number , v3fVec: IVec3);
        (v2fVec1: IVec2, v2fVec2: IVec2);
        (v3fVec: IVec3, fValue:  number );
        (fValue1:  number , fValue2:  number , v2fVec: IVec2);
        (fValue1:  number , v2fVec: IVec2, fValue2:  number );
        (v2fVec: IVec2 ,fValue1:  number , fValue2:  number );
        (fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number );
    }


	export interface IVec4 {
		x:  number ;
		y:  number ;
		z:  number ;
		w:  number ;


/*represents two-component vector from original vector*/

xx: IVec2;
/*represents two-component vector from original vector*/

xy: IVec2;
/*represents two-component vector from original vector*/

xz: IVec2;
/*represents two-component vector from original vector*/

xw: IVec2;
/*represents two-component vector from original vector*/

yx: IVec2;
/*represents two-component vector from original vector*/

yy: IVec2;
/*represents two-component vector from original vector*/

yz: IVec2;
/*represents two-component vector from original vector*/

yw: IVec2;
/*represents two-component vector from original vector*/

zx: IVec2;
/*represents two-component vector from original vector*/

zy: IVec2;
/*represents two-component vector from original vector*/

zz: IVec2;
/*represents two-component vector from original vector*/

zw: IVec2;
/*represents two-component vector from original vector*/

wx: IVec2;
/*represents two-component vector from original vector*/

wy: IVec2;
/*represents two-component vector from original vector*/

wz: IVec2;
/*represents two-component vector from original vector*/

ww: IVec2;

/*represents three-component vector from original vector*/

xxx: IVec3;
/*represents three-component vector from original vector*/

xxy: IVec3;
/*represents three-component vector from original vector*/

xxz: IVec3;
/*represents three-component vector from original vector*/

xxw: IVec3;
/*represents three-component vector from original vector*/

xyx: IVec3;
/*represents three-component vector from original vector*/

xyy: IVec3;
/*represents three-component vector from original vector*/

xyz: IVec3;
/*represents three-component vector from original vector*/

xyw: IVec3;
/*represents three-component vector from original vector*/

xzx: IVec3;
/*represents three-component vector from original vector*/

xzy: IVec3;
/*represents three-component vector from original vector*/

xzz: IVec3;
/*represents three-component vector from original vector*/

xzw: IVec3;
/*represents three-component vector from original vector*/

xwx: IVec3;
/*represents three-component vector from original vector*/

xwy: IVec3;
/*represents three-component vector from original vector*/

xwz: IVec3;
/*represents three-component vector from original vector*/

xww: IVec3;
/*represents three-component vector from original vector*/

yxx: IVec3;
/*represents three-component vector from original vector*/

yxy: IVec3;
/*represents three-component vector from original vector*/

yxz: IVec3;
/*represents three-component vector from original vector*/

yxw: IVec3;
/*represents three-component vector from original vector*/

yyx: IVec3;
/*represents three-component vector from original vector*/

yyy: IVec3;
/*represents three-component vector from original vector*/

yyz: IVec3;
/*represents three-component vector from original vector*/

yyw: IVec3;
/*represents three-component vector from original vector*/

yzx: IVec3;
/*represents three-component vector from original vector*/

yzy: IVec3;
/*represents three-component vector from original vector*/

yzz: IVec3;
/*represents three-component vector from original vector*/

yzw: IVec3;
/*represents three-component vector from original vector*/

ywx: IVec3;
/*represents three-component vector from original vector*/

ywy: IVec3;
/*represents three-component vector from original vector*/

ywz: IVec3;
/*represents three-component vector from original vector*/

yww: IVec3;
/*represents three-component vector from original vector*/

zxx: IVec3;
/*represents three-component vector from original vector*/

zxy: IVec3;
/*represents three-component vector from original vector*/

zxz: IVec3;
/*represents three-component vector from original vector*/

zxw: IVec3;
/*represents three-component vector from original vector*/

zyx: IVec3;
/*represents three-component vector from original vector*/

zyy: IVec3;
/*represents three-component vector from original vector*/

zyz: IVec3;
/*represents three-component vector from original vector*/

zyw: IVec3;
/*represents three-component vector from original vector*/

zzx: IVec3;
/*represents three-component vector from original vector*/

zzy: IVec3;
/*represents three-component vector from original vector*/

zzz: IVec3;
/*represents three-component vector from original vector*/

zzw: IVec3;
/*represents three-component vector from original vector*/

zwx: IVec3;
/*represents three-component vector from original vector*/

zwy: IVec3;
/*represents three-component vector from original vector*/

zwz: IVec3;
/*represents three-component vector from original vector*/

zww: IVec3;
/*represents three-component vector from original vector*/

wxx: IVec3;
/*represents three-component vector from original vector*/

wxy: IVec3;
/*represents three-component vector from original vector*/

wxz: IVec3;
/*represents three-component vector from original vector*/

wxw: IVec3;
/*represents three-component vector from original vector*/

wyx: IVec3;
/*represents three-component vector from original vector*/

wyy: IVec3;
/*represents three-component vector from original vector*/

wyz: IVec3;
/*represents three-component vector from original vector*/

wyw: IVec3;
/*represents three-component vector from original vector*/

wzx: IVec3;
/*represents three-component vector from original vector*/

wzy: IVec3;
/*represents three-component vector from original vector*/

wzz: IVec3;
/*represents three-component vector from original vector*/

wzw: IVec3;
/*represents three-component vector from original vector*/

wwx: IVec3;
/*represents three-component vector from original vector*/

wwy: IVec3;
/*represents three-component vector from original vector*/

wwz: IVec3;
/*represents three-component vector from original vector*/

www: IVec3;

/*represents four-component vector from original vector*/

xxxx: IVec4;
/*represents four-component vector from original vector*/

xxxy: IVec4;
/*represents four-component vector from original vector*/

xxxz: IVec4;
/*represents four-component vector from original vector*/

xxxw: IVec4;
/*represents four-component vector from original vector*/

xxyx: IVec4;
/*represents four-component vector from original vector*/

xxyy: IVec4;
/*represents four-component vector from original vector*/

xxyz: IVec4;
/*represents four-component vector from original vector*/

xxyw: IVec4;
/*represents four-component vector from original vector*/

xxzx: IVec4;
/*represents four-component vector from original vector*/

xxzy: IVec4;
/*represents four-component vector from original vector*/

xxzz: IVec4;
/*represents four-component vector from original vector*/

xxzw: IVec4;
/*represents four-component vector from original vector*/

xxwx: IVec4;
/*represents four-component vector from original vector*/

xxwy: IVec4;
/*represents four-component vector from original vector*/

xxwz: IVec4;
/*represents four-component vector from original vector*/

xxww: IVec4;
/*represents four-component vector from original vector*/

xyxx: IVec4;
/*represents four-component vector from original vector*/

xyxy: IVec4;
/*represents four-component vector from original vector*/

xyxz: IVec4;
/*represents four-component vector from original vector*/

xyxw: IVec4;
/*represents four-component vector from original vector*/

xyyx: IVec4;
/*represents four-component vector from original vector*/

xyyy: IVec4;
/*represents four-component vector from original vector*/

xyyz: IVec4;
/*represents four-component vector from original vector*/

xyyw: IVec4;
/*represents four-component vector from original vector*/

xyzx: IVec4;
/*represents four-component vector from original vector*/

xyzy: IVec4;
/*represents four-component vector from original vector*/

xyzz: IVec4;
/*represents four-component vector from original vector*/

xyzw: IVec4;
/*represents four-component vector from original vector*/

xywx: IVec4;
/*represents four-component vector from original vector*/

xywy: IVec4;
/*represents four-component vector from original vector*/

xywz: IVec4;
/*represents four-component vector from original vector*/

xyww: IVec4;
/*represents four-component vector from original vector*/

xzxx: IVec4;
/*represents four-component vector from original vector*/

xzxy: IVec4;
/*represents four-component vector from original vector*/

xzxz: IVec4;
/*represents four-component vector from original vector*/

xzxw: IVec4;
/*represents four-component vector from original vector*/

xzyx: IVec4;
/*represents four-component vector from original vector*/

xzyy: IVec4;
/*represents four-component vector from original vector*/

xzyz: IVec4;
/*represents four-component vector from original vector*/

xzyw: IVec4;
/*represents four-component vector from original vector*/

xzzx: IVec4;
/*represents four-component vector from original vector*/

xzzy: IVec4;
/*represents four-component vector from original vector*/

xzzz: IVec4;
/*represents four-component vector from original vector*/

xzzw: IVec4;
/*represents four-component vector from original vector*/

xzwx: IVec4;
/*represents four-component vector from original vector*/

xzwy: IVec4;
/*represents four-component vector from original vector*/

xzwz: IVec4;
/*represents four-component vector from original vector*/

xzww: IVec4;
/*represents four-component vector from original vector*/

xwxx: IVec4;
/*represents four-component vector from original vector*/

xwxy: IVec4;
/*represents four-component vector from original vector*/

xwxz: IVec4;
/*represents four-component vector from original vector*/

xwxw: IVec4;
/*represents four-component vector from original vector*/

xwyx: IVec4;
/*represents four-component vector from original vector*/

xwyy: IVec4;
/*represents four-component vector from original vector*/

xwyz: IVec4;
/*represents four-component vector from original vector*/

xwyw: IVec4;
/*represents four-component vector from original vector*/

xwzx: IVec4;
/*represents four-component vector from original vector*/

xwzy: IVec4;
/*represents four-component vector from original vector*/

xwzz: IVec4;
/*represents four-component vector from original vector*/

xwzw: IVec4;
/*represents four-component vector from original vector*/

xwwx: IVec4;
/*represents four-component vector from original vector*/

xwwy: IVec4;
/*represents four-component vector from original vector*/

xwwz: IVec4;
/*represents four-component vector from original vector*/

xwww: IVec4;
/*represents four-component vector from original vector*/

yxxx: IVec4;
/*represents four-component vector from original vector*/

yxxy: IVec4;
/*represents four-component vector from original vector*/

yxxz: IVec4;
/*represents four-component vector from original vector*/

yxxw: IVec4;
/*represents four-component vector from original vector*/

yxyx: IVec4;
/*represents four-component vector from original vector*/

yxyy: IVec4;
/*represents four-component vector from original vector*/

yxyz: IVec4;
/*represents four-component vector from original vector*/

yxyw: IVec4;
/*represents four-component vector from original vector*/

yxzx: IVec4;
/*represents four-component vector from original vector*/

yxzy: IVec4;
/*represents four-component vector from original vector*/

yxzz: IVec4;
/*represents four-component vector from original vector*/

yxzw: IVec4;
/*represents four-component vector from original vector*/

yxwx: IVec4;
/*represents four-component vector from original vector*/

yxwy: IVec4;
/*represents four-component vector from original vector*/

yxwz: IVec4;
/*represents four-component vector from original vector*/

yxww: IVec4;
/*represents four-component vector from original vector*/

yyxx: IVec4;
/*represents four-component vector from original vector*/

yyxy: IVec4;
/*represents four-component vector from original vector*/

yyxz: IVec4;
/*represents four-component vector from original vector*/

yyxw: IVec4;
/*represents four-component vector from original vector*/

yyyx: IVec4;
/*represents four-component vector from original vector*/

yyyy: IVec4;
/*represents four-component vector from original vector*/

yyyz: IVec4;
/*represents four-component vector from original vector*/

yyyw: IVec4;
/*represents four-component vector from original vector*/

yyzx: IVec4;
/*represents four-component vector from original vector*/

yyzy: IVec4;
/*represents four-component vector from original vector*/

yyzz: IVec4;
/*represents four-component vector from original vector*/

yyzw: IVec4;
/*represents four-component vector from original vector*/

yywx: IVec4;
/*represents four-component vector from original vector*/

yywy: IVec4;
/*represents four-component vector from original vector*/

yywz: IVec4;
/*represents four-component vector from original vector*/

yyww: IVec4;
/*represents four-component vector from original vector*/

yzxx: IVec4;
/*represents four-component vector from original vector*/

yzxy: IVec4;
/*represents four-component vector from original vector*/

yzxz: IVec4;
/*represents four-component vector from original vector*/

yzxw: IVec4;
/*represents four-component vector from original vector*/

yzyx: IVec4;
/*represents four-component vector from original vector*/

yzyy: IVec4;
/*represents four-component vector from original vector*/

yzyz: IVec4;
/*represents four-component vector from original vector*/

yzyw: IVec4;
/*represents four-component vector from original vector*/

yzzx: IVec4;
/*represents four-component vector from original vector*/

yzzy: IVec4;
/*represents four-component vector from original vector*/

yzzz: IVec4;
/*represents four-component vector from original vector*/

yzzw: IVec4;
/*represents four-component vector from original vector*/

yzwx: IVec4;
/*represents four-component vector from original vector*/

yzwy: IVec4;
/*represents four-component vector from original vector*/

yzwz: IVec4;
/*represents four-component vector from original vector*/

yzww: IVec4;
/*represents four-component vector from original vector*/

ywxx: IVec4;
/*represents four-component vector from original vector*/

ywxy: IVec4;
/*represents four-component vector from original vector*/

ywxz: IVec4;
/*represents four-component vector from original vector*/

ywxw: IVec4;
/*represents four-component vector from original vector*/

ywyx: IVec4;
/*represents four-component vector from original vector*/

ywyy: IVec4;
/*represents four-component vector from original vector*/

ywyz: IVec4;
/*represents four-component vector from original vector*/

ywyw: IVec4;
/*represents four-component vector from original vector*/

ywzx: IVec4;
/*represents four-component vector from original vector*/

ywzy: IVec4;
/*represents four-component vector from original vector*/

ywzz: IVec4;
/*represents four-component vector from original vector*/

ywzw: IVec4;
/*represents four-component vector from original vector*/

ywwx: IVec4;
/*represents four-component vector from original vector*/

ywwy: IVec4;
/*represents four-component vector from original vector*/

ywwz: IVec4;
/*represents four-component vector from original vector*/

ywww: IVec4;
/*represents four-component vector from original vector*/

zxxx: IVec4;
/*represents four-component vector from original vector*/

zxxy: IVec4;
/*represents four-component vector from original vector*/

zxxz: IVec4;
/*represents four-component vector from original vector*/

zxxw: IVec4;
/*represents four-component vector from original vector*/

zxyx: IVec4;
/*represents four-component vector from original vector*/

zxyy: IVec4;
/*represents four-component vector from original vector*/

zxyz: IVec4;
/*represents four-component vector from original vector*/

zxyw: IVec4;
/*represents four-component vector from original vector*/

zxzx: IVec4;
/*represents four-component vector from original vector*/

zxzy: IVec4;
/*represents four-component vector from original vector*/

zxzz: IVec4;
/*represents four-component vector from original vector*/

zxzw: IVec4;
/*represents four-component vector from original vector*/

zxwx: IVec4;
/*represents four-component vector from original vector*/

zxwy: IVec4;
/*represents four-component vector from original vector*/

zxwz: IVec4;
/*represents four-component vector from original vector*/

zxww: IVec4;
/*represents four-component vector from original vector*/

zyxx: IVec4;
/*represents four-component vector from original vector*/

zyxy: IVec4;
/*represents four-component vector from original vector*/

zyxz: IVec4;
/*represents four-component vector from original vector*/

zyxw: IVec4;
/*represents four-component vector from original vector*/

zyyx: IVec4;
/*represents four-component vector from original vector*/

zyyy: IVec4;
/*represents four-component vector from original vector*/

zyyz: IVec4;
/*represents four-component vector from original vector*/

zyyw: IVec4;
/*represents four-component vector from original vector*/

zyzx: IVec4;
/*represents four-component vector from original vector*/

zyzy: IVec4;
/*represents four-component vector from original vector*/

zyzz: IVec4;
/*represents four-component vector from original vector*/

zyzw: IVec4;
/*represents four-component vector from original vector*/

zywx: IVec4;
/*represents four-component vector from original vector*/

zywy: IVec4;
/*represents four-component vector from original vector*/

zywz: IVec4;
/*represents four-component vector from original vector*/

zyww: IVec4;
/*represents four-component vector from original vector*/

zzxx: IVec4;
/*represents four-component vector from original vector*/

zzxy: IVec4;
/*represents four-component vector from original vector*/

zzxz: IVec4;
/*represents four-component vector from original vector*/

zzxw: IVec4;
/*represents four-component vector from original vector*/

zzyx: IVec4;
/*represents four-component vector from original vector*/

zzyy: IVec4;
/*represents four-component vector from original vector*/

zzyz: IVec4;
/*represents four-component vector from original vector*/

zzyw: IVec4;
/*represents four-component vector from original vector*/

zzzx: IVec4;
/*represents four-component vector from original vector*/

zzzy: IVec4;
/*represents four-component vector from original vector*/

zzzz: IVec4;
/*represents four-component vector from original vector*/

zzzw: IVec4;
/*represents four-component vector from original vector*/

zzwx: IVec4;
/*represents four-component vector from original vector*/

zzwy: IVec4;
/*represents four-component vector from original vector*/

zzwz: IVec4;
/*represents four-component vector from original vector*/

zzww: IVec4;
/*represents four-component vector from original vector*/

zwxx: IVec4;
/*represents four-component vector from original vector*/

zwxy: IVec4;
/*represents four-component vector from original vector*/

zwxz: IVec4;
/*represents four-component vector from original vector*/

zwxw: IVec4;
/*represents four-component vector from original vector*/

zwyx: IVec4;
/*represents four-component vector from original vector*/

zwyy: IVec4;
/*represents four-component vector from original vector*/

zwyz: IVec4;
/*represents four-component vector from original vector*/

zwyw: IVec4;
/*represents four-component vector from original vector*/

zwzx: IVec4;
/*represents four-component vector from original vector*/

zwzy: IVec4;
/*represents four-component vector from original vector*/

zwzz: IVec4;
/*represents four-component vector from original vector*/

zwzw: IVec4;
/*represents four-component vector from original vector*/

zwwx: IVec4;
/*represents four-component vector from original vector*/

zwwy: IVec4;
/*represents four-component vector from original vector*/

zwwz: IVec4;
/*represents four-component vector from original vector*/

zwww: IVec4;
/*represents four-component vector from original vector*/

wxxx: IVec4;
/*represents four-component vector from original vector*/

wxxy: IVec4;
/*represents four-component vector from original vector*/

wxxz: IVec4;
/*represents four-component vector from original vector*/

wxxw: IVec4;
/*represents four-component vector from original vector*/

wxyx: IVec4;
/*represents four-component vector from original vector*/

wxyy: IVec4;
/*represents four-component vector from original vector*/

wxyz: IVec4;
/*represents four-component vector from original vector*/

wxyw: IVec4;
/*represents four-component vector from original vector*/

wxzx: IVec4;
/*represents four-component vector from original vector*/

wxzy: IVec4;
/*represents four-component vector from original vector*/

wxzz: IVec4;
/*represents four-component vector from original vector*/

wxzw: IVec4;
/*represents four-component vector from original vector*/

wxwx: IVec4;
/*represents four-component vector from original vector*/

wxwy: IVec4;
/*represents four-component vector from original vector*/

wxwz: IVec4;
/*represents four-component vector from original vector*/

wxww: IVec4;
/*represents four-component vector from original vector*/

wyxx: IVec4;
/*represents four-component vector from original vector*/

wyxy: IVec4;
/*represents four-component vector from original vector*/

wyxz: IVec4;
/*represents four-component vector from original vector*/

wyxw: IVec4;
/*represents four-component vector from original vector*/

wyyx: IVec4;
/*represents four-component vector from original vector*/

wyyy: IVec4;
/*represents four-component vector from original vector*/

wyyz: IVec4;
/*represents four-component vector from original vector*/

wyyw: IVec4;
/*represents four-component vector from original vector*/

wyzx: IVec4;
/*represents four-component vector from original vector*/

wyzy: IVec4;
/*represents four-component vector from original vector*/

wyzz: IVec4;
/*represents four-component vector from original vector*/

wyzw: IVec4;
/*represents four-component vector from original vector*/

wywx: IVec4;
/*represents four-component vector from original vector*/

wywy: IVec4;
/*represents four-component vector from original vector*/

wywz: IVec4;
/*represents four-component vector from original vector*/

wyww: IVec4;
/*represents four-component vector from original vector*/

wzxx: IVec4;
/*represents four-component vector from original vector*/

wzxy: IVec4;
/*represents four-component vector from original vector*/

wzxz: IVec4;
/*represents four-component vector from original vector*/

wzxw: IVec4;
/*represents four-component vector from original vector*/

wzyx: IVec4;
/*represents four-component vector from original vector*/

wzyy: IVec4;
/*represents four-component vector from original vector*/

wzyz: IVec4;
/*represents four-component vector from original vector*/

wzyw: IVec4;
/*represents four-component vector from original vector*/

wzzx: IVec4;
/*represents four-component vector from original vector*/

wzzy: IVec4;
/*represents four-component vector from original vector*/

wzzz: IVec4;
/*represents four-component vector from original vector*/

wzzw: IVec4;
/*represents four-component vector from original vector*/

wzwx: IVec4;
/*represents four-component vector from original vector*/

wzwy: IVec4;
/*represents four-component vector from original vector*/

wzwz: IVec4;
/*represents four-component vector from original vector*/

wzww: IVec4;
/*represents four-component vector from original vector*/

wwxx: IVec4;
/*represents four-component vector from original vector*/

wwxy: IVec4;
/*represents four-component vector from original vector*/

wwxz: IVec4;
/*represents four-component vector from original vector*/

wwxw: IVec4;
/*represents four-component vector from original vector*/

wwyx: IVec4;
/*represents four-component vector from original vector*/

wwyy: IVec4;
/*represents four-component vector from original vector*/

wwyz: IVec4;
/*represents four-component vector from original vector*/

wwyw: IVec4;
/*represents four-component vector from original vector*/

wwzx: IVec4;
/*represents four-component vector from original vector*/

wwzy: IVec4;
/*represents four-component vector from original vector*/

wwzz: IVec4;
/*represents four-component vector from original vector*/

wwzw: IVec4;
/*represents four-component vector from original vector*/

wwwx: IVec4;
/*represents four-component vector from original vector*/

wwwy: IVec4;
/*represents four-component vector from original vector*/

wwwz: IVec4;
/*represents four-component vector from original vector*/

wwww: IVec4;

		set(): IVec4;
		set(fValue:  number ): IVec4;
		set(v4fVec: IVec4): IVec4;
		set(c4fColor: IColorValue): IVec4;
		set(pArray:  number []): IVec4;
		set(fValue:  number , v3fVec: IVec3): IVec4;
		set(v2fVec1: IVec2, v2fVec2: IVec2): IVec4;
		set(v3fVec: IVec3, fValue:  number ): IVec4;
		set(fValue1:  number , fValue2:  number , v2fVec: IVec2): IVec4;
		set(fValue1:  number , v2fVec: IVec2, fValue2:  number ): IVec4;
		set(v2fVec: IVec2, fValue1:  number , fValue2:  number ): IVec4;
		set(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ): IVec4;

		clear(): IVec4;

		add(v4fVec: IVec4, v4fDestination?: IVec4): IVec4;
		subtract(v4fVec: IVec4, v4fDestination?: IVec4): IVec4;
		dot(v4fVec: IVec4):  number ;

		isEqual(v4fVec: IVec4, fEps?:  number ): bool;
		isClear(fEps?:  number ): bool;

		negate(v4fDestination?: IVec4): IVec4;
		scale(fScale:  number , v4fDestination?: IVec4): IVec4;
		normalize(v4fDestination?: IVec4): IVec4;
		length():  number ;
		lengthSquare():  number ;

		direction(v4fVec: IVec4, v4fDestination?: IVec4): IVec4;

		mix(v4fVec: IVec4, fA:  number , v4fDestination?: IVec4): IVec4;

		toString(): string;
	};
};





module akra.math {
    export class Mat4 implements IMat4{
    	data: Float32Array;

		constructor();
		constructor(fValue:  number );
		constructor(v4fVec: IVec4);
		constructor(m3fMat: IMat3, v3fTranslation?: IVec3);
		constructor(m4fMat: IMat4);
		constructor(pArray:  number []);
		constructor(pArray: Float32Array, bFlag: bool);
		constructor(fValue1:  number , fValue2:  number ,
				fValue3:  number , fValue4:  number );
		constructor(v4fVec1: IVec4, v4fVec2: IVec4,
				v4fVec3: IVec4, v4fVec4: IVec4);
		constructor(pArray1:  number [], pArray2:  number [],
				pArray3:  number [], pArray4:  number []);
		constructor(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ,
				fValue5:  number , fValue6:  number , fValue7:  number , fValue8:  number ,
				fValue9:  number , fValue10:  number , fValue11:  number , fValue12:  number ,
				fValue13:  number , fValue14:  number , fValue15:  number , fValue16:  number );
		constructor(fValue1?, fValue2?, fValue3?, fValue4?,
					fValue5?, fValue6?, fValue7?, fValue8?,
					fValue9?, fValue10?, fValue11?, fValue12?,
					fValue13?, fValue14?, fValue15?, fValue16?){
			var nArgumentsLength:  number  = arguments.length;

			if(nArgumentsLength === 2){
				if(isBoolean(arguments[1])){
					if(arguments[1]){
						this.data = arguments[0];
					}
					else{
						this.data = new Float32Array(16);
						this.set(arguments[0]);
					}
				}
				else{
					this.data = new Float32Array(16);
					this.set(arguments[0], arguments[1]);
				}
			}
			else{
				this.data = new Float32Array(16);

				switch(nArgumentsLength){
					case 1:
						if(arguments[0] instanceof Mat3){
							this.set(arguments[0],vec3(0.));
						}
						else{
							this.set(arguments[0]);
						}
						break;
					case 4:
						this.set(arguments[0],arguments[1],arguments[2],arguments[3]);
						break;
					case 16:
						this.set(arguments[0], arguments[1], arguments[2], arguments[3],
							 arguments[4], arguments[5], arguments[6], arguments[7],
							 arguments[8], arguments[9], arguments[10], arguments[11],
							 arguments[12], arguments[13], arguments[14], arguments[15]);
						 break;
					 default:
					 	break;
				}
			}
		};

		set(): IMat4;
		set(fValue:  number ): IMat4;
		set(v4fVec: IVec4): IMat4;
		set(m3fMat: IMat3, v3fTranslation?: IVec3): IMat4;
		set(m4fMat: IMat4): IMat4;
		set(pArray:  number []): IMat4;
		set(fValue1:  number , fValue2:  number ,
			fValue3:  number , fValue4:  number ): IMat4;
		set(v4fVec1: IVec4, v4fVec2: IVec4,
			v4fVec3: IVec4, v4fVec4: IVec4): IMat4;
		set(pArray1:  number [], pArray2:  number [],
			pArray3:  number [], pArray4:  number []): IMat4;
		set(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ,
			fValue5:  number , fValue6:  number , fValue7:  number , fValue8:  number ,
			fValue9:  number , fValue10:  number , fValue11:  number , fValue12:  number ,
			fValue13:  number , fValue14:  number , fValue15:  number , fValue16:  number ): IMat4;
		set(fValue1?, fValue2?, fValue3?, fValue4?,
			fValue5?, fValue6?, fValue7?, fValue8?,
			fValue9?, fValue10?, fValue11?, fValue12?,
			fValue13?, fValue14?, fValue15?, fValue16?): IMat4{

			var nArgumentsLength:  number  = arguments.length;
			var pData: Float32Array = this.data;

			if(nArgumentsLength === 0){
				pData[ 0 ] = pData[ 4 ] = pData[ 8 ] = pData[ 12 ] =
				pData[ 1 ] = pData[ 5 ] = pData[ 9 ] = pData[ 13 ] =
				pData[ 2 ] = pData[ 6 ] = pData[ 10 ] = pData[ 14 ] =
				pData[ 3 ] = pData[ 7 ] = pData[ 11 ] = pData[ 15 ] = 0.;

				return this;
			}

			if(nArgumentsLength === 1){
				if(isFloat(arguments[0])){
					var fValue:  number  = arguments[0];

					pData[ 0 ] = fValue;
					pData[ 4 ] = 0.;
					pData[ 8 ] = 0.;
					pData[ 12 ] = 0.;

					pData[ 1 ] = 0.;
					pData[ 5 ] = fValue;
					pData[ 9 ] = 0.;
					pData[ 13 ] = 0.;

					pData[ 2 ] = 0.;
					pData[ 6 ] = 0.;
					pData[ 10 ] = fValue;
					pData[ 14 ] = 0.;

					pData[ 3 ] = 0.;
					pData[ 7 ] = 0.;
					pData[ 11 ] = 0.
					pData[ 15 ] = fValue;
				}
				else if(arguments[0] instanceof Vec4){
					var v4fVec = arguments[0];

					pData[ 0 ] = v4fVec.x;
					pData[ 4 ] = 0.;
					pData[ 8 ] = 0.;
					pData[ 12 ] = 0.;

					pData[ 1 ] = 0.;
					pData[ 5 ] = v4fVec.y;
					pData[ 9 ] = 0.;
					pData[ 13 ] = 0.;

					pData[ 2 ] = 0.;
					pData[ 6 ] = 0.;
					pData[ 10 ] = v4fVec.z;
					pData[ 14 ] = 0.;

					pData[ 3 ] = 0.;
					pData[ 7 ] = 0.;
					pData[ 11 ] = 0.
					pData[ 15 ] = v4fVec.w;
				}
				else if(isDef(arguments[0].data)){
					var pMatrixData: Float32Array = arguments[0].data;
					if(pMatrixData.length == 16){
//Mat4
						pData.set(pMatrixData);
					}
					else{
//Mat3
						pData[ 0 ] = pMatrixData[ 0 ];
						pData[ 4 ] = pMatrixData[ 3 ];
						pData[ 8 ] = pMatrixData[ 6 ];

						pData[ 1 ] = pMatrixData[ 1 ];
						pData[ 5 ] = pMatrixData[ 4 ];
						pData[ 9 ] = pMatrixData[ 7 ];

						pData[ 2 ] = pMatrixData[ 2 ];
						pData[ 6 ] = pMatrixData[ 5 ];
						pData[ 10 ] = pMatrixData[ 8 ];

						pData[ 3 ] = 0.;
						pData[ 7 ] = 0.;
						pData[ 11 ] = 0.;
						pData[ 15 ] = 1.;
					}
				}
				else{
//array
					var pArray:  number [] = arguments[0];

					if(pArray.length === 4){
						pData[ 0 ] = pArray[0];
						pData[ 4 ] = 0.;
						pData[ 8 ] = 0.;
						pData[ 12 ] = 0.;

						pData[ 1 ] = 0.;
						pData[ 5 ] = pArray[1];
						pData[ 9 ] = 0.;
						pData[ 13 ] = 0.;

						pData[ 2 ] = 0.;
						pData[ 6 ] = 0.;
						pData[ 10 ] = pArray[2];
						pData[ 14 ] = 0.;

						pData[ 3 ] = 0.;
						pData[ 7 ] = 0.;
						pData[ 11 ] = 0.
						pData[ 15 ] = pArray[3];
					}
					else{
//length == 16

						pData[ 0 ] = pArray[ 0 ];
						pData[ 4 ] = pArray[ 4 ];
						pData[ 8 ] = pArray[ 8 ];
						pData[ 12 ] = pArray[ 12 ];

						pData[ 1 ] = pArray[ 1 ];
						pData[ 5 ] = pArray[ 5 ];
						pData[ 9 ] = pArray[ 9 ];
						pData[ 13 ] = pArray[ 13 ];

						pData[ 2 ] = pArray[ 2 ];
						pData[ 6 ] = pArray[ 6 ];
						pData[ 10 ] = pArray[ 10 ];
						pData[ 14 ] = pArray[ 14 ];

						pData[ 3 ] = pArray[ 3 ];
						pData[ 7 ] = pArray[ 7 ];
						pData[ 11 ] = pArray[ 11 ];
						pData[ 15 ] = pArray[ 15 ];
					}
				}
			}
			else if(nArgumentsLength == 2){
				var pMatrixData: Float32Array = arguments[0];
				var v3fTranslation : IVec3 = arguments[1];

				pData[ 0 ] = pMatrixData[ 0 ];
				pData[ 4 ] = pMatrixData[ 3 ];
				pData[ 8 ] = pMatrixData[ 6 ];
				pData[ 12 ] = v3fTranslation.x;

				pData[ 1 ] = pMatrixData[ 1 ];
				pData[ 5 ] = pMatrixData[ 4 ];
				pData[ 9 ] = pMatrixData[ 7 ];
				pData[ 13 ] = v3fTranslation.y;

				pData[ 2 ] = pMatrixData[ 2 ];
				pData[ 6 ] = pMatrixData[ 5 ];
				pData[ 10 ] = pMatrixData[ 8 ];
				pData[ 14 ] = v3fTranslation.z;

				pData[ 3 ] = 0.;
				pData[ 7 ] = 0.;
				pData[ 11 ] = 0.;
				pData[ 15 ] = 1.;

			}
			else if(nArgumentsLength == 4){
				if(isFloat(arguments[0])){

					pData[ 0 ] = arguments[0];
					pData[ 4 ] = 0;
					pData[ 8 ] = 0;
					pData[ 12 ] = 0;

					pData[ 1 ] = 0;
					pData[ 5 ] = arguments[1];
					pData[ 9 ] = 0;
					pData[ 13 ] = 0;

					pData[ 2 ] = 0;
					pData[ 6 ] = 0;
					pData[ 10 ] = arguments[2];
					pData[ 14 ] = 0;

					pData[ 3 ] = 0;
					pData[ 7 ] = 0;
					pData[ 11 ] = 0;
					pData[ 15 ] = arguments[3];
				}
				else if(arguments[0] instanceof Vec4){

					var v4fColumn1: IVec4 = arguments[0];
					var v4fColumn2: IVec4 = arguments[1];
					var v4fColumn3: IVec4 = arguments[2];
					var v4fColumn4: IVec4 = arguments[3];

					pData[ 0 ] = v4fColumn1.x;
					pData[ 4 ] = v4fColumn2.x;
					pData[ 8 ] = v4fColumn3.x;
					pData[ 12 ] = v4fColumn4.x;

					pData[ 1 ] = v4fColumn1.y;
					pData[ 5 ] = v4fColumn2.y;
					pData[ 9 ] = v4fColumn3.y;
					pData[ 13 ] = v4fColumn4.y;

					pData[ 2 ] = v4fColumn1.z;
					pData[ 6 ] = v4fColumn2.z;
					pData[ 10 ] = v4fColumn3.z;
					pData[ 14 ] = v4fColumn4.z;

					pData[ 3 ] = v4fColumn1.w;
					pData[ 7 ] = v4fColumn2.w;
					pData[ 11 ] = v4fColumn3.w;
					pData[ 15 ] = v4fColumn4.w;
				}
				else{
//arrays

					var v4fColumn1:  number [] = arguments[0];
					var v4fColumn2:  number [] = arguments[1];
					var v4fColumn3:  number [] = arguments[2];
					var v4fColumn4:  number [] = arguments[3];

					pData[ 0 ] = v4fColumn1[0];
					pData[ 4 ] = v4fColumn2[0];
					pData[ 8 ] = v4fColumn3[0];
					pData[ 12 ] = v4fColumn4[0];

					pData[ 1 ] = v4fColumn1[1];
					pData[ 5 ] = v4fColumn2[1];
					pData[ 9 ] = v4fColumn3[1];
					pData[ 13 ] = v4fColumn4[1];

					pData[ 2 ] = v4fColumn1[2];
					pData[ 6 ] = v4fColumn2[2];
					pData[ 10 ] = v4fColumn3[2];
					pData[ 14 ] = v4fColumn4[2];

					pData[ 3 ] = v4fColumn1[3];
					pData[ 7 ] = v4fColumn2[3];
					pData[ 11 ] = v4fColumn3[3];
					pData[ 15 ] = v4fColumn4[3];

				}
			}
			else{
//nArgumentsLength === 16

				pData[ 0 ] = arguments[ 0 ];
				pData[ 4 ] = arguments[ 4 ];
				pData[ 8 ] = arguments[ 8 ];
				pData[ 12 ] = arguments[ 12 ];

				pData[ 1 ] = arguments[ 1 ];
				pData[ 5 ] = arguments[ 5 ];
				pData[ 9 ] = arguments[ 9 ];
				pData[ 13 ] = arguments[ 13 ];

				pData[ 2 ] = arguments[ 2 ];
				pData[ 6 ] = arguments[ 6 ];
				pData[ 10 ] = arguments[ 10 ];
				pData[ 14 ] = arguments[ 14 ];

				pData[ 3 ] = arguments[ 3 ];
				pData[ 7 ] = arguments[ 7 ];
				pData[ 11 ] = arguments[ 11 ];
				pData[ 15 ] = arguments[ 15 ];
			}
			return this;
		};

		identity() : IMat4{
			var pData: Float32Array = this.data;

			pData[ 0 ] = 1.;
			pData[ 4 ] = 0.;
			pData[ 8 ] = 0.;
			pData[ 12 ] = 0.;

			pData[ 1 ] = 0.;
			pData[ 5 ] = 1.;
			pData[ 9 ] = 0.;
			pData[ 13 ] = 0.;

			pData[ 2 ] = 0.;
			pData[ 6 ] = 0.;
			pData[ 10 ] = 1.;
			pData[ 14 ] = 0.;

			pData[ 3 ] = 0.;
			pData[ 7 ] = 0.;
			pData[ 11 ] = 0.;
			pData[ 15 ] = 1.;

			return this;
		};

		add(m4fMat: IMat4, m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
				m4fDestination = this;
			}

			var pData1: Float32Array = this.data;
			var pData2: Float32Array = m4fMat.data;
			var pDataDestination: Float32Array = m4fDestination.data;

			pDataDestination[ 0 ] = pData1[ 0 ] + pData2[ 0 ];
			pDataDestination[ 4 ] = pData1[ 4 ] + pData2[ 4 ];
			pDataDestination[ 8 ] = pData1[ 8 ] + pData2[ 8 ];
			pDataDestination[ 12 ] = pData1[ 12 ] + pData2[ 12 ];

			pDataDestination[ 1 ] = pData1[ 1 ] + pData2[ 1 ];
			pDataDestination[ 5 ] = pData1[ 5 ] + pData2[ 5 ];
			pDataDestination[ 9 ] = pData1[ 9 ] + pData2[ 9 ];
			pDataDestination[ 13 ] = pData1[ 13 ] + pData2[ 13 ];

			pDataDestination[ 2 ] = pData1[ 2 ] + pData2[ 2 ];
			pDataDestination[ 6 ] = pData1[ 6 ] + pData2[ 6 ];
			pDataDestination[ 10 ] = pData1[ 10 ] + pData2[ 10 ];
			pDataDestination[ 14 ] = pData1[ 14 ] + pData2[ 14 ];

			pDataDestination[ 3 ] = pData1[ 3 ] + pData2[ 3 ];
			pDataDestination[ 7 ] = pData1[ 7 ] + pData2[ 7 ];
			pDataDestination[ 11 ] = pData1[ 11 ] + pData2[ 11 ];
			pDataDestination[ 15 ] = pData1[ 15 ] + pData2[ 15 ];

			return m4fDestination;
		};

		subtract(m4fMat: IMat4, m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
				m4fDestination = this;
			}

			var pData1: Float32Array = this.data;
			var pData2: Float32Array = m4fMat.data;
			var pDataDestination: Float32Array = m4fDestination.data;

			pDataDestination[ 0 ] = pData1[ 0 ] - pData2[ 0 ];
			pDataDestination[ 4 ] = pData1[ 4 ] - pData2[ 4 ];
			pDataDestination[ 8 ] = pData1[ 8 ] - pData2[ 8 ];
			pDataDestination[ 12 ] = pData1[ 12 ] - pData2[ 12 ];

			pDataDestination[ 1 ] = pData1[ 1 ] - pData2[ 1 ];
			pDataDestination[ 5 ] = pData1[ 5 ] - pData2[ 5 ];
			pDataDestination[ 9 ] = pData1[ 9 ] - pData2[ 9 ];
			pDataDestination[ 13 ] = pData1[ 13 ] - pData2[ 13 ];

			pDataDestination[ 2 ] = pData1[ 2 ] - pData2[ 2 ];
			pDataDestination[ 6 ] = pData1[ 6 ] - pData2[ 6 ];
			pDataDestination[ 10 ] = pData1[ 10 ] - pData2[ 10 ];
			pDataDestination[ 14 ] = pData1[ 14 ] - pData2[ 14 ];

			pDataDestination[ 3 ] = pData1[ 3 ] - pData2[ 3 ];
			pDataDestination[ 7 ] = pData1[ 7 ] - pData2[ 7 ];
			pDataDestination[ 11 ] = pData1[ 11 ] - pData2[ 11 ];
			pDataDestination[ 15 ] = pData1[ 15 ] - pData2[ 15 ];

			return m4fDestination;
		};

		multiply(m4fMat: IMat4, m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
	            m4fDestination = this;
	        }

			var pData1: Float32Array = this.data;
		    var pData2: Float32Array = m4fMat.data;
	        var pDataDestination: Float32Array = m4fDestination.data;

//кешируем значения матриц для ускорения

	        var a11:  number  = pData1[ 0 ], a12:  number  = pData1[ 4 ], a13:  number  = pData1[ 8 ], a14:  number  = pData1[ 12 ];
	        var a21:  number  = pData1[ 1 ], a22:  number  = pData1[ 5 ], a23:  number  = pData1[ 9 ], a24:  number  = pData1[ 13 ];
	        var a31:  number  = pData1[ 2 ], a32:  number  = pData1[ 6 ], a33:  number  = pData1[ 10 ], a34:  number  = pData1[ 14 ];
	        var a41:  number  = pData1[ 3 ], a42:  number  = pData1[ 7 ], a43:  number  = pData1[ 11 ], a44:  number  = pData1[ 15 ];

	        var b11:  number  = pData2[ 0 ], b12:  number  = pData2[ 4 ], b13:  number  = pData2[ 8 ], b14:  number  = pData2[ 12 ];
	        var b21:  number  = pData2[ 1 ], b22:  number  = pData2[ 5 ], b23:  number  = pData2[ 9 ], b24:  number  = pData2[ 13 ];
	        var b31:  number  = pData2[ 2 ], b32:  number  = pData2[ 6 ], b33:  number  = pData2[ 10 ], b34:  number  = pData2[ 14 ];
	        var b41:  number  = pData2[ 3 ], b42:  number  = pData2[ 7 ], b43:  number  = pData2[ 11 ], b44:  number  = pData2[ 15 ];

	        pDataDestination[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
	        pDataDestination[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
	        pDataDestination[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
	        pDataDestination[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

	        pDataDestination[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
	        pDataDestination[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
	        pDataDestination[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
	        pDataDestination[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

	        pDataDestination[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
	        pDataDestination[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
	        pDataDestination[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
	        pDataDestination[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

	        pDataDestination[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
	        pDataDestination[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
	        pDataDestination[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
	        pDataDestination[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		    return m4fDestination;
		};

		/**@inline*/  multiplyLeft(m4fMat: IMat4, m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
				m4fDestination = this;
			}
			return m4fMat.multiply(this,m4fDestination);
		};

		multiplyVec4(v4fVec: IVec4, v4fDestination?: IVec4): IVec4{
			if(!isDef(v4fDestination)){
				v4fDestination = new Vec4();
			}

			var pData: Float32Array = this.data;

			var x:  number  = v4fVec.x, y:  number  = v4fVec.y, z:  number  = v4fVec.z, w:  number  = v4fVec.w;

			v4fDestination.x = pData[ 0 ]*x + pData[ 4 ]*y + pData[ 8 ]*z + pData[ 12 ]*w;
	        v4fDestination.y = pData[ 1 ]*x + pData[ 5 ]*y + pData[ 9 ]*z + pData[ 13 ]*w;
	        v4fDestination.z = pData[ 2 ]*x + pData[ 6 ]*y + pData[ 10 ]*z + pData[ 14 ]*w;
	        v4fDestination.w = pData[ 3 ]*x + pData[ 7 ]*y + pData[ 11 ]*z + pData[ 15 ]*w;

	        return v4fDestination;
		};

		transpose(m4fDestination?: IMat4): IMat4{

			var pData = this.data;

		    if(!isDef(m4fDestination)){
		        var a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ], a14:  number  = pData[ 12 ];
		        var a23:  number  = pData[ 9 ], a24:  number  = pData[ 13 ];
		        var a34:  number  = pData[ 14 ];

		        pData[ 4 ] = pData[ 1 ];
		        pData[ 8 ] = pData[ 2 ];
		        pData[ 12 ] = pData[ 3 ];

		        pData[ 1 ] = a12;
		        pData[ 9 ] = pData[ 6 ];
		        pData[ 13 ] = pData[ 7 ];

		        pData[ 2 ] = a13;
		        pData[ 6 ] = a23;
		        pData[ 14 ] = pData[ 11 ];

		        pData[ 3 ] = a14;
		        pData[ 7 ] = a24;
		        pData[ 11 ] = a34;

		        return this;
		    }

		    var pDataDestination = m4fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ];
		    pDataDestination[ 4 ] = pData[ 1 ];
		    pDataDestination[ 8 ] = pData[ 2 ];
		    pDataDestination[ 12 ] = pData[ 3 ];

		    pDataDestination[ 1 ] = pData[ 4 ];
		    pDataDestination[ 5 ] = pData[ 5 ];
		    pDataDestination[ 9 ] = pData[ 6 ];
		    pDataDestination[ 13 ] = pData[ 7 ];

		    pDataDestination[ 2 ] = pData[ 8 ];
		    pDataDestination[ 6 ] = pData[ 9 ];
		    pDataDestination[ 10 ] = pData[ 10 ];
		    pDataDestination[ 14 ] = pData[ 11 ];

		    pDataDestination[ 3 ] = pData[ 12 ];
		    pDataDestination[ 7 ] = pData[ 13 ];
		    pDataDestination[ 11 ] = pData[ 14 ];
		    pDataDestination[ 15 ] = pData[ 15 ];

		    return m4fDestination;
		};

		determinant():  number {
			var pData = this.data;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ], a14:  number  = pData[ 12 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 5 ], a23:  number  = pData[ 9 ], a24:  number  = pData[ 13 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 6 ], a33:  number  = pData[ 10 ], a34:  number  = pData[ 14 ];
		    var a41:  number  = pData[ 3 ], a42:  number  = pData[ 7 ], a43:  number  = pData[ 11 ], a44:  number  = pData[ 15 ];

		    return  a41*a32*a23*a14 - a31*a42*a23*a14 - a41*a22*a33*a14 + a21*a42*a33*a14 +
			        a31*a22*a43*a14 - a21*a32*a43*a14 - a41*a32*a13*a24 + a31*a42*a13*a24 +
			        a41*a12*a33*a24 - a11*a42*a33*a24 - a31*a12*a43*a24 + a11*a32*a43*a24 +
			        a41*a22*a13*a34 - a21*a42*a13*a34 - a41*a12*a23*a34 + a11*a42*a23*a34 +
			        a21*a12*a43*a34 - a11*a22*a43*a34 - a31*a22*a13*a44 + a21*a32*a13*a44 +
			        a31*a12*a23*a44 - a11*a32*a23*a44 - a21*a12*a33*a44 + a11*a22*a33*a44;
		};

		inverse(m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
		        m4fDestination = this;
		    }

		    var pData: Float32Array = this.data;
		    var pDataDestination: Float32Array = m4fDestination.data;

// Cache the matrix values (makes for huge speed increases!)
		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ], a14:  number  = pData[ 12 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 5 ], a23:  number  = pData[ 9 ], a24:  number  = pData[ 13 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 6 ], a33:  number  = pData[ 10 ], a34:  number  = pData[ 14 ];
		    var a41:  number  = pData[ 3 ], a42:  number  = pData[ 7 ], a43:  number  = pData[ 11 ], a44:  number  = pData[ 15 ];

		    var b00:  number  = a11*a22 - a12*a21;
		    var b01:  number  = a11*a23 - a13*a21;
		    var b02:  number  = a11*a24 - a14*a21;
		    var b03:  number  = a12*a23 - a13*a22;
		    var b04:  number  = a12*a24 - a14*a22;
		    var b05:  number  = a13*a24 - a14*a23;
		    var b06:  number  = a31*a42 - a32*a41;
		    var b07:  number  = a31*a43 - a33*a41;
		    var b08:  number  = a31*a44 - a34*a41;
		    var b09:  number  = a32*a43 - a33*a42;
		    var b10:  number  = a32*a44 - a34*a42;
		    var b11:  number  = a33*a44 - a34*a43;

		    var fDeterminant:  number  = b00*b11 - b01*b10 + b02*b09 + b03*b08 - b04*b07 + b05*b06;

		    if(fDeterminant === 0.){
		        logger.setSourceLocation( "Mat4.ts" , 624 ); logger.assert(false,"обращение матрицы с нулевым детеминантом:\n" + this.toString());
                                            ;

//чтоб все не навернулось		        return m4fDestination.set(1.);
		    }

		    var fInverseDeterminant:  number  = 1/fDeterminant;

		    pDataDestination[ 0 ] = (a22 * b11 - a23 * b10 + a24 * b09) * fInverseDeterminant;
		    pDataDestination[ 4 ] = (-a12 * b11 + a13 * b10 - a14 * b09) * fInverseDeterminant;
		    pDataDestination[ 8 ] = (a42 * b05 - a43 * b04 + a44 * b03) * fInverseDeterminant;
		    pDataDestination[ 12 ] = (-a32 * b05 + a33 * b04 - a34 * b03) * fInverseDeterminant;

		    pDataDestination[ 1 ] = (-a21 * b11 + a23 * b08 - a24 * b07) * fInverseDeterminant;
		    pDataDestination[ 5 ] = (a11 * b11 - a13 * b08 + a14 * b07) * fInverseDeterminant;
		    pDataDestination[ 9 ] = (-a41 * b05 + a43 * b02 - a44 * b01) * fInverseDeterminant;
		    pDataDestination[ 13 ] = (a31 * b05 - a33 * b02 + a34 * b01) * fInverseDeterminant;

		    pDataDestination[ 2 ] = (a21 * b10 - a22 * b08 + a24 * b06) * fInverseDeterminant;
		    pDataDestination[ 6 ] = (-a11 * b10 + a12 * b08 - a14 * b06) * fInverseDeterminant;
		    pDataDestination[ 10 ] = (a41 * b04 - a42 * b02 + a44 * b00) * fInverseDeterminant;
		    pDataDestination[ 14 ] = (-a31 * b04 + a32 * b02 - a34 * b00) * fInverseDeterminant;

		    pDataDestination[ 3 ] = (-a21 * b09 + a22 * b07 - a23 * b06) * fInverseDeterminant;
		    pDataDestination[ 7 ] = (a11 * b09 - a12 * b07 + a13 * b06) * fInverseDeterminant;
		    pDataDestination[ 11 ] = (-a41 * b03 + a42 * b01 - a43 * b00) * fInverseDeterminant;
		    pDataDestination[ 15 ] = (a31 * b03 - a32 * b01 + a33 * b00) * fInverseDeterminant;

		    return m4fDestination;
		};

		/**@inline*/  trace():  number {
			var pData: Float32Array = this.data;
			return pData[ 0 ] + pData[ 5 ] + pData[ 10 ] + pData[ 15 ];
		};

		isEqual(m4fMat: IMat4, fEps:  number  = 0.): bool{
		    var pData1: Float32Array = this.data;
		    var pData2: Float32Array = m4fMat.data;

		    if(fEps === 0.){
		        if(    pData1[ 0 ] != pData2[ 0 ]
		            || pData1[ 4 ] != pData2[ 4 ]
		            || pData1[ 8 ] != pData2[ 8 ]
		            || pData1[ 12 ] != pData2[ 12 ]
		            || pData1[ 1 ] != pData2[ 1 ]
		            || pData1[ 5 ] != pData2[ 5 ]
		            || pData1[ 9 ] != pData2[ 9 ]
		            || pData1[ 13 ] != pData2[ 13 ]
		            || pData1[ 2 ] != pData2[ 2 ]
		            || pData1[ 6 ] != pData2[ 6 ]
		            || pData1[ 10 ] != pData2[ 10 ]
		            || pData1[ 14 ] != pData2[ 14 ]
		            || pData1[ 3 ] != pData2[ 3 ]
		            || pData1[ 7 ] != pData2[ 7 ]
		            || pData1[ 11 ] != pData2[ 11 ]
		            || pData1[ 15 ] != pData2[ 15 ]){

		            return false;
		        }
		    }
		    else{
		        if(    abs(pData1[ 0 ] - pData2[ 0 ]) > fEps
		            || abs(pData1[ 4 ] - pData2[ 4 ]) > fEps
		            || abs(pData1[ 8 ] - pData2[ 8 ]) > fEps
		            || abs(pData1[ 12 ] - pData2[ 12 ]) > fEps
		            || abs(pData1[ 1 ] - pData2[ 1 ]) > fEps
		            || abs(pData1[ 5 ] - pData2[ 5 ]) > fEps
		            || abs(pData1[ 9 ] - pData2[ 9 ]) > fEps
		            || abs(pData1[ 13 ] - pData2[ 13 ]) > fEps
		            || abs(pData1[ 2 ] - pData2[ 2 ]) > fEps
		            || abs(pData1[ 6 ] - pData2[ 6 ]) > fEps
		            || abs(pData1[ 10 ] - pData2[ 10 ]) > fEps
		            || abs(pData1[ 14 ] - pData2[ 14 ]) > fEps
		            || abs(pData1[ 3 ] - pData2[ 3 ]) > fEps
		            || abs(pData1[ 7 ] - pData2[ 7 ]) > fEps
		            || abs(pData1[ 11 ] - pData2[ 11 ]) > fEps
		            || abs(pData1[ 15 ] - pData2[ 15 ]) > fEps){

		            return false;
		        }
		    }
		    return true;
		};

		isDiagonal(fEps:  number  = 0.): bool{
			var pData: Float32Array = this.data;

		    if(fEps === 0.){
		        if(    pData[ 4 ] !== 0. || pData[ 8 ] !== 0. || pData[ 12 ] != 0.
		            || pData[ 1 ] !== 0. || pData[ 9 ] !== 0. || pData[ 13 ] != 0.
		            || pData[ 2 ] !== 0. || pData[ 6 ] !== 0. || pData[ 14 ] != 0.
		            || pData[ 3 ] !== 0. || pData[ 7 ] !== 0. || pData[ 11 ] != 0.){

		            return false;
		        }
		    }
		    else{
		        if(    abs(pData[ 4 ]) > fEps || abs(pData[ 8 ]) > fEps || abs(pData[ 12 ]) > fEps
		            || abs(pData[ 1 ]) > fEps || abs(pData[ 9 ]) > fEps || abs(pData[ 13 ]) > fEps
		            || abs(pData[ 2 ]) > fEps || abs(pData[ 6 ]) > fEps || abs(pData[ 14 ]) > fEps
		            || abs(pData[ 3 ]) > fEps || abs(pData[ 7 ]) > fEps || abs(pData[ 11 ]) > fEps){

		            return false;
		        }
		    }
		    return true;
		};

		toMat3(m3fDestination?: IMat3): IMat3{
			if(!isDef(m3fDestination)){
		        m3fDestination = new Mat3();
		    }

		    var pData: Float32Array = this.data;
		    var pDataDestination: Float32Array = m3fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ];
		    pDataDestination[ 3 ] = pData[ 4 ];
		    pDataDestination[ 6 ] = pData[ 8 ];

		    pDataDestination[ 1 ] = pData[ 1 ];
		    pDataDestination[ 4 ] = pData[ 5 ];
		    pDataDestination[ 7 ] = pData[ 9 ];

		    pDataDestination[ 2 ] = pData[ 2 ];
		    pDataDestination[ 5 ] = pData[ 6 ];
		    pDataDestination[ 8 ] = pData[ 10 ];

		    return m3fDestination;
		};

		toQuat4(q4fDestination?: IQuat4){
			if(!isDef(q4fDestination)){
				q4fDestination = new Quat4();
			}

			var pData: Float32Array = this.data;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 5 ], a23:  number  = pData[ 9 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 6 ], a33:  number  = pData[ 10 ];

/*x^2*/
		    var x2:  number  = ((a11 - a22 - a33) + 1.)/4.;
/*y^2*/
		    var y2:  number  = ((a22 - a11 - a33) + 1.)/4.;
/*z^2*/
		    var z2:  number  = ((a33 - a11 - a22) + 1.)/4.;
/*w^2*/
		    var w2:  number  = ((a11 + a22 + a33) + 1.)/4.;

		    var fMax:  number  = max(x2,max(y2,max(z2,w2)));

		    if(fMax == x2){
//максимальная компонента берется положительной
		        var x:  number  = sqrt(x2);

		        q4fDestination.x = x;
		        q4fDestination.y = (a21 + a12)/4./x;
		        q4fDestination.z = (a31 + a13)/4./x;
		        q4fDestination.w = (a32 - a23)/4./x;
		    }
		    else if(fMax == y2){
//максимальная компонента берется положительной
		        var y:  number  = sqrt(y2);

		        q4fDestination.x = (a21 + a12)/4./y;
		        q4fDestination.y = y;
		        q4fDestination.z = (a32 + a23)/4./y;
		        q4fDestination.w = (a13 - a31)/4./y;
		    }
		    else if(fMax == z2){
//максимальная компонента берется положительной
		        var z:  number  = sqrt(z2);

		        q4fDestination.x = (a31 + a13)/4./z;
		        q4fDestination.y = (a32 + a23)/4./z;
		        q4fDestination.z = z;
		        q4fDestination.w = (a21 - a12)/4./z;
		    }
		    else{
//максимальная компонента берется положительной
		        var w:  number  = sqrt(w2);

		        q4fDestination.x = (a32 - a23)/4./w;
		        q4fDestination.y = (a13 - a31)/4./w;
		        q4fDestination.z = (a21 - a12)/4./w;
		        q4fDestination.w = w;
		    }

		    return q4fDestination;
		};

		toRotationMatrix(m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4();
		    }

		    var pData: Float32Array = this.data;
		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ];
		    pDataDestination[ 4 ] = pData[ 4 ];
		    pDataDestination[ 8 ] = pData[ 8 ];
		    pDataDestination[ 12 ] = 0.;

		    pDataDestination[ 1 ] = pData[ 1 ];
		    pDataDestination[ 5 ] = pData[ 5 ];
		    pDataDestination[ 9 ] = pData[ 9 ];
		    pDataDestination[ 13 ] = 0.;

		    pDataDestination[ 2 ] = pData[ 2 ];
		    pDataDestination[ 6 ] = pData[ 6 ];
		    pDataDestination[ 10 ] = pData[ 10 ];
		    pDataDestination[ 14 ] = 0.;

		    pDataDestination[ 3 ] = 0.;
		    pDataDestination[ 7 ] = 0.;
		    pDataDestination[ 11 ] = 0.;
		    pDataDestination[ 15 ] = 1.;

		    return m4fDestination;
		};

		toString(): string{
			var pData: Float32Array = this.data;

		    return '['  + pData[ 0 ] + ", " + pData[ 4 ] + ', ' + pData[ 8 ] + ', ' + pData[ 12 ] + ',\n'
		                + pData[ 1 ] + ", " + pData[ 5 ] + ', ' + pData[ 9 ] + ', ' + pData[ 13 ] + ',\n'
		                + pData[ 2 ] + ", " + pData[ 6 ] + ', ' + pData[ 10 ] + ', ' + pData[ 14 ] + ',\n'
		                + pData[ 3 ] + ", " + pData[ 7 ] + ', ' + pData[ 11 ] + ', ' + pData[ 15 ]+ ']';
		};

		rotateRight(fAngle:  number , v3fAxis: IVec3, m4fDestination?: IMat4): IMat4{
			var pData: Float32Array = this.data;

		    var x:  number  = v3fAxis.x, y:  number  = v3fAxis.y, z:  number  = v3fAxis.z;
		    var fLength:  number  = Math.sqrt(x*x + y*y + z*z);

		    if(fLength === 0.){
		    	logger.setSourceLocation( "Mat4.ts" , 860 ); logger.assert(false,"попытка вращения вокруг оси нулевой длины. Угол " + fAngle + ". Ось " + v3fAxis.toString()); ;
		    	if(isDef(m4fDestination)){
		    		m4fDestination.set(this);
		    	}
		    	else{
		    		m4fDestination = this;
		    	}
		    	return m4fDestination;
		    }

		    var fInvLength:  number  = 1./fLength;

		    x*=fInvLength;
		    y*=fInvLength;
		    z*=fInvLength;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 5 ], a23:  number  = pData[ 9 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 6 ], a33:  number  = pData[ 10 ];

		    var fSin:  number  = sin(fAngle);
		    var fCos:  number  = cos(fAngle);
		    var fTmp:  number  = 1. - fCos;

//build Rotation matrix

		    var b11:  number  = fCos + fTmp*x*x, b12:  number  = fTmp*x*y - fSin*z, b13:  number  = fTmp*x*z + fSin*y;
		    var b21:  number  = fTmp*y*z + fSin*z, b22:  number  = fCos + fTmp*y*y, b23:  number  = fTmp*y*z - fSin*x;
		    var b31:  number  = fTmp*z*x - fSin*y, b32:  number  = fTmp*z*y + fSin*x, b33:  number  = fCos + fTmp*z*z;

		    if(!isDef(m4fDestination)){
		        pData[ 0 ] = a11*b11 + a12*b21 + a13*b31;
		        pData[ 4 ] = a11*b12 + a12*b22 + a13*b32;
		        pData[ 8 ] = a11*b13 + a12*b23 + a13*b33;

		        pData[ 1 ] = a21*b11 + a22*b21 + a23*b31;
		        pData[ 5 ] = a21*b12 + a22*b22 + a23*b32;
		        pData[ 9 ] = a21*b13 + a22*b23 + a23*b33;

		        pData[ 2 ] = a31*b11 + a32*b21 + a33*b31;
		        pData[ 6 ] = a31*b12 + a32*b22 + a33*b32;
		        pData[ 10 ] = a31*b13 + a32*b23 + a33*b33;

		        return this;
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = a11*b11 + a12*b21 + a13*b31;
		    pDataDestination[ 4 ] = a11*b12 + a12*b22 + a13*b32;
		    pDataDestination[ 8 ] = a11*b13 + a12*b23 + a13*b33;
		    pDataDestination[ 12 ] = pData[ 12 ];

		    pDataDestination[ 1 ] = a21*b11 + a22*b21 + a23*b31;
		    pDataDestination[ 5 ] = a21*b12 + a22*b22 + a23*b32;
		    pDataDestination[ 9 ] = a21*b13 + a22*b23 + a23*b33;
		    pDataDestination[ 13 ] = pData[ 13 ];

		    pDataDestination[ 2 ] = a31*b11 + a32*b21 + a33*b31;
		    pDataDestination[ 6 ] = a31*b12 + a32*b22 + a33*b32;
		    pDataDestination[ 10 ] = a31*b13 + a32*b23 + a33*b33;
		    pDataDestination[ 14 ] = pData[ 14 ];

		    pDataDestination[ 3 ] = pData[ 3 ];
		    pDataDestination[ 7 ] = pData[ 7 ];
		    pDataDestination[ 11 ] = pData[ 11 ];
		    pDataDestination[ 15 ] = pData[ 15 ];

		    return m4fDestination;
		};

		rotateLeft(fAngle:  number , v3fAxis: IVec3, m4fDestination?: IMat4): IMat4{
			var pData: Float32Array = this.data;

		    var x:  number  = v3fAxis.x, y:  number  = v3fAxis.y, z:  number  = v3fAxis.z;
		    var fLength:  number  = Math.sqrt(x*x + y*y + z*z);

		    if(fLength === 0.){
		    	logger.setSourceLocation( "Mat4.ts" , 938 ); logger.assert(false,"попытка вращения вокруг оси нулевой длины. Угол " + fAngle + ". Ось " + v3fAxis.toString()); ;
		    	if(isDef(m4fDestination)){
		    		m4fDestination.set(this);
		    	}
		    	else{
		    		m4fDestination = this;
		    	}
		    	return m4fDestination;
		    }

		    var fInvLength:  number  = 1./fLength;

		    x*=fInvLength;
		    y*=fInvLength;
		    z*=fInvLength;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ], a14:  number  = pData[ 12 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 5 ], a23:  number  = pData[ 9 ], a24:  number  = pData[ 13 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 6 ], a33:  number  = pData[ 10 ], a34:  number  = pData[ 14 ];

		    var fSin:  number  = sin(fAngle);
		    var fCos:  number  = cos(fAngle);
		    var fTmp:  number  = 1. - fCos;

//build Rotation matrix

		    var b11:  number  = fCos + fTmp*x*x, b12:  number  = fTmp*x*y - fSin*z, b13:  number  = fTmp*x*z + fSin*y;
		    var b21:  number  = fTmp*y*z + fSin*z, b22:  number  = fCos + fTmp*y*y, b23:  number  = fTmp*y*z - fSin*x;
		    var b31:  number  = fTmp*z*x - fSin*y, b32:  number  = fTmp*z*y + fSin*x, b33:  number  = fCos + fTmp*z*z;

		    if(!isDef(m4fDestination)){
		        pData[ 0 ] = b11*a11 + b12*a21 + b13*a31;
		        pData[ 4 ] = b11*a12 + b12*a22 + b13*a32;
		        pData[ 8 ] = b11*a13 + b12*a23 + b13*a33;
		        pData[ 12 ] = b11*a14 + b12*a24 + b13*a34;

		        pData[ 1 ] = b21*a11 + b22*a21 + b23*a31;
		        pData[ 5 ] = b21*a12 + b22*a22 + b23*a32;
		        pData[ 9 ] = b21*a13 + b22*a23 + b23*a33;
		        pData[ 13 ] = b21*a14 + b22*a24 + b23*a34;

		        pData[ 2 ] = b31*a11 + b32*a21 + b33*a31;
		        pData[ 6 ] = b31*a12 + b32*a22 + b33*a32;
		        pData[ 10 ] = b31*a13 + b32*a23 + b33*a33;
		        pData[ 14 ] = b31*a14 + b32*a24 + b33*a34;

		        return this;
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = b11*a11 + b12*a21 + b13*a31;
		    pDataDestination[ 4 ] = b11*a12 + b12*a22 + b13*a32;
		    pDataDestination[ 8 ] = b11*a13 + b12*a23 + b13*a33;
		    pDataDestination[ 12 ] = b11*a14 + b12*a24 + b13*a34;

		    pDataDestination[ 1 ] = b21*a11 + b22*a21 + b23*a31;
		    pDataDestination[ 5 ] = b21*a12 + b22*a22 + b23*a32;
		    pDataDestination[ 9 ] = b21*a13 + b22*a23 + b23*a33;
		    pDataDestination[ 13 ] = b21*a14 + b22*a24 + b23*a34;

		    pDataDestination[ 2 ] = b31*a11 + b32*a21 + b33*a31;
		    pDataDestination[ 6 ] = b31*a12 + b32*a22 + b33*a32;
		    pDataDestination[ 10 ] = b31*a13 + b32*a23 + b33*a33;
		    pDataDestination[ 14 ] = b31*a14 + b32*a24 + b33*a34;

		    pDataDestination[ 3 ] = pData[ 3 ];
		    pDataDestination[ 7 ] = pData[ 7 ];
		    pDataDestination[ 11 ] = pData[ 11 ];
		    pDataDestination[ 15 ] = pData[ 15 ];

		    return m4fDestination;
		};

		/**@inline*/  setTranslation(v3fTranslation: IVec3): IMat4{
			var pData: Float32Array = this.data;

			pData[ 12 ] = v3fTranslation.x;
			pData[ 13 ] = v3fTranslation.y;
			pData[ 14 ] = v3fTranslation.z;

			return this;
		};

		/**@inline*/  getTranslation(v3fTranslation?: IVec3): IVec3{
			if(!isDef(v3fTranslation)){
				v3fTranslation = new Vec3();
			}

			var pData: Float32Array = this.data;

			v3fTranslation.x = pData[ 12 ];
			v3fTranslation.y = pData[ 13 ];
			v3fTranslation.z = pData[ 14 ];

			return v3fTranslation;
		};

		translateRight(v3fTranslation: IVec3, m4fDestination?: IMat4): IMat4{
			var pData: Float32Array = this.data;

		    var x:  number  = v3fTranslation.x, y:  number  = v3fTranslation.y, z:  number  = v3fTranslation.z;

		    if(!isDef(m4fDestination)){
		        pData[ 12 ] = pData[ 0 ]*x + pData[ 4 ]*y + pData[ 8 ]*z + pData[ 12 ];
		        pData[ 13 ] = pData[ 1 ]*x + pData[ 5 ]*y + pData[ 9 ]*z + pData[ 13 ];
		        pData[ 14 ] = pData[ 2 ]*x + pData[ 6 ]*y + pData[ 10 ]*z + pData[ 14 ];
		        pData[ 15 ] = pData[ 3 ]*x + pData[ 7 ]*y + pData[ 11 ]*z + pData[ 15 ];
//строго говоря последнюю строчку умножать не обязательно, так как она должна быть -> 0 0 0 1
		        return this;
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

//кешируем матрицу вращений
		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ];
		    var a21:  number  = pData[ 0 ], a22:  number  = pData[ 5 ], a23:  number  = pData[ 9 ];
		    var a31:  number  = pData[ 0 ], a32:  number  = pData[ 6 ], a33:  number  = pData[ 10 ];
		    var a41:  number  = pData[ 0 ], a42:  number  = pData[ 7 ], a43:  number  = pData[ 11 ];

		    pDataDestination[ 0 ] = a11;
		    pDataDestination[ 4 ] = a12;
		    pDataDestination[ 8 ] = a13;
		    pDataDestination[ 12 ] = a11*x + a12*y + a13*z + pData[ 12 ];

		    pDataDestination[ 1 ] = a21;
		    pDataDestination[ 5 ] = a22;
		    pDataDestination[ 9 ] = a23;
		    pDataDestination[ 13 ] = a21*x + a22*y + a23*z + pData[ 13 ];

		    pDataDestination[ 2 ] = a31;
		    pDataDestination[ 6 ] = a32;
		    pDataDestination[ 10 ] = a33;
		    pDataDestination[ 14 ] = a31*x + a32*y + a33*z + pData[ 14 ];

		    pDataDestination[ 3 ] = a41;
		    pDataDestination[ 7 ] = a42;
		    pDataDestination[ 11 ] = a43;
		    pDataDestination[ 15 ] = a41*x + a42*y + a43*z + pData[ 15 ];

		    return m4fDestination;
		};

		translateLeft(v3fTranslation: IVec3, m4fDestination?: IMat4): IMat4{
			var pData: Float32Array = this.data;

		    var x:  number  = v3fTranslation.x, y:  number  = v3fTranslation.y, z:  number  = v3fTranslation.z;

		    if(!isDef(m4fDestination)){
		        pData[ 12 ] = x + pData[ 12 ];
		        pData[ 13 ] = y + pData[ 13 ];
		        pData[ 14 ] = z + pData[ 14 ];
		        return this;
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ];
		    pDataDestination[ 4 ] = pData[ 4 ];
		    pDataDestination[ 8 ] = pData[ 8 ];
		    pDataDestination[ 12 ] = x + pData[ 12 ];

		    pDataDestination[ 1 ] = pData[ 1 ];
		    pDataDestination[ 5 ] = pData[ 5 ];
		    pDataDestination[ 9 ] = pData[ 9 ];
		    pDataDestination[ 13 ] = y + pData[ 13 ];

		    pDataDestination[ 2 ] = pData[ 2 ];
		    pDataDestination[ 6 ] = pData[ 6 ];
		    pDataDestination[ 10 ] = pData[ 10 ];
		    pDataDestination[ 14 ] = z + pData[ 14 ];

		    pDataDestination[ 3 ] = pData[ 3 ];
		    pDataDestination[ 7 ] = pData[ 7 ];
		    pDataDestination[ 11 ] = pData[ 11 ];
		    pDataDestination[ 15 ] = pData[ 15 ];

		    return m4fDestination;
		};

		scaleRight(v3fScale: IVec3, m4fDestination?: IMat4): IMat4{
			var pData: Float32Array = this.data;

		    var x:  number  = v3fScale.x, y:  number  = v3fScale.y, z:  number  = v3fScale.z;

		    if(!isDef(m4fDestination)){
		        pData[ 0 ] *= x;
		        pData[ 4 ] *= y;
		        pData[ 8 ] *= z;

		        pData[ 1 ] *= x;
		        pData[ 5 ] *= y;
		        pData[ 9 ] *= z;

		        pData[ 2 ] *= x;
		        pData[ 6 ] *= y;
		        pData[ 10 ] *= z;

//скейлить эти компоненты необязательно, так как там должны лежать нули
		        pData[ 3 ] *= x;
		        pData[ 7 ] *= y;
		        pData[ 11 ] *= z;

		        return this;
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ]*x;
		    pDataDestination[ 4 ] = pData[ 4 ]*y;
		    pDataDestination[ 8 ] = pData[ 8 ]*z;
		    pDataDestination[ 12 ] = pData[ 12 ];

		    pDataDestination[ 1 ] = pData[ 1 ]*x;
		    pDataDestination[ 5 ] = pData[ 5 ]*y;
		    pDataDestination[ 9 ] = pData[ 9 ]*z;
		    pDataDestination[ 13 ] = pData[ 13 ];

		    pDataDestination[ 2 ] = pData[ 2 ]*x;
		    pDataDestination[ 6 ] = pData[ 6 ]*y;
		    pDataDestination[ 10 ] = pData[ 10 ]*z;
		    pDataDestination[ 14 ] = pData[ 14 ];

//скейлить эти компоненты необязательно, так как там должны лежать нули
		    pDataDestination[ 3 ] = pData[ 3 ]*x;
		    pDataDestination[ 7 ] = pData[ 7 ]*y;
		    pDataDestination[ 11 ] = pData[ 11 ]*z;
		    pDataDestination[ 15 ] = pData[ 15 ];

		    return m4fDestination;
		};

		scaleLeft(v3fScale: IVec3, m4fDestination?: IMat4): IMat4{
			var pData: Float32Array = this.data;

		    var x:  number  = v3fScale.x, y:  number  = v3fScale.y, z:  number  = v3fScale.z;

		    if(!isDef(m4fDestination)){
		        pData[ 0 ] *= x;
		        pData[ 4 ] *= x;
		        pData[ 8 ] *= x;
		        pData[ 12 ] *= x;

		        pData[ 1 ] *= y;
		        pData[ 5 ] *= y;
		        pData[ 9 ] *= y;
		        pData[ 13 ] *= y;

		        pData[ 2 ] *= z;
		        pData[ 6 ] *= z;
		        pData[ 10 ] *= z;
		        pData[ 14 ] *= z;

		        return this;
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ]*x;
		    pDataDestination[ 4 ] = pData[ 4 ]*x;
		    pDataDestination[ 8 ] = pData[ 8 ]*x;
		    pDataDestination[ 12 ] = pData[ 12 ]*x;

		    pDataDestination[ 1 ] = pData[ 1 ]*y;
		    pDataDestination[ 5 ] = pData[ 5 ]*y;
		    pDataDestination[ 9 ] = pData[ 9 ]*y;
		    pDataDestination[ 13 ] = pData[ 13 ]*y;

		    pDataDestination[ 2 ] = pData[ 2 ]*z;
		    pDataDestination[ 6 ] = pData[ 6 ]*z;
		    pDataDestination[ 10 ] = pData[ 10 ]*z;
		    pDataDestination[ 14 ] = pData[ 14 ]*z;

		    pDataDestination[ 3 ] = pData[ 3 ];
		    pDataDestination[ 7 ] = pData[ 7 ];
		    pDataDestination[ 11 ] = pData[ 11 ];
		    pDataDestination[ 15 ] = pData[ 15 ];

		    return m4fDestination;
		};

		/**@inline*/  decompose(q4fRotation: IQuat4, v3fScale: IVec3, v3fTranslation: IVec3): bool{
			this.getTranslation(v3fTranslation);
			var m3fRotScale = this.toMat3(mat3());
			return m3fRotScale.decompose(q4fRotation,v3fScale);
		};

		row(iRow:  number , v4fDestination?: IVec4): IVec4{
			if(!isDef(v4fDestination)){
				v4fDestination = new Vec4();
			}

			var pData: Float32Array = this.data;

			switch(iRow){
				case 1:
					v4fDestination.x = pData[ 0 ];
					v4fDestination.y = pData[ 4 ];
					v4fDestination.z = pData[ 8 ];
					v4fDestination.w = pData[ 12 ];
					break;
				case 2:
					v4fDestination.x = pData[ 1 ];
					v4fDestination.y = pData[ 5 ];
					v4fDestination.z = pData[ 9 ];
					v4fDestination.w = pData[ 13 ];
					break;
				case 3:
					v4fDestination.x = pData[ 2 ];
					v4fDestination.y = pData[ 6 ];
					v4fDestination.z = pData[ 10 ];
					v4fDestination.w = pData[ 14 ];
					break;
				case 4:
					v4fDestination.x = pData[ 3 ];
					v4fDestination.y = pData[ 7 ];
					v4fDestination.z = pData[ 11 ];
					v4fDestination.w = pData[ 15 ];
					break;
			}

			return v4fDestination;
		};

		column(iColumn:  number , v4fDestination?: IVec4): IVec4{
			if(!isDef(v4fDestination)){
				v4fDestination = new Vec4();
			}

			var pData: Float32Array = this.data;

			switch(iColumn){
				case 1:
					v4fDestination.x = pData[ 0 ];
					v4fDestination.y = pData[ 1 ];
					v4fDestination.z = pData[ 2 ];
					v4fDestination.w = pData[ 3 ];
					break;
				case 2:
					v4fDestination.x = pData[ 4 ];
					v4fDestination.y = pData[ 5 ];
					v4fDestination.z = pData[ 6 ];
					v4fDestination.w = pData[ 7 ];
					break;
				case 3:
					v4fDestination.x = pData[ 8 ];
					v4fDestination.y = pData[ 9 ];
					v4fDestination.z = pData[ 10 ];
					v4fDestination.w = pData[ 11 ];
					break;
				case 4:
					v4fDestination.x = pData[ 12 ];
					v4fDestination.y = pData[ 13 ];
					v4fDestination.z = pData[ 14 ];
					v4fDestination.w = pData[ 15 ];
					break;
			}

			return v4fDestination;
		};

		unproj(v3fScreen: IVec3, v4fDestination?: IVec4): IVec4;
		unproj(v4fScreen: IVec4, v4fDestination?: IVec4): IVec4;
		unproj(v: any, v4fDestination?: IVec4): IVec4 {
			if(!isDef(v4fDestination)){
				v4fDestination = new Vec4();
			}

			var pData: Float32Array = this.data;
			var v3fScreen: IVec3 = <IVec3>v;
			var x:  number , y:  number , z:  number ;

			if(pData[ 15 ] === 1.){
//orthogonal projection case

				z = (v3fScreen.z - pData[ 14 ])/pData[ 10 ];
				y = (v3fScreen.y - pData[ 13 ])/pData[ 5 ];
				x = (v3fScreen.x - pData[ 12 ])/pData[ 0 ];
			}
			else{
//pData[__43] === -1
//frustum case

				z = -pData[ 14 ]/(pData[ 10 ] + v3fScreen.z);
			    y = -(v3fScreen.y + pData[ 9 ])*z/pData[ 5 ];
			    x = -(v3fScreen.x + pData[ 8 ])*z/pData[ 0 ];
			}

			v4fDestination.x = x;
			v4fDestination.y = y;
			v4fDestination.z = z;
			v4fDestination.w = 1.;

			return v4fDestination;
		};

		static fromYawPitchRoll(fYaw:  number , fPitch:  number , fRoll:  number , m4fDestination?: IMat4): IMat4;
		static fromYawPitchRoll(v3fAngles: IVec3, m4fDestination?: IMat4): IMat4;
		static fromYawPitchRoll(fYaw?,fPitch?,fRoll?,m4fDestination?): IMat4{
			if(arguments.length <= 2){
//Vec3 + m4fDestination
		        var v3fVec: IVec3 = arguments[0];

		        fYaw   = v3fVec.x;
		        fPitch = v3fVec.y;
		        fRoll  = v3fVec.z;

		        m4fDestination = arguments[1];
		    }

		    if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4();
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    var fSin1:  number  = Math.sin(fYaw);
		    var fSin2:  number  = Math.sin(fPitch);
		    var fSin3:  number  = Math.sin(fRoll);

		    var fCos1:  number  = Math.cos(fYaw);
		    var fCos2:  number  = Math.cos(fPitch);
		    var fCos3:  number  = Math.cos(fRoll);

		    pDataDestination[ 0 ] = fCos1 * fCos3 + fSin1 * fSin2 * fSin3;
		    pDataDestination[ 4 ] = fCos3 * fSin1 * fSin2 - fCos1 * fSin3;
		    pDataDestination[ 8 ] = fCos2 * fSin1;
		    pDataDestination[ 12 ] = 0.;

		    pDataDestination[ 1 ] = fCos2 * fSin3;
		    pDataDestination[ 5 ] = fCos2 * fCos3;
		    pDataDestination[ 9 ] = -fSin2;
		    pDataDestination[ 13 ] = 0.;

		    pDataDestination[ 2 ] = fCos1 * fSin2 * fSin3 - fCos3 * fSin1;
		    pDataDestination[ 6 ] = fSin1 * fSin3 + fCos1 * fCos3 * fSin2;
		    pDataDestination[ 10 ] = fCos1 * fCos2;
		    pDataDestination[ 14 ] = 0.;

		    pDataDestination[ 3 ] = 0.;
		    pDataDestination[ 7 ] = 0.;
		    pDataDestination[ 11 ] = 0.;
		    pDataDestination[ 15 ] = 1.;

		    return m4fDestination;
		};

		static fromXYZ(fX:  number , fY:  number , fZ:  number , m4fDestination?: IMat4): IMat4;
		static fromXYZ(v3fAngles: IVec3, m4fDestination?: IMat4): IMat4;
		static fromXYZ(fX?, fY?, fZ?, m4fDestination?) : IMat4{
			if(arguments.length <= 2){
//Vec3 + m4fDestination
				var v3fVec: IVec3 = arguments[0];
				return Mat4.fromYawPitchRoll(v3fVec.y,v3fVec.x,v3fVec.z,arguments[1]);
			}
			else{
//fX fY fZ m4fDestination
				var fX:  number  = arguments[0];
				var fY:  number  = arguments[1];
				var fZ:  number  = arguments[2];

				return Mat4.fromYawPitchRoll(fY, fX, fZ, arguments[3]);
			}
		};

		static frustum(fLeft:  number , fRight:  number , fBottom:  number , fTop:  number , fNear:  number , fFar:  number , m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4();
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    var fRL:  number  = fRight - fLeft;
		    var fTB:  number  = fTop - fBottom;
		    var fFN:  number  = fFar - fNear;

		    pDataDestination[ 0 ] = 2.*fNear/fRL;
		    pDataDestination[ 4 ] = 0.;
		    pDataDestination[ 8 ] = (fRight + fLeft)/fRL;
		    pDataDestination[ 12 ] = 0.;

		    pDataDestination[ 1 ] = 0.;
		    pDataDestination[ 5 ] = 2.*fNear/fTB;
		    pDataDestination[ 9 ] = (fTop + fBottom)/fTB;
		    pDataDestination[ 13 ] = 0.;

		    pDataDestination[ 2 ] = 0.;
		    pDataDestination[ 6 ] = 0.;
		    pDataDestination[ 10 ] = -(fFar + fNear)/fFN;
		    pDataDestination[ 14 ] = -2.*fFar*fNear/fFN;

		    pDataDestination[ 3 ] = 0.;
		    pDataDestination[ 7 ] = 0.;
		    pDataDestination[ 11 ] = -1.;
		    pDataDestination[ 15 ] = 0.;

		    return m4fDestination;
		};

		/**@inline*/  static perspective(fFovy:  number , fAspect:  number , fNear:  number , fFar:  number , m4fDestination?: IMat4): IMat4{
			var fTop:  number  = fNear*tan(fFovy/2.);
			var fRight:  number  = fTop*fAspect;

			return Mat4.frustum(-fRight, fRight, -fTop, fTop, fNear, fFar, m4fDestination);
		};

		static orthogonalProjectionAsymmetric(fLeft:  number , fRight:  number , fBottom:  number ,
												 fTop:  number , fNear:  number , fFar:  number , m4fDestination?: IMat4): IMat4{

			 if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4();
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    var fRL:  number  = fRight - fLeft;
		    var fTB:  number  = fTop - fBottom;
		    var fFN:  number  = fFar - fNear;

		    pDataDestination[ 0 ] = 2./fRL;
		    pDataDestination[ 4 ] = 0.;
		    pDataDestination[ 8 ] = 0.;
		    pDataDestination[ 12 ] = -(fRight + fLeft)/fRL;

		    pDataDestination[ 1 ] = 0.;
		    pDataDestination[ 5 ] = 2./fTB;
		    pDataDestination[ 9 ] = 0.;
		    pDataDestination[ 13 ] = -(fTop + fBottom)/fTB;

		    pDataDestination[ 2 ] = 0.;
		    pDataDestination[ 6 ] = 0.;
		    pDataDestination[ 10 ] = -2./fFN;
		    pDataDestination[ 14 ] = -(fFar + fNear)/fFN;

		    pDataDestination[ 3 ] = 0.;
		    pDataDestination[ 7 ] = 0.;
		    pDataDestination[ 11 ] = 0.;
		    pDataDestination[ 15 ] = 1.;

		    return m4fDestination;
		};

		/**@inline*/  static orthogonalProjection(fWidth:  number , fHeight:  number , fNear:  number , fFar:  number , m4fDestination?: IMat4): IMat4{
			var fRight:  number  = fWidth/2.;
		    var fTop:  number  = fHeight/2.;
		    return Mat4.orthogonalProjectionAsymmetric(-fRight, fRight, -fTop, fTop, fNear, fFar, m4fDestination);
		};

		static lookAt(v3fEye: IVec3, v3fCenter: IVec3, v3fUp: IVec3, m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4(1.);
		    }

		    var fEyeX:  number  = v3fEye.x, fEyeY:  number  = v3fEye.y, fEyeZ:  number  = v3fEye.z;
		    var fCenterX:  number  = v3fCenter.x, fCenterY:  number  = v3fCenter.y, fCenterZ:  number  = v3fCenter.z;
		    var fUpX:  number  = v3fUp.x, fUpY:  number  = v3fUp.y, fUpZ:  number  = v3fUp.z;

		    var fLength:  number ;
		    var fInvLength:  number ;

		    if(fEyeX === fCenterX && fEyeY === fCenterY && fEyeZ === fCenterZ){
		        return m4fDestination;
		    }

		    var fXNewX:  number , fXNewY:  number , fXNewZ:  number ;
		    var fYNewX:  number , fYNewY:  number , fYNewZ:  number ;
		    var fZNewX:  number , fZNewY:  number , fZNewZ:  number ;

//ось Z направлена на наблюдателя
		    fZNewX = fEyeX - fCenterX;
		    fZNewY = fEyeY - fCenterY;
		    fZNewZ = fEyeZ - fCenterZ;

		    fLength = sqrt(fZNewX*fZNewX + fZNewY*fZNewY + fZNewZ*fZNewZ);
		    fInvLength = 1./fLength;

//новая ось Z
		    fZNewX = fZNewX*fInvLength;
		    fZNewY = fZNewY*fInvLength;
		    fZNewZ = fZNewZ*fInvLength;

//новая ось X
		    fXNewX = fUpY*fZNewZ - fUpZ*fZNewY;
		    fXNewY = fUpZ*fZNewX - fUpX*fZNewZ;
		    fXNewZ = fUpX*fZNewY - fUpY*fZNewX;

		    fLength = sqrt(fXNewX*fXNewX + fXNewY*fXNewY + fXNewZ*fXNewZ);
		    if(fLength){
		    	fInvLength = 1./fLength;

		        fXNewX = fXNewX*fInvLength;
		        fXNewY = fXNewY*fInvLength;
		        fXNewZ = fXNewZ*fInvLength;
		    }

//новая ось Y

		    fYNewX = fZNewY*fXNewZ - fZNewZ*fXNewY;
		    fYNewY = fZNewZ*fXNewX - fZNewX*fXNewZ;
		    fYNewZ = fZNewX*fXNewY - fZNewY*fXNewX;

//но��мировать ненужно, так как было векторное умножение двух ортонормированных векторов

//положение камеры в новых осях
		    var fEyeNewX:  number  = fEyeX*fXNewX + fEyeY*fXNewY + fEyeZ*fXNewZ;
		    var fEyeNewY:  number  = fEyeX*fYNewX + fEyeY*fYNewY + fEyeZ*fYNewZ;
		    var fEyeNewZ:  number  = fEyeX*fZNewX + fEyeY*fZNewY + fEyeZ*fZNewZ;

		    var pDataDestination: Float32Array = m4fDestination.data;

//lookAt matrix === camera view matrix 
//почему новый базис записывается по строкам?
//это сзязано с тем, что это получающаяся матрица - 
//это viewMatrix камеры, а на эту матрицу умножается при рендеринге, то есть
//модель должна испытать преобразования противоположные тем, которые испытывает камера
//то есть вращение в другую сторону(базис по строкам) и сдвиг в противоположную сторону

		    pDataDestination[ 0 ] = fXNewX;
		    pDataDestination[ 4 ] = fXNewY;
		    pDataDestination[ 8 ] = fXNewZ;
/*отъезжаем в позицию камеры*/
		    pDataDestination[ 12 ] = -fEyeNewX;

		    pDataDestination[ 1 ] = fYNewX;
		    pDataDestination[ 5 ] = fYNewY;
		    pDataDestination[ 9 ] = fYNewZ;
/*отъезжаем в позицию камеры*/
		    pDataDestination[ 13 ] = -fEyeNewY;

		    pDataDestination[ 2 ] = fZNewX;
		    pDataDestination[ 6 ] = fZNewY;
		    pDataDestination[ 10 ] = fZNewZ;
/*отъезжаем в позицию камеры*/
		    pDataDestination[ 14 ] = -fEyeNewZ;

		    pDataDestination[ 3 ] = 0.;
		    pDataDestination[ 7 ] = 0.;
		    pDataDestination[ 11 ] = 0.;
		    pDataDestination[ 15 ] = 1.;

		    return m4fDestination;
		};

		static get stackCeil(): Mat4 { Mat4.stackPosition = Mat4.stackPosition === Mat4.stackSize - 1? 0: Mat4.stackPosition; return Mat4.stack[Mat4.stackPosition ++]; } static stackSize: number = 100; static stackPosition: number = 0; static stack: Mat4[] = (function(): Mat4[]{ var pStack: Mat4[] = new Array(Mat4.stackSize); for(var i: number = 0; i<Mat4.stackSize; i++){ pStack[i] = new Mat4(); } return pStack})();
    }
}

















module akra.math {
    export class Quat4 implements IQuat4{
    	x:  number ;
    	y:  number ;
    	z:  number ;
    	w:  number ;

    	constructor();
    	constructor(q4fQuat: IQuat4);
    	constructor(pArray:  number []);
    	constructor(fValue:  number , fW:  number );
    	constructor(v3fValue: IVec3, fW:  number );
    	constructor(fX:  number , fY:  number , fZ:  number , fW:  number );
    	constructor(fX?, fY?, fZ?, fW?){
    		var nArgumentsLength:  number  = arguments.length;

    		switch(nArgumentsLength){
    			case 1:
    				this.set(arguments[0]);
    				break;
				case 2:
					this.set(arguments[0], arguments[1]);
					break;
				case 4:
					this.set(arguments[0], arguments[1], arguments[2], arguments[3]);
					break;
				default:
					this.x = this.y = this.z = 0.;
					this.w = 1.;
					break;
    		}
    	};

    	set(): IQuat4;
		set(q4fQuat: IQuat4): IQuat4;
		set(pArray:  number []): IQuat4;
		set(fValue:  number , fW:  number ): IQuat4;
		set(v3fValue: IVec3, fW:  number ): IQuat4;
		set(fX:  number , fY:  number , fZ:  number , fW:  number ): IQuat4;
		set(fX?, fY?, fZ?, fW?): IQuat4{
			var nArgumentsLength:  number  = arguments.length;

		    if(nArgumentsLength === 0){
		        this.x = this.y = this.z = 0.;
		        this.w = 1.;
		    }
		    if(nArgumentsLength === 1){
		        if(arguments[0] instanceof Quat4){
		        	var q4fQuat: IQuat4 = arguments[0];

		            this.x = q4fQuat.x;
		            this.y = q4fQuat.y;
		            this.z = q4fQuat.z;
		            this.w = q4fQuat.w;
		        }
		        else{
//Array
		            var pElements:  number [] = arguments[0];

		            this.x = pElements[0];
		            this.y = pElements[1];
		            this.z = pElements[2];
		            this.w = pElements[3];
		        }
		    }
		    else if(nArgumentsLength === 2){
//float float
//vec3 float
		        if(isFloat(arguments[0])){
//float float
		            var fValue:  number  = arguments[0];

		            this.x = fValue;
		            this.y = fValue;
		            this.z = fValue;
		            this.w = arguments[1];
		        }
		        else{
//vec3 float
		            var v3fValue: IVec3 = arguments[0];

		            this.x = v3fValue.x;
		            this.y = v3fValue.y;
		            this.z = v3fValue.z;
		            this.w = arguments[1];
		        }
		    }
		    else if(nArgumentsLength === 4){
		        this.x = arguments[0];
		        this.y = arguments[1];
		        this.z = arguments[2];
		        this.w = arguments[3];
		    }

		    return this;
		};

		multiply(q4fQuat: IQuat4, q4fDestination?: IQuat4): IQuat4{
			if(!isDef(q4fDestination)){
		        q4fDestination = this;
		    }

		    var x1:  number  = this.x, y1:  number  = this.y, z1:  number  = this.z, w1:  number  = this.w;
		    var x2:  number  = q4fQuat.x, y2:  number  = q4fQuat.y, z2:  number  = q4fQuat.z, w2:  number  = q4fQuat.w;

		    q4fDestination.x = x1*w2 + x2*w1 + y1*z2 - z1*y2;
		    q4fDestination.y = y1*w2 + y2*w1 + z1*x2 - x1*z2;
		    q4fDestination.z = z1*w2 + z2*w1 + x1*y2 - y1*x2;
		    q4fDestination.w = w1*w2 - x1*x2 - y1*y2 - z1*z2;

		    return q4fDestination;
		};

		multiplyVec3(v3fVec: IVec3, v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
		        v3fDestination = v3fVec;
		    }

		    var q4fVec: IQuat4 = quat4(v3fVec,0);
		    var qInverse: IQuat4 = this.inverse(quat4());

		    var qResult: IQuat4 = this.multiply(q4fVec.multiply(qInverse),quat4());

		    v3fDestination.x = qResult.x;
		    v3fDestination.y = qResult.y;
		    v3fDestination.z = qResult.z;

		    return v3fDestination;
		};

		conjugate(q4fDestination?: IQuat4): IQuat4{
			if(!isDef(q4fDestination)){
			    this.x = -this.x;
			    this.y = -this.y;
			    this.z = -this.z;

			    return this;
			}

			q4fDestination.x = -this.x;
			q4fDestination.y = -this.y;
			q4fDestination.z = -this.z;
			q4fDestination.w = this.w;

			return q4fDestination;
		};

		inverse(q4fDestination?: IQuat4): IQuat4{
			if(!isDef(q4fDestination)){
		        q4fDestination = this;
		    }

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;
		    var fSqLength:  number  = x*x + y*y + z*z + w*w;

		    if(fSqLength === 0.){
		        q4fDestination.x = 0.;
		        q4fDestination.y = 0.;
		        q4fDestination.z = 0.;
		        q4fDestination.w = 0.;
		    }
		    else{
		        var fInvSqLength :  number = 1./fSqLength;
		        q4fDestination.x = -x*fInvSqLength;
		        q4fDestination.y = -y*fInvSqLength;
		        q4fDestination.z = -z*fInvSqLength;
		        q4fDestination.w =  w*fInvSqLength;
		    }

		    return q4fDestination;
		};

		/**@inline*/  length() :  number {
			var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;
    		return sqrt(x*x + y*y + z*z + w*w);
		};

		normalize(q4fDestination?: IQuat4): IQuat4{
			if(!isDef(q4fDestination)){
		        q4fDestination = this;
		    }

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

		    var fLength:  number  = sqrt(x*x + y*y + z*z + w*w);

		    if(fLength === 0.){
		    	q4fDestination.x = 0.;
		    	q4fDestination.y = 0.;
		    	q4fDestination.z = 0.;
		    	q4fDestination.w = 0.;

		    }
		    else{
		    	var fInvLength:  number  = 1/fLength;

		    	q4fDestination.x = x*fInvLength;
		    	q4fDestination.y = y*fInvLength;
		    	q4fDestination.z = z*fInvLength;
		    	q4fDestination.w = w*fInvLength;
		    }

		    return q4fDestination;
		};

		calculateW(q4fDestination?: IQuat4): IQuat4{
			var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z;

		    if(!isDef(q4fDestination)){
		        this.w = sqrt(1. - x*x - y*y - z*z);
		        return this;
		    }

		    q4fDestination.x = x;
		    q4fDestination.y = y;
		    q4fDestination.z = z;
		    q4fDestination.w = sqrt(1. - x*x - y*y - z*z);

		    return q4fDestination;
		};

		isEqual(q4fQuat: IQuat4, fEps:  number  = 0., asMatrix: bool = false): bool{

		    var x1:  number  = this.x, y1:  number  = this.y, z1:  number  = this.z, w1:  number  = this.w;
		    var x2:  number  = q4fQuat.x, y2:  number  = q4fQuat.y, z2:  number  = q4fQuat.z, w2:  number  = q4fQuat.w;

		    var fLength1:  number  = sqrt(x1*x1 + y1*y1 + z1*z1 + w1*w1);
		    var fLength2:  number  = sqrt(x2*x2 + y2*y2 + z2*z2 + w2*w2);

		    if(abs(fLength2 - fLength2) > fEps){
		        return false;
		    }

		    var cosHalfTheta:  number  = (x1*x2 + y1*y2 + z1*z2 + w1*w2)/fLength1/fLength2;

		    if(asMatrix){
		        cosHalfTheta = abs(cosHalfTheta);
		    }

		    if(1. - cosHalfTheta > fEps){
		        return false;
		    }
		    return true;
		};

		getYaw():  number {
		    var fYaw:  number ;

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

		    var fx2:  number  = x*2.;
		    var fy2:  number  = y*2.;

		    if(abs(x) == abs(w)){
//вырожденный случай обрабатывается отдельно
//
		        var wTemp:  number  = w*sqrt(2.);
//cos(Yaw/2)*cos(Roll/2) + sin(Yaw/2)*sin(Roll/2) = cos((Yaw-Roll)/2); Roll = 0;
//x==-w
//cos(Yaw/2)*cos(Roll/2) - sin(Yaw/2)*sin(Roll/2) = cos((Yaw+Roll)/2); Roll = 0;
		        var yTemp:  number  = y*sqrt(2.);
//sin(Yaw/2)*cos(Roll/2) - cos(Yaw/2)*sin(Roll/2) = sin((Yaw-Roll)/2); Roll = 0;
//x==-w
//sin(Yaw/2)*cos(Roll/2) + cos(Yaw/2)*sin(Roll/2) = sin((Yaw+Roll)/2); Roll = 0;

		        fYaw = atan2(yTemp,wTemp)*2.;
//fRoll = 0;

//убираем дополнительный оборот
		        var pi:  number  = PI;
		        if(fYaw > pi){
		            fYaw -= pi;
//fRoll = (x == w) ? -pi : pi;
		        }
		        else if(fYaw < -pi){
		            fYaw += pi;
//fRoll = (x == w) ? pi : -pi;
		        }
		    }
		    else{
//Math.atan2(sin(Yaw)*cos(Pitch),cos(Yaw)*cos(Pitch));
		        fYaw = atan2(fx2*z + fy2*w, 1. - (fx2*x + fy2*y));
		    }

		    return fYaw;
		};

		getPitch():  number {
			var fPitch:  number ;

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

		    var fx2:  number  = x*2.;
		    var fy2:  number  = y*2.;

/*в очень редких случаях из-за ошибок округления получается результат > 1*/
		    var fSinPitch:  number  = clamp(fx2*w - fy2*z,-1.,1.);
		    fPitch = asin(fSinPitch)

		    return fPitch;
		};

		getRoll():  number {
		    var fRoll:  number ;

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

		    var fx2:  number  = x*2.;
		    var fz2:  number  = z*2.;

		    if(abs(x) == abs(w)){
//вырожденный случай обрабатывается отдельно
//
		        var wTemp:  number  = w*sqrt(2.);
//cos(Yaw/2)*cos(Roll/2) + sin(Yaw/2)*sin(Roll/2) = cos((Yaw-Roll)/2); Roll = 0;
//x==-w
//cos(Yaw/2)*cos(Roll/2) - sin(Yaw/2)*sin(Roll/2) = cos((Yaw+Roll)/2); Roll = 0;
		        var yTemp:  number  = y*sqrt(2.);
//sin(Yaw/2)*cos(Roll/2) - cos(Yaw/2)*sin(Roll/2) = sin((Yaw-Roll)/2); Roll = 0;
//x==-w
//sin(Yaw/2)*cos(Roll/2) + cos(Yaw/2)*sin(Roll/2) = sin((Yaw+Roll)/2); Roll = 0;

		        var fYaw:  number  = atan2(yTemp,wTemp)*2.;
		        fRoll = 0.;

//убираем дополнительный оборот
		        var pi:  number  = PI;
		        if(fYaw > pi){
//fYaw -= pi;
		            fRoll = (x == w) ? -pi : pi;
		        }
		        else if(fYaw < -pi){
//fYaw += pi;
		            fRoll = (x == w) ? pi : -pi;
		        }
		    }
		    else{
//Math.atan2(cos(Pitch) * sin(Roll),cos(Pitch)*cos(Roll));
		        fRoll = atan2(fx2*y + fz2*w, 1. - (fx2*x + fz2*z));
		    }

		    return fRoll;
		};

		toYawPitchRoll(v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
		        v3fDestination = new Vec3();
		    }

		    var fYaw:  number , fPitch:  number , fRoll:  number ;

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

		    var fx2:  number  = x*2.;
		    var fy2:  number  = y*2.;
		    var fz2:  number  = z*2.;
		    var fw2:  number  = w*2.;

/*в очень редких случаях из-за ошибок округления получается результат > 1*/
		    var fSinPitch:  number  = clamp(fx2*w - fy2*z,-1.,1.);
		    fPitch = asin(fSinPitch);
//не известен знак косинуса, как следствие это потребует дополнительной проверки.
//как показала практика - это не на что не влияет, просто один и тот же кватернион можно получить двумя разными вращениями

		    if(abs(x) == abs(w)){
//вырожденный случай обрабатывается отдельно
//
		        var wTemp:  number  = w*sqrt(2.);
//cos(Yaw/2)*cos(Roll/2) + sin(Yaw/2)*sin(Roll/2) = cos((Yaw-Roll)/2); Roll = 0;
//x==-w
//cos(Yaw/2)*cos(Roll/2) - sin(Yaw/2)*sin(Roll/2) = cos((Yaw+Roll)/2); Roll = 0;
		        var yTemp:  number  = y*sqrt(2.);
//sin(Yaw/2)*cos(Roll/2) - cos(Yaw/2)*sin(Roll/2) = sin((Yaw-Roll)/2); Roll = 0;
//x==-w
//sin(Yaw/2)*cos(Roll/2) + cos(Yaw/2)*sin(Roll/2) = sin((Yaw+Roll)/2); Roll = 0;

		        fYaw = atan2(yTemp,wTemp)*2.;
		        fRoll = 0.;

//убираем дополнительный оборот
		        var pi:  number  = PI;
		        if(fYaw > pi){
		            fYaw -= pi;
		            fRoll = (x == w) ? -pi : pi;
		        }
		        else if(fYaw < -pi){
		            fYaw += pi;
		            fRoll = (x == w) ? pi : -pi;
		        }
		    }
		    else{
//Math.atan2(sin(Yaw)*cos(Pitch),cos(Yaw)*cos(Pitch));
		        fYaw = atan2(fx2*z + fy2*w, 1. - (fx2*x + fy2*y));
//Math.atan2(cos(Pitch) * sin(Roll),cos(Pitch)*cos(Roll));
		        fRoll = atan2(fx2*y + fz2*w, 1. - (fx2*x + fz2*z));
		    }

		    v3fDestination.x = fYaw;
		    v3fDestination.y = fPitch;
		    v3fDestination.z = fRoll;

		    return v3fDestination;
		};

		toMat3(m3fDestination?: IMat3): IMat3{
			if(!isDef(m3fDestination)){
		        m3fDestination = new Mat3();
		    }
		    var pDataDestination: Float32Array = m3fDestination.data;

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

//потом необходимо ускорить

		    pDataDestination[ 0 ] = 1. - 2.*(y*y + z*z);
		    pDataDestination[ 3 ] = 2.*(x*y - z*w);
		    pDataDestination[ 6 ] = 2.*(x*z + y*w);

		    pDataDestination[ 1 ] = 2.*(x*y + z*w);
		    pDataDestination[ 4 ] = 1. - 2.*(x*x + z*z);
		    pDataDestination[ 7 ] = 2.*(y*z - x*w);

		    pDataDestination[ 2 ] = 2.*(x*z - y*w);
		    pDataDestination[ 5 ] = 2.*(y*z + x*w);
		    pDataDestination[ 8 ] = 1. - 2.*(x*x + y*y);

		    return m3fDestination;
		};

		toMat4(m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4();
		    }
		    var pDataDestination: Float32Array = m4fDestination.data;

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

//потом необходимо ускорить

		    pDataDestination[ 0 ] = 1. - 2.*(y*y + z*z);
		    pDataDestination[ 4 ] = 2.*(x*y - z*w);
		    pDataDestination[ 8 ] = 2.*(x*z + y*w);
		    pDataDestination[ 12 ] = 0.;

		    pDataDestination[ 1 ] = 2.*(x*y + z*w);
		    pDataDestination[ 5 ] = 1. - 2.*(x*x + z*z);
		    pDataDestination[ 9 ] = 2.*(y*z - x*w);
		    pDataDestination[ 13 ] = 0.;

		    pDataDestination[ 2 ] = 2.*(x*z - y*w);
		    pDataDestination[ 6 ] = 2.*(y*z + x*w);
		    pDataDestination[ 10 ] = 1. - 2.*(x*x + y*y);
		    pDataDestination[ 14 ] = 0.;

		    pDataDestination[ 3 ] = 0.;
		    pDataDestination[ 7 ] = 0.;
		    pDataDestination[ 11 ] = 0.;
		    pDataDestination[ 15 ] = 1.;

    		return m4fDestination;
		};

		/**@inline*/  toString(): string{
			return "[x: " + this.x + ", y: " + this.y + ", z: " + this.z + ", w: " + this.w + "]";
		};

		mix(q4fQuat: IQuat4, fA:  number , q4fDestination?: IQuat4, bShortestPath: bool = true){
			if(!isDef(q4fDestination)){
		        q4fDestination = this;
		    }

		    fA = clamp(fA,0,1);

		    var x1:  number  = this.x, y1:  number  = this.y, z1:  number  = this.z, w1:  number  = this.w;
		    var x2:  number  = q4fQuat.x, y2:  number  = q4fQuat.y, z2:  number  = q4fQuat.z, w2:  number  = q4fQuat.w;

//скалярное произведение
		    var fCos:  number  = x1*x2 + y1*y2 + z1*z2 + w1*w2;

		    if(fCos < 0. && bShortestPath){
		        x2 = -x2;
		        y2 = -y2;
		        z2 = -z2;
		        w2 = -w2;
		    }

		    var k1:  number  = 1. - fA;
		    var k2:  number  = fA;

		    q4fDestination.x = x1*k1 + x2*k2;
		    q4fDestination.y = y1*k1 + y2*k2;
		    q4fDestination.z = z1*k1 + z2*k2;
		    q4fDestination.w = w1*k1 + w2*k2;

		    return q4fDestination;
		};

		smix(q4fQuat: IQuat4, fA:  number , q4fDestination?: IQuat4, bShortestPath: bool = true){
			if(!isDef(q4fDestination)){
		        q4fDestination = this;
		    }

		    fA = clamp(fA,0,1);

		    var x1:  number  = this.x, y1:  number  = this.y, z1:  number  = this.z, w1:  number  = this.w;
		    var x2:  number  = q4fQuat.x, y2:  number  = q4fQuat.y, z2:  number  = q4fQuat.z, w2:  number  = q4fQuat.w;

//скалярное произведение
		    var fCos:  number  = x1*x2 + y1*y2 + z1*z2 + w1*w2;

		    if(fCos < 0 && bShortestPath){
		        fCos = -fCos;
		        x2 = -x2;
		        y2 = -y2;
		        z2 = -z2;
		        w2 = -w2;
		    }

		    var fEps:  number  = 1e-3;
		    if(abs(fCos) < 1. - fEps){
		        var fSin:  number  = sqrt(1. - fCos*fCos);
		        var fInvSin:  number  = 1./fSin;

		        var fAngle:  number  = atan2(fSin,fCos);

		        var k1:  number  = sin((1. - fA) * fAngle)*fInvSin;
		        var k2:  number  = sin(fA * fAngle)*fInvSin;

		        q4fDestination.x = x1*k1 + x2*k2;
		        q4fDestination.y = y1*k1 + y2*k2;
		        q4fDestination.z = z1*k1 + z2*k2;
		        q4fDestination.w = w1*k1 + w2*k2;
		    }
		    else{
//два кватерниона или очень близки (тогда можно делать линейную интерполяцию) 
//или два кватениона диаметрально противоположны, тогда можно интерполировать любым способом
//позже надо будет реализовать какой-нибудь, а пока тоже линейная интерполяция

		        var k1:  number  = 1 - fA;
		        var k2:  number  = fA;

		        var x:  number  = x1*k1 + x2*k2;
		        var y:  number  = y1*k1 + y2*k2;
		        var z:  number  = z1*k1 + z2*k2;
		        var w:  number  = w1*k1 + w2*k2;

// и нормализуем так-как мы сошли со сферы

		        var fLength:  number  = sqrt(x*x + y*y + z*z + w*w);
		        var fInvLen:  number  = fLength ? 1/fLength : 0;

		        q4fDestination.x = x*fInvLen;
		        q4fDestination.y = y*fInvLen;
		        q4fDestination.z = z*fInvLen;
		        q4fDestination.w = w*fInvLen;
		    }

		    return q4fDestination;
		};

		static fromForwardUp(v3fForward: IVec3, v3fUp: IVec3, q4fDestination?: IQuat4): IQuat4{
			if(!isDef(q4fDestination)){
		        q4fDestination = new Quat4();
		    }

		    var fForwardX:  number  = v3fForward.x, fForwardY:  number  = v3fForward.y, fForwardZ:  number  = v3fForward.z;
		    var fUpX:  number  = v3fUp.x, fUpY:  number  = v3fUp.y, fUpZ:  number  = v3fUp.z;

		    var m3fTemp: IMat3 = mat3();
		    var pTempData: Float32Array = m3fTemp.data;

		    pTempData[ 0 ] = fUpY*fForwardZ - fUpZ*fForwardY;
		    pTempData[ 3 ] = fUpX;
		    pTempData[ 6 ] = fForwardX;

		    pTempData[ 1 ] = fUpZ*fForwardX - fUpX*fForwardZ;
		    pTempData[ 4 ] = fUpY;
		    pTempData[ 7 ] = fForwardY;

		    pTempData[ 2 ] = fUpX*fForwardY - fUpY*fForwardX;
		    pTempData[ 5 ] = fUpZ;
		    pTempData[ 8 ] = fForwardZ;

		    return m3fTemp.toQuat4(q4fDestination);
		};

		static fromAxisAngle(v3fAxis: IVec3, fAngle:  number , q4fDestination?: IQuat4): IQuat4{

			if(!isDef(q4fDestination)){
		        q4fDestination = new Quat4();
		    }

		    var x:  number  = v3fAxis.x, y:  number  = v3fAxis.y, z:  number  = v3fAxis.z;

		    var fLength:  number  = sqrt(x*x + y*y + z*z);

		    if(fLength === 0.){
		        q4fDestination.x = q4fDestination.y = q4fDestination.z = 0;
		        q4fDestination.w = 1;
		        return q4fDestination;
		    }

		    var fInvLength = 1/fLength;

		    x *= fInvLength;
		    y *= fInvLength;
		    z *= fInvLength;

		    var fSin:  number  = sin(fAngle/2);
		    var fCos:  number  = cos(fAngle/2);

		    q4fDestination.x = x * fSin;
		    q4fDestination.y = y * fSin;
		    q4fDestination.z = z * fSin;
		    q4fDestination.w = fCos;

		    return q4fDestination;
		};

		static fromYawPitchRoll(fYaw:  number , fPitch:  number , fRoll:  number ,q4fDestination?: IQuat4): IQuat4;
		static fromYawPitchRoll(v3fAngles: IVec3,q4fDestination?: IQuat4): IQuat4;
		static fromYawPitchRoll(fYaw? ,fPitch?, fRoll?, q4fDestination?): IQuat4{
			if(arguments.length <= 2){
				var v3fVec: IVec3 = arguments[0];

				fYaw = v3fVec.x;
				fPitch = v3fVec.y;
				fRoll = v3fVec.z;

				q4fDestination = arguments[1];
			}

			if(!isDef(q4fDestination)){
				q4fDestination = new Quat4();
			}

		    var fHalfYaw:  number  = fYaw * 0.5;
		    var fHalfPitch:  number  = fPitch * 0.5;
		    var fHalfRoll:  number  = fRoll * 0.5;

		    var fCos1:  number  = cos(fHalfYaw), fSin1:  number  = sin(fHalfYaw);
		    var fCos2:  number  = cos(fHalfPitch), fSin2:  number  = sin(fHalfPitch);
		    var fCos3:  number  = cos(fHalfRoll), fSin3:  number  = sin(fHalfRoll);

		    q4fDestination.x = fCos1 * fSin2 * fCos3 + fSin1 * fCos2 * fSin3;
		    q4fDestination.y = fSin1 * fCos2 * fCos3 - fCos1 * fSin2 * fSin3;
		    q4fDestination.z = fCos1 * fCos2 * fSin3 - fSin1 * fSin2 * fCos3;
		    q4fDestination.w = fCos1 * fCos2 * fCos3 + fSin1 * fSin2 * fSin3;

		    return q4fDestination;
		};

		static fromXYZ(fX:  number , fY:  number , fZ:  number , q4fDestination?: IQuat4): IQuat4;
		static fromXYZ(v3fAngles: IVec3, q4fDestination?: IQuat4): IQuat4;
		static fromXYZ(fX?, fY?, fZ?, q4fDestination?) : IQuat4{
			if(arguments.length <= 2){
//Vec3 + m4fDestination
				var v3fVec: IVec3 = arguments[0];
				return Quat4.fromYawPitchRoll(v3fVec.y,v3fVec.x,v3fVec.z,arguments[1]);
			}
			else{
//fX fY fZ m4fDestination
				var fX:  number  = arguments[0];
				var fY:  number  = arguments[1];
				var fZ:  number  = arguments[2];

				return Quat4.fromYawPitchRoll(fY, fX, fZ, arguments[3]);
			}
		};

		static get stackCeil(): Quat4 { Quat4.stackPosition = Quat4.stackPosition === Quat4.stackSize - 1? 0: Quat4.stackPosition; return Quat4.stack[Quat4.stackPosition ++]; } static stackSize: number = 100; static stackPosition: number = 0; static stack: Quat4[] = (function(): Quat4[]{ var pStack: Quat4[] = new Array(Quat4.stackSize); for(var i: number = 0; i<Quat4.stackSize; i++){ pStack[i] = new Quat4(); } return pStack})();
    }
}




module akra.math {

//
// BASIC MATH AND UNIT CONVERSION CONSTANTS
//

	export var E:  number  								= < number >Math.E;
	export var LN2:  number  								= < number >Math.LN2;
	export var LOG2E:  number  							= < number >Math.LOG2E;
	export var LOG10E:  number  							= < number >Math.LOG10E;
	export var PI:  number  								= < number >Math.PI;
	export var SQRT1_2:  number  							= < number >Math.SQRT1_2;
	export var SQRT2:  number  							= < number >Math.SQRT2;
	export var LN10:  number  								= < number >Math.LN10;

	export var POSITIVE_INFINITY:  number                  = < number >Number.POSITIVE_INFINITY;
	export var NEGATIVE_INFINITY:  number                  = < number >Number.NEGATIVE_INFINITY;


	export var FLOAT_PRECISION:  number 					= < number >(3.4e-8);
	export var TWO_PI:  number 							= < number >(2.0*PI);
	export var HALF_PI:  number 							= < number >(PI/2.0);
	export var QUARTER_PI:  number 						= < number >(PI/4.0);
	export var EIGHTH_PI:  number 							= < number >(PI/8.0);
	export var PI_SQUARED:  number 						= < number >(9.86960440108935861883449099987615113531369940724079);
	export var PI_INVERSE:  number 						= < number >(0.31830988618379067153776752674502872406891929148091);
	export var PI_OVER_180:  number 						= < number >(PI/180);
	export var PI_DIV_180:  number 						= < number >(180/PI);
	export var NATURAL_LOGARITHM_BASE:  number 			= < number >(2.71828182845904523536028747135266249775724709369996);
	export var EULERS_CONSTANT:  number 					= < number >(0.57721566490153286060651);
	export var SQUARE_ROOT_2:  number 						= < number >(1.41421356237309504880168872420969807856967187537695);
	export var INVERSE_ROOT_2:  number 					= < number >(0.707106781186547524400844362105198);
	export var SQUARE_ROOT_3:  number 						= < number >(1.73205080756887729352744634150587236694280525381038);
	export var SQUARE_ROOT_5:  number 						= < number >(2.23606797749978969640917366873127623544061835961153);
	export var SQUARE_ROOT_10:  number 					= < number >(3.16227766016837933199889354443271853371955513932522);
	export var CUBE_ROOT_2:  number 						= < number >(1.25992104989487316476721060727822835057025146470151);
	export var CUBE_ROOT_3:  number 						= < number >(1.44224957030740838232163831078010958839186925349935);
	export var FOURTH_ROOT_2:  number 						= < number >(1.18920711500272106671749997056047591529297209246382);
	export var NATURAL_LOG_2:  number 						= < number >(0.69314718055994530941723212145817656807550013436026);
	export var NATURAL_LOG_3:  number 						= < number >(1.09861228866810969139524523692252570464749055782275);
	export var NATURAL_LOG_10:  number 					= < number >(2.30258509299404568401799145468436420760110148862877);
	export var NATURAL_LOG_PI:  number 					= < number >(1.14472988584940017414342735135305871164729481291531);
	export var BASE_TEN_LOG_PI:  number 					= < number >(0.49714987269413385435126828829089887365167832438044);
	export var NATURAL_LOGARITHM_BASE_INVERSE:  number 	= < number >(0.36787944117144232159552377016146086744581113103177);
	export var NATURAL_LOGARITHM_BASE_SQUARED:  number 	= < number >(7.38905609893065022723042746057500781318031557055185);
	export var GOLDEN_RATIO:  number 						= < number >((SQUARE_ROOT_5 + 1.0) / 2.0);
	export var DEGREE_RATIO:  number 						= < number >(PI_DIV_180);
	export var RADIAN_RATIO:  number 						= < number >(PI_OVER_180);
	export var GRAVITY_CONSTANT:  number  					= 9.81;

//
// MATH AND UNIT CONVERSION FUNCTION PROTOTYPES
//

	export var abs = Math.abs;
	export var acos = Math.acos;
	export var asin = Math.asin;
	export var atan = Math.atan;
	export var atan2 = Math.atan2;
	export var exp = Math.exp;
	export var min = Math.min;
	export var random = Math.random;
	export var sqrt = Math.sqrt;
	export var log = Math.log;
	export var round = Math.round;
	export var floor = Math.floor;
	export var ceil = Math.ceil;
	export var sin = Math.sin;
	export var cos = Math.cos;
	export var tan = Math.tan;
	export var pow = Math.pow;
	export var max = Math.max;

/*	
	-----------------------------------------------------------------
	    
		Floating Point Macros
	    
	-----------------------------------------------------------------
	*/

// reinterpret a float as an int32
/** @inline */

	export var fpBits = (f:  number ):  number  => floor(f);

// reinterpret an int32 as a float
/** @inline */

	export var intBits = (i:  number ):  number  => < number > i;

// return 0 or -1 based on the sign of the float
/** @inline */

	export var fpSign = (f:  number ) => (f >> 31);

// extract the 8 bits of exponent as a signed integer
// by masking out this bits, shifting down by 23,
// and subtracting the bias value of 127
/** @inline */

	export var fpExponent = (f:  number ):  number  => (((fpBits(f) & 0x7fffffff) >> 23) - 127);

// return 0 or -1 based on the sign of the exponent
/** @inline */

	export var fpExponentSign = (f:  number ):  number  => (fpExponent(f) >> 31) ;

// get the 23 bits of mantissa without the implied bit
/** @inline */

	export var fpPureMantissa = (f:  number ):  number  => ((fpBits(f) & 0x7fffff));

// get the 23 bits of mantissa with the implied bit replaced
/** @inline */

	export var fpMantissa = (f:  number ):  number  => (fpPureMantissa(f) | (1 << 23));

	export var fpOneBits = 0x3F800000;

// flipSign is a helper Macro to
// invert the sign of i if flip equals -1, 
// if flip equals 0, it does nothing
//export var flipSign = (i, flip) ((i^ flip) - flip)
/** @inline */

	export var flipSign = (i: number, flip: number):  number  => ((flip == -1) ? -i : i);

/**
	 * Абсолютное значение числа
	 * @inline
	 */

	export var absoluteValue = abs;
/**
	 * Pow
	 * @inline
	 */

	export var raiseToPower = pow;
/**
	 * Число положительно?
	 * @inline
	 */

	export var isPositive = (a: number) => (a >= 0);
/**
	 * Число отрицательно?
	 * @inline
	 */

	export var isNegative = (a: number) => (a < 0);
/**
	 * Число одного знака?
	 * @inline
	 */

	export var sameSigns = (a: number, b: number): bool => (isNegative(a) == isNegative(b));
/**
	 * Копировать знак
	 * @inline
	 */

	export var copySign = (a: number, b: number): number => (isNegative(b) ? -absoluteValue(a) : absoluteValue(a));
/**
	 * Растояние между а и b меньше epsilon?
	 * @inline
	 */

	export var deltaRangeTest = (a: number, b: number, epsilon: number = 0.0000001): bool => ((absoluteValue(a - b) < epsilon) ? true : false);

/**
	 * Ограничивает value интервалом [low,high]
	 * @inline
	 */

	export var clamp = (value: number, low: number, high: number): number => max(low, min(value, high));
/**
	 * Ограничивает value интервалом [0,+Infinity]
	 * @inline
	 */

	export var clampPositive = (value: number): number => (value < 0 ? 0 : value);
/**
	 * Ограничивает value интервалом [-Infinity,0]
	 * @inline
	 */

	export var clampNegative = (value: number): number => (value > 0 ? 0 : value);
/**
	 * Ограничивает value интервалом [-1,1]
	 * @inline
	 */

	export var clampUnitSize = (value: number): number => clamp(value, -1, 1);


/**
	 * Номер с права начиная от нуля, самого левого установленного бита
	 * @inline
	 */

	export var highestBitSet = (value: number):  number  => value == 0 ? (null) : (value < 0 ? 31 : ((log(value) / LN2) << 0));
/**
	 * Номер с права начиная от нуля, самого правого установленного бита
	 * @inline
	 */

	export var lowestBitSet = (value:  number ):  number  => {
		var temp:  number ;

	    if (value == 0) {
	        return null;
	    }

	    for (temp = 0; temp <= 31; temp++) {
	        if (value & (1 << temp)) {
	            return temp;
	        }
	    }

	    return null;
	}

/**
	 * Является ли число степенью двойки
	 * @inline
	 */

	export var isPowerOfTwo = (value:  number ): bool => (value > 0 && highestBitSet(value) == lowestBitSet(value));
/**
	 * Округление до числа наиболее близкого к степени двойки
	 * @inline
	 */

	export var nearestPowerOfTwo = (value:  number ):  number  => {
		if (value <= 1) {
        	return 1;
	    }

	    var highestBit:  number  = highestBitSet(value);
	    var roundingTest:  number  = value & (1 << (highestBit - 1));

	    if (roundingTest != 0) {
	        ++ highestBit;
	    }

	    return 1 << highestBit;
	}

/**
	 * Округление до следующего числа являющегося к степени двойки
	 * @inline
	 */

	export var ceilingPowerOfTwo = (value:  number ):  number  => {
		if (value <= 1) {
	        return 1;
	    }

	    var highestBit:  number  = highestBitSet(value);
	    var mask:  number  = value & ((1 << highestBit) - 1);
	    highestBit += mask && 1;
	    return 1 << highestBit;
	}
/**
	 * Округление до преды��ущего числа являющегося к степени двойки
	 * @inline
	 */

	export var floorPowerOfTwo = (value:  number ):  number  => {
		if (value <= 1) {
        	return 1;
	    }

	    var highestBit:  number  = highestBitSet(value);

	    return 1 << highestBit;
	}

/**
	 * Деление по модулю
	 * @inline
	 */

	export var modulus = (e:  number , divisor:  number ):  number  => (e - floor(e / divisor) * divisor);
/**
	 * 
	 * @inline
	 */

	export var mod = modulus;

/**
	 * Вырвнивание числа на alignment вверх
	 * @inline
	 */

	export var alignUp = (value:  number , alignment:  number ):  number  => {
		var iRemainder:  number  = modulus(value, alignment);
	    if (iRemainder == 0) {
	        return(value);
	    }

	    return(value + (alignment - iRemainder));
	}


/**
	 * Вырвнивание числа на alignment вниз
	 * @inline
	 */

	export var alignDown = (value:  number , alignment:  number ):  number  => {
		var remainder:  number  = modulus(value, alignment);
	    if (remainder == 0) {
	        return(value);
	    }

	    return(value - remainder);
	}

/**
	 * пнвертировать число
	 * @inline
	 */

	export var inverse = (a: number): number => 1. / a;
/**
	 * log base 2
	 * @inline
	 */

	export var log2 = (f:  number ):  number  => log(f) / LN2;
/**
	 * Округлени числа с определенной точностью, где округляется до значащих чисел как 1/(2^precision)
	 * @inline
	 */

	export var trimFloat = (f:  number , precision:  number ):  number  => f;

/**
	 * Перевод дробного в целое с усеением
	 * @inline
	 */

	export var realToInt32_chop = (a:  number ):  number  => round(a);
/**
	 * Перевод дробного в целое до меньшего
	 * @inline
	 */

	export var realToInt32_floor = (a:  number ):  number  => floor(a);
/**
	 * Перевод дробного в целое до большего
	 * @inline
	 */

	export var realToInt32_ceil = (a:  number ):  number  => ceil(a);

/**
	 * Наибольший общий делитель
	 * @inline
	 */

	export var nod = (n:  number , m:  number ):  number  => {
		var p:  number  = n % m;

		while (p != 0) {
			n = m
			m = p
			p = n % m
		}

		return m;
	}
/**
	 * Наименьшее общее кратное
	 * @inline
	 */

	export var nok = (n:  number , m:  number ):  number  => abs(n * m) / nod(n , m);
/**
	 * Greatest common devider
	 * @inline
	 */

	export var gcd = nod;
/**
	 * Least common multiple
	 * @inline
	 */

	export var lcm = nok;

// var pMat3Stack = new Array(100);
// var iMat3StackIndex = 0;

	export var isRealEqual = (a:  number , b:  number , tolerance:  number  = 1.19209e-007): bool => {
        if (math.abs(b - a) <= tolerance)
            return true;
        else
            return false;
    }

    export function vec2(): IVec2;
    export function vec2(fValue:  number ): IVec2;
    export function vec2(v2fVec: IVec2): IVec2;
    export function vec2(pArray:  number []): IVec2;
    export function vec2(fValue1:  number , fValue2:  number ): IVec2;
    export function vec2(fValue1?, fValue2?): IVec2{
        var nArgumentsLength:  number  = arguments.length;
        var v2fVec: IVec2 = Vec2.stack[Vec2.stackPosition ++];

        if(Vec2.stackPosition == Vec2.stackSize){
            Vec2.stackPosition = 0;
        }

        switch(nArgumentsLength){
            case 1:
                v2fVec.set(arguments[0]);
                break;
            case 2:
                v2fVec.set(arguments[0], arguments[1]);
                break;
            default:
                v2fVec.x = v2fVec.y = 0.;
                break;
        }

        return v2fVec;
    };

    export function vec3(): IVec3;
    export function vec3(fValue:  number ): IVec3;
    export function vec3(v3fVec: IVec3): IVec3;
    export function vec3(pArray:  number []): IVec3;
    export function vec3(fValue:  number , v2fVec: IVec2): IVec3;
    export function vec3(v2fVec: IVec2, fValue:  number ): IVec3;
    export function vec3(fValue1:  number , fValue2:  number , fValue3:  number ): IVec3;
    export function vec3(fValue1?, fValue2?, fValue3?): IVec3{
        var nArgumentsLength:  number  = arguments.length;
        var v3fVec: IVec3 = Vec3.stack[Vec3.stackPosition ++];

        if(Vec3.stackPosition == Vec3.stackSize){
            Vec3.stackPosition = 0;
        }

        switch(nArgumentsLength){
            case 1:
                v3fVec.set(arguments[0]);
                break;
            case 2:
                v3fVec.set(arguments[0], arguments[1]);
                break;
            case 3:
                v3fVec.set(arguments[0], arguments[1], arguments[2]);
                break;
            default:
                v3fVec.x = v3fVec.y = v3fVec.z = 0.;
                break;
        }

        return v3fVec;
    };

    export function vec4(): IVec4;
    export function vec4(fValue:  number ): IVec4;
    export function vec4(v4fVec: IVec4): IVec4;
    export function vec4(pArray:  number []): IVec4;
    export function vec4(fValue:  number , v3fVec: IVec3): IVec4;
    export function vec4(v2fVec1: IVec2, v2fVec2: IVec2): IVec4;
    export function vec4(v3fVec: IVec3, fValue:  number ): IVec4;
    export function vec4(fValue1:  number , fValue2:  number , v2fVec: IVec2): IVec4;
    export function vec4(fValue1:  number , v2fVec: IVec2, fValue2:  number ): IVec4;
    export function vec4(v2fVec: IVec2 ,fValue1:  number , fValue2:  number ): IVec4;
    export function vec4(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ): IVec4;
    export function vec4(fValue1?, fValue2?, fValue3?, fValue4?): IVec4{
        var nArgumentsLength:  number  = arguments.length;
        var v4fVec: IVec4 = Vec4.stack[Vec4.stackPosition ++];

        if(Vec4.stackPosition == Vec4.stackSize){
            Vec4.stackPosition = 0;
        }

        switch(nArgumentsLength){
            case 1:
                v4fVec.set(arguments[0]);
                break;
            case 2:
                v4fVec.set(arguments[0],arguments[1]);
                break;
            case 3:
                v4fVec.set(arguments[0],arguments[1], arguments[2]);
                break;
            case 4:
                v4fVec.set(arguments[0],arguments[1], arguments[2], arguments[3]);
                break;
            default:
                v4fVec.x = v4fVec.y = v4fVec.z = v4fVec.w = 0.;
                break;
        }

        return v4fVec;
    };

    export function quat4(): IQuat4;
	export function quat4(q4fQuat: IQuat4): IQuat4;
	export function quat4(pArray:  number []): IQuat4;
	export function quat4(fValue:  number , fW:  number ): IQuat4;
	export function quat4(v3fValue: IVec3, fW:  number ): IQuat4;
	export function quat4(fX:  number , fY:  number , fZ:  number , fW:  number ): IQuat4;
	export function quat4(fX?, fY?, fZ?, fW?): IQuat4{
		var nArgumentsLength:  number  = arguments.length;
		var q4fQuat: IQuat4 = Quat4.stack[Quat4.stackPosition ++];

		if(Quat4.stackPosition == Quat4.stackSize){
            Quat4.stackPosition = 0;
		}

		switch(nArgumentsLength){
			case 1:
				q4fQuat.set(arguments[0]);
				break;
			case 2:
				q4fQuat.set(arguments[0], arguments[1]);
				break;
			case 4:
				q4fQuat.set(arguments[0], arguments[1], arguments[2], arguments[3]);
				break;
			default:
				q4fQuat.x = q4fQuat.y = q4fQuat.z = 0.;
				q4fQuat.w = 1.;
				break;
		}

		return q4fQuat;
	};

	export function mat3(): IMat3;
	export function mat3(fValue:  number ): IMat3;
	export function mat3(v3fVec: IVec3): IMat3;
	export function mat3(m3fMat: IMat3): IMat3;
	export function mat3(m4fMat: IMat4): IMat3;
	export function mat3(pArray:  number []): IMat3;
	export function mat3(fValue1:  number , fValue2:  number , fValue3:  number ): IMat3;
	export function mat3(v3fVec1: IVec3, v3fVec2: IVec3, v3fVec3: IVec3): IMat3;
	export function mat3(pArray1:  number [], pArray2:  number [], pArray3:  number []): IMat3;
	export function mat3(fValue1:  number , fValue2:  number , fValue3:  number ,
				fValue4:  number , fValue5:  number , fValue6:  number ,
				fValue7:  number , fValue8:  number , fValue9:  number ): IMat3;
	export function mat3(fValue1?, fValue2?, fValue3?,
				fValue4?, fValue5?, fValue6?,
				fValue7?, fValue8?, fValue9?): IMat3{

		var nArgumentsLength:  number  = arguments.length;
		var m3fMat: IMat3 = Mat3.stack[Mat3.stackPosition ++];

        if(Mat3.stackPosition == Mat3.stackSize){
            Mat3.stackPosition = 0;
		}

		switch(nArgumentsLength){
			case 1:
				m3fMat.set(arguments[0]);
				break;
			case 3:
				m3fMat.set(arguments[0], arguments[1], arguments[2]);
				break;
			case 9:
				m3fMat.set(arguments[0], arguments[1], arguments[2],
						 arguments[3], arguments[4], arguments[5],
						 arguments[6], arguments[7], arguments[8]);
				break;
			default:
				m3fMat.set(0.);
				break;
		}

		return m3fMat;
	};

	export function mat4(): IMat4;
	export function mat4(fValue:  number ): IMat4;
	export function mat4(v4fVec: IVec4): IMat4;
	export function mat4(m3fMat: IMat3, v3fTranslation?: IVec3): IMat4;
	export function mat4(m4fMat: IMat4): IMat4;
	export function mat4(pArray:  number []): IMat4;
	export function mat4(pArray: Float32Array, bFlag: bool): IMat4;
	export function mat4(fValue1:  number , fValue2:  number ,
			fValue3:  number , fValue4:  number ): IMat4;
	export function mat4(v4fVec1: IVec4, v4fVec2: IVec4,
			v4fVec3: IVec4, v4fVec4: IVec4): IMat4;
	export function mat4(pArray1:  number [], pArray2:  number [],
			pArray3:  number [], pArray4:  number []): IMat4;
	export function mat4(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ,
			fValue5:  number , fValue6:  number , fValue7:  number , fValue8:  number ,
			fValue9:  number , fValue10:  number , fValue11:  number , fValue12:  number ,
			fValue13:  number , fValue14:  number , fValue15:  number , fValue16:  number ): IMat4;
	export function mat4(fValue1?, fValue2?, fValue3?, fValue4?,
				fValue5?, fValue6?, fValue7?, fValue8?,
				fValue9?, fValue10?, fValue11?, fValue12?,
				fValue13?, fValue14?, fValue15?, fValue16?): IMat4{

		var nArgumentsLength:  number  = arguments.length;
		var m4fMat: IMat4 = Mat4.stack[Mat4.stackPosition ++];

        if(Mat4.stackPosition == Mat4.stackSize){
            Mat4.stackPosition = 0;
		}

		if(nArgumentsLength === 2){
			if(isBoolean(arguments[1])){
				if(arguments[1]){
					m4fMat.data = arguments[0];
				}
				else{
					m4fMat.set(arguments[0]);
				}
			}
			else{
				m4fMat.set(arguments[0], arguments[1]);
			}
		}
		else{
			switch(nArgumentsLength){
				case 1:
					if(arguments[0] instanceof Mat3){
						m4fMat.set(arguments[0],vec3(0.));
					}
					else{
						m4fMat.set(arguments[0]);
					}
					break;
				case 4:
					m4fMat.set(arguments[0],arguments[1],arguments[2],arguments[3]);
					break;
				case 16:
					m4fMat.set(arguments[0], arguments[1], arguments[2], arguments[3],
						 arguments[4], arguments[5], arguments[6], arguments[7],
						 arguments[8], arguments[9], arguments[10], arguments[11],
						 arguments[12], arguments[13], arguments[14], arguments[15]);
					 break;
				 default:
				 	break;
			}
		}

		return m4fMat;
	};

	export function calcPOTtextureSize (nPixels:  number ):  number [] {
	    var w:  number , h:  number ;
	    var n:  number  = nPixels;


	    w = Math.ceil(Math.log(n) / Math.LN2 / 2.0);
	    h = Math.ceil(Math.log(n / Math.pow(2, w)) / Math.LN2);
	    w = Math.pow(2, w);
	    h = Math.pow(2, h);
	    n = w * h;
	    return [w, h, n];
	}

}

module akra {
	export var Vec2 = math.Vec2;
	export var Vec3 = math.Vec3;
	export var Vec4 = math.Vec4;

	export var Mat3 = math.Mat3;
	export var Mat4 = math.Mat4;
	export var Quat4 = math.Quat4;

	export var vec2 = math.vec2;
	export var vec3 = math.vec3;
	export var vec4 = math.vec4;
	export var quat4 = math.quat4;
	export var mat3 = math.mat3;
	export var mat4 = math.mat4;
}



module akra.scene {

	export enum ENodeUpdateFlags {
		k_SetForDestruction = 0,
//if changed scale, otation or position
		k_NewOrientation,
// k_NewTranslation,
// k_NewScale,
		k_NewWorldMatrix,
		k_NewLocalMatrix,
		k_RebuildInverseWorldMatrix,
		k_RebuildNormalMatrix,
     };

	export class Node extends util.Entity implements INode {
		/**@protected*/  _m4fLocalMatrix: IMat4 = null;
		/**@protected*/  _m4fWorldMatrix: IMat4 = null;
		/**@protected*/  _m4fInverseWorldMatrix: IMat4 = null;
		/**@protected*/  _m3fNormalMatrix: IMat3 = null;

		/**@protected*/  _v3fWorldPosition: IVec3 = null;

		/**@protected*/  _qRotation: IQuat4 = null;
		/**@protected*/  _v3fTranslation: IVec3 = null;
		/**@protected*/  _v3fScale: IVec3 = null;

		/**@protected*/  _iUpdateFlags:  number  = 0;
		/**@protected*/  _eInheritance: ENodeInheritance = ENodeInheritance.POSITION;


		/**@inline*/  get localOrientation(): IQuat4 {
			return this._qRotation;
		}

		/**@inline*/  set localOrientation(qOrient: IQuat4) {
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
			this._qRotation.set(qOrient);
		}

		/**@inline*/  get localPosition(): IVec3 {
			return this._v3fTranslation;
		}

		/**@inline*/  set localPosition(v3fPosition: IVec3) {
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
			this._v3fTranslation.set(v3fPosition);
		}

		/**@inline*/  get localScale(): IVec3 {
			return this._v3fScale;
		}

		/**@inline*/  set localScale(v3fScale: IVec3) {
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
			this._v3fScale.set(v3fScale);
		}

		/**@inline*/  get localMatrix(): IMat4 {
			return this._m4fLocalMatrix;
		}

		/**@inline*/  set localMatrix(m4fLocalMatrix: IMat4) {
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewLocalMatrix))) ) ;
			this._m4fLocalMatrix.set(m4fLocalMatrix);
		}


		/**@inline*/  get worldMatrix(): IMat4 {
			return this._m4fWorldMatrix;
		}

		/**@inline*/  get worldPosition(): IVec3 {
			return this._v3fWorldPosition;
		}

		get inverseWorldMatrix(): IMat4 {
			if ( ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_RebuildInverseWorldMatrix)) ) != 0) ) {
		        this._m4fWorldMatrix.inverse(this._m4fInverseWorldMatrix);
		        ((this._iUpdateFlags) &= ~ (1 << ((ENodeUpdateFlags.k_RebuildInverseWorldMatrix))) ) ;
		    }

			return this._m4fInverseWorldMatrix;
		}

		get normalMatrix(): IMat3 {
			if ( ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_RebuildNormalMatrix)) ) != 0) ) {

		        this._m4fWorldMatrix.toMat3(this._m3fNormalMatrix).inverse().transpose();

		        ((this._iUpdateFlags) &= ~ (1 << ((ENodeUpdateFlags.k_RebuildNormalMatrix))) ) ;
		    }

			return this._m3fNormalMatrix;
		}


		update(): bool {
// derived classes update the local matrix
// then call this base function to complete
// the update
		    return this.recalcWorldMatrix();
		}


		prepareForUpdate(): void {
			super.prepareForUpdate();
// clear the temporary flags
			((this._iUpdateFlags) &= ~( (1 << (ENodeUpdateFlags.k_NewLocalMatrix)) | (1 << (ENodeUpdateFlags.k_NewOrientation)) | (1 << (ENodeUpdateFlags.k_NewWorldMatrix)) ))
                                                                                            ;
		}


		/**@inline*/  setInheritance(eInheritance: ENodeInheritance) {
			this._eInheritance = eInheritance;
		}

		/**@inline*/  getInheritance(): ENodeInheritance {
			return this._eInheritance;
		}

		/**@inline*/  isWorldMatrixNew(): bool {
			return  ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_NewWorldMatrix)) ) != 0) ;
		}

		/**@inline*/  isLocalMatrixNew(): bool {
			return  ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_NewLocalMatrix)) ) != 0) ;
		}

		private recalcWorldMatrix(): bool {
			var isParentMoved: bool = this._pParent && (<Node>this._pParent).isWorldMatrixNew();
		    var isOrientModified: bool =  ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_NewOrientation)) ) != 0) ;
		    var isLocalModified: bool =  ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_NewLocalMatrix)) ) != 0) ;

		    if (isOrientModified || isParentMoved || isLocalModified) {
		        var m4fLocal: IMat4 = this._m4fLocalMatrix;
		        var m4fWorld: IMat4 = this._m4fWorldMatrix;
		        var m4fParent: IMat4 = (<Node>this._pParent).worldMatrix;
		        var m4fOrient: IMat4 = Node._m4fTemp;
		        var v3fTemp: IVec3 = Node._v3fTemp;

		        var pWorldData: Float32Array = m4fWorld.data;
		        var pParentData: Float32Array = m4fParent.data;
		        var pOrientData: Float32Array = m4fOrient.data;

		        this._qRotation.toMat4(m4fOrient);

		        m4fOrient.setTranslation(this._v3fTranslation);
		        m4fOrient.scaleLeft(this._v3fScale);
		        m4fOrient.multiply(m4fLocal);

		        console.error(m4fOrient.toString());

		        if (this._pParent) {
		            if (this._eInheritance === ENodeInheritance.ALL) {
		                m4fParent.multiply(m4fOrient, m4fWorld);
		            }
		            else if (this._eInheritance === ENodeInheritance.POSITION) {
		                m4fWorld.set(m4fOrient);

		                pWorldData[ 12 ] = pParentData[ 12 ] + pOrientData[ 12 ];
		                pWorldData[ 13 ] = pParentData[ 13 ] + pOrientData[ 13 ];
		                pWorldData[ 14 ] = pParentData[ 14 ] + pOrientData[ 14 ];
		            }
		            else if (this._eInheritance === ENodeInheritance.ROTSCALE) {
		                var p11 = pParentData[ 0 ], p12 = pParentData[ 4 ],
		                    p13 = pParentData[ 8 ];
		                var p21 = pParentData[ 1 ], p22 = pParentData[ 5 ],
		                    p23 = pParentData[ 9 ];
		                var p31 = pParentData[ 2 ], p32 = pParentData[ 6 ],
		                    p33 = pParentData[ 10 ];

		                var l11 = pOrientData[ 0 ], l12 = pOrientData[ 4 ],
		                    l13 = pOrientData[ 8 ];
		                var l21 = pOrientData[ 1 ], l22 = pOrientData[ 5 ],
		                    l23 = pOrientData[ 9 ];
		                var l31 = pOrientData[ 2 ], l32 = pOrientData[ 6 ],
		                    l33 = pOrientData[ 10 ];

		                pWorldData[ 0 ] = p11 * l11 + p12 * l21 + p13 * l31;
		                pWorldData[ 4 ] = p11 * l12 + p12 * l22 + p13 * l32;
		                pWorldData[ 8 ] = p11 * l13 + p12 * l23 + p13 * l33;
		                pWorldData[ 12 ] = pOrientData[ 12 ];
		                pWorldData[ 1 ] = p21 * l11 + p22 * l21 + p23 * l31;
		                pWorldData[ 5 ] = p21 * l12 + p22 * l22 + p23 * l32;
		                pWorldData[ 9 ] = p21 * l13 + p22 * l23 + p23 * l33;
		                pWorldData[ 13 ] = pOrientData[ 13 ];
		                pWorldData[ 2 ] = p31 * l11 + p32 * l21 + p33 * l31;
		                pWorldData[ 6 ] = p31 * l12 + p32 * l22 + p33 * l32;
		                pWorldData[ 10 ] = p31 * l13 + p32 * l23 + p33 * l33;
		                pWorldData[ 14 ] = pOrientData[ 14 ];

		                pWorldData[ 3 ] = pOrientData[ 3 ];
		                pWorldData[ 7 ] = pOrientData[ 7 ];
		                pWorldData[ 11 ] = pOrientData[ 11 ];
		                pWorldData[ 15 ] = pOrientData[ 15 ];
		            }
		        }
		        else {
		            m4fWorld.set(m4fOrient);
		        }

		        this._v3fWorldPosition.x = pWorldData[ 12 ];
		        this._v3fWorldPosition.y = pWorldData[ 13 ];
		        this._v3fWorldPosition.z = pWorldData[ 14 ];

// set the flag that our world matrix has changed
		        ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewWorldMatrix))) ) ;
// and it's inverse & vectors are out of date
		        ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_RebuildInverseWorldMatrix))) ) ;
		        ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_RebuildNormalMatrix))) ) ;

		        return true;
		    }

		    return false;
		}

		setPosition(v3fPosition: IVec3): void;
		setPosition(fX:  number , fY:  number , fZ:  number ): void;
		setPosition(fX?: any, fY?: any, fZ?: any): void {
			var pPos: IVec3 = arguments.length === 1? arguments[0]: vec3(fX, fY, fZ);
		    var v3fTranslation: IVec3 = this._v3fTranslation;

		    v3fTranslation.set(pPos);

		    ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		addPosition(v3fPosition: IVec3): void;
		addPosition(fX:  number , fY:  number , fZ:  number ): void;
		addPosition(fX?: any, fY?: any, fZ?: any): void {
			var pPos: IVec3 = arguments.length === 1? arguments[0]: vec3(fX, fY, fZ);
		    var v3fTranslation: IVec3 = this._v3fTranslation;

		    v3fTranslation.add(pPos);

		    ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		addRelPosition(v3fPosition: IVec3): void;
		addRelPosition(fX:  number , fY:  number , fZ:  number ): void;
		addRelPosition(fX?: any, fY?: any, fZ?: any): void {
			var pPos: IVec3 = arguments.length === 1? arguments[0]: vec3(fX, fY, fZ);
		    var v3fTranslation: IVec3 = this._v3fTranslation;

		    this._qRotation.multiplyVec3(pPos);
    		v3fTranslation.add(pPos);

		    ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		setRotationByMatrix(m3fRotation: IMat3): void;
		setRotationByMatrix(m4fRotation: IMat4): void;
		setRotationByMatrix(matrix: any): void {
			matrix.toQuat4(this._qRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		setRotationByAxisAngle(v3fAxis: IVec3, fAngle:  number ): void {
			Quat4.fromAxisAngle(v3fAxis, fAngle, this._qRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		setRotationByForwardUp(v3fForward: IVec3, v3fUp: IVec3): void {
			Quat4.fromForwardUp(v3fForward, v3fUp, this._qRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		setRotationByEulerAngles(fYaw:  number , fPitch:  number , fRoll:  number ): void {
			Quat4.fromYawPitchRoll(fYaw, fPitch, fRoll, this._qRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		setRotationByXYZAxis(fX:  number , fY:  number , fZ:  number ): void {
			Quat4.fromYawPitchRoll(fY, fX, fZ, this._qRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		setRotation(q4fRotation: IQuat4): void {
			this._qRotation.set(q4fRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		addRelRotationByMatrix(m3fRotation: IMat3): void;
		addRelRotationByMatrix(m4fRotation: IMat4): void;
		addRelRotationByMatrix(matrix: any): void {
			this.addRelRotation(arguments[0].toQuat4(Node._q4fTemp));
		}

		addRelRotationByAxisAngle(v3fAxis: IVec3, fAngle:  number ): void {
			this.addRelRotation(Quat4.fromAxisAngle(v3fAxis, fAngle, Node._q4fTemp));
		}

		addRelRotationByForwardUp(v3fForward: IVec3, v3fUp: IVec3): void {
			this.addRelRotation(Quat4.fromForwardUp(v3fForward, v3fUp, Node._q4fTemp));
		}

		addRelRotationByEulerAngles(fYaw:  number , fPitch:  number , fRoll:  number ): void {
			this.addRelRotation(Quat4.fromYawPitchRoll(fYaw, fPitch, fRoll, Node._q4fTemp));
		}

		addRelRotationByXYZAxis(fX:  number , fY:  number , fZ:  number ): void {
			this.addRelRotation(Quat4.fromYawPitchRoll(fY, fX, fZ, Node._q4fTemp));
		}

		addRelRotation(q4fRotation: IQuat4): void {
			this._qRotation.multiply(q4fRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		addRotationByMatrix(m3fRotation: IMat3): void;
		addRotationByMatrix(m4fRotation: IMat4): void;
		addRotationByMatrix(matrix: any): void {
			this.addRotation(arguments[0].toQuat4(Node._q4fTemp));
		}

		addRotationByAxisAngle(v3fAxis: IVec3, fAngle:  number ): void {
			this.addRotation(Quat4.fromAxisAngle(v3fAxis, fAngle, Node._q4fTemp));
		}

		addRotationByForwardUp(v3fForward: IVec3, v3fUp: IVec3): void {
			this.addRotation(Quat4.fromForwardUp(v3fForward, v3fUp, Node._q4fTemp));
		}

		addRotationByEulerAngles(fYaw:  number , fPitch:  number , fRoll:  number ): void {
			this.addRotation(Quat4.fromYawPitchRoll(fYaw, fPitch, fRoll, Node._q4fTemp));
		}

		addRotationByXYZAxis(fX:  number , fY:  number , fZ:  number ): void {
			this.addRotation(Quat4.fromYawPitchRoll(fY, fX, fZ, Node._q4fTemp));
		}

		addRotation(q4fRotation: IQuat4): void {
			q4fRotation.multiplyVec3(this._v3fTranslation);
    		q4fRotation.multiply(this._qRotation, this._qRotation);
    		((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}


		scale(fScale:  number ): void;
		scale(fX:  number , fY:  number , fZ:  number ): void;
		scale(fX: any, fY?: any, fZ?: any): void {
			var pScale: IVec3 = arguments.length === 1? arguments[0]: vec3(fX);
		    var v3fScale: IVec3 = this._v3fScale;

		    v3fScale.scale(pScale);

		    ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}



		attachToParent(pParent: IEntity): bool {
			if (super.attachToParent(pParent)) {
// adjust my local matrix to be relative to this new parent
	            var m4fInvertedParentMatrix: IMat4 = mat4();
	            (<Node>this._pParent)._m4fWorldMatrix.inverse(m4fInvertedParentMatrix);
	            return true;
			}

			return false;
		}

		detachFromParent(): bool {
			if (super.detachFromParent()) {
				this._m4fWorldMatrix.identity();
				return true;
			}

			return false;
		}

		toString(isRecursive: bool = false, iDepth:  number  = 0): string {


		    if (!isRecursive) {
		        return '<node' + (this.name? " " + this.name: "") + '>';
		    }

		    var pSibling: IEntity = this.sibling;
		    var pChild: IEntity = this.child;
		    var s = "";

		    for (var i = 0; i < iDepth; ++ i) {
		        s += ':  ';
		    }

		    s += '+----[depth: ' + this.depth + ']' + this.toString() + '\n';

		    if (pChild) {
		        s += pChild.toString(true, iDepth + 1);
		    }

		    if (pSibling) {
		        s += pSibling.toString(true, iDepth);
		    }

		    return s;

		};

		private static _v3fTemp: IVec3 = vec3();
		private static _v4fTemp: IVec4 = vec4();
		private static _m3fTemp: IMat3 = mat3();
		private static _m4fTemp: IMat4 = mat4();
		private static _q4fTemp: IQuat4 = quat4();
	}
}



module akra.scene {
	export class SceneNode extends Node implements ISceneNode {
		/**@protected*/  _pScene: IScene3d = null;

		/**@inline*/  get scene(): IScene3d { return this._pScene; }
		/**@inline*/  set scene(pScene: IScene3d) { this._pScene = pScene; }

		constructor (pScene: IScene3d) {
			super();

			pScene.connect(this,  "attached" ,  "nodeAttachment" , EEventTypes.UNICAST);
			pScene.connect(this,  "detached" ,  "nodeDetachment" , EEventTypes.UNICAST);

			this.scene = pScene;

			this._eType = EEntityTypes.SCENE_NODE;
		}

		create(): bool {
			super.create();

			this._m4fLocalMatrix        = new Mat4(1);
		    this._m4fWorldMatrix        = new Mat4(1);
		    this._m4fInverseWorldMatrix = new Mat4(1);
		    this._m3fNormalMatrix       = new Mat3(1);

		    this._v3fWorldPosition  = new Vec3();

		    this._v3fTranslation    = new Vec3(0);
		    this._v3fScale          = new Vec3(1);
		    this._qRotation         = new Quat4(0, 1);

		    return true;
		}

		destroy(): void {
			super.destroy();
		}

/**
		 * @deprecated
		 */

		render(): void {

		}

/**
		 * @deprecated
		 */

		prepareForRender(): void {

		}

/**
		 * @deprecated
		 */

		recursiveRender(): void {
// render myself
		    this.prepareForRender();
		    this.render();
// render my sibling
		    if (this.sibling) {
		        (<ISceneNode>(this.sibling)).recursiveRender();
		    }
// render my child
		    if (this.child) {
		        (<ISceneNode>(this.child)).recursiveRender();
		    }
		}


		attachToParent(pParent: IEntity): bool {
			if ((<ISceneNode>pParent).scene !== this._pScene) {
				logger.setSourceLocation( "SceneNode.ts" , 82 ); logger.warning("transfer of the scene node between trees scene - forbidden"); ;
				return false;
			}

			return super.attachToParent(pParent);
		}

		toString(isRecursive: bool = false, iDepth:  number  = 0): string {
			if (!isRecursive) {
		        return "<scene_node" + (this.name? " " + this.name: "") + ">";
		    }

		    return super.toString(isRecursive, iDepth);
		}

	}
}




















module akra {

	export interface IVec3 {} ;
	export interface ICircle {} ;

	export interface ISphere {

		center: IVec3;
		radius:  number ;

		circle: ICircle;
		z:  number ;

		set(): ISphere;
		set(pSphere: ISphere): ISphere;
		set(v3fCenter: IVec3, fRadius:  number ): ISphere;
		set(fCenterX:  number , fCenterY:  number , fCenterZ:  number , fRadius:  number ): ISphere;

		clear(): ISphere;

		isEqual(pSphere: ISphere): bool;
		isClear(): bool;
		isValid(): bool;

		offset(v3fOffset: IVec3): ISphere;
		expand(fInc:  number ): ISphere;
		normalize(): ISphere;

		transform(m4fMatrix: IMat4): ISphere;
	};
};












module akra {

	export interface IVec2 {} ;

	export interface ICircle {

		radius:  number ;
		center: IVec2;

		set(): ICircle;
		set(pCircle: ICircle): ICircle;
		set(v2fCenter: IVec2, fRadius:  number ): ICircle;
		set(fCenterX:  number , fCenterY:  number , fRadius:  number ): ICircle;

		clear(): ICircle;

		isEqual(pCircle: ICircle): bool;
		isClear(): bool;
		isValid(): bool;

		offset(v2fOffset: IVec2): ICircle;
		expand(fInc:  number ): ICircle;
		normalize(): ICircle;
	};
};



module akra.geometry{
	export class Circle implements ICircle{
		center: IVec2;
		radius:  number ;

		constructor();
		constructor(pCircle: ICircle);
		constructor(v2fCenter: IVec2, fRadius:  number );
		constructor(fCenterX:  number , fCenterY:  number , fRadius:  number );
		constructor(fCenterX?, fCenterY?, fRadius?){
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					var pCircle: ICircle = arguments[0];
					this.center = new Vec2(pCircle.center);
					this.radius = pCircle.radius;
					break;
				case 2:
					var v2fCenter: IVec2 = arguments[0];
					var fRadius:  number  = arguments[1];

					this.center = new Vec2(v2fCenter);
					this.radius = fRadius;
					break;
				case 3:
					this.center = new Vec2(arguments[0], arguments[1]);
					this.radius = arguments[2];
					break;
				default:
					this.center = new Vec2();
					this.radius = 0.;
					break;
			}
		};

		set(): ICircle;
		set(pCircle: ICircle): ICircle;
		set(v2fCenter: IVec2, fRadius:  number ): ICircle;
		set(fCenterX:  number , fCenterY:  number , fRadius:  number ): ICircle;
		set(fCenterX?, fCenterY?, fRadius?): ICircle{
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					var pCircle: ICircle = arguments[0];
					this.center.set(pCircle.center);
					this.radius = pCircle.radius;
					break;
				case 2:
					var v2fCenter: IVec2 = arguments[0];
					var fRadius:  number  = arguments[1];

					this.center.set(v2fCenter);
					this.radius = fRadius;
					break;
				case 3:
					this.center.set(arguments[0], arguments[1]);
					this.radius = arguments[2];
					break;
				default:
					this.center.set(0.);
					this.radius = 0.;
			}

			return this;
		};

		/**@inline*/  clear(): ICircle{
			this.center.clear();
			this.radius = 0.;

			return this;
		};

		/**@inline*/  isEqual(pCircle: ICircle): bool{
			return this.center.isEqual(pCircle.center) && (this.radius == pCircle.radius);
		};

		/**@inline*/  isClear(): bool{
			return this.center.isClear() && (this.radius === 0.);
		};

		/**@inline*/  isValid(): bool{
			return (this.radius >= 0.);
		};

		/**@inline*/  offset(v2fOffset: IVec2): ICircle{
			this.center.add(v2fOffset);
			return this;
		};

		/**@inline*/  expand(fInc:  number ): ICircle{
			this.radius += fInc;
			return this;
		};

		/**@inline*/  normalize(): ICircle{
			this.radius = math.abs(this.radius);
			return this;
		};
	};
};



module akra.geometry{
	export class Sphere implements ISphere{
		center: IVec3;
		radius:  number ;

		constructor();
		constructor(pSphere: ISphere);
		constructor(v3fCenter: IVec3, fRadius:  number );
		constructor(fCenterX:  number , fCenterY:  number , fCenterZ:  number , fRadius:  number );
		constructor(fCenterX?, fCenterY?, fCenterZ?, fRadius?){
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					var pSphere = arguments[0];

					this.center = new Vec3(pSphere.v3fCenter);
					this.radius = pSphere.fRadius;
					break;
				case 2:
					var v3fCenter: IVec3 = arguments[0];
					var fRadius:  number  = arguments[1];

					this.center = new Vec3(v3fCenter);
					this.radius = fRadius;
					break;
				case 4:
					this.center = new Vec3(arguments[0], arguments[1], arguments[2]);
					this.radius = arguments[3];
					break;
				default:
					this.center = new Vec3();
					this.radius = 0.;
					break;
			}
		};

		get circle(): ICircle{
			var v3fCenter: IVec3 = this.center;
			return new Circle(v3fCenter.x, v3fCenter.y, this.radius);
		};
		set circle(pCircle: ICircle){
			var v3fCenter: IVec3 = this.center;
			var v2fCircleCenter: IVec2 = pCircle.center;
			v3fCenter.x = v2fCircleCenter.x;
			v3fCenter.y = v2fCircleCenter.y;
			this.radius = pCircle.radius;
		};

		get z():  number {
			return this.center.z;
		};
		set z(fZ:  number ){
			this.center.z = fZ;
		};

		set(): ISphere;
		set(pSphere: ISphere): ISphere;
		set(v3fCenter: IVec3, fRadius:  number ): ISphere;
		set(fCenterX:  number , fCenterY:  number , fCenterZ:  number , fRadius:  number ): ISphere;
		set(fCenterX?, fCenterY?, fCenterZ?, fRadius?): ISphere{
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					var pSphere = arguments[0];

					this.center.set(pSphere.center);
					this.radius = pSphere.radius;
					break;
				case 2:
					var v3fCenter: IVec3 = arguments[0];
					var fRadius:  number  = arguments[1];

					this.center.set(v3fCenter);
					this.radius = fRadius;
					break;
				case 4:
					this.center.set(arguments[0], arguments[1], arguments[2]);
					this.radius = arguments[3];
					break;
				default:
					this.center.set(0.);
					this.radius = 0.;
					break;
			}

			return this;
		};

		/**@inline*/  clear(): ISphere{
			this.center.clear();
			this.radius = 0.;

			return this;
		};

		/**@inline*/  isEqual(pSphere: ISphere): bool{
			return this.center.isEqual(pSphere.center) && (this.radius == pSphere.radius);
		};

		/**@inline*/  isClear(): bool{
			return this.center.isClear() && (this.radius === 0.);
		};

		/**@inline*/  isValid(): bool{
			return (this.radius >= 0.);
		};

		/**@inline*/  offset(v3fOffset: IVec3): ISphere{
			this.center.add(v3fOffset);
			return this;
		};

		/**@inline*/  expand(fInc:  number ): ISphere{
			this.radius += fInc;
			return this;
		};

		/**@inline*/  normalize(): ISphere{
			this.radius = math.abs(this.radius);
			return this;
		};

		transform(m4fMatrix: IMat4): ISphere {
			logger.setSourceLocation( "Sphere.ts" , 133 ); logger.criticalError("TODO: transform() for Sphere similar to Rect3d::transform();"); ;

			return this;
		}
	};
}












module akra{

	export interface IVec2 {} ;
	export interface ICircle {} ;

	export interface IRect2d{
		x0:  number ;
		x1:  number ;
		y0:  number ;
		y1:  number ;

		left:  number ;
		top:  number ;

		width:  number ;
		height:  number ;

		set(): IRect2d;
		set(pRect: IRect2d): IRect2d;
		set(v2fVec: IVec2): IRect2d;
		set(fSizeX:  number , fSizeY:  number ): IRect2d;
		set(fX0:  number , fX1:  number , fY0:  number , fY1:  number ): IRect2d;

		setFloor(pRect: IRect2d): IRect2d;
		setCeil(pRect: IRect2d): IRect2d;

		clear(): IRect2d;

		addSelf(fValue:  number ): IRect2d;
		addSelf(v2fVec: IVec2): IRect2d;

		subSelf(fValue:  number ): IRect2d;
		subSelf(v2fVec: IVec2): IRect2d;

		multSelf(fValue:  number ): IRect2d;
		multSelf(v2fVec: IVec2): IRect2d;

		divSelf(fValue:  number ): IRect2d;
		divSelf(v2fVec: IVec2): IRect2d;

		offset(v2fOffset: IVec2): IRect2d;
		offset(fOffsetX:  number , fOffsetY:  number ): IRect2d;

		expand(fValue:  number ): IRect2d;
		expand(v2fValue: IVec2): IRect2d;
		expand(fValueX:  number , fValueY:  number ): IRect2d;

		expandX(fValue:  number ): IRect2d;
		expandY(fValue:  number ): IRect2d;

		resize(v2fSize: IVec2): IRect2d;
		resize(fSizeX:  number , fSizeY:  number ): IRect2d;

		resizeX(fSize:  number ): IRect2d;
		resizeY(fSize:  number ): IRect2d;

		resizeMax(v2fSpan: IVec2): IRect2d;
		resizeMax(fSpanX:  number , fSpanY:  number ): IRect2d;

		resizeMaxX(fSpan:  number ): IRect2d;
		resizeMaxY(fSpan:  number ): IRect2d;

		resizeMin(v2fSpan: IVec2): IRect2d;
		resizeMin(fSpanX:  number , fSpanY:  number ): IRect2d;

		resizeMinX(fSpan:  number ): IRect2d;
		resizeMinY(fSpan:  number ): IRect2d;

		unionPoint(v2fPoint: IVec2): IRect2d;
		unionPoint(fX:  number , fY:  number ): IRect2d;
		unionRect(pRect: IRect2d): IRect2d;

		negate(pDestination?: IRect2d): IRect2d;
		normalize(): IRect2d;

		isEqual(pRect: IRect2d): bool;
		isClear(): bool;
		isValid(): bool;
		isPointInRect(v2fPoint: IVec2): bool;

		midPoint(v2fDestination?: IVec2): IVec2;
		midX():  number ;
		midY():  number ;

		size(v2fDestination?: IVec2): IVec2;
		sizeX():  number ;
		sizeY():  number ;

		minPoint(v2fDestination?: IVec2): IVec2;
		maxPoint(v2fDestination?: IVec2): IVec2;

		area():  number ;

		corner(iIndex:  number , v2fDestination?: IVec2): IVec2;

		createBoundingCircle(pCircle?: ICircle): ICircle;

		toString(): string;
	};
};





module akra.geometry{
	export class Rect2d implements IRect2d{
		x0:  number ;
		x1:  number ;
		y0:  number ;
		y1:  number ;

		/**@inline*/  get left():  number  { return this.x0; }
		/**@inline*/  get top():  number  { return this.y0; }
		/**@inline*/  get width():  number  { return this.x1 - this.x0; }
		/**@inline*/  get height():  number  { return this.y1 - this.y0; }

		constructor();
		constructor(pRect: IRect2d);
		constructor(v2fVec: IVec2);
		constructor(fSizeX:  number , fSizeY:  number );
		constructor(fX0:  number , fX1:  number , fY0:  number , fY1:  number );
		constructor(fX0?, fX1?, fY0?, fY1?){
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					this.set(arguments[0]);
					break;
				case 2:
					this.set(arguments[0], arguments[1]);
					break;
				case 4:
					this.set(arguments[0], arguments[1], arguments[2], arguments[3]);
					break;
				default:
					this.x0 = this.x1 = this.y0 = this.y1 = 0.;
					break;
			}
		};

		set(): IRect2d;
		set(pRect: IRect2d): IRect2d;
		set(v2fVec: IVec2): IRect2d;
		set(fSizeX:  number , fSizeY:  number ): IRect2d;
		set(fX0:  number , fX1:  number , fY0:  number , fY1:  number ): IRect2d;
		set(fX0?, fX1?, fY0?, fY1?): IRect2d{
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					if(arguments[0] instanceof Rect2d){
						var pRect: IRect2d = arguments[0];

						this.x0 = pRect.x0;
						this.x1 = pRect.x1;
						this.y0 = pRect.y0;
						this.y1 = pRect.y1;
					}
					else{
						var v2fSizes: IVec2 = arguments[0];

						this.x1 = v2fSizes.x*0.5;
						this.x0 = -this.x1;

						this.y1 = v2fSizes.y*0.5;
						this.y0 = -this.y1;
					}
					break;
				case 2:
					var fSizeX:  number  = arguments[0];
					var fSizeY:  number  = arguments[1];

					this.x1 = fSizeX*0.5;
					this.x0 = -this.x1;

					this.y1 = fSizeY*0.5;
					this.y0 = -this.y1;
					break;
				case 4:
					this.x0 = arguments[0];
					this.x1 = arguments[1];
					this.y0 = arguments[2];
					this.y1 = arguments[3];
					break;
				default:
					this.x0 = this.x1 = this.y0 = this.y1 = 0.;
					break;
			}

			return this;
		};

		setFloor(pRect: IRect2d): IRect2d{
			this.x0 = math.floor(pRect.x0);
			this.x1 = math.floor(pRect.x1);
			this.y0 = math.floor(pRect.y0);
			this.y1 = math.floor(pRect.y1);

			return this;
		};

		setCeil(pRect: IRect2d): IRect2d{
			this.x0 = math.ceil(pRect.x0);
			this.x1 = math.ceil(pRect.x1);
			this.y0 = math.ceil(pRect.y0);
			this.y1 = math.ceil(pRect.y1);

			return this;
		};

		/**@inline*/  clear(): IRect2d{
			this.x0 = this.x1 = this.y0 = this.y1 = 0.;
			return this;
		};

		addSelf(fValue:  number ): IRect2d;
		addSelf(v2fVec: IVec2): IRect2d;
		addSelf(v2fVec?): IRect2d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				this.x0 += fValue;
				this.x1 += fValue;
				this.y0 += fValue;
				this.y1 += fValue;
			}
			else{
				var v2fVec: IVec2 = arguments[0];

				this.x0 += v2fVec.x;
				this.x1 += v2fVec.x;

				this.y0 += v2fVec.y;
				this.y1 += v2fVec.y;
			}

			return this;
		};

		subSelf(fValue:  number ): IRect2d;
		subSelf(v2fVec: IVec2): IRect2d;
		subSelf(v2fVec?): IRect2d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				this.x0 -= fValue;
				this.x1 -= fValue;
				this.y0 -= fValue;
				this.y1 -= fValue;
			}
			else{
				var v2fVec: IVec2 = arguments[0];

				this.x0 -= v2fVec.x;
				this.x1 -= v2fVec.x;

				this.y0 -= v2fVec.y;
				this.y1 -= v2fVec.y;
			}

			return this;
		};

		multSelf(fValue:  number ): IRect2d;
		multSelf(v2fVec: IVec2): IRect2d;
		multSelf(v2fVec?): IRect2d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				this.x0 *= fValue;
				this.x1 *= fValue;
				this.y0 *= fValue;
				this.y1 *= fValue;
			}
			else{
				var v2fVec: IVec2 = arguments[0];

				this.x0 *= v2fVec.x;
				this.x1 *= v2fVec.x;

				this.y0 *= v2fVec.y;
				this.y1 *= v2fVec.y;
			}

			return this;
		};

		divSelf(fValue:  number ): IRect2d;
		divSelf(v2fVec: IVec2): IRect2d;
		divSelf(v2fVec?): IRect2d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];
				logger.setSourceLocation( "Rect2d.ts" , 196 ); logger.assert(fValue != 0.,"divide by zero error"); ;

				var fInvValue:  number  = 1./fValue;

				this.x0 *= fInvValue;
				this.x1 *= fInvValue;
				this.y0 *= fInvValue;
				this.y1 *= fInvValue;
			}
			else{
				var v2fVec: IVec2 = arguments[0];

				logger.setSourceLocation( "Rect2d.ts" , 208 ); logger.assert(v2fVec.x != 0.,"divide by zero error"); ;
				logger.setSourceLocation( "Rect2d.ts" , 209 ); logger.assert(v2fVec.y != 0.,"divide by zero error"); ;

				var fInvX:  number  = 1./v2fVec.x;
				var fInvY:  number  = 1./v2fVec.y;

				this.x0 *= fInvX;
				this.x1 *= fInvX;

				this.y0 *= fInvY;
				this.y1 *= fInvY;
			}

			return this;
		};

		offset(v2fOffset: IVec2): IRect2d;
		offset(fOffsetX:  number , fOffsetY:  number ): IRect2d;
		offset(fOffsetX?, fOffsetY?): IRect2d{
			if(arguments.length === 1){
				var v2fOffset: IVec2 = arguments[0];

				this.x0 += v2fOffset.x;
				this.x1 += v2fOffset.x;

				this.y0 += v2fOffset.y;
				this.y1 += v2fOffset.y;
			}
			else{
				this.x0 += arguments[0];
				this.x1 += arguments[0];

				this.y0 += arguments[1];
				this.y1 += arguments[1];
			}

			return this;
		};

		expand(fValue:  number ): IRect2d;
		expand(v2fValue: IVec2): IRect2d;
		expand(fValueX:  number , fValueY:  number ): IRect2d;
		expand(fValueX?, fValueY?): IRect2d{
			if(arguments.length == 1){
				if(isFloat(arguments[0])){
					var fValue:  number  = arguments[0];

					this.x0 -= fValue;
					this.x1 += fValue;

					this.y0 -= fValue;
					this.y1 += fValue;
				}
				else{
					var v2fValue: IVec2 = v2fValue;

					this.x0 -= v2fValue.x;
					this.x1 += v2fValue.x;

					this.y0 -= v2fValue.y;
					this.y1 += v2fValue.y;
				}
			}
			else{
//arguments.length == 2

				this.x0 -= arguments[0];
				this.x1 += arguments[0];

				this.y0 -= arguments[1];
				this.y1 += arguments[1];
			}

			return this;
		};

		expandX(fValue:  number ): IRect2d{
			this.x0 -= fValue;
			this.x1 += fValue;

			return this;
		};

		expandY(fValue:  number ): IRect2d{
			this.y0 -= fValue;
			this.y1 += fValue;

			return this;
		};

		resize(v2fSize: IVec2): IRect2d;
		resize(fSizeX:  number , fSizeY:  number ): IRect2d;
		resize(fSizeX?, fSizeY?): IRect2d{
			var fSizeX:  number , fSizeY:  number ;

			if(arguments.length == 1){
				var v2fSize: IVec2 = arguments[0];

				fSizeX = v2fSize.x;
				fSizeY = v2fSize.y;
			}
			else{
				fSizeX = arguments[0];
				fSizeY = arguments[1];
			}

			this.x1 = (this.x0 + this.x1 + fSizeX)*0.5;
			this.x0 = this.x1 - fSizeX;

			this.y1 = (this.y0 + this.y1 + fSizeY)*0.5;
			this.y0 = this.y1 - fSizeY;

			return this;
		};

		/**@inline*/  resizeX(fSize:  number ): IRect2d{
			this.x1 = (this.x0 + this.x1 + fSize)*0.5;
			this.x0 = this.x1 - fSize;

			return this;
		};

		/**@inline*/  resizeY(fSize:  number ): IRect2d{
			this.y1 = (this.y0 + this.y1 + fSize)*0.5;
			this.y0 = this.y1 - fSize;

			return this;
		};

		resizeMax(v2fSpan: IVec2): IRect2d;
		resizeMax(fSpanX:  number , fSpanY:  number ): IRect2d;
		resizeMax(fSpanX?, fSpanY?): IRect2d{
			if(arguments.length == 1){
				var v2fSpan: IVec2 = arguments[0];

				this.x1 = this.x0 + v2fSpan.x;
				this.y1 = this.y0 + v2fSpan.y;
			}
			else{
				this.x1 = this.x0 + arguments[0];
				this.y1 = this.y0 + arguments[1];
			}

			return this;
		};

		/**@inline*/  resizeMaxX(fSpan:  number ): IRect2d{
			this.x1 = this.x0 + fSpan;
			return this;
		};

		/**@inline*/  resizeMaxY(fSpan:  number ): IRect2d{
			this.y1 = this.y0 + fSpan;
			return this;
		};

		resizeMin(v2fSpan: IVec2): IRect2d;
		resizeMin(fSpanX:  number , fSpanY:  number ): IRect2d;
		resizeMin(fSpanX?, fSpanY?): IRect2d{
			if(arguments.length == 1){
				var v2fSpan: IVec2 = arguments[0];

				this.x0 = this.x1 - v2fSpan.x;
				this.y0 = this.y1 - v2fSpan.y;
			}
			else{
				this.x0 = this.x1 - arguments[0];
				this.y0 = this.y1 - arguments[1];
			}

			return this;
		};

		/**@inline*/  resizeMinX(fSpan:  number ): IRect2d{
			this.x0 = this.x1 - fSpan;
			return this;
		};

		/**@inline*/  resizeMinY(fSpan:  number ): IRect2d{
			this.y0 = this.y1 - fSpan;
			return this;
		};

		unionPoint(v2fPoint: IVec2): IRect2d;
		unionPoint(fX:  number , fY:  number ): IRect2d;
		unionPoint(fX?, fY?): IRect2d{
			if(arguments.length == 1){
				var v2fPoint: IVec2 = arguments[0];

				this.x0 = math.min(this.x0, v2fPoint.x);
				this.x1 = math.max(this.x1, v2fPoint.x);

				this.y0 = math.min(this.y0, v2fPoint.y);
				this.y1 = math.max(this.y1, v2fPoint.y);
			}
			else{
				var fX:  number  = arguments[0];
				var fY:  number  = arguments[1];

				this.x0 = math.min(this.x0, fX);
				this.x1 = math.max(this.x1, fX);

				this.y0 = math.min(this.y0, fY);
				this.y1 = math.max(this.y1, fY);
			}

			return this;
		};

		unionRect(pRect: IRect2d): IRect2d{
			this.normalize();
			pRect.normalize();

			this.x0 = math.min(this.x0, pRect.x0);
			this.x1 = math.max(this.x1, pRect.x1);

			this.y0 = math.min(this.y0, pRect.y0);
			this.y1 = math.max(this.y1, pRect.y1);

			return this;
		};

		negate(pDestination?: IRect2d): IRect2d{
			if(!isDef(pDestination)){
				pDestination = this;
			}

			return pDestination.set(-this.x1, -this.x0, -this.y1, -this.y0);
		};

		normalize(): IRect2d{
			var fTmp:  number ;
			if(this.x0 > this.x1){
				fTmp = this.x0;
				this.x0 = this.x1;
				this.x1 = fTmp;
			}
			if(this.y0 > this.y1){
				fTmp = this.y0;
				this.y0 = this.y1;
				this.y1 = fTmp;
			}
			return this;
		};

		/**@inline*/  isEqual(pRect: IRect2d): bool{
			return 	this.x0 == pRect.x0 && this.x1 == pRect.x1
					&& this.y0 == pRect.y0 && this.y1 == pRect.y1;
		};

		/**@inline*/  isClear(): bool{
			return this.x0 == 0. && this.x1 == 0. && this.y0 == 0. && this.y1 == 0.;
		};

		/**@inline*/  isValid(): bool{
			return this.x0 <= this.x1 && this.y0 <= this.y1;
		};

		/**@inline*/  isPointInRect(v2fPoint: IVec2): bool{
			var x:  number  = v2fPoint.x;
			var y:  number  = v2fPoint.y;

			return (this.x0 <= x && x <= this.x1) && (this.y0 <= y && y <= this.y1);
		};

		midPoint(v2fDestination?: IVec2): IVec2{
			if(!isDef(v2fDestination)){
				v2fDestination = new Vec2();
			}

			v2fDestination.x = (this.x0 + this.x1)*0.5;
			v2fDestination.y = (this.y0 + this.y1)*0.5;

			return v2fDestination;
		};

		/**@inline*/  midX():  number {
			return (this.x0 + this.x1)*0.5;
		};

		/**@inline*/  midY():  number {
			return (this.y0 + this.y1)*0.5;
		};

		size(v2fDestination?: IVec2): IVec2{
			if(!isDef(v2fDestination)){
				v2fDestination = new Vec2();
			}

			v2fDestination.x = this.x1 - this.x0;
			v2fDestination.y = this.y1 - this.y0;

			return v2fDestination;
		};

		/**@inline*/  sizeX():  number {
			return this.x1 - this.x0;
		};

		/**@inline*/  sizeY():  number {
			return this.y1 - this.y0;
		};

		minPoint(v2fDestination?: IVec2): IVec2{
			if(!isDef(v2fDestination)){
				v2fDestination = new Vec2();
			}

			v2fDestination.x = this.x0;
			v2fDestination.y = this.y0;

			return v2fDestination;
		};

		maxPoint(v2fDestination?: IVec2): IVec2{
			if(!isDef(v2fDestination)){
				v2fDestination = new Vec2();
			}

			v2fDestination.x = this.x1;
			v2fDestination.y = this.y1;

			return v2fDestination;
		};

		/**@inline*/  area():  number {
			return (this.x1 - this.x0)*(this.y1 - this.y0);
		};

/**
		 * counter-clockwise
		 * x0,y0 -> x1,y0 -> x1,y1 -> x0,y1;
		 */


		corner(iIndex:  number , v2fDestination?: IVec2): IVec2{
			if(!isDef(v2fDestination)){
				v2fDestination = new Vec2();
			}

			logger.setSourceLocation( "Rect2d.ts" , 547 ); logger.assert(0 <= iIndex && iIndex < 4, "invalid index"); ;

			switch(iIndex){
				case 0:
					v2fDestination.set(this.x0, this.y0);
					break;
				case 1:
					v2fDestination.set(this.x1, this.y0);
					break;
				case 2:
					v2fDestination.set(this.x1, this.y1);
					break;
				case 3:
					v2fDestination.set(this.x0, this.y1);
					break;
			};
			return v2fDestination;
		};

		createBoundingCircle(pCircle?: ICircle): ICircle{
			if(!isDef(pCircle)){
				pCircle = new Circle();
			}

			var fX0:  number  = this.x0, fX1:  number  = this.x1;
			var fY0:  number  = this.y0, fY1:  number  = this.y1;

			var fHalfSizeX:  number  = (fX1 - fX0)*0.5;
			var fHalfSizeY:  number  = (fY1 - fY0)*0.5;

			pCircle.set((fX0 + fX1)*0.5, (fY0 + fY1)*0.5,
				math.sqrt(fHalfSizeX*fHalfSizeX + fHalfSizeY*fHalfSizeY));

			return pCircle;
		};

		toString(): string{
			return "(" + this.x0 + ", " + this.y0 + ") --> (" +
					this.x1 + ", " + this.y1 + ")";
		};
	};
}






module akra {

	export interface IRect2d {} ;
	export interface IVec3 {} ;

	export interface IRect3d {
		x0:  number ;
		x1:  number ;
		y0:  number ;
		y1:  number ;
		z0:  number ;
		z1:  number ;

		rect2d: IRect2d;

		set(): IRect3d;
		set(pRect: IRect3d): IRect3d;
		set(v3fSize: IVec3): IRect3d;
		set(fSizeX:  number , fSizeY:  number , fSizeZ:  number ): IRect3d;
		set(v3fMinPoint: IVec3, v3fMaxPoint: IVec3): IRect3d;
		set(fX0:  number , fX1:  number , fY0:  number ,
			fY1:  number , fZ0:  number , fZ1:  number ): IRect3d;

		setFloor(pRect: IRect3d): IRect3d;
		setCeil(pRect: IRect3d): IRect3d;

		clear(): IRect3d;

		addSelf(fValue:  number ): IRect3d;
		addSelf(v3fVec: IVec3): IRect3d;

		subSelf(fValue:  number ): IRect3d;
		subSelf(v3fVec: IVec3): IRect3d;

		multSelf(fValue:  number ): IRect3d;
		multSelf(v3fVec: IVec3): IRect3d;

		divSelf(fValue:  number ): IRect3d;
		divSelf(v3fVec: IVec3): IRect3d;

		offset(v3fOffset: IVec3): IRect3d;
		offset(fOffsetX:  number , fOffsetY:  number , fOffsetZ:  number ): IRect3d;

		expand(fValue:  number ): IRect3d;
		expand(v3fVec: IVec3): IRect3d;
		expand(fValueX:  number , fValueY:  number , fValueZ:  number ): IRect3d;

		expandX(fValue:  number ): IRect3d;
		expandY(fValue:  number ): IRect3d;
		expandZ(fValue:  number ): IRect3d;

		resize(v3fSize: IVec3): IRect3d;
		resize(fSizeX:  number , fSizeY:  number , fSizeZ:  number ): IRect3d;

		resizeX(fSize:  number ): IRect3d;
		resizeY(fSize:  number ): IRect3d;
		resizeZ(fSize:  number ): IRect3d;

		resizeMax(v3fSpan: IVec3): IRect3d;
		resizeMax(fSpanX:  number , fSpanY:  number , fSpanZ:  number ): IRect3d;

		resizeMaxX(fSpan:  number ): IRect3d;
		resizeMaxY(fSpan:  number ): IRect3d;
		resizeMaxZ(fSpan:  number ): IRect3d;

		resizeMin(v3fSpan: IVec3): IRect3d;
		resizeMin(fSpanX:  number , fSpanY:  number , fSpanZ:  number ): IRect3d;

		resizeMinX(fSpan:  number ): IRect3d;
		resizeMinY(fSpan:  number ): IRect3d;
		resizeMinZ(fSpan:  number ): IRect3d;

		unionPoint(v3fPoint: IVec3): IRect3d;
		unionPoint(fX:  number , fY:  number , fZ:  number ): IRect3d;
		unionRect(pRect: IRect3d): IRect3d;

		negate(pDestination?: IRect3d): IRect3d;
		normalize(): IRect3d;

		transform(m4fMatrix: IMat4): IRect3d;

		isEqual(pRect: IRect3d): bool;
		isClear(): bool;
		isValid(): bool;
		isPointInRect(v3fPoint: IVec3): bool;

		midPoint(v3fDestination?: IVec3): IVec3;
		midX():  number ;
		midY():  number ;
		midZ():  number ;

		size(v3fDestination: IVec3): IVec3;
		sizeX():  number ;
		sizeY():  number ;
		sizeZ():  number ;

		minPoint(v3fDestination?: IVec3): IVec3;
		maxPoint(v3fDestination?: IVec3): IVec3;

		volume():  number ;

		corner(iIndex:  number , v3fDestination?: IVec3): IVec3;

		createBoundingSphere(pSphere?: ISphere): ISphere;

		toString(): string;
	}
}





module akra.geometry {
    export class Rect3d implements IRect3d{
    	x0:  number ;
    	x1:  number ;
		y0:  number ;
		y1:  number ;
		z0:  number ;
		z1:  number ;

		constructor();
		constructor(pRect: IRect3d);
		constructor(v3fSize: IVec3);
		constructor(fSizeX:  number , fSizeY:  number , fSizeZ:  number );
		constructor(v3fMinPoint: IVec3, v3fMaxPoint: IVec3);
		constructor(fX0:  number , fX1:  number , fY0:  number ,
					fY1:  number , fZ0:  number , fZ1:  number );
		constructor(fX0?, fX1?, fY0?, fY1?, fZ0?, fZ1?){
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					this.set(arguments[0]);
					break;
				case 2:
					this.set(arguments[0], arguments[1]);
					break;
				case 3:
					this.set(arguments[0], arguments[1], arguments[2]);
					break;
				case 6:
					this.set(arguments[0], arguments[1], arguments[2],
							arguments[3], arguments[4], arguments[5]);
					break;
				default:
					this.x0 = this.x1 = this.y0 = this.y1 = this.z0 = this.z1 = 0.;
					break;
			}
		};

		get rect2d(): IRect2d{
			return new Rect2d(this.x0, this.x1, this.y0, this.y1);
		};

		set rect2d(pRect: IRect2d){
			this.x0 = pRect.x0;
			this.x1 = pRect.x1;
			this.y0 = pRect.y0;
			this.y1 = pRect.y1;
		};

		set(): IRect3d;
		set(pRect: IRect3d): IRect3d;
		set(v3fSize: IVec3): IRect3d;
		set(fSizeX:  number , fSizeY:  number , fSizeZ:  number ): IRect3d;
		set(v3fMinPoint: IVec3, v3fMaxPoint: IVec3): IRect3d;
		set(fX0:  number , fX1:  number , fY0:  number ,
			fY1:  number , fZ0:  number , fZ1:  number ): IRect3d;
		set(fX0?, fX1?, fY0?, fY1?, fZ0?, fZ1?): IRect3d{
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					if(arguments[0] instanceof Rect3d){
						var pRect: IRect3d = arguments[0];

						this.x0 = pRect.x0;
						this.x1 = pRect.x1;
						this.y0 = pRect.y0;
						this.y1 = pRect.y1;
						this.z0 = pRect.z0;
						this.z1 = pRect.z1;
					}
					else{
						var v3fSize: IVec3 = arguments[0];

						this.x1 = v3fSize.x*0.5;
						this.x0 = -this.x1;

						this.y1 = v3fSize.y*0.5;
						this.y0 = -this.y1;

						this.z1 = v3fSize.z*0.5;
						this.z0 = -this.z1;
					}
					break;
				case 2:
					var v3fMinPoint: IVec3 = arguments[0];
					var v3fMaxPoint: IVec3 = arguments[1];

					this.x0 = v3fMinPoint.x;
					this.y0 = v3fMinPoint.y;
					this.z0 = v3fMinPoint.z;

					this.x1 = v3fMaxPoint.x;
					this.y1 = v3fMaxPoint.y;
					this.z1 = v3fMaxPoint.z;
					break;
				case 3:
					var fSizeX:  number  = arguments[0];
					var fSizeY:  number  = arguments[1];
					var fSizeZ:  number  = arguments[2];

					this.x1 = fSizeX*0.5;
					this.x0 = -this.x1;

					this.y1 = fSizeY*0.5;
					this.y0 = -this.y1;

					this.z1 = fSizeZ*0.5;
					this.z0 = -this.z1;
					break;
				case 6:
					this.x0 = arguments[0];
					this.x1 = arguments[1];

					this.y0 = arguments[2];
					this.y1 = arguments[3];

					this.z0 = arguments[4];
					this.z1 = arguments[5];
					break;
				default:
					this.x0 = this.x1 = this.y0 = this.y1 = this.z0 = this.z1 = 0.;
					break;
			}
			return this;
		};

		setFloor(pRect: IRect3d): IRect3d{
			this.x0 = math.floor(pRect.x0);
			this.x1 = math.floor(pRect.x1);
			this.y0 = math.floor(pRect.y0);
			this.y1 = math.floor(pRect.y1);
			this.z0 = math.floor(pRect.z0);
			this.z1 = math.floor(pRect.z1);

			return this;
		};

		setCeil(pRect: IRect3d): IRect3d{
			this.x0 = math.ceil(pRect.x0);
			this.x1 = math.ceil(pRect.x1);
			this.y0 = math.ceil(pRect.y0);
			this.y1 = math.ceil(pRect.y1);
			this.z0 = math.ceil(pRect.z0);
			this.z1 = math.ceil(pRect.z1);

			return this;
		};

		/**@inline*/  clear(): IRect3d{
			this.x0 = this.x1 = this.y0 = this.y1 = this.z0 = this.z1 = 0.;
			return this;
		};

		addSelf(fValue:  number ): IRect3d;
		addSelf(v3fVec: IVec3): IRect3d;
		addSelf(v3fVec?): IRect3d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				this.x0 += fValue;
				this.x1 += fValue;
				this.y0 += fValue;
				this.y1 += fValue;
				this.z0 += fValue;
				this.z1 += fValue;
			}
			else{
				var v3fVec: IVec3 = arguments[0];

				this.x0 += v3fVec.x;
				this.x1 += v3fVec.x;

				this.y0 += v3fVec.y;
				this.y1 += v3fVec.y;

				this.z0 += v3fVec.z;
				this.z1 += v3fVec.z;
			}

			return this;
		};


		subSelf(fValue:  number ): IRect3d;
		subSelf(v3fVec: IVec3): IRect3d;
		subSelf(v3fVec?): IRect3d{
			if(isFloat(fValue)){
				var fValue:  number  = arguments[0];

				this.x0 -= fValue;
				this.x1 -= fValue;
				this.y0 -= fValue;
				this.y1 -= fValue;
				this.z0 -= fValue;
				this.z1 -= fValue;
			}
			else{
				var v3fVec: IVec3 = arguments[0];

				this.x0 -= v3fVec.x;
				this.x1 -= v3fVec.x;

				this.y0 -= v3fVec.y;
				this.y1 -= v3fVec.y;

				this.z0 -= v3fVec.z;
				this.z1 -= v3fVec.z;
			}

			return this;
		};

		multSelf(fValue:  number ): IRect3d;
		multSelf(v3fVec: IVec3): IRect3d;
		multSelf(v3fVec?): IRect3d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				this.x0 *= fValue;
				this.x1 *= fValue;
				this.y0 *= fValue;
				this.y1 *= fValue;
				this.z0 *= fValue;
				this.z1 *= fValue;
			}
			else{
				var v3fVec: IVec3 = arguments[0];

				this.x0 *= v3fVec.x;
				this.x1 *= v3fVec.x;

				this.y0 *= v3fVec.y;
				this.y1 *= v3fVec.y;

				this.z0 *= v3fVec.z;
				this.z1 *= v3fVec.z;
			}

			return this;
		};

		divSelf(fValue:  number ): IRect3d;
		divSelf(v3fVec: IVec3): IRect3d;
		divSelf(v3fVec?): IRect3d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				logger.setSourceLocation( "geometry/Rect3d.ts" , 261 ); logger.assert(fValue != 0.0, "divide by zero error"); ;

				var fInvValue:  number  = 1./fValue;

				this.x0 *= fInvValue;
				this.x1 *= fInvValue;
				this.y0 *= fInvValue;
				this.y1 *= fInvValue;
				this.z0 *= fInvValue;
				this.z1 *= fInvValue;
			}
			else{
				var v3fVec: IVec3 = arguments[0];

				logger.setSourceLocation( "geometry/Rect3d.ts" , 275 ); logger.assert(v3fVec.x != 0.0, "divide by zero error"); ;
				logger.setSourceLocation( "geometry/Rect3d.ts" , 276 ); logger.assert(v3fVec.y != 0.0, "divide by zero error"); ;
				logger.setSourceLocation( "geometry/Rect3d.ts" , 277 ); logger.assert(v3fVec.z != 0.0, "divide by zero error"); ;

				var fInvX:  number  = 1./v3fVec.x;
				var fInvY:  number  = 1./v3fVec.y;
				var fInvZ:  number  = 1./v3fVec.z;

				this.x0 *= fInvX;
				this.x1 *= fInvX;

				this.y0 *= fInvY;
				this.y1 *= fInvY;

				this.z0 *= fInvZ;
				this.z1 *= fInvZ;
			}

			return this;
		};

		offset(v3fOffset: IVec3): IRect3d;
		offset(fOffsetX:  number , fOffsetY:  number , fOffsetZ:  number ): IRect3d;
		offset(fOffsetX?, fOffsetY?, fOffsetZ?): IRect3d{
			if(arguments.length === 1){
				var v3fOffset: IVec3 = arguments[0];

				this.x0 += v3fOffset.x;
				this.x1 += v3fOffset.x;

				this.y0 += v3fOffset.y;
				this.y1 += v3fOffset.y;

				this.z0 += v3fOffset.z;
				this.z1 += v3fOffset.z;
			}
			else{
				this.x0 += arguments[0];
				this.x1 += arguments[0];

				this.y0 += arguments[1];
				this.y1 += arguments[1];

				this.z0 += arguments[2];
				this.z1 += arguments[2];
			}

			return this;
		};

		expand(fValue:  number ): IRect3d;
		expand(v3fVec: IVec3): IRect3d;
		expand(fValueX:  number , fValueY:  number , fValueZ:  number ): IRect3d;
		expand(fValueX?, fValueY?, fValueZ?): IRect3d{
			if(arguments.length === 1){
				if(isFloat(arguments[0])){
					var fValue:  number  = arguments[0];

					this.x0 -= fValue;
					this.x1 += fValue;

					this.y0 -= fValue;
					this.y1 += fValue;

					this.z0 -= fValue;
					this.z1 += fValue;
				}
				else{
					var v3fVec: IVec3 = arguments[0];

					this.x0 -= v3fVec.x;
					this.x1 += v3fVec.x;

					this.y0 -= v3fVec.y;
					this.y1 += v3fVec.y;

					this.z0 -= v3fVec.z;
					this.z1 += v3fVec.z;
				}
			}
			else{
//arguments.length === 3

				this.x0 -= arguments[0];
				this.x1 += arguments[0];

				this.y0 -= arguments[1];
				this.y1 += arguments[1];

				this.z0 -= arguments[2];
				this.z1 += arguments[2];
			}

			return this;
		};

		/**@inline*/  expandX(fValue:  number ): IRect3d{
			this.x0 -= fValue;
			this.x1 += fValue;

			return this;
		};

		/**@inline*/  expandY(fValue:  number ): IRect3d{
			this.y0 -= fValue;
			this.y1 += fValue;

			return this;
		};

		/**@inline*/  expandZ(fValue:  number ): IRect3d{
			this.z0 -= fValue;
			this.z1 += fValue;

			return this;
		};

		resize(v3fSize: IVec3): IRect3d;
		resize(fSizeX:  number , fSizeY:  number , fSizeZ:  number ): IRect3d;
		resize(fSizeX?, fSizeY?, fSizeZ?): IRect3d{
			var fSizeX:  number , fSizeY:  number , fSizeZ:  number ;

			if(arguments.length === 1){
				var v3fSize: IVec3 = arguments[0];

				fSizeX = v3fSize.x;
				fSizeY = v3fSize.y;
				fSizeZ = v3fSize.z;
			}
			else{
				fSizeX = arguments[0];
				fSizeY = arguments[1];
				fSizeZ = arguments[2];
			}

			this.x1 = (this.x0 + this.x1 + fSizeX)*0.5;
			this.x0 = this.x1 - fSizeX;

			this.y1 = (this.y0 + this.y1 + fSizeY)*0.5;
			this.y0 = this.y1 - fSizeY;

			this.z1 = (this.z0 + this.z1 + fSizeZ)*0.5;
			this.z0 = this.z1 - fSizeZ;

			return this;
		};

		/**@inline*/  resizeX(fSize:  number ): IRect3d{
			this.x1 = (this.x0 + this.x1 + fSize)*0.5;
			this.x0 = this.x1 - fSize;

			return this;
		};

		/**@inline*/  resizeY(fSize:  number ): IRect3d{
			this.y1 = (this.y0 + this.y1 + fSize)*0.5;
			this.y0 = this.y1 - fSize;

			return this;
		};

		/**@inline*/  resizeZ(fSize:  number ): IRect3d{
			this.z1 = (this.z0 + this.z1 + fSize)*0.5;
			this.z0 = this.z1 - fSize;

			return this;
		};

		resizeMax(v3fSpan: IVec3): IRect3d;
		resizeMax(fSpanX:  number , fSpanY:  number , fSpanZ:  number ): IRect3d;
		resizeMax(fSpanX?, fSpanY?, fSpanZ?): IRect3d{
			if(arguments.length === 1){
				var v3fSpan: IVec3 = arguments[0];

				this.x1 = this.x0 + v3fSpan.x;
				this.y1 = this.y0 + v3fSpan.y;
				this.z1 = this.z0 + v3fSpan.z;
			}
			else{
//arguments.length === 3
				this.x1 = this.x0 + arguments[0];
				this.y1 = this.y0 + arguments[1];
				this.z1 = this.z0 + arguments[2];
			}

			return this;
		};

		/**@inline*/  resizeMaxX(fSpan:  number ): IRect3d{
			this.x1 = this.x0 + fSpan;
			return this;
		};

		/**@inline*/  resizeMaxY(fSpan:  number ): IRect3d{
			this.y1 = this.y0 + fSpan;
			return this;
		};

		/**@inline*/  resizeMaxZ(fSpan:  number ): IRect3d{
			this.z1 = this.z0 + fSpan;
			return this;
		};

		resizeMin(v3fSpan: IVec3): IRect3d;
		resizeMin(fSpanX:  number , fSpanY:  number , fSpanZ:  number ): IRect3d;
		resizeMin(fSpanX?, fSpanY?, fSpanZ?): IRect3d{
			if(arguments.length === 1){
				var v3fSpan: IVec3 = arguments[0];

				this.x0 = this.x1 - v3fSpan.x;
				this.y0 = this.y1 - v3fSpan.y;
				this.z0 = this.z1 - v3fSpan.z;
			}
			else{
//arguments.length === 3
				this.x0 = this.x1 - arguments[0];
				this.y0 = this.y1 - arguments[1];
				this.z0 = this.z1 - arguments[2];
			}

			return this;
		};

		/**@inline*/  resizeMinX(fSpan:  number ): IRect3d{
			this.x0 = this.x1 - fSpan;
			return this;
		};

		/**@inline*/  resizeMinY(fSpan:  number ): IRect3d{
			this.y0 = this.y1 - fSpan;
			return this;
		};

		/**@inline*/  resizeMinZ(fSpan:  number ): IRect3d{
			this.z0 = this.z1 - fSpan;
			return this;
		};

		unionPoint(v3fPoint: IVec3): IRect3d;
		unionPoint(fX:  number , fY:  number , fZ:  number ): IRect3d;
		unionPoint(fX?, fY?, fZ?): IRect3d{
			if(arguments.length === 1){
				var v3fPoint: IVec3 = arguments[0];

				this.x0 = math.min(this.x0, v3fPoint.x);
				this.x1 = math.max(this.x1, v3fPoint.x);

				this.y0 = math.min(this.y0, v3fPoint.y);
				this.y1 = math.max(this.y1, v3fPoint.y);

				this.z0 = math.min(this.z0, v3fPoint.z);
				this.z1 = math.max(this.z1, v3fPoint.z);
			}
			else{
//arguments.length === 3

				this.x0 = math.min(this.x0, arguments[0]);
				this.x1 = math.max(this.x1, arguments[0]);

				this.y0 = math.min(this.y0, arguments[1]);
				this.y1 = math.max(this.y1, arguments[1]);

				this.z0 = math.min(this.z0, arguments[2]);
				this.z1 = math.max(this.z1, arguments[2]);
			}

			return this;
		};

		unionRect(pRect: IRect3d): IRect3d{
			console.log(this,pRect);
			this.normalize();
			pRect.normalize();

			this.x0 = math.min(this.x0, pRect.x0);
			this.x1 = math.max(this.x1, pRect.x1);

			this.y0 = math.min(this.y0, pRect.y0);
			this.y1 = math.max(this.y1, pRect.y1);

			this.z0 = math.min(this.z0, pRect.z0);
			this.z1 = math.max(this.z1, pRect.z1);

			return this;
		};

		negate(pDestination?: IRect3d): IRect3d{
			if(!isDef(pDestination)){
				pDestination = this;
			}

			return pDestination.set(-this.x1, -this.x0,
							 -this.y1, -this.y0,
							 -this.z1, -this.z0);
		};

		normalize(): IRect3d{
			var fTmp:  number ;
			if(this.x0 > this.x1){
				fTmp = this.x0;
				this.x0 = this.x1;
				this.x1 = fTmp;
			}
			if(this.y0 > this.y1){
				fTmp = this.y0;
				this.y0 = this.y1;
				this.y1 = fTmp;
			}
			if(this.z0 > this.z1){
				fTmp = this.z0;
				this.z0 = this.z1;
				this.z1 = fTmp;
			}

			return this;
		};

		transform(m4fMatrix: IMat4): IRect3d{
			var pData: Float32Array = m4fMatrix.data;

			var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ],
				a13:  number  = pData[ 8 ], a14:  number  = pData[ 12 ];
			var a21:  number  = pData[ 1 ], a22:  number  = pData[ 5 ],
				a23:  number  = pData[ 9 ], a24:  number  = pData[ 13 ];
			var a31:  number  = pData[ 2 ], a32:  number  = pData[ 6 ],
				a33:  number  = pData[ 10 ], a34:  number  = pData[ 14 ];

			var fX0:  number  = this.x0, fX1:  number  = this.x1;
			var fY0:  number  = this.y0, fY1:  number  = this.y1;
			var fZ0:  number  = this.z0, fZ1:  number  = this.z1;

//base point

			var fBaseX:  number  = a11*fX0 + a12*fY0 + a13*fZ0 + a14;
			var fBaseY:  number  = a21*fX0 + a22*fY0 + a23*fZ0 + a24;
			var fBaseZ:  number  = a31*fX0 + a32*fY0 + a33*fZ0 + a34;

//new x vector

			var fXNewX:  number  = a11*(fX1 - fX0);
			var fXNewY:  number  = a21*(fX1 - fX0);
			var fXNewZ:  number  = a31*(fX1 - fX0);

//new y vector

			var fYNewX:  number  = a12*(fY1 - fY0);
			var fYNewY:  number  = a22*(fY1 - fY0);
			var fYNewZ:  number  = a32*(fY1 - fY0);

//new z vector

			var fZNewX:  number  = a13*(fZ1 - fZ0);
			var fZNewY:  number  = a23*(fZ1 - fZ0);
			var fZNewZ:  number  = a33*(fZ1 - fZ0);

			var fXMultX:  number  = (fXNewX > 0.) ? 1. : 0.;
			var fYMultX:  number  = (fYNewX > 0.) ? 1. : 0.;
			var fZMultX:  number  = (fZNewX > 0.) ? 1. : 0.;

			var fXMultY:  number  = (fXNewY > 0.) ? 1. : 0.;
			var fYMultY:  number  = (fYNewY > 0.) ? 1. : 0.;
			var fZMultY:  number  = (fZNewY > 0.) ? 1. : 0.;

			var fXMultZ:  number  = (fXNewZ > 0.) ? 1. : 0.;
			var fYMultZ:  number  = (fYNewZ > 0.) ? 1. : 0.;
			var fZMultZ:  number  = (fZNewZ > 0.) ? 1. : 0.;

			this.x1 = fBaseX + fXMultX*fXNewX + fYMultX*fYNewX + fZMultX*fZNewX;
			this.y1 = fBaseY + fXMultY*fXNewY + fYMultY*fYNewY + fZMultY*fZNewY;
			this.z1 = fBaseZ + fXMultZ*fXNewZ + fYMultZ*fYNewZ + fZMultZ*fZNewZ;

			this.x0 = fBaseX + (1. - fXMultX)*fXNewX + (1. - fYMultX)*fYNewX + (1. - fZMultX)*fZNewX;
			this.y0 = fBaseY + (1. - fXMultY)*fXNewY + (1. - fYMultY)*fYNewY + (1. - fZMultY)*fZNewY;
			this.z0 = fBaseZ + (1. - fXMultZ)*fXNewZ + (1. - fYMultZ)*fYNewZ + (1. - fZMultZ)*fZNewZ;

			return this;
		};

		/**@inline*/  isEqual(pRect: IRect3d): bool{
			return this.x0 == pRect.x0 && this.x1 == pRect.x1
					&& this.y0 == pRect.y0 && this.y1 == pRect.y1
					&& this.z0 == pRect.z0 && this.z1 == pRect.z1;
		};

		/**@inline*/  isClear(): bool{
			return this.x0 == 0. && this.x1 == 0.
					&& this.y0 == 0. && this.y1 == 0.
					&& this.z0 == 0. && this.z1 == 0.;
		};

		/**@inline*/  isValid(): bool{
			return this.x0 <= this.x1
					&& this.y0 <= this.y1
					&& this.z0 <= this.z1;
		};

		/**@inline*/  isPointInRect(v3fPoint: IVec3): bool{
			var x:  number  = v3fPoint.x;
			var y:  number  = v3fPoint.y;
			var z:  number  = v3fPoint.z;

			return (this.x0 <= x && x <= this.x1)
					&& (this.y0 <= y && y <= this.y1)
					&& (this.z0 <= z && z <= this.z1);
		};

		midPoint(v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			return v3fDestination.set((this.x0 + this.x1)*0.5,
									  (this.y0 + this.y1)*0.5,
									  (this.z0 + this.z1)*0.5);
		};

		/**@inline*/  midX():  number {
			return (this.x0 + this.x1)*0.5;
		};

		/**@inline*/  midY():  number {
			return (this.y0 + this.y1)*0.5;
		};

		/**@inline*/  midZ():  number {
			return (this.z0 + this.z1)*0.5;
		}

		size(v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			return v3fDestination.set(this.x1 - this.x0, this.y1 - this.y0, this.z1 - this.z0);
		};

		/**@inline*/  sizeX():  number {
			return this.x1 - this.x0;
		};

		/**@inline*/  sizeY():  number {
			return this.y1 - this.y0;
		};

		/**@inline*/  sizeZ():  number {
			return this.z1 - this.z0;
		};

		minPoint(v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			return v3fDestination.set(this.x0, this.y0, this.z0);
		};

		maxPoint(v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			return v3fDestination.set(this.x1, this.y1, this.z1);
		};

		/**@inline*/  volume():  number {
			return (this.x1 - this.x0)*(this.y1 - this.y0)*(this.z1 - this.z0);
		};

/**
		 * counter-clockwise and from bottom
		 * x0,y0,z0 -> x1,y0,z0 -> x1,y1,z0 -> x0,y1,z0 ->
		 * x0,y0,z1 -> x1,y0,z1 -> x1,y1,z1 -> x0,y1,z1
		 */

		corner(iIndex:  number , v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			logger.setSourceLocation( "geometry/Rect3d.ts" , 753 ); logger.assert(0 <= iIndex && iIndex < 8, "invalid index"); ;

			switch(iIndex){
				case 0:
					v3fDestination.set(this.x0, this.y0, this.z0);
					break;
				case 1:
					v3fDestination.set(this.x1, this.y0, this.z0);
					break;
				case 2:
					v3fDestination.set(this.x1, this.y1, this.z0);
					break;
				case 3:
					v3fDestination.set(this.x0, this.y1, this.z0);
					break;
				case 4:
					v3fDestination.set(this.x0, this.y0, this.z1);
					break;
				case 5:
					v3fDestination.set(this.x1, this.y0, this.z1);
					break;
				case 6:
					v3fDestination.set(this.x1, this.y1, this.z1);
					break;
				case 7:
					v3fDestination.set(this.x0, this.y1, this.z1);
					break;
			}
			return v3fDestination;
		};

		createBoundingSphere(pSphere?: ISphere): ISphere{
			if(!isDef(pSphere)){
				pSphere = new Sphere();
			}

			var fX0:  number  = this.x0, fX1:  number  = this.x1;
			var fY0:  number  = this.y0, fY1:  number  = this.y1;
			var fZ0:  number  = this.z0, fZ1:  number  = this.z1;

			var fHalfSizeX:  number  = (fX1 - fX0)*0.5;
			var fHalfSizeY:  number  = (fY1 - fY0)*0.5;
			var fHalfSizeZ:  number  = (fZ1 - fZ0)*0.5;

			pSphere.set((fX0 + fX1)*0.5, (fY0 + fY1)*0.5, (fZ0 + fZ1)*0.5,
				math.sqrt(fHalfSizeX*fHalfSizeX + fHalfSizeY*fHalfSizeY + fHalfSizeZ*fHalfSizeZ));

			return pSphere;
		};

		toString(): string{
			return "(" + this.x0 + ", " + this.y0 + ", " + this.z0 + ") --> (" +
					this.x1 + ", " + this.y1 + ", " + this.z1 +")";
		};

		static get stackCeil(): Rect3d { Rect3d.stackPosition = Rect3d.stackPosition === Rect3d.stackSize - 1? 0: Rect3d.stackPosition; return Rect3d.stack[Rect3d.stackPosition ++]; } static stackSize: number = 128; static stackPosition: number = 0; static stack: Rect3d[] = (function(): Rect3d[]{ var pStack: Rect3d[] = new Array(Rect3d.stackSize); for(var i: number = 0; i<Rect3d.stackSize; i++){ pStack[i] = new Rect3d(); } return pStack})(); ;
    }
}













module akra {
	export interface IRenderPass {} ;
	export interface IRenderMethod {} ;

	export interface IRenderTechnique extends IEventProvider {
		 totalPasses:  number ;
		 modified:  number ;

		destroy(): void;

		getPass(n:  number ): IRenderPass;
		getMethod(): IRenderMethod;

		setMethod(pMethod: IRenderMethod);
		isReady(): bool;

		setState(sName: string, pValue: any): void;
		setForeign(sName: string, pValue: any): void;
		setStruct(sName: string, pValue: any): void;

		setTextureBySemantics(sName: string, pValue: any): void;
		setShadowSamplerArray(sName: string, pValue: any): void;
		setVec2BySemantic(sName: string, pValue: any): void;

		 render(): void;
	}
}





module akra {
	export interface IRenderableObject extends IEventProvider {
		renderMethod: IRenderMethod;

		 effect: IEffect;
		 surfaceMaterial: ISurfaceMaterial;

		 material: IMaterial;

		getGuid():  number ;
		getRenderer(): IRenderer;
		getTechnique(sName?: string): IRenderTechnique;

		destroy(): void;

		addRenderMethod(pMethod: IRenderMethod, csName?: string): bool;
		addRenderMethod(csMethod: string, csName?: string): bool;

// findRenderMethod(csName: string): uint;
		switchRenderMethod(csName: string): bool;
		switchRenderMethod(pMethod: IRenderMethod): bool;
		removeRenderMethod(csName: string): bool;
		getRenderMethod(csName?: string): IRenderMethod;

		hasShadow(): bool;
		setShadow(bValue?: bool): void;

		isReadyForRender(): bool;
		isAllMethodsLoaded(): bool;


		render(csMethod?: string): void;

		_setup(pRenderer: IRenderer, csDefaultMethod?: string): void;
		_draw(): void;

/** Notify, when shadow added or removed. */

		 shadow(bValue: bool): void;
	}
}



module akra.scene {

	export enum ESceneObjectFlags {
		k_NewLocalBounds = 0,
		k_NewWorldBounds
	};

	export class SceneObject extends SceneNode implements ISceneObject {
		/**@protected*/  _iObjectFlags:  number  = 0;
		/**@protected*/  _pLocalBounds: IRect3d = new geometry.Rect3d();
		/**@protected*/  _pWorldBounds: IRect3d = new geometry.Rect3d();
		/**@protected*/  _hasShadows: bool = false;

		/**@inline*/  get totalRenderable():  number  { return 0; }

		/**@inline*/  get worldBounds(): IRect3d {
			return this._pWorldBounds;
		}

		/**@inline*/  set worldBounds(pBox: IRect3d) {
			this._pWorldBounds = pBox;
		}

		/**@inline*/  get localBounds(): IRect3d {
			return this._pLocalBounds;
		}


		constructor (pScene: IScene3d) {
			super(pScene);

			this._eType = EEntityTypes.SCENE_OBJECT;
		}

		/**@inline*/  getRenderable(i?:  number ): IRenderableObject {
			return null;
		}

		accessLocalBounds(): IRect3d {
			((this._iObjectFlags) |= (1 << ((ESceneObjectFlags.k_NewLocalBounds))) ) ;
			return this._pLocalBounds;
		}

		/**@inline*/  isWorldBoundsNew(): bool {
			return  ((this._iObjectFlags & (1 << (ESceneObjectFlags.k_NewLocalBounds)) ) != 0) ;
		}

		destroy(): void {
			super.destroy();
		}

		prepareForUpdate(): void {
			super.prepareForUpdate();

			((this._iObjectFlags) &= ~( (1 << (ESceneObjectFlags.k_NewLocalBounds)) | (1 << (ESceneObjectFlags.k_NewWorldBounds)) ))
                                                                                        ;
		}

		update(): bool {
//если, обновится мировая матрица узла, то и AABB обновится 
			super.update();
// do we need to update our local matrix?
// derived classes update the local matrix
// then call this base function to complete
// the update
		    return this.recalcWorldBounds();
		}

		private recalcWorldBounds(): bool {
// nodes only get their bounds updated
// as nessesary
		    if ( ((this._iObjectFlags & (1 << (ESceneObjectFlags.k_NewLocalBounds)) ) != 0)
		        || this.isWorldMatrixNew()) {
// transform our local rectangle 
// by the current world matrix
		        this._pWorldBounds.set(this._pLocalBounds);
// make sure we have some degree of thickness
		        if (true) {
		            this._pWorldBounds.x1 = Math.max(this._pWorldBounds.x1, this._pWorldBounds.x0 + 0.01);
		            this._pWorldBounds.y1 = Math.max(this._pWorldBounds.y1, this._pWorldBounds.y0 + 0.01);
		            this._pWorldBounds.z1 = Math.max(this._pWorldBounds.z1, this._pWorldBounds.z0 + 0.01);
		        }
		        this._pWorldBounds.transform(this.worldMatrix);

// set the flag that our bounding box has changed
		        ((this._iObjectFlags) |= (1 << ((ESceneObjectFlags.k_NewWorldBounds))) ) ;

		        this.worldBoundsUpdated();

		        return true;
		    }

		    return false;
		}

    	hasShadows(): bool {
    		return this._hasShadows;
    	}

    	setShadows(bValue: bool = true): void {
    		this._hasShadows = bValue;
    	}

    	getObjectFlags():  number  {
    		return this._iObjectFlags;
    	}

    	toString(isRecursive: bool = false, iDepth:  number  = 0): string {

			if (!isRecursive) {
		        return "<scene_object" + (this._sName ? " " + this._sName : "") + ">";
		    }

		    return super.toString(isRecursive, iDepth);

    	}

		private _iGuid: number = eval("this._iGuid || akra.sid()"); private _pUnicastSlotMap: IEventSlotMap = null; private _pBroadcastSlotList: IEventSlotListMap = null; private static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable {return SceneObject._pEventTable; } getGuid(): number {return this._iGuid < 0? (this._iGuid = sid()): this._iGuid; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
			worldBoundsUpdated (): void { var _recivier: any = this; this._pUnicastSlotMap = this._pUnicastSlotMap || this.getEventTable().findUnicastList(this._iGuid); var _unicast: IEventSlot = (<any>this._pUnicastSlotMap).worldBoundsUpdated; if(isDef(_unicast)){ _unicast.target? _unicast.target[_unicast.callback] (_recivier) : _unicast.listener (_recivier) ; } } ; ;
		;
	}

	export  /**@inline*/  function isSceneObject(pEntity: IEntity): bool {
		return pEntity.type >= EEntityTypes.SCENE_OBJECT && pEntity.type < EEntityTypes.OBJECTS_LIMIT;
	}
}










module akra {
/** ObjectArray interface */

	export interface IObjectArray {
/** number of element in array */

		length:  number ;

/** lock array for writing */

		lock(): void;
/**
		 * unlock array.
		 */

		unlock(): void;
/**
		 * Is arrat can be modified?
		 */

		isLocked(): bool;

/**
		 * Remove all elements from array;
		 * @param {Bool=false} bRemoveLinks Remove old pointers to data. 
		 */

		clear(bQuick?: bool): IObjectArray;

/** Get value of <n> element. */

		value(n:  number ): any;
/** Set value for <n> element. */

		set(n:  number , data: any): IObjectArray;
/** Fill ObjectArray from any <Array> */

		fromArray(elements: any[], iOffset?:  number , iSize?:  number ): IObjectArray;
/** Push element to end of array */

		push(element: any): IObjectArray;
/** Get & remove last element in array */

		pop(): any;
/** Complitly remove all data from array */

		release(): IObjectArray;
/** Swap elements in array */

		swap(i:  number , j:  number ): IObjectArray;
	}
}





module akra.util {
	export class ObjectArray implements IObjectArray {
		/**@protected*/  _pData: any[] = [];
		/**@protected*/  _bLock: bool = false;
		/**@protected*/  _iLength:  number  = 0;

		/**@inline*/  get length():  number  {
			return this._iLength;
		}

// set length(n: uint) {

// 	if (this._bLock) {
// 		return;
// 	}

// 	this.extend(n);
// 	this._iLength = n;
// }

		constructor (pElements?: any[]) {
			if (arguments.length) {
				this.fromArray(pElements);
			}
		}

		/**@inline*/  lock(): void {
			this._bLock = true;
		}

		/**@inline*/  unlock(): void {
			this._bLock = false;
		}

		/**@inline*/  isLocked(): bool {
			return this._bLock;
		}

		clear(bRemoveLinks: bool = false): IObjectArray {

			logger.setSourceLocation( "util/ObjectArray.ts" , 47 ); logger.assert(!this._bLock, "cannot clear. array is locked."); ;

			this._iLength = 0;

			if (bRemoveLinks) {
				for (var i:  number  = 0; i < this._pData.length; ++ i) {
					this._pData[i] = null;
				}
			}

			return this;
		}

		release(): IObjectArray {
			this.clear(true);
			this._pData.clear();
			return this;
		}

		/**@inline*/  value(n:  number ): any {
			return this._pData[n];
		}

		private extend(n:  number ): void {
			if (this._pData.length < n) {
// LOG("extending object array to > " + n);
				for (var i:  number  = this._pData.length; i < n; ++ i) {
					this._pData[i] = null;
				}
			}
		}

		set(n:  number , pData: any): IObjectArray {
			logger.setSourceLocation( "util/ObjectArray.ts" , 80 ); logger.assert(!this._bLock, "cannot clear. array is locked."); ;

			var N:  number  = n + 1;

			this.extend(N);

			if (this._iLength < N) {
				this._iLength = N;
			}

			this._pData[n] = pData;

			return this;
		}

		fromArray(pElements: any[], iOffset:  number  = 0, iSize:  number  = 0): IObjectArray {
			logger.setSourceLocation( "util/ObjectArray.ts" , 96 ); logger.assert(!this._bLock, "cannot clear. array is locked."); ;

			iSize = iSize > 0? iSize < pElements.length? iSize: pElements.length: pElements.length;

			this.extend(iSize);

			for (var i:  number  = iOffset, j:  number  = 0; i < iSize; ++ i, ++ j) {
				this._pData[i] = pElements[j];
			}

			this._iLength = i;

			return this;
		}

		/**@inline*/  push(pElement: any): IObjectArray {

			logger.setSourceLocation( "util/ObjectArray.ts" , 113 ); logger.assert(!this._bLock, "cannot clear. array is locked."); ;

			return this.set(this._iLength, pElement);
		}

		/**@inline*/  pop(): any {
			logger.setSourceLocation( "util/ObjectArray.ts" , 119 ); logger.assert(!this._bLock, "cannot clear. array is locked."); ;
			return this._iLength > 0? this._pData[-- this._iLength]: null;
		}

		/**@inline*/  swap(i:  number , j:  number ): IObjectArray {
			logger.setSourceLocation( "util/ObjectArray.ts" , 124 ); logger.assert(!this._bLock, "cannot clear. array is locked."); ;
			logger.setSourceLocation( "util/ObjectArray.ts" , 125 ); logger.assert(i < this._iLength && j < this._iLength, "invalid swap index."); ;

			this._pData.swap(i, j);

			return this;
		}

	}
}

module akra {
	export var ObjectArray = util.ObjectArray;
}



module akra.scene {
	export class DisplayList implements IDisplayList {
		/**@protected*/  _pScene: IScene3d = null;
		/**@protected*/  _sName: string = "";

		/**@inline*/  get name(): string { return this._sName; }
		/**@inline*/  set name(sName: string) { this._sName = sName; }

		_onNodeAttachment(pScene: IScene3d, pNode: ISceneNode): void {
			this.attachObject(pNode);
		}

		_onNodeDetachment(pScene: IScene3d, pNode: ISceneNode): void {
			this.detachObject(pNode);
		}

		/**@protected*/  attachObject(pNode: ISceneNode): void {
			logger.setSourceLocation( "DisplayList.ts" , 29 ); logger.error("pure virtual method DisplayList::attachObject()"); ;
		}

		/**@protected*/  detachObject(pNode: ISceneNode): void {
			logger.setSourceLocation( "DisplayList.ts" , 33 ); logger.error("pure virtual method DisplayList::detachObject()"); ;
		}

		_setup(pScene: IScene3d): void {
			if (isDefAndNotNull(this._pScene)) {
				logger.setSourceLocation( "DisplayList.ts" , 38 ); logger.criticalError("list movement from scene to another scene temprary unsupported!"); ;
			}

			this._pScene = pScene;

			this.connect(pScene, "nodeAttachment" , "_onNodeAttachment" ) ;
			this.connect(pScene, "nodeDetachment" , "_onNodeDetachment" ) ;

			var me = this;

			pScene.getRootNode().explore(function (pEntity: IEntity) {
					me._onNodeAttachment(pScene, <ISceneNode>pEntity);
				});
		}

		_findObjects(pCamera: ICamera, bQuickSearch: bool = true): IObjectArray {
			logger.setSourceLocation( "DisplayList.ts" , 54 ); logger.error("pure virtual method"); ;
			return null;
		}

		private _iGuid: number = eval("this._iGuid || akra.sid()"); private _pUnicastSlotMap: IEventSlotMap = null; private _pBroadcastSlotList: IEventSlotListMap = null; private static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable {return DisplayList._pEventTable; } getGuid(): number {return this._iGuid < 0? (this._iGuid = sid()): this._iGuid; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
		;
	}
}












module akra {

	export interface IOcTree {} ;
	export interface ISceneObject {} ;
	export interface IRect3d {} ;
	export interface IObjectList {} ;

	export interface IOcTreeNode {
/** Parent tree */

		tree: IOcTree;
/** Level of node */

		level:  number ;
/** Byte x-coord of node */

// x: int;
// /** Byte y-coord of node */
// y: int;
// /** Byte z-coord of node */
// z: int;
/** Index in array of nodes in tree */

		index:  number ;
/** First SceneObject in this node */

		membersList: IObjectList;
/** Rect of node in real world */

		worldBounds: IRect3d;
/** Link ro next node in tree */

//forwardNodeLink: IOcTreeNode;
/** Link ro previous node in tree */

		rearNodeLink: IOcTreeNode;

//eight links to possible children nodes;		
		childrenList: IObjectList[];

		addMember(pMember: ISceneObject): void;
		removeMember(pMember: ISceneObject): void;
//nodeCoords(): void;
	}
}
















module akra {
	export interface IListExplorerFunc {
		(data: any, index?:  number ): bool;
//(data: any): void;
	}

/** ObjectList interface. */

	export interface IObjectList {
/** Number of elements in list */

		length:  number ;
/** First element in list */

		first: any;
/** Last element in list */

		last: any;
/** Current element in list */

		current: any;

/** Lock list for midifications. */

		lock(): void;
/** Unlock list */

		unlock(): void;
/** Is list locked ? */

		isLocked(): bool;

/** Set current element to <n> position. */

		seek(n?:  number ): IObjectList;
/** Get next element */

		next(): any;
/** Get prev element */

		prev(): any;
/** Push element to end of list. */

		push(element: any): IObjectList;
/** Pop element from end of list. */

		pop(): any;
/** Add element to list head. */

		prepend(element: any): IObjectList;

/** Add element from array. */

		fromArray(elements: any[], iOffset?:  number , iSize?:  number ): IObjectList;

/** Insert element before <n> element. */

		insert(n:  number , data: any): IObjectList;
/** Get valuie of <n> element */

		value(n:  number , defaultValue?: any): any;
/** Get index of element with given data */

		indexOf(element: any, from?:  number ):  number ;
/** Get sub list from this list */

		mid(pos?:  number , size?:  number ): IObjectList;
/** slice from array */

		slice(start?:  number , end?:  number ): IObjectList;
/** Move element from <from> postion to <to> position.*/

		move(from:  number , to:  number ): IObjectList;

/** Replace data of <n> element. */

		replace(pos:  number , value: any): IObjectList;
/** Erase element with number <n>. */

		erase(pos:  number ): IObjectList;
/** Erase elements from begin to end. */

		erase(begin:  number , end:  number ): IObjectList;
/** Is list contains data with <value>?*/

		contains(value: any): bool;

/** Get data of <n> item and remove it. */

		takeAt(pos:  number ): any;
/** Get data of first item and remove it. */

		takeFirst(): any;
/** Get data of last item and remove it. */

		takeLast(): any;
/** Get data of current item and remove it. */

		takeCurrent(): any;

/** Remove <n> item. */

		removeAt(n:  number ): void;
/** Remove one lement with data <element>. */

		removeOne(element: any): void;
/** Remove all lement with data <element>. */

		removeAll(element: any):  number ;

/** Swap items. */

		swap(i:  number , j:  number ): IObjectList;
/** Add another list to this */

		add(list: IObjectList): IObjectList;
/** Is this list equal to <list>. */

		isEqual(list: IObjectList): bool;

/** Clear list. */

		clear(): IObjectList;
/** For each loop. */

		forEach(fn: IListExplorerFunc): void;
	}
}







module akra.util {
	export interface IObjectListItem {
		next: IObjectListItem;
		prev: IObjectListItem;
		data: any;
	};


	export class ObjectList implements IObjectList {
		/**@protected*/  _pHead: IObjectListItem = null;
		/**@protected*/  _pTail: IObjectListItem = null;
		/**@protected*/  _pCurrent: IObjectListItem = null;
		/**@protected*/  _iLength:  number  = 0;
		/**@protected*/  _bLock: bool = false;


		/**@inline*/  get length():  number  {
			return this._iLength;
		};

		/**@inline*/  get first(): any {
			this._pCurrent = this._pHead;
			return (isDefAndNotNull(this._pCurrent)) ? this._pCurrent.data : null;
		};

		/**@inline*/  get last(): any {
			this._pCurrent = this._pTail;
			return (isDefAndNotNull(this._pCurrent)) ? this._pCurrent.data : null;
		}

		/**@inline*/  get current(): any {
			return (isDefAndNotNull(this._pCurrent)) ? this._pCurrent.data : null;
		}

		/**@inline*/  lock(): void {
			this._bLock = true;
		}

		/**@inline*/  unlock(): void {
			this._bLock = false;
		}

		/**@inline*/  isLocked(): bool {
			return this._bLock;
		}

		/**@inline*/  value(n:  number ): any{
			return this.find(n).data;
		};

		constructor (pData?: any[]) {
			if (arguments.length) {
				this.fromArray(pData);
			}
		}

		indexOf(pData: any, iFrom:  number  = 0.):  number {
			var pItem: IObjectListItem = this.find(iFrom);

			for(var i:  number  = iFrom; i<this._iLength; i++){
				if(pItem.data === pData){
					return i;
				}
				pItem = pItem.next;
			}
			return -1;
		};

		mid(iPos:  number  = 0, iSize:  number  = this._iLength): IObjectList{
			iSize = Math.min(this._iLength - iPos, iSize);

			if (iPos > this._iLength - 1) {
				return null;
			}

			var pNewList: IObjectList = new ObjectList();
			var pItem: IObjectListItem = this.find(iPos);

			for (var i:  number  = 0; i < iSize; ++ i) {
				pNewList.push(pItem.data);
				pItem = pItem.next;
			};

			return pNewList;
		};

		/**@inline*/  slice(iStart:  number  = 0, iEnd:  number  = Math.max(this._iLength - iStart, 0)): IObjectList {
			return this.mid(iStart, iEnd - iStart);
		}

		/**@inline*/  move(iFrom:  number , iTo:  number ): IObjectList{
			return this.insert(iTo - 1, this.takeAt(iFrom));
		};

		/**@inline*/  replace(iPos:  number , pData: any): IObjectList{
			logger.setSourceLocation( "util/ObjectList.ts" , 102 ); logger.assert(!this.isLocked(), "list locked."); ;
			this.find(iPos).data = pData;
			return this;
		};

		erase(pos:  number ): IObjectList;
		erase(begin:  number , end:  number ): IObjectList;
		erase(begin:  number , end?:  number ): IObjectList{
			if(arguments.length < 2){
				this.takeAt(< number >arguments[0]);
			}
			else{
				end = Math.min(end, this._iLength);
				for(var i:  number  = begin; i < end; i++){
					this.takeAt(i);
				}
			}
			return this;
		};

		/**@inline*/  contains(pData: any): bool{
			return (this.indexOf(pData) >= 0);
		};

		/**@inline*/  removeAt(n:  number ): void{
			this.takeAt(n);
		};

		/**@inline*/  removeOne(pData: any): void{
			this.removeAt(this.indexOf(pData));
		};

		/**@inline*/  removeAll(pData: any):  number  {
			var i:  number ;
			var n:  number  = this.length;

			while((i = this.indexOf(pData)) >= 0){
				this.removeAt(i);
				i--;
			}

			return n;
		}

		swap(i:  number , j:  number ): IObjectList {
			logger.setSourceLocation( "util/ObjectList.ts" , 147 ); logger.assert(!this.isLocked(), "list locked."); ;

			i = Math.min(i, this._iLength-1);
			j = Math.min(j, this._iLength-1);

			if (i != j) {
				var pItem1: IObjectListItem = this.find(i);
				var pItem2: IObjectListItem = this.find(j);

				var pTmp: any = pItem1.data;

				pItem1.data = pItem2.data;
				pItem2.data = pTmp;
			}

			return this;
		}

		add(pList: IObjectList): IObjectList{
			pList.seek(0);

			if(pList.length > 1){
				this.push(pList.first());
			}

			for(var i:  number =1; i<pList.length; i++){
				this.push(pList.next());
			}

			return this;
		}

		seek(n:  number  = 0): IObjectList {
			var pElement: IObjectListItem;

			n = Math.min(n, this._iLength - 1);

			if (n > this._iLength / 2) {
				pElement = this._pTail;

				for (var m:  number  = this._iLength - 1 - n; m > 0; -- m) {
					pElement = pElement.prev;
				}
			}
			else {
				pElement = this._pHead;

				for (var i:  number  = 0; i < n; ++ i) {
					pElement = pElement.next;
				}
			}

			this._pCurrent = pElement;

			return this;
		};

		/**@inline*/  next(): any {
			return (isDefAndNotNull(this._pCurrent) && isDefAndNotNull(this._pCurrent.next))? (this._pCurrent = this._pCurrent.next).data: null;
		}

		/**@inline*/  prev(): any {
			return (isDefAndNotNull(this._pCurrent) && isDefAndNotNull(this._pCurrent.prev))? (this._pCurrent = this._pCurrent.prev).data: null;
		}

		/**@inline*/  push(pElement: any): IObjectList{
			return this.insert(this._iLength, pElement)
		};

		/**@inline*/  takeAt(n:  number ): any{
			logger.setSourceLocation( "util/ObjectList.ts" , 217 ); logger.assert(!this.isLocked(), "list locked."); ;

			if(n < 0){
				return null;
			}

			return this.pullElement(this.find(n));
		};

		private pullElement(pItem: IObjectListItem): any {

			if (isNull(pItem.prev)) {
				this._pHead = pItem.next;
			}
			else {
				pItem.prev.next = pItem.next;
			}

			if (isNull(pItem.next)) {
				this._pTail = pItem.prev;
			}
			else {
				pItem.next.prev = pItem.prev;
			}

			this._iLength --;

			if (isNull(pItem.next)) {
				this._pCurrent = this._pTail;
			}
			else {
				this._pCurrent = pItem.next;
			}

			return this.releaseItem(pItem);
		};


		/**@inline*/  takeFirst(): any{
			return this.takeAt(0);
		};

		/**@inline*/  takeLast(): any {
			return this.takeAt(this._iLength - 1);
		};

		/**@inline*/  takeCurrent(isPrev: bool = false): any {
			return this.pullElement(this._pCurrent);
		}

		/**@inline*/  pop(): any{
			return this.takeAt(this._iLength - 1);
		};

		/**@inline*/  prepend(pElement: any): IObjectList{
			return this.insert(0,pElement)
		};

		/**@inline*/  private find(n:  number ): IObjectListItem{
			if (n < this._iLength) {
				this.seek(n);
				return this._pCurrent;
			}

			return null;
		};

		/**@inline*/  private releaseItem(pItem: IObjectListItem): any {
			var pData: any = pItem.data;

			pItem.next = null;
			pItem.prev = null;
			pItem.data = null;

			ObjectList.listItemPool.push(pItem);

			return pData;
		};

		/**@inline*/  private createItem(): IObjectListItem {
			if (ObjectList.listItemPool.length == 0) {
// LOG("allocated object list item");
				return {next: null, prev: null, data: null};
			}
// LOG("before pop <----------", this._iLength, this.first);
			return <IObjectListItem>ObjectList.listItemPool.pop();
		}

		fromArray(elements: any[], iOffset:  number  = 0, iSize:  number  = elements.length): IObjectList{
			iOffset = Math.min(iOffset, this._iLength);

			for(var i:  number  = 0; i < iSize; i++){
				this.insert(iOffset + i, elements[i]);
			}

			return this;
		}

		insert(n:  number , pData: any): IObjectList{
			logger.setSourceLocation( "util/ObjectList.ts" , 316 ); logger.assert(!this.isLocked(), "list locked."); ;

			var pNew: IObjectListItem = this.createItem();
			var pItem: IObjectListItem;

			n = Math.min(n, this._iLength);
			pNew.data = pData;


			if (n == 0) {
				if (isNull(this._pHead)) {
					this._pTail = pNew;
				}

				pNew.next = this._pHead;
				this._pHead = pNew;
			}
			else {
				pItem = this.find(n - 1);

				if(pItem == null) {
					this._pHead = pNew;
				}
				else {

					if (pItem.next == null) {
						this._pTail = pNew;
					}
					else {
						pNew.next = pItem.next;
						pItem.next.prev = pNew;
					}

					pItem.next = pNew;
					pNew.prev = pItem;
				}
			}

			this._iLength ++;
			this._pCurrent = pNew;

			return this;
		};

		isEqual(pList: IObjectList): bool {
			if (this._iLength == pList.length) {
				if (this === pList) {
					return true;
				}

				var l1: IObjectListItem = this.first;
				var l2: IObjectListItem = pList.first;

				for (var i:  number  = 0; i < this._iLength; ++i) {
					if (l1 != l2) {
						return false;
					}

					l1 = this.next();
					l2 = pList.next();
				}

				return true;
			}

			return false;
		}

		clear(): IObjectList {
			logger.setSourceLocation( "util/ObjectList.ts" , 385 ); logger.assert(!this.isLocked(), "list locked."); ;

			var pPrev: IObjectListItem;
			var pNext: IObjectListItem;

			this._pCurrent = this._pHead;

			for (var i:  number  = 0; i < this._iLength; ++ i) {
				pPrev = this._pCurrent;
				pNext = this._pCurrent = this._pCurrent.next;

				this.releaseItem(pPrev);
			}

			this._pHead = this._pCurrent = this._pTail = null;
			this._iLength = 0;

			return this;
		}

		forEach(fn: IListExplorerFunc): void {
			var pItem: IObjectListItem = this._pHead;
			var n:  number  = 0;
			do {
				if (fn(pItem.data, n ++) === false) {
					return;
				}
			} while ((pItem = pItem.next));
		}

		static private listItemPool: IObjectArray = new ObjectArray;

	}
}

module akra {
	export var ObjectList = util.ObjectList;
}





module akra.scene {

/** OcTreeNode class represent node of OcTree */

	export class OcTreeNode implements IOcTreeNode {
/** Parent tree */

		tree: IOcTree;
/** Level of node */

		level:  number  = 0;
/** Byte x-coord of node */

//x: int = 0;
/** Byte y-coord of node */

//y: int = 0;
/** Byte z-coord of node */

//z: int = 0;
/** Index in array of nodes in tree */

		index:  number  = 0;
/** First SceneObject in this node */

		membersList: IObjectList;
/** Rect of node in real world */

		worldBounds: IRect3d;

/** Link to previous node in tree */

		rearNodeLink: IOcTreeNode = null;

//eight links to possible children nodes;		
		childrenList: IObjectList[];

//index - is xyz where x-left = 0, x-right = 1 etc.

		constructor(pTree: IOcTree){
			this.membersList = new util.ObjectList();
			this.worldBounds = new geometry.Rect3d();

			this.childrenList = new Array(8);
			for(var i=0; i<8;i++){
				this.childrenList[i] = new util.ObjectList();
			}

			this.tree = pTree;
		}

/**
		 * Add object in this node
		 */

		addMember(pObject: ISceneObject): void {
			this.membersList.push(pObject);
			this.connect(pObject,  "worldBoundsUpdated" ,  "objectMoved" , EEventTypes.UNICAST);
// console.log(this.membersList);
		};

/**
		 * Remove member object from node and release node if there are not members in it
		 */

		removeMember(pObject: ISceneObject): void {
			var i: number  = this.membersList.indexOf(pObject);
// console.log('position in list ------------>',i);

// make sure this is one of ours
			logger.setSourceLocation( "OcTreeNode.ts" , 69 ); logger.assert(i>=0, "error removing member cannot find member"); ;

	    	if(i>=0){
	    		this.membersList.takeAt(i);
	    		this.disconnect(pObject,  "worldBoundsUpdated" ,  "objectMoved" , EEventTypes.UNICAST);
	    	}

	    	if(this.membersList.length === 0){
	    		this.tree.deleteNodeFromTree(this);
	    	}
		};

		private _iGuid: number = eval("this._iGuid || akra.sid()"); private _pUnicastSlotMap: IEventSlotMap = null; private _pBroadcastSlotList: IEventSlotListMap = null; private static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable {return OcTreeNode._pEventTable; } getGuid(): number {return this._iGuid < 0? (this._iGuid = sid()): this._iGuid; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;

		objectMoved(pObject: ISceneObject){
// console.warn('object moving');
			var pNode: IOcTreeNode = this.tree.findTreeNode(pObject);
//console.error('-----before------>', this, pNode,'<-------arter------');
			if(pNode !== this){
				this.removeMember(pObject);
				pNode.addMember(pObject);
			}
		};

		;


	};

	export class OcTreeRootNode extends OcTreeNode implements IOcTreeNode{

		/**@protected*/  _pBasicWorldBounds: IRect3d;

		constructor(pTree: IOcTree){
			super(pTree);

			var iTmp:  number  = (1 << this.tree.depth);

			this._pBasicWorldBounds = new geometry.Rect3d(0, iTmp, 0, iTmp, 0, iTmp);
		    this._pBasicWorldBounds.divSelf(this.tree.worldScale);
		    this._pBasicWorldBounds.subSelf(this.tree.worldOffset);

		    this.worldBounds.set(this._pBasicWorldBounds);
		};

		addMember(pMember: ISceneObject): void{
			super.addMember(pMember);
//обновляем границы нода, критично, в том случае если объект выходит за границы нода, так как иначе отсекаться будет неправильно
	    	this._updateNodeBoundingBox();
		};

		removeMember(pObject: ISceneObject): void{
			var i: number  = this.membersList.indexOf(pObject);

			console.log('position in list ------------>',i);

// make sure this is one of ours
			logger.setSourceLocation( "OcTreeNode.ts" , 126 ); logger.assert(i>=0, "error removing member cannot find member"); ;

	    	if(i>=0){
	    		this.membersList.takeAt(i);
	    		this.disconnect(pObject,  "moved" ,  "objectMoved" , EEventTypes.UNICAST);
	    	}

//обновляем границы нода, критично, в том случае если объект выходит за границы нода, так как иначе отсекаться будет неправильно
			this._updateNodeBoundingBox();
		};

		/**@protected*/  _updateNodeBoundingBox(): void {
		    var pNodeWorldBounds: IRect3d = this.worldBounds;
		    pNodeWorldBounds.set(this._pBasicWorldBounds);

		    var pObject: ISceneObject = this.membersList.first;
		    while(isDefAndNotNull(pObject)){
		    	console.warn(pObject,pObject.worldBounds);
		    	pNodeWorldBounds.unionRect(pObject.worldBounds);

		    	pObject = this.membersList.next();
		    }
		};
	}
}







// #include "IOcTreeRect.ts"
// #include "IRect3d.ts"
// #include "IVec3.ts"
// #include "geometry/Rect3d.ts"

// #define ocTreeRect() OcTreeRect.stackCeil

// module akra.scene {

// 	/** OcTreeRect class represent simple 3d byte rect */
// 	export class OcTreeRect implements IOcTreeRect { 
// 		protected x0: int = 0;
// 		protected x1: int = 0;
// 		protected y0: int = 0;
// 		protected y1: int = 0;
// 		protected z0: int = 0;
// 		protected z1: int = 0;


// 		constructor (pRect: OcTreeRect);
// 		constructor (x0: int, x1: int, y0: int, y1: int, z0: int, z1: int);
// 		constructor (x0, x1?, y0?, y1?, z0?, z1?) {
// 			switch (arguments.length) {
// 		        case 1:
// 		            this.x0 = (<OcTreeRect>arguments[0]).x0;
// 		            this.x1 = (<OcTreeRect>arguments[0]).x1;
// 		            this.y0 = (<OcTreeRect>arguments[0]).y0;
// 		            this.y1 = (<OcTreeRect>arguments[0]).y1;
// 		            this.z0 = (<OcTreeRect>arguments[0]).z0;
// 		            this.z1 = (<OcTreeRect>arguments[0]).z1;
// 		            break;
// 		        case 6:
// 		            this.x0 = arguments[0];
// 		            this.x1 = arguments[1];
// 		            this.y0 = arguments[2];
// 		            this.y1 = arguments[3];
// 		            this.z0 = arguments[4];
// 		            this.z1 = arguments[5];
// 		            break;
// 		    }
// 		}

// 		/**
// 		 * Convert Rect3d to byte rect
// 		 */
// 		convert(pWorldRect: IRect3d, v3fOffset: IVec3, v3fScale: IVec3): void {
// 		    var convertedRect: IRect3d = new geometry.Rect3d(pWorldRect);
// 		    // reposition and v3fScale world coordinates to OcTree coordinates
// 		    convertedRect.addSelf(v3fOffset);
// 		    convertedRect.multSelf(v3fScale);
// 		    //alert([convertedRect.iX0,convertedRect.iY0,convertedRect.iZ0,convertedRect.iX1,convertedRect.iY1,convertedRect.iZ1]);
// 		    // reduce by a tiny amount to handle tiled data
// 		    convertedRect.x1 = math.max(convertedRect.x1 - 0.01, convertedRect.x0);
// 		    convertedRect.y1 = math.max(convertedRect.y1 - 0.01, convertedRect.y0);
// 		    convertedRect.z1 = math.max(convertedRect.z1 - 0.01, convertedRect.z0);

// 		    // convert to integer values, taking the floor of each real
// 		    this.x0 = convertedRect.fX0 << 0;
// 		    this.x1 = convertedRect.fX1 << 0;
// 		    this.y0 = convertedRect.fY0 << 0;
// 		    this.y1 = convertedRect.fY1 << 0;
// 		    this.z0 = convertedRect.fZ0 << 0;
// 		    this.z1 = convertedRect.fZ1 << 0;
// 		    // we must be positive
// 		    this.x0 = math.clamp(this.x0, 0, 1022);
// 		    this.y0 = math.clamp(this.y0, 0, 1022);
// 		    this.z0 = math.clamp(this.z0, 0, 1022);

// 		    // we must be at least one unit large
// 		    this.x1 = math.clamp(this.x1, this.x0 + 1, 1023);
// 		    this.y1 = math.clamp(this.y1, this.y0 + 1, 1023);
// 		    this.z1 = math.clamp(this.z1, this.z0 + 1, 1023);
// 		}

// 		/**
// 		 * Set
// 		 */
// 		set(iX0: int, iX1: int, iY0: int, iY1: int, iZ0: int, iZ: int): void {
// 		    this.iX0 = iX0;
// 		    this.iX1 = iX1;
// 		    this.iY0 = iY0;
// 		    this.iY1 = iY1;
// 		    this.iZ0 = iZ0;
// 		    this.iZ1 = iZ1;
// 		}

// 		ALLOCATE_STORAGE(OcTreeRect, 8);
// 	}
// }








module akra{

	export interface IMat4 {} ;
	export interface IVec3 {} ;
	export interface IRect3 {} ;
	export interface ISphere {} ;
	export interface IRect3d {} ;

	export interface IFrustum{
		leftPlane: IPlane3d;
		rightPlane: IPlane3d;
		topPlane: IPlane3d;
		bottomPlane: IPlane3d;
		nearPlane: IPlane3d;
		farPlane: IPlane3d;

		set(): IFrustum;
		set(pFrustum: IFrustum): IFrustum;
		set(pLeftPlane: IPlane3d, pRightPlane: IPlane3d,
			pTopPlane: IPlane3d, pBottomPlane: IPlane3d,
			pNearPlane: IPlane3d, pFarPlane: IPlane3d): IFrustum;

		extractFromMatrix(m4fProjection: IMat4, m4fWorld?: IMat4, pSearchRect?: IRect3d): IFrustum;

		isEqual(pFrustum: IFrustum): bool;

		testPoint(v3fPoint: IVec3): bool;
		testRect(pRect: IRect3): bool;
		testSphere(pSphere: ISphere): bool;

	};
};
















module akra{

	export interface IVec2 {} ;
	export interface ICircle {} ;

	export interface IPlane2d{
		normal: IVec2;
		distance:  number ;

		set(): IPlane2d;
		set(pPlane: IPlane2d): IPlane2d;
		set(v2fNormal: IVec2, fDistance:  number ): IPlane2d;
		set(v2fPoint1: IVec2, v2fPoint2: IVec2): IPlane2d;

		clear(): IPlane2d;

		normalize(): IPlane2d;

		isEqual(pPlane: IPlane2d): bool;

		projectPointToPlane(v2fPoint: IVec2, v2fDestination?: IVec2): IVec2;

		solveForX(fY:  number ):  number ;
		solveForY(fX:  number ):  number ;

		signedDistance(v2fPoint):  number ;
	}
}



module akra.geometry{
	export class Plane2d implements IPlane2d{
		normal: IVec2;
		distance:  number ;

		constructor();
		constructor(pPlane: IPlane2d);
		constructor(v2fNormal: IVec2, fDistance:  number );
		constructor(v2fPoint1: IVec2, v2fPoint2: IVec2);
		constructor(v2fPoint1?, v2fPoint2?){

			this.normal = new Vec2();
			this.distance = 0.;

			var nArgumentsLength = arguments.length;

			switch(nArgumentsLength){
				case 1:
					this.set(arguments[0]);
					break;
				case 2:
					this.set(arguments[0], arguments[1]);
					break;
				default:
					break;
			}
		};

		set(): IPlane2d;
		set(pPlane: IPlane2d): IPlane2d;
		set(v2fNormal: IVec2, fDistance:  number ): IPlane2d;
		set(v2fPoint1: IVec2, v2fPoint2: IVec2): IPlane2d;
		set(v2fPoint1?, v2fPoint2?): IPlane2d{
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					var pPlane: IPlane2d = arguments[0];

					this.normal.set(pPlane.normal);
					this.distance = pPlane.distance;
					break;
				case 2:
					if(isFloat(arguments[1])){
						this.normal.set(arguments[0]);
						this.distance = arguments[1];
					}
					else{
						var v2fLine: IVec2 = vec2(<IVec2>arguments[1]).subtract(arguments[0]);
						var v2fNormal: IVec2 = this.normal;

						v2fNormal.set(-v2fLine.y, v2fLine.x);
						this.distance = -v2fNormal.dot(arguments[0]);
					}
					break;
				default:
					this.normal.clear();
					this.distance = 0.;
					break;
			}

			return this.normalize();
		};

		/**@inline*/  clear(): IPlane2d{
			this.normal.clear();
			this.distance = 0.;
			return this;
		};

		normalize(): IPlane2d{
			var v2fNormal: IVec2 = this.normal;

			var x:  number  = v2fNormal.x;
			var y:  number  = v2fNormal.y

			var fLength:  number  = math.sqrt(x*x + y*y);

			if(fLength !== 0.){
				var fInvLength:  number  = 1./fLength;

				v2fNormal.x = x*fInvLength;
				v2fNormal.y = y*fInvLength;

				this.distance = this.distance*fInvLength;
			}

			return this;
		};

		/**@inline*/  isEqual(pPlane: IPlane2d): bool{
			return this.normal.isEqual(pPlane.normal) && (this.distance == pPlane.distance);
		};

/*предполагается работа только с нормализованной плоскостью*/

		projectPointToPlane(v2fPoint: IVec2, v2fDestination?: IVec2): IVec2{
			if(!isDef(v2fDestination)){
				v2fDestination = new Vec2();
			}

			var v2fNormal: IVec2 = this.normal;
			var fDistance:  number  = this.distance + v2fNormal.dot(v2fPoint);

			v2fDestination.x = v2fPoint.x - fDistance*v2fNormal.x;
			v2fDestination.y = v2fPoint.y - fDistance*v2fNormal.y;

			return v2fDestination;
		};

		solveForX(fY:  number ):  number {
/*Ax+By+d=0;
			x=-(d+By)/A;*/


			var v2fNormal: IVec2 = this.normal;

			if(v2fNormal.x !== 0.){
				return -(this.distance + v2fNormal.y*fY)/v2fNormal.x;
			}
			return 0.;
		};

		solveForY(fX:  number ):  number {
/*Ax+By+d=0;
			y=-(d+Ax)/B;*/


			var v2fNormal: IVec2 = this.normal;

			if(v2fNormal.y !== 0.){
				return -(this.distance + v2fNormal.x*fX)/v2fNormal.y;
			}
			return 0.;
		};

/*предполагается работа только с нормализованной плоскостью*/

		/**@inline*/  signedDistance(v2fPoint: IVec2):  number {
			return this.distance + this.normal.dot(v2fPoint);
		};
	};
}







module akra{
	export enum EVolumeClassifications{
		NO_RELATION = 0,
		EQUAL,
		A_CONTAINS_B,
		B_CONTAINS_A,
		INTERSECTING
	};

	export enum EPlaneClassifications{
/**
		 * ax+by+cz+d=0
		 * PLANE_FRONT - объект находится перед плоскостью, то есть по направлению нормали
		 * PLANE_BACK - объект находится за плостостью, то есть против направления нормали
		 */

		PLANE_FRONT = 0,
		PLANE_BACK,
		PLANE_INTERSECT
	};
}

module akra.geometry{

	export function planeClassifyCircle(pPlane: IPlane2d, pCircle: ICircle): EPlaneClassifications{
		var fDistance:  number  = pPlane.signedDistance(pCircle.center);
		var fRadius:  number  = pCircle.radius;

		if(fDistance > fRadius){
			return EPlaneClassifications.PLANE_FRONT;
		}
		else if(fDistance < -fRadius){
			return EPlaneClassifications.PLANE_BACK;
		}
		else{
			return EPlaneClassifications.PLANE_INTERSECT;
		}
	};

	export function planeClassifySphere(pPlane: IPlane3d, pSphere: ISphere): EPlaneClassifications{
		var fDistance:  number  = pPlane.signedDistance(pSphere.center);
		var fRadius:  number  = pSphere.radius;

		if(fDistance > fRadius){
			return EPlaneClassifications.PLANE_FRONT;
		}
		else if(fDistance < -fRadius){
			return EPlaneClassifications.PLANE_BACK;
		}
		else{
			return EPlaneClassifications.PLANE_INTERSECT;
		}
	};

	export function planeClassifyRect2d(pPlane: IPlane2d, pRect: IRect2d): EPlaneClassifications{
		var v2fMinPoint: IVec2 = vec2();
		var v2fMaxPoint: IVec2 = vec2();

		var v2fNormal: IVec2 = pPlane.normal;

		if(v2fNormal.x > 0.){
			v2fMinPoint.x = pRect.x0;
			v2fMaxPoint.x = pRect.x1;
		}
		else{
			v2fMinPoint.x = pRect.x1;
			v2fMaxPoint.x = pRect.x0;
		}

		if(v2fNormal.y > 0.){
			v2fMinPoint.y = pRect.y0;
			v2fMaxPoint.y = pRect.y1;
		}
		else{
			v2fMinPoint.y = pRect.y1;
			v2fMaxPoint.y = pRect.y0;
		}

		var fMinDistance:  number  = pPlane.signedDistance(v2fMinPoint);
		var fMaxDistance:  number  = pPlane.signedDistance(v2fMaxPoint);

		if(fMinDistance*fMaxDistance <= 0.){
			return EPlaneClassifications.PLANE_INTERSECT;
		}
		else if (fMaxDistance < 0.){
			return EPlaneClassifications.PLANE_BACK;
		}
		else{
			return EPlaneClassifications.PLANE_FRONT;
		}
	};

	export function planeClassifyRect3d(pPlane: IPlane3d, pRect: IRect3d): EPlaneClassifications{
		var v3fMinPoint: IVec3 = vec3();
		var v3fMaxPoint: IVec3 = vec3();

		var v3fNormal: IVec3 = pPlane.normal;

		if(v3fNormal.x > 0.){
			v3fMinPoint.x = pRect.x0;
			v3fMaxPoint.x = pRect.x1;
		}
		else{
			v3fMinPoint.x = pRect.x1;
			v3fMaxPoint.x = pRect.x0;
		}

		if(v3fNormal.y > 0.){
			v3fMinPoint.y = pRect.y0;
			v3fMaxPoint.y = pRect.y1;
		}
		else{
			v3fMinPoint.y = pRect.y1;
			v3fMaxPoint.y = pRect.y0;
		}

		if(v3fNormal.z > 0.){
			v3fMinPoint.z = pRect.z0;
			v3fMaxPoint.z = pRect.z1;
		}
		else{
			v3fMinPoint.z = pRect.z1;
			v3fMaxPoint.z = pRect.z0;
		}

		var fMinDistance:  number  = pPlane.signedDistance(v3fMinPoint);
		var fMaxDistance:  number  = pPlane.signedDistance(v3fMaxPoint);

		if(fMinDistance*fMaxDistance <= 0.){
			return EPlaneClassifications.PLANE_INTERSECT;
		}
		else if (fMaxDistance < 0.){
			return EPlaneClassifications.PLANE_BACK;
		}
		else{
			return EPlaneClassifications.PLANE_FRONT;
		}
	};

	export function planeClassify(pPlane: IPlane2d, pCircle: ICircle): EPlaneClassifications;
	export function planeClassify(pPlane: IPlane3d, pSphere: ISphere): EPlaneClassifications;
	export function planeClassify(pPlane: IPlane2d, pRect: IRect2d): EPlaneClassifications;
	export function planeClassify(pPlane: IPlane3d, pRect: IRect3d): EPlaneClassifications;
	export function planeClassify(pPlane?, pRect?): EPlaneClassifications{
		var pArg0: any = arguments[0];
		var pArg1: any = arguments[1];

		if(pArg0 instanceof Plane2d){
			if(pArg1 instanceof Circle){
				return planeClassifyCircle(pArg0, pArg1);
			}
			else{
				return planeClassifyRect2d(pArg0, pArg1);
			}
		}
		else{
			if(pArg1 instanceof Sphere){
				return planeClassifySphere(pArg0, pArg1);
			}
			else{
				return planeClassifyRect3d(pArg0, pArg1);
			}
		}
	};

	export function classifyRect2d(pRectA: IRect2d, pRectB: IRect2d): EVolumeClassifications{
		var fRectAX0:  number  = pRectA.x0, fRectAX1:  number  = pRectA.x1;
		var fRectAY0:  number  = pRectA.y0, fRectAY1:  number  = pRectA.y1;

		var fRectBX0:  number  = pRectB.x0, fRectBX1:  number  = pRectB.x1;
		var fRectBY0:  number  = pRectB.y0, fRectBY1:  number  = pRectB.y1;

		if((fRectAX1 < fRectBX0 || fRectBX1 < fRectAX0)
			|| (fRectAY1 < fRectBY0 || fRectAY1 < fRectBY0)){

			return EVolumeClassifications.NO_RELATION;
		}

		if((fRectAX0 == fRectBX0 && fRectAX1 == fRectBX1)
			&& (fRectAY0 == fRectBY0 && fRectAY1 == fRectBY1)){

			return EVolumeClassifications.EQUAL;
		}

		if((fRectAX0 <= fRectBX0 && fRectBX1 <= fRectAX1)
			 && (fRectAY0 <= fRectBY0 && fRectBY1 <= fRectAY1)){

			return EVolumeClassifications.A_CONTAINS_B;
		}

		if((fRectBX0 <= fRectAX0 && fRectAX1 <= fRectBX1)
			&& (fRectBY0 <= fRectAY0 && fRectAY1 <= fRectBY1)){

			return EVolumeClassifications.B_CONTAINS_A;
		}

		return EVolumeClassifications.INTERSECTING;
	};

	export function classifyRect3d(pRectA: IRect3d, pRectB: IRect3d): EVolumeClassifications{
		var fRectAX0:  number  = pRectA.x0, fRectAX1:  number  = pRectA.x1;
		var fRectAY0:  number  = pRectA.y0, fRectAY1:  number  = pRectA.y1;
		var fRectAZ0:  number  = pRectA.z0, fRectAZ1:  number  = pRectA.z1;

		var fRectBX0:  number  = pRectB.x0, fRectBX1:  number  = pRectB.x1;
		var fRectBY0:  number  = pRectB.y0, fRectBY1:  number  = pRectB.y1;
		var fRectBZ0:  number  = pRectB.z0, fRectBZ1:  number  = pRectB.z1;

		if((fRectAX1 < fRectBX0 || fRectBX1 < fRectAX0)
			|| (fRectAY1 < fRectBY0 || fRectAY1 < fRectBY0)
			|| (fRectAZ1 < fRectBZ0 || fRectAZ1 < fRectBZ0)){

			return EVolumeClassifications.NO_RELATION;
		}

		if((fRectAX0 == fRectBX0 && fRectAX1 == fRectBX1)
			&& (fRectAY0 == fRectBY0 && fRectAY1 == fRectBY1)
			&& (fRectAZ0 == fRectBZ0 && fRectAZ1 == fRectBZ1)){

			return EVolumeClassifications.EQUAL;
		}

		if((fRectAX0 <= fRectBX0 && fRectBX1 <= fRectAX1)
			 && (fRectAY0 <= fRectBY0 && fRectBY1 <= fRectAY1)
			 && (fRectAZ0 <= fRectBZ0 && fRectBZ1 <= fRectAZ1)){

			return EVolumeClassifications.A_CONTAINS_B;
		}

		if((fRectBX0 <= fRectAX0 && fRectAX1 <= fRectBX1)
			&& (fRectBY0 <= fRectAY0 && fRectAY1 <= fRectBY1)
			&& (fRectBZ0 <= fRectAZ0 && fRectAZ1 <= fRectBZ1)){

			return EVolumeClassifications.B_CONTAINS_A;
		}

		return EVolumeClassifications.INTERSECTING;
	};

	export function classifyFrustumRect3d(pFrustum: IFrustum, pRect: IRect3d){
		var kClassification: EPlaneClassifications;
		var isIntersect: bool = false;

		kClassification = planeClassifyRect3d(pFrustum.leftPlane, pRect);
		if(kClassification == EPlaneClassifications.PLANE_FRONT){
			return EVolumeClassifications.NO_RELATION;
		}
		else if(kClassification == EPlaneClassifications.PLANE_INTERSECT){
			isIntersect = true;
		}

		kClassification = planeClassifyRect3d(pFrustum.rightPlane, pRect);
		if(kClassification == EPlaneClassifications.PLANE_FRONT){
			return EVolumeClassifications.NO_RELATION;
		}
		else if(kClassification == EPlaneClassifications.PLANE_INTERSECT){
			isIntersect = true;
		}

		kClassification = planeClassifyRect3d(pFrustum.topPlane, pRect);
		if(kClassification == EPlaneClassifications.PLANE_FRONT){
			return EVolumeClassifications.NO_RELATION;
		}
		else if(kClassification == EPlaneClassifications.PLANE_INTERSECT){
			isIntersect = true;
		}

		kClassification = planeClassifyRect3d(pFrustum.bottomPlane, pRect);
		if(kClassification == EPlaneClassifications.PLANE_FRONT){
			return EVolumeClassifications.NO_RELATION;
		}
		else if(kClassification == EPlaneClassifications.PLANE_INTERSECT){
			isIntersect = true;
		}

		kClassification = planeClassifyRect3d(pFrustum.nearPlane, pRect);
		if(kClassification == EPlaneClassifications.PLANE_FRONT){
			return EVolumeClassifications.NO_RELATION;
		}
		else if(kClassification == EPlaneClassifications.PLANE_INTERSECT){
			isIntersect = true;
		}

		kClassification = planeClassifyRect3d(pFrustum.farPlane, pRect);
		if(kClassification == EPlaneClassifications.PLANE_FRONT){
			return EVolumeClassifications.NO_RELATION;
		}
		else if(kClassification == EPlaneClassifications.PLANE_INTERSECT){
			isIntersect = true;
		}

		if(isIntersect){
			return EVolumeClassifications.INTERSECTING;
		}
		else{
			return EVolumeClassifications.A_CONTAINS_B;
		}
	};

}
















module akra {

	export interface IVec2 {} ;

	export interface IRay2d {
		point: IVec2;
		normal: IVec2;
	};
}



module akra.geometry{
	export  class  Ray2d implements IRay2d{
		point: IVec2;
		normal: IVec2;

		constructor(){
			this.point = new Vec2();
			this.normal = new Vec2();
		};
	};
}












module akra {

	export interface IVec3 {} ;

	export interface IRay3d {
		point: IVec3;
		normal: IVec3;
	};
}



module akra.geometry{
	export  class  Ray3d implements IRay3d{
		point: IVec3;
		normal: IVec3;

		constructor(){
			this.point = new Vec3();
			this.normal = new Vec3();
		};
	};
}














module akra{

	export interface IVec3 {} ;

	export interface IPlane3d{
		normal: IVec3;
		distance:  number ;

		set(): IPlane3d;
		set(pPlane: IPlane3d): IPlane3d;
		set(v3fNormal: IVec3, fDistance:  number ): IPlane3d;
		set(v3fPoint1: IVec3, v3fPoint2: IVec3, v3fPoint3: IVec3): IPlane3d;

		clear(): IPlane3d;

		normalize(): IPlane3d;

		isEqual(pPlane: IPlane3d): bool;

		projectPointToPlane(v3fPoint: IVec3, v3fDestination?: IVec3): IVec3;

		solveForX(fY:  number , fZ:  number ):  number ;
		solveForY(fX:  number , fZ:  number ):  number ;
		solveForZ(fX:  number , fY:  number ):  number ;

		signedDistance(v3fPoint: IVec3):  number ;
	};
}



module akra.geometry{
	export class Plane3d implements IPlane3d{
		normal: IVec3;
		distance:  number ;

		constructor();
		constructor(pPlane: IPlane3d);
		constructor(v3fNormal: IVec3, fDistance:  number );
		constructor(v3fPoint1: IVec3, v3fPoint2: IVec3, v3fPoint3: IVec3);
		constructor(v3fPoint1?, v3fPoint2?, v3fPoint3?){

			this.normal = new Vec3();
			this.distance = 0.;

			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					this.set(arguments[0]);
					break;
				case 2:
					this.set(arguments[0], arguments[1]);
					break;
				case 3:
					this.set(arguments[0], arguments[1], arguments[2]);
					break;
				default:
					break;
			}
		};

		set(): IPlane3d;
		set(pPlane: IPlane3d): IPlane3d;
		set(v3fNormal: IVec3, fDistance:  number ): IPlane3d;
		set(v3fPoint1: IVec3, v3fPoint2: IVec3, v3fPoint3: IVec3): IPlane3d;
		set(v3fPoint1?, v3fPoint2?, v3fPoint3?): IPlane3d{
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					var pPlane: IPlane3d = arguments[0];

					this.normal.set(pPlane.normal);
					this.distance = pPlane.distance;
					break;
				case 2:
					this.normal.set(arguments[0]);
					this.distance = arguments[1];
					break;
				case 3:
					var v3fPoint1: IVec3 = arguments[0];
					var v3fPoint2: IVec3 = arguments[1];
					var v3fPoint3: IVec3 = arguments[2];

					var x1:  number  = v3fPoint2.x - v3fPoint1.x;
					var y1:  number  = v3fPoint2.y - v3fPoint1.y;
					var z1:  number  = v3fPoint2.z - v3fPoint1.z;

					var x2:  number  = v3fPoint3.x - v3fPoint1.x;
					var y2:  number  = v3fPoint3.y - v3fPoint1.y;
					var z2:  number  = v3fPoint3.z - v3fPoint1.z;

					var x:  number  = y1*z2 - y2*z1;
					var y:  number  = z1*x2 - z2*x1;
					var z:  number  = x1*y2 - x2*y1;

					this.distance = -(x*v3fPoint1.x + y*v3fPoint1.y + z*v3fPoint1.z);
					this.normal.set(x,y,z);

					break;
				default:
					this.normal.clear();
					this.distance = 0.;
					break;
			}

			return this.normalize();
		};

		/**@inline*/  clear(): IPlane3d{
			this.normal.clear();
			this.distance = 0.;
			return this;
		};

		normalize(): IPlane3d{
			var v3fNormal: IVec3 = this.normal;
			var x:  number  = v3fNormal.x, y:  number  = v3fNormal.y, z:  number  = v3fNormal.z;

			var fLength:  number  = math.sqrt(x*x + y*y + z*z);

			if(fLength !== 0.){
				var fInvLength = 1./fLength;

				v3fNormal.x = x*fInvLength;
				v3fNormal.y = y*fInvLength;
				v3fNormal.z = z*fInvLength;

				this.distance *= fInvLength;
			}

			return this;
		};

		isEqual(pPlane: IPlane3d): bool{
			return this.normal.isEqual(pPlane.normal) && (this.distance == pPlane.distance);
		};

/*предполагается работа только с нормализованной плоскостью*/

		projectPointToPlane(v3fPoint: IVec3, v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			var v3fNormal: IVec3 = this.normal;
			var fDistance:  number  = this.distance + v3fNormal.dot(v3fPoint);

			v3fDestination.x = v3fPoint.x - fDistance*v3fNormal.x;
			v3fDestination.y = v3fPoint.y - fDistance*v3fNormal.y;
			v3fDestination.z = v3fPoint.z - fDistance*v3fNormal.z;

			return v3fDestination;
		};

		solveForX(fY:  number , fZ:  number ):  number {
/*Ax+By+Cz+D=0;
			x = -(D+By+Cz)/A;*/


			var v3fNormal: IVec3 = this.normal;

			if(v3fNormal.x !== 0.){
				return -(this.distance + v3fNormal.y*fY + v3fNormal.z*fZ)/v3fNormal.x;
			}
			return 0.;
		};

		solveForY(fX:  number , fZ:  number ):  number {
/*Ax+By+Cz+D=0;
			y = -(D+Ax+Cz)/B;*/


			var v3fNormal: IVec3 = this.normal;

			if(v3fNormal.y !== 0.){
				return -(this.distance + v3fNormal.x*fX + v3fNormal.z*fZ)/v3fNormal.y;
			}
			return 0.;
		};

		solveForZ(fX:  number , fY:  number ):  number {
/*Ax+By+Cz+D=0;
			z = -(D+Ax+By)/C;*/


			var v3fNormal: IVec3 = this.normal;

			if(v3fNormal.z !== 0.){
				return -(this.distance + v3fNormal.x*fX + v3fNormal.y*fY)/v3fNormal.z;
			}

			return 0.;
		};

		signedDistance(v3fPoint: IVec3):  number {
			return this.distance + this.normal.dot(v3fPoint);
		};
	};
};













module akra.geometry{

	export function intersectPlane2dRay2d(pPlane: IPlane2d, pRay: IRay2d): bool{
		var fDistance:  number  = pPlane.signedDistance(pRay.point);
		var fNdotV:  number  = pPlane.normal.dot(pRay.normal);

		if(fDistance == 0.){
			return true;
		}
		else{
			if(fNdotV == 0.){
				return false;
			}
			else{
				if(fDistance/fNdotV < 0.){
					return true;
				}
				else{
					return false;
				}
			}
		}
	};

	export function intersectPlane3dRay3d(pPlane: IPlane3d, pRay: IRay3d): bool{
		var fDistance:  number  = pPlane.signedDistance(pRay.point);
		var fNdotV:  number  = pPlane.normal.dot(pRay.normal);

		if(fDistance == 0.){
			return true;
		}
		else{
			if(fNdotV == 0.){
				return false;
			}
			else{
				if(fDistance/fNdotV < 0.){
					return true;
				}
				else{
					return false;
				}
			}
		}
	};

	export function intersectCircleRay2d(pCircle: ICircle, pRay: IRay2d): bool{
		var v2fCenterToPoint: IVec2 = pRay.point.subtract(pCircle.center, vec2());

		var v2fNormal: IVec2 = pRay.normal;

//a*t^2+ 2b*t + c = 0;

		var fA:  number  = v2fNormal.lengthSquare();
		var fB:  number  = v2fCenterToPoint.dot(v2fNormal);
		var fC:  number  = v2fCenterToPoint.lengthSquare() - pCircle.radius*pCircle.radius;

/*b^2/4 - a*c*/
		var fDiscriminant:  number  = fB*fB - fA*fC;

		if(fDiscriminant < 0.){
			return false;
		}

		var fSqrtDiscriminant:  number  = math.sqrt(fDiscriminant);

		var fT1:  number  = (-fB + fSqrtDiscriminant)/fA;
//var fT2: float = (-fB - fSqrtDiscriminant)/fA;
//fT2 don't needed because fT2 < fT1 always
//since fA > 0

		if(fT1 < 0.){
			return false;
		}
		else{
			return true;
		}
	};

	export function intersectSphereRay3d(pSphere: ISphere, pRay: IRay3d): bool{
		var v3fCenterToPoint: IVec3 = pRay.point.subtract(pSphere.center, vec3());

		var v3fNormal: IVec3 = pRay.normal;

//a*t^2+ 2b*t + c = 0;

		var fA:  number  = v3fNormal.lengthSquare();
		var fB:  number  = v3fCenterToPoint.dot(v3fNormal);
		var fC:  number  = v3fCenterToPoint.lengthSquare() - pSphere.radius*pSphere.radius;

/*b^2/4 - a*c*/
		var fDiscriminant:  number  = fB*fB - fA*fC;

		if(fDiscriminant < 0.){
			return false;
		}

		var fSqrtDiscriminant:  number  = math.sqrt(fDiscriminant);

		var fT1:  number  = (-fB + fSqrtDiscriminant)/fA;
//var fT2: float = (-fB - fSqrtDiscriminant)/fA;
//fT2 don't needed because fT2 < fT1 always
//since fA > 0

		if(fT1 < 0.){
			return false;
		}
		else{
			return true;
		}
	};

	export function intersectRect2dRay2d(pRect: IRect2d, pRay: IRay2d): bool{
		var v2fNormal: IVec2 = pRay.normal;
		var v2fPoint: IVec2 = pRay.point;

		var fT1:  number , fT2:  number ;

		var fX1:  number , fX2:  number ;
		var fY1:  number , fY2:  number ;

		if(v2fNormal.x != 0.){
			fT1 = (pRect.x0 - v2fPoint.x)/v2fNormal.x;
			fT2 = (pRect.x1 - v2fPoint.x)/v2fNormal.x;
		}
		else{
			fT1 = (pRect.y0 - v2fPoint.y)/v2fNormal.y;
			fT2 = (pRect.y1 - v2fPoint.y)/v2fNormal.y;
		}

		if(fT1 < 0 && fT2 < 0){
			return false;
		}

		fT1 = math.max(fT1,0.);
		fT2 = math.max(fT2,0.);

		fX1 = v2fPoint.x + fT1*v2fNormal.x;
		fX2 = v2fPoint.x + fT2*v2fNormal.x;

		fY1 = v2fPoint.y + fT1*v2fNormal.y;
		fY2 = v2fPoint.y + fT2*v2fNormal.y;

		if(		(fX1 < pRect.x0 && fX2 < pRect.x0)
			||  (fX1 > pRect.x1 && fX2 > pRect.x1)

			||  (fY1 < pRect.y0 && fY2 < pRect.y0)
			||  (fY1 > pRect.y1 && fY2 > pRect.y1)){

			return false;
		}

		return true;
	};

	export function intersectRect3dRay3d(pRect: IRect3d, pRay: IRay3d): bool{
		var v3fNormal: IVec3 = pRay.normal;
		var v3fPoint: IVec3 = pRay.point;

		var fT1:  number , fT2:  number ;

		var fX1:  number , fX2:  number ;
		var fY1:  number , fY2:  number ;
		var fZ1:  number , fZ2:  number ;

		if(v3fNormal.x != 0.){
			fT1 = (pRect.x0 - v3fPoint.x)/v3fNormal.x;
			fT2 = (pRect.x1 - v3fPoint.x)/v3fNormal.x;
		}
		else if(v3fNormal.y != 0.){
			fT1 = (pRect.y0 - v3fPoint.y)/v3fNormal.y;
			fT2 = (pRect.y1 - v3fPoint.y)/v3fNormal.y;
		}
		else{
			fT1 = (pRect.z0 - v3fPoint.z)/v3fNormal.z;
			fT2 = (pRect.z1 - v3fPoint.z)/v3fNormal.z;
		}

		if(fT1 < 0 && fT2 < 0){
			return false;
		}

		fT1 = math.max(fT1,0.);
		fT2 = math.max(fT2,0.);

		fX1 = v3fPoint.x + fT1*v3fNormal.x;
		fX2 = v3fPoint.x + fT2*v3fNormal.x;

		fY1 = v3fPoint.y + fT1*v3fNormal.y;
		fY2 = v3fPoint.y + fT2*v3fNormal.y;

		fZ1 = v3fPoint.z + fT1*v3fNormal.z;
		fZ2 = v3fPoint.z + fT2*v3fNormal.z;

		if(		(fX1 < pRect.x0 && fX2 < pRect.x0)
			||  (fX1 > pRect.x1 && fX2 > pRect.x1)

			||  (fY1 < pRect.y0 && fY2 < pRect.y0)
			||  (fY1 > pRect.y1 && fY2 > pRect.y1)

			||	(fZ1 < pRect.z0 && fZ2 < pRect.z0)
			||  (fZ1 > pRect.z1 && fZ2 > pRect.z1)){

			return false;
		}

		return true;
	};

	export function intersectCircleCircle(pCircle1: ICircle, pCircle2: ICircle): bool{
		var v2fCenter1: IVec2 = pCircle1.center;
		var v2fCenter2: IVec2 = pCircle2.center;

		var fX:  number  = v2fCenter2.x - v2fCenter1.x;
		var fY:  number  = v2fCenter2.y - v2fCenter1.y;

		var fContactRadius:  number  = pCircle1.radius + pCircle2.radius;

		if((fX*fX + fY*fY) > fContactRadius*fContactRadius){
			return false;
		}
		return true;
	};

	export function intersectSphereSphere(pSphere1: ISphere, pSphere2: ISphere): bool{
		var v3fCenter1: IVec3 = pSphere1.center;
		var v3fCenter2: IVec3 = pSphere2.center;

		var fX:  number  = v3fCenter2.x - v3fCenter1.x;
		var fY:  number  = v3fCenter2.y - v3fCenter1.y;
		var fZ:  number  = v3fCenter2.z - v3fCenter1.z;

		var fContactRadius:  number  = pSphere1.radius + pSphere2.radius;

		if((fX*fX + fY*fY + fZ*fZ) > fContactRadius*fContactRadius){
			return false;
		}
		return true;
	};

	export function intersectRect2dCircle(pRect: IRect2d, pCircle: ICircle){
		var v2fCenter: IVec2 = pCircle.center;
		var fOffsetX:  number  = 0., fOffsetY:  number  = 0.;
		var nInside:  number  = 0;

		if(v2fCenter.x < pRect.x0){
			fOffsetX = pRect.x0 - v2fCenter.x;
		}
		else if(v2fCenter.x > pRect.x1){
			fOffsetX = v2fCenter.x - pRect.x1;
		}
		else{
			nInside++;
		}

		if(v2fCenter.y < pRect.y0){
			fOffsetY = pRect.y0 - v2fCenter.y;
		}
		else if(v2fCenter.y > pRect.y1){
			fOffsetY = v2fCenter.y - pRect.y1;
		}
		else{
			nInside++;
		}

//if nInside == 2 then circle inside rect
		if(nInside === 2){
			return true;
		}

		var fOffsetLengthSquare:  number  = fOffsetX*fOffsetX + fOffsetY*fOffsetY;
		var fRadius:  number  = pCircle.radius;

		if(fOffsetLengthSquare > fRadius*fRadius){
			return false;
		}
		return true;
	};

	export function intersectRect3dSphere(pRect: IRect3d, pSphere: ISphere){
		var v3fCenter: IVec3 = pSphere.center;
		var fOffsetX:  number  = 0., fOffsetY:  number  = 0., fOffsetZ:  number  = 0.;
		var nInside:  number  = 0;

		if(v3fCenter.x < pRect.x0){
			fOffsetX = pRect.x0 - v3fCenter.x;
		}
		else if(v3fCenter.x > pRect.x1){
			fOffsetX = v3fCenter.x - pRect.x1;
		}
		else{
			nInside++;
		}

		if(v3fCenter.y < pRect.y0){
			fOffsetY = pRect.y0 - v3fCenter.y;
		}
		else if(v3fCenter.y > pRect.y1){
			fOffsetY = v3fCenter.y - pRect.y1;
		}
		else{
			nInside++;
		}

		if(v3fCenter.z < pRect.z0){
			fOffsetZ = pRect.z0 - v3fCenter.z;
		}
		else if(v3fCenter.z > pRect.z1){
			fOffsetZ = v3fCenter.z - pRect.z1;
		}
		else{
			nInside++;
		}

//if nInside == 3 then sphere inside rect
		if(nInside === 3){
			return true;
		}

		var fOffsetLengthSquare:  number  = fOffsetX*fOffsetX + fOffsetY*fOffsetY + fOffsetZ*fOffsetZ;
		var fRadius:  number  = pSphere.radius;

		if(fOffsetLengthSquare > fRadius*fRadius){
			return false;
		}
		return true;
	};

	export function intersectRect2dRect2d(pRect1: IRect2d, pRect2: IRect2d, pResult?: IRect2d): bool{
		if(!isDef(pResult)){
			var fX0:  number  = math.max(pRect1.x0, pRect2.x0);
			var fX1:  number  = math.min(pRect1.x1, pRect2.x1);
			if(fX0 <= fX1){
				var fY0:  number  = math.max(pRect1.y0, pRect2.y0);
				var fY1:  number  = math.min(pRect1.y1, pRect2.y1);
				if(fY0 <= fY1){
					return true;
				}
			}
			return false;
		}
		else{
			pResult.x0 = math.max(pRect1.x0, pRect2.x0);
			pResult.x1 = math.min(pRect1.x1, pRect2.x1);

			pResult.y0 = math.max(pRect1.y0, pRect2.y0);
			pResult.y1 = math.min(pRect1.y1, pRect2.y1);

			return pResult.isValid();
		}
	};

	export function intersectRect3dRect3d(pRect1: IRect3d, pRect2: IRect3d, pResult?: IRect3d): bool{
		if(!isDef(pResult)){
			var fX0:  number  = math.max(pRect1.x0, pRect2.x0);
			var fX1:  number  = math.min(pRect1.x1, pRect2.x1);
			if(fX0 <= fX1){
				var fY0:  number  = math.max(pRect1.y0, pRect2.y0);
				var fY1:  number  = math.min(pRect1.y1, pRect2.y1);
				if(fY0 <= fY1){
					var fZ0:  number  = math.max(pRect1.z0, pRect2.z0);
					var fZ1:  number  = math.min(pRect1.z1, pRect2.z1);
					if(fZ0 <= fZ1){
						return true;
					}
				}
			}
			return false;
		}
		else{
			pResult.x0 = math.max(pRect1.x0, pRect2.x0);
			pResult.x1 = math.min(pRect1.x1, pRect2.x1);

			pResult.y0 = math.max(pRect1.y0, pRect2.y0);
			pResult.y1 = math.min(pRect1.y1, pRect2.y1);

			pResult.z0 = math.max(pRect1.z0, pRect2.z0);
			pResult.z1 = math.min(pRect1.z1, pRect2.z1);

			return pResult.isValid();
		}
	};

	export function intersect(pPlane: IPlane2d, pRay: IRay2d): bool;
	export function intersect(pPlane: IPlane3d, pRay: IRay3d): bool;
	export function intersect(pCircle: ICircle, pRay: IRay2d): bool;
	export function intersect(pSphere: ISphere, pRay: IRay3d): bool;
	export function intersect(pRect: IRect2d, pRay: IRay2d): bool;
	export function intersect(pRect: IRect3d, pRay: IRay3d): bool;
	export function intersect(pCircle1: ICircle, pCircle2: ICircle): bool;
	export function intersect(pSphere1: ISphere, pSphere2: ISphere): bool;
	export function intersect(pRect: IRect2d, pCircle: ICircle): bool;
	export function intersect(pRect: IRect3d, pSphere: ISphere): bool;
	export function intersect(pRect1: IRect2d, pRect2: IRect2d, pResult?: IRect2d): bool;
	export function intersect(pRect1: IRect3d, pRect2: IRect3d, pResult?: IRect3d): bool;
	export function intersect(pRect1?, pRect2?, pResult?): bool{
		var nArgumentsLength:  number  = arguments.length;

		if(nArgumentsLength === 3){
			if(arguments[2] instanceof Rect2d){
				return intersectRect2dRect2d(arguments[0], arguments[1], arguments[2]);
			}
			else{
				return intersectRect3dRect3d(arguments[0], arguments[1], arguments[2]);
			}
		}
		else{
			var pArg0: any = arguments[0];
			var pArg1: any = arguments[1];

			if(pArg1 instanceof Ray2d){
				if(pArg0 instanceof Plane2d){
					return intersectPlane2dRay2d(pArg0, pArg1);
				}
				else if(pArg0 instanceof Circle){
					return intersectCircleRay2d(pArg0, pArg1);
				}
				else{
					return intersectRect2dRay2d(pArg0, pArg1);
				}
			}
			else if(pArg1 instanceof Ray3d){
				if(pArg0 instanceof Plane3d){
					return intersectPlane3dRay3d(pArg0, pArg1);
				}
				else if(pArg0 instanceof Sphere){
					return intersectSphereRay3d(pArg0, pArg1);
				}
				else{
					return intersectRect3dRay3d(pArg0, pArg1);
				}
			}
			else if(pArg1 instanceof Circle){
				if(pArg0 instanceof Circle){
					return intersectCircleCircle(pArg0, pArg1);
				}
				else{
					return intersectRect2dCircle(pArg0, pArg1);
				}
			}
			else if(pArg1 instanceof Sphere){
				if(pArg0 instanceof Sphere){
					return intersectSphereSphere(pArg0, pArg1);
				}
				else{
					return intersectRect3dSphere(pArg0, pArg1);
				}
			}
			else{
				if(pArg0 instanceof Rect2d){
					return intersectRect2dRect2d(pArg0, pArg1);
				}
				else{
					return intersectRect3dRect3d(pArg0, pArg1);
				}
			}
		}
	};
};



module akra.scene {
	export enum EOcTreeConstants {
	    k_MinimumTreeDepth = 0,
	    k_MaximumTreeDepth = 10
    };

	export class OcTree extends DisplayList implements IOcTree {
/** List of OcTreeNodes on each level */

//protected _ppLevelNodes: IOcTreeNode[][] = null;
/** First node in list of all nodes */

//protected _pFirstNode: IOcTreeNode = null;
		/**@protected*/  _pHead: IOcTreeNode = null;
/** Size of world bounding box */

		/**@protected*/  _v3fWorldExtents: IVec3 = new Vec3();
/** Negate min point of bounding box */

		/**@protected*/  _v3fWorldScale: IVec3 = new Vec3();
/** Value of relation between (1024,1024,1024) and bounding box size */

		/**@protected*/  _v3fWorldOffset: IVec3 = new Vec3();
/** Maximum depth of tree. Value set when you call OcTree::create() */

		/**@protected*/  _iDepth:  number  = 0;
//protected _iSize: int = 0;//2^iDepth;
/** 
		 * Список свободных узлов(объектов OcTreeNode). 
		 * Необходимо для экономии ресурсов памяти и чтобы не делать лишних delete 
		 */

		/**@protected*/  _pFreeNodePool: IOcTreeNode[] = null;
/**
		 * Список байтовых ректов ректа камеры для тестов объектов.
		 */

//protected _pTestLocalRect: IOcTreeRect[] = null;

		constructor () {
			super();
			this.name = "OcTree";
		};

		/**@inline*/  get depth():  number {
			return this._iDepth;
		};

		/**@inline*/  get worldScale(): IVec3{
			return this._v3fWorldScale;
		};

		/**@inline*/  get worldOffset(): IVec3{
			return this._v3fWorldOffset;
		};

/**
		 * Create
		 */

		create(pWorldBoundingBox: IRect3d, iDepth:  number , nNodes:  number  = 64): void {

		    var v3fTemp: IVec3 = vec3();
		    var i:  number  = 0;


		    logger.setSourceLocation( "scene/OcTree.ts" , 72 ); logger.assert(!this.isReady(), "the Oc tree has already been created"); ;
		    logger.setSourceLocation( "scene/OcTree.ts" , 74 ); logger.assert(iDepth >= EOcTreeConstants.k_MinimumTreeDepth && iDepth <= EOcTreeConstants.k_MaximumTreeDepth, "invalid tree depth");
                                                                              ;

		    this._iDepth = iDepth;

		    this._v3fWorldExtents.set(pWorldBoundingBox.size(v3fTemp));

		    this._v3fWorldOffset.set(pWorldBoundingBox.minPoint(v3fTemp).negate());

		    var iSize:  number  = 1 << iDepth;

		    this._v3fWorldScale.x = iSize / this._v3fWorldExtents.x;
		    this._v3fWorldScale.y = iSize / this._v3fWorldExtents.y;
		    this._v3fWorldScale.z = iSize / this._v3fWorldExtents.z;

// allocate the nodes
// this._ppLevelNodes = new Array(iDepth);

// for (i = 0; i < iDepth; ++i) {
//     this._ppLevelNodes[i] = new Array();
// }

// this._pTestLocalRect = new Array(iDepth);

// for (i = 0; i < iDepth; ++i) {
//     this._pTestLocalRect[i] = new OcTreeRect;
// }

		    this._pHead = new OcTreeRootNode(this) ;
		    this._pHead.level = 0;

		    this._pFreeNodePool = new Array();

		    for (i = 0; i < nNodes; ++i) {
		        this._pFreeNodePool.push(new OcTreeNode(this));
		    }
		}

/**
		 * is any levels of tree are availeable(some object in a tree)
		 */

		isReady(): bool {
			if(this._iDepth > 0){
				return true;
			}
			else{
				return false;
			}
		}

/**
		 * find node
		 */

		findTreeNode(pObject: ISceneObject): IOcTreeNode {
		    var pRect: IRect3d = pObject.worldBounds;
		    var iX0:  number  = pRect.x0, iX1:  number  = pRect.x1,
		        iY0:  number  = pRect.y0, iY1:  number  = pRect.y1,
		        iZ0:  number  = pRect.z0, iZ1:  number  = pRect.z1;

		    var v3fWorldOffset: IVec3 = this._v3fWorldOffset;
		    var v3fWorldScale: IVec3 = this._v3fWorldScale;

		    iX0 += v3fWorldOffset.x; iX1 += v3fWorldOffset.x;
		    iY0 += v3fWorldOffset.y; iY1 += v3fWorldOffset.y;
		    iZ0 += v3fWorldOffset.z; iZ1 += v3fWorldOffset.z;

		    iX0 *= v3fWorldScale.x; iX1 *= v3fWorldScale.x;
		    iY0 *= v3fWorldScale.y; iY1 *= v3fWorldScale.y;
		    iZ0 *= v3fWorldScale.z; iZ1 *= v3fWorldScale.z;

//round it
		    iX0 = math.floor(iX0); iX1 = math.ceil(iX1);
		    iY0 = math.floor(iY0); iY1 = math.ceil(iY1);
		    iZ0 = math.floor(iZ0); iZ1 = math.ceil(iZ1);

		    iX1 = (iX1 === iX0) ? iX0 + 1 : iX1;
		    iY1 = (iY1 === iY0) ? iY0 + 1 : iY1;
		    iZ1 = (iZ1 === iZ0) ? iZ0 + 1 : iZ1;

//var iMax1: int = 1 << this._iDepth - 2;
//var iMax2: int = 1 << this._iDepth - 1;

//iX0 = math.clamp(iX0, 0, iMax1);
//iY0 = math.clamp(iY0, 0, iMax1);
//iZ0 = math.clamp(iZ0, 0, iMax1);

//iX1 = math.clamp(iX1, iX0 + 1, iMax2);
//iY1 = math.clamp(iY1, iY0 + 1, iMax2);
//iZ1 = math.clamp(iZ1, iZ0 + 1, iMax2);

// console.error('zzzzzz', iX0, iX1, iY0, iY1, iZ0, iZ1);

		    var pNode: IOcTreeNode = this.findTreeNodeByRect(iX0, iX1, iY0, iY1, iZ0, iZ1);

		    return pNode;
		};

/**
		 * Find tree node by Rect
		 */

		findTreeNodeByRect(iX0:  number , iX1:  number , iY0:  number , iY1:  number , iZ0:  number , iZ1:  number ): IOcTreeNode {

			var nMax:  number  = (1 << this._iDepth);

			if(iX0 < 0 || iX1 > nMax || iY0 < 0 || iY1 > nMax
				|| iZ0 < 0 || iZ1 > nMax){

				return this._pHead;
			}

			var iDepth:  number  = this._iDepth;
		    var iLevel:  number ;

///////////////////////////
		    iLevel = this._findNodeLevel(iX0, iX1, iY0, iY1, iZ0, iZ1);

// console.warn(iLevel);
///////////////////////////

		    if(iLevel == 0){
		    	return this._pHead;
		    }

		    var iComposedIndex:  number ;
		    var iShift:  number  = iDepth - iLevel;
		    iComposedIndex = (iX0 >> (iDepth - iLevel)) << (2*iDepth + iShift);
// console.log(iComposedIndex);
		    iComposedIndex += (iY0 >> (iDepth - iLevel)) << (iDepth + iShift);
// console.log(iComposedIndex);
		    iComposedIndex += (iZ0 >> (iDepth - iLevel)) << (iShift);

//console.log(iComposedIndex, iX0, iY0, iZ0);

			var iWay:  number ;

            var pParentNode: IOcTreeNode, pNode: IOcTreeNode
		    pParentNode = this._pHead;
		    pNode = null;

		    var iTmpX:  number , iTmpY:  number , iTmpZ:  number ;
		    var iX:  number , iY:  number , iZ:  number ;

		    var i:  number  = 0;
			while(i < iLevel){

				iTmpX = iX0; iTmpY = iY0; iTmpZ = iZ0;

				iX = (iTmpX >> (iDepth - i - 1)) & 1;
		    	iY = (iTmpY >> (iDepth - i - 1)) & 1;
		    	iZ = (iTmpZ >> (iDepth - i - 1)) & 1;

				iWay = 4*iX + 2*iY + iZ;

// console.log('iWay -------------->', iWay, '<--------------');

				var pNodeList: IObjectList = pParentNode.childrenList[iWay];
// console.log(pParentNode);

				if(pNodeList.length === 0){
					pNode = this.getAndSetFreeNode(iLevel, iComposedIndex, pParentNode);
					pNodeList.push(pNode);
					return pNode;
				}

				var iPosition:  number  = 0;
				var pTestNode: IOcTreeNode = pNodeList.first;

				var iTestMask:  number  = (iDepth >= i + 2) ? 1 << (iDepth - i - 2) : 0;

				var iMask:  number   = (iTestMask << (2*iDepth)) + (iTestMask << iDepth) + iTestMask;
// console.log('mask-------------->',iMask,'<-----------');

				var pParentNodeOld: IOcTreeNode = pParentNode;

				while(isDefAndNotNull(pTestNode)){

					var iTest:  number  = pTestNode.index & iComposedIndex;

// console.log(pTestNode);
// console.error('iLevel--->', iLevel,'iTest ------------>', iTest);
// console.error('testNode index', pTestNode.index, 'composed index', iComposedIndex);

					var iResult1:  number  = pTestNode.index & iMask;
					var iResult2:  number  = iComposedIndex & iMask;

// console.warn(iResult1, iResult2);

					if(iResult1 === iResult2){
						if(pTestNode.level === iLevel){
							return pTestNode;
						}
						else if(pTestNode.level < iLevel){
							pParentNode = pTestNode;
							i = pTestNode.level;
							break;
						}
						else{
//alert("" + <string><any>pTestNode.level + "  " + <string><any>iLevel);
							if(pNode === null){
								pNode = this.getAndSetFreeNode(iLevel, iComposedIndex, pParentNode);
								pParentNode.childrenList[iWay].push(pNode);
								i = iLevel;
							}

							var iTestIndex:  number  = pTestNode.index;
							var iShift = iDepth - i - 1;

							iX = (iTestIndex >> (2*iDepth + iShift))&1;
							iY = (iTestIndex >> (iDepth + iShift))&1;
							iZ = (iTestIndex >> iShift)&1;

							var iTestWay:  number  = 4*iX + 2*iY + iZ;

							pNodeList.takeAt(iPosition);
							pNodeList.seek(iPosition-1);
							iPosition--;

							pNode.childrenList[iTestWay].push(pTestNode);
							pTestNode.rearNodeLink = pNode;
						}
					}

					pTestNode = pNodeList.next();
					iPosition++;
				}

				if(pNode === null && pParentNodeOld === pParentNode){
					pNode = this.getAndSetFreeNode(iLevel, iComposedIndex, pParentNode);
					pParentNode.childrenList[iWay].push(pNode);
					break;
				}
			}

			return pNode;
		};

		private _findNodeLevel(iX0:  number , iX1:  number , iY0:  number , iY1:  number , iZ0:  number , iZ1:  number ):  number {
			var iLengthX:  number  = iX1 - iX0;
			var iLengthY:  number  = iY1 - iY0;
			var iLengthZ:  number  = iZ1 - iZ0;

			var iLength:  number  = math.max(iLengthX, math.max(iLengthY, iLengthZ));
//maximum possible level
			var iLevel:  number  = this._iDepth - math.floor(math.log(iLength) / math.LN2);

			while(iLevel > 0){
				var iPitch:  number  = 1 << (this._iDepth - iLevel);
				var iTest1:  number , iTest2:  number ;

//first test for x then for y and z

				var i;
				for(i=0; i<3; i++){
					iTest1 = math.floor(arguments[2*i] / iPitch);
					iTest2 = math.floor(arguments[2*i + 1] / iPitch);

					if(iTest1 != iTest2){
						if((iTest1 + 1) == iTest2){
							if((arguments[2*i+1]%iPitch) != 0){
								break;
							}
						}
						else{
							break;
						}
					}
				}
				if(i!=3){
					iLevel--;
				}
				else{
					break;
				}
			}
			return iLevel;
		};

/**
		 * Get free node. 
		 * Get it from _pFreeNodePull or create new OcTreeNode if it`s empty and set his data.
		 */

		getAndSetFreeNode(iLevel:  number , iComposedIndex:  number , pParentNode: IOcTreeNode): IOcTreeNode {
			var pNode: IOcTreeNode = this._pFreeNodePool.pop();
			if (!isDefAndNotNull(pNode)) {
		        pNode = new OcTreeNode(this);
		    }


			var iDepth:  number  = this._iDepth;
			var iMask:  number  = (1<<this._iDepth) - 1;
			var iIndexX:  number  = (iComposedIndex >> (2*iDepth)) & iMask;
			var iIndexY:  number  = (iComposedIndex >> (iDepth)) & iMask;
			var iIndexZ:  number  = iComposedIndex & iMask;
			var iSize:  number  = 1 << (this._iDepth - iLevel);

		    pNode.level = iLevel;
// pNode.x = iX;
// pNode.y = iY;
// pNode.z = iZ;
		    pNode.index = iComposedIndex;
		    pNode.rearNodeLink = pParentNode;
		    pNode.worldBounds.set(iIndexX, iIndexX + iSize, iIndexY, iIndexY + iSize, iIndexZ, iIndexZ + iSize);
		    pNode.worldBounds.divSelf(this._v3fWorldScale);
		    pNode.worldBounds.subSelf(this._v3fWorldOffset)

//this._ppLevelNodes[iLevel][iIndex] = pNode;

// if (this._pFirstNode) {
//     this._pFirstNode.rearNodeLink = pNode;
// }

// pNode.forwardNodeLink = this.pFirstNode;
// pNode.rearNodeLink = null;

//this._pFirstNode = pNode;
/*
		     var i,j;
		     var pTempNode;
		     for(i=iLevel-1; i>=0; --i){
		     j = (((iZ>>(iLevel-i))<<i)<<i) + ((iY>>(iLevel-i))<<i) + (iX>>(iLevel-i));
		     pTempNode = this._ppLevelNodes[i][j];
		     if (pTempNode) {
		     this.pParentNode = pTempNode;
		     this.pSibling = pTempNode.pChildren;
		     pTempNode.pChildren = this;
		     break;
		     }
		     }
		     */

		    return pNode;
		};

/**
		 * Delete node from tree
		 */

		deleteNodeFromTree(pNode: IOcTreeNode): void {
			var pParentNode: IOcTreeNode = pNode.rearNodeLink;

// console.error(pNode,pParentNode);

			logger.setSourceLocation( "scene/OcTree.ts" , 413 ); logger.assert(pNode.membersList.length == 0,"list members of node don't empty"); ;

			var iDepth:  number  = this._iDepth;
			var iParentLevel:  number  = pParentNode.level;
			var iIndex:  number  = pNode.index;
			var iShift:  number  = iDepth - iParentLevel - 1;

			var iX:  number  = (iIndex >> (2*iDepth + iShift))&1;
			var iY:  number  = (iIndex >> (iDepth + iShift))&1;
			var iZ:  number  = (iIndex >> iShift)&1;

			var iWay:  number  = 4*iX + 2*iY + iZ;

			var pParentBranch: IObjectList = pParentNode.childrenList[iWay];

//console.log('iWay ------------>', iWay);

			var iNode:  number  = pParentBranch.indexOf(pNode);

			logger.setSourceLocation( "scene/OcTree.ts" , 432 ); logger.assert(iNode != -1, "can't remove node from parent, node not found"); ;

//deleting node from parent list
			pParentBranch.takeAt(iNode);

			for(var i=0;i<8;i++){
				var pChildrens: IObjectList = pNode.childrenList[i];
				while(pChildrens.length){
					var pChildNode: IOcTreeNode = pChildrens.pop();
					pChildNode.rearNodeLink = pParentNode;
					pParentBranch.push(pChildNode);
				}
			}

			pNode.level = 0;
			pNode.rearNodeLink = null;
			pNode.worldBounds.clear();

		    this._pFreeNodePool.push(pNode);
		};

/**
		 * Test rect and frustum
		 */


		_buildSearchResults(pSearchRect: IRect3d, pOptionalFrustum?: IFrustum): IObjectArray{
			var pResult: IObjectArray = new util.ObjectArray();
			if(arguments.length === 1){
				this._buildSearchResultsByRect(pSearchRect, this._pHead, pResult);
			}
			else{
				this._buildSearchResultsByRectAndFrustum(pSearchRect, pOptionalFrustum,
				 this._pHead, pResult);
			}

			return pResult;
		};

		/**@protected*/  _buildSearchResultsByRect(pSearchRect: IRect3d, pNode: IOcTreeNode, pResultList: IObjectArray){
			var pNodeRect: IRect3d = pNode.worldBounds;

			var kResult: EVolumeClassifications = geometry.classifyRect3d(pSearchRect, pNodeRect);

			if(kResult == EVolumeClassifications.B_CONTAINS_A
				|| kResult == EVolumeClassifications.INTERSECTING){

//надо проводить дополнительные тесты

				var pMemberList: IObjectList = pNode.membersList;
				var pObject: ISceneObject = pMemberList.first;
				while(isDefAndNotNull(pObject)){
					if(geometry.intersectRect3dRect3d(pSearchRect, pObject.worldBounds)){
						pResultList.push(pObject);
					}
					pObject = pMemberList.next();
				}

				for(var i: number  = 0; i < 8; i++){
					var pChildrenList: IObjectList = pNode.childrenList[i];
					var pChildNode: IOcTreeNode = pChildrenList.first;

					while(isDefAndNotNull(pChildNode)){
						this._buildSearchResultsByRect(pSearchRect, pChildNode, pResultList);
						pChildNode = pChildrenList.next();
					}
				}
			}
			else if(kResult != EVolumeClassifications.NO_RELATION){
//объект полностью попал
				this._includeAllTreeSubbranch(pNode, pResultList);
			}
		};

		/**@protected*/  _buildSearchResultsByRectAndFrustum(pSearchRect: IRect3d, pOptionalFrustum: IFrustum,
			pNode: IOcTreeNode, pResultList: IObjectArray){

			var pNodeRect: IRect3d = pNode.worldBounds;
//var pChildRect: IRect3d;

			if(geometry.intersectRect3dRect3d(pSearchRect, pNodeRect)){
				var kTestResult:  number  = geometry.classifyFrustumRect3d(pOptionalFrustum, pNodeRect);
				if(kTestResult == EVolumeClassifications.A_CONTAINS_B){
//объект полностью попал	
					this._includeAllTreeSubbranch(pNode, pResultList);
				}
				else if(kTestResult == EVolumeClassifications.INTERSECTING){
//объект попал частично
					var pMemberList: IObjectList = pNode.membersList;
					var pObject: ISceneObject = pMemberList.first;
					while(isDefAndNotNull(pObject)){
						if(pOptionalFrustum.testRect(pObject.worldBounds)){
							pResultList.push(pObject);
						}
						pObject = pMemberList.next();
					}

					for(var i: number  = 0; i < 8; i++){
//TODO: test by child rect
						var pChildrenList: IObjectList = pNode.childrenList[i];
						var pChildNode: IOcTreeNode = pChildrenList.first;
						while(isDefAndNotNull(pChildNode)){
							this._buildSearchResultsByRectAndFrustum(pSearchRect, pOptionalFrustum, pChildNode, pResultList);
							pChildNode = pChildrenList.next();
						}
					}
				}
			}
		};

		/**@protected*/  _includeAllTreeSubbranch(pNode: IOcTreeNode, pResultList: IObjectArray){
//console.warn("----------------> including all subbranch <------------------");
			var pMemberList: IObjectList = pNode.membersList;
			var pObject: ISceneObject = pMemberList.first;
			while(isDefAndNotNull(pObject)){
				pResultList.push(pObject);
				pObject = pMemberList.next();
			}

			for(var i: number  = 0; i < 8; i++){
				var pChildrenList: IObjectList = pNode.childrenList[i];
				var pChildNode: IOcTreeNode = pChildrenList.first;

				while(isDefAndNotNull(pChildNode)){
					this._includeAllTreeSubbranch(pChildNode, pResultList);
					pChildNode = pChildrenList.next();
				}
			}
		};

		_findObjects(pCamera: ICamera, bFastSearch: bool = false): IObjectArray{
//while we ignore second parametr
//don't have normal implementation

			return this._buildSearchResults(pCamera.searchRect, pCamera.frustum);
		}

		/**@protected*/  attachObject(pNode: ISceneNode): void {
			console.error(pNode, isSceneObject(pNode));
			if(isSceneObject(pNode)){
				var pOcTreeNode: IOcTreeNode = this.findTreeNode(<ISceneObject>pNode);
				pOcTreeNode.addMember(<ISceneObject>pNode);
			}
		};

		/**@protected*/  detachObject(pNode: ISceneNode): void {
			if(isSceneObject(pNode)){
				var pOcTreeNode: IOcTreeNode = this.findTreeNode(<ISceneObject>pNode);
				pOcTreeNode.removeMember(<ISceneObject>pNode);
			}
		};

		_toSimpleObject(pNode?: IOcTreeNode = this._pHead): any{

			var pResult: any = {};
			pResult.members = [];
			pResult.childrens = new Array(8);
			for(var i: number  = 0; i < 8; i++){
				pResult.childrens[i] = [];
			}
			pResult.level = pNode.level;
			pResult.index = pNode.index;
			pResult.worldBounds = pNode.worldBounds;


			var pMemberList: IObjectList = pNode.membersList;
			var pObject: ISceneObject = pMemberList.first;
			while(isDefAndNotNull(pObject)){
				pResult.members.push(pObject.worldBounds);
				pObject = pMemberList.next();
			}

			for(var i: number  = 0; i < 8; i++){
				var pList: IObjectList = pNode.childrenList[i];
				var pChildNode: IOcTreeNode = pList.first;

				while(isDefAndNotNull(pChildNode)){
					pResult.childrens[i].push(this._toSimpleObject(pChildNode));
					pChildNode = pList.next();
				}
			}

			return pResult;
		};

/**
		 * Getter for OcTreeNode by level and x, y, z
		 */

// getNodeFromLevelXYZ(iLevel: int, iIndex: int): IOcTreeNode {
//     debug_assert(this.isReady(), "the Oc tree has not been created");

//     if (iLevel >= 0 && iLevel < this._iDepth) {
//         return this._ppLevelNodes[iLevel][iIndex];
//     }

//     return null;
// }



/**
		 * Destroy tree and all nodes in tree. Set _iDepth to 0.
		 */

// destroy(): void {
//     var i: int;

//     // for (i = 0; i < this._iDepth; ++i) {
//     //     delete this._ppLevelNodes[i];
//     // }

//     for (i = 0; i < this._pFreeNodePool.length; ++i) {
//         delete this._pFreeNodePool[i];
//     }

//     //this._ppLevelNodes = null;
//     this._pFreeNodePool = null;
//     this._iDepth = 0;
// }




// /**
//  * Build pByteRect from Rect3d
//  * Convert to integer values, taking the floor of each real
//  */
// inline buildByteRect(pWorldRect: IRect3d, pWorldByteRect: IOcTreeRect): void {
//     pWorldByteRect.convert(pWorldRect, this._v3fWorldOffset, this._v3fWorldScale);
// };

	}
}










module akra{

	export interface IDisplayList {} ;
	export interface ICamera {} ;
	export interface IObjectArray {} ;

	export interface ILightGraph extends IDisplayList{
//_findObjects(pCamera: ICamera, bQuickSearch: bool): IObjectArray;
	};
};















module akra {
	export interface ILightParameters {
//default parameters
	    ambient: IColor;
	    diffuse: IColor;
	    specular: IColor;
	    attenuation: IVec3;
	}

	export interface ILightPoint extends ISceneNode {
		params: ILightParameters;
		enabled: bool;

		isShadowCaster(): bool;
		setShadowCasting(bValue?: bool): void;

		_calculateShadows(): void;
	}
}








module akra.scene.light {
	export  class  LightParameters implements ILightParameters {
		ambient: IColor = new Color;
	    diffuse: IColor = new Color;
	    specular: IColor = new Color;
	    attenuation: IVec3 = new Vec3;
	}

	export class LightPoint extends SceneNode implements ILightPoint {
		/**@protected*/  _bCastShadows: bool = false;
		/**@protected*/  _isEnabled: bool = true;
		/**@protected*/  _iMaxShadowResolution:  number  = 256;
		/**@protected*/  _pLightParameters: ILightParameters = new LightParameters;

		/**@inline*/  get enabled(): bool{
			return this._isEnabled;
		};

		/**@inline*/  set enabled(bValue: bool){
			this._isEnabled = bValue;
		}


		/**@inline*/  get params(): ILightParameters {
			return this._pLightParameters;
		}

		create(isShadowCaster: bool = true, iMaxShadowResolution:  number  = 256): bool {
			var isOk: bool = super.create();

//активен ли источник
			this._isEnabled = true;
//есть тени от источника или нет
			this._bCastShadows = isShadowCaster;
//мкасимальный размер shadow текстуры
			this._iMaxShadowResolution = math.ceilingPowerOfTwo(iMaxShadowResolution);

			return isOk;
		}

		/**@inline*/  isShadowCaster(): bool {
			return this._bCastShadows;
		}

		/**@inline*/  setShadowCasting(bValue: bool = true): void {
			this._bCastShadows = bValue;
		}

		_calculateShadows(): void {
			logger.setSourceLocation( "light/LightPoint.ts" , 57 ); logger.criticalError("NOT IMPLEMENTED!"); ;
		}
	}
	export function isLightPoint(pNode: ISceneNode){
		var eType: EEntityTypes = pNode.type;
		return EEntityTypes.LIGHT_PROJECT <= eType && eType <= EEntityTypes.LIGHT_OMNI_DIRECTIONAL;
	}
}



module akra.scene {
	export class LightGraph extends DisplayList implements ILightGraph{

		constructor () {
			super();
			this.name = "LightGraph";
		}

		/**@protected*/  attachObject(pNode: ISceneNode): void {
			if(light.isLightPoint(pNode)){
				console.error("light here", pNode);
			}
		}

		/**@protected*/  detachObject(pNode: ISceneNode): void {

		}
	}
}























module akra {

	export interface IEngine {} ;
	export interface IResourceWatcherFunc {} ;
	export interface IResourceNotifyRoutineFunc {} ;
	export interface IResourceCode {} ;
	export interface IResourcePool {} ;
	export interface IResourcePoolManager {} ;

/**
     * Отражает состояние ресурса
     **/

    export enum EResourceItemEvents{
//ресур создан
		CREATED,
//ресур заполнен данным и готов к использованию
		LOADED,
//ресур в данный момент отключен для использования
		DISABLED,
//ресур был изменен после загрузки		
		ALTERED,
		TOTALRESOURCEFLAGS
	};

	export interface IResourcePoolItem extends IReferenceCounter, IEventProvider {
/** resource code */

		 resourceCode: IResourceCode;
/** resource pool */

		 resourcePool: IResourcePool;
/** resource handle */

		 resourceHandle:  number ;
/** resource flags */

		 resourceFlags:  number ;
/** Проверка был ли изменен ресур после загрузки */

		 alteredFlag: bool;

		 manager: IResourcePoolManager;



/** Get current Engine. */

		getEngine(): IEngine;
		getManager(): IResourcePoolManager;

/** Инициализация ресурса, вызывается один раз. Виртуальная. */

		createResource(): bool;
/** Уничтожение ресурса. Виртуальная. */

		destroyResource(): bool;
/**  Удаление ресурса из энергозависимой памяти. Виртуальная. */

		disableResource(): bool;
/** Возвращение ресурса в энегрозависимю память. Виртуальная. */

		restoreResource(): bool;

/** Загрузка ресурса из файла, или null при использовании имени ресурса. Виртуальная. */

		loadResource(sFilename?: string): bool;
/** Сохранение ресурса в файл, или null при использовании имени ресурса. */

		saveResource(sFilename?: string): bool;

/** Добавление и удаление функции, которая будет вызываться при изменении состояния ресурса( fnFunc(iNewSost,iOldSost) ) */

		setChangesNotifyRoutine(fn: IResourceNotifyRoutineFunc): void;
		delChangesNotifyRoutine(fn: IResourceNotifyRoutineFunc): void;

		setStateWatcher(eEvent: EResourceItemEvents, fnWatcher: IResourceWatcherFunc): void;

/** sinchronize events with other resourse */

//sync(pResourceItem: IResourcePoolItem, sSignal: string, sSlot?: string): bool;
		sync(pResourceItem: IResourcePoolItem, eSignal: EResourceItemEvents, eSlot?: EResourceItemEvents): bool;

//unsync(pResourceItem: IResourcePoolItem, sSignal: string, sSlot?: string): bool;
		unsync(pResourceItem: IResourcePoolItem, eSignal: EResourceItemEvents, eSlot?: EResourceItemEvents): bool;

/** Установка состояния в созданный */

		notifyCreated(): void;
/** Установка в состояние не созданный */

		notifyDestroyed(): void;
/** Уставнока в состояние загруженный */

		notifyLoaded(): void;
/** Уставнока в состояние незагруженный */

		notifyUnloaded(): void;
/** Установка в состояние используемый */

		notifyRestored(): void;
/** Установка в состояние не используемый */

		notifyDisabled(): void;
/** Установка в состояние не используемый */

		notifyAltered(): void;
/** Установка в состояние сохраненый */

		notifySaved(): void;

		notifyStateChange(eEvent: EResourceItemEvents, pTarget?: IResourcePoolItem);

/** Проверка создан ли ресурс */

		isResourceCreated(): bool;
/** Проверка загружен ли ресурс */

		isResourceLoaded(): bool;
/** Проверка активен ли ресурс */

		isResourceDisabled(): bool;
/** Проверка обновлен ли ресурс */

		isResourceAltered(): bool;

/** Установка состояния в изменен после загружки */

		setAlteredFlag(isOn?: bool): bool;

/** Пиписывание ресурсу имени */

		setResourceName(sName: string);

/** Поиск имени ресурса */

		findResourceName(): string;

/** оповещение о уменьшении количесва ссылок на ресурс */

		release():  number ;

		setResourceCode(pCode: IResourceCode): void;
		setResourcePool(pPool: IResourcePool): void;
		setResourceHandle(iHandle:  number ): void;

		setResourceFlag(eFlagBit: EResourceItemEvents, isSetting: bool): bool;
		setResourceFlag(iFlagBit:  number , isSetting: bool): bool;

		 created(): void;
		 destroyed(): void;
		 loaded(): void;
		 unloaded(): void;
		 restored(): void;
		 disabled(): void;
		 altered(): void;
		 saved(): void;

	}

	export interface IResourcePoolItemType {
		new (pManager: IResourcePoolManager): IResourcePoolItem;
	}
}



module akra {
	export interface IHardwareObject {} ;

    export interface IRenderResource extends IResourcePoolItem {
//getHardwareObject(): IHardwareObject;
    };
}






module akra {
	export enum EPixelFormats {
/*Unknown pixel format.*/
        UNKNOWN = 0,

/*8-bit pixel format, all bits luminance.*/
        L8 = 1,
        BYTE_L = L8,
/*16-bit pixel format, all bits luminance.*/
        L16 = 2,
        SHORT_L = L16,
/*8-bit pixel format, all bits alpha.*/
        A8 = 3,
        BYTE_A = A8,
/*8-bit pixel format, 4 bits alpha, 4 bits luminance.*/
        A4L4 = 4,
/*2 byte pixel format, 1 byte luminance, 1 byte alpha*/
        BYTE_LA = 5,

/*16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.*/
        R5G6B5 = 6,
/*16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.*/
        B5G6R5 = 7,
/*8-bit pixel format, 2 bits blue, 3 bits green, 3 bits red.*/
        R3G3B2 = 31,
/*16-bit pixel format, 4 bits for alpha, red, green and blue.*/
        A4R4G4B4 = 8,
/*16-bit pixel format, 5 bits for blue, green, red and 1 for alpha.*/
        A1R5G5B5 = 9,
/*24-bit pixel format, 8 bits for red, green and blue.*/
        R8G8B8 = 10,
/*24-bit pixel format, 8 bits for blue, green and red.*/
        B8G8R8 = 11,
/*32-bit pixel format, 8 bits for alpha, red, green and blue.*/
        A8R8G8B8 = 12,
/*32-bit pixel format, 8 bits for blue, green, red and alpha.*/
        A8B8G8R8 = 13,
/*32-bit pixel format, 8 bits for blue, green, red and alpha.*/
        B8G8R8A8 = 14,
/*32-bit pixel format, 8 bits for red, green, blue and alpha.*/
        R8G8B8A8 = 28,

/*32-bit pixel format, 8 bits for red, 8 bits for green, 8 bits for blue like A8R8G8B8, but alpha will get discarded*/
        X8R8G8B8 = 26,
/*32-bit pixel format, 8 bits for blue, 8 bits for green, 8 bits for red like A8B8G8R8, but alpha will get discarded*/
        X8B8G8R8 = 27,

/*3 byte pixel format, 1 byte for red, 1 byte for green, 1 byte for blue*/
        BYTE_RGB = R8G8B8,
/*3 byte pixel format, 1 byte for blue, 1 byte for green, 1 byte for red*/
        BYTE_BGR = B8G8R8,
/*4 byte pixel format, 1 byte for blue, 1 byte for green, 1 byte for red and one byte for alpha*/
        BYTE_BGRA = B8G8R8A8,
/*4 byte pixel format, 1 byte for red, 1 byte for green, 1 byte for blue, and one byte for alpha*/
        BYTE_RGBA = R8G8B8A8,

/*32-bit pixel format, 2 bits for alpha, 10 bits for red, green and blue.*/
        A2R10G10B10 = 15,
/*32-bit pixel format, 10 bits for blue, green and red, 2 bits for alpha.*/
        A2B10G10R10 = 16,

/*DDS (DirectDraw Surface) DXT1 format.*/
        DXT1 = 17,
/*DDS (DirectDraw Surface) DXT2 format.*/
        DXT2 = 18,
/*DDS (DirectDraw Surface) DXT3 format.*/
        DXT3 = 19,
/*DDS (DirectDraw Surface) DXT4 format.*/
        DXT4 = 20,
/*DDS (DirectDraw Surface) DXT5 format.*/
        DXT5 = 21,

/*16-bit pixel format, 16 bits (float) for red*/
        FLOAT16_R = 32,
/*48-bit pixel format, 16 bits (float) for red, 16 bits (float) for green, 16 bits (float) for blue*/
        FLOAT16_RGB = 22,
/*64-bit pixel format, 16 bits (float) for red, 16 bits (float) for green, 16 bits (float) for blue, 16 bits (float) for alpha*/
        FLOAT16_RGBA = 23,
/*32-bit pixel format, 32 bits (float) for red*/
        FLOAT32_R = 33,
/*96-bit pixel format, 32 bits (float) for red, 32 bits (float) for green, 32 bits (float) for blue*/
        FLOAT32_RGB = 24,
/*128-bit pixel format, 32 bits (float) for red, 32 bits (float) for green, 32 bits (float) for blue, 32 bits (float) for alpha*/
        FLOAT32_RGBA = 25,
/*32-bit, 2-channel s10e5 floating point pixel format, 16-bit green, 16-bit red*/
        FLOAT16_GR = 35,
/*64-bit, 2-channel floating point pixel format, 32-bit green, 32-bit red*/
        FLOAT32_GR = 36,

/*Float Depth texture format*/
        DEPTH = 29,
/*Byte Depth texture format */
        DEPTH_BYTE = 44,

/*64-bit pixel format, 16 bits for red, green, blue and alpha*/
        SHORT_RGBA = 30,
/*32-bit pixel format, 16-bit green, 16-bit red*/
        SHORT_GR = 34,
/*48-bit pixel format, 16 bits for red, green and blue*/
        SHORT_RGB = 37,

/*PVRTC (PowerVR) RGB 2 bpp.*/
        PVRTC_RGB2 = 38,
/*PVRTC (PowerVR) RGBA 2 bpp.*/
        PVRTC_RGBA2 = 39,
/*PVRTC (PowerVR) RGB 4 bpp.*/
        PVRTC_RGB4 = 40,
/*PVRTC (PowerVR) RGBA 4 bpp.*/
        PVRTC_RGBA4 = 41,

/*8-bit pixel format, all bits red.*/
        R8 = 42,
/*16-bit pixel format, 8 bits red, 8 bits green.*/
        RG8 = 43,
        TOTAL = 45
    };

    export interface PixelFormatList {
    	[index:  number ]: EPixelFormats;
    }


/**
     * Flags defining some on/off properties of pixel formats
     */

    export enum  EPixelFormatFlags {
// This format has an alpha channel
        HASALPHA        = 0x00000001,
// This format is compressed. This invalidates the values in elemBytes,
// elemBits and the bit counts as these might not be fixed in a compressed format.
        COMPRESSED    = 0x00000002,
// This is a floating point format
        FLOAT           = 0x00000004,
// This is a depth format (for depth textures)
        DEPTH           = 0x00000008,
// Format is in native endian. Generally true for the 16, 24 and 32 bits
// formats which can be represented as machine integers.
        NATIVEENDIAN    = 0x00000010,
// This is an intensity format instead of a RGB one. The luminance
// replaces R,G and B. (but not A)
        LUMINANCE       = 0x00000020
    }

/** Pixel component format */

    export enum EPixelComponentTypes
    {
/*Byte per component (8 bit fixed 0.0..1.0)*/
        BYTE = 0,
/*Short per component (16 bit fixed 0.0..1.0))*/
        SHORT = 1,
/*16 bit float per component*/
        FLOAT16 = 2,
/*32 bit float per component*/
        FLOAT32 = 3,
/*Number of pixel types*/
        COUNT = 4
    };

    export enum EFilters {
        NEAREST,
        LINEAR,
        BILINEAR,
        BOX,
        TRIANGLE,
        BICUBIC
    };
}










module akra {
	export interface IBuffer {
//number of elements
		 length:  number ;

//size in bytes
		 byteLength:  number ;


	}
}



module akra {

	export enum EHardwareBufferFlags {
		STATIC 		= 0x01,
		DYNAMIC 	= 0x02,
		STREAM 		= 0x80,

		READABLE	= 0x04,

		BACKUP_COPY = 0x08,
/** indicate, that buffer does not use GPU memory or other specific memory. */

		SOFTWARE 	= 0x10,
/** Indicate, tha buffer uses specific data aligment */

		ALIGNMENT	= 0x20,
/** Indicates that the application will be refilling the contents
            of the buffer regularly (not just updating, but generating the
            contents from scratch), and therefore does not mind if the contents 
            of the buffer are lost somehow and need to be recreated. This
            allows and additional level of optimisation on the buffer.
            This option only really makes sense when combined with 
            DYNAMIC and without READING.
            */

		DISCARDABLE = 0x40,

		STATIC_READABLE = STATIC | READABLE,
		DYNAMIC_DISCARDABLE = DYNAMIC | DISCARDABLE
	}

	export enum ELockFlags {
		READ 			= 0x01,
		WRITE 			= 0x02,
		DISCARD 		= 0x04,
		NO_OVERWRITE	= 0x08,

		NORMAL			= READ | WRITE
	}

	export interface IHardwareBuffer extends IBuffer {
		clone(pSrc: IHardwareBuffer): bool;

		isValid(): bool;
		isDynamic(): bool;
		isStatic(): bool;
		isStream(): bool;
		isReadable(): bool;
		isBackupPresent(): bool;
		isSoftware(): bool;
		isAligned(): bool;
		isLocked(): bool;

		getFlags():  number ;

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;

		writeData(pData: Uint8Array, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer?: bool): bool;
		writeData(pData: ArrayBuffer, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer?: bool): bool;


		copyData(pSrcBuffer: IHardwareBuffer, iSrcOffset:  number ,
				 iDstOffset:  number , iSize:  number , bDiscardWholeBuffer?: bool): bool;

		create(iFlags:  number ): bool;
// create(iByteSize: uint, iFlags: int, pData: Uint8Array): bool;
// create(iByteSize: uint, iFlags: int, pData: ArrayBuffer): bool;

		destroy(): void;

		resize(iSize:  number ): bool;

		lock(iLockFlags:  number ): any;
		lock(iOffset:  number , iSize:  number , iLockFlags?:  number ): any;
		unlock(): void;

		restoreFromBackup(): bool;
	}
}









module akra {
	export interface IPixelBuffer extends IHardwareBuffer {
		 width:  number ;
		 height:  number ;
		 depth:  number ;

		 format: EPixelFormats;

		create(iFlags:  number ): bool;
		create(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats, iFlags:  number ): bool;

		blit(pSource: IPixelBuffer, pSrcBox: IBox, pDestBox: IBox): bool;
		blit(pSource: IPixelBuffer);

		blitFromMemory(pSource: IPixelBox): bool;
		blitFromMemory(pSource: IPixelBox, pDestBox?: IBox): bool;

		blitToMemory(pDest: IPixelBox): bool;
		blitToMemory(pSrcBox: IBox, pDest: IPixelBox): bool;

		getRenderTarget(): IRenderTarget;

		lock(iLockFlags:  number ): any;
		lock(iOffset:  number , iSize:  number , iLockFlags?:  number ): any;
		lock(pLockBox: IBox, iLockFlags?:  number ): IPixelBox;

		_clearRTT(iZOffset:  number ): void;
	}
}










module akra {

    export interface IImg {} ;

    export enum ETextureFlags {
        STATIC = < number >EHardwareBufferFlags.STATIC,
        DYNAMIC = < number >EHardwareBufferFlags.DYNAMIC,
        READEBLE = < number >EHardwareBufferFlags.READABLE,
        DYNAMIC_DISCARDABLE = < number >EHardwareBufferFlags.DYNAMIC_DISCARDABLE,
/// mipmaps will be automatically generated for this texture
        AUTOMIPMAP = 0x100,
/// this texture will be a render target, i.e. used as a target for render to texture
/// setting this flag will ignore all other texture usages except AUTOMIPMAP
        RENDERTARGET = 0x200,
/// default to automatic mipmap generation static textures
        DEFAULT = AUTOMIPMAP | STATIC
    }

    export enum ETextureFilters {
        NEAREST = 0x2600,
        LINEAR = 0x2601,
        NEAREST_MIPMAP_NEAREST = 0x2700,
        LINEAR_MIPMAP_NEAREST = 0x2701,
        NEAREST_MIPMAP_LINEAR = 0x2702,
        LINEAR_MIPMAP_LINEAR = 0x2703
    };

    export enum ETextureWrapModes {
        REPEAT = 0x2901,
        CLAMP_TO_EDGE = 0x812F,
        MIRRORED_REPEAT = 0x8370
    };

    export enum ETextureParameters {
        MAG_FILTER = 0x2800,
        MIN_FILTER,
        WRAP_S,
        WRAP_T
    };

    export enum ETextureTypes {
        TEXTURE_2D = 0x0DE1,
        TEXTURE = 0x1702,
        TEXTURE_CUBE_MAP = 0x8513,
        TEXTURE_BINDING_CUBE_MAP = 0x8514,
        TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515,
        TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516,
        TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517,
        TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518,
        TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519,
        TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A,
        MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C
    };

    export enum ETextureUnits {
        TEXTURE = 0x84C0
    };

// export interface ITextureParameters {
//     minFilter: ETextureFilters;
//     magFilter: ETextureFilters;

//     wrapS: ETextureWrapModes;
//     wrapT: ETextureWrapModes;
// }

    export interface ITexture extends IRenderResource {
    	width:  number ;
        height:  number ;
        depth:  number ;

        format: EPixelFormats;
        mipLevels:  number ;

        textureType: ETextureTypes;

        desiredIntegerBitDepth:  number ;
        desiredFloatBitDepth:  number ;

         desiredFormat: EPixelFormats;
         srcFormat: EPixelFormats;
         srcWidth:  number ;
         srcHeight:  number ;
         srcDepth:  number ;

        setFlags(iTextureFlag:  number ): void;
        getFlags():  number ;

        calculateSize():  number ;
        getNumFaces():  number ;
        getSize():  number ;

        isTexture2D(): bool;
        isTextureCube(): bool;
        isCompressed(): bool;
        isValid(): bool;

        create(iWidth:  number , iHeight:  number , iDepth:  number , pFillColor?: IColor,
               iFlags?:  number , nMipLevels?:  number , eTextureType?: ETextureTypes, eFormat?: EPixelFormats): bool;
        create(iWidth:  number , iHeight:  number , iDepth:  number , pPixels?: Array,
               iFlags?:  number , nMipLevels?:  number , eTextureType?: ETextureTypes, eFormat?: EPixelFormats): bool;
        create(iWidth:  number , iHeight:  number , iDepth:  number , pPixels?: ArrayBufferView,
               iFlags?:  number , nMipLevels?:  number , eTextureType?: ETextureTypes, eFormat?: EPixelFormats): bool;


        getBuffer(iFace?:  number , iMipmap?:  number ): IPixelBuffer;

        setParameter(eParam: ETextureParameters, eValue: ETextureFilters): bool;
        setParameter(eParam: ETextureParameters, eValue: ETextureWrapModes): bool;

        loadRawData(pData: ArrayBufferView, iWidth:  number , iHeight:  number , eFormat: EPixelFormats): bool;
        loadImage(pImage: IImg): bool;
        loadImages(pImages: IImg[]): bool;

        convertToImage(pDestImage: IImg, bIncludeMipMaps: bool): void;

        copyToTexture(pTarget: ITexture): void;

        createInternalTexture(cFillColor?: IColor): bool;
        freeInternalTexture(): bool;

        getNativeFormat(eTextureType?: ETextureTypes, eFormat?: EPixelFormats, iFlags?:  number ): EPixelFormats;
    }
}










module akra {
    export interface IManager {
        initialize(): bool;
        destroy(): void;
    }
}



module akra {

    export interface IEngine {} ;
    export interface IResourceCode {} ;
    export interface IResourcePool {} ;
    export interface IResourceWatcherFunc {} ;
    export interface IResourcePoolItem {} ;

/** Семейства ресурсов */

	export enum EResourceFamilies {
		VIDEO_RESOURCE = 0,
		AUDIO_RESOURCE,
		GAME_RESOURCE,
		TOTAL_RESOURCE_FAMILIES
	};

/** Члены семейства видео ресурсов */

	export enum EVideoResources {
		TEXTURE_RESOURCE,
		VIDEOBUFFER_RESOURCE,
		VERTEXBUFFER_RESOURCE,
		INDEXBUFFER_RESOURCE,
		EFFECT_RESOURCE,
		RENDERMETHOD_RESOURCE,
		MODEL_RESOURCE,
		EFFECTFILEDATA_RESOURCE,
		IMAGE_RESOURCE,
		SURFACEMATERIAL_RESOURCE,
		SHADERPROGRAM_RESOURCE,
		COMPONENT_RESOURCE,
		TOTAL_VIDEO_RESOURCES
	};

	export enum EAudioResources {
		TOTAL_AUDIO_RESOURCES
	};

	export enum EGameResources {
		TOTAL_GAME_RESOURCES
	};

/** Конструктор класса, занимается очисткой списков пулов по семействам ресурсвов и краты пулов по коду ресурсов */

    export interface IResourcePoolManager extends IManager {
    	texturePool: IResourcePool;
    	surfaceMaterialPool: IResourcePool;
    	vertexBufferPool: IResourcePool;
    	videoBufferPool: IResourcePool;
    	indexBufferPool: IResourcePool;
        textureBufferPool: IResourcePool;
    	renderMethodPool: IResourcePool;
// colladaPool: IResourcePool;
    	imagePool: IResourcePool;
//ex: private
    	shaderProgramPool: IResourcePool;
//ex: private
    	effectPool: IResourcePool;
//ex: private
    	componentPool: IResourcePool;

/** Регистрируется пул ресурсов опредленного типа в менеджере русурсов */

    	registerResourcePool(pCode: IResourceCode, pPool: IResourcePool): void;
/** Удаляет пул ресурсов опредленного типа в менеджере русурсов */

    	unregisterResourcePool(pCode: IResourceCode): IResourcePool;

/** Удаление ресурсов определенного семества */

    	destroyResourceFamily(eFamily: EResourceFamilies): void;
    	restoreResourceFamily(eFamily: EResourceFamilies): void;
    	disableResourceFamily(eFamily: EResourceFamilies): void;
    	cleanResourceFamily(eFamily: EResourceFamilies): void;

    	destroyResourceType(pCode: IResourceCode): void;
    	restoreResourceType(pCode: IResourceCode): void;
    	disableResourceType(pCode: IResourceCode): void;
    	cleanResourceType(pCode: IResourceCode): void;
/** Возвращает пул ресурса опредленного типа по его коду */

    	findResourcePool(pCode: IResourceCode): IResourcePool;
/**
		 * Возвращает хендл конкретного ресурса по его имени из конкретного пула опредленного типа
		 **/

    	findResourceHandle(pCode: IResourceCode, sName: string):  number ;
/** Возвращает конкретный ресурс по его имени из конкретного пула опредленного типа */

    	findResource(pCode: IResourceCode, sName: string): IResourcePoolItem;
        findResource(pCode: IResourceCode, iHandle:  number ): IResourcePoolItem;

    	monitorInitResources(fnMonitor: IResourceWatcherFunc): void;
    	setLoadedAllRoutine(fnCallback: Function): void;

/** Удаление всех ресурсов */

    	destroyAll(): void;
    	restoreAll(): void;
    	disableAll(): void;

    	clean(): void;

    	createDeviceResources(): bool;
    	destroyDeviceResources(): bool;
    	restoreDeviceResources(): bool;
    	disableDeviceResources(): bool;

        getEngine(): IEngine;

        createRenderMethod(sResourceName: string): IRenderMethod;
        createTexture(sResourceName: string): ITexture;
        createSurfaceMaterial(sResourceName: string): ISurfaceMaterial;
        createEffect(sResourceName: string): IEffect;
        createVertexBuffer(sResourceName: string): IVertexBuffer;
        createVideoBuffer(sResourceName: string): IVertexBuffer;
        createModel(sResourceName: string): IModel;
    }
}










module akra {
	export interface IShadowCaster extends ICamera {
		 lightPoint: ILightPoint;
		 face:  number ;
	}

	export interface IShadowCasterCube {
		[i:  number ]: IShadowCaster;
	}
}
















module akra {

    export interface IRect2d {} ;
    export interface IColor {} ;
    export interface IRenderTarget {} ;
    export interface ICamera {} ;

    export enum EViewportTypes {
        DEFAULT = -1,
        DSVIEWPORT = 1
    }

    export interface IViewport extends IEventProvider {
        left:  number ;
        top:  number ;
        width:  number ;
        height:  number ;

//in pixels
        actualLeft:  number ;
        actualTop:  number ;
        actualWidth:  number ;
        actualHeight:  number ;

        zIndex:  number ;

        backgroundColor: IColor;
        depthClear:  number ;

        update(): void;
        destroy(): void;

        clear(iBuffers?:  number , cColor?: IColor, iDepth?:  number ): void;

        getTarget(): IRenderTarget;
        getCamera(): ICamera;
        setCamera(pCamera: ICamera): bool;

        setDimensions(fLeft:  number , fTop:  number , fWidth:  number , fHeight:  number ): bool;
        setDimensions(pRect: IRect2d): bool;

        getActualDimensions(): IRect2d;

//iBuffers=FBT_COLOUR|FBT_DEPTH
        setClearEveryFrame(isClear: bool, iBuffers?:  number ): void;
        getClearEveryFrame(): bool;
        getClearBuffers():  number ;

        setAutoUpdated(bValue?: bool): void;
        isAutoUpdated(): bool;

        isUpdated(): bool;
        _clearUpdatedFlag(): void;

        _getNumRenderedPolygons():  number ;
        _updateDimensions(pDimensions: IRect2d): void;

         viewportDimensionsChanged(): void;
         viewportCameraChanged(): void;
    }
}























module akra.geometry{
	export class Frustum implements IFrustum {
		leftPlane: IPlane3d;
		rightPlane: IPlane3d;
		topPlane: IPlane3d;
		bottomPlane: IPlane3d;
		nearPlane: IPlane3d;
		farPlane: IPlane3d;

		constructor ();
		constructor (pFrustum: IFrustum);
		constructor (pLeftPlane: IPlane3d, pRightPlane: IPlane3d,
					pTopPlane: IPlane3d, pBottomPlane: IPlane3d,
					pNearPlane: IPlane3d, pFarPlane: IPlane3d);
		constructor (pLeftPlane?,pRightPlane?,pTopPlane?,
					pBottomPlane?, pNearPlane?, pFarPlane?) {

			this.leftPlane = new Plane3d();
			this.rightPlane = new Plane3d();
			this.topPlane = new Plane3d();
			this.bottomPlane = new Plane3d();
			this.nearPlane = new Plane3d();
			this.farPlane = new Plane3d();

			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					this.set(arguments[0]);
					break;
				case 6:
					this.set(arguments[0], arguments[1], arguments[2],
							 arguments[3], arguments[4], arguments[5]);
					break;
				default:
					break;
			}
		};



		set(): IFrustum;
		set(pFrustum: IFrustum): IFrustum;
		set(pLeftPlane: IPlane3d, pRightPlane: IPlane3d,
			pTopPlane: IPlane3d, pBottomPlane: IPlane3d,
			pNearPlane: IPlane3d, pFarPlane: IPlane3d): IFrustum;
		set(pLeftPlane?, pRightPlane?, pTopPlane?,
			pBottomPlane?, pNearPlane?, pFarPlane?): IFrustum {

			var nArgumentsLength = arguments.length;

			switch(nArgumentsLength) {
				case 1:
					var pFrustum: IFrustum = arguments[0];

					this.leftPlane.set(pFrustum.leftPlane);
					this.rightPlane.set(pFrustum.rightPlane);
					this.topPlane.set(pFrustum.topPlane);
					this.bottomPlane.set(pFrustum.bottomPlane);
					this.nearPlane.set(pFrustum.nearPlane);
					this.farPlane.set(pFrustum.farPlane);
					break;
				case 6:
					this.leftPlane.set(arguments[0]);
					this.rightPlane.set(arguments[1]);
					this.topPlane.set(arguments[2]);
					this.bottomPlane.set(arguments[3]);
					this.nearPlane.set(arguments[4]);
					this.farPlane.set(arguments[5]);
					break;
				default:
					this.leftPlane.clear();
					this.rightPlane.clear();
					this.topPlane.clear();
					this.bottomPlane.clear();
					this.nearPlane.clear();
					this.farPlane.clear();
					break;
			}

			return this;
		};

		extractFromMatrix(m4fProjection: IMat4, m4fWorld?: IMat4, pSearchRect?: IRect3d): IFrustum{

			var v4fLeftBottomNear: IVec4 = vec4();
			var v4fRightBottomNear: IVec4 = vec4();
			var v4fLeftTopNear: IVec4 = vec4();
			var v4fRightTopNear: IVec4 = vec4();

			var v4fLeftBottomFar: IVec4 = vec4();
			var v4fRightBottomFar: IVec4 = vec4();
			var v4fLeftTopFar: IVec4 = vec4();
			var v4fRightTopFar: IVec4 = vec4();

			m4fProjection.unproj(vec3(-1,-1,-1), v4fLeftBottomNear);
		    m4fProjection.unproj(vec3(1,-1,-1), v4fRightBottomNear);
		    m4fProjection.unproj(vec3(-1,1,-1), v4fLeftTopNear);
		    m4fProjection.unproj(vec3(1,1,-1), v4fRightTopNear);

		    m4fProjection.unproj(vec3(-1,-1,1), v4fLeftBottomFar);
		    m4fProjection.unproj(vec3(1,-1,1), v4fRightBottomFar);
		    m4fProjection.unproj(vec3(-1,1,1), v4fLeftTopFar);
		    m4fProjection.unproj(vec3(1,1,1), v4fRightTopFar);

		    if(isDef(m4fWorld)){
		    	m4fWorld.multiplyVec4(v4fLeftBottomNear, v4fLeftBottomNear);
		    	m4fWorld.multiplyVec4(v4fRightBottomNear, v4fRightBottomNear);
		    	m4fWorld.multiplyVec4(v4fLeftTopNear, v4fLeftTopNear);
		    	m4fWorld.multiplyVec4(v4fRightTopNear, v4fRightTopNear);

		    	m4fWorld.multiplyVec4(v4fLeftBottomFar, v4fLeftBottomFar);
		    	m4fWorld.multiplyVec4(v4fRightBottomFar, v4fRightBottomFar);
		    	m4fWorld.multiplyVec4(v4fLeftTopFar, v4fLeftTopFar);
		    	m4fWorld.multiplyVec4(v4fRightTopFar, v4fRightTopFar);
		    }

		    var v3fLeftBottomNear: IVec3 = v4fLeftBottomNear.xyz;
		    var v3fRightBottomNear: IVec3 = v4fRightBottomNear.xyz;
		    var v3fLeftTopNear: IVec3 = v4fLeftTopNear.xyz;
		    var v3fRightTopNear: IVec3 = v4fRightTopNear.xyz;

		    var v3fLeftBottomFar: IVec3 = v4fLeftBottomFar.xyz;
		    var v3fRightBottomFar: IVec3 = v4fRightBottomFar.xyz;
		    var v3fLeftTopFar: IVec3 = v4fLeftTopFar.xyz;
		    var v3fRightTopFar: IVec3 = v4fRightTopFar.xyz;

//filling search rectangle

		    if(isDef(pSearchRect)){
		    	pSearchRect.set(v3fLeftBottomNear, v3fLeftBottomNear);

		    	pSearchRect.unionPoint(v3fRightBottomNear);
		    	pSearchRect.unionPoint(v3fLeftTopNear);
		    	pSearchRect.unionPoint(v3fRightTopNear);

		    	pSearchRect.unionPoint(v3fLeftBottomFar);
		    	pSearchRect.unionPoint(v3fRightBottomFar);
		    	pSearchRect.unionPoint(v3fLeftTopFar);
		    	pSearchRect.unionPoint(v3fRightTopFar);
		    }

//calculating planes

		    this.leftPlane.set(v3fLeftTopNear, v3fLeftTopFar, v3fLeftBottomNear);
			this.rightPlane.set(v3fRightBottomFar, v3fRightTopFar, v3fRightBottomNear);
			this.topPlane.set(v3fLeftTopNear, v3fRightTopNear, v3fLeftTopFar);
			this.bottomPlane.set(v3fRightBottomFar, v3fRightBottomNear, v3fLeftBottomFar);
			this.nearPlane.set(v3fLeftTopNear, v3fLeftBottomNear, v3fRightTopNear);
			this.farPlane.set(v3fRightBottomFar, v3fLeftBottomFar, v3fRightTopFar);

			return this;
		};

		/**@inline*/  isEqual(pFrustum: IFrustum): bool{
			return (this.leftPlane.isEqual(pFrustum.leftPlane)
				&& this.rightPlane.isEqual(pFrustum.rightPlane)
				&& this.topPlane.isEqual(pFrustum.topPlane)
				&& this.bottomPlane.isEqual(pFrustum.bottomPlane)
				&& this.nearPlane.isEqual(pFrustum.nearPlane)
				&& this.farPlane.isEqual(pFrustum.farPlane));
		};

		testPoint(v3fPoint: IVec3): bool{
			if(	   this.leftPlane.signedDistance(v3fPoint) > 0.
				|| this.rightPlane.signedDistance(v3fPoint) > 0.
				|| this.topPlane.signedDistance(v3fPoint) > 0.
				|| this.bottomPlane.signedDistance(v3fPoint) > 0.
				|| this.nearPlane.signedDistance(v3fPoint) > 0.
				|| this.farPlane.signedDistance(v3fPoint) > 0.){

				return false;
			}
			return true;
		};

		testRect(pRect: IRect3d): bool{
			if(planeClassifyRect3d(this.leftPlane, pRect) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifyRect3d(this.rightPlane, pRect) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifyRect3d(this.topPlane, pRect) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifyRect3d(this.bottomPlane, pRect) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifyRect3d(this.nearPlane, pRect) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifyRect3d(this.farPlane, pRect) == EPlaneClassifications.PLANE_FRONT){

				return false;
			}
			return true;
		};

		testSphere(pSphere: ISphere): bool{
			if(	   planeClassifySphere(this.leftPlane, pSphere) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifySphere(this.rightPlane, pSphere) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifySphere(this.topPlane, pSphere) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifySphere(this.bottomPlane, pSphere) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifySphere(this.nearPlane, pSphere) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifySphere(this.farPlane, pSphere) == EPlaneClassifications.PLANE_FRONT){

				return false;
			}
			return true;
		};
	};
}





module akra.scene.objects {
	export enum ECameraFlags {
		k_NewProjectionMatrix = 0
	}

	export interface ICameraCache {
		[displayList: string]: ISceneObject[];
	};

	export class DLTechnique {
		list: IDisplayList;
		camera: ICamera;

		private _pPrevResult: IObjectArray = null;

		constructor (pList: IDisplayList, pCamera: ICamera) {
			this.list = pList;
			this.camera = pCamera;
		}

		/**@inline*/  findObjects(bQuickSearch: bool = false): IObjectArray {
			var pResult: IObjectArray = this.list._findObjects(this.camera,
					bQuickSearch && isDefAndNotNull(this._pPrevResult));

			if (isNull(this._pPrevResult)) {
				this._pPrevResult = pResult;
			}

			return this._pPrevResult;
		}
	}

	export class Camera extends SceneNode implements ICamera {
/** camera type */

		/**@protected*/  _eCameraType: ECameraTypes = ECameraTypes.PERSPECTIVE;
/** camera options */

		/**@protected*/  _iCameraOptions:  number  = 0;
/** update projection bit flag */

		/**@protected*/  _iUpdateProjectionFlags:  number  = 0;

/** View matrix */

		/**@protected*/  _m4fView: IMat4 = new Mat4;
/** internal, un-biased projection matrix */

		/**@protected*/  _m4fProj: IMat4 = new Mat4;
		/**@protected*/  _m4fUnitProj: IMat4 = new Mat4;
/** internal, un-biased projection+view matrix */

		/**@protected*/  _m4fProjView: IMat4 = new Mat4;

/** Biased for use during current render stage */

		/**@protected*/  _m4fRenderStageProj: IMat4 = new Mat4;
		/**@protected*/  _m4fRenderStageProjView: IMat4 = new Mat4;

/** Search rect for scene culling */

		/**@protected*/  _pSearchRect: IRect3d = new geometry.Rect3d();
/** Position */

		/**@protected*/  _v3fTargetPos: IVec3 = new Vec3;

/** Attributes for projection matrix */

		/**@protected*/  _fFOV:  number  = math.PI / 5.;
		/**@protected*/  _fAspect:  number  = 4. / 3.;
		/**@protected*/  _fNearPlane:  number  = 0.1;
		/**@protected*/  _fFarPlane:  number  = 500.;
		/**@protected*/  _fWidth:  number  = 0.;
		/**@protected*/  _fHeight:  number  = 0.;
		/**@protected*/  _fMinX:  number  = 0.;
		/**@protected*/  _fMaxX:  number  = 0.;
		/**@protected*/  _fMinY:  number  = 0.;
		/**@protected*/  _fMaxY:  number  = 0.;

		/**@protected*/  _pFrustum: IFrustum = new geometry.Frustum;

		/**@protected*/  _pLastViewport: IViewport = null;

		/**@protected*/  _pDLTechniques: DLTechnique[] = [];


// protected _pPrevObjects: ISceneNode[] = null;
// protected _p

		/**@inline*/  get viewMatrix(): IMat4 { return this._m4fView; }

    	/**@inline*/  get projectionMatrix(): IMat4 { return this._m4fRenderStageProj; }

    	/**@inline*/  get projViewMatrix(): IMat4 { return this._m4fRenderStageProjView; }

    	/**@inline*/  get internalProjectionMatrix(): IMat4 { return this._m4fProj; }

    	/**@inline*/  get internalViewProjMatrix(): IMat4 { return this._m4fProjView; }

    	/**@inline*/  get targetPos(): IVec3 { return this._v3fTargetPos; }

    	/**@inline*/  get fov():  number  { return this._fFOV; }
    	/**@inline*/  set fov(fFOV:  number ) { this._fFOV = fFOV; };

    	/**@inline*/  get aspect():  number  { return this._fAspect; }
    	/**@inline*/  set aspect(fAspect:  number ) { this._fAspect = fAspect; }

    	/**@inline*/  get nearPlane():  number  { return this._fNearPlane; }
    	/**@inline*/  set nearPlane(fNearPlane:  number ) { this._fNearPlane = fNearPlane; }

    	/**@inline*/  get farPlane():  number  { return this._fFarPlane; }
    	/**@inline*/  set farPlane(fFarPlane:  number ) { this._fFarPlane = fFarPlane; }

    	/**@inline*/  get viewDistance():  number  { return this._fFarPlane - this._fNearPlane; }
    	/**@inline*/  get searchRect(): IRect3d { return this._pSearchRect; }
    	/**@inline*/  get frustum(): IFrustum { return this._pFrustum; }

		constructor (pScene: IScene3d) {
			super(pScene);

			this._eType = EEntityTypes.CAMERA;
		}

		create(): bool {
			var isOK: bool = super.create();

			if (isOK) {
				this._v3fTargetPos.set(
					this._m4fLocalMatrix.data[ 8 ],
					this._m4fLocalMatrix.data[ 9 ],
					this._m4fLocalMatrix.data[ 10 ]);
				this._v3fTargetPos.negate();

				this.setProjParams(this._fFOV, this._fAspect, this._fNearPlane, this._fFarPlane);
				this.recalcMatrices();

				var pScene: IScene3d = this._pScene;

				this.connect(pScene,  "displayListAdded" ,  "_addDisplayList" );
				this.connect(pScene,  "displayListRemoved" ,  "_removeDisplayList" );

				for (var i:  number  = 0; i < pScene.totalDL; ++ i) {
					var pList: IDisplayList = pScene.getDisplayList(i);

					if (!isNull(pList)) {
						this._addDisplayList(pScene, pList, i);
					}
				}
			}

			return isOK;
		}

		prepareForUpdate(): void {
			super.prepareForUpdate();

//reset culling cache for all display lists
// for (var i: int = 0; i < this._pDLTechniques.length; ++ i) {
// 	if (this._pDLTechniques[i] != null) {
// 		this._pDLTechniques.reset();
// 	}
// }
		}




/*DL_DEFAULT*/
		display(iList:  number  =               0): IObjectArray {
			var pObjects: IObjectArray = this._pDLTechniques[iList].findObjects(!this.isUpdated());

			return pObjects;
		}

		setParameter(eParam: ECameraParameters, pValue: any): void {
			if (eParam === ECameraParameters.CONST_ASPECT && <bool>pValue) {
				((this._iCameraOptions) |= (< number >eParam)) ;
			}
		}

		isConstantAspect(): bool {
			return  (((this._iCameraOptions) & (ECameraParameters.CONST_ASPECT)) != 0) ;
		}

    	setProjParams(fFOV:  number , fAspect:  number , fNearPlane:  number , fFarPlane:  number ): void {
// Set attributes for the projection matrix
		    this._fFOV = fFOV;
		    this._fAspect = fAspect;
		    this._fNearPlane = fNearPlane;
		    this._fFarPlane = fFarPlane;
		    this._eCameraType = ECameraTypes.PERSPECTIVE;

// create the regular projection matrix
		    Mat4.perspective(fFOV, fAspect, fNearPlane, fFarPlane, this._m4fProj);

// create a unit-space matrix 
// for sky box geometry.
// this ensures that the 
// near and far plane enclose 
// the unit space around the camera
		    Mat4.perspective(fFOV, fAspect, 0.01, 2.0, this._m4fUnitProj);

		    ((this._iUpdateProjectionFlags) |= (1 << ((ECameraFlags.k_NewProjectionMatrix))) ) ;
    	}

    	setOrthoParams(fWidth:  number , fHeight:  number , fNearPlane:  number , fFarPlane:  number ): void {
		    logger.setSourceLocation( "scene/objects/Camera.ts" , 207 ); logger.criticalError("TODO: setOrthoParams();"); ;
/*
		    
		    this._fWidth = fWidth;
		    this._fHeight = fHeight;
		    this._fNearPlane = fNearPlane;
		    this._fFarPlane = fFarPlane;
		    this._eCameraType = ECameraTypes.ORTHO;

		    // create the regular projection matrix
		    Mat4.matrixOrthoRH(fWidth, fHeight, fNearPlane, fFarPlane, this._m4fProj);

		    // create a unit-space matrix 
		    // for sky box geometry.
		    // this ensures that the 
		    // near and far plane enclose 
		    // the unit space around the camera
		    Mat4.matrixOrthoRH(fWidth, fHeight, 0.01, 2.0, this._m4fUnitProj);

		    TRUE_BIT(this._iUpdateProjectionFlags, ECameraFlags.k_NewProjectionMatrix);

		    */

    	}

    	setOffsetOrthoParams(fMinX:  number , fMaxX:  number , fMinY:  number , fMaxY:  number , fNearPlane:  number , fFarPlane:  number ): void {
    		this._fMinX = fMinX;
		    this._fMaxX = fMaxX;
		    this._fMinY = fMinY;
		    this._fMaxY = fMaxY;
		    this._fNearPlane = fNearPlane;
		    this._fFarPlane = fFarPlane;
		    this._eCameraType = ECameraTypes.OFFSET_ORTHO;

// create the regular projection matrix
/*orthogonalProjection*/
		    Mat4.                        orthogonalProjectionAsymmetric(fMinX, fMaxX, fMinY, fMaxY,
		                                fNearPlane, fFarPlane, this._m4fProj);

// create a unit-space matrix 
// for sky box geometry.
// this ensures that the 
// near and far plane enclose 
// the unit space around the camera
/*orthogonalProjection*/
		    Mat4.                        orthogonalProjectionAsymmetric(fMinX, fMaxX, fMinY, fMaxY,
		                                0.01, 2.0, this._m4fUnitProj);

		    ((this._iUpdateProjectionFlags) |= (1 << ((ECameraFlags.k_NewProjectionMatrix))) ) ;
    	}

    	private recalcMatrices(): void {
    		this._v3fTargetPos.set(
	        this._m4fLocalMatrix.data[ 8 ],
	        this._m4fLocalMatrix.data[ 9 ],
	        this._m4fLocalMatrix.data[ 10 ]);

		    this._v3fTargetPos.negate();

// the camera view matrix is the
// inverse of the world matrix
		    this._m4fView.set(this.inverseWorldMatrix);
// sky boxes use the inverse 
// world matrix of the camera (the
// camera view matrix) without 
// any translation information.

//this.m4fSkyBox.set(this.m4fView);
// this.m4fSkyBox.data[__14] = 0.0;
// this.m4fSkyBox.data[__24] = 0.0;
// this.m4fSkyBox.data[__34] = 0.0;

// this is combined with the unit
// space projection matrix to form
// the sky box viewing matrix
//this.m4fSkyBox.multiply(this.m4fUnitProj, this.m4fSkyBox);


// billboard objects use our world matrix
// without translation
// this.m4fBillboard.set(this.worldMatrix());
// this.m4fBillboard.data[__14] = 0.0;
// this.m4fBillboard.data[__24] = 0.0;
// this.m4fBillboard.data[__34] = 0.0;
    	}

    	update(): bool {
    		var isUpdated: bool = super.update();

		    if (this.isWorldMatrixNew() ||  ((this._iUpdateProjectionFlags & (1 << (ECameraFlags.k_NewProjectionMatrix)) ) != 0) ) {
		    	this._pFrustum.extractFromMatrix(this._m4fProj, this._m4fWorldMatrix, this._pSearchRect);

// our projView matrix is the projection 
//matrix multiplied by the inverse of our world matrix  
		        this._m4fProj.multiply(this._m4fView, this._m4fRenderStageProjView);

		        isUpdated = true;
		    }

		    return isUpdated;
    	}

		applyRenderStageBias(iStage:  number ): void {
	    	var fZ_bias = iStage > 1 ? 0.001 : 0.0;

		    this._m4fRenderStageProj.set(this._m4fProj);
		    this._m4fRenderStageProjView.set(this._m4fProjView);

		    this._m4fRenderStageProj[ 14 ] -= fZ_bias;
		    this._m4fRenderStageProjView[ 14 ] -= fZ_bias;
	    }

    	lookAt(v3fFrom: IVec3, v3fCenter: IVec3, v3fUp?: IVec3): void;
    	lookAt(v3fCenter: IVec3, v3fUp?: IVec3): void;
    	lookAt(v3f?): void {
    		var v3fFrom: IVec3, v3fCenter: IVec3, v3fUp: IVec3;

		    if (arguments.length < 3) {
		        v3fFrom = this.worldPosition;
		        v3fCenter = <IVec3>arguments[0];
		        v3fUp = <IVec3>arguments[1];
		    }
		    else {
		        v3fFrom = <IVec3>arguments[0];
		        v3fCenter = <IVec3>arguments[1];
		        v3fUp = <IVec3>arguments[2];
		    }

		    v3fUp = v3fUp || vec3(0., 1., 0.);

		    var v3fParentPos: IVec3 = (<Node>this.parent).worldPosition;
		    var m4fTemp: IMat4 = Mat4.lookAt(v3fFrom, v3fCenter, v3fUp, mat4()).inverse();
		    var pData: Float32Array = m4fTemp.data;

		    switch (this._eInheritance) {
		        case ENodeInheritance.ALL :
		            (<Node>this._pParent).inverseWorldMatrix.multiply(m4fTemp, m4fTemp);
		            m4fTemp.toQuat4(this._qRotation);
		            this.setPosition(pData[ 12 ], pData[ 13 ], pData[ 14 ]);
		            break;
		        case ENodeInheritance.ROTSCALE :
		            var m3fTemp = m4fTemp.toMat3();
		            m3fTemp = (<Node>this._pParent).inverseWorldMatrix.toMat3().multiply(m3fTemp, mat3());
		            m3fTemp.toQuat4(this._qRotation);
		            this.setPosition(pData[ 12 ], pData[ 13 ], pData[ 14 ]);
		            break;
		        default :
		            m4fTemp.toQuat4(this._qRotation);
		            this.setPosition(
		            	pData[ 12 ] - v3fParentPos.x,
		            	pData[ 13 ] - v3fParentPos.y,
		                pData[ 14 ] - v3fParentPos.z);
		    }
    	}

    	_renderScene(pViewport: IViewport): void {
//update the pixel display ratio
// if (this._eCameraType == ECameraTypes.PERSPECTIVE) {
// 	mPixelDisplayRatio = (2. * math.tan(this._fFOV * 0.5)) / pViewport.actualHeight;
// }
// else {
// 	mPixelDisplayRatio = (mTop - mBottom) / vp->getActualHeight();
// }

//notify prerender scene
			this.preRenderScene();


			pViewport.update();

//notify postrender scene
			this.postRenderScene();
    	}


    	_keepLastViewport(pViewport: IViewport): void { this._pLastViewport = pViewport; }
    	_getLastViewport(): IViewport { return this._pLastViewport; }
    	_getNumRenderedFaces():  number  { return 0; }
    	_notifyRenderedFaces(nFaces:  number ): void {}

    	toString(isRecursive: bool = false, iDepth:  number  = 0): string {
		    if (!isRecursive) {
		        return "<camera" + (this._sName? " " + this._sName: "") + ">";
		    }

		    return super.toString(isRecursive, iDepth);
    	}

    	_addDisplayList(pScene: IScene3d, pList: IDisplayList, index:  number ): void {
    		this._pDLTechniques[index] = new DLTechnique(pList, this);
    	}

    	_removeDisplayList(pScene: IScene3d, pList: IDisplayList, index:  number ): void {
    		this._pDLTechniques[index] = null;
    	}



    	private _iGuid: number = eval("this._iGuid || akra.sid()"); private _pUnicastSlotMap: IEventSlotMap = null; private _pBroadcastSlotList: IEventSlotListMap = null; private static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable {return Camera._pEventTable; } getGuid(): number {return this._iGuid < 0? (this._iGuid = sid()): this._iGuid; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
    		preRenderScene (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).preRenderScene; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
    		postRenderScene (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).postRenderScene; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
    	;
	}
}



module akra.scene.light {
	export class ShadowCaster extends objects.Camera implements IShadowCaster {
		/**@protected*/  _pLightPoint: ILightPoint;
		/**@protected*/  _iFace:  number ;

		get lightPoint(): ILightPoint{
			return this._pLightPoint;
		};

		get face():  number {
			return this._iFace;
		};

		constructor (pLightPoint: ILightPoint, iFace:  number  =  0 ) {
			super(pLightPoint.scene);

			this._pLightPoint = pLightPoint;
			this._iFace = iFace;
		}
	}
}



module akra.scene.light {
	export class ProjectLight extends LightPoint implements IProjectLight {
		/**@protected*/  _pDepthTexture: ITexture = null;
// protected _pColorTexture: ITexture = null;
		/**@protected*/  _pShadowCaster: IShadowCaster;

		/**@protected*/  _m4fOptimizdeProj: IMat4 = null;
		/**@protected*/  _m4fCurrentOptimizedProj: IMat4 = null;

		/**@inline*/  get optimizedProjection(): IMat4 {
			return this._m4fOptimizdeProj;
		}

		/**@inline*/  get currentOptimizedProjection(): IMat4 {
			return this._m4fCurrentOptimizedProj;
		}

		constructor (pScene: IScene3d) {
			super(pScene);
			this._eType = EEntityTypes.LIGHT_PROJECT;
		}

		create(isShadowCaster: bool = true): bool {
			var isOk: bool = super.create();

			var pCaster: IShadowCaster = new ShadowCaster(this);

			if (!pCaster.create()) {
				logger.setSourceLocation( "scene/light/ProjectLight.ts" , 36 ); logger.error("cannot create shadow caster"); ;
				return false;
			}

			pCaster.setParameter(ECameraParameters.CONST_ASPECT, true);
			pCaster.setInheritance(ENodeInheritance.ALL);
			pCaster.attachToParent(this);

			pCaster.accessLocalMatrix().identity();

			if (this.isShadowCaster()) {
				this._m4fOptimizdeProj = new Mat4();
			}

			this.initializeTextures();

			return isOk;
		}

		/**@inline*/  getDepthTexture(): ITexture {
			return this._pDepthTexture;
		}

		/**@inline*/  getRenderTarget(): ITexture {
			return this._pDepthTexture.getBuffer().getRenderTarget();
		}

		/**@inline*/  getShadowCaster(): IShadowCaster {
			return this._pShadowCaster;
		}

		private initializeTextures(): void {
			if (!this.isShadowCaster()) {
				return;
			}

			var pEngine: IEngine = this.scene.getManager().getEngine();
			var pResMgr: IResourcePoolManager = pEngine.getResourceManager();
			var iSize:  number  = this._iMaxShadowResolution;

			if (this._pDepthTexture) {
				this._pDepthTexture.destroy();
			}

			var pDepthTexture: ITexture = this._pDepthTexture =
				pResMgr.createTexture("depth_texture_" + this.getGuid());
			pDepthTexture.create(iSize, iSize, 1, Color.BLACK, 0,
				0, ETextureTypes.TEXTURE_2D, EPixelFormats.DEPTH);

			pDepthTexture.setParameter(ETextureParameters.WRAP_S, ETextureWrapModes.CLAMP_TO_EDGE);
			pDepthTexture.setParameter(ETextureParameters.WRAP_T, ETextureWrapModes.CLAMP_TO_EDGE);
			pDepthTexture.setParameter(ETextureParameters.MAG_FILTER, ETextureFilters.LINEAR);
			pDepthTexture.setParameter(ETextureParameters.MIN_FILTER, ETextureFilters.LINEAR);

// if (this._pColorTexture) {
// 	this._pColorTexture.destroy();
// }

// var pColorTexture: ITexture = pResMgr.createTexture("light_color_texture_" + this.getGuid());
// pColorTexture(iSize, iSize, 1, Color.BLACK, 0,
// 	0, ETextureTypes.TEXTURE_2D, EPixelFormats.LUMINANCE);

// this._pColorTexture = pColorTexture;

//TODO: Multiple render target			this.getRenderTarget().addViewport(this._pShadowCaster);
		}

		_calculateShadows(): void {
			if (!this._isEnabled || !this.isShadowCaster()) {
				return;
			}

			this.getRenderTarget().update();
		}
	}
}






//"use strict";



















module akra {

    export interface IEngine {} ;
    export interface IScene3d {} ;
    export interface IScene2d {} ;

    export interface ISceneManager extends IManager {
        createScene3D(): IScene3d;
        createScene2D(): IScene2d;

        getScene3D(iScene?:  number ): IScene3d;
        getScene2D(iScene?:  number ): IScene2d;
        getScene(iScene?:  number , eType?: ESceneTypes): IScene;

        update(): void;
        notifyUpdateScene(): void;
        notifyPreUpdateScene(): void;
    }
}









module akra {
    export interface IParticleManager extends IManager {

    }
}








module akra {

    export interface IAFXComponent {} ;
    export interface IAFXEffect {} ;
    export interface IRenderableObject {} ;
    export interface IRenderSnapshot {} ;
    export interface ISceneObject {} ;
    export interface IBufferMap {} ;
    export interface IShaderProgram {} ;
    export interface ISurfaceMaterial {} ;
    export interface IVertexData {} ;
    export interface IVertexBuffer {} ;
    export interface ITexture {} ;
    export interface IIndexBuffer {} ;
    export interface IRenderResource {} ;
    export interface IRenderEntry {} ;
    export interface IFrameBuffer {} ;
    export interface IViewport {} ;
    export interface IColor {} ;
    export interface IEngine {} ;
    export interface IRenderTarget {} ;




//API SPECIFIFC CONSTANTS

    export enum EPrimitiveTypes {
        POINTLIST = 0,
        LINELIST,
        LINELOOP,
        LINESTRIP,
        TRIANGLELIST,
        TRIANGLESTRIP,
        TRIANGLEFAN
    };

    export enum ERenderCapabilitiesCategory {
        C_COMMON = 0,
        C_COMMON_2 = 1,
        C_WEBGL = 2,

        COUNT = 3
    }

    export enum ERenderCapabilities{
        AUTOMIPMAP              =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 0)) ,
        BLENDING                =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 1)) ,
/// Supports anisotropic texture filtering
        ANISOTROPY              =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 2)) ,
/// Supports fixed-function DOT3 texture blend
        DOT3                    =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 3)) ,
/// Supports cube mapping
        CUBEMAPPING             =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 4)) ,
/// Supports hardware stencil buffer
        HWSTENCIL               =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 5)) ,
/// Supports hardware vertex and index buffers
        VBO                     =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 7)) ,
/// Supports vertex programs (vertex shaders)
        VERTEX_PROGRAM          =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 9)) ,
/// Supports fragment programs (pixel shaders)
        FRAGMENT_PROGRAM        =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 10)) ,
/// Supports performing a scissor test to exclude areas of the screen
        SCISSOR_TEST            =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 11)) ,
/// Supports separate stencil updates for both front and back faces
        TWO_SIDED_STENCIL       =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 12)) ,
/// Supports wrapping the stencil value at the range extremeties
        STENCIL_WRAP            =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 13)) ,
/// Supports hardware occlusion queries
        HWOCCLUSION             =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 14)) ,
/// Supports user clipping planes
        USER_CLIP_PLANES        =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 15)) ,
/// Supports the VET_UBYTE4 vertex element type
        VERTEX_FORMAT_UBYTE4    =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 16)) ,
/// Supports infinite far plane projection
        INFINITE_FAR_PLANE      =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 17)) ,
/// Supports hardware render-to-texture (bigger than framebuffer)
        HWRENDER_TO_TEXTURE     =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 18)) ,
/// Supports float textures and render targets
        TEXTURE_FLOAT           =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 19)) ,
/// Supports non-power of two textures
        NON_POWER_OF_2_TEXTURES =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 20)) ,
/// Supports 3d (volume) textures
        TEXTURE_3D              =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 21)) ,
/// Supports basic point sprite rendering
        POINT_SPRITES           =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 22)) ,
/// Supports extra point parameters (minsize, maxsize, attenuation)
        POINT_EXTENDED_PARAMETERS =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 23)) ,
/// Supports vertex texture fetch
        VERTEX_TEXTURE_FETCH =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 24)) ,
/// Supports mipmap LOD biasing
        MIPMAP_LOD_BIAS =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 25)) ,
/// Supports hardware geometry programs
        GEOMETRY_PROGRAM =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 26)) ,
/// Supports rendering to vertex buffers
        HWRENDER_TO_VERTEX_BUFFER =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 27)) ,

/// Supports compressed textures
        TEXTURE_COMPRESSION =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 0)) ,
/// Supports compressed textures in the DXT/ST3C formats
        TEXTURE_COMPRESSION_DXT =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 1)) ,
/// Supports compressed textures in the VTC format
        TEXTURE_COMPRESSION_VTC =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 2)) ,
/// Supports compressed textures in the PVRTC format
        TEXTURE_COMPRESSION_PVRTC =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 3)) ,
/// Supports fixed-function pipeline
        FIXED_FUNCTION =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 4)) ,
/// Supports MRTs with different bit depths
        MRT_DIFFERENT_BIT_DEPTHS =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 5)) ,
/// Supports Alpha to Coverage (A2C)
        ALPHA_TO_COVERAGE =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 6)) ,
/// Supports Blending operations other than +
        ADVANCED_BLEND_OPERATIONS =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 7)) ,
/// Supports a separate depth buffer for RTTs. D3D 9 & 10, OGL w/FBO (FBO implies this flag)
        RTT_SEPARATE_DEPTHBUFFER =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 8)) ,
/// Supports using the MAIN depth buffer for RTTs. D3D 9&10, OGL w/FBO support unknown
/// (undefined behavior?), OGL w/ copy supports it
        RTT_MAIN_DEPTHBUFFER_ATTACHABLE =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 9)) ,
/// Supports attaching a depth buffer to an RTT that has width & height less or equal than RTT's.
/// Otherwise must be of _exact_ same resolution. D3D 9, OGL 3.0 (not 2.0, not D3D10)
        RTT_DEPTHBUFFER_RESOLUTION_LESSEQUAL =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 10)) ,
/// Supports using vertex buffers for instance data
        VERTEX_BUFFER_INSTANCE_DATA =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 11)) ,
/// Supports using vertex buffers for instance data
        CAN_GET_COMPILED_SHADER_BUFFER =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 12)) ,


// ***** GL Specific Caps *****
/// Supports openGL GLEW version 1.5
        GL1_5_NOVBO    =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 1)) ,
/// Support for Frame Buffer Objects (FBOs)
        FBO              =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 2)) ,
/// Support for Frame Buffer Objects ARB implementation (regular FBO is higher precedence)
        FBO_ARB          =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 3)) ,
/// Support for Frame Buffer Objects ATI implementation (ARB FBO is higher precedence)
        FBO_ATI          =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 4)) ,
/// Support for PBuffer
        PBUFFER          =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 5)) ,
/// Support for GL 1.5 but without HW occlusion workaround
        GL1_5_NOHWOCCLUSION =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 6)) ,
/// Support for point parameters ARB implementation
        POINT_EXTENDED_PARAMETERS_ARB =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 7)) ,
/// Support for point parameters EXT implementation
        POINT_EXTENDED_PARAMETERS_EXT =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 8)) ,
/// Support for Separate Shader Objects
        SEPARATE_SHADER_OBJECTS =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 9))
    }

// export enum EGLSpecifics {
//     UNPACK_ALIGNMENT = 0x0CF5,
//     PACK_ALIGNMENT = 0x0D05,
//     UNPACK_FLIP_Y_WEBGL = 0x9240,
//     UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241,
//     CONTEXT_LOST_WEBGL = 0x9242,
//     UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243,
//     BROWSER_DEFAULT_WEBGL = 0x9244
// };

// export enum EBufferMasks {
//     DEPTH_BUFFER_BIT               = 0x00000100,
//     STENCIL_BUFFER_BIT             = 0x00000400,
//     COLOR_BUFFER_BIT               = 0x00004000
// };

// export enum EBufferUsages {
//     STREAM_DRAW = 0x88E0,
//     STATIC_DRAW = 0x88E4,
//     DYNAMIC_DRAW = 0x88E8
// };

// export enum EBufferTypes {
//     ARRAY_BUFFER = 0x8892,
//     ELEMENT_ARRAY_BUFFER = 0x8893,
//     FRAME_BUFFER = 0x8D40,
//     RENDER_BUFFER = 0x8D41
// };

// export enum EAttachmentTypes {
//     COLOR_ATTACHMENT0 = 0x8CE0,
//     DEPTH_ATTACHMENT = 0x8D00,
//     STENCIL_ATTACHMENT = 0x8D20,
//     DEPTH_STENCIL_ATTACHMENT = 0x821A
// };

// export enum ERenderStates {
//     ZENABLE = 7,
//     ZWRITEENABLE = 14,
//     SRCBLEND = 19,
//     DESTBLEND = 20,
//     CULLMODE = 22,
//     ZFUNC = 23,
//     DITHERENABLE = 26,
//     ALPHABLENDENABLE = 27,
//     ALPHATESTENABLE
// };

// export enum EBlendModes {
//     ZERO = 0,
//     ONE = 1,
//     SRCCOLOR = 0x0300,
//     INVSRCCOLOR = 0x301,
//     SRCALPHA = 0x0302,
//     INVSRCALPHA = 0x0303,
//     DESTALPHA = 0x0304,
//     INVDESTALPHA = 0x0305,
//     DESTCOLOR = 0x0306,
//     INVDESTCOLOR = 0x0307,
//     SRCALPHASAT = 0x0308
// };

// export enum ECmpFuncs {
//     NEVER = 1,
//     LESS = 2,
//     EQUAL = 3,
//     LESSEQUAL = 4,
//     GREATER = 5,
//     NOTEQUAL = 6,
//     GREATEREQUAL = 7,
//     ALWAYS = 8
// };

// export enum ECullModes {
//     NONE = 0,
//     CW = 0x404, //FRONT
//     CCW = 0x0405, //BACK
//     FRONT_AND_BACK = 0x0408
// };

//END OF API SPECIFIC

// export enum ERenderStages {
//  SHADOWS = 2,
//  LIGHTING,
//  GLOBALPOSTEFFECTS,
//  DEFAULT
// }

    export interface IRenderer {
        getEngine(): IEngine;

        debug(bValue?: bool): bool;
        enableAPITrace(): bool;

        isDebug(): bool;
        isValid(): bool;

        getError();

        clearFrameBuffer(iBuffer:  number , cColor: IColor, iDepth:  number ): void;

        _disableAllTextureUnits(): void;
        _disableTextureUnitsFrom(iUnit:  number ): void;

        _initRenderTargets(): void;
        _updateAllRenderTargets(): void;

        _setViewport(pViewport: IViewport): void;
        _getViewport(): IViewport;

        hasCapability(eCapability: ERenderCapabilities): bool;

        attachRenderTarget(pTarget: IRenderTarget): bool;
        detachRenderTarget(pTarget: IRenderTarget): bool;
        destroyRenderTarget(pTarget: IRenderTarget): void;

        getActiveProgram(): IShaderProgram;
    }



}






module akra {
	export enum EUtilTimerCommands {
//! <to reset the timer
		TIMER_RESET,
//! <to start the timer
		TIMER_START,
//! <to stop (or pause) the timer
		TIMER_STOP,
//! <to advance the timer by 0.1 seconds
		TIMER_ADVANCE,
//! <to get the absolute system time
		TIMER_GET_ABSOLUTE_TIME,
//! <to get the current time
		TIMER_GET_APP_TIME,
		TIMER_GET_ELAPSED_TIME
//! to get the time that elapsed between TIMER_GETELAPSEDTIME calls
	}

    export interface IUtilTimer {
        absoluteTime:  number ;
        appTime:  number ;
        elapsedTime:  number ;

        start(): bool;
        stop(): bool;
        reset(): bool;
        execCommand(e: EUtilTimerCommands):  number ;

//static start(): IUtilTimer;
    }
}
















module akra {

        export interface IEngine {} ;
        export interface IResourceCode {} ;
        export interface IResourcePoolItem {} ;
        export interface IResourcePoolManager {} ;

        export interface IResourcePool extends IEventProvider {
                iFourcc:  number ;
                 manager: IResourcePoolManager;

/** Добавление данного пула в менеджер ресурсво по его коду */

                registerResourcePool(pCode: IResourceCode): void;
/** Удаление данного пула в менеджер ресурсво по его коду */

                unregisterResourcePool(): void;
/** По имени ресурса возвращает его хендл */

                findResourceHandle(sName: string):  number ;
/** По хендлу ресурва возвращает его имя */

                findResourceName(iHandle:  number ): string;

/** set resource name */

                setResourceName(iHandle:  number , sName: string): void;

                initialize(iGrowSize:  number ): void;
                destroy(): void;
                clean(): void;

                destroyAll(): void;
                restoreAll(): void;
                disableAll(): void;

                isInitialized(): bool;

//callbackDestroy(pPool: IDataPool, iHandle: int, pResource: IResourcePoolItem): void;
//callbackDisable(pPool: IDataPool, iHandle: int, pResource: IResourcePoolItem): void;
//callbackRestore(pPool: IDataPool, iHandle: int, pResource: IResourcePoolItem): void;
//callbackClean(pPool: IDataPool, iHandle: int, pResource: IResourcePoolItem): void;

                createResource(sResourceName: string): IResourcePoolItem;
                loadResource(sResourceName: string): IResourcePoolItem;
                saveResource(pResource: IResourcePoolItem): bool;
                destroyResource(pResource: IResourcePoolItem): void;

                findResource(sName: string): IResourcePoolItem;
                getResource(iHandle:  number ): IResourcePoolItem;
                getResources(): IResourcePoolItem[];

                 createdResource(pResource: IResourcePoolItem): void;
        }
}








module akra {

	export interface IResourcePoolItem {} ;

	export interface IResourceWatcherFunc {
		(nLoaded?:  number , nTotal?:  number , pTarget?: IResourcePoolItem): void;
	}
}













// totalAnimations: uint;
// totalMeshes: uint;
// node: ISceneNode;

// getAnimation(iAnim: uint): IAnimationBase;
// setAnimation(iAnim: uint, pAnimation: IAnimationBase): void;
// addAnimation(pAnimation: IAnimationBase): void;

// getAnimationController(): IAnimationController;

// getMesh(iMesh: uint): IMesh;
// addMesh(pMesh: IMesh): void;

// addNode(pNode: ISceneNode): void;

// addSkeleton(pSkeleton: ISkeleton): void;

// addToScene(pScene: IScene3d): bool;
//    attachToScene(pNode: ISceneNode): bool;

// getRootNodes(): ISceneNode[];

// loadResource(sFilename?: string, pOptions?: IColladaLoadOptions, fnCallback?: (pModel: IModel) => void): bool;
// loadAnimation(sFilename: string): bool;

// //instead old method: applyShadow();
// _setup(): bool;

// _notifyFileLoaded(): uint;
// _notifyFileLoad(): uint;
// _totalFiles(): uint;

module akra {
	export interface ISkeleton {} ;
	export interface IModel {} ;
	export interface IEngine {} ;

//=============================================
// COLLADA LOAD OPTIONS
//=============================================

    export interface ICollada extends IModel {
//getAnimationController(): IAnimationController;
//getMesh(sName: string);
//getSkeleton();
    }

	export interface IColladaAnimationLoadOptions {
		pose?: bool;
	}

    export interface IColladaCache {
        meshMap: IMeshMap;
        sharedBuffer: IRenderDataCollection;
    }



	export interface IColladaLoadOptions {
/** Add nodes, that visualize joints in animated models. */

    	drawJoints?: bool;
/** Convert all meshed to wireframe. */

    	wireframe?: bool;
/** 
    	 * Use common buffer for all data 
    	 * @deprecated
    	 */

    	sharedBuffer?: bool;

    	animation?: IColladaAnimationLoadOptions;
    	scene?: bool;
    	extractPoses?: bool;
    	skeletons?: ISkeleton[];
    }

// xml

    export interface IXMLExplorer {
        (pXML: Node, sName?: string): void;
    }

//----------------------

    export interface IColladaTarget {
        value: number;
        object?: IColladaEntry;
        source?: IColladaEntry;
    }

    export interface IColladaEntry {
        id?: string;
        sid?: string;
        name?: string;
    }

    export interface IColladaEntryMap {
        [id: string]: IColladaEntry;
    }

    export interface IColladaLibrary extends IColladaEntry {
        [element: string]: IColladaEntryMap;
    }

    export interface IColladaEffectLibrary extends IColladaLibrary {
        effects: { [id: string]: IColladaEffect; };
    }

    export interface IColladaEntryLoader {
        (pXML: Node): IColladaEntry;
    }


    export interface IColladaUnknownFormat {
    	name: string[];
    	type: string[];
    }

/** Stride for collada formats, discretized at 32 bits. */

    export interface IColladaFormatStrideTable {
    	[format: string]:  number ;
    }

    export interface IColladaConverter {
    	(data: string, output: any[], from:  number ):  number ;
    }

    export interface IColladaConvertionTableRow {
        type: any;
        converter: IColladaConverter;
    }

    export interface IColladaConvertionTable {
    	[type: string]: IColladaConvertionTableRow;
    }

    export interface IColladaLinkMap {
    	[link: string]: any;
    }

    export interface IColladaLibraryMap {
    	[library: string]: IColladaLibrary;
    }

    export interface IColladaLibraryTemplate {
/** library tag name.*/
    	lib: string;
/** element in liibrary. */
    	element: string;
/** loader function */
    	loader: string;
    }

//=============================================
// COLLADA NODES / VISUAL SCENE AND COMMON
//=============================================

    export interface IColladaUnit extends IColladaEntry {
        name: string;
        meter:  number ;
    }

    export interface IColladaContributor extends IColladaEntry {
        author: string;
        authorTool: string;
        comments: string;
        copyright: string;
        sourceData: any;
    }

    export interface IColladaAsset extends IColladaEntry {
        unit: IColladaUnit;
        upAxis: string;
        title: string;
        created: string;
        modified: string;
        contributor: IColladaContributor;
    }

    export interface IColladaInstance extends IColladaEntry {
        url?: string;
    }

    export interface IColladaNewParam extends IColladaEntry {
        sid: string;
        annotate: string;
        semantics: string;
        modifier: string;
        value: any;
        type: string;
    }

    export interface IColladaNewParamMap {
        [sid: string]: IColladaNewParam;
    }

    export interface IColladaParam extends IColladaEntry {
        name: string;
        type: string;
    }

    export interface IColladaAccessor extends IColladaEntry {
        data: IColladaEntry;
        count:  number ;
        stride:  number ;
        params: IColladaParam[];
    }


    export interface IColladaTechniqueCommon extends IColladaEntry {
        accessor: IColladaAccessor;
    }


    export interface IColladaSource extends IColladaEntry {
        name: string;

        array: Object;
        techniqueCommon: IColladaTechniqueCommon;
    }

    export interface IColladaInput extends IColladaEntry {
        semantics: string;
        source: IColladaSource;
        offset:  number ;
        set: string;

        array?: any[];
        arrayId?: string;
        accessor?: IColladaAccessor;
    }

    export interface IColladaTransform extends IColladaEntry {
        transform: string;
        value: any;
    }

    export interface IColladaRotate extends IColladaTransform {
        value: IVec4;
    }

    export interface IColladaTranslate extends IColladaTransform {
        value: IVec3;
    }

    export interface IColladaScale extends IColladaTransform {
        value: IVec3;
    }

    export interface IColladaMatrix extends IColladaTransform {
        value: IMat4;
    }

    export interface IColladaVertices extends IColladaEntry {
        inputs: { [semantics: string]: IColladaInput; };
    }

    export interface IColladaJoints extends IColladaEntry {
        inputs: { [input: string]: IColladaInput; };

    }

    export interface IColladaPolygons extends IColladaEntry {
        name: string;

        inputs: IColladaInput[];
        p:  number [];
        material: string;

        type?: EPrimitiveTypes;
    }

    export interface IColladaMesh extends IColladaEntry {
        sources: IColladaSource[];
        polygons: IColladaPolygons[];
    }

    export interface IColladaConvexMesh extends IColladaEntry {
//TODO: IColladaConvexMesh
    }

    export interface IColladaSpline extends IColladaEntry {
//TODO: IColladaSpline
    }

    export interface IColladaGeometrie extends IColladaEntry {
        name: string;

        mesh: IColladaMesh;
        convexMesh: IColladaConvexMesh;
        spline: IColladaSpline;
    }

    export interface IColladaMorph extends IColladaEntry {
//TODO: IColladaMorph
    }

    export interface IColladaVertexWeights extends IColladaEntry {
        count:  number ;
        inputs: IColladaInput[];
        weightInput: IColladaInput;
        vcount:  number [];
        v:  number [];
    }

    export interface IColladaSkin extends IColladaEntry {
        shapeMatrix: IMat4;
        sources: IColladaSource[];
        geometry: IColladaGeometrie;
        joints: IColladaJoints;
        vertexWeights: IColladaVertexWeights;
    }

    export interface IColladaController extends IColladaEntry {
        name: string;

        skin: IColladaSkin;
        morph: IColladaMorph;
    }

    export interface IColladaImage extends IColladaEntry {
        name: string;

        depth:  number ;
        data: any;
        path: string;
    }

//effects

    export interface IColladaSurface extends IColladaEntry {
        initFrom: string;
    }

    export interface IColladaSampler2D extends IColladaEntry {
        param: IColladaNewParam;
        wrapS: string;
        wrapT: string;
        minFilter: string;
        mipFilter: string;
        magFilter: string;
    }

    export interface IColladaTexture extends IColladaEntry {
        texcoord: string;
        sampler: IColladaSampler2D;
        surface: IColladaSurface;
        image: IColladaImage;


    }


    export interface IColladaInstanceEffect extends IColladaInstance {
        parameters: Object;
        techniqueHint: StringMap;
        effect: IColladaEffect;
    }


    export interface IColladaPhong extends IColladaEntry {
        diffuse: IColorValue;
        specular: IColorValue;
        ambient: IColorValue;
        emissive: IColorValue;
        shininess:  number ;

        reflective: IColorValue;
        reflectivity:  number ;
        transparent: IColorValue;
        transparency:  number ;

        indexOfRefraction:  number ;

//------------------
        textures?: {
            diffuse: IColladaTexture;
            specular: IColladaTexture;
            ambient: IColladaTexture;
            emissive: IColladaTexture;
        };
    }

    export interface IColladaEffectTechnique extends IColladaEntry {
        sid: string;
        type: string;
        value: IColladaEntry;
    }

    export interface IColladaProfileCommon extends IColladaEntry {
        technique: IColladaEffectTechnique;
        newParam: IColladaNewParamMap;
    }

    export interface IColladaEffect extends IColladaEntry {
        profileCommon: IColladaProfileCommon;
    }

// materials

    export interface IColladaMaterial extends IColladaEntry {
        name: string;

        instanceEffect: IColladaInstanceEffect;
    }



    export interface IColladaTechniqueValue extends IColladaEntry {

    }


    export interface IColladaBindVertexInput extends IColladaEntry {
        semantics: string;
        inputSemantic: string;
        inputSet:  number ;
    }

    export interface IColladaBindVertexInputMap {
        [semantics: string]: IColladaBindVertexInput;
    }

    export interface IColladaInstanceMaterial extends IColladaInstance {
        symbol: string;
        target: string;
        vertexInput: IColladaBindVertexInputMap;
        material: IColladaMaterial;
    }

    export interface IColladaBindMaterial extends IColladaEntry {
        [symbol: string]: IColladaInstanceMaterial;
    }

    export interface IColladaInstanceGeometry extends IColladaInstance {
        geometry: IColladaGeometrie;
        material: IColladaBindMaterial;
    }


    export interface IColladaInstanceController extends IColladaInstance {
        controller: IColladaController;
        material: IColladaBindMaterial;
        skeletons: string[];
    }

    export interface IColladaNode extends IColladaEntry {
        sid: string;
        name: string;
        type: string;
        layer: string;

        transform: IMat4;
        geometry: IColladaInstanceGeometry[];
        controller: IColladaInstanceController[];

        childNodes: IColladaNode[];
        depth:  number ;
        transforms: IColladaTransform[];

        constructedNode: ISceneNode;
    }

    export interface IColladaVisualScene extends IColladaEntry {
        name: string;

        nodes: IColladaNode[];
    }



/// animation

    export interface IColladaAnimationSampler extends IColladaEntry {
        inputs: { [semantics: string]: IColladaInput; };
    }

    export interface IColladaAnimationChannel extends IColladaEntry {
        source: string;
        target: IColladaTarget;
        sampler: IColladaAnimationSampler;
    }

    export interface IColladaAnimation extends IColladaEntry {
        name: string;

        sources: IColladaSource[];
        samplers: IColladaAnimationSampler[];
        channels: IColladaAnimationChannel[];

        animations: IColladaAnimation[];
    }


}



module akra {
    export interface IAnimationBase {} ;
    export interface IAnimationBaseController {} ;
    export interface IColladaLoadOptions {} ;
    export interface ISceneNode {} ;
    export interface IScene3d {} ;
    export interface ISkeleton {} ;
    export interface IMesh {} ;


    export interface IModel extends IResourcePoolItem {

        loadResource(sFilename?: string, pOptions?: IColladaLoadOptions): bool;
        attachToScene(pNode: ISceneNode): bool;
    }
}



// totalAnimations: uint;
// totalMeshes: uint;
// node: ISceneNode;

// getAnimation(iAnim: uint): IAnimationBase;
// setAnimation(iAnim: uint, pAnimation: IAnimationBase): void;
// addAnimation(pAnimation: IAnimationBase): void;

// getAnimationController(): IAnimationController;

// getMesh(iMesh: uint): IMesh;
// addMesh(pMesh: IMesh): void;

// addNode(pNode: ISceneNode): void;

// addSkeleton(pSkeleton: ISkeleton): void;

// addToScene(pScene: IScene3d): bool;
//    attachToScene(pNode: ISceneNode): bool;

// getRootNodes(): ISceneNode[];

// loadResource(sFilename?: string, pOptions?: IColladaLoadOptions, fnCallback?: (pModel: IModel) => void): bool;
// loadAnimation(sFilename: string): bool;

// //instead old method: applyShadow();
// _setup(): bool;

// _notifyFileLoaded(): uint;
// _notifyFileLoad(): uint;
// _totalFiles(): uint;











module akra {
	export enum EResourceCodes {
		INVALID_CODE = 0xFFFFFFFF
	};

	export interface IResourceCode {
		family:  number ;
		type:  number ;
/** Пеерводит текущее состояние идентифиакора в невалидное */

		setInvalid(): void;
/** operator "<" */

		less(pSrc: IResourceCode): bool;
/** operator = */

		eq(pSrc: IResourceCode): IResourceCode;

		valueOf():  number ;
		toNumber():  number ;
	}
}



module akra.core.pool {
	export class ResourceCode implements IResourceCode {
		private iValue:  number  = <number>(EResourceCodes.INVALID_CODE);

		get family():  number  {
			return this.iValue >> 16;
		}

		set family(iNewFamily:  number ) {
			this.iValue &= 0x0000FFFF;
	        this.iValue |= iNewFamily << 16;
		}

		get type():  number  {
			return this.iValue & 0x0000FFFF;
		}

		set type(iNewType:  number ) {
			this.iValue &= 0xFFFF0000;
            this.iValue |= iNewType & 0x0000FFFF;
		}

		constructor ();
		constructor(iCode:  number );
		constructor(eCode: EResourceCodes);
		constructor(pCode: IResourceCode);
		constructor(iFamily:  number , iType:  number );
		constructor (iFamily?, iType?) {
			switch (arguments.length) {
		        case 0:
		            this.iValue = <number>EResourceCodes.INVALID_CODE;
		            break;
		        case 1:
		            if (arguments[0] instanceof ResourceCode) {
		                this.iValue = arguments[0].iValue;
		            }
		            else {
		                this.iValue = arguments[0];
		            }
		            break;
		        case 2:
		            this.family = arguments[0];
		            this.type = arguments[1];
		            break;
		    }
		}

		setInvalid(): void {
		    this.iValue = <number>EResourceCodes.INVALID_CODE;
		}

		less (pSrc: IResourceCode): bool {
		    return this.iValue < pSrc.valueOf();
		}

		eq(pSrc: IResourceCode): IResourceCode {
		    this.iValue = pSrc.valueOf();
		    return this;
		};

		valueOf():  number  {
		    return this.iValue;
		};

		toNumber():  number  {
			return this.iValue;
		}
	}


}
















module akra {

	export interface IEngine {} ;
	export interface IResourcePoolManager {} ;

	export interface IDataPool {
		manager: IResourcePoolManager;
/** Инициализация пула данных */

		initialize(iGrowSize:  number ): void;

/** Инициализирован ли пул */

		isInitialized(): bool;

/** Очистка пула и пометка о том что он больш не инициализирован */

		destroy(): void;

/** Высвобождаем элемент в пуле по его номеру */

		release(iHandle:  number ): void;
/*
		 * даление всех групп
 		 * Все группы должны быть пусты, иначе во время удаления произойдет ошибка
		 **/

		clear(): void;
/** Добавляет новый элемент в пул */

		add(pMembers: IResourcePoolItem):  number ;

/** Цикл по всем объектам с приминением к ним функции, как fFunction(текущий пул данных, объект к торому применяется); */

		forEach(fFunction: (pPool: IDataPool, iHandle:  number , pMember: IResourcePoolItem) => void): void;

/** Ищет первый свободный элемент в пуле */

		nextHandle():  number ;
/** Проверяется используется лм этот элемент */

		isHandleValid(iHandle:  number ): bool;

/** Возвратитть элемент по хендлу */

		get(iHandle:  number ): IResourcePoolItem;
/** Возвратитть элемент по хендлу */

		getPtr(iHandle:  number ): IResourcePoolItem;
/** Возвратитть элемент по хендлу */

		getGenericPtr(iHandle:  number ): IResourcePoolItem;
	}
}











module akra.core.pool {
    export class ResourcePool extends util.ReferenceCounter implements IResourcePool {
        private pManager: IResourcePoolManager = null;
/** Конструктор для создания данных в пуле ресурсов */

        private tTemplate: IResourcePoolItemType = null;
        private sExt: string = null;
        private pRegistrationCode: IResourceCode = new ResourceCode(EResourceCodes.INVALID_CODE);
/*{[index: number]: string;}*/
        private pNameMap: string[]                               = new Array();
        private pDataPool: IDataPool = null;


        /**@inline*/  get iFourcc():  number  {
            return (this.sExt.charCodeAt(3) << 24)
                      | (this.sExt.charCodeAt(2) << 16)
                      | (this.sExt.charCodeAt(1) << 8)
                      | (this.sExt.charCodeAt(0));
        }



        set iFourcc(iNewFourcc:  number ) {
            this.sExt = String.fromCharCode((iNewFourcc & 0x000000FF),
                                             (iNewFourcc & 0x0000FF00) >>> 8,
                                             (iNewFourcc & 0x00FF0000) >>> 16,
                                             (iNewFourcc & 0xFF000000) >>> 24);
        }

        /**@inline*/  get manager(): IResourcePoolManager {
            return this.pManager;
        }

        constructor (pManager: IResourcePoolManager, tTemplate: IResourcePoolItemType) {
            super();

            this.pManager = pManager;
            this.tTemplate = tTemplate;
            this.pDataPool = new DataPool(this.pManager, tTemplate);
        }

/** Добавление данного пула в менеджер ресурсво по его коду */

        registerResourcePool(pCode: IResourceCode): void {
            this.pRegistrationCode.eq(pCode);
            this.pManager.registerResourcePool(this.pRegistrationCode, this);
        }

/** Удаление данного пула в менеджер ресурсво по его коду */

        unregisterResourcePool(): void {
            this.pManager.unregisterResourcePool(this.pRegistrationCode);
            this.pRegistrationCode.setInvalid();
        }

/** По имени ресурса возвращает его хендл */

        findResourceHandle(sName: string):  number  {
// look up the name in our map
            var iNewHandle = INVALID_INDEX;

            for (var iHandle:  number  = 0; iHandle < this.pNameMap.length; ++ iHandle) {
                if (this.pNameMap[iHandle] === sName) {
                    return iHandle;
                }
            }

            return iNewHandle;
        }

/** 
         * Get resource name by handle.
         * @inline
         */

        findResourceName(iHandle:  number ): string {
            return this.pNameMap[iHandle];
        }

        setResourceName(iHandle:  number , sName: string): void {
            this.pNameMap[iHandle] = sName;
        }


        initialize(iGrowSize:  number ): void {
            this.pDataPool.initialize(iGrowSize);
        }

/** @inline */

        destroy(): void {
            this.pDataPool.destroy();
        }


        clean(): void {
            this.pDataPool.forEach(ResourcePool.callbackClean);
        }

        destroyAll(): void {
            this.pDataPool.forEach(ResourcePool.callbackDestroy);
        }

        restoreAll(): void {
            this.pDataPool.forEach(ResourcePool.callbackRestore);
        }

        disableAll(): void {
            this.pDataPool.forEach(ResourcePool.callbackDisable);
        }

/** @inline */

        isInitialized(): bool {
            return this.pDataPool.isInitialized();
        }



        createResource(sResourceName: string): IResourcePoolItem {
            var iHandle:  number  = this.internalCreateResource(sResourceName);

            if (iHandle !== INVALID_INDEX) {
                var pResource: IResourcePoolItem = this.getResource(iHandle);

                pResource.setResourcePool(this);
                pResource.setResourceHandle(iHandle);
                pResource.setResourceCode(this.pRegistrationCode);

                this.createdResource(pResource);

                return pResource;
            }

            return null;
        }

        loadResource(sResourceName: string): IResourcePoolItem {
// does the resource already exist?
            var pResource: IResourcePoolItem = this.findResource(sResourceName);

            if (pResource == null) {
// create a new resource
                pResource = this.createResource(sResourceName);

                if (pResource != null) {
// attempt to load the desired data
                    if (pResource.loadResource(sResourceName)) {
// ok!
                        return pResource;
                    }

// loading failed.
// destroy the resource we created
// destroyResource(pResource);
                    pResource.release();
                    pResource = null;
                }

            }

            return pResource;
        }

        saveResource(pResource: IResourcePoolItem): bool {
            if (pResource != null) {
// save the resource using it's own name as the file path
                return pResource.saveResource();
            }
            return false;
        }

        destroyResource(pResource: IResourcePoolItem): void {
            if (pResource != null) {
                var iReferenceCount:  number  = pResource.referenceCount();

                logger.setSourceLocation( "ResourcePool.ts" , 181 ); logger.assert(iReferenceCount == 0, "destruction of non-zero reference count!"); ;

                if (iReferenceCount <= 0) {
                    var iHandle:  number  = pResource.resourceHandle;
                    this.internalDestroyResource(iHandle);
                }
            }
        }

        findResource(sName: string): IResourcePoolItem {

// look up the name in our map
            for (var iHandle:  number  = 0; iHandle < this.pNameMap.length; ++ iHandle) {
                if (this.pNameMap[iHandle] == sName) {
                    if (iHandle != INVALID_INDEX) {
                        var pResource = this.getResource(iHandle);
                        return pResource;
                    }
                }
            }

            return null;
        }

        getResource(iHandle:  number ): IResourcePoolItem {
            var pResource: IResourcePoolItem = this.internalGetResource(iHandle);

            if (pResource != null) {
                pResource.addRef();
            }

            return pResource;
        }

        getResources(): IResourcePoolItem[] {
            var pResources: IResourcePoolItem[] = [];

            for (var iHandleResource in this.pNameMap) {
                pResources.push(this.getResource(parseInt(iHandleResource)));
            }

            return pResources;
        }


        private internalGetResource(iHandle:  number ): IResourcePoolItem {
            return this.pDataPool.getPtr(iHandle);
        }

        private internalDestroyResource(iHandle:  number ): void {
// get a pointer to the resource and call it's destruction handler
            var pResource = this.pDataPool.getPtr(iHandle);

            pResource.destroyResource();

            delete this.pNameMap[iHandle];

// free the resource slot associated with the handle
            this.pDataPool.release(iHandle);
        };

        private internalCreateResource(sResourceName: string):  number  {
            var iHandle:  number  = this.pDataPool.nextHandle();

// make sure this name is not already in use
            for (var iter in this.pNameMap) {
                logger.setSourceLocation( "ResourcePool.ts" , 248 ); logger.assert((this.pNameMap[iter] != sResourceName), "A resource with this name already exists: " + sResourceName);
                                                                                         ;
            }

// add this resource name to our map of handles
            this.pNameMap[iHandle] = sResourceName;

// get a pointer to the resource and call it's creation function
            var pResource = this.pDataPool.getPtr(iHandle);

            pResource.createResource();

            return iHandle;
        }

        private static callbackDestroy(pPool: IDataPool, iHandle:  number , pResource: IResourcePoolItem): void {
            pResource.destroyResource();
        }

        private static callbackDisable(pPool: IDataPool, iHandle:  number , pResource: IResourcePoolItem): void {
            pResource.disableResource();
        }

        private static callbackRestore(pPool: IDataPool, iHandle:  number , pResource: IResourcePoolItem): void {
            pResource.restoreResource();
        }

        private static callbackClean(pPool: IDataPool, iHandle:  number , pResource: IResourcePoolItem): void {
            if (pResource.referenceCount() == 0) {
                pPool.release(iHandle);
            }
        }

        private _iGuid: number = eval("this._iGuid || akra.sid()"); private _pUnicastSlotMap: IEventSlotMap = null; private _pBroadcastSlotList: IEventSlotListMap = null; private static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable {return ResourcePool._pEventTable; } getGuid(): number {return this._iGuid < 0? (this._iGuid = sid()): this._iGuid; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
            createdResource (pResource): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).createdResource; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pResource) : _broadcast[i].listener (_recivier, pResource) ; } } } ; ;
        ;
    }
}
















module akra.core.pool {

	export interface IGroupNumber {
		value:  number ;
	}

	export class PoolGroup {
		private pManager: IResourcePoolManager;

/** Конструктор для создания данных в группе */

		private tTemplate: IResourcePoolItemType;

/** Число свободных элементов группы */

		private iTotalOpen:  number  = 0;
/** Первый свободный элемент группы */

		private iFirstOpen:  number  = 0;
/** Колмичество элементов в группе */

		private iMaxCount:  number  = 0;

/** Список свободных элементов группы */

		private pNextOpenList:  number [] = null;
/** Массив элементов группы */

		private pMemberList: IResourcePoolItem[] = null;

		/**@inline*/  get manager(): IResourcePoolManager { return this.pManager; }

/** 
		 * Возвращает количесвто свободных мест в группе 
		 * @inline
		 */

		get totalOpen():  number  {
			return this.iTotalOpen;
		}

/** 
		 * Возвращает количесвто занятых мест в группе 
		 * @inline
		 */

		get totalUsed():  number  {
			return this.iMaxCount - this.iTotalOpen;
		}

/**
		 * Номер первого свободного элемента в группе
		 * @inline
		 */

		get firstOpen():  number  {
			return this.iFirstOpen;
		}

		constructor (pManager: IResourcePoolManager, tTemplate: IResourcePoolItemType, iMaxCount:  number ) {
			this.pManager = pManager;
			this.tTemplate = tTemplate;
			this.iMaxCount = iMaxCount;
		}

/** Создание группы, создается массив элементов, инициализирется список свободный и т.д. */

		create(): void {
			var i:  number ;

		    logger.setSourceLocation( "DataPool.ts" , 70 ); logger.assert(this.pMemberList == null && this.pNextOpenList == null, "Group has already been created"); ;

		    this.pNextOpenList = new Array(this.iMaxCount);

		    logger.setSourceLocation( "DataPool.ts" , 74 ); logger.assert(this.pNextOpenList != null, "tragic memory allocation failure!"); ;

		    this.pMemberList = new Array(this.iMaxCount);


		    for (i = 0; i < this.iMaxCount; i++) {
		        this.pMemberList[i] = new this.tTemplate(this.pManager);
		    }

		    logger.setSourceLocation( "DataPool.ts" , 83 ); logger.assert(this.pNextOpenList != null, "tragic memory allocation failure!"); ;

		    for (i = 0; i < this.iMaxCount - 1; i++) {
		        this.pNextOpenList[i] = i + 1;
		    }

		    this.pNextOpenList[i] = i;
		    this.iTotalOpen = this.iMaxCount;
		    this.iFirstOpen = 0;
		}

/**  
		 * Удаление группы: удаление массива элементов, списка совбодных элементов и т.д.
		 * Выдается ошибка если группа не пуста 
		 * */

		destroy(): void {
		    logger.setSourceLocation( "DataPool.ts" , 99 ); logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created"); ;
		    logger.setSourceLocation( "DataPool.ts" , 100 ); logger.assert(this.iTotalOpen == this.iMaxCount, "Group is not empty"); ;

		    delete this.pMemberList;
		    this.pMemberList = null;

		    delete this.pNextOpenList;
		    this.pNextOpenList = null;

		    this.iTotalOpen = 0;
		    this.iMaxCount = 0;
		}

/** Возвращает номер следующего совбодного элемента в списке, и помечает его как используемый */

		nextMember() {
		    logger.setSourceLocation( "DataPool.ts" , 114 ); logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created"); ;
		    logger.setSourceLocation( "DataPool.ts" , 115 ); logger.assert(this.iTotalOpen != null, "no open slots"); ;
//Возвращает номер первого свободного элемента в группе,
//и изменяет номер первого свободного на следующего свободного

		    var iSlot = this.iFirstOpen;
		    this.iFirstOpen = this.pNextOpenList[iSlot];
		    this.iTotalOpen --;

		    logger.setSourceLocation( "DataPool.ts" , 123 ); logger.assert(this.iFirstOpen != INVALID_INDEX, "Invalid Open Index"); ;
		    logger.setSourceLocation( "DataPool.ts" , 124 ); logger.assert(this.isOpen(iSlot), "invalid index"); ;

//помечаем что элемент который отдали является используемым
		    this.pNextOpenList[iSlot] = INVALID_INDEX;

		    return iSlot;
		}

/** Добавляем новый элемент в список */

		addMember(pMember: IResourcePoolItem):  number  {
			var iSlot:  number  = this.nextMember();
		    this.pMemberList[iSlot] = pMember;

		    return iSlot;
		}

/** Исключение элемента из списка по его номеру */

		release(iIndex:  number ): void {
			logger.setSourceLocation( "DataPool.ts" , 142 ); logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created"); ;
		    logger.setSourceLocation( "DataPool.ts" , 143 ); logger.assert(iIndex < this.iMaxCount, "invalid index"); ;
		    logger.setSourceLocation( "DataPool.ts" , 144 ); logger.assert(this.isOpen(iIndex) == false, "invalid index to release"); ;

		    this.pNextOpenList[iIndex] = this.iTotalOpen > 0 ? this.iFirstOpen : iIndex;
		    this.iTotalOpen ++;
		    this.iFirstOpen = iIndex;
		}


/** Проверить свободна ли эта ячейка в группе */

		isOpen (iIndex:  number ): bool {
		    logger.setSourceLocation( "DataPool.ts" , 154 ); logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created"); ;
		    logger.setSourceLocation( "DataPool.ts" , 155 ); logger.assert(iIndex < this.iMaxCount, "invalid index"); ;

		    return this.pNextOpenList[iIndex] != INVALID_INDEX;
		}

/** Получение элемента по его номеру */

		member(iIndex:  number ): IResourcePoolItem {
		    logger.setSourceLocation( "DataPool.ts" , 162 ); logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created"); ;
		    logger.setSourceLocation( "DataPool.ts" , 163 ); logger.assert(iIndex < this.iMaxCount, "invalid index"); ;
		    return this.pMemberList[iIndex];
		}

		memberPtr(iIndex:  number ): IResourcePoolItem {
		    logger.setSourceLocation( "DataPool.ts" , 168 ); logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created"); ;
		    logger.setSourceLocation( "DataPool.ts" , 169 ); logger.assert(iIndex < this.iMaxCount, "invalid index"); ;
		    return this.pMemberList[iIndex];
		}
	}

	export class DataPool implements IDataPool {
		private pManager: IResourcePoolManager;
		private tTemplate: IResourcePoolItemType;
		private bInitialized: bool = false;

/** Массив групп */

		private pGroupList: PoolGroup[] = null;

/** Общее число ячеек */

		private iTotalMembers:  number  = 0;
/** Количесвто свободных ячеек */

		private iTotalOpen:  number  = 0;
/** Количесвто элементов в группе */

		private iGroupCount:  number  = 0;
/**
		 * Номер элемента состоит из номер группы сдвинутого на _iIndexShift
    	 * и номера элемента в этой группе, который можно вырезать маской _iIndexMask
		 */

		private iIndexMask:  number  = 0;
/**
		 * Номер элемента состоит из номер группы сдвинутого на _iIndexShift
     	 * и номера элемента в этой группе, который можно вырезать маской _iIndexMask
		 */

		private iIndexShift:  number  = 0;


		/**@inline*/  get manager(): IResourcePoolManager { return this.pManager; }

		constructor(pManager: IResourcePoolManager, tTemplate: IResourcePoolItemType) {
			this.pManager = pManager;
			this.tTemplate = tTemplate;
		}


		initialize(iGrowSize:  number ): void {
			logger.setSourceLocation( "DataPool.ts" , 209 ); logger.assert(this.isInitialized() == false, "the cDataPool is already initialized"); ;

		    this.bInitialized = true;
		    this.iGroupCount = math.nearestPowerOfTwo(iGrowSize);
		    this.iIndexShift = math.lowestBitSet(this.iGroupCount);
		    this.iIndexShift = math.clamp(this.iIndexShift, 1, 15);
		    this.iGroupCount = 1 << this.iIndexShift;
		    this.iIndexMask = this.iGroupCount - 1;
		}


/** @inline */

		isInitialized(): bool {
			return this.bInitialized;
		}


		destroy(): void {
			this.clear();
    		this.bInitialized = false;
		}


		release(iHandle:  number ): void {
			logger.setSourceLocation( "DataPool.ts" , 233 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); ;

		    if (this.isHandleValid(iHandle) == true) {
		        logger.setSourceLocation( "DataPool.ts" , 236 ); logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created"); ;

		        var iGroupIndex:  number  = this.getGroupNumber(iHandle);
		        var iItemIndex:  number  = this.getItemIndex(iHandle);

		        var pGroup: PoolGroup = this.getGroup(iGroupIndex);
		        pGroup.release(iItemIndex);
		        var pGroupBack: PoolGroup = this.pGroupList[this.pGroupList.length - 1];

		        if (pGroupBack.totalOpen == this.iGroupCount) {
		            pGroupBack.destroy();
		            this.pGroupList.splice(this.pGroupList.length - 1, 1);
		        }

		        this.iTotalOpen ++;
		    }
		}

		clear(): void {
// destroy all groups in the list
		    for (var iGroupIter:  number  = 0; iGroupIter < this.pGroupList.length; ++ iGroupIter) {
		        this.pGroupList[iGroupIter].destroy();
		    }

// now clear the list itself
		    this.pGroupList.clear();
		}

		add(pMembers: IResourcePoolItem):  number  {
			logger.setSourceLocation( "DataPool.ts" , 265 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); ;

		    var iGroupNumber: IGroupNumber = {value: 0};

		    var pOpenGroup: PoolGroup = this.findOpenGroup(iGroupNumber);
		    var iIndex:  number  = pOpenGroup.addMember(pMembers);

		    this.iTotalOpen --;

		    return this.buildHandle(iGroupNumber.value, iIndex);
		}

		forEach(fFunction: (pPool: IDataPool, iHandle:  number , pMember: IResourcePoolItem) => void): void {
			logger.setSourceLocation( "DataPool.ts" , 278 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); ;
// iterate through every group

		    var iGroupNumber:  number  = 0;
		    for (var iGroupIter:  number  = 0; iGroupIter < this.pGroupList.length; iGroupIter++) {

		        var nCallbackCount:  number  = this.pGroupList[iGroupIter].totalUsed;
		        var iItemIndex:  number  = 0;

		        while (nCallbackCount != 0 && iItemIndex < this.iGroupCount) {
		            if (this.pGroupList[iGroupIter].isOpen(iItemIndex) == false) {
		                fFunction(
		                	this,
		                	this.buildHandle(iGroupNumber, iItemIndex),
		                	this.pGroupList[iGroupIter].member(iItemIndex)
		                	);
		                nCallbackCount--;
		            }

		            ++iItemIndex;
		        }

		        ++iGroupNumber;
		    }
		}

		nextHandle():  number  {
			logger.setSourceLocation( "DataPool.ts" , 305 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); ;

		    var iGroupNumber: IGroupNumber = {value: 0};
		    var pOpenGroup: PoolGroup = this.findOpenGroup(iGroupNumber);
		    var iIndex:  number  = pOpenGroup.nextMember();

		    this.iTotalOpen --;

		    return this.buildHandle(iGroupNumber.value, iIndex);
		}

		isHandleValid(iHandle:  number ): bool {
			logger.setSourceLocation( "DataPool.ts" , 317 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); ;

		    if (iHandle !== INVALID_INDEX) {
		        logger.setSourceLocation( "DataPool.ts" , 320 ); logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created"); ;

		        var pGroup: PoolGroup = this.getGroup(this.getGroupNumber(iHandle));

		        return !pGroup.isOpen(this.getItemIndex(iHandle));
		    }

		    return false;
		}

		get(iHandle:  number ): IResourcePoolItem {
			logger.setSourceLocation( "DataPool.ts" , 331 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); ;
		    logger.setSourceLocation( "DataPool.ts" , 332 ); logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created"); ;

		    var pGroup: PoolGroup = this.getGroup(this.getGroupNumber(iHandle));
		    var iItemIndex:  number  = this.getItemIndex(iHandle);

		    return pGroup.member(iItemIndex);
		}

		getPtr(iHandle:  number ): IResourcePoolItem {
			logger.setSourceLocation( "DataPool.ts" , 341 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); ;
		    logger.setSourceLocation( "DataPool.ts" , 342 ); logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created"); ;

		    var pGroup: PoolGroup = this.getGroup(this.getGroupNumber(iHandle));
		    var iItemIndex:  number  = this.getItemIndex(iHandle);

		    return pGroup.memberPtr(iItemIndex);
		}

		getGenericPtr(iHandle:  number ): IResourcePoolItem {
			logger.setSourceLocation( "DataPool.ts" , 351 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); ;

    		return this.getPtr(iHandle);
		}


/** 
		 * @inline 
		 * Получение номера группы по номеру элемента
		 */

		private getGroupNumber(iHandle:  number ):  number  {
			return iHandle >> this.iIndexShift;
		}

/** 
		 * @inline 
		 * Получение номера элеменат в группе по его номеру
		 */

		private getItemIndex(iHandle:  number ):  number  {
			return iHandle & this.iIndexMask;
		}

/** 
		 * @inline 
		 * Полученяи номера элеменат по его номеру группы и группе
		 */

		private buildHandle(iGroup, iIndex):  number  {
			return (iGroup << this.iIndexShift) + iIndex;
		}

/** Добавление группы в пул */

		private addGroup(): PoolGroup {
// append a new group to the list to start things off
		    var pNewGroup: PoolGroup = new PoolGroup(this.pManager, this.tTemplate, this.iGroupCount);
		    this.pGroupList.push(pNewGroup);
// gain access to the new group and innitialize it
		    pNewGroup.create();
// increment our internal counters
		    this.iTotalMembers += this.iGroupCount;
		    this.iTotalOpen += this.iGroupCount;

		    return pNewGroup;
		}

/** Поиск первой группы которая имеет свободную область */

		private findOpenGroup(pGroupNumber: IGroupNumber): PoolGroup {
			pGroupNumber.value = 0;

//найдем и вренем первую группу имеющую свободную группу
		    for (var iGroupIter:  number  = 0; iGroupIter < this.pGroupList.length; iGroupIter++) {
		        if (this.pGroupList[iGroupIter].totalOpen > 0) {
		            return this.pGroupList[iGroupIter];
		        }

		        pGroupNumber.value ++;
		    }

//свободных областей нет, поэтому мы должны добавить новую группу в пул,
//но пержде чем содавать убедимся что не достигли максимума

		    logger.setSourceLocation( "DataPool.ts" , 411 ); logger.assert((this.pGroupList.length + 1) < MAX_UINT16, "the cDataPool is full!!!!"); ;
//добавим новую группу

		    return this.addGroup();
		}

/** 
		 * @inline 
		 * Возвращает группу по ее номеру
		 */

		private getGroup(iIndex:  number ): PoolGroup {
			logger.setSourceLocation( "DataPool.ts" , 422 ); logger.assert(iIndex < this.pGroupList.length, "Invalid group index requested"); ;
    		return this.pGroupList[iIndex];
		}


	}
}














module akra {

	export interface IEffect {} ;
	export interface ISurfaceMaterial {} ;

	export interface IRenderMethod extends IResourcePoolItem {
		effect: IEffect;
		surfaceMaterial: ISurfaceMaterial;

		isEqual(pRenderMethod: IRenderMethod): bool;
	}
}





















module akra {
	export interface IResourceNotifyRoutineFunc {
		(iFlagBit?:  number , iResourceFlags?:  number , isSet?: bool): void;
		(eEvent?: EResourceItemEvents, iResourceFlags?:  number , isSet?: bool): void;
	}
}









module akra.core.pool {

	export interface ICallbackSlot {
		bState: bool;
		fn: IResourceNotifyRoutineFunc;
		pResourceItem: IResourcePoolItem;
	}

	export class ResourcePoolItem extends util.ReferenceCounter implements IResourcePoolItem {
//private pManager: IResourcePoolManager;
		private pResourceCode: IResourceCode;
		private pResourcePool: IResourcePool = null;
		private iResourceHandle:  number  = 0;
		private iResourceFlags:  number  = 0;
		private pCallbackFunctions: IResourceNotifyRoutineFunc[];
		private pStateWatcher: IResourceWatcherFunc[];
		private pCallbackSlots: ICallbackSlot[][];


		/**@inline*/  get resourceCode(): IResourceCode {
			return this.pResourceCode;
		}

		/**@inline*/  get resourcePool(): IResourcePool {
			return this.pResourcePool;
		}

		/**@inline*/  get resourceHandle():  number  {
			return this.iResourceHandle;
		}

		/**@inline*/  get resourceFlags():  number  {
			return this.iResourceFlags;
		}

		/**@inline*/  get alteredFlag(): bool {
			return bf.testBit(this.iResourceFlags, <number>EResourceItemEvents.ALTERED);
		}

		/**@inline*/  get manager(): IResourcePoolManager { return this.getManager(); }

/** Constructor of ResourcePoolItem class */

/*pManager: IResourcePoolManager*/
		constructor (                                  ) {
			super();

//this.pManager = pManager;
			this.pResourceCode = new ResourceCode(0);
			this.pCallbackFunctions = [];
			this.pStateWatcher = [];
			this.pCallbackSlots = genArray(null, <number>EResourceItemEvents.TOTALRESOURCEFLAGS);
		}

		/**@inline*/  getEngine(): IEngine {
			var pManager: IResourcePoolManager = this.getManager();

			if (pManager) {
				return pManager.getEngine();
			}

			return null;
		}

		/**@inline*/  getManager(): IResourcePoolManager {
			return this.pResourcePool? this.pResourcePool.manager: null;
		}

		createResource(): bool {
			return false;
		}

		destroyResource(): bool {
			return false;
		}

		disableResource(): bool {
			return false;
		}

		restoreResource(): bool {
			return false;
		}

		loadResource(sFilename: string = null): bool {
			return false;
		}

		saveResource(sFilename: string = null): bool {
			return false;
		}


		setChangesNotifyRoutine(fn: IResourceNotifyRoutineFunc): void {
			for (var i:  number  = 0; i < this.pCallbackFunctions.length; i ++) {

			    if (this.pCallbackFunctions[i] == fn) {
			        return;
			    }
			}

			this.pCallbackFunctions.push(fn);
		}

		delChangesNotifyRoutine(fn: IResourceNotifyRoutineFunc): void {
			for (var i:  number  = 0; i < this.pCallbackFunctions.length; i ++) {
		        if (this.pCallbackFunctions[i] == fn) {
		            this.pCallbackFunctions[i] = null;
		        }
		    }
		}

		setStateWatcher(eEvent: EResourceItemEvents, fnWatcher: IResourceWatcherFunc): void {
			this.pStateWatcher[eEvent] = fnWatcher;
		}

		sync(pResourceItem: IResourcePoolItem, eSignal: EResourceItemEvents, eSlot?: EResourceItemEvents): bool {
			eSlot = isDef(eSlot)? eSlot: eSignal;

		    eSlot = ResourcePoolItem.parseEvent(<number>eSlot);
		    eSignal = ResourcePoolItem.parseEvent(<number>eSignal);

		    var pSlots: ICallbackSlot[][] = this.pCallbackSlots, pSignSlots: ICallbackSlot[];

		    var me: IResourcePoolItem = this;
		    var n:  number ;
		    var fn: IResourceNotifyRoutineFunc;
		    var bState: bool;

		    if (isNull(pSlots[eSlot])) {
		        pSlots[eSlot] = [];
		    }

		    pSignSlots = pSlots[eSlot];
		    n = pSignSlots.length;
		    bState = bf.testBit(pResourceItem.resourceFlags, <number>eSignal);

		    fn = function (eFlag?: EResourceItemEvents, iResourceFlags?:  number , isSet?: bool) {
		        if (eFlag == <number>eSignal) {
		            pSignSlots[n].bState = isSet;
		            me.notifyStateChange(eSlot, this);

		            for (var i:  number  = 0; i < pSignSlots.length; ++i) {
		                if (pSignSlots[i].bState === false) {
		                    if (bf.testBit(me.resourceFlags, <number>eFlag)) {
		                        me.setResourceFlag(eFlag, false);
		                    }
		                    return;
		                }
		            }

		            me.setResourceFlag(eFlag, true);
		        }
		    };

		    pSignSlots.push({bState : bState, fn : fn, pResourceItem : pResourceItem});

		    fn.call(pResourceItem, eSignal, pResourceItem.resourceFlags, bState);
		    pResourceItem.setChangesNotifyRoutine(fn);

		    return true;
		}

		unsync(pResourceItem: IResourcePoolItem, eSignal: EResourceItemEvents, eSlot?: EResourceItemEvents): bool {
			eSlot = isDef(eSlot)? eSlot: eSignal;
		    eSlot = ResourcePoolItem.parseEvent(<number>eSlot);
		    eSignal = ResourcePoolItem.parseEvent(<number>eSignal);

		    var pSlots: ICallbackSlot[][] = this.pCallbackSlots, pSignSlots: ICallbackSlot[];
		    var me: IResourcePoolItem = this;
		    var isRem: bool = false;

		    pSignSlots = pSlots[eSlot];


		    for (var i:  number  = 0, n:  number  = pSignSlots.length; i < n; ++i) {
		        if (pSignSlots[i].pResourceItem === pResourceItem) {
		            pSignSlots[i].pResourceItem.delChangesNotifyRoutine(pSignSlots[i].fn);
		            pSignSlots.splice(i, 1);

		            --n;
		            --i;

		            isRem = true;
		        }
		    }

		    return isRem;
		}


		/**@inline*/  isResourceCreated(): bool {
			return bf.testBit(this.iResourceFlags, <number>EResourceItemEvents.CREATED);
		}

		/**@inline*/  isResourceLoaded(): bool {
			return bf.testBit(this.iResourceFlags, <number>EResourceItemEvents.LOADED);
		}

		/**@inline*/  isResourceDisabled(): bool {
			return bf.testBit(this.iResourceFlags, <number>EResourceItemEvents.DISABLED);
		}

		/**@inline*/  isResourceAltered(): bool {
			return bf.testBit(this.iResourceFlags, <number>EResourceItemEvents.ALTERED );
		}

		setAlteredFlag(isOn: bool = true): bool {
//notify always, when altered called
    		if (this.setResourceFlag(EResourceItemEvents.ALTERED, isOn) || isOn) {
    			isOn? this.altered(): this.saved();
    			return true;
    		}

    		return false;
		}

		/**@inline*/  setResourceName(sName: string) {
			if (this.pResourcePool != null) {
		        this.pResourcePool.setResourceName(this.iResourceHandle, sName);
		    }
		}

		findResourceName(): string {
			if (this.pResourcePool != null) {
		        return this.pResourcePool.findResourceName(this.iResourceHandle);
		    }

		    return null;
		}

		release():  number  {
			var iRefCount = super.release();

		    if (iRefCount == 0) {
//Если у нас есть менеджер попросим его удалить нас
		        if (this.pResourcePool != null) {
		            this.pResourcePool.destroyResource(this);
		        }
		    }

		    return iRefCount;
		}
		/**@inline*/  notifyCreated(): void {
			if (this.setResourceFlag(EResourceItemEvents.CREATED, true)) {
				this.created();
			}
		}

		/**@inline*/  notifyDestroyed(): void {
			if (this.setResourceFlag(EResourceItemEvents.CREATED, false)) {
				this.destroyed();
			}
		}

		/**@inline*/  notifyLoaded(): void {
			this.setAlteredFlag(false);
    		if (this.setResourceFlag(EResourceItemEvents.LOADED, true)) {
    			this.loaded();
    		}
		}

		/**@inline*/  notifyUnloaded(): void {
			if (this.setResourceFlag(EResourceItemEvents.LOADED, false)) {
				this.unloaded();
			}
		}

		/**@inline*/  notifyRestored(): void {
			if (this.setResourceFlag(EResourceItemEvents.DISABLED, false)) {
				this.restored();
			}
		}

		/**@inline*/  notifyDisabled(): void {
			if (this.setResourceFlag(EResourceItemEvents.DISABLED, true)) {
				this.disabled();
			}
		}

		/**@inline*/  notifyAltered(): void {
			this.setAlteredFlag(true);
		}

		/**@inline*/  notifySaved(): void {
			this.setAlteredFlag(false);
		}

/**
		 * Назначение кода ресурсу
		 * @inline
		 */

		setResourceCode(pCode: IResourceCode): void {
			this.pResourceCode.eq(pCode);
		}

/**
		 * Чтобы ресурс знал какому пулу ресурсов принадлжит
		 * @inline
		 */

		setResourcePool(pPool: IResourcePool): void {
			this.pResourcePool = pPool;
		}

/**
		 * Назначение хендла ресурсу
		 * @inline
		 */

		setResourceHandle(iHandle:  number ): void {
			this.iResourceHandle = iHandle;
		}

		notifyStateChange(eEvent: EResourceItemEvents, pTarget: IResourcePoolItem = null): void {
			if (!this.pStateWatcher[eEvent]) {
		        return;
		    }

		    var pSignSlots: ICallbackSlot[]  = this.pCallbackSlots[eEvent];
		    var nTotal:  number  = pSignSlots.length, nLoaded:  number  = 0;

		    for (var i:  number  = 0; i < nTotal; ++i) {
		        if (pSignSlots[i].bState) {
		            ++ nLoaded;
		        }
		    }

		    this.pStateWatcher[eEvent](nLoaded, nTotal, pTarget);
		}

		setResourceFlag(eFlagBit: EResourceItemEvents, isSetting: bool): bool;
		setResourceFlag(iFlagBit:  number , isSetting: bool): bool;
		setResourceFlag(iFlagBit, isSetting: bool): bool {
			var iTempFlags:  number  = this.iResourceFlags;

		    bf.setBit(this.iResourceFlags, iFlagBit, isSetting);

		    if (iTempFlags != this.iResourceFlags) {
		        for (var i:  number  = 0; i < this.pCallbackFunctions.length; i++) {
		            if (this.pCallbackFunctions[i]) {
		                this.pCallbackFunctions[i].call(this, iFlagBit, this.iResourceFlags, isSetting);
		            }
		        }
		        return true;
		    }

		    return false;
		}

		static private parseEvent(sEvent: string): EResourceItemEvents;
		static private parseEvent(iEvent:  number ): EResourceItemEvents;
		static private parseEvent(pEvent) {
		 	if (isInt(pEvent)) {
		        return <EResourceItemEvents>pEvent;
		    }

		    switch (pEvent.toLowerCase()) {
		        case 'loaded':
		            return EResourceItemEvents.LOADED;
		        case 'created':
		            return EResourceItemEvents.CREATED;
		        case 'disabled':
		            return EResourceItemEvents.DISABLED;
		        case 'altered':
		            return EResourceItemEvents.ALTERED;
		        default:
		            logger.setSourceLocation( "../ResourcePoolItem.ts" , 377 ); logger.error('Использовано неизвестное событие для ресурса.'); ;
		            return 0;
		    }
		}


		private _iGuid: number = eval("this._iGuid || akra.sid()"); private _pUnicastSlotMap: IEventSlotMap = null; private _pBroadcastSlotList: IEventSlotListMap = null; private static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable {return ResourcePoolItem._pEventTable; } getGuid(): number {return this._iGuid < 0? (this._iGuid = sid()): this._iGuid; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
			created (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).created; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
			destroyed (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).destroyed; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
			loaded (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).loaded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
			unloaded (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).unloaded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
			restored (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).restored; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
			disabled (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).disabled; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
			altered (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).altered; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
			saved (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).saved; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		;
	}

}



module akra.core.pool.resources {
	export class RenderMethod extends ResourcePoolItem implements IRenderMethod {
		effect: IEffect;
		surfaceMaterial: ISurfaceMaterial;

		isEqual(pRenderMethod: IRenderMethod): bool {return false;}
	}


}










module akra {
	export interface IMaterial {} ;
	export interface ITexture {} ;

	export enum ESurfaceMaterialTextures {
		TEXTURE0 = 0,
        TEXTURE1,
        TEXTURE2,
        TEXTURE3,
        TEXTURE4,
        TEXTURE5,
        TEXTURE6,
        TEXTURE7,
        TEXTURE8,
        TEXTURE9,
        TEXTURE10,
        TEXTURE11,
        TEXTURE12,
        TEXTURE13,
        TEXTURE14,
        TEXTURE15,
        DIFFUSE = TEXTURE0,
        AMBIENT,
        SPECULAR,
        EMISSIVE,
        EMISSION = EMISSIVE
	};



    export interface ISurfaceMaterial extends IResourcePoolItem {
    	totalTextures:  number ;
    	material: IMaterial;
    	textureFlags:  number ;
    	textureMatrixFlags:  number ;

        setTexture(iIndex:  number , sTexture: string, iTexcoord?:  number ): bool;
        setTexture(iIndex:  number , iTextureHandle:  number , iTexcoord?:  number ): bool;
    	setTexture(iIndex:  number , pTexture: ITexture, iTexcoord?:  number ): bool;
    	setTextureMatrix(iIndex:  number , m4fValue: IMat4): bool;
    	setMaterial(pMaterial: IMaterial): void;
    	isEqual(pSurface: ISurfaceMaterial): bool;

    	texture(iSlot:  number ): ITexture;
    	texcoord(iSlot:  number ):  number ;
    	textureMatrix(iSlot:  number ): IMat4;
    }

}













module akra {
	export interface IVertexData {} ;

	export interface IMaterialBase {
		diffuse: IColorValue;
		ambient: IColorValue;
		specular: IColorValue;
		emissive: IColorValue;
		shininess:  number ;
	}

	export interface IMaterial extends IMaterialBase {
		name: string;

		set(pMat: IMaterialBase): IMaterial;
		isEqual(pMat: IMaterialBase): bool;
	}

	export interface IFlexMaterial extends IMaterial {
		data: IVertexData;
	}

// export interface IMaterialEx extends IMaterial {
// 	reflective: 
// 	reflectivity
// 	transparent
// 	transparency
// 	indexofrefraction
// }
}











module akra {

	export interface IVertexElement {} ;

	export  /**@const*/var  DeclarationUsages = {
		POSITION 	: "POSITION",
	    POSITION1	: "POSITION1",
	    POSITION2	: "POSITION2",
	    POSITION3	: "POSITION3",

	    BLENDWEIGHT	: "BLENDWEIGHT",
	    BLENDINDICES: "BLENDINDICES",
	    BLENDMETA	: "BLENDMETA",

	    NORMAL 		: "NORMAL",
	    NORMAL1		: "NORMAL1",
	    NORMAL2		: "NORMAL2",
	    NORMAL3		: "NORMAL3",

	    PSIZE		: "PSIZE",

	    TEXCOORD 	: "TEXCOORD",
	    TEXCOORD1	: "TEXCOORD1",
	    TEXCOORD2	: "TEXCOORD2",
	    TEXCOORD3	: "TEXCOORD3",
	    TEXCOORD4	: "TEXCOORD4",
	    TEXCOORD5	: "TEXCOORD5",

	    TANGENT		: "TANGENT",
	    BINORMAL 	: "BINORMAL",

	    TESSFACTOR	: "TESSFACTOR",
	    COLOR 		: "COLOR",
	    FOG 		: "FOG",
	    DEPTH 		: "DEPTH",
	    SAMPLE 		: "SAMPLE",

	    INDEX 		: "INDEX",
		INDEX0 		: "INDEX0",
	    INDEX1 		: "INDEX1",
	    INDEX2 		: "INDEX2",
	    INDEX3 		: "INDEX3",
//system indices starts from 10
	    INDEX10 	: "INDEX10",
	    INDEX11 	: "INDEX11",
	    INDEX12 	: "INDEX12",
	    INDEX13 	: "INDEX13",

	    MATERIAL 	: "MATERIAL",
	    MATERIAL1 	: "MATERIAL1",
	    MATERIAL2 	: "MATERIAL2",

	    DIFFUSE		: "DIFFUSE",
	    AMBIENT 	: "AMBIENT",
	    SPECULAR 	: "SPECULAR",
	    EMISSIVE 	: "EMISSIVE",
	    SHININESS 	: "SHININESS",
	    UNKNOWN 	: "UNKNOWN",
	    END 		: "\a\n\r"
	};

	export  /**@const*/var  DeclUsages = DeclarationUsages;

	export interface IVertexDeclaration {
		stride:  number ;
		length:  number ;


//[index: number]: IVertexElement;

		append(...pElement: IVertexElementInterface[]): bool;
		append(pElements: IVertexElementInterface[]): bool;

		extend(pDecl: IVertexDeclaration): bool;

		hasSemantics(sSemantics: string): bool;
		findElement(sSemantics: string, iCount?:  number ): IVertexElement;
		clone(): IVertexDeclaration;

		element(i:  number ): IVertexElement;

		_update(): bool;

///DEBUG!!!
		toString(): string;
	}



	export function VE_CUSTOM(sUsage: string, eType: EDataTypes = EDataTypes.FLOAT, iCount:  number  = 1, iOffset?:  number ): IVertexElementInterface {
		return {count: iCount, type: eType, usage: sUsage, offset: iOffset};
	}

	export function VE_FLOAT(sName: string, iOffset?:  number ): IVertexElementInterface { return VE_CUSTOM(sName, EDataTypes.FLOAT, 1, iOffset); };
	export function VE_FLOAT2(sName: string, iOffset:  number  = 2): IVertexElementInterface { return VE_CUSTOM(sName, EDataTypes.FLOAT, 2, iOffset); };
	export function VE_FLOAT3(sName: string, iOffset:  number  = 3): IVertexElementInterface { return VE_CUSTOM(sName, EDataTypes.FLOAT, 3, iOffset); };
	export function VE_FLOAT4(sName: string, iOffset:  number  = 4): IVertexElementInterface { return VE_CUSTOM(sName, EDataTypes.FLOAT, 4, iOffset); };
	export function VE_FLOAT4x4(sName: string, iOffset:  number  = 16): IVertexElementInterface { return VE_CUSTOM(sName, EDataTypes.FLOAT, 16, iOffset); };
	export function VE_VEC2(sName: string, iOffset:  number  = 2): IVertexElementInterface { return VE_CUSTOM(sName, EDataTypes.FLOAT, 2, iOffset); };
	export function VE_VEC3(sName: string, iOffset:  number  = 3): IVertexElementInterface { return VE_CUSTOM(sName, EDataTypes.FLOAT, 3, iOffset); };
	export function VE_VEC4(sName: string, iOffset:  number  = 4): IVertexElementInterface { return VE_CUSTOM(sName, EDataTypes.FLOAT, 4, iOffset); };
	export function VE_MAT4(sName: string, iOffset:  number  = 16): IVertexElementInterface { return VE_CUSTOM(sName, EDataTypes.FLOAT, 16, iOffset); };
	export function VE_INT(sName: string, iOffset:  number ): IVertexElementInterface { return VE_CUSTOM(sName, EDataTypes.INT, 1, iOffset);};

	export function VE_END(iOffset:  number  = 0): IVertexElementInterface { return VE_CUSTOM(DeclUsages.END, EDataTypes.UNSIGNED_BYTE, 0, iOffset); };

	export var createVertexDeclaration: (pData?) => IVertexDeclaration;
}












module akra {
	export interface IVertexElementInterface {
/**
		 * Number of uint.
		 */

		count:  number ;
/**
		 * Type of units. 
		 */

		type: EDataTypes;
/**
		 * Usage of element.
		 * For ex., basicly for vertices is 'POSITION'.
		 */

		usage: string;
/**
		 * Offset in bytes.
		 */

		offset?:  number ;
	}

	export interface IVertexElement extends IVertexElementInterface {
/**
		 * Size in bytes.
		 */

		size:  number ;
/**
		 * numerical index of declaration. 
		 * For ex. for usage INDEX10, index is 10, semantics is 'INDEX'.
		 */

		index:  number ;
/**
		 * Semantics of declaration.
		 * @see DelcarationUsages.
		 */

		semantics: string;

		clone(): IVertexElement;

//DEBUG!!
		toString(): string;
	}
}




module akra.data {
	export class VertexElement implements IVertexElement {
		count:  number ;
		type: EDataTypes;
		usage: string;
		offset:  number ;

// this properties is readonly for public usage.
		size:  number  = 0;
		index:  number  = 0;
		semantics: string = DeclarationUsages.UNKNOWN;

		constructor (
			nCount:  number  = 1,
			eType: EDataTypes = EDataTypes.FLOAT,
			eUsage: string = DeclarationUsages.POSITION,
//mark invalid offset, for determine true offset in VertexDeclaration::_update();
			iOffset:  number  = MAX_INT32) {

			this.count = nCount;
			this.type = eType;
			this.usage = eUsage;
			this.offset = iOffset;

			this.update();
		}

		private update(): void {
			this.size = this.count * getTypeSize(this.type);
		    this.index = 0;
		    this.semantics = null;

		    var pMatches: string[] = this.usage.match(/^(.*?\w)(\d+)$/i);

		    if (!isNull(pMatches)) {
		        this.semantics = pMatches[1];
		        this.index = parseInt(pMatches[2]);

// To avoid the colosseum between the "usage" of the element as POSITION & POSITION0, 
// given that this is the same thing, here are the elements with index 0 
// for "usage" with the POSITION.
		        if (this.index === 0) {
		        	this.usage = this.semantics;
		        }
		    }
		    else {
		        this.semantics = this.usage;
		    }
		}

		clone(): IVertexElement {
			return new VertexElement(this.count, this.type, this.usage, this.offset);
		}

		/**@inline*/  static hasUnknownOffset(pElement: IVertexElementInterface): bool {
			return pElement.offset === MAX_INT32;
		}

		toString(): string {

			function _an(data: any, n:  number , bBackward: bool = false): string {
		        var s: string = String(data);

		        for (var i = 0, t = n - s.length; i < t; ++ i) {
		            if (bBackward) {
		                s = " " + s;
		            }
		            else {
		                s += " ";
		            }
		        }
		        return s;
		    }

		    var s = "[ USAGE: " + _an(this.usage, 12) + ", OFFSET " + _an(this.offset, 4) + " ]";

		    return s;

		}
	}
}

module akra {
	export var VertexElement = VertexElement;
}



module akra.data {

	export class VertexDeclaration implements IVertexDeclaration {
//readonly property for public usage
		stride:  number  = 0;

		private _pElements: IVertexElement[] = [];

		/**@inline*/  get length():  number  {
			return this._pElements.length;
		}

//FIXME: typescript error "Overload signature is not compatible with function definition" ???
//constructor (...pElement: IVertexElement[]) 
		constructor (...pElements: IVertexElementInterface[]);
		constructor (pElements: IVertexElementInterface[]);
		constructor (pElements: any) {
			if (arguments.length > 0) {
				this.append.apply(this, arguments);
			}
		}

		/**@inline*/  element(i:  number ): IVertexElement {
			return this._pElements[i] || null;
		}

		append(...pElement: IVertexElementInterface[]): bool;
		append(pElements: IVertexElementInterface[]): bool;
		append(pData: any) {
			var iOffset:  number ;
			var pElements: IVertexElementInterface[];

			if (!isArray(arguments[0])) {
				pElements = <IVertexElementInterface[]><any>arguments;
			}
			else {
				pElements = <IVertexElementInterface[]><any>arguments[0];
			}

			for (var i:  number  = 0; i < pElements.length; ++ i) {
				iOffset = pElements[i].offset;

				if (VertexElement.hasUnknownOffset(pElements[i])) {
//calculation offset
					if (i > 0) {
						iOffset = this._pElements[i - 1].offset + this._pElements[i - 1].size;
					}
					else {
						iOffset = 0;
					}
				}

				this._pElements.push(new VertexElement(
					pElements[i].count,
		            pElements[i].type,
		            pElements[i].usage,
		            iOffset));
			}

			return this._update();
		}

		_update(): bool {
			var iStride:  number ;

			for (var i:  number  = 0; i < this.length; ++ i) {
//move "END" element to end of declaration
				if (this._pElements[i].usage === DeclUsages.END) {
		            this._pElements.swap(i, i + 1);
		        }

//recalc total stride
		        iStride = this._pElements[i].size + this._pElements[i].offset;

		        if (this.stride < iStride) {
		            this.stride = iStride
		        }
			}

			var pLast: IVertexElement = this._pElements.last;

		    if (pLast.usage === DeclUsages.END && pLast.offset < this.stride) {
		        pLast.offset = this.stride;
		    }

		    return true;
		}



		extend(pDecl: IVertexDeclaration): bool {
			var pElement: IVertexElement;

		    for (var i = 0; i < this.length; ++ i) {
		        for (var j = 0; j < pDecl.length; ++ j) {
		            if (pDecl.element(j).usage == this._pElements[i].usage) {
		                logger.setSourceLocation( "data/VertexDeclaration.ts" , 103 ); logger.log('inconsistent declarations:', this, pDecl); ;
		                logger.setSourceLocation( "data/VertexDeclaration.ts" , 104 ); logger.error('The attempt to combine the declaration containing the exact same semantics.'); ;
		                return false;
		            }
		        }
		    }

		    for (var i = 0; i < pDecl.length; i++) {
		        pElement = pDecl.element(i).clone();
		        pElement.offset += this.stride;
		        this._pElements.push(pElement);
		    }

		    return this._update();
		}

		/**@inline*/  hasSemantics(sSemantics: string): bool {
			return this.findElement(sSemantics) !== null;
		}

		findElement(sSemantics: string, iCount:  number  = MAX_INT32): IVertexElement {
			sSemantics = sSemantics.toUpperCase();

			for (var i = 0; i < this.length; ++i) {
				if (this._pElements[i].usage === sSemantics && (iCount === MAX_INT32 || this._pElements[i].count == iCount)) {
					return this._pElements[i];
				}
			}

			return null;
		}

		clone(): IVertexDeclaration {
			var pElements: IVertexElement[] = [];
			var pDecl: IVertexDeclaration;

		    for (var i = 0; i < this.length; ++ i) {
		        pElements.push(this._pElements[i].clone());
		    }

		    pDecl = new VertexDeclaration(pElements);

		    if (pDecl._update()) {
		    	return pDecl;
		    }

		    return null;
		}

///DEBUG!!!
		toString(): string {

			var s = "";

	    	s += "  VERTEX DECLARATION ( " + this.stride +" b. ) \n";
		    s += "---------------------------------------\n";

		    for (var i = 0; i < this.length; ++ i) {
		        s += this._pElements[i].toString() + '\n';
		    }

		    return s;

		}
	}
}

module akra {
	export var VertexDeclaration = data.VertexDeclaration;

	createVertexDeclaration = function (pData?): IVertexDeclaration {
		if (!(pData instanceof VertexDeclaration)) {
	        if (!(pData instanceof Array)) {
	            pData = [pData];
	        }

	        pData = new VertexDeclaration(pData);
	    }

	    return pData;
	}

}














module akra {

	export interface IColorIValue {
		r:  number ;
		g:  number ;
		b:  number ;
		a:  number ;
	}

	export interface IColorValue {
		r:  number ;
		g:  number ;
		b:  number ;
		a:  number ;
	}
}



module akra {

	export interface IColor extends IColorValue {
		rgba:  number ;
		argb:  number ;
		bgra:  number ;
		abgr:  number ;

		set(cColor: IColorValue): IColor;
		set(cColor: IColor): IColor;
		set(r?:  number , g?:  number , b?:  number , a?:  number ): IColor;
		set(fGray:  number , fAlpha:  number ): IColor;

/** Clamps colour value to the range [0, 1].
         */

        saturate(): void;

/** As saturate, except that this colour value is unaffected and
		    the saturated colour value is returned as a copy. */

		saturateCopy(): IColor;

		add(cColor: IColor, ppDest?: IColor): IColor;
		subtract(cColor: IColor, ppDest?: IColor): IColor;
		multiply(cColor: IColor, ppDest?: IColor): IColor;
		multiply(fScalar:  number , ppDest?: IColor): IColor;
		divide(cColor: IColor, ppDest?: IColor): IColor;
		divide(fScalar:  number , ppDest?: IColor): IColor;

/** Set a colour value from Hue, Saturation and Brightness.
			@param hue Hue value, scaled to the [0,1] range as opposed to the 0-360
			@param saturation Saturation level, [0,1]
			@param brightness Brightness level, [0,1]
		*/

		setHSB(fHue:  number , fSaturation:  number , fBrightness:  number ): IColor;

/** Convert the current colour to Hue, Saturation and Brightness values. 
			@param hue Output hue value, scaled to the [0,1] range as opposed to the 0-360
			@param saturation Output saturation level, [0,1]
			@param brightness Output brightness level, [0,1]
		*/


		getHSB(pHsb?:  number []):  number [];

		toString(): string;
	}
}



module akra.util {

	export class Color implements IColor {
		r:  number ;
		g:  number ;
		b:  number ;
		a:  number ;

		constructor ();
		constructor (cColor: IColor);
		constructor (pData: ArrayBufferView);
		constructor (r:  number , g:  number , b:  number , a:  number );
		constructor (r:  number , g:  number , b:  number );
		constructor (fGray:  number , fAlpha:  number );
		constructor (fGray:  number );
		constructor (r?: any, g?: any, b?: any, a?: any) {
			this.set.apply(this, arguments);
		}

		get rgba():  number  {
			var val32:  number  = 0;
// Convert to 32bit pattern
	        val32 = < number >(this.a * 255) << 24;
	        val32 += < number >(this.b * 255) << 16;
	        val32 += < number >(this.g * 255) << 8;
	        val32 += < number >(this.r * 255);

	        return val32;
		}

		get argb():  number  {
			var val32:  number  = 0;
// Convert to 32bit pattern
	        val32 = < number >(this.b * 255) << 24;
	        val32 += < number >(this.g * 255) << 16;
	        val32 += < number >(this.r * 255) << 8;
	        val32 += < number >(this.a * 255);

	        return val32;
		}

		get bgra():  number  {
	        var val32:  number  = 0;
// Convert to 32bit pattern
	        val32 = < number >(this.a * 255) << 24;
	        val32 += < number >(this.r * 255) << 16;
	        val32 += < number >(this.g * 255) << 8;
	        val32 += < number >(this.b * 255);

	        return val32;
		}

		get abgr():  number  {
			var val32:  number  = 0;
// Convert to 32bit pattern
	        val32 = < number >(this.r * 255) << 24;
	        val32 += < number >(this.g * 255) << 16;
	        val32 += < number >(this.b * 255) << 8;
	        val32 += < number >(this.a * 255);

	        return val32;
		}

		set rgba(c:  number ) {
			var val32:  number  = c;

// Convert from 32bit pattern
	        this.a = ((val32 >> 24) & 0xFF) / 255.0;
	        this.b = ((val32 >> 16) & 0xFF) / 255.0;
	        this.g = ((val32 >> 8) & 0xFF) / 255.0;
	        this.r = (val32 & 0xFF) / 255.0;

		}

		set argb(c:  number ) {
			var val32:  number  = c;

// Convert from 32bit pattern
	        this.b = ((val32 >> 24) & 0xFF) / 255.0;
	        this.g = ((val32 >> 16) & 0xFF) / 255.0;
	        this.r = ((val32 >> 8) & 0xFF) / 255.0;
	        this.a = (val32 & 0xFF) / 255.0;

		}

		set bgra(c:  number ) {
			var val32:  number  = c;

// Convert from 32bit pattern
	        this.a = ((val32 >> 24) & 0xFF) / 255.0;
	        this.r = ((val32 >> 16) & 0xFF) / 255.0;
	        this.g = ((val32 >> 8) & 0xFF) / 255.0;
	        this.b = (val32 & 0xFF) / 255.0;

		}

		set abgr(c:  number ) {
			var val32:  number  = c;

// Convert from 32bit pattern
	        this.r = ((val32 >> 24) & 0xFF) / 255.0;
	        this.g = ((val32 >> 16) & 0xFF) / 255.0;
	        this.b = ((val32 >> 8) & 0xFF) / 255.0;
	        this.a = (val32 & 0xFF) / 255.0;

		}

		set(): IColor;
		set(cColor: IColorValue): IColor;
		set(pData: ArrayBufferView): IColor;
		set(cColor: IColor): IColor;
		set(r:  number , g:  number , b:  number , a:  number ): IColor;
		set(r:  number , g:  number , b:  number ): IColor;
		set(fGray:  number , fAlpha:  number ): IColor;
		set(fGray:  number ): IColor;
		set(r?: any, g?: any, b?: any, a?: any): IColor {
			switch (arguments.length) {
				case 0:
					this.r = this.g = this.b = 0.;
					this.a = 1.;
					break;
				case 1:
					if (isInt(arguments[0])) {
						this.r = this.g = this.b = < number >r;
						this.a = 1.;
					}
					else if (isDef(arguments[0].buffer)) {
						var c: ArrayBufferView = <ArrayBufferView>arguments[0];
						this.r = c[0];
						this.g = c[1];
						this.b = c[2];
						this.a = c[3];
					}
					else {
						var v: IColorValue = <IColorValue>arguments[0];
						this.r = v.r;
						this.g = v.g;
						this.b = v.b;
						this.a = v.a;
					}
					break;
				case 2:
					this.r = this.g = this.b = < number >r;
					this.a = < number >g;
					break;
				case 3:
				case 4:
					this.r = < number >r;
					this.g = < number >g;
					this.b = < number >b;
					this.a = isDef(a)? < number >a: 1.;
					break;
			}

			return this;
		}

        saturate(): IColor {
        	if (this.r < 0.)
                this.r = 0.;
            else if (this.r > 1.)
                this.r = 1.;

            if (this.g < 0.)
                this.g = 0.;
            else if (this.g > 1.)
                this.g = 1.;

            if (this.b < 0.)
                this.b = 0.;
            else if (this.b > 1.)
                this.b = 1.;

            if (this.a < 0.)
                this.a = 0.;
            else if (this.a > 1.)
                this.a = 1.;

        	return this;
        }

/** As saturate, except that this colour value is unaffected and
		    the saturated colour value is returned as a copy. */

		saturateCopy(): IColor {
			var ret: IColor = new Color(this);
            ret.saturate();
            return ret;
		}

		add(cColor: IColor, ppDest: IColor = new Color): IColor {

            ppDest.r = this.r + cColor.r;
            ppDest.g = this.g + cColor.g;
            ppDest.b = this.b + cColor.b;
            ppDest.a = this.a + cColor.a;

            return ppDest;
		}

		subtract(cColor: IColor, ppDest: IColor = new Color): IColor {
			ppDest.r = this.r - cColor.r;
            ppDest.g = this.g - cColor.g;
            ppDest.b = this.b - cColor.b;
            ppDest.a = this.a - cColor.a;

            return ppDest;
		}

		multiply(cColor: IColor, ppDest?: IColor): IColor;
		multiply(fScalar:  number , ppDest?: IColor): IColor;
		multiply(fScalar: any, ppDest: IColor = new Color): IColor {
			if (isNumber(fScalar)) {
				var f:  number  = < number >fScalar;
				ppDest.r = this.r * f;
	            ppDest.g = this.g * f;
	            ppDest.b = this.b * f;
	            ppDest.a = this.a * f;
			}
			else {
				var c: IColor = <IColor>arguments[0];
				ppDest.r = this.r * c.r;
	            ppDest.g = this.g * c.g;
	            ppDest.b = this.b * c.b;
	            ppDest.a = this.a * c.a;
			}

            return ppDest;
		}


		divide(cColor: IColor, ppDest?: IColor): IColor;
		divide(fScalar:  number , ppDest?: IColor): IColor;
		divide(fScalar: any, ppDest: IColor = new Color): IColor {
			if (isNumber(fScalar)) {
				var f:  number  = < number >fScalar;
				ppDest.r = this.r / f;
	            ppDest.g = this.g / f;
	            ppDest.b = this.b / f;
	            ppDest.a = this.a / f;
			}
			else {
				var c: IColor = <IColor>arguments[0];
				ppDest.r = this.r / c.r;
	            ppDest.g = this.g / c.g;
	            ppDest.b = this.b / c.b;
	            ppDest.a = this.a / c.a;
			}

            return ppDest;
		}

		setHSB(fHue:  number , fSaturation:  number , fBrightness:  number ): IColor {
// wrap hue
			if (fHue > 1.0) {
				fHue -= < number >fHue;
			}
			else if (fHue < 0.0) {
				fHue += < number >fHue + 1;
			}

// clamp saturation / fBrightness
			fSaturation = math.min(fSaturation, 1.0);
			fSaturation = math.max(fSaturation, 0.0);
			fBrightness = math.min(fBrightness, 1.0);
			fBrightness = math.max(fBrightness, 0.0);

			if (fBrightness == 0.0) {
// early exit, this has to be black
				this.r = this.g = this.b = 0.0;
				return;
			}

			if (fSaturation == 0.0) {
// early exit, this has to be grey

				this.r = this.g = this.b = fBrightness;
				return;
			}


			var fHueDomain:  number   = fHue * 6.0;
			if (fHueDomain >= 6.0)
			{
// wrap around, and allow mathematical errors
				fHueDomain = 0.0;
			}

			var domain:  number  = < number >fHueDomain;
			var f1:  number  = fBrightness * (1 - fSaturation);
			var f2:  number  = fBrightness * (1 - fSaturation * (fHueDomain - domain));
			var f3:  number  = fBrightness * (1 - fSaturation * (1 - (fHueDomain - domain)));

			switch (domain) {
			case 0:
// red domain; green ascends
				this.r = fBrightness;
				this.g = f3;
				this.b = f1;
				break;
			case 1:
// yellow domain; red descends
				this.r = f2;
				this.g = fBrightness;
				this.b = f1;
				break;
			case 2:
// green domain; blue ascends
				this.r = f1;
				this.g = fBrightness;
				this.b = f3;
				break;
			case 3:
// cyan domain; green descends
				this.r = f1;
				this.g = f2;
				this.b = fBrightness;
				break;
			case 4:
// blue domain; red ascends
				this.r = f3;
				this.g = f1;
				this.b = fBrightness;
				break;
			case 5:
// magenta domain; blue descends
				this.r = fBrightness;
				this.g = f1;
				this.b = f2;
				break;
			}

			return this;
		}

		getHSB(pHsb:  number [] = [0., 0., 0.]):  number [] {
			var vMin:  number  = math.min(this.r, math.min(this.g, this.b));
			var vMax:  number  = math.max(this.r, math.max(this.g, this.b));
			var delta:  number  = vMax - vMin;

			var brightness:  number  = vMax;
			var hue:  number ;
			var saturation:  number ;

			if (math.isRealEqual(delta, 0.0, 1e-6)) {
// grey
				hue = 0.;
				saturation = 0.;
			}
			else {
// a colour
				saturation = delta / vMax;

				var deltaR:  number  = (((vMax - this.r) / 6.0) + (delta / 2.0)) / delta;
				var deltaG:  number  = (((vMax - this.g) / 6.0) + (delta / 2.0)) / delta;
				var deltaB:  number  = (((vMax - this.b) / 6.0) + (delta / 2.0)) / delta;

				if (math.isRealEqual(this.r, vMax))
					hue = deltaB - deltaG;
				else if (math.isRealEqual(this.g, vMax))
					hue = 0.3333333 + deltaR - deltaB;
				else if (math.isRealEqual(this.b, vMax))
					hue = 0.6666667 + deltaG - deltaR;

				if (hue < 0.0)
					hue += 1.0;
				if (hue > 1.0)
					hue -= 1.0;
			}

			pHsb[0] = hue;
			pHsb[1] = saturation;
			pHsb[2] = brightness;

			return pHsb;
		}

		static toFloat32Array(pValue: IColorValue): Float32Array {
			var pArr: Float32Array = new Float32Array(4);

			pArr[0] = pValue.r;
			pArr[1] = pValue.g;
			pArr[2] = pValue.b;
			pArr[3] = pValue.a;

			return pArr;
		}

		static BLACK: IColor = new Color(0);
		static isEqual(c1: IColorValue, c2: IColorValue): bool {
			return 	c1.r === c2.r &&
					c1.g === c2.g &&
					c1.b === c2.b &&
					c1.a === c2.a;
		}
	}
}

module akra {
	export var Color = util.Color;
}



module akra.material {
	export class Material implements IMaterial {
		name: string = null;

		diffuse: IColor = new Color(.5);
		ambient: IColor = new Color(.5);
		specular: IColor = new Color(.5);
		emissive: IColor = new Color(.5);
		shininess:  number  = 50.;

		constructor (sName: string = null, pMat?: IMaterial) {
			this.name = sName;

			if (isDefAndNotNull(pMat)) {
				this.set(pMat);
			}
		}

		set(pMat: IMaterialBase): IMaterial {
//this.name = pMat.name;

			this.diffuse.set(pMat.diffuse);
			this.ambient.set(pMat.ambient);
			this.specular.set(pMat.specular);
			this.emissive.set(pMat.emissive);
			this.shininess = pMat.shininess;

			return this;
		}

		isEqual(pMat: IMaterialBase): bool {
			return Color.isEqual(this.diffuse, pMat.diffuse) &&
			Color.isEqual(this.ambient, pMat.ambient) &&
			Color.isEqual(this.specular, pMat.specular) &&
			Color.isEqual(this.emissive, pMat.emissive) &&
				this.shininess === pMat.shininess;
		}
	}

	class FlexMaterial implements IFlexMaterial {
		name: string = null;

		/**@protected*/  _pData: IVertexData;

		/**@inline*/  get diffuse(): IColorValue { return new Color(this._pData.getTypedData(DeclUsages.DIFFUSE, 0, 1)); }
		/**@inline*/  get ambient(): IColorValue { return new Color(this._pData.getTypedData(DeclUsages.AMBIENT, 0, 1)); }
		/**@inline*/  get specular(): IColorValue { return new Color(this._pData.getTypedData(DeclUsages.SPECULAR, 0, 1)); }
		/**@inline*/  get emissive(): IColorValue { return new Color(this._pData.getTypedData(DeclUsages.EMISSIVE, 0, 1)); }
		/**@inline*/  get shininess():  number  { return this._pData.getTypedData(DeclUsages.SHININESS, 0, 1)[0]; }

		/**@inline*/  set diffuse(pValue: IColorValue) { this._pData.setData(Color.toFloat32Array(pValue), DeclUsages.DIFFUSE); }
		/**@inline*/  set ambient(pValue: IColorValue) { this._pData.setData(Color.toFloat32Array(pValue), DeclUsages.AMBIENT); }
		/**@inline*/  set specular(pValue: IColorValue) { this._pData.setData(Color.toFloat32Array(pValue), DeclUsages.SPECULAR); }
		/**@inline*/  set emissive(pValue: IColorValue) { this._pData.setData(Color.toFloat32Array(pValue), DeclUsages.EMISSIVE); }
		/**@inline*/  set shininess(pValue:  number ) { this._pData.setData(new Float32Array([pValue]), DeclUsages.SHININESS); }

		/**@inline*/  get data(): IVertexData { return this._pData; }

		constructor (sName: string, pData: IVertexData) {
			this._pData = pData;
			this.name = sName;
		}

		set(pMat: IMaterial): IMaterial {
//this.name = 

			this.diffuse = pMat.diffuse;
			this.ambient = pMat.ambient;
			this.specular = pMat.specular;
			this.emissive = pMat.emissive;
			this.shininess = pMat.shininess;

			return this;

		}

		isEqual(pMat: IMaterial): bool {
			return Color.isEqual(this.diffuse, pMat.diffuse) &&
			Color.isEqual(this.ambient, pMat.ambient) &&
			Color.isEqual(this.specular, pMat.specular) &&
			Color.isEqual(this.emissive, pMat.emissive) &&
				this.shininess === pMat.shininess;
		}
	}

	export  /**@const*/var  VERTEX_DECL: IVertexDeclaration = createVertexDeclaration(
		[
            {count: 17, type: EDataTypes.FLOAT, usage: DeclUsages.MATERIAL 	},
            {count: 4, 	type: EDataTypes.FLOAT, usage: DeclUsages.DIFFUSE, offset: 0},
            {count: 4, 	type: EDataTypes.FLOAT, usage: DeclUsages.AMBIENT 	},
            {count: 4, 	type: EDataTypes.FLOAT, usage: DeclUsages.SPECULAR 	},
            {count: 4, 	type: EDataTypes.FLOAT, usage: DeclUsages.EMISSIVE	},
            {count: 1, 	type: EDataTypes.FLOAT, usage: DeclUsages.SHININESS }
        ]);

	export  /**@const*/var  DEFAULT: IMaterial = new Material;

	export function create(sName: string = null, pMat: IMaterial = null): IMaterial {
		return new Material(sName, pMat);
	}

	export function _createFlex(sName: string, pData: IVertexData): IMaterial {
		return new FlexMaterial(sName, pData);
	}
}

module akra {
	export var Material = material.Material;
}



module akra.core.pool.resources {
	export class SurfaceMaterial extends ResourcePoolItem implements ISurfaceMaterial {
		/**@protected*/  _pMaterial: IMaterial = new Material;
		/**@protected*/  _nTotalTextures:  number  = 0;
		/**@protected*/  _iTextureFlags:  number  = 0;
		/**@protected*/  _iTextureMatrixFlags:  number  = 0;
		/**@protected*/  _pTextures: ITexture[] = new Array(SurfaceMaterial.MAX_TEXTURES_PER_SURFACE);
		/**@protected*/  _pTexcoords:  number [] = new Array(SurfaceMaterial.MAX_TEXTURES_PER_SURFACE);
		/**@protected*/  _pTextureMatrices: IMat4[] = new Array(SurfaceMaterial.MAX_TEXTURES_PER_SURFACE);



		/**@inline*/  get totalTextures():  number  { return this._nTotalTextures; }
    	/**@inline*/  get material(): IMaterial { return this._pMaterial; }
    	/**@inline*/  set material(pMaterial: IMaterial) { this._pMaterial.set(pMaterial); }
    	/**@inline*/  get textureFlags():  number  { return this._iTextureFlags; }
    	/**@inline*/  get textureMatrixFlags():  number  { return this._iTextureMatrixFlags; }

    	constructor () {
    		super();

    		for (var i:  number  = 0; i < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE; ++ i) {
    			this._pTexcoords[i] = i;
    		}
    	}

    	setTexture(iIndex:  number , iTextureHandle:  number , iTexcoord:  number  = 0): bool;
    	setTexture(iIndex:  number , sTexture: string, iTexcoord:  number  = 0): bool;
    	setTexture(iIndex:  number , pTexture: ITexture, iTexcoord:  number  = 0): bool;
    	setTexture(iIndex:  number , pTexture: any, iTexcoord:  number  = 0): bool {

		    logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 40 ); logger.assert(iIndex < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE, "invalid texture slot");
                                          ;

		    var pRmgr: IResourcePoolManager = this.getManager();
		    var pTexture: ITexture;

		    this._pTexcoords[iIndex] = iTexcoord;

		    if (isString(arguments[0])) {
		    	pTexture = this._pTextures[iIndex];

		        if (pTexture) {
//realise first

		            if (pTexture.release() == 0) {
		            	this._pTextures[iIndex] = null;
//pTexture.destroyResource();
		            }
		            else {
		            	logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 58 ); logger.warning("cannot destroy resource...");
		            }

		            ((this._iTextureFlags) &= ~ (1 << ((iIndex))) ) ;
		            -- this._nTotalTextures;
		        }


		        this._pTextures[iIndex] = <ITexture>pRmgr.texturePool.loadResource(<string>arguments[0]);

		        if (this._pTextures[iIndex]) {
		            ((this._iTextureFlags) |= (1 << ((iIndex))) ) ;

		            ++ this._nTotalTextures;

		            this.sync(this._pTextures[iIndex], EResourceItemEvents.LOADED);
		        }

		        return true;
		    }
		    else if (arguments[0] instanceof Texture) {
		        if (!this._pTextures[iIndex] || pTexture != this._pTextures[iIndex]) {
		            if (this._pTextures[iIndex]) {
// realise first
// DisplayManager.texturePool().releaseResource(this._pTextures[iIndex]);

		                if (this._pTextures[iIndex].release() == 0) {
// this._pTextureMatrices[iIndex].destroyResource();
		                	this._pTextures[iIndex] = null;
		                }
		                else {
		                	logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 89 ); logger.warning("cannot destroy resource..."); ;
		                }

		                ((this._iTextureFlags) &= ~ (1 << ((iIndex))) ) ;
		                -- this._nTotalTextures;
		            }

		            this._pTextures[iIndex] = pTexture;

		            this._pTextures[iIndex].addRef();
		            ((this._iTextureFlags) |= (1 << ((iIndex))) ) ;
		            ++this._nTotalTextures;
		            this.sync(this._pTextures[iIndex], EResourceItemEvents.LOADED);

// var me = this;
// trace('me get texture :)');
// pTexture.setChangesNotifyRoutine(function() {
//                 if (pTexture.isResourceLoaded()) {
//                     trace(arguments);
//                     trace('Texture <', pTexture.findResourceName(), '> loaded');
//                     if (me.isResourceLoaded()) {
//                         trace('Surface material loaded too.')
//                     }
//                 }
//             });
		        }

		        return true;
		    }
//similar to [cPoolHandle texture]
		    else if (isNumber(arguments[0])) {
		        if (!this._pTextures[iIndex] || this._pTextures[iIndex].resourceHandle != < number >arguments[0]) {
		            if (this._pTextures[iIndex]) {
//TheGameHost.displayManager().texturePool().releaseResource(m_pTextures[index]);
		                if (this._pTextures[iIndex].release() === 0) {
// this._pTextures[iIndex].destroyResource();
		                	this._pTextures[iIndex] = null;
		                }
		                else {
		                	logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 128 ); logger.warning("cannot destroy resource..."); ;
		                }

		                ((this._iTextureFlags) &= ~ (1 << ((iIndex))) ) ;
		                -- this._nTotalTextures;
		            }

		            this._pTextures[iIndex] = <ITexture>pRmgr.texturePool.getResource(< number >arguments[0]);

		            if (this._pTextures[iIndex]) {
		                ((this._iTextureFlags) |= (1 << ((iIndex))) ) ;
		                ++ this._nTotalTextures;
		                this.sync(this._pTextures[iIndex], EResourceItemEvents.LOADED);
		            }
		        }

		        return true;
		    }

		    this._pTexcoords[iIndex] = iIndex;

		    return false;
    	}

    	setTextureMatrix(iIndex:  number , m4fValue: IMat4): bool {
    		logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 154 ); logger.assert(iIndex < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE, "invalid texture slot");
                                        ;

		    if (!m4fValue) {
		        this._pTextureMatrices[iIndex] = new Mat4();
		    }
		    else {
		        this._pTextureMatrices[iIndex] = new Mat4(m4fValue);
		    }

		    ((this._iTextureMatrixFlags) |= (1 << ((iIndex))) ) ;
		    return true;
    	}

    	/**@inline*/  setMaterial(pMaterial: IMaterial): void {
    		this._pMaterial.set(pMaterial);
    	}

    	isEqual(pSurfaceMaterial: ISurfaceMaterial): bool {
    		if (this._nTotalTextures === pSurfaceMaterial.totalTextures &&
		        this._iTextureFlags === pSurfaceMaterial.textureFlags &&
		        this._iTextureMatrixFlags === pSurfaceMaterial.textureMatrixFlags) {

		        if ((this._pMaterial && this._pMaterial.isEqual(pSurfaceMaterial.material))
		            || (pSurfaceMaterial.material === null)) {

		            for (var i = 0; i < this._pTextures.length; i++) {
		                if (this._pTextures[i] !== pSurfaceMaterial.texture[i]) {
		                    return false;
		                }
		            };

		            for (var i = 0; i< this._pTextureMatrices.length; ++ i) {
		                for (var j = 0; j < this._pTextureMatrices[i].data.length; j++) {
		                    if (this._pTextureMatrices[i].data[j] !== pSurfaceMaterial.textureMatrix[i].data[j]) {
		                        return false;
		                    }
		                };
		            }

		            return true;
		        }
		    }

		    return false;
    	}

    	/**@inline*/  texture(iSlot:  number ): ITexture {
    		logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 202 ); logger.assert((iSlot >= 0 && iSlot < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE), "invalid texture slot");
                                        ;
    		return this._pTextures[iSlot];
    	}

    	/**@inline*/  texcoord(iSlot:  number ):  number  {
    		logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 208 ); logger.assert((iSlot >= 0 && iSlot < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE), "invalid texture slot");
                                        ;
    		return this._pTexcoords[iSlot];
    	}

    	/**@inline*/  textureMatrix(iSlot:  number ): IMat4 {
    		logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 214 ); logger.assert((iSlot >= 0 && iSlot < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE), "invalid texture slot");
                                        ;
    		return this._pTextureMatrices[iSlot];
    	}

    	static MAX_TEXTURES_PER_SURFACE:  number  = 16;
	}
}


//#include "resources/Model.ts"








module akra {

	export interface IAFXComponent {} ;

	export interface IEffect extends IResourcePoolItem {
		totalComponents:  number ;
		totalPasses:  number ;

		isEqual(pEffect: IEffect): bool;
		isReplicated(): bool;
		isMixid(): bool;
		isParameterUsed(pParam: any, iPass?:  number ): bool;

		create(): void;
		replicable(bValue: bool): void;
		miscible(bValue: bool): void;

		getComponent(i:  number ): IAFXComponent;
		addComponent(iComponentHandle:  number , nShift?:  number , isSet?: bool): bool;
		addComponent(pComponent: IAFXComponent, nShift?:  number , isSet?: bool): bool;
		addComponent(sComponent: string, nShift?:  number , isSet?: bool): bool;
		delComponent(iComponentHandle:  number , nShift?:  number , isSet?: bool): bool;
		delComponent(sComponent: string, nShift?:  number , isSet?: bool): bool;
		delComponent(pComponent: IAFXComponent, nShift?:  number , isSet?: bool): bool;

		findParameter(pParam: any, iPass?:  number ): any;
	}
}





module akra.core.pool.resources {
	export class Effect implements IEffect extends ResourcePoolItem {
		totalComponents:  number ;
		totalPasses:  number ;

		isEqual(pEffect: IEffect): bool {return false;}
		isReplicated(): bool {return false;}
		isMixid(): bool {return false;}
		isParameterUsed(pParam: any, iPass?:  number ): bool {return false;}

		create(): void {return;}
		replicable(bValue: bool): void {return;}
		miscible(bValue: bool): void {return;}

		getComponent(i:  number ): IAFXComponent {return null;}
		addComponent(iComponentHandle:  number , nShift?:  number , isSet?: bool): bool;
		addComponent(pComponent: IAFXComponent, nShift?:  number , isSet?: bool): bool;
		addComponent(sComponent: string, nShift?:  number , isSet?: bool): bool;
		addComponent(sComponent: any, nShift?:  number , isSet?: bool): bool  {return false;}
		delComponent(iComponentHandle:  number , nShift?:  number , isSet?: bool): bool;
		delComponent(sComponent: string, nShift?:  number , isSet?: bool): bool;
		delComponent(pComponent: IAFXComponent, nShift?:  number , isSet?: bool): bool;
		delComponent(pComponent: any, nShift?:  number , isSet?: bool): bool {return false;}

		findParameter(pParam: any, iPass?:  number ): any {return null;}
	}
}















module akra {

	export enum EImageFlags {
		COMPRESSED = 0x00000001,
        CUBEMAP    = 0x00000002,
        TEXTURE_3D = 0x00000004
	};

    export interface IImg extends IResourcePoolItem {
    	byteLength:  number ;

    	width:  number ;
    	height:  number ;
    	depth:  number ;

    	numFaces:  number ;
    	numMipMaps:  number ;
    	format: EPixelFormats;


    	set(pSrc: IImg): IImg;

/** @param Destination image. If destination not specified, original image will be modified.*/

    	flipY(pDest?: IImg): IImg;
    	flipX(pDest?: IImg): IImg;

    	loadFromMemory(pData: Uint8Array, iWidth:  number , iHeight:  number , eFormat: EPixelFormats): bool;
    	loadFromMemory(pData: Uint8Array, iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats): bool;

    	loadRawData(pData: Uint8Array, iWidth:  number , iHeight:  number , eFormat: EPixelFormats, nFaces?:  number , nMipMaps?:  number ): bool;
    	loadRawData(pData: Uint8Array, iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats, nFaces?:  number , nMipMaps?:  number ): bool;

        loadDynamicImage(pData: Uint8Array, iWidth:  number , iHeight:  number , iDepth:  number ,
                         eFormat: EPixelFormats, bAutoDelete?: bool,
                         iNumFaces?:  number , iNumMipMaps?:  number ): IImg;

    	load(sFilename: string);
    	create(iWidth:  number , iHeight:  number , eFormat: EPixelFormats, iFlags:  number ): bool;
    	create(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats, iFlags:  number ): bool;

    	convert(eFormat: EPixelFormats): bool;

//Gets the physical width in bytes of each row of pixels.
    	getRawSpan():  number ;
    	getBPP():  number ;
    	getFlags():  number ;
    	getData(): Uint8Array;

    	hasFlag(eFlag: EImageFlags): bool;

    	hasAlpha(): bool;
    	isCompressed(): bool;
    	isLumiance(): bool;

    	freeMemory();

    	getColorAt(x:  number , y:  number , z?: number ): IColor;
    	setColorAt(pColor: IColorValue, x:  number , y:  number , z:  number ): void;

    	getPixels(nFace?:  number , iMipMap?:  number ): IPixelBox;

    	scale(pDest: IPixelBox, eFilter?: EFilters): bool;

    	resize(iWidth:  number , iHeight:  number , eFilter?: EFilters): bool;

    	generatePerlinNoise(fScale:  number , iOctaves:  number , fFalloff:  number ): void;
    	randomChannelNoise(iChannel:  number , iMinRange:  number , iMaxRange:  number ): void;
    }

}





module akra.core.pool.resources {

	export class Img extends ResourcePoolItem implements IImg {
		/**@protected*/  _iWidth:  number  = 0;
		/**@protected*/  _iHeight:  number  = 0;
		/**@protected*/  _iDepth:  number  = 0;

		/**@protected*/  _nMipMaps:  number  = 0;
		/**@protected*/  _iFlags:  number  = 0;

		/**@protected*/  _eFormat: EPixelFormats = EPixelFormats.UNKNOWN;

		/**@protected*/  _iPixelSize:  number ;
		/**@protected*/  _pBuffer: Uint8Array = null;

		/**@inline*/  get byteLength():  number  {
			return 0;
		}

    	/**@inline*/  get width():  number  {
    		return this._iWidth;
    	}

    	/**@inline*/  get height():  number  {
    		return this._iHeight;
    	}

    	/**@inline*/  get depth():  number  {
    		return this._iDepth;
    	}

    	/**@inline*/  get numFaces():  number  {
    		if (this.hasFlag(EImageFlags.CUBEMAP)) {
    			return 6;
    		}

    		return 1;
    	}

    	/**@inline*/  get numMipMaps():  number  {
    		return this._nMipMaps;
    	}

    	/**@inline*/  get format(): EPixelFormats {
    		return this._eFormat;
    	}

		constructor () {
			super();
		}

		createResource(): bool {
// innitialize the resource (called once)
		    logger.setSourceLocation( "resources/Img.ts" , 61 ); logger.assert(!this.isResourceCreated(), "The resource has already been created.");
                                                            ;

// signal that the resource is now created,
// but has not been enabled
		    this.notifyCreated();
		    this.notifyDisabled();

		    return true;
		}

		destroyResource(): bool {
// destroy the resource
//
// we permit redundant calls to destroy, so there are no asserts here
//
		    if (this.isResourceCreated()) {
// disable the resource
		        this.disableResource();

		        this.freeMemory();

		        this.notifyUnloaded();
		        this.notifyDestroyed();

		        return (true);
		    }

		    return (false);
		}

		restoreResource(): bool {
			logger.setSourceLocation( "resources/Img.ts" , 93 ); logger.assert(this.isResourceCreated(), "The resource has not been created.");
                                                        ;

		    this.notifyRestored();
		    return true;
		}

		disableResource(): bool {
			logger.setSourceLocation( "resources/Img.ts" , 101 ); logger.assert(this.isResourceCreated(), "The resource has not been created.");
                                                      ;

		    this.notifyDisabled();
		    return true;
		}

		loadResource(sFilename?: string): bool {
			return false;
		}

		saveResource(sFilename?: string): bool {
			return false;
		}

		create(iWidth:  number , iHeight:  number , eFormat: EPixelFormats, iFlags:  number ): bool;
    	create(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats, iFlags:  number ): bool;
    	create(iWidth:  number , iHeight:  number , iDepth?: any, eFormat?: any, iFlags?: any): bool {
    		return false;
    	}


    	freeMemory(): void {
    		this._iWidth = 0;
    		this._iHeight = 0;
    		this._iDepth = 0;
    		this._pBuffer = null;
    	}

    	set(pSrc: IImg): IImg {
    		this.freeMemory();

    		this._iWidth = pSrc.width;
    		this._iHeight = pSrc.height;
    		this._iDepth = pSrc.depth;
    		this._eFormat = pSrc.format;

    		this._iFlags = pSrc.getFlags();
    		this._iPixelSize = math.ceil(pSrc.getBPP() / 8);

    		this._nMipMaps = pSrc.numMipMaps;

    		this._pBuffer = new Uint8Array(pSrc.getData());

    		return this;
    	}


    	flipY(pDest?: IImg): IImg {
    		return this;
    	}

    	flipX(pDest?: IImg): IImg {
    		return this;
    	}

    	loadFromMemory(pData: Uint8Array, iWidth:  number , iHeight:  number , eFormat: EPixelFormats): bool;
    	loadFromMemory(pData: Uint8Array, iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats): bool;
    	loadFromMemory(pData: Uint8Array, iWidth:  number , iHeight:  number , iDepth: any, eFormat?: any): bool {
    		return false;
    	}

    	loadRawData(pData: Uint8Array, iWidth:  number , iHeight:  number , eFormat: EPixelFormats, nFaces?:  number , nMipMaps?:  number ): bool;
    	loadRawData(pData: Uint8Array, iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats, nFaces?:  number , nMipMaps?:  number ): bool;
    	loadRawData(pData: Uint8Array, iWidth:  number , iHeight:  number , iDepth: any, eFormat?: any, nFaces?: any, nMipMaps?: any): bool {
    		return false;
    	}

        loadDynamicImage(pData: Uint8Array, iWidth:  number , iHeight:  number , iDepth:  number ,
                         eFormat: EPixelFormats, bAutoDelete?: bool = false,
                         iNumFaces?:  number  = 1, iNumMipMaps?:  number  = 0): IImg {
            return null;
        }

    	load(sFilename: string): bool {
    		return false;
    	}

    	convert(eFormat: EPixelFormats): bool {
    		return false;
    	}

//Gets the physical width in bytes of each row of pixels.
    	getRawSpan():  number  {
    		return 0;
    	}

    	getBPP():  number  {
    		return 0;
    	}

    	getFlags():  number  {
    		return 0;
    	}

    	getData(): Uint8Array {
    		return null;
    	}

    	hasFlag(eFlag: EImageFlags): bool {
    		return false;
    	}

    	hasAlpha(): bool {
    		return false;
    	}

    	isCompressed(): bool {
    		return false;
    	}

    	isLumiance(): bool {
    		return false;
    	}


    	getColorAt(x:  number , y:  number , z?: number ): IColor {
    		return null;
    	}

    	setColorAt(pColor: IColorValue, x:  number , y:  number , z:  number ): void {

    	}

    	getPixels(nFace?:  number , iMipMap?:  number ): IPixelBox {
    		return null;
    	}

    	scale(pDest: IPixelBox, eFilter?: EFilters): bool {
    		return null;
    	}

    	resize(iWidth:  number , iHeight:  number , eFilter?: EFilters): bool {
    		return null;
    	}

    	generatePerlinNoise(fScale:  number , iOctaves:  number , fFalloff:  number ): void {

    	}

    	randomChannelNoise(iChannel:  number , iMinRange:  number , iMaxRange:  number ): void {

    	}
	}
}













module akra {
	export interface IAFXComponent extends IResourcePoolItem {

	}
}





module akra.core.pool.resources {
	export class Component extends ResourcePoolItem implements IAFXComponent{

	}
}



// #include "resources/Collada.ts"













/*
-----------------------------------------------------------------------------
This source file is part of OGRE
    (Object-oriented Graphics Rendering Engine)
For the latest info, see http://www.ogre3d.org/

Copyright (c) 2000-2012 Torus Knot Software Ltd
-----------------------------------------------------------------------------
*/


module akra.core.pool.resources {
	export class HardwareBuffer extends ResourcePoolItem implements IHardwareBuffer {
		/**@protected*/  _iFlags:  number  = 0;

		/**@protected*/  _isLocked: bool = false;
/** Lock byte offset. */

		/**@protected*/  _iLockStart:  number ;
/** Lock byte size. */

		/**@protected*/  _iLockSize:  number ;

		/**@protected*/  _pBackupCopy: HardwareBuffer = null;
		/**@protected*/  _pBackupUpdated: bool = false;
		/**@protected*/  _bIgnoreHardwareUpdate: bool = false;

		byteLength:  number  = 0;
		length:  number  = 0;

		constructor() {
			super();
		}

		/**@inline*/  isValid(): bool {
			return false;
		}

		/**@inline*/  isDynamic(): bool {
			return  (((this._iFlags) & (EHardwareBufferFlags.DYNAMIC)) != 0) ;
		}

		/**@inline*/  isStatic(): bool {
			return  (((this._iFlags) & (EHardwareBufferFlags.STATIC)) != 0) ;
		}

		/**@inline*/  isStream(): bool {
			return  (((this._iFlags) & (EHardwareBufferFlags.STREAM)) != 0) ;
		}

		/**@inline*/  isReadable(): bool {
			return  (((this._iFlags) & (EHardwareBufferFlags.READABLE)) != 0) ;
		}

		/**@inline*/  isBackupPresent(): bool {
			return this._pBackupCopy != null;
		}

		/**@inline*/  isSoftware(): bool {
    		return  (((this._iFlags) & (EHardwareBufferFlags.SOFTWARE)) != 0) ;
		}

		/**@inline*/  isAligned(): bool {
			return  (((this._iFlags) & (EHardwareBufferFlags.ALIGNMENT)) != 0) ;
		}

		/**@inline*/  isLocked(): bool {
			return this._isLocked;
		}

		clone(pSrc: IHardwareBuffer): bool {
			return false;
		}

		/**@inline*/  getFlags():  number  { return this._iFlags; }

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;
		readData(iOffset: any, iSize?: any, ppDest?: any): bool {
			return false;
		}

		writeData(pData: Uint8Array, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: ArrayBufferView, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: any, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool {
			return false;
		}

		copyData(pSrcBuffer: IHardwareBuffer, iSrcOffset:  number , iDstOffset:  number , iSize:  number , bDiscardWholeBuffer: bool = false): bool {
			var pData: any = pSrcBuffer.lock(iSrcOffset, iSize);
			this.writeData(pData, iDstOffset, iSize, bDiscardWholeBuffer);
			pSrcBuffer.unlock();
			return true;
		}

		create(iFlags:  number ): bool {
			iFlags |= EHardwareBufferFlags.STATIC;

			if ( (((iFlags) & (EHardwareBufferFlags.DYNAMIC)) != 0) ) {
				((iFlags) &= ~(EHardwareBufferFlags.STATIC)) ;

				if ( (((iFlags) & (EHardwareBufferFlags.BACKUP_COPY)) != 0) ) {
					((iFlags) &= ~(EHardwareBufferFlags.READABLE)) ;
				}
			}

			this._iFlags = iFlags;

			this.notifyCreated();
			this.notifyRestored();

			return true;
		}

		destroy(): void {
			this._iFlags = 0;
			this.notifyDestroyed();
			this.notifyUnloaded();
		}

		resize(iSize:  number ): bool {
			return false;
		}

		lock(iLockFlags:  number ): any;
		lock(iOffset:  number , iSize:  number , iLockFlags:  number  = EHardwareBufferFlags.READABLE): any;
		lock(iOffset:  number , iSize?: any, iLockFlags:  number  = EHardwareBufferFlags.READABLE): any {
			logger.setSourceLocation( "core/pool/resources/HardwareBuffer.ts" , 128 ); logger.assert(!this.isLocked(), "Cannot lock this buffer, it is already locked!"); ;

			if (arguments.length == 1) {
				iLockFlags = < number >arguments[0];
				iOffset = 0;
				iSize = this.byteLength;
			}

			var pResult: any = null;

			if ((iOffset + iSize) > this.byteLength) {
				logger.setSourceLocation( "core/pool/resources/HardwareBuffer.ts" , 139 ); logger.error("Lock request out of bounds.", "HardwareBuffer::lock"); ;
			}
			else if (this.isBackupPresent()) {
				if (! (((iLockFlags) & (ELockFlags.WRITE)) != 0) ) {
// we have to assume a read / write lock so we use the shadow buffer
// and tag for sync on unlock()
                    this._pBackupUpdated = true;
                }

                pResult = this._pBackupCopy.lock(iOffset, iSize, iLockFlags);
            }
            else {
// Lock the real buffer if there is no shadow buffer 
                pResult = this.lockImpl(iOffset, iSize, iLockFlags);
                this._isLocked = true;
            }

			this._iLockStart = iOffset;
			this._iLockSize = iSize;

            return pResult;
		}

		unlock(): void {
			logger.setSourceLocation( "core/pool/resources/HardwareBuffer.ts" , 163 ); logger.assert(this.isLocked(), "Cannot unlock this buffer, it is not locked!"); ;

// If we used the shadow buffer this time...
            if (this._pBackupCopy && this._pBackupCopy.isLocked()) {
                this._pBackupCopy.unlock();
// Potentially update the 'real' buffer from the shadow buffer
                this.restoreFromBackup();
            }
            else
            {
// Otherwise, unlock the real one
                this.unlockImpl();
                this._isLocked = false;
            }
		}

		restoreFromBackup(): bool {
			if (this._pBackupCopy && this._pBackupUpdated && !this._bIgnoreHardwareUpdate) {
// Do this manually to avoid locking problems
	            var pBackupData: any = this._pBackupCopy.lockImpl(this._iLockStart,
	            	this._iLockSize, ELockFlags.READ);
// Lock with discard if the whole buffer was locked, otherwise normal
				var iLockFlags:  number ;

				if (this._iLockStart == 0 && this._iLockSize == this.byteLength) {
					iLockFlags = ELockFlags.DISCARD;
				}
				else {
					iLockFlags = ELockFlags.NORMAL;
				}

	            var pRealData: any = this.lockImpl(this._iLockStart, this._iLockSize, iLockFlags);
// Copy backup to real
	            this.copyBackupToRealImpl(pRealData, pBackupData, iLockFlags);

	            this.unlockImpl();
	            this._pBackupCopy.unlockImpl();
	            this._pBackupUpdated = false;

	            return true;
	        }

	        return false;
		}

		createResource(): bool {
// innitialize the resource (called once)
		    logger.setSourceLocation( "core/pool/resources/HardwareBuffer.ts" , 211 ); logger.assert(!this.isResourceCreated(), "The resource has already been created.");
                                                            ;

// signal that the resource is now created,
// but has not been enabled
//this.notifyCreated();
		    this.notifyDisabled();

		    return true;
		}

		destroyResource(): bool {
// destroy the resource
//
// we permit redundant calls to destroy, so there are no asserts here
//
		    if (this.isResourceCreated()) {
// disable the resource
		        this.disableResource();
		        this.destroy();
		        return true;
		    }

		    return false;
		}

		restoreResource(): bool {
		    logger.setSourceLocation( "core/pool/resources/HardwareBuffer.ts" , 237 ); logger.assert(this.isResourceCreated(), "The resource has not been created."); ;

		    this.notifyRestored();
		    return true;
		}

		disableResource (): bool {
		    logger.setSourceLocation( "core/pool/resources/HardwareBuffer.ts" , 244 ); logger.assert(this.isResourceCreated(), "The resource has not been created."); ;

		    this.notifyDisabled();
		    return true;
		}

		/**@protected*/  lockImpl(iOffset:  number , iSize:  number , iLockFlags:  number ): any {
			return null;
		}

		/**@protected*/  unlockImpl(): void {

		}

		/**@protected*/  copyBackupToRealImpl(pRealData: any, pBackupData: any, iLockFlags:  number ): void {

		}
	}
}










module akra {
	export interface IBox {
		width:  number ;
		height:  number ;
		depth:  number ;

		left:  number ;
		top:  number ;
		right:  number ;
		bottom:  number ;
		front:  number ;
		back:  number ;

		contains(pDest: IBox): bool;
	}
}




module akra.geometry {
	export class Box implements IBox {
		left:  number ;
		top:  number ;
		front:  number ;
		right:  number ;
		bottom:  number ;
		back:  number ;

		/**@inline*/  get width():  number  {
			return this.right - this.left;
		}

		/**@inline*/  get height():  number  {
			return this.bottom - this.top;
		}

		/**@inline*/  get depth():  number  {
			return this.back - this.front;
		}

		constructor ();
		constructor (pExtents: IBox);
		constructor (iLeft:  number , iTop:  number , iRight:  number , iBottom:  number );
		constructor (iLeft:  number , iTop:  number , iFront:  number , iRight:  number , iBottom:  number , iBack:  number );
		constructor (l:  number  = 0, t:  number  = 0, ff:  number  = 0, r:  number  = 1, b:  number  = 1, bb:  number  = 1) {
			switch (arguments.length) {
				case 1:
					this.left 	= arguments[0].left;
					this.top 	= arguments[0].top;
					this.front 	= arguments[0].front;

					this.right 	= arguments[0].right;
					this.bottom = arguments[0].bottom;
					this.back 	= arguments[0].back;
					break;
				case 3:
				case 6:
					this.left 	= l;
					this.top 	= t;
					this.front 	= ff;

					this.right 	= r;
					this.bottom = b;
					this.back 	= bb;
					break;
				case 4:
					this.left 	= l;
					this.top 	= t;
					this.right 	= ff;
					this.bottom = r;

					this.back 	= 1;
					this.front 	= 0;
					break;
				case 5:
					logger.setSourceLocation( "geometry/Box.ts" , 62 ); logger.error("invalid number of arguments"); ;
			}

			logger.setSourceLocation( "geometry/Box.ts" , 65 ); logger.assert(this.right >= this.left && this.bottom >= this.top && this.back >= this.front); ;
		}

		contains(pDest: IBox): bool {
			return (pDest.left >= this.left && pDest.top >= this.top && pDest.front >= this.front &&
	    		pDest.right <= this.right && pDest.bottom <= this.bottom && pDest.back <= this.back);
		}
	}
}







// see: http://www.khronos.org/registry/webgl/specs/latest/

interface WebGLObject
{
};

interface WebGLBuffer extends WebGLObject
{
};

interface WebGLFramebuffer extends WebGLObject
{
};

interface WebGLProgram extends WebGLObject
{
};

interface WebGLRenderbuffer extends WebGLObject
{
};

interface WebGLShader extends WebGLObject
{
};

interface WebGLTexture extends WebGLObject
{
};

interface WebGLUniformLocation
{
};

interface WebGLActiveInfo
{
	size: number;
	type: number;
	name: string;
};

interface WebGLShaderPrecisionFormat
{
	rangeMin: number;
	rangeMax: number;
	precision: number;
};


interface WebGLContextAttributes
{
	alpha?: bool;
	depth?: bool;
	stencil?: bool;
	antialias?: bool;
	premultipliedAlpha?: bool;
	preserveDrawingBuffer?: bool;
};

interface WebGLRenderingContext
{
/* ClearBufferMask */

	DEPTH_BUFFER_BIT: number;
	STENCIL_BUFFER_BIT: number;
	COLOR_BUFFER_BIT: number;

/* BeginMode */

	POINTS: number;
	LINES: number;
	LINE_LOOP: number;
	LINE_STRIP: number;
	TRIANGLES: number;
	TRIANGLE_STRIP: number;
	TRIANGLE_FAN: number;

/* AlphaFunction (not supported in ES20) */

/*      NEVER */

/*      LESS */

/*      EQUAL */

/*      LEQUAL */

/*      GREATER */

/*      NOTEQUAL */

/*      GEQUAL */

/*      ALWAYS */


/* BlendingFactorDest */

	ZERO: number;
	ONE: number;
	SRC_COLOR: number;
	ONE_MINUS_SRC_COLOR: number;
	SRC_ALPHA: number;
	ONE_MINUS_SRC_ALPHA: number;
	DST_ALPHA: number;
	ONE_MINUS_DST_ALPHA: number;

/* BlendingFactorSrc */

/*      ZERO */

/*      ONE */

	DST_COLOR: number;
	ONE_MINUS_DST_COLOR: number;
	SRC_ALPHA_SATURATE: number;
/*      SRC_ALPHA */

/*      ONE_MINUS_SRC_ALPHA */

/*      DST_ALPHA */

/*      ONE_MINUS_DST_ALPHA */


/* BlendEquationSeparate */

	FUNC_ADD: number;
	BLEND_EQUATION: number;
	BLEND_EQUATION_RGB: number;
	BLEND_EQUATION_ALPHA: number;

/* BlendSubtract */

	FUNC_SUBTRACT: number;
	FUNC_REVERSE_SUBTRACT: number;

/* Separate Blend Functions */

	BLEND_DST_RGB: number;
	BLEND_SRC_RGB: number;
	BLEND_DST_ALPHA: number;
	BLEND_SRC_ALPHA: number;
	CONSTANT_COLOR: number;
	ONE_MINUS_CONSTANT_COLOR: number;
	CONSTANT_ALPHA: number;
	ONE_MINUS_CONSTANT_ALPHA: number;
	BLEND_COLOR: number;

/* Buffer Objects */

	ARRAY_BUFFER: number;
	ELEMENT_ARRAY_BUFFER: number;
	ARRAY_BUFFER_BINDING: number;
	ELEMENT_ARRAY_BUFFER_BINDING: number;

	STREAM_DRAW: number;
	STATIC_DRAW: number;
	DYNAMIC_DRAW: number;

	BUFFER_SIZE: number;
	BUFFER_USAGE: number;

	CURRENT_VERTEX_ATTRIB: number;

/* CullFaceMode */

	FRONT: number;
	BACK: number;
	FRONT_AND_BACK: number;

/* DepthFunction */

/*      NEVER */

/*      LESS */

/*      EQUAL */

/*      LEQUAL */

/*      GREATER */

/*      NOTEQUAL */

/*      GEQUAL */

/*      ALWAYS */


/* EnableCap */

/* TEXTURE_2D */

	CULL_FACE: number;
	BLEND: number;
	DITHER: number;
	STENCIL_TEST: number;
	DEPTH_TEST: number;
	SCISSOR_TEST: number;
	POLYGON_OFFSET_FILL: number;
	SAMPLE_ALPHA_TO_COVERAGE: number;
	SAMPLE_COVERAGE: number;

/* ErrorCode */

	NO_ERROR: number;
	INVALID_ENUM: number;
	INVALID_VALUE: number;
	INVALID_OPERATION: number;
	OUT_OF_MEMORY: number;

/* FrontFaceDirection */

	CW: number;
	CCW: number;

/* GetPName */

	LINE_WIDTH: number;
	ALIASED_POINT_SIZE_RANGE: number;
	ALIASED_LINE_WIDTH_RANGE: number;
	CULL_FACE_MODE: number;
	FRONT_FACE: number;
	DEPTH_RANGE: number;
	DEPTH_WRITEMASK: number;
	DEPTH_CLEAR_VALUE: number;
	DEPTH_FUNC: number;
	STENCIL_CLEAR_VALUE: number;
	STENCIL_FUNC: number;
	STENCIL_FAIL: number;
	STENCIL_PASS_DEPTH_FAIL: number;
	STENCIL_PASS_DEPTH_PASS: number;
	STENCIL_REF: number;
	STENCIL_VALUE_MASK: number;
	STENCIL_WRITEMASK: number;
	STENCIL_BACK_FUNC: number;
	STENCIL_BACK_FAIL: number;
	STENCIL_BACK_PASS_DEPTH_FAIL: number;
	STENCIL_BACK_PASS_DEPTH_PASS: number;
	STENCIL_BACK_REF: number;
	STENCIL_BACK_VALUE_MASK: number;
	STENCIL_BACK_WRITEMASK: number;
	VIEWPORT: number;
	SCISSOR_BOX: number;
/*      SCISSOR_TEST */

	COLOR_CLEAR_VALUE: number;
	COLOR_WRITEMASK: number;
	UNPACK_ALIGNMENT: number;
	PACK_ALIGNMENT: number;
	MAX_TEXTURE_SIZE: number;
	MAX_VIEWPORT_DIMS: number;
	SUBPIXEL_BITS: number;
	RED_BITS: number;
	GREEN_BITS: number;
	BLUE_BITS: number;
	ALPHA_BITS: number;
	DEPTH_BITS: number;
	STENCIL_BITS: number;
	POLYGON_OFFSET_UNITS: number;
/*      POLYGON_OFFSET_FILL */

	POLYGON_OFFSET_FACTOR: number;
	TEXTURE_BINDING_2D: number;
	SAMPLE_BUFFERS: number;
	SAMPLES: number;
	SAMPLE_COVERAGE_VALUE: number;
	SAMPLE_COVERAGE_INVERT: number;

/* GetTextureParameter */

/*      TEXTURE_MAG_FILTER */

/*      TEXTURE_MIN_FILTER */

/*      TEXTURE_WRAP_S */

/*      TEXTURE_WRAP_T */


	COMPRESSED_TEXTURE_FORMATS: number;

/* HintMode */

	DONT_CARE: number;
	FASTEST: number;
	NICEST: number;

/* HintTarget */

	GENERATE_MIPMAP_HINT: number;

/* DataType */

	BYTE: number;
	UNSIGNED_BYTE: number;
	SHORT: number;
	UNSIGNED_SHORT: number;
	INT: number;
	UNSIGNED_INT: number;
	FLOAT: number;

/* PixelFormat */

	DEPTH_COMPONENT: number;
	ALPHA: number;
	RGB: number;
	RGBA: number;
	LUMINANCE: number;
	LUMINANCE_ALPHA: number;

/* PixelType */

/*      UNSIGNED_BYTE */

	UNSIGNED_SHORT_4_4_4_4: number;
	UNSIGNED_SHORT_5_5_5_1: number;
	UNSIGNED_SHORT_5_6_5: number;

/* Shaders */

	FRAGMENT_SHADER: number;
	VERTEX_SHADER: number;
	MAX_VERTEX_ATTRIBS: number;
	MAX_VERTEX_UNIFORM_VECTORS: number;
	MAX_VARYING_VECTORS: number;
	MAX_COMBINED_TEXTURE_IMAGE_UNITS: number;
	MAX_VERTEX_TEXTURE_IMAGE_UNITS: number;
	MAX_TEXTURE_IMAGE_UNITS: number;
	MAX_FRAGMENT_UNIFORM_VECTORS: number;
	SHADER_TYPE: number;
	DELETE_STATUS: number;
	LINK_STATUS: number;
	VALIDATE_STATUS: number;
	ATTACHED_SHADERS: number;
	ACTIVE_UNIFORMS: number;
	ACTIVE_ATTRIBUTES: number;
	SHADING_LANGUAGE_VERSION: number;
	CURRENT_PROGRAM: number;

/* StencilFunction */

	NEVER: number;
	LESS: number;
	EQUAL: number;
	LEQUAL: number;
	GREATER: number;
	NOTEQUAL: number;
	GEQUAL: number;
	ALWAYS: number;

/* StencilOp */

/*      ZERO */

	KEEP: number;
	REPLACE: number;
	INCR: number;
	DECR: number;
	INVERT: number;
	INCR_WRAP: number;
	DECR_WRAP: number;

/* StringName */

	VENDOR: number;
	RENDERER: number;
	VERSION: number;

/* TextureMagFilter */

	NEAREST: number;
	LINEAR: number;

/* TextureMinFilter */

/*      NEAREST */

/*      LINEAR */

	NEAREST_MIPMAP_NEAREST: number;
	LINEAR_MIPMAP_NEAREST: number;
	NEAREST_MIPMAP_LINEAR: number;
	LINEAR_MIPMAP_LINEAR: number;

/* TextureParameterName */

	TEXTURE_MAG_FILTER: number;
	TEXTURE_MIN_FILTER: number;
	TEXTURE_WRAP_S: number;
	TEXTURE_WRAP_T: number;

/* TextureTarget */

	TEXTURE_2D: number;
	TEXTURE: number;

	TEXTURE_CUBE_MAP: number;
	TEXTURE_BINDING_CUBE_MAP: number;
	TEXTURE_CUBE_MAP_POSITIVE_X: number;
	TEXTURE_CUBE_MAP_NEGATIVE_X: number;
	TEXTURE_CUBE_MAP_POSITIVE_Y: number;
	TEXTURE_CUBE_MAP_NEGATIVE_Y: number;
	TEXTURE_CUBE_MAP_POSITIVE_Z: number;
	TEXTURE_CUBE_MAP_NEGATIVE_Z: number;
	MAX_CUBE_MAP_TEXTURE_SIZE: number;

/* TextureUnit */

	TEXTURE0: number;
	TEXTURE1: number;
	TEXTURE2: number;
	TEXTURE3: number;
	TEXTURE4: number;
	TEXTURE5: number;
	TEXTURE6: number;
	TEXTURE7: number;
	TEXTURE8: number;
	TEXTURE9: number;
	TEXTURE10: number;
	TEXTURE11: number;
	TEXTURE12: number;
	TEXTURE13: number;
	TEXTURE14: number;
	TEXTURE15: number;
	TEXTURE16: number;
	TEXTURE17: number;
	TEXTURE18: number;
	TEXTURE19: number;
	TEXTURE20: number;
	TEXTURE21: number;
	TEXTURE22: number;
	TEXTURE23: number;
	TEXTURE24: number;
	TEXTURE25: number;
	TEXTURE26: number;
	TEXTURE27: number;
	TEXTURE28: number;
	TEXTURE29: number;
	TEXTURE30: number;
	TEXTURE31: number;
	ACTIVE_TEXTURE: number;

/* TextureWrapMode */

	REPEAT: number;
	CLAMP_TO_EDGE: number;
	MIRRORED_REPEAT: number;

/* Uniform Types */

	FLOAT_VEC2: number;
	FLOAT_VEC3: number;
	FLOAT_VEC4: number;
	INT_VEC2: number;
	INT_VEC3: number;
	INT_VEC4: number;
	BOOL: number;
	BOOL_VEC2: number;
	BOOL_VEC3: number;
	BOOL_VEC4: number;
	FLOAT_MAT2: number;
	FLOAT_MAT3: number;
	FLOAT_MAT4: number;
	SAMPLER_2D: number;
	SAMPLER_CUBE: number;

/* Vertex Arrays */

	VERTEX_ATTRIB_ARRAY_ENABLED: number;
	VERTEX_ATTRIB_ARRAY_SIZE: number;
	VERTEX_ATTRIB_ARRAY_STRIDE: number;
	VERTEX_ATTRIB_ARRAY_TYPE: number;
	VERTEX_ATTRIB_ARRAY_NORMALIZED: number;
	VERTEX_ATTRIB_ARRAY_POINTER: number;
	VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: number;

/* Shader Source */

	COMPILE_STATUS: number;

/* Shader Precision-Specified Types */

	LOW_FLOAT: number;
	MEDIUM_FLOAT: number;
	HIGH_FLOAT: number;
	LOW_INT: number;
	MEDIUM_INT: number;
	HIGH_INT: number;

/* Framebuffer Object. */

	FRAMEBUFFER: number;
	RENDERBUFFER: number;

	RGBA4: number;
	RGB5_A1: number;
	RGB565: number;
	DEPTH_COMPONENT16: number;
	STENCIL_INDEX: number;
	STENCIL_INDEX8: number;
	DEPTH_STENCIL: number;

	RENDERBUFFER_WIDTH: number;
	RENDERBUFFER_HEIGHT: number;
	RENDERBUFFER_INTERNAL_FORMAT: number;
	RENDERBUFFER_RED_SIZE: number;
	RENDERBUFFER_GREEN_SIZE: number;
	RENDERBUFFER_BLUE_SIZE: number;
	RENDERBUFFER_ALPHA_SIZE: number;
	RENDERBUFFER_DEPTH_SIZE: number;
	RENDERBUFFER_STENCIL_SIZE: number;

	FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: number;
	FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: number;
	FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: number;
	FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: number;

	COLOR_ATTACHMENT0: number;
	DEPTH_ATTACHMENT: number;
	STENCIL_ATTACHMENT: number;
	DEPTH_STENCIL_ATTACHMENT: number;

	NONE: number;

	FRAMEBUFFER_COMPLETE: number;
	FRAMEBUFFER_INCOMPLETE_ATTACHMENT: number;
	FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: number;
	FRAMEBUFFER_INCOMPLETE_DIMENSIONS: number;
	FRAMEBUFFER_UNSUPPORTED: number;

	FRAMEBUFFER_BINDING: number;
	RENDERBUFFER_BINDING: number;
	MAX_RENDERBUFFER_SIZE: number;

	INVALID_FRAMEBUFFER_OPERATION: number;

/* WebGL-specific enums */

	UNPACK_FLIP_Y_WEBGL: number;
	UNPACK_PREMULTIPLY_ALPHA_WEBGL: number;
	CONTEXT_LOST_WEBGL: number;
	UNPACK_COLORSPACE_CONVERSION_WEBGL: number;
	BROWSER_DEFAULT_WEBGL: number;




	canvas: HTMLCanvasElement;
	drawingBufferWidth: number;
	drawingBufferHeight: number;

	getContextAttributes(): WebGLContextAttributes;
	isContextLost(): bool;

	getSupportedExtensions(): string[];
	getExtension(name: string): any;

	activeTexture(texture: number): void;
	attachShader(program: WebGLProgram, shader: WebGLShader): void;
	bindAttribLocation(program: WebGLProgram, index: number, name: string): void;
	bindBuffer(target: number, buffer: WebGLBuffer): void;
	bindFramebuffer(target: number, framebuffer: WebGLFramebuffer): void;
	bindRenderbuffer(target: number, renderbuffer: WebGLRenderbuffer): void;
	bindTexture(target: number, texture: WebGLTexture): void;
	blendColor(red: number, green: number, blue: number, alpha: number): void;
	blendEquation(mode: number): void;
	blendEquationSeparate(modeRGB: number, modeAlpha: number): void;
	blendFunc(sfactor: number, dfactor: number): void;
	blendFuncSeparate(srcRGB: number, dstRGB: number, srcAlpha: number, dstAlpha: number): void;

	bufferData(target: number, size: number, usage: number): void;
	bufferData(target: number, data: ArrayBufferView, usage: number): void;
	bufferData(target: number, data: ArrayBuffer, usage: number): void;
	bufferSubData(target: number, offset: number, data: ArrayBufferView): void;
	bufferSubData(target: number, offset: number, data: ArrayBuffer): void;

	checkFramebufferStatus(target: number): number;
	clear(mask: number): void;
	clearColor(red: number, green: number, blue: number, alpha: number): void;
	clearDepth(depth: number): void;
	clearStencil(s: number): void;
	colorMask(red: bool, green: bool, blue: bool, alpha: bool): void;
	compileShader(shader: WebGLShader): void;

	compressedTexImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, data: ArrayBufferView): void;
	compressedTexSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, data: ArrayBufferView): void;

	copyTexImage2D(target: number, level: number, internalformat: number, x: number, y: number, width: number, height: number, border: number): void;
	copyTexSubImage2D(target: number, level: number, xoffset: number, yoffset: number, x: number, y: number, width: number, height: number): void;

	createBuffer(): WebGLBuffer;
	createFramebuffer(): WebGLFramebuffer;
	createProgram(): WebGLProgram;
	createRenderbuffer(): WebGLRenderbuffer;
	createShader(type: number): WebGLShader;
	createTexture(): WebGLTexture;

	cullFace(mode: number): void;

	deleteBuffer(buffer: WebGLBuffer): void;
	deleteFramebuffer(framebuffer: WebGLFramebuffer): void;
	deleteProgram(program: WebGLProgram): void;
	deleteRenderbuffer(renderbuffer: WebGLRenderbuffer): void;
	deleteShader(shader: WebGLShader): void;
	deleteTexture(texture: WebGLTexture): void;

	depthFunc(func: number): void;
	depthMask(flag: bool): void;
	depthRange(zNear: number, zFar: number): void;
	detachShader(program: WebGLProgram, shader: WebGLShader): void;
	disable(cap: number): void;
	disableVertexAttribArray(index: number): void;
	drawArrays(mode: number, first: number, count: number): void;
	drawElements(mode: number, count: number, type: number, offset: number): void;

	enable(cap: number): void;
	enableVertexAttribArray(index: number): void;
	finish(): void;
	flush(): void;
	framebufferRenderbuffer(target: number, attachment: number, renderbuffertarget: number, renderbuffer: WebGLRenderbuffer): void;
	framebufferTexture2D(target: number, attachment: number, textarget: number, texture: WebGLTexture, level: number): void;
	frontFace(mode: number): void;

	generateMipmap(target: number): void;

	getActiveAttrib(program: WebGLProgram, index: number): WebGLActiveInfo;
	getActiveUniform(program: WebGLProgram, index: number): WebGLActiveInfo;
	getAttachedShaders(program: WebGLProgram): WebGLShader[];

	getAttribLocation(program: WebGLProgram, name: string): number;

	getBufferParameter(target: number, pname: number): any;
	getParameter(pname: number): any;

	getError(): number;

	getFramebufferAttachmentParameter(target: number, attachment: number, pname: number): any;
	getProgramParameter(program: WebGLProgram, pname: number): any;
	getProgramInfoLog(program: WebGLProgram): string;
	getRenderbufferParameter(target: number, pname: number): any;
	getTranslatedShaderSource(shader: WebGLShader): string;
	getShaderParameter(shader: WebGLShader, pname: number): any;
	getShaderPrecisionFormat(shadertype: number, precisiontype: number): WebGLShaderPrecisionFormat;
	getShaderInfoLog(shader: WebGLShader): string;

	getShaderSource(shader: WebGLShader): string;

	getTexParameter(target: number, pname: number): any;

	getUniform(program: WebGLProgram, location: WebGLUniformLocation): any;

	getUniformLocation(program: WebGLProgram, name: string): WebGLUniformLocation;

	getVertexAttrib(index: number, pname: number): any;

	getVertexAttribOffset(index: number, pname: number): number;

	hint(target: number, mode: number): void;
	isBuffer(buffer: WebGLBuffer): bool;
	isEnabled(cap: number): bool;
	isFramebuffer(framebuffer: WebGLFramebuffer): bool;
	isProgram(program: WebGLProgram): bool;
	isRenderbuffer(renderbuffer: WebGLRenderbuffer): bool;
	isShader(shader: WebGLShader): bool;
	isTexture(texture: WebGLTexture): bool;
	lineWidth(width: number): void;
	linkProgram(program: WebGLProgram): void;
	pixelStorei(pname: number, param: number): void;
	polygonOffset(factor: number, units: number): void;

	readPixels(x: number, y: number, width: number, height: number, format: number, type: number, pixels: ArrayBufferView): void;

	renderbufferStorage(target: number, internalformat: number, width: number, height: number): void;
	sampleCoverage(value: number, invert: bool): void;
	scissor(x: number, y: number, width: number, height: number): void;

	shaderSource(shader: WebGLShader, source: string): void;

	stencilFunc(func: number, ref: number, mask: number): void;
	stencilFuncSeparate(face: number, func: number, ref: number, mask: number): void;
	stencilMask(mask: number): void;
	stencilMaskSeparate(face: number, mask: number): void;
	stencilOp(fail: number, zfail: number, zpass: number): void;
	stencilOpSeparate(face: number, fail: number, zfail: number, zpass: number): void;

	texImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, format: number, type: number, pixels: ArrayBufferView): void;
	texImage2D(target: number, level: number, internalformat: number, format: number, type: number, pixels: ImageData): void;
// May throw DOMException	texImage2D(target: number, level: number, internalformat: number, format: number, type: number, image: HTMLImageElement): void;
// May throw DOMException	texImage2D(target: number, level: number, internalformat: number, format: number, type: number, canvas: HTMLCanvasElement): void;
// May throw DOMException	texImage2D(target: number, level: number, internalformat: number, format: number, type: number, video: HTMLVideoElement): void;

	texParameterf(target: number, pname: number, param: number): void;
	texParameteri(target: number, pname: number, param: number): void;

	texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, type: number, pixels: ArrayBufferView): void;
	texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, pixels: ImageData): void;
// May throw DOMException	texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, image: HTMLImageElement): void;
// May throw DOMException	texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, canvas: HTMLCanvasElement): void;
// May throw DOMException	texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, video: HTMLVideoElement): void;

	uniform1f(location: WebGLUniformLocation, x: number): void;
	uniform1fv(location: WebGLUniformLocation, v: Float32Array): void;
	uniform1fv(location: WebGLUniformLocation, v: number[]): void;
	uniform1i(location: WebGLUniformLocation, x: number): void;
	uniform1iv(location: WebGLUniformLocation, v: Int32Array): void;
	uniform1iv(location: WebGLUniformLocation, v: number[]): void;
	uniform2f(location: WebGLUniformLocation, x: number, y: number): void;
	uniform2fv(location: WebGLUniformLocation, v: Float32Array): void;
	uniform2fv(location: WebGLUniformLocation, v: number[]): void;
	uniform2i(location: WebGLUniformLocation, x: number, y: number): void;
	uniform2iv(location: WebGLUniformLocation, v: Int32Array): void;
	uniform2iv(location: WebGLUniformLocation, v: number[]): void;
	uniform3f(location: WebGLUniformLocation, x: number, y: number, z: number): void;
	uniform3fv(location: WebGLUniformLocation, v: Float32Array): void;
	uniform3fv(location: WebGLUniformLocation, v: number[]): void;
	uniform3i(location: WebGLUniformLocation, x: number, y: number, z: number): void;
	uniform3iv(location: WebGLUniformLocation, v: Int32Array): void;
	uniform3iv(location: WebGLUniformLocation, v: number[]): void;
	uniform4f(location: WebGLUniformLocation, x: number, y: number, z: number, w: number): void;
	uniform4fv(location: WebGLUniformLocation, v: Float32Array): void;
	uniform4fv(location: WebGLUniformLocation, v: number[]): void;
	uniform4i(location: WebGLUniformLocation, x: number, y: number, z: number, w: number): void;
	uniform4iv(location: WebGLUniformLocation, v: Int32Array): void;
	uniform4iv(location: WebGLUniformLocation, v: number[]): void;

	uniformMatrix2fv(location: WebGLUniformLocation, transpose: bool, value: Float32Array): void;
	uniformMatrix2fv(location: WebGLUniformLocation, transpose: bool, value: number[]): void;
	uniformMatrix3fv(location: WebGLUniformLocation, transpose: bool, value: Float32Array): void;
	uniformMatrix3fv(location: WebGLUniformLocation, transpose: bool, value: number[]): void;
	uniformMatrix4fv(location: WebGLUniformLocation, transpose: bool, value: Float32Array): void;
	uniformMatrix4fv(location: WebGLUniformLocation, transpose: bool, value: number[]): void;

	useProgram(program: WebGLProgram): void;
	validateProgram(program: WebGLProgram): void;

	vertexAttrib1f(indx: number, x: number): void;
	vertexAttrib1fv(indx: number, values: Float32Array): void;
	vertexAttrib1fv(indx: number, value: number[]): void;
	vertexAttrib2f(indx: number, x: number, y: number): void;
	vertexAttrib2fv(indx: number, values: Float32Array): void;
	vertexAttrib2fv(indx: number, value: number[]): void;
	vertexAttrib3f(indx: number, x: number, y: number, z: number): void;
	vertexAttrib3fv(indx: number, values: Float32Array): void;
	vertexAttrib3fv(indx: number, value: number[]): void;
	vertexAttrib4f(indx: number, x: number, y: number, z: number, w: number): void;
	vertexAttrib4fv(indx: number, values: Float32Array): void;
	vertexAttrib4fv(indx: number, value: number[]): void;
	vertexAttribPointer(indx: number, size: number, type: number, normalized: bool, stride: number, offset: number): void;

	viewport(x: number, y: number, width: number, height: number): void;
};

interface CanvasRenderingContext {

}

interface WebGLRenderingContext extends CanvasRenderingContext {

}



declare var WebGLRenderingContext: {
    prototype: WebGLRenderingContext;
    new(): WebGLRenderingContext;
}

interface HTMLCanvasElement extends HTMLElement {
    getContext(contextId: string, args?: WebGLContextAttributes): WebGLRenderingContext;
}

interface WEBGL_debug_shaders {
      getTranslatedShaderSource(shader: WebGLShader): DOMString;
};

interface WEBGL_debug_renderer_info {
    UNMASKED_VENDOR_WEBGL: number;
    UNMASKED_RENDERER_WEBGL: number;
};

interface WEBGL_compressed_texture_pvrtc {
/* Compressed Texture Formats */

    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: number;
    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: number;
    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: number;
    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: number;
};

interface WEBGL_compressed_texture_atc {
/* Compressed Texture Formats */

    COMPRESSED_RGB_ATC_WEBGL: number;
    COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: number;
    COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: number;
};

interface WEBGL_compressed_texture_s3tc {
/* Compressed Texture Formats */

    COMPRESSED_RGB_S3TC_DXT1_EXT : number;
    COMPRESSED_RGBA_S3TC_DXT1_EXT: number;
    COMPRESSED_RGBA_S3TC_DXT3_EXT: number;
    COMPRESSED_RGBA_S3TC_DXT5_EXT: number;
};

interface WEBGL_depth_texture {
  UNSIGNED_INT_24_8_WEBGL: number;
};

interface OES_element_index_uint {
};

interface WebGLVertexArrayObjectOES extends WebGLObject {
};

interface OES_vertex_array_object {
    VERTEX_ARRAY_BINDING_OES: number;

    createVertexArrayOES(): WebGLVertexArrayObjectOES;
    deleteVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES): void;
    isVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES): bool;
    bindVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES): void;
};

interface OES_standard_derivatives {
    FRAGMENT_SHADER_DERIVATIVE_HINT_OES: number;
};

interface OES_texture_half_float {
 	HALF_FLOAT_OES: number;
};

interface OES_texture_float {
};

interface WEBGL_lose_context {
      loseContext(): void;
      restoreContext(): void;
};

interface WEBGL_multiple_render_targets {
    COLOR_ATTACHMENT0_WEBGL: number;
    COLOR_ATTACHMENT1_WEBGL: number;
    COLOR_ATTACHMENT2_WEBGL: number;
    COLOR_ATTACHMENT3_WEBGL: number;
    COLOR_ATTACHMENT4_WEBGL: number;
    COLOR_ATTACHMENT5_WEBGL: number;
    COLOR_ATTACHMENT6_WEBGL: number;
    COLOR_ATTACHMENT7_WEBGL: number;
    COLOR_ATTACHMENT8_WEBGL: number;
    COLOR_ATTACHMENT9_WEBGL: number;
    COLOR_ATTACHMENT10_WEBGL: number;
    COLOR_ATTACHMENT11_WEBGL: number;
    COLOR_ATTACHMENT12_WEBGL: number;
    COLOR_ATTACHMENT13_WEBGL: number;
    COLOR_ATTACHMENT14_WEBGL: number;
    COLOR_ATTACHMENT15_WEBGL: number;

    DRAW_BUFFER0_WEBGL: number;
    DRAW_BUFFER1_WEBGL: number;
    DRAW_BUFFER2_WEBGL: number;
    DRAW_BUFFER3_WEBGL: number;
    DRAW_BUFFER4_WEBGL: number;
    DRAW_BUFFER5_WEBGL: number;
    DRAW_BUFFER6_WEBGL: number;
    DRAW_BUFFER7_WEBGL: number;
    DRAW_BUFFER8_WEBGL: number;
    DRAW_BUFFER9_WEBGL: number;
    DRAW_BUFFER10_WEBGL: number;
    DRAW_BUFFER11_WEBGL: number;
    DRAW_BUFFER12_WEBGL: number;
    DRAW_BUFFER13_WEBGL: number;
    DRAW_BUFFER14_WEBGL: number;
    DRAW_BUFFER15_WEBGL: number;

    MAX_COLOR_ATTACHMENTS_WEBGL: number;
    MAX_DRAW_BUFFERS_WEBGL: number;

    drawBuffersWEBGL(buffers: number[]): void;
};

interface WEBGL_fbo_color_attachments {
    COLOR_ATTACHMENT0: number;
    COLOR_ATTACHMENT1: number;
    COLOR_ATTACHMENT2: number;
    COLOR_ATTACHMENT3: number;
    COLOR_ATTACHMENT4: number;
    COLOR_ATTACHMENT5: number;
    COLOR_ATTACHMENT6: number;
    COLOR_ATTACHMENT7: number;
    COLOR_ATTACHMENT8: number;
    COLOR_ATTACHMENT9: number;
    COLOR_ATTACHMENT10: number;
    COLOR_ATTACHMENT11: number;
    COLOR_ATTACHMENT12: number;
    COLOR_ATTACHMENT13: number;
    COLOR_ATTACHMENT14: number;
    COLOR_ATTACHMENT15: number;

    MAX_COLOR_ATTACHMENTS: number;
};

/* ClearBufferMask */





/* BeginMode */









/* AlphaFunction (not supported in ES20) */

/*      NEVER */

/*      LESS */

/*      EQUAL */

/*      LEQUAL */

/*      GREATER */

/*      NOTEQUAL */

/*      GEQUAL */

/*      ALWAYS */


/* BlendingFactorDest */










/* BlendingFactorSrc */

/*      ZERO */

/*      ONE */




/*      SRC_ALPHA */

/*      ONE_MINUS_SRC_ALPHA */

/*      DST_ALPHA */

/*      ONE_MINUS_DST_ALPHA */


/* BlendEquationSeparate */



/* same as BLEND_EQUATION */



/* BlendSubtract */




/* Separate Blend Functions */











/* Buffer Objects */















/* CullFaceMode */





/* DepthFunction */

/*      NEVER */

/*      LESS */

/*      EQUAL */

/*      LEQUAL */

/*      GREATER */

/*      NOTEQUAL */

/*      GEQUAL */

/*      ALWAYS */


/* EnableCap */

/* TEXTURE_2D */











/* ErrorCode */







/* FrontFaceDirection */




/* GetPName */



























/*      SCISSOR_TEST */















/*      POLYGON_OFFSET_FILL */








/* GetTextureParameter */

/*      TEXTURE_MAG_FILTER */

/*      TEXTURE_MIN_FILTER */

/*      TEXTURE_WRAP_S */

/*      TEXTURE_WRAP_T */




/* HintMode */





/* HintTarget */



/* DataType */










/* PixelFormat */










/* PixelType */

/*      UNSIGNED_BYTE */





/* Shaders */




















/* StencilFunction */










/* StencilOp */

/*      ZERO */









/* StringName */





/* TextureMagFilter */




/* TextureMinFilter */

/*      NEAREST */

/*      LINEAR */






/* TextureParameterName */






/* TextureTarget */














/* TextureUnit */



































/* TextureWrapMode */





/* Uniform Types */

















/* Vertex Arrays */









/* Shader Source */



/* Shader Precision-Specified Types */








/* Framebuffer Object. */














































/* WebGL-specific enums */





























//WebGL Extensions 










//draft









//Future















module akra {
	export interface IColor {} ;

	export interface IPixelBox extends IBox {
		format: EPixelFormats;
		data: Uint8Array;
		rowPitch:  number ;
		slicePitch:  number ;

		setConsecutive(): void;

		getRowSkip():  number ;
		getSliceSkip():  number ;

		isConsecutive(): bool;
		getConsecutiveSize():  number ;

		getSubBox(pDest: IBox): IPixelBox;
		getColorAt(x:  number , y:  number , z?:  number ): IColor;
		setColorAt(pColor: IColor, x:  number , y:  number , z?:  number ): void;

		scale(pDest: IPixelBox, eFilter?: EFilters): bool;
	}
}





















module akra.webgl {
	export var maxTextureSize:  number  = 0;
	export var maxCubeMapTextureSize:  number  = 0;
	export var maxViewPortSize:  number  = 0;

	export var maxTextureImageUnits:  number  = 0;
	export var maxVertexAttributes:  number  = 0;
	export var maxVertexTextureImageUnits:  number  = 0;
	export var maxCombinedTextureImageUnits:  number  = 0;

	export var maxColorAttachments:  number  = 1;

	export var stencilBits:  number  = 0;
	export var colorBits:  number [] = [0, 0, 0];
	export var alphaBits:  number  = 0;
	export var multisampleType:  number  = 0.;

	export var shaderVersion:  number  = 0;
	export var hasNonPowerOf2Textures: bool = false;

	var pSupportedExtensionList: string[] = null;
	var pLoadedExtensionList: Object = null;

    export function createContext(
            pCanvas: HTMLCanvasElement = <HTMLCanvasElement>document.createElement("canvas"),
            pOptions?: { antialias?: bool; }): WebGLRenderingContext {

    	var pWebGLContext: WebGLRenderingContext = null;

		try {
			pWebGLContext = pCanvas.getContext("webgl", pOptions) ||
				pCanvas.getContext("experimental-webgl", pOptions);
    	}
		catch (e) {}

		if (!pWebGLContext) {
			logger.setSourceLocation( "webgl/webgl.ts" , 58 ); logger.warning("cannot get 3d device"); ;
		}

		return pWebGLContext;
    }

	(function (pWebGLContext: WebGLRenderingContext): void {
		if (!pWebGLContext) {
			return;
		}

		maxTextureSize 					= pWebGLContext.getParameter( 0x0D33 );
		maxCubeMapTextureSize 			= pWebGLContext.getParameter( 0x851C );
		maxViewPortSize 				= pWebGLContext.getParameter( 0x0D3A );

		maxTextureImageUnits 			= pWebGLContext.getParameter( 0x8872 );
		maxVertexAttributes 			= pWebGLContext.getParameter( 0x8869 );
		maxVertexTextureImageUnits 		= pWebGLContext.getParameter( 0x8B4C );
		maxCombinedTextureImageUnits 	= pWebGLContext.getParameter( 0x8B4D );

		stencilBits 					= pWebGLContext.getParameter( 0x0D57 );
		colorBits 						= [
									        pWebGLContext.getParameter( 0x0D52 ),
									        pWebGLContext.getParameter( 0x0D53 ),
									        pWebGLContext.getParameter( 0x0D54 )
	   									];

	    alphaBits 						= pWebGLContext.getParameter( 0x0D55 );
	    multisampleType 				= pWebGLContext.getParameter( 0x80AA );

	    pSupportedExtensionList 		= pWebGLContext.getSupportedExtensions();


	    pSupportedExtensionList.push( "WEBGL_debug_shaders" ,  "WEBGL_debug_renderer_info" );

	    var pWebGLExtentionList: Object = {};
	    var pWebGLExtension: Object;

	    for (var i:  number  = 0; i < pSupportedExtensionList.length; ++ i) {
	        if (pWebGLExtension = pWebGLContext.getExtension(pSupportedExtensionList[i])) {
	            pWebGLExtentionList[pSupportedExtensionList[i]] = pWebGLExtension;

	            logger.setSourceLocation( "webgl/webgl.ts" , 100 ); logger.log("loaded WebGL extension: %1", pSupportedExtensionList[i]); ;

	            for (var j in pWebGLExtension) {
	                if (isFunction(pWebGLExtension[j])) {

	                    pWebGLContext[j] = function () {
	                        pWebGLContext[j] = new Function(
	                            "var t = this.pWebGLExtentionList[" + pSupportedExtensionList[i] + "];" +
	                            "t." + j + ".apply(t, arguments);");
	                    }

	                }
	                else {
	                    pWebGLContext[j] = pWebGLExtentionList[pSupportedExtensionList[i]][j];
	                }
	            }
	        }
	        else {
	            logger.setSourceLocation( "webgl/webgl.ts" , 118 ); logger.warning("cannot load extension: %1", pSupportedExtensionList[i]); ;
	            pSupportedExtensionList.splice(i, 1);
	        }
	    }


	    (<any>pWebGLContext).pWebGLExtentionList = pWebGLExtentionList;
	    pLoadedExtensionList = pWebGLExtentionList;

	})(createContext());

	export function hasExtension(sExtName: string): bool {
        for (var i:  number  = 0; i < pSupportedExtensionList.length; ++ i) {
            if (pSupportedExtensionList[i].search(sExtName) != -1) {
                return true;
            }
        }

        return false;
	}

	export function getWebGLUsage(iFlags:  number ):  number  {
		if ( (((iFlags) & (EHardwareBufferFlags.DYNAMIC)) != 0) ) {
	        return  0x88E8 ;
	    }
	    else if ( (((iFlags) & (EHardwareBufferFlags.STREAM)) != 0) ) {
	        return  0x88E0 ;
	    }

	    return  0x88E4 ;
	}

	export function getWebGLOriginFormat(eFormat: EPixelFormats):  number  {
		switch(eFormat){
			case EPixelFormats.A8:
                return  0x1906 ;

            case EPixelFormats.L8:
            case EPixelFormats.L16:
                return  0x1909 ;

            case EPixelFormats.FLOAT16_RGB:
            	return webgl.hasExtension( "OES_texture_half_float" ) ?  0x1907  : 0;

            case EPixelFormats.FLOAT16_RGBA:
            	return webgl.hasExtension( "OES_texture_half_float" ) ?  0x1908  : 0;

           	case EPixelFormats.FLOAT16_R:
            case EPixelFormats.R8:
                return webgl.hasExtension( "EXT_texture_rg" ) ?  0x1903  : 0;

            case EPixelFormats.FLOAT16_GR:
            case EPixelFormats.RG8:
                return webgl.hasExtension( "EXT_texture_rg" ) ?  0x8227  : 0;

            case EPixelFormats.BYTE_LA:
            case EPixelFormats.SHORT_GR:
                return  0x190A ;

// PVRTC compressed formats
            case EPixelFormats.PVRTC_RGB2:
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ?  0x8C01  : 0;
            case EPixelFormats.PVRTC_RGB4:
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ?  0x8C00  : 0;
            case EPixelFormats.PVRTC_RGBA2:
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ?  0x8C03  : 0;
            case EPixelFormats.PVRTC_RGBA4:
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ?  0x8C02  : 0;

            case EPixelFormats.R5G6B5:
            case EPixelFormats.B5G6R5:
            case EPixelFormats.R8G8B8:
            case EPixelFormats.B8G8R8:
                return  0x1907 ;

            case EPixelFormats.A1R5G5B5:
                return  0x80E1 ;

            case EPixelFormats.A4R4G4B4:
            case EPixelFormats.X8R8G8B8:
            case EPixelFormats.A8R8G8B8:
            case EPixelFormats.B8G8R8A8:
            case EPixelFormats.X8B8G8R8:
            case EPixelFormats.A8B8G8R8:
                return  0x1908 ;

            case EPixelFormats.DXT1:
                return webgl.hasExtension( "WEBGL_compressed_texture_s3tc" ) ?  0x83F1  : 0;

            case EPixelFormats.DXT3:
                return webgl.hasExtension( "WEBGL_compressed_texture_s3tc" ) ?  0x83F2  : 0;

            case EPixelFormats.DXT5:
                return webgl.hasExtension( "WEBGL_compressed_texture_s3tc" ) ?  0x83F3  : 0;

            case EPixelFormats.FLOAT32_GR:
            case EPixelFormats.FLOAT32_R:

            default:
                return 0;
        }

	}

	export function getWebGLOriginDataType(eFormat: EPixelFormats):  number  {
		switch(eFormat){
			case EPixelFormats.A8:
            case EPixelFormats.L8:
            case EPixelFormats.L16:
            case EPixelFormats.R8G8B8:
            case EPixelFormats.B8G8R8:
            case EPixelFormats.BYTE_LA:
                return  0x1401 ;
            case EPixelFormats.R5G6B5:
            case EPixelFormats.B5G6R5:
                return  0x8363 ;
            case EPixelFormats.A4R4G4B4:
				return  0x8033 ;
            case EPixelFormats.A1R5G5B5:
                return  0x8034 ;

            case EPixelFormats.X8B8G8R8:
            case EPixelFormats.A8B8G8R8:
                return  0x8367 ;
            case EPixelFormats.X8R8G8B8:
            case EPixelFormats.A8B8G8R8:
            case EPixelFormats.A8R8G8B8:
                return  0x8367 ;
            case EPixelFormats.B8G8R8A8:
                return  0x1401 ;
            case EPixelFormats.R8G8B8A8:
                return  0x1401 ;

            case EPixelFormats.FLOAT16_R:
            case EPixelFormats.FLOAT16_GR:
            case EPixelFormats.FLOAT16_RGB:
            case EPixelFormats.FLOAT16_RGBA:
                return webgl.hasExtension( "OES_texture_half_float" ) ?  0x8D61  : 0;

            case EPixelFormats.R8:
            case EPixelFormats.RG8:
                return webgl.hasExtension( "EXT_texture_rg" ) ?  0x1401  : 0;

            case EPixelFormats.FLOAT32_R:
            case EPixelFormats.FLOAT32_GR:
            case EPixelFormats.FLOAT32_RGB:
            case EPixelFormats.FLOAT32_RGBA:
                return  0x1406 ;
            case EPixelFormats.DXT1:
            case EPixelFormats.DXT3:
            case EPixelFormats.DXT5:
            case EPixelFormats.R3G3B2:
            case EPixelFormats.A2R10G10B10:
            case EPixelFormats.A2B10G10R10:
            case EPixelFormats.SHORT_RGBA:
            case EPixelFormats.SHORT_RGB:
            case EPixelFormats.SHORT_GR:
// TODO not supported
            default:
                return 0;
		}
	}



	export function getWebGLInternalFormat(eFormat: EPixelFormats, isHWGamma: bool = false):  number  {
        switch (eFormat) {
            case EPixelFormats.L8:
            case EPixelFormats.L16:
                return  0x1909 ;

            case EPixelFormats.A8:
                return  0x1906 ;

            case EPixelFormats.BYTE_LA:
                return  0x190A ;

            case EPixelFormats.PVRTC_RGB2:
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ?  0x8C01  : 0;
            case EPixelFormats.PVRTC_RGB4:
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ?  0x8C00  : 0;
            case EPixelFormats.PVRTC_RGBA2:
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ?  0x8C03  : 0;
            case EPixelFormats.PVRTC_RGBA4:
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ?  0x8C02  : 0;

            case EPixelFormats.X8B8G8R8:
            case EPixelFormats.X8R8G8B8:
			case EPixelFormats.A8B8G8R8:
            case EPixelFormats.A8R8G8B8:
            case EPixelFormats.B8G8R8A8:
            case EPixelFormats.A1R5G5B5:
            case EPixelFormats.A4R4G4B4:
                return  0x1908 ;
            case EPixelFormats.R5G6B5:
            case EPixelFormats.B5G6R5:
            case EPixelFormats.R8G8B8:
            case EPixelFormats.B8G8R8:
                return  0x1907 ;

            case EPixelFormats.FLOAT16_R:
            case EPixelFormats.FLOAT32_R:
            case EPixelFormats.R8:
                return webgl.hasExtension( "EXT_texture_rg" ) ?  0x1903  : 0;
            case EPixelFormats.FLOAT16_GR:
            case EPixelFormats.FLOAT32_GR:
            case EPixelFormats.RG8:
                return webgl.hasExtension( "EXT_texture_rg" ) ?  0x1903  : 0;

            case EPixelFormats.A4L4:
            case EPixelFormats.R3G3B2:
            case EPixelFormats.A2R10G10B10:
            case EPixelFormats.A2B10G10R10:
            case EPixelFormats.FLOAT16_RGBA:
            case EPixelFormats.FLOAT32_RGB:
            case EPixelFormats.FLOAT32_RGBA:
            case EPixelFormats.SHORT_RGBA:
            case EPixelFormats.SHORT_RGB:
            case EPixelFormats.SHORT_GR:

			case EPixelFormats.DXT1:
				if (!isHWGamma)
					return webgl.hasExtension( "WEBGL_compressed_texture_s3tc" ) ?  0x83F1  : 0;
            case EPixelFormats.DXT3:
				if (!isHWGamma)
	                return webgl.hasExtension( "WEBGL_compressed_texture_s3tc" ) ?  0x83F2  : 0;
            case EPixelFormats.DXT5:
				if (!isHWGamma)
	                return webgl.hasExtension( "WEBGL_compressed_texture_s3tc" ) ?  0x83F2  : 0;

            default:
                return 0;
        }
    }

    export function getWebGLPrimitiveType(eType: EPrimitiveTypes):  number  {
        switch (eType) {
            case EPrimitiveTypes.POINTLIST:
                return  0x0000 ;
            case EPrimitiveTypes.LINELIST:
                return  0x0001 ;
            case EPrimitiveTypes.LINELOOP:
                return  0x0002 ;
            case EPrimitiveTypes.LINESTRIP:
                return  0x0003 ;
            case EPrimitiveTypes.TRIANGLELIST:
                return  0x0004 ;
            case EPrimitiveTypes.TRIANGLESTRIP:
                return  0x0005 ;
            case EPrimitiveTypes.TRIANGLEFAN:
                return  0x0006 ;
        }

        return  0x0000 ;
    }

    export function getClosestWebGLInternalFormat(eFormat: EPixelFormats, isHWGamma: bool = false):  number  {
        var iGLFormat = webgl.getWebGLInternalFormat(eFormat, isHWGamma);

        if (iGLFormat ===  0 ) {
            if (isHWGamma) {
// TODO not supported
                return 0;
            }
            else {
                return  0x1908 ;
            }
        }
        else {
            return iGLFormat;
        }
    }

    export function getClosestAkraFormat(iGLFormat:  number , iGLDataType:  number ): EPixelFormats {
        switch (iGLFormat) {

            case  0x8C01 :
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ? EPixelFormats.PVRTC_RGB2 : EPixelFormats.A8R8G8B8;
            case  0x8C03 :
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ? EPixelFormats.PVRTC_RGBA2 : EPixelFormats.A8R8G8B8;
            case  0x8C00 :
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ? EPixelFormats.PVRTC_RGB4 : EPixelFormats.A8R8G8B8;
            case  0x8C02 :
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ? EPixelFormats.PVRTC_RGBA4 : EPixelFormats.A8R8G8B8;

            case  0x1909 :
                return EPixelFormats.L8;
            case  0x1906 :
                return EPixelFormats.A8;
            case  0x190A :
                return EPixelFormats.BYTE_LA;

            case  0x1907 :
                switch(iGLDataType) {
	                case  0x8363 :
	                    return EPixelFormats.B5G6R5;
	                default:
	                    return EPixelFormats.R8G8B8;
            	};
            case  0x1908 :
                switch(iGLDataType) {
	                case  0x8034 :
	                    return EPixelFormats.A1R5G5B5;
	                case  0x8033 :
	                    return EPixelFormats.A4R4G4B4;
	                default:
	                    return EPixelFormats.A8B8G8R8;
	            }

            case  0x80E1 :
                return EPixelFormats.A8B8G8R8;

            case  0x83F0 :
            case  0x83F1 :
                return webgl.hasExtension( "WEBGL_compressed_texture_s3tc" ) ? EPixelFormats.DXT1 : EPixelFormats.A8R8G8B8;

            case  0x83F2 :
                return webgl.hasExtension( "WEBGL_compressed_texture_s3tc" ) ? EPixelFormats.DXT3 : EPixelFormats.A8R8G8B8;
            case  0x83F3 :
                return webgl.hasExtension( "WEBGL_compressed_texture_s3tc" ) ? EPixelFormats.DXT5 : EPixelFormats.A8R8G8B8;

            case  0x8229 :
                return webgl.hasExtension( "EXT_texture_rg" ) ? EPixelFormats.R8 : EPixelFormats.A8R8G8B8;
            case  0x822B :
                return webgl.hasExtension( "EXT_texture_rg" ) ? EPixelFormats.RG8 : EPixelFormats.A8R8G8B8;

            default:
//TODO: not supported
                return EPixelFormats.A8R8G8B8;
        };
    }

    export function getMaxMipmaps(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats) :  number  {
		var iCount:  number  = 0;
        if((iWidth > 0) && (iHeight > 0)) {
            do {
                if(iWidth>1)		iWidth = iWidth/2;
                if(iHeight>1)		iHeight = iHeight/2;
                if(iDepth>1)		iDepth = iDepth/2;
/*
                 NOT needed, compressed formats will have mipmaps up to 1x1
                 if(PixelUtil::isValidExtent(width, height, depth, format))
                 count ++;
                 else
                 break;
                 */


                iCount ++;
            } while(!(iWidth === 1 && iHeight === 1 && iDepth === 1));
        }
		return iCount;
    }

    export function optionalPO2(iValue:  number ) :  number  {
        if (webgl.hasNonPowerOf2Textures) {
            return iValue;
        }
        else {
            return math.ceilingPowerOfTwo(< number >iValue);
        }
    }


	export function convertToWebGLformat(pSource: IPixelBox, pDest: IPixelBox): void {
// Always need to convert PF_A4R4G4B4, GL expects the colors to be in the 
// reverse order
        if (pDest.format == EPixelFormats.A4R4G4B4) {
// Convert PF_A4R4G4B4 -> PF_B4G4R4A4
// Reverse pixel order
            var iSrcPtr:  number  = (pSource.left + pSource.top * pSource.rowPitch + pSource.front * pSource.slicePitch);
            var iDstPtr:  number  = (pDest.left + pDest.top * pDest.rowPitch + pDest.front * pDest.slicePitch);
            var iSrcSliceSkip:  number  = pSource.getSliceSkip();
            var iDstSliceSkip:  number  = pDest.getSliceSkip();
            var k:  number  = pSource.right - pSource.left;
            var x:  number  = 0,
            	y:  number  = 0,
            	z:  number  = 0;

            for(z = pSource.front; z < pSource.back; z++) {
                for(y = pSource.top; y < pSource.bottom; y++) {
                    for(x = 0; x < k; x++) {
// B                        pDest[iDstPtr + x] = ((pSource[iSrcPtr + x]&0x000F)<<12) |
// G                                    		 ((pSource[iSrcPtr + x]&0x00F0)<<4)  |
// R                                    		 ((pSource[iSrcPtr + x]&0x0F00)>>4)  |
// A                                    	     ((pSource[iSrcPtr + x]&0xF000)>>12);
                    }

                    iSrcPtr += pSource.rowPitch;
                    iDstPtr += pDest.rowPitch;
                }

                iSrcPtr += iSrcSliceSkip;
                iDstPtr += iDstSliceSkip;
            }
        }
	}

	export function checkFBOAttachmentFormat(eFormat: EPixelFormats): bool {
		return false;
	}

	export function getSupportedAlternative(eFormat: EPixelFormats): EPixelFormats {
		if (checkFBOAttachmentFormat(eFormat)) {
            return eFormat;
        }

/// Find first alternative
        var pct: EPixelComponentTypes = pixelUtil.getComponentType(eFormat);

        switch (pct) {
            case EPixelComponentTypes.BYTE:
                eFormat = EPixelFormats.A8R8G8B8;
                break;
            case EPixelComponentTypes.SHORT:
                eFormat = EPixelFormats.SHORT_RGBA;
                break;
            case EPixelComponentTypes.FLOAT16:
                eFormat = EPixelFormats.FLOAT16_RGBA;
                break;
            case EPixelComponentTypes.FLOAT32:
                eFormat = EPixelFormats.FLOAT32_RGBA;
                break;
            case EPixelComponentTypes.COUNT:
            default:
                break;
        }

        if (checkFBOAttachmentFormat(eFormat)){
            return eFormat;
        }

/// If none at all, return to default
		return EPixelFormats.A8R8G8B8;
	}

}



































module akra {

	export interface IPixelFormatDescription {
/* Name of the format, as in the enum */

        name: string;
/* Number of bytes one element (colour value) takes. */

        elemBytes:  number ;
/* Pixel format flags, see enum PixelFormatFlags for the bit field
        * definitions
        */

        flags:  number ;
/** Component type
         */

        componentType: EPixelComponentTypes;
/** Component count
         */

        componentCount:  number ;
/* Number of bits for red(or luminance), green, blue, alpha
        */

        rbits:  number ;
        gbits:  number ;
        bbits:  number ;
/*, ibits, dbits, ... */
        abits:  number ;

/* Masks and shifts as used by packers/unpackers */

        rmask:  number ;
        gmask:  number ;
        bmask:  number ;
        amask:  number ;

        rshift:  number ;
        gshift:  number ;
        bshift:  number ;
        ashift:  number ;
	}


	function fillPixelFormats(pData: any[][]): IPixelFormatDescription[] {
		var pPixelFormats: IPixelFormatDescription[] = [];

		for (var i:  number  = 0; i < pData.length; ++ i) {
			var pEl: any[] = pData[i];
			pPixelFormats.push({
					name: 			<string>pEl[0],
					elemBytes: 		< number >	pEl[1],
					flags: 			< number >	pEl[2],
					componentType: 	<EPixelComponentTypes>pEl[3],
					componentCount: < number >	pEl[4],

					rbits: < number >pEl[5],
					gbits: < number >pEl[6],
					bbits: < number >pEl[7],
					abits: < number >pEl[8],

					rmask: < number >pEl[9],
					gmask: < number >pEl[10],
					bmask: < number >pEl[11],
					amask: < number >pEl[12],

					rshift: < number >pEl[13],
					gshift: < number >pEl[14],
					bshift: < number >pEl[15],
					ashift: < number >pEl[16]
				});
		}

		return pPixelFormats;
	}

	var pPixelFormats: IPixelFormatDescription[] = fillPixelFormats([
		["PF_UNKNOWN",
/* Bytes per element */

        0,
/* Flags */

        0,
/* Component type and count */

        EPixelComponentTypes.BYTE, 0,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_L8",
/* Bytes per element */

        1,
/* Flags */

        EPixelFormatFlags.LUMINANCE | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 1,
/* rbits, gbits, bbits, abits */

        8, 0, 0, 0,
/* Masks and shifts */

        0xFF, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_L16",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.LUMINANCE | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.SHORT, 1,
/* rbits, gbits, bbits, abits */

        16, 0, 0, 0,
/* Masks and shifts */

        0xFFFF, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_A8",
/* Bytes per element */

        1,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 1,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 8,
/* Masks and shifts */

        0, 0, 0, 0xFF, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_A4L4",
/* Bytes per element */

        1,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.LUMINANCE | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 2,
/* rbits, gbits, bbits, abits */

        4, 0, 0, 4,
/* Masks and shifts */

        0x0F, 0, 0, 0xF0, 0, 0, 0, 4
        ],
//-----------------------------------------------------------------------
        ["PF_BYTE_LA",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.LUMINANCE,
/* Component type and count */

        EPixelComponentTypes.BYTE, 2,
/* rbits, gbits, bbits, abits */

        8, 0, 0, 8,
/* Masks and shifts */

        0,0,0,0,0,0,0,0
        ],
//-----------------------------------------------------------------------
        ["PF_R5G6B5",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        5, 6, 5, 0,
/* Masks and shifts */

        0xF800, 0x07E0, 0x001F, 0,
        11, 5, 0, 0
        ],
//-----------------------------------------------------------------------
		["PF_B5G6R5",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        5, 6, 5, 0,
/* Masks and shifts */

        0x001F, 0x07E0, 0xF800, 0,
        0, 5, 11, 0
        ],
//-----------------------------------------------------------------------
        ["PF_A4R4G4B4",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        4, 4, 4, 4,
/* Masks and shifts */

        0x0F00, 0x00F0, 0x000F, 0xF000,
        8, 4, 0, 12
        ],
//-----------------------------------------------------------------------
        ["PF_A1R5G5B5",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        5, 5, 5, 1,
/* Masks and shifts */

        0x7C00, 0x03E0, 0x001F, 0x8000,
        10, 5, 0, 15,
        ],
//-----------------------------------------------------------------------
        ["PF_R8G8B8",
/* Bytes per element */

// 24 bit integer -- special        3,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 0,
/* Masks and shifts */

        0xFF0000, 0x00FF00, 0x0000FF, 0,
        16, 8, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_B8G8R8",
/* Bytes per element */

// 24 bit integer -- special        3,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 0,
/* Masks and shifts */

        0x0000FF, 0x00FF00, 0xFF0000, 0,
        0, 8, 16, 0
        ],
//-----------------------------------------------------------------------
        ["PF_A8R8G8B8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 8,
/* Masks and shifts */

        0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000,
        16, 8, 0, 24
        ],
//-----------------------------------------------------------------------
        ["PF_A8B8G8R8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 8,
/* Masks and shifts */

        0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000,
        0, 8, 16, 24,
        ],
//-----------------------------------------------------------------------
        ["PF_B8G8R8A8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 8,
/* Masks and shifts */

        0x0000FF00, 0x00FF0000, 0xFF000000, 0x000000FF,
        8, 16, 24, 0
        ],
//-----------------------------------------------------------------------
        ["PF_A2R10G10B10",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        10, 10, 10, 2,
/* Masks and shifts */

        0x3FF00000, 0x000FFC00, 0x000003FF, 0xC0000000,
        20, 10, 0, 30
        ],
//-----------------------------------------------------------------------
        ["PF_A2B10G10R10",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        10, 10, 10, 2,
/* Masks and shifts */

        0x000003FF, 0x000FFC00, 0x3FF00000, 0xC0000000,
        0, 10, 20, 30
        ],
//-----------------------------------------------------------------------
        ["PF_DXT1",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

// No alpha        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_DXT2",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_DXT3",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_DXT4",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_DXT5",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_FLOAT16_RGB",
/* Bytes per element */

        6,
/* Flags */

        EPixelFormatFlags.FLOAT,
/* Component type and count */

        EPixelComponentTypes.FLOAT16, 3,
/* rbits, gbits, bbits, abits */

        16, 16, 16, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_FLOAT16_RGBA",
/* Bytes per element */

        8,
/* Flags */

        EPixelFormatFlags.FLOAT | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.FLOAT16, 4,
/* rbits, gbits, bbits, abits */

        16, 16, 16, 16,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_FLOAT32_RGB",
/* Bytes per element */

        12,
/* Flags */

        EPixelFormatFlags.FLOAT,
/* Component type and count */

        EPixelComponentTypes.FLOAT32, 3,
/* rbits, gbits, bbits, abits */

        32, 32, 32, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_FLOAT32_RGBA",
/* Bytes per element */

        16,
/* Flags */

        EPixelFormatFlags.FLOAT | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.FLOAT32, 4,
/* rbits, gbits, bbits, abits */

        32, 32, 32, 32,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_X8R8G8B8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 0,
/* Masks and shifts */

        0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000,
        16, 8, 0, 24
        ],
//-----------------------------------------------------------------------
        ["PF_X8B8G8R8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 0,
/* Masks and shifts */

        0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000,
        0, 8, 16, 24
        ],
//-----------------------------------------------------------------------
        ["PF_R8G8B8A8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 8,
/* Masks and shifts */

        0xFF000000, 0x00FF0000, 0x0000FF00, 0x000000FF,
        24, 16, 8, 0
        ],
//-----------------------------------------------------------------------
		["PF_DEPTH",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.DEPTH,
/* Component type and count */

// ?        EPixelComponentTypes.FLOAT32, 1,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

		0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
		["PF_SHORT_RGBA",
/* Bytes per element */

        8,
/* Flags */

        EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.SHORT, 4,
/* rbits, gbits, bbits, abits */

        16, 16, 16, 16,
/* Masks and shifts */

		0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_R3G3B2",
/* Bytes per element */

        1,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        3, 3, 2, 0,
/* Masks and shifts */

        0xE0, 0x1C, 0x03, 0,
        5, 2, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_FLOAT16_R",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.FLOAT,
/* Component type and count */

        EPixelComponentTypes.FLOAT16, 1,
/* rbits, gbits, bbits, abits */

        16, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_FLOAT32_R",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.FLOAT,
/* Component type and count */

        EPixelComponentTypes.FLOAT32, 1,
/* rbits, gbits, bbits, abits */

        32, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_SHORT_GR",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.SHORT, 2,
/* rbits, gbits, bbits, abits */

        16, 16, 0, 0,
/* Masks and shifts */

        0x0000FFFF, 0xFFFF0000, 0, 0,
		0, 16, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_FLOAT16_GR",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.FLOAT,
/* Component type and count */

        EPixelComponentTypes.FLOAT16, 2,
/* rbits, gbits, bbits, abits */

        16, 16, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_FLOAT32_GR",
/* Bytes per element */

        8,
/* Flags */

        EPixelFormatFlags.FLOAT,
/* Component type and count */

        EPixelComponentTypes.FLOAT32, 2,
/* rbits, gbits, bbits, abits */

        32, 32, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
		["PF_SHORT_RGB",
/* Bytes per element */

        6,
/* Flags */

        0,
/* Component type and count */

        EPixelComponentTypes.SHORT, 3,
/* rbits, gbits, bbits, abits */

        16, 16, 16, 0,
/* Masks and shifts */

		0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
		["PF_PVRTC_RGB2",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
		["PF_PVRTC_RGBA2",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
		["PF_PVRTC_RGB4",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
		["PF_PVRTC_RGBA4",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_R8",
/* Bytes per element */

        1,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 1,
/* rbits, gbits, bbits, abits */

        8, 0, 0, 0,
/* Masks and shifts */

        0xFF0000, 0, 0, 0,
        0, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_RG8",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 2,
/* rbits, gbits, bbits, abits */

        8, 8, 0, 0,
/* Masks and shifts */

        0xFF0000, 0x00FF00, 0, 0,
        8, 0, 0, 0
        ],
//-----------------------------------------------------------------------
        ["PF_DEPTH_BYTE",
/* Bytes per element */

        1,
/* Flags */

        EPixelFormatFlags.DEPTH,
/* Component type and count */

        EPixelComponentTypes.BYTE, 1,
/* rbits, gbits, bbits, abits */

        8, 0, 0, 0,
/* Masks and shifts */

        0xFF, 0, 0, 0, 0, 0, 0, 0
        ],
	]);

    var _pColorValue: IColorValue = {r: 0., g: 0., b: 0., a: 1.};

	export module pixelUtil {
        export  /**@inline*/  function getDescriptionFor(eFmt: EPixelFormats): IPixelFormatDescription {
            var ord:  number  = < number >eFmt;
            logger.setSourceLocation( "pixelUtil.ts" , 696 ); logger.assert(ord>=0 && ord<EPixelFormats.TOTAL); ;

            return pPixelFormats[ord];
        }

/** Returns the size in bytes of an element of the given pixel format.
         @return
               The size in bytes of an element. See Remarks.
         @remarks
               Passing PF_UNKNOWN will result in returning a size of 0 bytes.
        */

        export  /**@inline*/  function getNumElemBytes(eFormat: EPixelFormats):  number  {
        	return getDescriptionFor(eFormat).elemBytes;
        }

/** Returns the size in bits of an element of the given pixel format.
          @return
               The size in bits of an element. See Remarks.
           @remarks
               Passing PF_UNKNOWN will result in returning a size of 0 bits.
        */

        export  /**@inline*/  function getNumElemBits(eFormat: EPixelFormats):  number  {
        	return getDescriptionFor(eFormat).elemBytes * 8;
        }



/** Returns the size in memory of a region with the given extents and pixel
			format with consecutive memory layout.
			@param width
				The width of the area
			@param height
				The height of the area
			@param depth
				The depth of the area
			@param format
				The format of the area
		  	@return
		  		The size in bytes
			@remarks
				In case that the format is non-compressed, this simply returns
				width*height*depth*PixelUtil::getNumElemBytes(format). In the compressed
				case, this does serious magic.
		*/

		export function getMemorySize(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats):  number  {
			if(isCompressed(eFormat)) {
				switch(eFormat) {
// DXT formats work by dividing the image into 4x4 blocks, then encoding each
// 4x4 block with a certain number of bytes. 
					case EPixelFormats.DXT1:
						return ((iWidth + 3) / 4) * ((iHeight + 3) / 4) * 8 * iDepth;
					case EPixelFormats.DXT2:
					case EPixelFormats.DXT3:
					case EPixelFormats.DXT4:
					case EPixelFormats.DXT5:
						return ((iWidth + 3) / 4) * ((iHeight + 3) / 4) * 16 * iDepth;

// Size calculations from the PVRTC OpenGL extension spec
// http://www.khronos.org/registry/gles/extensions/IMG/IMG_texture_compression_pvrtc.txt
// Basically, 32 bytes is the minimum texture size.  Smaller textures are padded up to 32 bytes
	                case EPixelFormats.PVRTC_RGB2:
	                case EPixelFormats.PVRTC_RGBA2:
						logger.setSourceLocation( "pixelUtil.ts" , 758 ); logger.assert(iDepth == 1); ;
	                    return (math.max(< number >iWidth, 16) * math.max(< number >iHeight, 8) * 2 + 7) / 8;
	                case EPixelFormats.PVRTC_RGB4:
	                case EPixelFormats.PVRTC_RGBA4:
						logger.setSourceLocation( "pixelUtil.ts" , 762 ); logger.assert(iDepth == 1); ;
	                    return (math.max(< number >iWidth, 8) * math.max(< number >iHeight, 8) * 4 + 7) / 8;
					default:
						logger.setSourceLocation( "pixelUtil.ts" , 765 ); logger.error("Invalid compressed pixel format", "PixelUtil::getMemorySize"); ;
				}
			}
			else {
				return iWidth * iHeight * iDepth * getNumElemBytes(eFormat);
			}
		}

/** Returns the property flags for this pixel format
          @return
               A bitfield combination of PFF_HASALPHA, PFF_ISCOMPRESSED,
               PFF_FLOAT, PFF_DEPTH, PFF_NATIVEENDIAN, PFF_LUMINANCE
          @remarks
               This replaces the separate functions for formatHasAlpha, formatIsFloat, ...
        */

        export  /**@inline*/  function getFlags(eFormat: EPixelFormats):  number  {
        	return getDescriptionFor(eFormat).flags;
        }

/** Shortcut method to determine if the format has an alpha component */

        export  /**@inline*/  function hasAlpha(eFormat: EPixelFormats): bool {
        	return (getFlags(eFormat) & EPixelFormatFlags.HASALPHA) > 0;
        }
/** Shortcut method to determine if the format is floating point */

        export  /**@inline*/  function isFloatingPoint(eFormat: EPixelFormats): bool {
        	return (getFlags(eFormat) & EPixelFormatFlags.FLOAT) > 0;
        }
/** Shortcut method to determine if the format is compressed */

        export  /**@inline*/  function isCompressed(eFormat: EPixelFormats): bool {
        	return (getFlags(eFormat) & EPixelFormatFlags.COMPRESSED) > 0;
        }
/** Shortcut method to determine if the format is a depth format. */

        export  /**@inline*/  function isDepth(eFormat: EPixelFormats): bool {
        	return (getFlags(eFormat) & EPixelFormatFlags.DEPTH) > 0;
        }
/** Shortcut method to determine if the format is in native endian format. */

        export  /**@inline*/  function isNativeEndian(eFormat: EPixelFormats): bool {
        	return (getFlags(eFormat) & EPixelFormatFlags.NATIVEENDIAN) > 0;
        }
/** Shortcut method to determine if the format is a luminance format. */

        export  /**@inline*/  function isLuminance(eFormat: EPixelFormats): bool {
        	return (getFlags(eFormat) & EPixelFormatFlags.LUMINANCE) > 0;
        }

/** Return wether a certain image extent is valid for this image format.
			@param width
				The width of the area
			@param height
				The height of the area
			@param depth
				The depth of the area
			@param format
				The format of the area
			@remarks For non-compressed formats, this is always true. For DXT formats,
			only sizes with a width and height multiple of 4 and depth 1 are allowed.
		*/

		export function isValidExtent(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats): bool {
			if(isCompressed(eFormat)) {
				switch(eFormat) {
					case EPixelFormats.DXT1:
					case EPixelFormats.DXT2:
					case EPixelFormats.DXT3:
					case EPixelFormats.DXT4:
					case EPixelFormats.DXT5:
						return ((iWidth&3)==0 && (iHeight&3)==0 && iDepth==1);
					default:
						return true;
				}
			}
			else
			{
				return true;
			}
		}

/** Gives the number of bits (RGBA) for a format. See remarks.          
          @remarks      For non-colour formats (dxt, depth) this returns [0,0,0,0].
        */

        export function getBitDepths(eFormat: EPixelFormats):  number [] {
        	/**@const*/var  des: IPixelFormatDescription = getDescriptionFor(eFormat);
        	var rgba:  number [] = [];

	        rgba[0] = des.rbits;
	        rgba[1] = des.gbits;
	        rgba[2] = des.bbits;
	        rgba[3] = des.abits;

	        return rgba;
        }

/** Gives the masks for the R, G, B and A component
		  @note			Only valid for native endian formats
        */

        export function getBitMasks(eFormat: EPixelFormats):  number [] {
        	/**@const*/var  des: IPixelFormatDescription = getDescriptionFor(eFormat);
        	var rgba:  number [] = [];

	        rgba[0] = des.rmask;
	        rgba[1] = des.gmask;
	        rgba[2] = des.bmask;
	        rgba[3] = des.amask;

	        return rgba;
        }

/** Gives the bit shifts for R, G, B and A component
		@note			Only valid for native endian formats
		*/

		export function getBitShifts(eFormat: EPixelFormats):  number [] {
			/**@const*/var  des: IPixelFormatDescription = getDescriptionFor(eFormat);
        	var rgba:  number [] = [];

	        rgba[0] = des.rshift;
	        rgba[1] = des.gshift;
	        rgba[2] = des.bshift;
	        rgba[3] = des.ashift;

	        return rgba;
		}

/** Gets the name of an image format
        */

        export  /**@inline*/  function getFormatName(eSrcFormat: EPixelFormats): string {
        	return getDescriptionFor(eSrcFormat).name;
        }

/** Returns wether the format can be packed or unpacked with the packColour()
        and unpackColour() functions. This is generally not true for compressed and
        depth formats as they are special. It can only be true for formats with a
        fixed element size.
          @return 
               true if yes, otherwise false
        */

        export function isAccessible(eSrcFormat: EPixelFormats): bool {
        	if (eSrcFormat == EPixelFormats.UNKNOWN)
	            return false;
	        var flags:  number  = getFlags(eSrcFormat);
	        return !((flags & EPixelFormatFlags.COMPRESSED) || (flags & EPixelFormatFlags.DEPTH));
        }

/** Returns the component type for a certain pixel format. Returns PCT_BYTE
            in case there is no clear component type like with compressed formats.
            This is one of PCT_BYTE, PCT_SHORT, PCT_FLOAT16, PCT_FLOAT32.
        */

        export  /**@inline*/  function getComponentType(eFmt: EPixelFormats): EPixelComponentTypes {
        	return getDescriptionFor(eFmt).componentType;
        }

/** Returns the component count for a certain pixel format. Returns 3(no alpha) or 
            4 (has alpha) in case there is no clear component type like with compressed formats.
         */

        export  /**@inline*/  function getComponentCount(eFmt: EPixelFormats):  number  {
        	return getDescriptionFor(eFmt).componentCount;
        }

        export  /**@inline*/  function getComponentTypeBits(eFormat: EPixelFormats):  number  {
            var eType: EPixelComponentTypes = getComponentType(eFormat);

            switch(eType) {
/*Byte per component (8 bit fixed 0.0..1.0)*/
                case EPixelComponentTypes.BYTE:      return 8;
/*Short per component (16 bit fixed 0.0..1.0))*/
                case EPixelComponentTypes.SHORT:     return 16;
/*16 bit float per component*/
                case EPixelComponentTypes.FLOAT16:   return 16;
/*32 bit float per component*/
                case EPixelComponentTypes.FLOAT32:   return 32;
            }

            return 0;
        }

/** Gets the format from given name.
            @param  name            The string of format name
            @param  accessibleOnly  If true, non-accessible format will treat as invalid format,
                                    otherwise, all supported format are valid.
            @param  caseSensitive   Should be set true if string match should use case sensitivity.
            @return                The format match the format name, or PF_UNKNOWN if is invalid name.
        */

        export function getFormatFromName(sName: string, isAccessibleOnly: bool = false, isCaseSensitive: bool = false): EPixelFormats {
        	var tmp: string = sName;

	        if (!isCaseSensitive) {
// We are stored upper-case format names.
	            tmp = tmp.toUpperCase();
	        }

	        for (var i:  number  = 0; i < EPixelFormats.TOTAL; ++i) {
	            var ePf: EPixelFormats = <EPixelFormats>i;
	            if (!isAccessibleOnly || isAccessible(ePf)) {
	                if (tmp == getFormatName(ePf))
	                    return ePf;
	            }
	        }

	        return EPixelFormats.UNKNOWN;
        }

/** Gets the BNF expression of the pixel-formats.
            @note                   The string returned by this function is intended to be used as a BNF expression
                                    to work with Compiler2Pass.
            @param  accessibleOnly  If true, only accessible pixel format will take into account, otherwise all
                                    pixel formats list in EPixelFormats enumeration will being returned.
            @return                A string contains the BNF expression.
        */

        export function getBNFExpressionOfPixelFormats(isAccessibleOnly: bool = false): string {
// Collect format names sorted by length, it's required by BNF compiler
// that similar tokens need longer ones comes first.

	        var formatNames: Pair[];
	        for (var i:  number  = 0; i < EPixelFormats.TOTAL; ++i) {
	            var ePf: EPixelFormats = <EPixelFormats>(i);
	            if (!isAccessibleOnly || isAccessible(ePf))
	            {
	                var formatName: string = getFormatName(ePf);
	                formatNames.push({first: formatName.length, second: formatName});
	            }
	        }

// Populate the BNF expression in reverse order
	        var result: string = "";
// Note: Stupid M$ VC7.1 can't dealing operator!= with FormatNameMap::const_reverse_iterator.
	        for (var j in formatNames) {
	            if (!isEmpty(result))
	                result += " | ";
	            result += "'" + formatNames[j] + "'";
	        }

	        return result;
        }

/** Returns the similar format but acoording with given bit depths.
            @param fmt      The original foamt.
            @param integerBits Preferred bit depth (pixel bits) for integer pixel format.
                            Available values: 0, 16 and 32, where 0 (the default) means as it is.
            @param floatBits Preferred bit depth (channel bits) for float pixel format.
                            Available values: 0, 16 and 32, where 0 (the default) means as it is.
            @return        The format that similar original format with bit depth according
                            with preferred bit depth, or original format if no conversion occurring.
        */

        export function getFormatForBitDepths(eFmt: EPixelFormats, iIntegerBits:  number , iFloatBits:  number ): EPixelFormats {
        	switch (iIntegerBits) {
	        case 16:
	            switch (eFmt) {
	            case EPixelFormats.R8G8B8:
	            case EPixelFormats.X8R8G8B8:
	                return EPixelFormats.R5G6B5;

	            case EPixelFormats.B8G8R8:
	            case EPixelFormats.X8B8G8R8:
	                return EPixelFormats.B5G6R5;

	            case EPixelFormats.A8R8G8B8:
	            case EPixelFormats.R8G8B8A8:
	            case EPixelFormats.A8B8G8R8:
	            case EPixelFormats.B8G8R8A8:
	                return EPixelFormats.A4R4G4B4;

	            case EPixelFormats.A2R10G10B10:
	            case EPixelFormats.A2B10G10R10:
	                return EPixelFormats.A1R5G5B5;

	            default:
// use original image format
	                break;
	            }
	            break;

	        case 32:
	            switch (eFmt) {
	            case EPixelFormats.R5G6B5:
	                return EPixelFormats.X8R8G8B8;

	            case EPixelFormats.B5G6R5:
	                return EPixelFormats.X8B8G8R8;

	            case EPixelFormats.A4R4G4B4:
	                return EPixelFormats.A8R8G8B8;

	            case EPixelFormats.A1R5G5B5:
	                return EPixelFormats.A2R10G10B10;

	            default:
// use original image format
	                break;
	            }
	            break;

	        default:
// use original image format
	            break;
	        }

	        switch (iFloatBits) {
	        case 16:
	            switch (eFmt) {
	            case EPixelFormats.FLOAT32_R:
	                return EPixelFormats.FLOAT16_R;

	            case EPixelFormats.FLOAT32_RGB:
	                return EPixelFormats.FLOAT16_RGB;

	            case EPixelFormats.FLOAT32_RGBA:
	                return EPixelFormats.FLOAT16_RGBA;

	            default:
// use original image format
	                break;
	            }
	            break;

	        case 32:
	            switch (eFmt) {
	            case EPixelFormats.FLOAT16_R:
	                return EPixelFormats.FLOAT32_R;

	            case EPixelFormats.FLOAT16_RGB:
	                return EPixelFormats.FLOAT32_RGB;

	            case EPixelFormats.FLOAT16_RGBA:
	                return EPixelFormats.FLOAT32_RGBA;

	            default:
// use original image format
	                break;
	            }
	            break;

	        default:
// use original image format
	            break;
	        }

	        return eFmt;
        }

/** Pack a colour value to memory
        	@param colour	The colour
        	@param pf		Pixelformat in which to write the colour
        	@param dest		Destination memory location
        */

        export  /**@inline*/  function packColour(cColour: IColor, ePf: EPixelFormats,  pDest: Uint8Array): void {
        	packColourFloat(cColour.r, cColour.g, cColour.b, cColour.a, ePf, pDest);
        }
/** Pack a colour value to memory
        	@param r,g,b,a	The four colour components, range 0x00 to 0xFF
        	@param pf		Pixelformat in which to write the colour
        	@param dest		Destination memory location
        */

        export function packColourUint(r:  number , g:  number , b:  number , a:  number , ePf: EPixelFormats,  pDest: Uint8Array): void {
// if (arguments.length < 4) {
// 	var cColour: IColor = arguments[0];
// 	packColour(cColour.r, cColour.g, cColour.b, cColour.a, ePf, pDest);
// 	return;
// }

        	/**@const*/var  des: IPixelFormatDescription = getDescriptionFor(ePf);
	        if(des.flags & EPixelFormatFlags.NATIVEENDIAN) {
// Shortcut for integer formats packing
	            var value:  number  =
	            	((bf.fixedToFixed(r, 8, des.rbits)<<des.rshift) & des.rmask) |
	                ((bf.fixedToFixed(g, 8, des.gbits)<<des.gshift) & des.gmask) |
	                ((bf.fixedToFixed(b, 8, des.bbits)<<des.bshift) & des.bmask) |
	                ((bf.fixedToFixed(a, 8, des.abits)<<des.ashift) & des.amask);
// And write to memory
	            bf.intWrite(pDest, des.elemBytes, value);
	        } else {
// Convert to float
	            packColourFloat(< number >r/255.0,< number >g/255.0,< number >b/255.0,< number >a/255.0, ePf, pDest);
	        }
        }
/** Pack a colour value to memory
        	@param r,g,b,a	The four colour components, range 0.0f to 1.0f
        					(an exception to this case exists for floating point pixel
        					formats, which don't clamp to 0.0f..1.0f)
        	@param pf		Pixelformat in which to write the colour
        	@param dest		Destination memory location
        */

        export function packColourFloat(r:  number , g:  number , b:  number , a:  number , ePf: EPixelFormats,  pDest: Uint8Array): void {
// Catch-it-all here
	        /**@const*/var  des: IPixelFormatDescription = getDescriptionFor(ePf);
	        if(des.flags & EPixelFormatFlags.NATIVEENDIAN) {
// Do the packing
//std::cerr << dest << " " << r << " " << g <<  " " << b << " " << a << std::endl;
	            /**@const*/var  value:  number  = ((bf.floatToFixed(r, des.rbits)<<des.rshift) & des.rmask) |
	                ((bf.floatToFixed(g, des.gbits)<<des.gshift) & des.gmask) |
	                ((bf.floatToFixed(b, des.bbits)<<des.bshift) & des.bmask) |
	                ((bf.floatToFixed(a, des.abits)<<des.ashift) & des.amask);
// And write to memory
	            bf.intWrite(pDest, des.elemBytes, value);
	        } else {
	            switch(ePf) {
	            case EPixelFormats.FLOAT32_R:
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 1)) [0] = r;
	                break;
				case EPixelFormats.FLOAT32_GR:
					(new Float32Array(pDest.buffer, pDest.byteOffset, 1)) [0] = g;
					(new Float32Array(pDest.buffer, pDest.byteOffset, 2)) [1] = r;
					break;
	            case EPixelFormats.FLOAT32_RGB:
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 1)) [0] = r;
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 2)) [1] = g;
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 3)) [2] = b;
	                break;
	            case EPixelFormats.FLOAT32_RGBA:
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 1)) [0] = r;
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 2)) [1] = g;
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 3)) [2] = b;
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 4)) [3] = a;
	                break;
	            case EPixelFormats.FLOAT16_R:
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 1)) [0] = bf.floatToHalf(r);
	                break;
				case EPixelFormats.FLOAT16_GR:
					(new Uint16Array(pDest.buffer, pDest.byteOffset, 1)) [0] = bf.floatToHalf(g);
					(new Uint16Array(pDest.buffer, pDest.byteOffset, 2)) [1] = bf.floatToHalf(r);
					break;
	            case EPixelFormats.FLOAT16_RGB:
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 1)) [0] = bf.floatToHalf(r);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 2)) [1] = bf.floatToHalf(g);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 3)) [2] = bf.floatToHalf(b);
	                break;
	            case EPixelFormats.FLOAT16_RGBA:
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 1)) [0] = bf.floatToHalf(r);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 2)) [1] = bf.floatToHalf(g);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 3)) [2] = bf.floatToHalf(b);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 4)) [3] = bf.floatToHalf(a);
	                break;
	            case EPixelFormats.SHORT_RGB:
					(new Uint16Array(pDest.buffer, pDest.byteOffset, 1)) [0] = bf.floatToFixed(r, 16);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 2)) [1] = bf.floatToFixed(g, 16);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 3)) [2] = bf.floatToFixed(b, 16);
	                break;
				case EPixelFormats.SHORT_RGBA:
					(new Uint16Array(pDest.buffer, pDest.byteOffset, 1)) [0] = bf.floatToFixed(r, 16);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 2)) [1] = bf.floatToFixed(g, 16);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 3)) [2] = bf.floatToFixed(b, 16);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 4)) [3] = bf.floatToFixed(a, 16);
					break;
				case EPixelFormats.BYTE_LA:
					pDest[0] = bf.floatToFixed(r, 8);
	                pDest[1] = bf.floatToFixed(a, 8);
					break;
	            default:
// Not yet supported
	                logger.setSourceLocation( "pixelUtil.ts" , 1208 ); logger.error("pack to "+ getFormatName(ePf)+" not implemented", "PixelUtil::packColour");
                                             ;
	                break;
	            }
	        }
        }



/** Unpack a colour value from memory
        	@param colour	The colour is returned here
        	@param pf		Pixelformat in which to read the colour
        	@param src		Source memory location
        */

        export function unpackColour(cColour: IColor, ePf: EPixelFormats,  pSrc: Uint8Array): void {
        	unpackColourFloat(cColour, ePf, pSrc);
        }
/** Unpack a colour value from memory
        	@param r,g,b,a	The colour is returned here (as byte)
        	@param pf		Pixelformat in which to read the colour
        	@param src		Source memory location
        	@remarks 	This function returns the colour components in 8 bit precision,
        		this will lose precision when coming from PF_A2R10G10B10 or floating
        		point formats.  
        */

        export function unpackColourUint(rgba: IColorIValue, ePf: EPixelFormats,  pSrc: Uint8Array): void {
        	/**@const*/var  des: IPixelFormatDescription = getDescriptionFor(ePf);
        	var r:  number , g:  number , b:  number , a:  number ;

	        if(des.flags & EPixelFormatFlags.NATIVEENDIAN) {
// Shortcut for integer formats unpacking
	            /**@const*/var  value:  number  = bf.intRead(pSrc, des.elemBytes);
	            if(des.flags & EPixelFormatFlags.LUMINANCE) {
// Luminance format -- only rbits used
	                r = g = b = < number >bf.fixedToFixed(
	                    (value & des.rmask) >> des.rshift, des.rbits, 8);
	            }
	            else {
	                r = < number >bf.fixedToFixed((value & des.rmask)>>des.rshift, des.rbits, 8);
	                g = < number >bf.fixedToFixed((value & des.gmask)>>des.gshift, des.gbits, 8);
	                b = < number >bf.fixedToFixed((value & des.bmask)>>des.bshift, des.bbits, 8);
	            }
	            if(des.flags & EPixelFormatFlags.HASALPHA) {
	                a = < number >bf.fixedToFixed((value & des.amask)>>des.ashift, des.abits, 8);
	            }
	            else {
// No alpha, default a component to full	                a = 255;
	            }

	        } else {
// Do the operation with the more generic floating point
	            var pRGBA: IColorValue = _pColorValue;
	            unpackColourFloat(pRGBA, ePf, pSrc);


	            r = bf.floatToFixed(pRGBA.r, 8);
	            g = bf.floatToFixed(pRGBA.g, 8);
	            b = bf.floatToFixed(pRGBA.b, 8);
	            a = bf.floatToFixed(pRGBA.a, 8);
	        }

	        rgba[0] = r;
	        rgba[1] = g;
	        rgba[2] = b;
	        rgba[3] = a;
        }
/** Unpack a colour value from memory
        	@param r,g,b,a	The colour is returned here (as float)
        	@param pf		Pixelformat in which to read the colour
        	@param src		Source memory location
        */

        export function unpackColourFloat(rgba: IColorValue, ePf: EPixelFormats,  pSrc: Uint8Array): void {
        	/**@const*/var  des: IPixelFormatDescription = getDescriptionFor(ePf);
        	var r:  number , g:  number , b:  number , a:  number ;

	        if(des.flags & EPixelFormatFlags.NATIVEENDIAN) {
// Shortcut for integer formats unpacking
	            /**@const*/var  value:  number  = bf.intRead(pSrc, des.elemBytes);
	            if(des.flags & EPixelFormatFlags.LUMINANCE) {
// Luminance format -- only rbits used
	                r = g = b = bf.fixedToFloat(
	                    (value & des.rmask)>>des.rshift, des.rbits);
	            }
	            else {
	                r = bf.fixedToFloat((value & des.rmask) >> des.rshift, des.rbits);
	                g = bf.fixedToFloat((value & des.gmask) >> des.gshift, des.gbits);
	                b = bf.fixedToFloat((value & des.bmask) >> des.bshift, des.bbits);
	            }

	            if (des.flags & EPixelFormatFlags.HASALPHA) {
	                a = bf.fixedToFloat((value & des.amask) >> des.ashift, des.abits);
	            }
	            else {
// No alpha, default a component to full	                a = 1.0;
	            }

	        } else {
	            switch(ePf) {
	            case EPixelFormats.FLOAT32_R:
	                r = g = b =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1)) [0];
	                a = 1.0;
	                break;
				case EPixelFormats.FLOAT32_GR:
					g =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1)) [0];
					r = b =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 2)) [1];
					a = 1.0;
					break;
	            case EPixelFormats.FLOAT32_RGB:
	                r =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1)) [0];
	                g =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 2)) [1];
	                b =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 3)) [2];
	                a = 1.0;
	                break;
	            case EPixelFormats.FLOAT32_RGBA:
	                r =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1)) [0];
	                g =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 2)) [1];
	                b =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 3)) [2];
	                a =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 4)) [3];
	                break;
	            case EPixelFormats.FLOAT16_R:
	                r = g = b = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[0]);
	                a = 1.0;
	                break;
				case EPixelFormats.FLOAT16_GR:
					g = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[0]);
					r = b = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2)) )[1]);
					a = 1.0;
					break;
	            case EPixelFormats.FLOAT16_RGB:
	                r = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[0]);
	                g = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[1]);
	                b = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2)) )[2]);
	                a = 1.0;
	                break;
	            case EPixelFormats.FLOAT16_RGBA:
	                r = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[0]);
	                g = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2)) )[1]);
	                b = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 3)) )[2]);
	                a = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 4)) )[3]);
	                break;
				case EPixelFormats.SHORT_RGB:
					r = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[0], 16);
	                g = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2)) )[1], 16);
					b = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 3)) )[2], 16);
					a = 1.0;
					break;
				case EPixelFormats.SHORT_RGBA:
					r = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[0], 16);
	                g = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2)) )[1], 16);
					b = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 3)) )[2], 16);
					a = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 4)) )[3], 16);
					break;
				case EPixelFormats.BYTE_LA:
					r = g = b = bf.fixedToFloat((pSrc)[0], 8);
					a = bf.fixedToFloat((pSrc)[1], 8);
					break;
	            default:
// Not yet supported
	                logger.setSourceLocation( "pixelUtil.ts" , 1367 ); logger.error("unpack from "+ getFormatName(ePf) +" not implemented", "PixelUtil::unpackColour");
                                               ;
	                break;
	            }
	        }

	        rgba.r = r;
	        rgba.g = g;
	        rgba.b = b;
	        rgba.a = a;
        }

/** Convert consecutive pixels from one format to another. No dithering or filtering is being done. 
         	Converting from RGB to luminance takes the R channel.  In case the source and destination format match,
         	just a copy is done.
         	@param	src			Pointer to source region
         	@param	srcFormat	Pixel format of source region
         	@param   dst			Pointer to destination region
         	@param	dstFormat	Pixel format of destination region
         */

        export function bulkPixelConversion(pSrc: Uint8Array, eSrcFormat: EPixelFormats, pDest: Uint8Array, eDstFormat: EPixelFormats, iCount:  number ): void;


/** Convert pixels from one format to another. No dithering or filtering is being done. Converting
          	from RGB to luminance takes the R channel. 
		 	@param	src			PixelBox containing the source pixels, pitches and format
		 	@param	dst			PixelBox containing the destination pixels, pitches and format
		 	@remarks The source and destination boxes must have the same
         	dimensions. In case the source and destination format match, a plain copy is done.
        */


        export function bulkPixelConversion(pSrc: IPixelBox, pDest: IPixelBox): void;

        export function bulkPixelConversion(pSrc: any, eSrcFormat: any, pDest?: any, eDstFormat?: any, iCount?:  number ): void {
        	var src: IPixelBox,
        		dst: IPixelBox;

        	if (arguments.length > 2) {
	        	src = new PixelBox(iCount, 1, 1, <EPixelFormats>eSrcFormat, <Uint8Array>pSrc);
				dst = new PixelBox(iCount, 1, 1, <EPixelFormats>eDstFormat, <Uint8Array>pDest);
			}

        	logger.setSourceLocation( "pixelUtil.ts" , 1410 ); logger.assert(src.width == dst.width && src.height == dst.height && src.depth == dst.depth);
                             ;

// Check for compressed formats, we don't support decompression, compression or recoding
			if(isCompressed(src.format) || isCompressed(dst.format)) {
				if(src.format == dst.format) {
//_memcpy(dst.data.buffer, src.data.buffer, src.getConsecutiveSize());
					dst.data.set(src.data.subarray(0, src.getConsecutiveSize()));
					return;
				}
				else {
					logger.setSourceLocation( "pixelUtil.ts" , 1421 ); logger.error("This method can not be used to compress or decompress images", "PixelUtil::bulkPixelConversion");
                                       ;
				}
			}

// The easy case
	        if(src.format == dst.format) {
// Everything consecutive?
	            if(src.isConsecutive() && dst.isConsecutive())
	            {
//_memcpy(dst.data.buffer, src.data.buffer, src.getConsecutiveSize());
					dst.data.set(src.data.subarray(0, src.getConsecutiveSize()));
	                return;
	            }

	            /**@const*/var  srcPixelSize:  number  = getNumElemBytes(src.format);
	            /**@const*/var  dstPixelSize:  number  = getNumElemBytes(dst.format);

	            var srcptr: Uint8Array = src.data.subarray(
	                (src.left + src.top * src.rowPitch + src.front * src.slicePitch) * srcPixelSize);
	            var dstptr: Uint8Array = dst.data.subarray(
					+ (dst.left + dst.top * dst.rowPitch + dst.front * dst.slicePitch) * dstPixelSize);

// Calculate pitches+skips in bytes
	            /**@const*/var  srcRowPitchBytes:  number  = src.rowPitch * srcPixelSize;
//const size_t srcRowSkipBytes = src.getRowSkip()*srcPixelSize;
	            /**@const*/var  srcSliceSkipBytes:  number  = src.getSliceSkip() * srcPixelSize;

	            /**@const*/var  dstRowPitchBytes:  number  = dst.rowPitch * dstPixelSize;
//const size_t dstRowSkipBytes = dst.getRowSkip()*dstPixelSize;
	            /**@const*/var  dstSliceSkipBytes:  number  = dst.getSliceSkip() * dstPixelSize;

// Otherwise, copy per row
	            /**@const*/var  rowSize:  number  = src.width * srcPixelSize;

	            for(var z:  number  = src.front; z < src.back; z++) {
	                for(var y:  number  = src.top; y < src.bottom; y++) {
//_memcpy(dstptr.buffer, srcptr.buffer, rowSize);
						dstptr.set(srcptr.subarray(0, rowSize));

	                    srcptr = srcptr.subarray(srcRowPitchBytes);
	                    dstptr = dstptr.subarray(dstRowPitchBytes);
	                }

	                srcptr = srcptr.subarray(srcSliceSkipBytes);
	                dstptr = dstptr.subarray(dstSliceSkipBytes);
	            }

	            return;
	        }
// Converting to PF_X8R8G8B8 is exactly the same as converting to
// PF_A8R8G8B8. (same with PF_X8B8G8R8 and PF_A8B8G8R8)
			if(dst.format == EPixelFormats.X8R8G8B8 || dst.format == EPixelFormats.X8B8G8R8) {
// Do the same conversion, with EPixelFormats.A8R8G8B8, which has a lot of
// optimized conversions
				var tempdst: IPixelBox = dst;
				tempdst.format = dst.format == EPixelFormats.X8R8G8B8 ? EPixelFormats.A8R8G8B8  :EPixelFormats.A8B8G8R8;
				bulkPixelConversion(src, tempdst);
				return;
			}
// Converting from EPixelFormats.X8R8G8B8 is exactly the same as converting from
// EPixelFormats.A8R8G8B8, given that the destination format does not have alpha.
			if((src.format == EPixelFormats.X8R8G8B8||src.format == EPixelFormats.X8B8G8R8) && !hasAlpha(dst.format)) {
// Do the same conversion, with EPixelFormats.A8R8G8B8, which has a lot of
// optimized conversions
				var tempsrc: IPixelBox = src;
				tempsrc.format = src.format == EPixelFormats.X8R8G8B8 ? EPixelFormats.A8R8G8B8 : EPixelFormats.A8B8G8R8;
				bulkPixelConversion(tempsrc, dst);
				return;
			}

	        /**@const*/var  srcPixelSize:  number  = getNumElemBytes(src.format);
	        /**@const*/var  dstPixelSize:  number  = getNumElemBytes(dst.format);

	        var srcptr: Uint8Array = src.data.subarray(
	            (src.left + src.top * src.rowPitch + src.front * src.slicePitch) * srcPixelSize);
	        var dstptr: Uint8Array = dst.data.subarray(
	            (dst.left + dst.top * dst.rowPitch + dst.front * dst.slicePitch) * dstPixelSize);

// Old way, not taking into account box dimensions
//uint8 *srcptr = static_cast<uint8*>(src.data), *dstptr = static_cast<uint8*>(dst.data);

// Calculate pitches+skips in bytes
	        /**@const*/var  srcRowSkipBytes:  number  = src.getRowSkip() * srcPixelSize;
	        /**@const*/var  srcSliceSkipBytes:  number  = src.getSliceSkip() * srcPixelSize;
	        /**@const*/var  dstRowSkipBytes:  number  = dst.getRowSkip() * dstPixelSize;
	        /**@const*/var  dstSliceSkipBytes:  number  = dst.getSliceSkip() * dstPixelSize;

// The brute force fallback
// var r: float = 0, g: float = 0, b: float = 0, a: float = 1;
	        var rgba = _pColorValue;
	        for(var z:  number  = src.front; z < src.back; z ++) {
	            for(var y:  number  = src.top; y < src.bottom; y ++) {
	                for(var x:  number  = src.left; x < src.right; x ++) {
	                    unpackColourFloat(rgba, src.format, srcptr);
	                    packColourFloat(rgba.r, rgba.g, rgba.b, rgba.a, dst.format, dstptr);
	                    srcptr = srcptr.subarray(srcPixelSize);
	                    dstptr = dstptr.subarray(dstPixelSize);
	                }
	                srcptr = srcptr.subarray(srcRowSkipBytes);
	                dstptr = dstptr.subarray(dstRowSkipBytes);
	            }
	            srcptr = srcptr.subarray(srcSliceSkipBytes);
	            dstptr = dstptr.subarray(dstSliceSkipBytes);
	        }
        }

        export function calculateSizeForImage(nMipLevels:  number , nFaces:  number ,
                                              iWidth:  number , iHeight:  number , iDepth:  number ,
                                              eFormat: EPixelFormats):  number  {
            var iSize:  number  = 0;
            var mip:  number  = 0;

            for(mip = 0; mip <= nMipLevels; ++mip){
                iSize += getMemorySize(iWidth, iHeight, iDepth, eFormat) * nFaces;
                if(iWidth !== 1) iWidth /= 2;
                if(iHeight !== 1) iHeight /= 2;
                if(iDepth !== 1) iDepth /= 2;
            }

            return iSize;
        }
	}
}









module akra.pixelUtil {
	export class PixelBox extends geometry.Box implements IPixelBox {
		data: Uint8Array;
		format: EPixelFormats;
		rowPitch:  number ;
		slicePitch:  number ;

		constructor();
		constructor(iWidth:  number , iHeight:  number , iDepth:  number , ePixelFormat: EPixelFormats, pPixelData: any = null);
		constructor (pExtents: IBox, ePixelFormat: EPixelFormats, pPixelData: Uint8Array = null);
		constructor (iWidth?: any, iHeight?: any, iDepth?: any, ePixelFormat?: any, pPixelData: Uint8Array = null) {
			if (arguments.length === 0) {
				return;
			}

			if (arguments.length >= 4) {
				super(0, 0, 0, < number >iWidth, < number >iHeight, < number >iDepth);
				this.data = isDef(arguments[4]) ? (<Uint8Array>arguments[4]) : null;
				this.format = <EPixelFormats>arguments[3];
			}
			else {
				super(<IBox>arguments[0]);
				this.data = <Uint8Array>arguments[2];
				this.format = <EPixelFormats>arguments[1];
			}

			this.setConsecutive();
		}

		setConsecutive(): void {
			this.rowPitch = this.width;
			this.slicePitch = this.width * this.height;
		}

		getRowSkip():  number  { return this.rowPitch - this.width; }
		getSliceSkip():  number  { return this.slicePitch - (this.height * this.rowPitch); }

		isConsecutive(): bool {
			return this.rowPitch == this.width && this.slicePitch == this.width * this.height;
		}

		getConsecutiveSize():  number  {
			return pixelUtil.getMemorySize(this.width, this.height, this.depth, this.format);
		}

		getSubBox(pDest: IBox): PixelBox {
			if(pixelUtil.isCompressed(this.format)) {
				if(pDest.left == this.left && pDest.top == this.top && pDest.front == this.front &&
				   pDest.right == this.right && pDest.bottom == this.bottom && pDest.back == this.back) {
// Entire buffer is being queried
					return this;
				}

				logger.setSourceLocation( "pixelUtil/PixelBox.ts" , 65 ); logger.error("Cannot return subvolume of compressed PixelBuffer", "PixelBox::getSubVolume"); ;
			}

			if(!this.contains(pDest))
				logger.setSourceLocation( "pixelUtil/PixelBox.ts" , 69 ); logger.error("Bounds out of range", "PixelBox::getSubVolume"); ;

			var elemSize:  number  = pixelUtil.getNumElemBytes(this.format);
// Calculate new data origin
// Notice how we do not propagate left/top/front from the incoming box, since
// the returned pointer is already offset
			var rval: PixelBox = new PixelBox(pDest.width, pDest.height, pDest.depth, this.format,
				(<Uint8Array> this.data).subarray(((pDest.left - this.left) * elemSize)
				+ ((pDest.top - this.top) * this.rowPitch * elemSize)
				+ ((pDest.front - this.front) * this.slicePitch * elemSize))
			);

			rval.rowPitch = this.rowPitch;
			rval.slicePitch = this.slicePitch;
			rval.format = this.format;

			return rval;
		}

		getColorAt(x:  number , y:  number , z?:  number ): IColor {
			var cv: IColor = new Color;

	        var pixelSize:  number  = pixelUtil.getNumElemBytes(this.format);
	        var pixelOffset:  number  = pixelSize * (z * this.slicePitch + y * this.rowPitch + x);

	        pixelUtil.unpackColour(cv, this.format, this.data.subarray(pixelOffset));

	        return cv;
		}

		setColorAt(pColor: IColor, x:  number , y:  number , z?:  number ): void {
			var pixelSize:  number  = pixelUtil.getNumElemBytes(this.format);
	        var pixelOffset:  number  = pixelSize * (z * this.slicePitch + y * this.rowPitch + x);
	        pixelUtil.packColour(pColor, this.format, this.data.subarray(pixelOffset));
		}

		scale(pDest: IPixelBox, eFilter: EFilters = EFilters.BILINEAR): bool {
			return false;
		}
	}

}



module akra.webgl {
	export class WebGLPixelBuffer extends core.pool.resources.HardwareBuffer implements IPixelBuffer {

		/**@protected*/  _iWidth:  number  = 0;
		/**@protected*/  _iHeight:  number  = 0;
		/**@protected*/  _iDepth:  number  = 0;

// Pitches (offsets between rows and slices)
		/**@protected*/  _iRowPitch:  number  = 0;
		/**@protected*/  _iSlicePitch:  number  = 0;

		/**@protected*/  _eFormat: EPixelFormats = EPixelFormats.UNKNOWN;

//webgl specific

		/**@protected*/  _pCurrentLock: IPixelBox = null;
		/**@protected*/  _pLockedBox: IBox = null;
		/**@protected*/  _iCurrentLockFlags:  number  = 0;

		/**@protected*/  _pBuffer: IPixelBox = null;
		/**@protected*/  _iWebGLInternalFormat:  number  = 0;

		/**@inline*/  get width():  number  { return this._iWidth; }
		/**@inline*/  get height():  number  { return this._iHeight; }
		/**@inline*/  get depth():  number  { return this._iDepth; }

		/**@inline*/  get format():  number  { return this._eFormat; }


		constructor () {
			super();
		}


//upload(download) data to(from) videocard.
		/**@protected*/  upload(pData: IPixelBox, pDestBox: IBox): void {
			logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 46 ); logger.criticalError("Upload not possible for this pixelbuffer type"); ;
		}

		/**@protected*/  download(pData: IPixelBox): void {
			logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 50 ); logger.criticalError("Download not possible for this pixelbuffer type"); ;
		}

		_bindToFramebuffer(pAttachment:  number , iZOffset:  number ): void {
			logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 54 ); logger.criticalError("Framebuffer bind not possible for this pixelbuffer type"); ;
		}

		_getWebGLFormat():  number  {
			return this._iWebGLInternalFormat;
		}

		_clearRTT(iZOffset:  number ): void {
		}

		create(iFlags:  number ): bool;
		create(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats, iFlags:  number ): bool;
		create(): bool {
			if(arguments.length === 1) {
				logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 68 ); logger.criticalError("Invalid number of arguments. For PixelBuffer it must be six"); ;
			}
			var iWidth:  number  = arguments[0];
			var iHeight:  number  = arguments[1];
			var iDepth:  number  = arguments[2];
			var eFormat:  number  = arguments[3];
			var iFlags:  number  = arguments[4];

 			super.create(iFlags);

			this._iWidth = iWidth;
			this._iHeight = iHeight;
			this._iDepth = iDepth;
			this._eFormat = eFormat;

			this._iRowPitch = iWidth;
			this._iSlicePitch = iHeight * iWidth;
			this.byteLength = iHeight * iWidth * akra.pixelUtil.getNumElemBytes(eFormat);

			this._pBuffer = new pixelUtil.PixelBox(iWidth, iHeight, iDepth, eFormat);
			this._iWebGLInternalFormat =  0 ;

			return true;
		}

		destroy(): void {
			this._pBuffer = null;

			super.destroy();
		}

		destroyResource(): bool {
			this.destroy();
			this.notifyDestroyed();
			return true;
		}

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;
		readData(): bool {
			logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 108 ); logger.criticalError("Reading a byte range is not implemented. Use blitToMemory."); ;
			return false;
		}

		writeData(pData: Uint8Array, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer?: bool): bool;
		writeData(pData: ArrayBuffer, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer?: bool): bool;
		writeData(): bool {
			logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 115 ); logger.criticalError("Writing a byte range is not implemented. Use blitFromMemory."); ;
			return false;
		}


//=====

		blit(pSource: IPixelBuffer): bool;
		blit(pSource: IPixelBuffer, pSrcBox: IBox, pDestBox: IBox): bool;
		blit(pSource: IPixelBuffer, pSrcBox?: IBox, pDestBox?: IBox): bool {
			if (arguments.length == 1) {
				return this.blit(pSource,
		            new geometry.Box(0, 0, 0, pSource.width, pSource.height, pSource.depth),
		            new geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth)
		        );
			}
			else {
				if(pSource === <IPixelBuffer>this) {
					logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 133 ); logger.criticalError("Source must not be the same object");  ;
				}

				/**@const*/var  pSrclock: IPixelBox = pSource.lock(pSrcBox, ELockFlags.READ);

				var eLockMethod: ELockFlags = ELockFlags.NORMAL;
				if (pDestBox.left === 0 && pDestBox.top === 0 && pDestBox.front === 0 &&
				    pDestBox.right === this._iWidth && pDestBox.bottom === this._iHeight &&
				    pDestBox.back === this._iDepth) {
// Entire buffer -- we can discard the previous contents
					eLockMethod = ELockFlags.DISCARD;
				}

				/**@const*/var  pDstlock: IPixelBox = this.lock(pDestBox, eLockMethod);

				if (pDstlock.width != pSrclock.width ||
		            pDstlock.height != pSrclock.height ||
		            pDstlock.depth != pSrclock.depth) {
// Scaling desired
					pSrclock.scale(pDstlock);
				}
				else {
// No scaling needed
					akra.pixelUtil.bulkPixelConversion(pSrclock, pDstlock);
				}

				this.unlock();
				pSource.unlock();

				return true;
			}
		}

		blitFromMemory(pSource: IPixelBox): bool;
		blitFromMemory(pSource: IPixelBox, pDestBox: IBox): bool;
		blitFromMemory(): bool {
			var pSource: IPixelBox;
			var pDestBox: IBox;

			pSource = arguments[0];

			if(arguments.length === 1) {
				pDestBox = new geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
				return this.blitFromMemory(pSource, pDestBox);
			}
			else{
				pDestBox = arguments[1];
			}

			if (!this._pBuffer.contains(pDestBox)) {
				logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 183 ); logger.criticalError("Destination box out of range"); ;
	        }

	        var pScaledBox: IPixelBox;

	        if (pSource.width != pDestBox.width ||
	            pSource.height != pDestBox.height ||
	            pSource.depth != pDestBox.depth) {
// Scale to destination size.
// This also does pixel format conversion if needed
	            this.allocateBuffer();
	            pScaledBox = this._pBuffer.getSubBox(pDestBox);
	            pSource.scale(pScaledBox, EFilters.BILINEAR);
	        }
	        else if ((pSource.format != this._eFormat) ||
	                 ((getWebGLOriginFormat(pSource.format) == 0) && (pSource.format != EPixelFormats.R8G8B8))) {
// Extents match, but format is not accepted as valid source format for GL
// do conversion in temporary buffer
	            this.allocateBuffer();
	            pScaledBox = this._pBuffer.getSubBox(pDestBox);
	            pixelUtil.bulkPixelConversion(pSource, pScaledBox);

	            if(this._eFormat === EPixelFormats.A4R4G4B4)
	            {
// ARGB->BGRA
	                convertToWebGLformat(pScaledBox, pScaledBox);
	            }
	        }
	        else {
	            this.allocateBuffer();
	            pScaledBox = pSource;

	            if (pSource.format == EPixelFormats.R8G8B8) {
	                pScaledBox.format = EPixelFormats.B8G8R8;
	                pixelUtil.bulkPixelConversion(pSource, pScaledBox);
	            }
	        }

	        this.upload(pScaledBox, pDestBox);
	        this.freeBuffer();

			return true;
		}

		blitToMemory(pDest: IPixelBox): bool;
		blitToMemory(pSrcBox: IBox, pDest: IPixelBox): bool;
		blitToMemory(): bool {
			var pSrcBox: IBox;
			var pDest: IPixelBox;

			if(arguments.length === 1){
				pDest = arguments[0];
				pSrcBox = new geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
				return this.blitToMemory(pSrcBox, pDest);
			}
			else{
				pSrcBox = arguments[0];
				pDest = arguments[1];
			}

			if (!this._pBuffer.contains(pSrcBox)) {
				logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 244 ); logger.criticalError("source box out of range"); ;
	        }

	        if (pSrcBox.left == 0 && pSrcBox.right == this._iWidth &&
            	pSrcBox.top == 0 && pSrcBox.bottom == this._iHeight &&
            	pSrcBox.front == 0 && pSrcBox.back == this._iDepth &&
            	pDest.width == this._iWidth &&
            	pDest.height == this._iHeight &&
            	pDest.depth == this._iDepth &&
            	getWebGLOriginFormat(pDest.format) != 0) {
// The direct case: the user wants the entire texture in a format supported by GL
// so we don't need an intermediate buffer
	            this.download(pDest);
	        }
	        else {
// Use buffer for intermediate copy
	            this.allocateBuffer();
// Download entire buffer
	            this.download(this._pBuffer);

	            if(pSrcBox.width != pDest.width ||
	               pSrcBox.height != pDest.height ||
	               pSrcBox.depth != pDest.depth) {
// We need scaling
	                this._pBuffer.getSubBox(pSrcBox).scale(pDest, EFilters.BILINEAR);
	            }
	            else {
// Just copy the bit that we need
	                pixelUtil.bulkPixelConversion(this._pBuffer.getSubBox(pSrcBox), pDest);
	            }
	            this.freeBuffer();
	        }

			return true;
		}

		getRenderTarget(): IRenderTarget {
			return null;
		}

		lock(iLockFlags:  number ): any;
		lock(iOffset:  number , iSize:  number , iLockFlags:  number  = EHardwareBufferFlags.READABLE): any;
		lock(pLockBox: IBox, iLockFlags:  number  = EHardwareBufferFlags.READABLE): IPixelBox;
		lock(): any {
			var pLockBox: IBox;
			var iLockFlags:  number ;

			if(isInt(arguments[0])){
				var iOffset:  number ;
				var iSize:  number ;

				if(arguments.length === 1){
					iLockFlags === arguments[0];
					iOffset = 0;
					iSize = this.byteLength;
				}
				else {
					iOffset = arguments[0];
					iSize = arguments[1];
					iLockFlags = (arguments.length === 3) ? arguments[2] : EHardwareBufferFlags.READABLE;
				}

				logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 307 ); logger.assert(!this.isLocked(), "Cannot lock this buffer, it is already locked!");
                                                         ;
				logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 309 ); logger.assert(iOffset === 0 && iSize === this.byteLength, "Cannot lock memory region, most lock box or entire buffer");
                                                                   ;

				pLockBox = new geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
			}

			if(this.isBackupPresent()){
				if (! (((iLockFlags) & (ELockFlags.WRITE)) != 0) ) {
// we have to assume a read / write lock so we use the shadow buffer
// and tag for sync on unlock()
                    this._pBackupUpdated = true;
                }

                this._pCurrentLock = (<WebGLPixelBuffer>(this._pBackupCopy)).lock(pLockBox, iLockFlags);
			}
			else {
				this._pCurrentLock = this.lockImpl(pLockBox, iLockFlags);
				this._isLocked = true;
			}

			return this._pCurrentLock;
		}

		/**@protected*/  allocateBuffer(): void {
			if(!isNull(this._pBuffer.data)){
				return;
			}

			this._pBuffer.data = new Uint8Array(this.byteLength);
		}

		/**@protected*/  freeBuffer(): void {
			if( (((this._iFlags) & (EHardwareBufferFlags.STATIC)) != 0) ){
				this._pBuffer.data = null;
			}
		}

		/**@protected*/  lockImpl(iOffset:  number , iSize:  number , iLockFlags:  number ): any;
		/**@protected*/  lockImpl(pLockBox: IBox, iLockFlags:  number ): IPixelBox;
		/**@protected*/  lockImpl(): any {
			if(arguments.length === 3){
				logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 349 ); logger.criticalError("lockImpl(offset,length) is not valid for PixelBuffers and should never be called"); ;
			}

			var pLockBox:IBox = arguments[0];
			var iLockFlags:  number  = arguments[1];

			this.allocateBuffer();

			if(! (((iLockFlags) & (ELockFlags.DISCARD)) != 0)  &&
			   (((this._iFlags) & (EHardwareBufferFlags.READABLE)) != 0) ){

			   	this.download(this._pBuffer);
			}

			this._iCurrentLockFlags = iLockFlags;
			this._pLockedBox = pLockBox;

			return this._pBuffer.getSubBox(pLockBox);
		}

		/**@protected*/  unlockImpl(): void {
			if ( (((this._iCurrentLockFlags) & (ELockFlags.WRITE)) != 0) ) {
// From buffer to card, only upload if was locked for writing
	            this.upload(this._pCurrentLock, this._pLockedBox);
	        }

	        this.freeBuffer();
		}





	}
}





















module akra {

	export interface IWebGLRenderer extends IRenderer {
		getWebGLContext(): WebGLRenderingContext;

/** Buffer Objects. */

		bindWebGLBuffer(eTarget:  number , pBuffer: WebGLBuffer): void;
		createWebGLBuffer(): WebGLBuffer;
		deleteWebGLBuffer(pBuffer: WebGLBuffer): void;

/** Texture Objects. */

		bindWebGLTexture(eTarget:  number , pTexture: WebGLTexture): void;
		activateWebGLTexture(iSlot:  number ): void;
		createWebGLTexture(): WebGLTexture;
		deleteWebGLTexture(pTexture: WebGLTexture): void;

/** Framebuffer Objects */

		createWebGLFramebuffer(): WebGLFramebuffer;
		bindWebGLFramebuffer(eTarget:  number , pBuffer: WebGLFramebuffer): void;
		deleteWebGLFramebuffer(pBuffer: WebGLFramebuffer): void;

/** Renderbuffer Objects */

		createWebGLRenderbuffer(): WebGLRenderbuffer;
		bindWebGLRenderbuffer(eTarget:  number , pBuffer: WebGLRenderbuffer): void;
		deleteWebGLRenderbuffer(pBuffer: WebGLRenderbuffer): void;

		useWebGLProgram(pProgram: WebGLProgram): void;
		createWebGLProgram(): WebGLProgram;
		deleteWebGLProgram(pProgram: WebGLProgram): void;

		disableAllWebGLVertexAttribs(): void;

		getError(): string;
	}
}









module akra.core.pool.resources {

    export enum ETextureForcedFormatFlags {
        FORCEMIPLEVELS = 0,
        FORCEFORMAT,
        FORCESIZE
    }

	export class Texture extends ResourcePoolItem implements ITexture {
        /**@protected*/  _iFlags:  number  = ETextureFlags.DEFAULT;
        /**@protected*/  _iWidth:  number  = 512;
        /**@protected*/  _iSrcWidth:  number  = 0;
        /**@protected*/  _iHeight:  number  = 512;
        /**@protected*/  _iSrcHeight:  number  = 0;
        /**@protected*/  _iDepth:  number  = 1;
        /**@protected*/  _iSrcDepth:  number  = 0;
        /**@protected*/  _eFormat: EPixelFormats = EPixelFormats.UNKNOWN;
        /**@protected*/  _nMipLevels:  number  = 0;
        /**@protected*/  _nRequestedMipLevels:  number  = 0;
        /**@protected*/  _eTextureType: ETextureTypes = ETextureTypes.TEXTURE_2D;
        /**@protected*/  _iDesiredIntegerBitDepth:  number  = 0;
        /**@protected*/  _iDesiredFloatBitDepth:  number  = 0;

        /**@protected*/  _eDesiredFormat: EPixelFormats = EPixelFormats.UNKNOWN;
        /**@protected*/  _eSrcFormat: EPixelFormats = EPixelFormats.UNKNOWN;

        /**@protected*/  _pParams: IntMap = <IntMap>{};

        /**@protected*/  _isInternalResourceCreated: bool = false;
        /**@protected*/  _isMipmapsHardwareGenerated: bool = false;

        /**@protected*/  _iResourceSize:  number  = 0;

        constructor () {
            super();

            this._pParams[ETextureParameters.MIN_FILTER] = ETextureFilters.NEAREST;
            this._pParams[ETextureParameters.MAG_FILTER] = ETextureFilters.NEAREST;

            this._pParams[ETextureParameters.WRAP_S] = ETextureWrapModes.CLAMP_TO_EDGE;
            this._pParams[ETextureParameters.WRAP_T] = ETextureWrapModes.CLAMP_TO_EDGE;
        }

		/**@inline*/  get width():  number  {
			return this._iWidth;
		}

        /**@inline*/  set width(iWidth:  number ) {
            this._iWidth = this._iSrcWidth = iWidth;
        }

        /**@inline*/  get height():  number  {
        	return this._iHeight;
        }

        /**@inline*/  set height(iHeight:  number ) {
            this._iHeight = this._iSrcHeight = iHeight;
        }

        /**@inline*/  get depth():  number  {
            return this._iDepth;
        }

        /**@inline*/  set depth(iDepth:  number ) {
            this._iDepth = this._iSrcDepth = iDepth;
        }

        /**@inline*/  get format(): EPixelFormats {
        	return this._eFormat;
        }

        /**@inline*/  set format(eFormat: EPixelFormats) {
            this._eFormat = eFormat;
            this._eDesiredFormat = eFormat;
            this._eSrcFormat = eFormat;
        }

        /**@inline*/  get textureType(): ETextureTypes {
            return this._eTextureType;
        }

        /**@inline*/  set textureType(eTextureType: ETextureTypes) {
            this._eTextureType = eTextureType;
        }

        /**@inline*/  get mipLevels():  number  {
            return this._nMipLevels;
        }

        /**@inline*/  set mipLevels(nMipLevels:  number ) {
            this._nMipLevels = nMipLevels;
        }

        /**@inline*/  get desiredIntegerBitDepth():  number  {
            return this._iDesiredIntegerBitDepth;
        }

        /**@inline*/  set desiredIntegerBitDepth(iDesiredIntegerBitDepth:  number ) {
            this._iDesiredIntegerBitDepth = iDesiredIntegerBitDepth;
        }

        /**@inline*/  get desiredFloatBitDepth():  number  {
            return this._iDesiredFloatBitDepth;
        }

        /**@inline*/  set desiredFloatBitDepth(iDesiredFloatBitDepth:  number ) {
            this._iDesiredFloatBitDepth = iDesiredFloatBitDepth;
        }

        /**@inline*/  get srcWidth():  number  {
            return this._iSrcWidth;
        }

        /**@inline*/  get srcHeight():  number  {
            return this._iSrcHeight;
        }

        /**@inline*/  get srcDepth():  number  {
            return this._iSrcWidth;
        }

        /**@inline*/  get desiredFormat(): EPixelFormats {
            return this._eDesiredFormat;
        }

        /**@inline*/  get srcFormat(): EPixelFormats {
            return this._eSrcFormat;
        }

        /**@inline*/  getFlags():  number  {
            return this._iFlags;
        }

        /**@inline*/  setFlags(iFlags:  number ): void {
            this._iFlags = iFlags;
        }

        /**@inline*/  isTexture2D(): bool {
        	return this._eTextureType === ETextureTypes.TEXTURE_2D;
        }

        /**@inline*/  isTextureCube(): bool {
        	return this._eTextureType === ETextureTypes.TEXTURE_CUBE_MAP;
        }

        /**@inline*/  isCompressed(): bool {
        	return (this._eFormat >= EPixelFormats.DXT1 && this._eFormat <= EPixelFormats.DXT5) ||
                (this._eFormat >= EPixelFormats.PVRTC_RGB2 && this._eFormat <= EPixelFormats.PVRTC_RGBA4);
        }

        /**@inline*/  isValid(): bool {
            return isDefAndNotNull(this._isInternalResourceCreated);
        }

        /**@inline*/  calculateSize():  number  {
            return this.getNumFaces() * pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
        }

        /**@inline*/  getNumFaces():  number  {
            return this._eTextureType === ETextureTypes.TEXTURE_CUBE_MAP ? 6 : 1;
        }

        /**@inline*/  getSize():  number  {
            return this._iResourceSize;
        }

        getBuffer(iFace?:  number , iMipmap?:  number ): IPixelBuffer {
            return null;
        }

        create(iWidth:  number , iHeight:  number , iDepth:  number , cFillColor?: IColor,
               iFlags?:  number , nMipLevels?:  number , eTextureType?: ETextureTypes, eFormat?: EPixelFormats): bool;
        create(iWidth:  number , iHeight:  number , iDepth:  number , pPixels?: Array,
               iFlags?:  number , nMipLevels?:  number , eTextureType?: ETextureTypes, eFormat?: EPixelFormats): bool;
        create(iWidth:  number , iHeight:  number , iDepth:  number , pPixels?: ArrayBufferView,
               iFlags?:  number , nMipLevels?:  number , eTextureType?: ETextureTypes, eFormat?: EPixelFormats): bool;
        create(iWidth:  number , iHeight:  number , iDepth:  number , pPixels?: any = null,
               iFlags?:  number  = 0, nMipLevels?:  number  = 0,
               eTextureType?: ETextureTypes = ETextureTypes.TEXTURE_2D,
               eFormat?: EPixelFormats = EPixelFormats.R8G8B8): bool {

            this._iWidth = iWidth;
            this._iHeight = iHeight;
            this._iDepth = iDepth;
            this._iFlags = iFlags;
            this._nMipLevels = nMipLevels;
            this._eTextureType = eTextureType;
            this._eFormat = eFormat;

            if(isDef(pPixels.length)){
                if(pPixels instanceof Array) {
                    pPixels = new Uint8Array(pPixels);
                }
                return this.loadRawData(pPixels, iWidth, iHeight, eFormat);
            }
            else {
                return this.createInternalTexture(pPixels);
            }
        }

        destroy(): void {
            this.freeInternalTexture();
        }

        destroyResource(): bool {
            this.destroy();
            this.notifyDestroyed();
            return true;
        }

        setParameter(eParam: ETextureParameters, eValue: ETextureFilters): void;
        setParameter(eParam: ETextureParameters, eValue: ETextureWrapModes): void;
        setParameter(eParam: ETextureParameters, eValue:  number ): bool {
            if (!this.isValid()) {
                return false;
            }

            this._pParams[eParam] = eValue;

        	return true;
        }

        loadRawData(pStream: ArrayBufferView, iWidth:  number , iHeight:  number , eFormat: EPixelFormats): bool {
            var pTempImg: IImg = <IImg>this.getManager().imagePool.findResource(".temp_image");

            if(isNull(pTempImg)){
                pTempImg = <IImg>this.getManager().imagePool.createResource(".temp_image");
//pTempImg.create();
            }

            pTempImg.loadRawData(<Uint8Array>pStream, iWidth, iHeight, eFormat);
            var isLoaded: bool = this.loadImage(pTempImg);
            this.getManager().imagePool.destroyResource(pTempImg);

            return isLoaded;
        }

        loadImage(pImage: IImg): bool {
            var isLoaded:bool = this._loadImages(pImage, true);

            if(isLoaded) {
                this.notifyLoaded();
                return true;
            }
            else {
                return false;
            }
        }

        loadImages(pImages: IImg[]): bool {
            var isLoaded:bool = this._loadImages(pImages);

            if(isLoaded) {
                this.notifyLoaded();
                return true;
            }
            else{
                return false;
            }
        }

        _loadImages(pImageList: IImg[]): bool;
        _loadImages(pImage: IImg, bOneImage: bool): bool;
        _loadImages(): bool {
            if(this.isResourceLoaded()){
                logger.setSourceLocation( "core/pool/resources/Texture.ts" , 276 ); logger.warning("Yoy try to load texture when it already have been loaded. All texture data was destoyed."); ;
                this.freeInternalTexture();
            }

            var pMainImage: IImg = null;
            var pImageList: IImg[] = null;

            if(arguments.length === 2) {
                pMainImage = arguments[0];
            }
            else {
                pImageList = arguments[0];
                if(pImageList.length === 0) {
                    logger.setSourceLocation( "core/pool/resources/Texture.ts" , 289 ); logger.criticalError("Cannot load empty list of images"); ;
                    return false;
                }
                pMainImage = pImageList[0];
            }

            this._iSrcWidth = this._iWidth = pMainImage.width;
            this._iSrcHeight = this._iHeight = pMainImage.height;
            this._iSrcDepth = this._iDepth = pMainImage.depth;

// Get source image format and adjust if required
            this._eSrcFormat = pMainImage.format;

            if (this._eDesiredFormat !== EPixelFormats.UNKNOWN) {
// If have desired format, use it
                this._eFormat = this._eDesiredFormat;
            }
            else {
// Get the format according with desired bit depth
                this._eFormat = pixelUtil.getFormatForBitDepths(this._eSrcFormat, this._iDesiredIntegerBitDepth, this._iDesiredFloatBitDepth);
            }

// The custom mipmaps in the image have priority over everything
            var iImageMips:  number  = pMainImage.numMipMaps;

            if(iImageMips > 0) {
                this._nMipLevels = this._nRequestedMipLevels = iImageMips;
// Disable flag for auto mip generation
                ((this._iFlags) &= ~(ETextureFlags.AUTOMIPMAP)) ;
            }
// Create the texture
            this.createInternalTexture(null);
// Check if we're loading one image with multiple faces
// or a vector of images representing the faces
            var iFaces:  number  = 0;
            var isMultiImage: bool = false;

            if(!isNull(pImageList) && pImageList.length > 1){
                iFaces = pImageList.length;
                isMultiImage = true;
            }
            else {
                iFaces = pMainImage.numFaces;
                isMultiImage = false;
            }

// Check wether number of faces in images exceeds number of faces
// in this texture. If so, clamp it.
            if(iFaces > this.getNumFaces()){
                iFaces = this.getNumFaces();
            }

// Main loading loop
// imageMips == 0 if the image has no custom mipmaps, otherwise contains the number of custom mips
            var mip:  number  = 0;
            var i:  number  = 0;
            for(mip = 0; mip <= iImageMips; ++mip) {
                for(i = 0; i < iFaces; ++i) {
                    var pSrc: IPixelBox;

                    if(isMultiImage){
// Load from multiple images
                        pSrc = pImageList[i].getPixels(0, mip);
                    }
                    else {
// Load from faces of images[0] or main Image
                        pSrc = pMainImage.getPixels(i, mip);
                    }

// Sets to treated format in case is difference
                    pSrc.format = this._eSrcFormat;
// Destination: entire texture. blitFromMemory does the scaling to
// a power of two for us when needed
                    this.getBuffer(i, mip).blitFromMemory(pSrc);
                }
            }
// Update size (the final size, not including temp space)
            this._iResourceSize = this.getNumFaces() * pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
            return true;
        }

        convertToImage(pDestImage: IImg, bIncludeMipMaps: bool): void {
            var iNumMips:  number  = bIncludeMipMaps ? this._nMipLevels + 1 : 1;
            var iDataSize:  number  = pixelUtil.calculateSizeForImage(iNumMips, this._nMipLevels,
                                                                  this._iWidth, this._iHeight, this._iDepth,
                                                                  this._eFormat);

            var pPixData: Uint8Array = new Uint8Array(iDataSize);
// if there are multiple faces and mipmaps we must pack them into the data
// faces, then mips
            var pCurrentPixData: Uint8Array = pPixData;

            var iFace:  number  = 0;
            var mip:  number  = 0;

            for (iFace = 0; iFace < this.getNumFaces(); ++iFace) {
                for (mip = 0; mip < iNumMips; ++mip) {

                    var iMipDataSize = pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);

                    var pPixBox: IPixelBox = new pixelUtil.PixelBox(this._iWidth, this._iHeight, this._iDepth, this._eFormat, pCurrentPixData);
                    this.getBuffer(iFace, mip).blitToMemory(pPixBox);

                    pCurrentPixData = pCurrentPixData.subarray(iMipDataSize);

                }
            }

// load, and tell Image to delete the memory when it's done.
            pDestImage.loadDynamicImage(pPixData, this._iWidth, this._iHeight, this._iDepth, this._eFormat, true,
                this.getNumFaces(), iNumMips - 1);
        }

        copyToTexture(pTarget: ITexture): void {
            if(pTarget.getNumFaces() !== this.getNumFaces()){
                logger.setSourceLocation( "core/pool/resources/Texture.ts" , 404 ); logger.criticalError("Texture types must match"); ;
            }

            var nMipLevels:  number  = Math.min(this._nMipLevels, pTarget.mipLevels);
            if( (((this._iFlags) & (ETextureFlags.AUTOMIPMAP)) != 0)  ||  (((this.getFlags()) & (ETextureFlags.AUTOMIPMAP)) != 0) ){
                nMipLevels = 0;
            }

            var iFace:  number  = 0, mip:  number  = 0;

            for(iFace = 0; iFace < this.getNumFaces(); iFace++){
                for(mip = 0; mip <= nMipLevels; mip++){
                    pTarget.getBuffer(iFace, mip).blit(this.getBuffer(iFace, mip));
                }
            }
        }

        createInternalTexture(cFillColor?: IColor = null): bool {
            if(!this._isInternalResourceCreated) {
                this.createInternalTextureImpl(cFillColor);
                this._isInternalResourceCreated = true;
                this.notifyCreated();
                return true;
            }

        	return false;
        }

        freeInternalTexture(): bool {
            if(this._isInternalResourceCreated){
                this.freeInternalTextureImpl();
                this._isInternalResourceCreated = false;
                this.notifyDestroyed();
                return true;
            }

            return false;
        }

        getNativeFormat(eTextureType?: ETextureTypes = this._eTextureType,
                        eFormat?: EPixelFormats = this._eFormat,
                        iFlags?:  number  = this._iFlags): EPixelFormats {

            return null;
        }

        /**@protected*/  createInternalTextureImpl(cFillColor?: IColor = null): bool {
            return false;
        }

        /**@protected*/  freeInternalTextureImpl(): bool {
            return false;
        }
	}
}






























module akra {
	export interface IDepthBuffer extends IRenderResource {
		bitDepth:  number ;
		width:  number ;
		height:  number ;

		create(iBitDepth:  number , iWidth:  number , iHeight:  number , bManual: bool): void;

		isManual(): bool;
		isCompatible(pTarget: IRenderTarget): bool;

		_notifyRenderTargetAttached(pTarget: IRenderTarget): void;
		_notifyRenderTargetDetached(pTarget: IRenderTarget): void;
	}
}






module akra {
	export interface IFPSStat {
		last:  number ;
		avg:  number ;
		best:  number ;
		worst:  number ;
	};

	export interface ITimeStat {
		best:  number ;
		worst:  number ;
	};

	export interface IFrameStats {
		fps: IFPSStat;
		time: ITimeStat;
		polygonsCount:  number ;
	}
}







module akra {
	export enum EFramebuffer {
		FRONT,
		BACK,
		AUTO
	};

	export enum EStatFlags {
		NONE           = 0,
        FPS            = 1,
        AVG_FPS        = 2,
        BEST_FPS       = 4,
        WORST_FPS      = 8,
        TRIANGLE_COUNT = 16,
        ALL            = 0xFFFF
	};

	export interface IRenderTarget extends IEventProvider {
		name: string;
		width:  number ;
		height:  number ;


		colorDepth:  number ;

		totalViewports:  number ;

		priority:  number ;

		getRenderer(): IRenderer;

		getDepthBuffer(): IDepthBuffer;

		attachDepthBuffer(pBuffer: IDepthBuffer): bool;
		attachDepthPixelBuffer(pBuffer: IPixelBuffer): bool;
		attachDepthTexture(pTexture: ITexture): bool;

		detachDepthBuffer(): void;
		detachDepthTexture(): void;
		detachDepthPixelBuffer(): void;

		destroy(): void;

		update(): void;
		updateStats(): void;

		getCustomAttribute(sName: string): any;

		addViewport(pCamera: ICamera, csRenderMethod?: string, iZIndex?:  number , fLeft?:  number , fTop?:  number , fWidth?:  number , fHeight?:  number ): IViewport;
		addViewport(pCamera: ICamera, eType?:  number , iZIndex?:  number , fLeft?:  number , fTop?:  number , fWidth?:  number , fHeight?:  number ): IViewport;

		getViewport(iIndex:  number ): IViewport;
		getViewportByZIndex(iZIndex:  number ): IViewport;
		hasViewportByZIndex(iZIndex:  number ): bool;
		removeViewport(iZIndex:  number ): bool;
		removeAllViewports():  number ;

		getPolygonCount():  number ;

		getStatistics(): IFrameStats;
		getLastFPS():  number ;
		getAverageFPS():  number ;
		getBestFPS():  number ;
		getWorstFPS():  number ;

		getBestFrameTime():  number ;
		getWorstFrameTime():  number ;
		resetStatistics(): void;

		isActive(): bool;
		setActive(isActive?: bool): void;
		setAutoUpdated(isAutoUpdate?: bool): void;
		isAutoUpdated(): bool;
		isPrimary(): bool;

		readPixels(ppDest?: IPixelBox, eFramebuffer?: EFramebuffer): IPixelBox;

		_beginUpdate(): void;
		_updateViewport(iZIndex:  number , bUpdateStatistics?: bool): void;
		_updateViewport(pViewport: IViewport, bUpdateStatistics?: bool): void;
		_updateAutoUpdatedViewports(bUpdateStatistics?: bool): void;
		_endUpdate(): void;

		 preUpdate(): void;
		 postUpdate(): void;

		 viewportPreUpdate(pViewport: IViewport): void;
		 viewportPostUpdate(pViewport: IViewport): void;
		 viewportAdded(pViewport: IViewport): void;
		 viewportRemoved(pViewport: IViewport): void;

		 cameraRemoved(pCamera: ICamera): void;
	}
}








module akra {

	export interface IRenderTexture extends IRenderTarget {
		copyContentsToMemory(pDest: IPixelBox, pBuffer: EFramebuffer): void;
		suggestPixelFormat(): EPixelFormats;
	}
}






































module akra {

















    export enum ENodeCreateMode {
        k_Default,
        k_Necessary,
        k_Not
    }

    export enum EParserCode {
        k_Pause,
        k_Ok,
        k_Error
    }

    export enum EParserType {
        k_LR0,
        k_LR1,
        k_LALR
    }

    export enum EParseMode {
        k_AllNode = 0x0001,
        k_Negate = 0x0002,
        k_Add = 0x0004,
        k_Optimize = 0x0008,
        k_DebugMode = 0x0010
    }

    export enum ETokenType {
        k_NumericLiteral = 1,
        k_CommentLiteral,
        k_StringLiteral,
        k_PunctuatorLiteral,
        k_WhitespaceLiteral,
        k_IdentifierLiteral,
        k_KeywordLiteral,
        k_Unknown,
        k_End
    }

    export interface IToken {
        value: string;
        start:  number ;
        end:  number ;
        line:  number ;

        name?: string;
        type?: ETokenType;
    }


    export interface IRule {
        left: string;
        right: string[];
        index:  number ;
    }

    export interface IFinishFunc {
        (eCode: EParserCode): void;
    }

    export enum EOperationType {
        k_Error = 100,
        k_Shift,
        k_Reduce,
        k_Success,
        k_Pause,
        k_Ok
    }

    export interface IRuleFunction {
        (): EOperationType;
    }

    export interface IParseNode {
        children: IParseNode[];
        parent: IParseNode;
        name: string;
        value: string;

//Data for next-step analyze
        isAnalyzed: bool;
        position:  number ;

        start?:  number ;
        end?:  number ;
        line?:  number ;
    }

    export interface IParseTree {
        setRoot(): void;

        setOptimizeMode(isOptimize: bool): void;

        addNode(pNode: IParseNode): void;
        reduceByRule(pRule: IRule, eCreate: ENodeCreateMode);

        toString(): string;

        clone(): IParseTree;

        getNodes(): IParseNode[];
        getLastNode(): IParseNode;

        root: IParseNode;
    }

    export interface ILexer {
        addPunctuator(sValue: string, sName?: string): string;
        addKeyword(sValue: string, sName: string): string;

        getTerminalValueByName(sName: string): string;

        init(sSource: string): void;

        getNextToken(): IToken;
    }

    export interface IParser {

        isTypeId(sValue: string): bool;

        returnCode(pNode: IParseNode): string;

        init(sGrammar: string, eMode?: EParseMode, eType?: EParserType): bool;

        parse(sSource: string, isSync?: bool, fnFinishCallback?: IFinishFunc, pCaller?: any): EParserCode;

        setParseFileName(sFileName: string): void;
        getParseFileName(): string;

        pause(): EParserCode;
        resume(): EParserCode;

        printStates(isPrintOnlyBase?: bool): void;
        printState(iStateIndex:  number , isPrintOnlyBase?: bool): void;

        getGrammarSymbols(): StringMap;
    }
}









module akra {

	export interface IAFXInstructionStateMap extends StringMap{
	}

	export interface IAFXInstructionRoutine {
		(): void;
	}
/**
	 * All opertion are represented by: 
	 * operator : arg1 ... argn
	 * Operator and instructions may be empty.
	 */

	export interface IAFXInstruction {
        setParent(pParent: IAFXInstruction): void;
        getParent(): IAFXInstruction;

        setOperator(sOperator: string): void;
        getOperator(): string;

        setInstructions(pInstructionList: IAFXInstruction[]): void;
        getInstructions(): IAFXInstruction[];

// /**
//  * Contain states of instruction
//  */
// stateMap: IAFXInstructionStateMap;

    	push(pInstruction: IAFXInstruction, isSetParent?: bool): void;

// changeState(sStateName: string, sValue: string): void;
// changeState(iStateIndex: int, sValue: string): void;

// stateChange(): void;
// isStateChange(): bool;

    	addRoutine(fnRoutine: IAFXInstructionRoutine, iPriority?:  number );
    	toString(): string;
    }

    export interface IAFXVariableTypeInstruction extends IAFXInstruction {
//type : IAFXTypeInstruction
//array: IAFXArrayInstruction
//pointer : IAFXPointerInstruction
        addArrayIndex(pExpr: IAFXExprInstruction): void;
        addPointIndex(): void;
        setVideoBuffer(pBuffer: IAFXIdInstruction): void;

        getTypeByIndex(): IAFXVariableTypeInstruction;
        getField(sFieldName: string, isCreateExpr: bool): IAFXIdExprInstruction;
        getPointerType(): IAFXVariableTypeInstruction;

        isEqual(pType: IAFXVariableTypeInstruction): bool;
        isBase(): bool;
        isArray(): bool;
        isPointer(): bool;
    }

    export interface IAFXTypedInstruction extends IAFXInstruction {
        getType(): IAFXVariableTypeInstruction;
        setType(pType: IAFXVariableTypeInstruction): void;
    }

    export interface IAFXDeclInstruction extends IAFXTypedInstruction {
        setSemantic(sSemantic: string);
        setAnnotation(pAnnotation: IAFXAnnotationInstruction): void;
    }

    export interface IAFXTypeDeclInstruction extends IAFXDeclInstruction {

    }

    export interface IAFXVariableDeclInstruction extends IAFXDeclInstruction {

    }

    export interface IAFXFunctionDeclInstruction extends IAFXDeclInstruction {
        getNameId(): IAFXIdInstruction;
        hasImplementation(): bool;
    }

    export interface IAFXUsageTypeInstruction extends IAFXInstruction {
//usage: IAFXKeywordInstruction[]
//id: IAFXIdInstruction
    }

    export interface IAFXStructDeclInstruction extends IAFXInstruction {
//id: IAFXIdInstruction
//structFields: IAFXStructInstruction
    }

    export interface IAFXBaseTypeInstruction extends IAFXInstruction {
//id: IAFXIdInstruction
//...
    }

    export interface IAFXIdInstruction extends IAFXInstruction {
        getName(): string;
        getRealName(): string;

        setName(sName: string): void;
        setRealName(sName: string): void;
    }

    export interface IAFXKeywordInstruction extends IAFXInstruction {
        setValue(sValue: string): void;
    }


    export interface IAFXExprInstruction extends IAFXTypedInstruction {

    }

    export interface IAFXIdExprInstruction extends IAFXExprInstruction {

    }

    export interface IAFXLiteralInstruction extends IAFXExprInstruction {
        setValue(pValue: any): void;
    }

    export interface IAFXAnnotationInstruction extends IAFXInstruction{

    }

    export interface IAFXStmtInstruction extends IAFXInstruction{

    }

}



module akra {

    export interface IAFXObject{
        getName(): string;
        getId(): IAFXIdInstruction;
    }

    export interface IAFXVariable extends IAFXObject {
        setName(sName: string): void;
        setType(pType: IAFXVariableTypeInstruction): void;
        getType(): IAFXVariableTypeInstruction;

        initializeFromInstruction(pInstruction: IAFXVariableDeclInstruction): void;

    }

    export interface IAFXType extends IAFXObject {
        isBase(): bool;
        initializeFromInstruction(pInstruction: IAFXTypeDeclInstruction): bool;
    }

    export interface IAFXFunction extends IAFXObject {
        getHash(): string;
    }

    export interface IAFXPass extends IAFXObject {

    }

    export interface IAFXTechnique extends IAFXObject {

    }

    export interface IAFXEffectStats{
        time:  number ;
    }

    export interface IAFXEffect {
        analyze(pTree: IParseTree): bool;
        setAnalyzedFileName(sFileName: string): void;
        getStats(): IAFXEffectStats;

        clear(): void;
    }
}



// #ifndef IAFXEFFECT_TS
// #define IAFXEFFECT_TS

// #include "IResourcePoolItem.ts"

// module akra {
// 	export interface IAFXEffect extends IResourcePoolItem {

// 	}
// }

// #endif





module akra {
	export interface IAFXPreRenderState {

	}
}







module akra {
	export interface IAFXComponentBlend {

	}
}







module akra {
	export interface IAFXPassBlend {
		blend(csPass: string): void;
	}
}















module akra {
    export interface IRenderDataCollection {} ;
    export interface IDataFlow {} ;
    export interface IVertexDeclaration {} ;
    export interface IVertexData {} ;

	export enum ERenderDataTypes {
/*<! положить данные в текстуру, и больше ничего не делать.*/
        ISOLATED = 0,
/*<! обычные даннае из текстуры, доступные по индексу.*/
        INDEXED,
/*<! данные по 2йному индексу.*/
        I2I,
/*<! непосредственно данные для атрибута.*/
        DIRECT
    };

    export enum ERenderDataOptions {
/*<! использовать индекс на индекс упаковку данных*/
        ADVANCED_INDEX =  (1 << (0x10)) ,
        SINGLE_INDEX   =  (1 << (0x11)) ,
/*<! создать RenderData как классические данные, с данными только в аттрибутах, без использования видео буфферов.*/

/*<! определяет, будет ли объект редерится*/
        RENDERABLE     =  (1 << (0x12))
    }

    export interface IRenderDataType {
        new (): IRenderData;
    }

	export interface IRenderData extends IReferenceCounter {
		 buffer: IRenderDataCollection;

/**
         * Allocate data for rendering.
         */

        allocateData(pDataDecl: IVertexElementInterface[], pData: ArrayBuffer, hasIndex?: bool):  number ;
        allocateData(pDataDecl: IVertexElementInterface[], pData: ArrayBufferView, hasIndex?: bool):  number ;
        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBuffer, hasIndex?: bool):  number ;
        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBufferView, hasIndex?: bool):  number ;

/**
         * Remove data from this render data.
         */

        releaseData(iDataLocation:  number ): void;

        allocateAttribute(pAttrDecl: IVertexDeclaration, pData: ArrayBuffer): bool;
        allocateAttribute(pAttrDecl: IVertexDeclaration, pData: ArrayBufferView): bool;

        allocateIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBuffer): bool;
        allocateIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBufferView): bool;
        allocateIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBuffer): bool;
        allocateIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBufferView): bool;

        addIndexSet(usePreviousDataSet?: bool, ePrimType?: EPrimitiveTypes, sName?: string):  number ;
        getNumIndexSet():  number ;
        getIndexSetName(iSet:  number ): string;
        selectIndexSet(iSet:  number ): bool;
        selectIndexSet(sName: string): bool;
        getIndexSet():  number ;

/**
         * Specifies uses advanced index.
         */

        useAdvancedIndex(): bool;
        useSingleIndex(): bool;
        useMultiIndex(): bool;

/** mark index set as renderable */

        setRenderable(iIndexSet:  number , bValue: bool): void;
        isRenderable(iIndexSet:  number ): bool;

/** Mark this RenderData as renderable. */

        isRenderable(): bool;
        setRenderable(bValue: bool): void;

        hasSemantics(sSemantics: string, bSearchComplete?: bool): bool;

        getDataLocation(iDataLocation:  number ):  number ;
        getDataLocation(sSemantics: string):  number ;
        getIndices(): IBufferData;
        getPrimitiveCount():  number ;
        getAdvancedIndexData(sSemantics: string): IVertexData;

        index(sData: string, sSemantics: string, useSame?: bool, iBeginWith?:  number ): bool;
        index(iData:  number , sSemantics: string, useSame?: bool, iBeginWith?:  number ): bool;


        toString(): string;

//applyMe(): bool;

        _draw(): void;

        _getFlow(iDataLocation:  number ): IDataFlow;
        _getFlow(sSemantics: string, bSearchComplete?: bool): IDataFlow;

        _getData(iDataLocation:  number , bSearchOnlyInCurrentMap?: bool): IVertexData;
        _getData(sSemanticsn: string, bSearchOnlyInCurrentMap?: bool): IVertexData;

        _addData(pVertexData: IVertexData, iFlow?:  number , eType?: ERenderDataTypes):  number ;

        _setup(pCollection: IRenderDataCollection, iId:  number , ePrimType?: EPrimitiveTypes, eOptions?:  number ): bool;

//FIXME: hack for terrain, for force limitin drawing index length
        _setIndexLength(iLength:  number );
	}
}




//#include "IHardwareBuffer.ts"
module akra {
    export interface IRenderDataCollection {} ;
    export interface ISkeleton {} ;
    export interface IRect3d {} ;
    export interface ISphere {} ;
    export interface IMeshSubset {} ;
    export interface ISceneNode {} ;
    export interface ISceneModel {} ;
    export interface ISkin {} ;

	export enum EMeshOptions {
        HB_READABLE = < number >EHardwareBufferFlags.READABLE,
        RD_ADVANCED_INDEX = < number >ERenderDataOptions.ADVANCED_INDEX
    };

    export enum EMeshCloneOptions{
/*<! copy only geometry*/
        GEOMETRY_ONLY = 0x00,
/*<! use shared geometry*/
        SHARED_GEOMETRY = 0x01
    };

    export interface IMeshMap {
        [name: string]: IMesh;
    }

	export interface IMesh extends IEventProvider {
         flexMaterials: IMaterial[];
         name: string;
         data: IRenderDataCollection;
/*<! number of submeshes in. */
         length:  number ;
         boundingBox: IRect3d;
         boundingSphere: ISphere;

		skeleton: ISkeleton;


        getOptions():  number ;
        getEngine(): IEngine;

//setup(sName: string, eOptions: int, pDataBuffer?: IRenderDataCollection): bool;
        destroy(): void;
        clone(iCloneOptions:  number ): IMesh;

/** @deprecated */

        replaceFlexMaterials(pFlexMaterials): void;
/** @deprecated */

        getFlexMaterial(iMaterial:  number ): IMaterial;
        getFlexMaterial(csName: string): IMaterial;
/** @deprecated */

        addFlexMaterial(sName: string, pMaterial?: IMaterial): bool;
/** @deprecated */

        setFlexMaterial(iMaterial:  number ): bool;
        setFlexMaterial(csName: string): bool;

        createSubset(sName: string, ePrimType: EPrimitiveTypes, eOptions?:  number );
        freeSubset(sName: string): bool;
        getSubset(sMesh: string): IMeshSubset;
        getSubset(i:  number ): IMeshSubset;
        appendSubset(sName: string, pData: IRenderData): IMeshSubset;

        setSkin(pSkin: ISkin): void;
        setSkeleton(pSkeleton: ISkeleton): void;
        createSkin(): ISkin;

        createBoundingBox(): bool;
        deleteBoundingBox(): bool;
        showBoundingBox(): bool;
        hideBoundingBox(): bool;
        createAndShowSubBoundingBox(): void;

        createBoundingSphere(): bool;
        deleteBoundingSphere(): bool;
        showBoundingSphere(): bool;
        hideBoundingSphere(): bool;
        createAndShowSubBoundingSphere(): void;

/** TRUE if only one mesh subset has a shadow. */

        hasShadow(): bool;
/** Add shadow for all subsets. */

        setShadow(bValue?: bool): void;

        isReadyForRender(): bool;

        toSceneModel(pParent: ISceneNode, sName?: string): ISceneModel;

        _drawSubset(iSubset:  number ): void;
        _draw(): void;

/** notify, when one of substets added or removed shadow */

         shadow(pSubset: IMeshSubset, bShadow: bool): void;
	}
}











module akra {

	export interface IMaterial {} ;
	export interface IAFXSamplerState {} ;
	export interface IAFXForeign {} ;
	export interface IAFXPass {} ;
	export interface IRenderData {} ;
	export interface IRenderMethod {} ;
	export interface ITexture {} ;
	export interface IVertexBuffer {} ;
	export interface IVertexData {} ;
	export interface IBufferMap {} ;


	export interface IRenderEntry {
		totalPasses:  number ;
		pass:  number ;

		effect: IRenderMethod;
		renderMethod: IRenderMethod;
		surfaceMaterial: ISurfaceMaterial;
		material: IMaterial;

		activatePass(iPass:  number ): bool;
		deactivatePass(): bool;
		renderPass(iPass:  number ): bool;

		begin(): bool;
		end(): bool;
		updated(bValue: bool): void;

		isMethodLoaded(): bool;
		isReady(): bool;
		isUpdated(): bool;

		setParameter(sName: string, pData: any, isSemantic?: string): bool;
		setParameterBySemantics(sName: string, pData: any): bool;
		setComplexParameter(sName: string, pData: any, isSemantic?: bool): bool;
		setComplexParameterBySemantics(sName: string, pData: any): bool;
		setParameterInArray(sName: string, pData: any, iElement:  number ): bool;
		setPassStates(pPasses: IAFXPass[], pTextures: ITexture[], pForeigns: IAFXForeign[]): void;

		setVertexBuffer(sName: string, pVertexBuffer: IVertexBuffer, isSemantic?: bool): bool;
		setVideoBufferBySemantics(sName: string, pVertexBuffer: IVertexBuffer): bool;

		setSamplerStates(sName: string, eParam: ETextureParameters, eValue: any, isSemantic?: bool): bool;
		setSamplerStatesBySemantics(sName: string, pState: IAFXSamplerState): bool;
		setSamplerStates(sName: string, pState: IAFXSamplerState, isSemantic?: bool): bool;
		setSamplerStatesBySemantics(sName: string, eParam: ETextureParameters, eValue: any): bool;

		setTexture(sName: string, pTexture: ITexture, isSemantic?: bool): bool;
		setTextureBySemantics(sName: string, pTexture: ITexture, isSemantic?: bool): bool;

		setForeignVariable(sName: string, pData: any): void;

		applyVertexData(pData: IVertexData): void;
		applyBufferMap(pBufferMap: IBufferMap): void;
		applyRenderData(pData: IRenderData): void;

	}
}








module akra {
	export interface IReferenceCounter {} ;
	export interface IVertexData {} ;
	export interface IDataMapper {} ;
	export interface IIndexData {} ;

	export enum EDataFlowTypes {
/*!< The data stream can be marked up its index.*/
        MAPPABLE   = 1,
/*!< The data stream cannot be marked up its index.*/
        UNMAPPABLE = 0
    };

    export interface IDataFlow {
    	flow:    number ;
        data:   IVertexData;
        type:   EDataFlowTypes;
        mapper: IDataMapper;
    }

    export interface IDataMapper {
    	data: IVertexData;
    	semantics: string;
    	addition:  number ;
    }

	export interface IBufferMap extends IReferenceCounter{
		primType: EPrimitiveTypes;
		index: IIndexData;
		length:  number ;

//FIXME: hack for terraing, for force limiting length of drawinf index.
/** writeonly */
		                 _length:  number ;

/** Number of primitives. */

		 primCount:  number ;
/** Maximum flow available in buffer map. */

		 limit:  number ;
/** Start index for drawning. */

		 startIndex:  number ;
/** Number of completed flows. */

		 size:  number ;
/** Completed flows. */

		 flows: IDataFlow[];
/** 
		 * Mappers. 
		 * @private
		 */

		 mappers: IDataMapper[];
/** 
		 * Offset in bytes for drawing with global idnex. 
		 * @deprecated
		 */

		 offset:  number ;

/**
		 * Find flow by semantics in.
		 * @param sSemantics VertexElement usage or semantics.
		 * @param {bool=} bComplete Find only in completed flows. Default is TRUE.
		 */

		getFlow(sSemantics: string, bComplete?: bool): IDataFlow;
		getFlow(iFlow:  number , bComplete?: bool): IDataFlow;
		reset(): void;

/**
		 * Add data to flow.
		 */

		flow(pVertexData: IVertexData):  number ;
		flow(iFlow:  number , pVertexData: IVertexData):  number ;
/**
		 * Add index for flow.
		 */

		mapping(iFlow:  number , pMap: IVertexData, sSemantics: string, iAddition?:  number ): bool;

/**
		 * Check, Is pData already used as flow or mapper.
		 */

		checkData(pData: IVertexData): bool;

/**
		 * Recals all statistics in buffer map.
		 */

		update(): bool;

		clone(bWithMapping?: bool): IBufferMap;
		toString(): string;

/**
		 * Draw buffer map.
		 */

		_draw(): void;
	}
}






module akra {

    export interface ISampler2d {} ;
    export interface IVertexData {} ;
    export interface ITexture {} ;
    export interface IMat2 {} ;
    export interface IMat3 {} ;
    export interface IMat4 {} ;
    export interface IVec2 {} ;
    export interface IVec3 {} ;
    export interface IVec4 {} ;
    export interface IQuat4 {} ;
    export interface IBufferMap {} ;

    export interface IShaderProgram extends IRenderResource {
    	create(csVertex?: string, csPixel?: string): bool;
    	compile(csVertex?: string, csPixel?: string): bool;
    	isLinked(): bool;
    	isValid(): bool;
    	isActive(): bool;

    	setFloat(sName: string, fValue:  number ): void;
    	setInt(sName: string, iValue:  number ): void;

    	setVec2(sName: string, v2fValue: IVec2): void;
    	setVec2(sName: string, x:  number , y:  number ): void;

    	setVec2i(sName: string, v2iValue: IVec2): void;
    	setVec2i(sName: string, x:  number , y:  number ): void;

    	setVec3(sName: string, v3fValue: IVec3): void;
    	setVec3(sName: string, x:  number , y:  number , z:  number ): void;

    	setVec3i(sName: string, v3iValue: IVec3): void;
    	setVec3i(sName: string, x:  number , y:  number , z:  number ): void;

    	setVec4(sName: string, v4fValue: IVec4): void;
    	setVec4(sName: string, x:  number , y:  number , z:  number , w:  number ): void;

    	setVec4i(sName: string, v4iValue: IVec4): void;
    	setVec4i(sName: string, x:  number , y:  number , z:  number , w:  number ): void;

    	setMat3(sName: string, m3fValue: IMat3): void;
    	setMat4(sName: string, m4fValue: IMat4): void;

    	setFloat32Array(sName: string, pValue: Float32Array): void;
    	setInt32Array(sName: string, pValue: Int32Array): void;

    	setVec2Array(sName: string, pValue: IVec2[]): void;
    	setVec2iArray(sName: string, pValue: IVec2[]): void;

    	setVec3Array(sName: string, pValue: IVec3[]): void;
    	setVec3iArray(sName: string, pValue: IVec3[]): void;

    	setVec4Array(sName: string, pValue: IVec4[]): void;
    	setVec4iArray(sName: string, pValue: IVec4[]): void;

    	setMat3Array(sName: string, pValue: IMat3[]): void;
    	setMat4Array(sName: string, pValue: IMat4[]): void;

    	setStruct(sName: string, pData: Object): void;
    	setSampler2D(sName: string, pData: ISampler2d): void;
    	setSampler2DToStruct(sName: string, pData: ISampler2d): void;

    	setTexture(sName: string, pData: ITexture): void;

//applyVertexBuffer(sName: string, pBuffer: IVertexBuffer);
    	applyVertexData(sName: string, pData: IVertexData): void;

        applyBufferMap(pMap: IBufferMap): void;
    }
}















module akra {
	export interface IBufferData {
		byteOffset:  number ;
		byteLength:  number ;
		buffer: IBuffer;
	}
}



module akra {
	export interface IBufferDataModifier {} ;
	export interface IVertexDeclaration {} ;
	export interface IVertexBuffer {} ;
	export interface IEventProvider {} ;

	export interface IVertexData extends IBufferData, IBuffer, IEventProvider {
		 stride:  number ;
		 startIndex:  number ;
		 id:  number ;

		getVertexDeclaration(): IVertexDeclaration;
		setVertexDeclaration(pDecl: IVertexDeclaration): bool;

		getVertexElementCount():  number ;
		hasSemantics(sSemantics: string): bool;

		destroy(): void;

		extend(pDecl: IVertexDeclaration, pData?: ArrayBufferView): bool;
		resize(nCount:  number , pDecl?: IVertexDeclaration): bool;
		resize(nCount:  number , iStride?:  number ): bool;
		applyModifier(sUsage: string, fnModifier: IBufferDataModifier): bool;

		setData(pData: ArrayBufferView, iOffset:  number , iSize?:  number , nCountStart?:  number , nCount?:  number ): bool;
		setData(pData: ArrayBufferView, sUsage?: string, iSize?:  number , nCountStart?:  number , nCount?:  number ): bool;

		getData(): ArrayBuffer;
		getData(iOffset:  number , iSize:  number , iFrom?:  number , iCount?:  number ): ArrayBuffer;
		getData(sUsage: string): ArrayBuffer;
		getData(sUsage: string, iFrom:  number , iCount:  number ): ArrayBuffer;

		getTypedData(sUsage: string, iFrom?:  number , iCount?:  number ): ArrayBufferView;
		getBufferHandle():  number ;

		toString(): string;
	}
}











module akra {

	export interface IVertexData {} ;
	export interface IVertexElement {} ;
	export interface IVertexDeclaration {} ;

	export enum EVertexBufferTypes {
		UNKNOWN,
		VBO,
		TBO
	};

	export interface IVertexBuffer extends IHardwareBuffer, IRenderResource {

		 type: EVertexBufferTypes;

		getVertexData(i:  number ): IVertexData;
		getVertexData(iOffset:  number , iCount:  number , pElements: IVertexElement[]): IVertexData;
		getVertexData(iOffset:  number , iCount:  number , pDecl: IVertexDeclaration): IVertexData;

		getEmptyVertexData(iCount:  number , pElements: IVertexElement[], ppVertexDataIn?: IVertexData): IVertexData;
		getEmptyVertexData(iCount:  number , pDecl: IVertexDeclaration, ppVertexDataIn?: IVertexData): IVertexData;
		getEmptyVertexData(iCount:  number , pSize:  number , ppVertexDataIn?: IVertexData): IVertexData;

		freeVertexData(pVertexData: IVertexData): bool;
		freeVertexData(): bool;

		allocateData(pElements: IVertexElement[], pData: ArrayBufferView): IVertexData;
		allocateData(pDecl: IVertexDeclaration, pData: ArrayBufferView): IVertexData;
	}
}















module akra {

	export interface IIndexData {} ;

	export interface IIndexBuffer extends IHardwareBuffer, IRenderResource {

		getIndexData(iOffset:  number , iCount:  number , ePrimitiveType: EPrimitiveTypes, eElementsType: EDataTypes): IIndexData;
		getEmptyIndexData(iCount:  number , ePrimitiveType: EPrimitiveTypes, eElementsType: EDataTypes): IIndexData;

		freeIndexData(pIndexData: IIndexData): bool;


		allocateData(ePrimitiveType: EPrimitiveTypes, eElementsType: EDataTypes, pData: ArrayBufferView): IIndexData;
	}
}









module akra {
    export interface IRenderEntry {

    }
}






module akra {
	export enum EFrameBufferTypes {
		COLOR  = 0x1,
        DEPTH   = 0x2,
        STENCIL = 0x4
	}

	export interface IFrameBuffer {

	}
}



































//#define DL_DEFAULT DEFAULT_NAME;

module akra.render {
	export class Viewport implements IViewport {
		/**@protected*/  _pCamera: ICamera;
		/**@protected*/  _pTarget: IRenderTarget;

		/**@protected*/  _fRelLeft:  number ;
		/**@protected*/  _fRelTop:  number ;
		/**@protected*/  _fRelWidth:  number ;
		/**@protected*/  _fRelHeight:  number ;

		/**@protected*/  _iActLeft:  number ;
		/**@protected*/  _iActTop:  number ;
		/**@protected*/  _iActWidth:  number ;
		/**@protected*/  _iActHeight:  number ;

		/**@protected*/  _iZIndex:  number ;

		/**@protected*/  _cBackColor: IColor = new Color(Color.BLACK);

		/**@protected*/  _fDepthClearValue:  number  = 1.;

		/**@protected*/  _bClearEveryFrame: bool = true;

		/**@protected*/  _iClearBuffers:  number  = EFrameBufferTypes.COLOR | EFrameBufferTypes.DEPTH;

		/**@protected*/  _bUpdated: bool = false;

// protected _bShowOverlays: bool = true;

// protected _bShowSkies: bool = true;
// protected _bShowShadows: bool = true;

		/**@protected*/  _iVisibilityMask:  number  = 0xFFFFFFFF;

// protected _sRQSequenceName: string;
// protected mRQSequence: RenderQueueInvocationSequence;

		/**@protected*/  sMaterialSchemeName: string = DEFAULT_MATERIAL_NAME;

// static _eDefaultOrientationMode: EOrientationModes;

		/**@protected*/  _isAutoUpdated: bool = true;

		/**@protected*/  _csDefaultRenderMethod: string = null;

		/**@inline*/  get zIndex():  number  {
			return this._iZIndex;
		}

		/**@inline*/  get left():  number  { return this._fRelLeft; }
        /**@inline*/  get top():  number  { return this._fRelTop; }
        /**@inline*/  get width():  number  { return this._fRelWidth; }
        /**@inline*/  get height():  number  { return this._fRelHeight; }

        /**@inline*/  get actualLeft():  number  { return this._iActLeft; }
        /**@inline*/  get actualTop():  number  { return this._iActTop; }
        /**@inline*/  get actualWidth():  number  { return this._iActWidth; }
        /**@inline*/  get actualHeight():  number  { return this._iActHeight; }

        /**@inline*/  get backgroundColor(): IColor { return this._cBackColor; }
        /**@inline*/  set backgroundColor(cColor: IColor) { this._cBackColor = cColor; }

        /**@inline*/  get depthClear():  number  { return this._fDepthClearValue; }
        /**@inline*/  set depthClear(fDepthClearValue:  number ) { this._fDepthClearValue = fDepthClearValue; }


		constructor (pCamera: ICamera, pTarget: IRenderTarget, csRenderMethod: string = null, fLeft:  number  = 0., fTop:  number  = 0., fWidth:  number  = 1., fHeight:  number  = 1., iZIndex:  number  = 0) {
			this._pTarget = pTarget;

			this._fRelLeft = fLeft;
			this._fRelTop = fTop;
			this._fRelWidth = fWidth;
			this._fRelHeight = fHeight;

			this._iZIndex = iZIndex;

			this._csDefaultRenderMethod = csRenderMethod;

			this._updateDimensions();

			this._setCamera(pCamera);
		}

		destroy(): void {
			var pRenderer: IRenderer = this._pTarget.getRenderer();
			if (pRenderer && pRenderer._getViewport() === this) {
				pRenderer._setViewport(null);
			}
		}


		clear(iBuffers:  number  = 1, cColor: IColor = Color.BLACK, iDepth:  number  = 1.): void {

			var pRenderer: IRenderer = this._pTarget.getRenderer();

			if (pRenderer) {
				var pCurrentViewport: IViewport = pRenderer._getViewport();

				if (pCurrentViewport && pCurrentViewport == this) {
					pRenderer.clearFrameBuffer(iBuffers, cColor, iDepth);
				}
				else if (pCurrentViewport) {
					pRenderer._setViewport(this);
					pRenderer.clearFrameBuffer(iBuffers, cColor, iDepth);
					pRenderer._setViewport(pCurrentViewport);
				}
			}
		}

        /**@inline*/  getTarget(): IRenderTarget {
        	return this._pTarget;
        }

        /**@inline*/  getCamera(): ICamera {
        	return this._pCamera;
        }

        setCamera(pCamera: ICamera): bool {
        	if(this._pCamera) {
				if(this._pCamera._getLastViewport() == this) {
					this._pCamera._keepLastViewport(null);
				}
			}

			if (this._pCamera) {
// update aspect ratio of new camera if needed.
				if (!pCamera.isConstantAspect()) {
					pCamera.aspect = (< number > this._iActWidth / < number > this._iActHeight);
				}
			}

			this._setCamera(pCamera);
			this.viewportCameraChanged();

			return true;
        }

        /**@protected*/  _setCamera(pCamera: ICamera): void {
			this._pCamera = pCamera;

			if (pCamera) {
				pCamera._keepLastViewport(this);
			}
        }

        setDimensions(fLeft:  number , fTop:  number , fWidth:  number , fHeight:  number ): bool;
        setDimensions(pRect: IRect2d): bool;
        setDimensions(fLeft?, fTop?, fWidth?, fHeight?): bool {
        	var pRect: IRect2d;
        	if (isNumber(arguments[0])) {
        		this._fRelLeft = < number >fLeft;
        		this._fRelTop = < number >fTop;
        		this._fRelWidth = < number >fWidth;
        		this._fRelHeight = < number >fHeight;
        	}
        	else {
        		pRect = <IRect2d>arguments[0];
        		this._fRelLeft = pRect.left;
        		this._fRelTop = pRect.top;
        		this._fRelWidth = pRect.width;
        		this._fRelHeight = pRect.height;
        	}

         	this._updateDimensions();

         	return true;
        }

        getActualDimensions(): IRect2d {
        	return new geometry.Rect2d(< number >this._iActLeft, < number >this._iActTop, < number >this._iActWidth, < number >this._iActHeight);
        }

//iBuffers=FBT_COLOUR|FBT_DEPTH
        setClearEveryFrame(isClear: bool, iBuffers?:  number ): void {
        	this._bClearEveryFrame = isClear;
			this._iClearBuffers = iBuffers;
        }

        /**@inline*/  getClearEveryFrame(): bool {
        	return this._bClearEveryFrame;
        }

        /**@inline*/  getClearBuffers():  number  {
        	return this._iClearBuffers;
        }

        /**@inline*/  setAutoUpdated(bValue: bool = true): void { this._isAutoUpdated = bValue; }
        /**@inline*/  isAutoUpdated(): bool { return this._isAutoUpdated; }

		_updateDimensions(): void {
			var fHeight:  number   = < number >this._pTarget.height;
			var fWidth:  number   = < number >this._pTarget.width;

			this._iActLeft = < number >(this._fRelLeft * fWidth);
			this._iActTop = < number >(this._fRelTop * fHeight);
			this._iActWidth = < number >(this._fRelWidth * fWidth);
			this._iActHeight = < number >(this._fRelHeight * fHeight);

// This will check if the cameras getAutoAspectRatio() property is set.
// If it's true its aspect ratio is fit to the current viewport
// If it's false the camera remains unchanged.
// This allows cameras to be used to render to many viewports,
// which can have their own dimensions and aspect ratios.

	        if (this._pCamera)  {
	            if (!this._pCamera.isConstantAspect())
	                this._pCamera.aspect = (< number > this._iActWidth / < number > this._iActHeight);

			}

	 		this._bUpdated = true;

			this.viewportDimensionsChanged();
		}

		update(): void {
			if (this._pCamera) {
				this.renderAsNormal(this._csDefaultRenderMethod, this._pCamera);
			}
		}

		/**@protected*/  renderAsNormal(csMethod: string, pCamera: ICamera): void {
				var pVisibleObjects: IObjectArray = pCamera.display();
				var pRenderable: IRenderableObject;

				for (var i:  number  = 0; i < pVisibleObjects.length; ++ i) {
					pRenderable = pVisibleObjects.value(i).getRenderable();

					if (!isNull(pRenderable)) {
						pRenderable.render(csMethod);
					}
				}
		}


        /**@inline*/  isUpdated(): bool {
        	return this._bUpdated;
        }

        /**@inline*/  _clearUpdatedFlag(): void {
        	this._bUpdated = false;
        }

        _getNumRenderedPolygons():  number  {
        	return this._pCamera? this._pCamera._getNumRenderedFaces(): 0;
        }

        private _iGuid: number = eval("this._iGuid || akra.sid()"); private _pUnicastSlotMap: IEventSlotMap = null; private _pBroadcastSlotList: IEventSlotListMap = null; private static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable {return Viewport._pEventTable; } getGuid(): number {return this._iGuid < 0? (this._iGuid = sid()): this._iGuid; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
        	viewportDimensionsChanged (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).viewportDimensionsChanged; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
        	viewportCameraChanged (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).viewportCameraChanged; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
        ;
	}
}










module akra {
	export interface IDSViewport extends IViewport {
		setSkybox(pSkyTexture: ITexture): void;
		setFXAA(bValue?: bool): void;
	}
}




















module akra.render {
	export interface IUniform {

	}

	export  class  LightData {
		DIFFUSE: IVec4 = new Vec4();
		AMBIENT: IVec4 = new Vec4();
		SPECULAR: IVec4 = new Vec4();
		POSITION: IVec3 = new Vec3();
		ATTENUATION: IVec3 = new Vec3();

		set(pLightParam: ILightParameters, v3fPosition: IVec3): LightData {

		    this.DIFFUSE.set(pLightParam.diffuse);
		    this.AMBIENT.set(pLightParam.ambient);
		    this.SPECULAR.set(pLightParam.specular);
		    this.ATTENUATION.set(pLightParam.attenuation);
		    this.POSITION.set(v3fPosition);

		    return this;
		}
	};

	export  class  UniformOmni implements IUniform {
		LIGHT_DATA: LightData = new LightData();

		setLightData(pLightParam: ILightParameters, v3fPosition: IVec3): UniformOmni {
			this.LIGHT_DATA.set(pLightParam, v3fPosition);

			return this;
		}

		static get stackCeil(): UniformOmni { UniformOmni.stackPosition = UniformOmni.stackPosition === UniformOmni.stackSize - 1? 0: UniformOmni.stackPosition; return UniformOmni.stack[UniformOmni.stackPosition ++]; } static stackSize: number = 200; static stackPosition: number = 0; static stack: UniformOmni[] = (function(): UniformOmni[]{ var pStack: UniformOmni[] = new Array(UniformOmni.stackSize); for(var i: number = 0; i<UniformOmni.stackSize; i++){ pStack[i] = new UniformOmni(); } return pStack})(); ;
	};

	export  class  UniformProject implements IUniform {
		LIGHT_DATA: LightData = new LightData();
    	SHADOW_MATRIX: IMat4 = new Mat4();

    	setLightData(pLightParam: ILightParameters, v3fPosition: IVec3): UniformProject {
			this.LIGHT_DATA.set(pLightParam, v3fPosition);

			return this;
		}

		setMatrix(m4fMatrix: IMat4): UniformProject {
			this.SHADOW_MATRIX.set(m4fMatrix);

			return this;
		}

    	static get stackCeil(): UniformProject { UniformProject.stackPosition = UniformProject.stackPosition === UniformProject.stackSize - 1? 0: UniformProject.stackPosition; return UniformProject.stack[UniformProject.stackPosition ++]; } static stackSize: number = 200; static stackPosition: number = 0; static stack: UniformProject[] = (function(): UniformProject[]{ var pStack: UniformProject[] = new Array(UniformProject.stackSize); for(var i: number = 0; i<UniformProject.stackSize; i++){ pStack[i] = new UniformProject(); } return pStack})(); ;
	};


	export  class  UniformProjectShadow implements IUniform {
		LIGHT_DATA: LightData = new LightData();
	    TO_LIGHT_SPACE: IMat4 = new Mat4();
	    REAL_PROJECTION_MATRIX: IMat4 = new Mat4();
	    OPTIMIZED_PROJECTION_MATRIX: IMat4 = new Mat4();
	    SHADOW_SAMPLER:  ISampler2d  = {TEXTURE: null};

	    setLightData(pLightParam: ILightParameters, v3fPosition: IVec3): UniformProjectShadow {
	    	this.LIGHT_DATA.set(pLightParam, v3fPosition);
	    	return this;
	    }

	    setMatrix(m4fToLightSpace: IMat4, m4fRealProj: IMat4, m4fOptimizedProj: IMat4): UniformProjectShadow {
	    	this.TO_LIGHT_SPACE.set(m4fToLightSpace);
		    this.REAL_PROJECTION_MATRIX.set(m4fRealProj);
		    this.OPTIMIZED_PROJECTION_MATRIX.set(m4fOptimizedProj);

	    	return this;
	    }

	    setSampler(sTexture: string): UniformProjectShadow {
	    	this.SHADOW_SAMPLER.TEXTURE = sTexture;
	    	return this;
	    }

	    static get stackCeil(): UniformProjectShadow { UniformProjectShadow.stackPosition = UniformProjectShadow.stackPosition === UniformProjectShadow.stackSize - 1? 0: UniformProjectShadow.stackPosition; return UniformProjectShadow.stack[UniformProjectShadow.stackPosition ++]; } static stackSize: number = 20; static stackPosition: number = 0; static stack: UniformProjectShadow[] = (function(): UniformProjectShadow[]{ var pStack: UniformProjectShadow[] = new Array(UniformProjectShadow.stackSize); for(var i: number = 0; i<UniformProjectShadow.stackSize; i++){ pStack[i] = new UniformProjectShadow(); } return pStack})(); ;
	}

	export  class  UniformOmniShadow implements IUniform {
		LIGHT_DATA: LightData = new LightData;
		TO_LIGHT_SPACE: IMat4[] =
		[
			new Mat4, new Mat4, new Mat4,
			new Mat4, new Mat4, new Mat4
		];

		OPTIMIZED_PROJECTION_MATRIX: IMat4[] =
		[
			new Mat4, new Mat4, new Mat4,
			new Mat4, new Mat4, new Mat4
		];

		SHADOW_SAMPLER:  ISampler2d [] =
		[
			{"TEXTURE" : null}, {"TEXTURE" : null}, {"TEXTURE" : null},
	        {"TEXTURE" : null}, {"TEXTURE" : null}, {"TEXTURE" : null}
	    ];

	    setLightData(pLightParam: ILightParameters, v3fPosition: IVec3): UniformOmniShadow {
		    this.LIGHT_DATA.set(pLightParam, v3fPosition);
		    return this;
		};

		setMatrix(m4fToLightSpace: IMat4, m4fOptimizedProj: IMat4, index:  number ): UniformOmniShadow {
		    this.TO_LIGHT_SPACE[index].set(m4fToLightSpace);
		    this.OPTIMIZED_PROJECTION_MATRIX[index].set(m4fOptimizedProj);
		    return this;
		};

		setSampler(sTexture: string, index:  number ): UniformOmniShadow {
		    this.SHADOW_SAMPLER[index].TEXTURE = sTexture;
		    return this;
		};

	    static get stackCeil(): UniformOmniShadow { UniformOmniShadow.stackPosition = UniformOmniShadow.stackPosition === UniformOmniShadow.stackSize - 1? 0: UniformOmniShadow.stackPosition; return UniformOmniShadow.stack[UniformOmniShadow.stackPosition ++]; } static stackSize: number = 3; static stackPosition: number = 0; static stack: UniformOmniShadow[] = (function(): UniformOmniShadow[]{ var pStack: UniformOmniShadow[] = new Array(UniformOmniShadow.stackSize); for(var i: number = 0; i<UniformOmniShadow.stackSize; i++){ pStack[i] = new UniformOmniShadow(); } return pStack})(); ;
	}

	export interface UniformMap {
		omni: UniformOmni[];
        project: UniformProject[];
        omniShadows: UniformOmniShadow[];
        projectShadows: UniformProjectShadow[];
        textures: ITexture[];
        samplersOmni:  ISampler2d [];
        samplersProject:  ISampler2d [];
	}
}








module akra {
	export interface IAFXPassBlend {} ;
	export interface IRenderTarget {} ;

	export interface IRenderPass {
		data: IAFXPassBlend;

		getRenderTarget(): IRenderTarget;
	}
}













module akra {
	export interface IOmniLight extends ILightPoint {
		optimizedProjectionCube: IMat4[];
		currentOptimizedProjection: IMat4;

		getShadowCaster(): IShadowCasterCube;
		getDepthTexture(iFace:  number ): ITexture;
		getRenderTarget(iFace:  number ): IRenderTarget;

		getDepthTextureCube(): ITexture[];
	}
}











module akra {
	export interface IProjectLight extends ILightPoint {
		optimizedProjection: IMat4;
		currentOptimizedProjection: IMat4;

		getShadowCaster(): IShadowCaster;
		getDepthTexture(): ITexture;
		getRenderTarget(): IRenderTarget;
	}
}




















module akra.render {
	export class RenderTechnique implements IRenderTechnique {
		private _pMethod: IRenderMethod;

		get modified():  number  {
			return 0;
		}

		get totalPasses():  number  {
			return 0;
		}

		constructor (pMethod: IRenderMethod = null) {
			this._pMethod = pMethod;
		}


		destroy(): void {

		}

		getPass(n:  number ): IRenderPass {
			return null;
		}

		getMethod(): IRenderMethod {
			return null;
		}

		setMethod(pMethod: IRenderMethod): void {

		}

		setState(sName: string, pValue: any): void {

		}

		setForeign(sName: string, pValue: any): void {

		}

		setStruct(sName: string, pValue: any): void {

		}

		setTextureBySemantics(sName: string, pValue: any): void {

		}

		setShadowSamplerArray(sName: string, pValue: any): void {

		}

		setVec2BySemantic(sName: string, pValue: any): void {

		}

		isReady(): bool {
			return false;
		}

		private _iGuid: number = eval("this._iGuid || akra.sid()"); private _pUnicastSlotMap: IEventSlotMap = null; private _pBroadcastSlotList: IEventSlotListMap = null; private static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable {return RenderTechnique._pEventTable; } getGuid(): number {return this._iGuid < 0? (this._iGuid = sid()): this._iGuid; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
			render (): void { var _recivier: any = this; this._pUnicastSlotMap = this._pUnicastSlotMap || this.getEventTable().findUnicastList(this._iGuid); var _unicast: IEventSlot = (<any>this._pUnicastSlotMap).render; if(isDef(_unicast)){ _unicast.target? _unicast.target[_unicast.callback] (_recivier) : _unicast.listener (_recivier) ; } } ; ;
		;
	}
}








module akra.render {

	export interface IRenderTechniqueMap {
		[key: string]: IRenderTechnique;
	}

	export class RenderableObject implements IRenderableObject {
		/**@protected*/  _pRenderer: IRenderer;
		/**@protected*/  _pTechnique: IRenderTechnique = null;
		/**@protected*/  _pTechniqueMap: IRenderTechniqueMap = {};
		/**@protected*/  _bShadow: bool = false;

		/**@inline*/  get renderMethod(): IRenderMethod {
			return this._pTechnique.getMethod();
		}

		/**@inline*/  set renderMethod(pMethod: IRenderMethod) {
			this.switchRenderMethod(pMethod);
		}

		/**@inline*/  get effect(): IEffect { return this._pTechnique.getMethod().effect; }
		/**@inline*/  get surfaceMaterial(): ISurfaceMaterial  { return this._pTechnique.getMethod().surfaceMaterial; }

		/**@inline*/  get material(): IMaterial  { return this.surfaceMaterial.material; }

		constructor () {

		}

		_setup(pRenderer: IRenderer, csDefaultMethod: string = null): void {
			this._pRenderer = pRenderer;

			if (this.addRenderMethod(csDefaultMethod) || this.switchRenderMethod(null) === false) {
				logger.setSourceLocation( "RenderableObject.ts" , 44 ); logger.criticalError("cannot add & switch render method to default"); ;
			}
		}

		/**@inline*/  getRenderer(): IRenderer {
			return this._pRenderer;
		}

		destroy(): void {
			this._pRenderer = null;
			this._pTechnique = null;

			for (var i in this._pTechniqueMap) {
				this._pTechniqueMap[i].destroy();
			}

			this._pTechniqueMap = null;
		}

		addRenderMethod(pMethod: IRenderMethod, csName: string =  "default" ): bool;
		addRenderMethod(csMethod: string, csName: string =  "default" ): bool;
		addRenderMethod(csMethod: any, csName: string =  "default" ): bool {
			var pTechnique: IRenderTechnique = new RenderTechnique;
			var pRmgr: IResourcePoolManager = this.getRenderer().getEngine().getResourceManager();
			var pMethod: IRenderMethod = null;

			if (isNull(csMethod)) {
				return false;
			}

		    if (isString(arguments[0])) {
		        pMethod = pRmgr.createRenderMethod((csMethod) + this.getGuid());

		        if (!isDefAndNotNull(pMethod)) {
		        	return false;
		        }

//adding empty, but NOT NULL effect & material
		        pMethod.surfaceMaterial = pRmgr.createSurfaceMaterial(csMethod + ".material." + this.getGuid());
		        pMethod.effect = pRmgr.createEffect(csMethod + ".effect." + this.getGuid());
		    }
		    else {
		    	pMethod = <IRenderMethod>arguments[0];
		    }


		    logger.setSourceLocation( "RenderableObject.ts" , 91 ); logger.assert(pMethod.getManager().getEngine().getRenderer() === this._pRenderer, "Render method should belong to the same engine instance that the renderable object.");
                                                                                                         ;

		    pTechnique.setMethod(pMethod);
//pTechnique.name = csName || DEFAULT_RT;

		    this._pTechniqueMap[csName ||  "default" ] = pTechnique;

		    return true;
		}

		switchRenderMethod(pMethod: IRenderMethod): bool;
		switchRenderMethod(csName: string): bool;
		switchRenderMethod(csName: any): bool {
			var pTechnique: IRenderTechnique;
			var sName: string;

			if (isString(arguments[0])) {
				sName = <string>csName;
			}
			else if (isDefAndNotNull(arguments[0])) {
				sName = (<IRenderMethod>arguments[0]).findResourceName();

				if (!isDefAndNotNull(this._pTechniqueMap[sName])) {
					if (!this.addRenderMethod(<IRenderMethod>arguments[0], sName)) {
						return false;
					}
				}
			}

			pTechnique = this._pTechniqueMap[sName];

			if (isDefAndNotNull(pTechnique)) {
				this._pTechnique = pTechnique;
				return true;
			}

			return false;
		}

		removeRenderMethod(csName: string): bool {
			var pTechnique: IRenderTechnique = this._pTechniqueMap[csName];

			if (isDefAndNotNull(pTechnique)) {
				delete this._pTechniqueMap[csName ||  "default" ];
				return true
			}

		    return false;
		}



		/**@inline*/  getRenderMethod(csName: string = null): IRenderMethod {
			var pTechnique: IRenderTechnique = this._pTechniqueMap[csName ||  "default" ];
			return pTechnique? pTechnique.getMethod(): null;
		}

		/**@inline*/  hasShadow(): bool {
			return this._bShadow;
		}

		setShadow(bValue: bool = true): void {
			if (this._bShadow != bValue) {
				this._bShadow = bValue;
				this.shadow(bValue);
			}
		}

		/**@inline*/  isReadyForRender(): bool {
			return this._pTechnique.isReady();
		}

		isAllMethodsLoaded(): bool {
			for (var i in this._pTechniqueMap) {
				var pMethod: IRenderMethod = this._pTechniqueMap[i].getMethod();

				if (!isDefAndNotNull(pMethod) || !pMethod.isResourceLoaded()) {
					return false;
				}
			}

			return true;
		}


		render(csMethod: string = null): void {
//TODO("DRAW!!!!");
			logger.setSourceLocation( "RenderableObject.ts" , 178 ); logger.error("TODO(DRAW!!)"); ;
		}

		getTechnique(sName: string = null): IRenderTechnique {
			return this._pTechniqueMap[sName] || null;
		}

		_draw(): void {
			logger.setSourceLocation( "RenderableObject.ts" , 186 ); logger.error("RenderableObject::_draw() pure virtual method() isn't callable!!"); ;
		}

		private _iGuid: number = eval("this._iGuid || akra.sid()"); private _pUnicastSlotMap: IEventSlotMap = null; private _pBroadcastSlotList: IEventSlotListMap = null; private static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable {return RenderableObject._pEventTable; } getGuid(): number {return this._iGuid < 0? (this._iGuid = sid()): this._iGuid; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
			shadow (bValue): void { var _recivier: any = this; this._pUnicastSlotMap = this._pUnicastSlotMap || this.getEventTable().findUnicastList(this._iGuid); var _unicast: IEventSlot = (<any>this._pUnicastSlotMap).shadow; if(isDef(_unicast)){ _unicast.target? _unicast.target[_unicast.callback] (_recivier, bValue) : _unicast.listener (_recivier, bValue) ; } } ; ;
		;
	}
}










module akra {
	export interface ICanvasInfo {
		width:  number ;
		height:  number ;
		id: string;
	}
}






module akra {
	export interface IURI {
		scheme: string;
		userinfo: string;
		host: string;
		port:  number ;
		path: string;
		query: string;
		fragment: string;
		urn: string;
		url: string;
		authority: string;
		protocol: string;

		toString(): string;
	}
}










module akra {
	export interface IBrowserInfo {
		name: string;
		version: string;
		os: string;
	}
}






module akra.util {
	export class Singleton {
		constructor () {
			var _constructor = (<any>this).constructor;

			logger.setSourceLocation( "Singleton.ts" , 10 ); logger.assert(!isDef(_constructor._pInstance), 'Singleton class may be created only one time.');
                                                    ;

			_constructor._pInstance = this;
		}
	}
}




module akra.util {
	export interface IBrowserData {
		string: string;
		subString: string;
		identity: string;
		versionSearch?: string;
		prop?: string;
	}

	export class BrowserInfo extends Singleton implements IBrowserInfo {
		private sBrowser: string = null;
		private sVersion: string = null;
		private sOS: string = null;
		private sVersionSearch: string = null;

		get name(): string {
			return this.sBrowser;
		}

		get version(): string {
			return this.sVersion;
		}

		get os(): string {
			return this.sOS;
		}

		private init(): void {
			this.sBrowser = this.searchString(BrowserInfo.dataBrowser) || "An unknown browser";
			this.sVersion = this.searchVersion(navigator.userAgent)
								|| this.searchVersion(navigator.appVersion)
				|| "an unknown version";
			this.sOS = this.searchString(BrowserInfo.dataOS) || "an unknown OS";
		}

		private searchString(pDataBrowser: IBrowserData[]): string {
			for (var i: number  = 0; i < pDataBrowser.length; i++) {
				var sData:string = pDataBrowser[i].string;
				var dataProp:string = pDataBrowser[i].prop;

				this.sVersionSearch = pDataBrowser[i].versionSearch || pDataBrowser[i].identity;

				if (sData) {
					if (sData.indexOf(pDataBrowser[i].subString) != -1) {
						return pDataBrowser[i].identity;
					}
				}
				else if (dataProp) {
					return pDataBrowser[i].identity;
				}
			}
			return null;
		}

		private searchVersion(sData: string): string {
			var iStartIndex: number  = sData.indexOf(this.sVersionSearch);

			if (iStartIndex == -1) {
				return null;
			}

			iStartIndex = sData.indexOf('/', iStartIndex + 1);

			if (iStartIndex == -1) {
				return null;
			}

			var iEndIndex: number  = sData.indexOf(' ', iStartIndex + 1);

			if (iEndIndex == -1) {
				iEndIndex = sData.indexOf(';', iStartIndex + 1);
				if (iEndIndex == -1) {
					return null;
				}
				return sData.slice(iStartIndex + 1);
			}

			return sData.slice((iStartIndex + 1), iEndIndex);
		}

		static private dataBrowser: IBrowserData[] = [
			{
				string: navigator.userAgent,
				subString: "Chrome",
				identity: "Chrome"
			},
			{
				string: navigator.userAgent,
				subString: "OmniWeb",
				versionSearch: "OmniWeb/",
				identity: "OmniWeb"
			},
			{
				string: navigator.vendor,
				subString: "Apple",
				identity: "Safari",
				versionSearch: "Version"
			},
			{
				prop: window.opera,
				identity: "Opera",
				versionSearch: "Version"
			},
			{
				string: navigator.vendor,
				subString: "iCab",
				identity: "iCab"
			},
			{
				string: navigator.vendor,
				subString: "KDE",
				identity: "Konqueror"
			},
			{
				string: navigator.userAgent,
				subString: "Firefox",
				identity: "Firefox"
			},
			{
				string: navigator.vendor,
				subString: "Camino",
				identity: "Camino"
			},
			{
// for newer Netscapes (6+)
				string: navigator.userAgent,
				subString: "Netscape",
				identity: "Netscape"
			},
			{
				string: navigator.userAgent,
				subString: "MSIE",
				identity: "Explorer",
				versionSearch: "MSIE"
			},
			{
				string: navigator.userAgent,
				subString: "Gecko",
				identity: "Mozilla",
				versionSearch: "rv"
			},
			{
// for older Netscapes (4-)
				string: navigator.userAgent,
				subString: "Mozilla",
				identity: "Netscape",
				versionSearch: "Mozilla"
			}
		];

		static private dataOS: IBrowserData[] = [
			{
				string    : navigator.platform,
				subString : "Win",
				identity  : "Windows"
			},
			{
				string    : navigator.platform,
				subString : "Mac",
				identity  : "Mac"
			},
			{
				string    : navigator.userAgent,
				subString : "iPhone",
				identity  : "iPhone/iPod"
			},
			{
				string    : navigator.platform,
				subString : "Linux",
				identity  : "Linux"
			}
		];
	}
}











module akra {
	export interface IScreenInfo {
		width:  number ;
		height:  number ;
		aspect:  number ;
		pixelDepth:  number ;
		colorDepth:  number ;
	}
}



module akra.util {
	export class ScreenInfo implements IScreenInfo {
		get width():  number  {
			return screen.width;
		}

		get height():  number  {
			return screen.height;
		}

		get aspect():  number  {
			return screen.width / screen.height;
		}

		get pixelDepth():  number  {
			return screen.pixelDepth;
		}

		get colorDepth():  number  {
			return screen.colorDepth;
		}
	}
}










module akra {
	export interface IApiInfo {
		webGL: bool;
		webAudio: bool;
		file: bool;
		fileSystem: bool;
		webWorker: bool;
		transferableObjects: bool;
		localStorage: bool;
		webSocket: bool;
	}
}







module akra.util {
	export class ApiInfo extends Singleton implements IApiInfo {
		private bWebGL: bool = false;
		private bWebAudio: bool = false;
		private bFile: bool = false;
		private bFileSystem: bool = false;
		private bWebWorker: bool = false;
		private bTransferableObjects: bool = false;
		private bLocalStorage: bool = false;
		private bWebSocket: bool = false;

		get webGL(): bool {
			if (!this.bWebGL) {
				this.bWebGL = ((<any>window).WebGLRenderingContext || this.checkWebGL() ? true : false);
			}

			return this.bWebGL;
		}

		get transferableObjects(): bool {
			if (!this.bTransferableObjects) {
				this.bTransferableObjects = (this.bWebWorker && this.chechTransferableObjects() ? true : false);
			}

			return this.bTransferableObjects;
		}

		get file(): bool {
			return this.bFile;
		}

		get fileSystem(): bool {
			return this.bFileSystem;
		}

		get webAudio(): bool {
			return this.bWebAudio;
		}

		get webWorker(): bool {
			return this.bWebWorker;
		}

		get localStorage(): bool {
			return this.bLocalStorage;
		}

		get webSocket(): bool {
			return this.bWebSocket;
		}

		constructor () {
			super();

			var pApi = {};

			this.bWebAudio = ((<any>window).AudioContext && (<any>window).webkitAudioContext ? true : false);
			this.bFile = ((<any>window).File && (<any>window).FileReader && (<any>window).FileList && (<any>window).Blob ? true : false);
			this.bFileSystem = (this.bFile && (<any>window).URL && (<any>window).requestFileSystem ? true : false);
			this.bWebWorker = isDef((<any>window).Worker);
			this.bLocalStorage = isDef((<any>window).localStorage);
			this.bWebSocket = isDef((<any>window).WebSocket);
		}

		private checkWebGL(): bool {
			var pCanvas: HTMLCanvasElement;
			var pDevice: WebGLRenderingContext;

			try {
				pCanvas = <HTMLCanvasElement> document.createElement('canvas');
				pDevice = pCanvas.getContext('webgl', {}) ||
                       		pCanvas.getContext('experimental-webgl', {});

                if (pDevice) {
                	return true;
                }
			}
			catch (e) {}

			return false;
		}

		private chechTransferableObjects(): bool {
			var pBlob: Blob = new Blob(["onmessage = function(e) { postMessage(true); }"]);
			var sBlobURL: string = (<any>window).URL.createObjectURL(pBlob);
			var pWorker: Worker = new Worker(sBlobURL);

			var pBuffer: ArrayBuffer = new ArrayBuffer(1);

		    try {
		        pWorker.postMessage(pBuffer, [pBuffer]);
		    }
		    catch (e) {
		        logger.setSourceLocation( "util/ApiInfo.ts" , 101 ); logger.log('transferable objects not supported in your browser...'); ;
		    }

		    pWorker.terminate();

		    if (pBuffer.byteLength) {
		        return false
		    }

		    return true;
		}
	}
}














module akra {
	export interface IPathinfo {
		path: string;
		dirname: string;
		filename: string;
		ext: string;
		basename: string;


		set(sPath: string): void;
		set(pPath: IPathinfo): void;
		isAbsolute(): bool;

		toString(): string;
	}

}



module akra.util {
	export class Pathinfo implements IPathinfo {
		private _sDirname: string = null;
		private _sExtension: string = null;
		private _sFilename: string = null;

		/**@inline*/  get path(): string { return this.toString(); }
		/**@inline*/  set path(sPath: string) { this.set(sPath); }

		/**@inline*/  get dirname(): string { return this._sDirname; }
		/**@inline*/  set dirname(sDirname: string) { this._sDirname = sDirname; }

		/**@inline*/  get filename(): string { return this._sFilename; }
		/**@inline*/  set filename(sFilename: string) { this._sFilename = sFilename; }

		/**@inline*/  get ext(): string { return this._sExtension; }
		/**@inline*/  set ext(sExtension: string) { this._sExtension = sExtension; }

		/**@inline*/  get basename(): string {
			return (this._sFilename ? this._sFilename + (this._sExtension ? "." + this._sExtension : "") : "");
		}

		/**@inline*/  set basename(sBasename: string) {
			var nPos:  number  = sBasename.lastIndexOf(".");

	        if (nPos < 0) {
	            this._sFilename = sBasename.substr(0);
	            this._sExtension = null;
	        }
	        else {
	            this._sFilename = sBasename.substr(0, nPos);
	            this._sExtension = sBasename.substr(nPos + 1);
	        }
		}


		constructor (pPath: IPathinfo);
		constructor (sPath: string);
		constructor (pPath?: any) {
			if (isDef(pPath)) {
				this.set(<string>pPath);
			}
		}


		set(sPath: string): void;
		set(pPath: IPathinfo): void;
		set(sPath?: any) {
			if (isString(sPath)) {
		        var pParts: string[] = sPath.replace('\\', '/').split('/');

		        this.basename = pParts.pop();

		        this._sDirname = pParts.join('/');
		    }
		    else if (sPath instanceof Pathinfo) {
		        this._sDirname = sPath.dirname;
		        this._sFilename = sPath.filename;
		        this._sExtension = sPath.ext;
		    }
		    else {
//critical_error
		        logger.setSourceLocation( "Pathinfo.ts" , 68 ); logger.error("Unexpected data type was used."); ;
		    }
		}

		isAbsolute(): bool { return this._sDirname[0] === "/"; }


		toString(): string {
			return (this._sDirname ? this._sDirname + "/" : "") + (this.basename);
		}

	}

}

module akra {
	export var Pathinfo = util.Pathinfo;
}









module akra.util {
	export class URI implements IURI {
		private sScheme: string = null;
		private sUserinfo: string = null;
		private sHost: string = null;
		private nPort:  number  = 0;
		private sPath: string = null;
		private sQuery: string = null;
		private sFragment: string = null;

		get urn(): string {
			return (this.sPath ? this.sPath : "") +
			(this.sQuery ? '?' + this.sQuery : "") +
			(this.sFragment ? '#' + this.sFragment : "");
		}

		get url(): string {
			return (this.sScheme ? this.sScheme : "") + this.authority;
		}

		get authority(): string {
			return (this.sHost ? '//' + (this.sUserinfo ? this.sUserinfo + '@' : "") +
				this.sHost + (this.nPort ? ':' + this.nPort : "") : "");
		}

		/**@inline*/  get scheme(): string {
			return this.sScheme;
		}

		get protocol(): string {
			if (!this.sScheme) {
				return this.sScheme;
			}

			return (this.sScheme.substr(0, this.sScheme.lastIndexOf(':')));
		}

		/**@inline*/  get userinfo(): string {
			return this.sUserinfo;
		}

		/**@inline*/  get host(): string {
			return this.sHost;
		}

		/**@inline*/  get port():  number  {
			return this.nPort;
		}

		/**@inline*/  set port(iPort:  number ) {
			this.nPort = iPort;
		}

		/**@inline*/  get path(): string {
			return this.sPath;
		}

		/**@inline*/  get query(): string {
			return this.sQuery;
		}

		/**@inline*/  get fragment(): string {
			return this.sFragment;
		}


		constructor (pUri: URI);
		constructor (sUri: string);
		constructor (pUri?) {
			if (pUri) {
				this.set(pUri);
			}
		}

		set(pUri: URI);
		set(sUri: string);
		set(pData?): URI {
			if (isString(pData)) {
				var pUri:RegExpExecArray = URI.uriExp.exec(<string>pData);

				logger.setSourceLocation( "URI.ts" , 86 ); logger.assert(pUri !== null, 'Invalid URI format used.\nused uri: ' + pData); ;

				if (!pUri) {
					return null;
				}

				this.sScheme = pUri[1] || null;
				this.sUserinfo = pUri[2] || null;
				this.sHost = pUri[3] || null;
				this.nPort = parseInt(pUri[4]) || null;
				this.sPath = pUri[5] || pUri[6] || null;
				this.sQuery = pUri[7] || null;
				this.sFragment = pUri[8] || null;

				return this;

			}
			else if (pData instanceof URI) {
				return this.set(pData.toString());
			}

			logger.setSourceLocation( "URI.ts" , 107 ); logger.error('Unexpected data type was used.'); ;

			return null;
		}

		toString(): string {
			return this.url + this.urn;
		}

//------------------------------------------------------------------//
//----- Validate a URI -----//
//------------------------------------------------------------------//
//- The different parts are kept in their own groups and can be recombined
//  depending on the scheme:
//  - http as $1://$3:$4$5?$7#$8
//  - ftp as $1://$2@$3:$4$5
//  - mailto as $1:$6?$7
//- groups are as follows:
//  1   == scheme
//  2   == userinfo
//  3   == host
//  4   == port
//  5,6 == path (5 if it has an authority, 6 if it doesn't)
//  7   == query
//  8   == fragment


		static private uriExp:RegExp = new RegExp("^([a-z0-9+.-]+:)?(?:\\/\\/(?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(?::(\\d*))?(\\/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?|(\\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})*(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?)(?:\\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?(?:#((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?$", "i");

/*
		 composed as follows:
		 ^
		 ([a-z0-9+.-]+):							#scheme
		 (?:
		 //							#it has an authority:
		 (?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?	#userinfo
		 ((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)		#host
		 (?::(\d*))?						#port
		 (/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?	#path
		 |
		 #it doesn't have an authority:
		 (/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})+(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?	#path
		 )
		 (?:
		 \?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)	#query string
		 )?
		 (?:
		 #((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)	#fragment
		 )?
		 $
		 */

	}
}



// #include "ReferenceCounter.ts"
// #include "Singleton.ts"

// #include "BrowserInfo.ts"
// #include "ApiInfo.ts"
// #include "ScreenInfo.ts"
// #include "DeviceInfo.ts"

// #include "UtilTimer.ts"

// #include "Entity.ts"

// #include "ThreadManager.ts"

module akra.util {

	export var uri = (sUri:string): IURI => new util.URI(sUri);

// export var pathinfo: (sPath: string) => IPathinfo;
// export var pathinfo: (pPath: IPathinfo) => IPathinfo;
	export var pathinfo: (pPath?) => IPathinfo;

	pathinfo = function (pPath?): IPathinfo {
		return new Pathinfo(pPath);
	}

//string to array buffer
	export var stoab = function (s: string): ArrayBuffer {
		var pCodeList:  number [] = new Array(len);

	    for (var i:  number  = 0, len = s.length; i < len; ++i) {
/*& 0xFF;*/
	        pCodeList[ i ] = s.charCodeAt(i);
	    }

	    return (new Uint8Array(pCodeList)).buffer;
	}

	export var abtos = function (pBuf: ArrayBuffer): string {
		var pData: Uint8Array = new Uint8Array(pBuf);
	    var s: string = "";

	    for (var n:  number  = 0; n < pData.length; ++ n) {
	        s += String.fromCharCode(pData[n]);
	    }

	    return s;
	}


	export function abtota(pBuffer: ArrayBuffer, eType: EDataTypes): ArrayBufferView {
        switch (eType) {
            case EDataTypes.FLOAT:
                return new Float32Array(pBuffer);
            case EDataTypes.SHORT:
                return new Int16Array(pBuffer);
            case EDataTypes.UNSIGNED_SHORT:
                return new Uint16Array(pBuffer);
            case EDataTypes.INT:
                return new Int32Array(pBuffer);
            case EDataTypes.UNSIGNED_INT:
                return new Uint32Array(pBuffer);
            case EDataTypes.BYTE:
                return new Int8Array(pBuffer);
            default:
            case EDataTypes.UNSIGNED_BYTE:
                return new Uint8Array(pBuffer);
        }
    }


	export function parseJSON(sJSON: string): Object {
		return eval('(' + sJSON + ')');
	};

/**
	 * Преобразование html-сформированного текста
	 * в dom.
	 */

	export function parseHTML(sHTML: string, useDocFragment: bool = true): any {
	    var pDivEl: HTMLDivElement = <HTMLDivElement>document.createElement('div');
	    var pDocFrag: DocumentFragment;

	    pDivEl.innerHTML = sHTML;

	    if (!useDocFragment) {
	        return pDivEl.childNodes;
	    }

	    pDocFrag = document.createDocumentFragment();

	    for (var i = 0, len:  number  = pDivEl.childNodes.length; i < len; ++ i) {
	        if (!isDef(pDivEl.childNodes[i])) {
	            continue;
	        }

	        pDocFrag.appendChild(pDivEl.childNodes[i]);
	    }

	    return pDocFrag;
	};

}



module akra.info {
	export function canvas(pCanvas: HTMLCanvasElement): ICanvasInfo;
	export function canvas(id: string): ICanvasInfo;
	export function canvas(id): ICanvasInfo {
		var pCanvas: HTMLCanvasElement = isString(id) ? document.getElementById(id) : id;

		return {
			width: isInt(pCanvas.width) ? pCanvas.width : parseInt(pCanvas.style.width),
			height: isInt(pCanvas.height) ? pCanvas.height : parseInt(pCanvas.style.height),
			id: pCanvas.id
		};
	}

	export var browser: IBrowserInfo = new util.BrowserInfo;
	export var api: IApiInfo = new util.ApiInfo;
	export var screen: IScreenInfo = new util.ScreenInfo;

	export var uri: IURI = util.uri(document.location.href);

	module is {
/**
         * show status - online or offline
         */

		export var online;
/**
         * perform test on mobile device
         */

		export var mobile: bool = (/mobile|iphone|ipad|ipod|android|blackberry|mini|windows\sce|palm/i)
			.test(navigator.userAgent.toLowerCase());
		export var linux: bool = browser.os === 'Linux';
		export var windows: bool = browser.os === 'Windows';
		export var mac: bool = browser.os === 'Mac';
		export var iPhone: bool = browser.os === 'iPhone';
	}


//TODO: move it to [akra.info.is] module, when typescript access this.
	Object.defineProperty(is, 'online', {
		get: function () {
			return navigator.onLine;
		}
	});
}









module akra.render {

	export class DSViewport extends Viewport implements IDSViewport  {
		private _pDefferedColorTextures: ITexture[];
		private _pDeferredDepthTexture: ITexture;
		private _pDeferredView: IRenderableObject = null;
		private _pDeferredSkyTexture: ITexture = null;
//index of lighting display list
		private _pLightDL:  number ;

		private _pLightingUnifoms: UniformMap = {
	        omni           	: [],
	        project        	: [],
	        omniShadows    	: [],
	        projectShadows 	: [],
	        textures       	: [],
	        samplersOmni  	: [],
	        samplersProject : []
	    };

	    private _pLightPoints: ILightPoint[] = null;

		constructor(pCamera: ICamera, pTarget: IRenderTarget, csRenderMethod: string = null, fLeft:  number  = 0., fTop:  number  = 0., fWidth:  number  = 1., fHeight:  number  = 1., iZIndex:  number  = 0) {
			super(pCamera, pTarget, null, fLeft, fTop, fWidth, fHeight, iZIndex);

			var pEngine: IEngine = this.getTarget().getRenderer().getEngine();
			var pResMgr: IResourcePoolManager = pEngine.getResourceManager();
			var pDeferredData: IRenderTarget[] = <IRenderTarget[]>new Array(2);
			var pDeferredTextures: ITexture[] = <ITexture[]>new Array(2);
			var pDepthTexture: ITexture;
			var pDefferedView: IRenderableObject = this._pDeferredView = new render.RenderableObject();
			var iGuid:  number  = sid();
			var iWidth:  number  = math.ceilingPowerOfTwo(this.actualWidth);
    		var iHeight:  number  = math.ceilingPowerOfTwo(this.actualHeight);

    		if (info.browser.name === "Firefox") {
		        iWidth 	= math.min(iWidth, 1024);
		        iHeight = math.min(iHeight, 1024);
		    }

			pDepthTexture = this._pDeferredDepthTexture = pResMgr.createTexture("deferred-depth-texture-" + iGuid);
			pDepthTexture.create(iWidth, iHeight, 1, null, 0, 0,
					ETextureTypes.TEXTURE_2D, EPixelFormats.DEPTH);

			for (var i = 0; i < 2; ++ i) {
				pDeferredTextures[i] = this._pDefferedColorTextures[i] =
					pResMgr.createTexture("deferred-color-texture-" + i + "-" +  iGuid);
				pDeferredTextures[i].create(iWidth, iHeight, 1, null, 0, 0,
					ETextureTypes.TEXTURE_2D, EPixelFormats.FLOAT32_RGBA);

				pDeferredData[i] = pDeferredTextures[i].getBuffer().getRenderTarget();
				pDeferredData[i].addViewport(this.getCamera(), "deferred_shading_pass_" + i);

				pDeferredData[i].attachDepthTexture(pDepthTexture);
			}

//TODO >>>
// pResMgr.loadAFXEffect("prepare_deferred_shading.afx");
// pResMgr.loadAFXEffect("base_deferred_shading.afx");
// pResMgr.loadAFXEffect("lights_and_shadows_deferred_shading.afx");
// pResMgr.loadAFXEffect("skybox_deferred_shading.afx");
// pResMgr.loadAFXEffect("fxaa_deferred_shading.afx");

			var pDSMethod: IRenderMethod  	= pResMgr.createRenderMethod(".deferred_shading");
			var pDSEffect: IEffect 			= pResMgr.createEffect(".deferred_shading");

// pDSEffect.addComponent("akra.system.prepareForDeferredShading");
			pDSEffect.addComponent("akra.system.deferredShading");
			pDSEffect.addComponent("akra.system.omniLighting");
			pDSEffect.addComponent("akra.system.projectLighting");
			pDSEffect.addComponent("akra.system.omniShadowsLighting");
			pDSEffect.addComponent("akra.system.projectShadowsLighting");
			pDSEffect.addComponent("akra.system.skybox", 1);

			pDSMethod.effect = pDSEffect;
			pDefferedView.renderMethod = pDSMethod;



			this.connect(pDefferedView.getTechnique(),  "render" ,  "_onRender" );
		}

		update (): bool {

			this.prepareForDeferredShading();

			var pLights: ILightPoint[] = <ILightPoint[]><any>this.getCamera().display( 1 );

		    for (var i:  number  = 0; i < pLights.length; i++) {
		        pLights[i]._calculateShadows();
		    }

		    this._pLightPoints = pLights;

//prepare deferred textures
			this._pDefferedColorTextures[0].getBuffer().getRenderTarget().update();
			this._pDefferedColorTextures[1].getBuffer().getRenderTarget().update();

//render defferred
			this._pDeferredView.render();

			return true;
		}

		prepareForDeferredShading(): void {
			var pNodeList: IObjectArray = this.getCamera().display();

			for (var i:  number  = 0; i < pNodeList.length; ++ i) {
				var pRenderable: IRenderableObject = pNodeList.value(i).getRenderable();

				if (pRenderable) {
					for (var j:  number  = 0; j < 2; ++ j) {
						var sMethod: string = "deferred_shading_pass_" + j;
						var pMethod: IRenderMethod = pRenderable.getRenderMethod(sMethod);
						var pTechCurr: IRenderTechnique = pRenderable.getTechnique();
						var pTechnique: IRenderTechnique = pRenderable.getTechnique(sMethod);

						if (isNull(pTechnique) || pTechCurr.modified >= pTechnique.modified) {
							if (!pRenderable.addRenderMethod(pRenderable.getRenderMethod(), sMethod)) {
								logger.setSourceLocation( "DSViewport2.ts" , 138 ); logger.criticalError("cannot clone active render method"); ;
							}

							pTechnique = pRenderable.getTechnique(sMethod);

							for (var k:  number  = 0; k < pTechnique.totalPasses; ++ k) {
								var pPass: IRenderPass = pTechnique.getPass(k);

								if (isNull(pPass.getRenderTarget())) {
									pPass.data.blend("akra.system.prepareForDeferredShading.pass" + j);
								}
							}
						}
					}
				}
			};
		}

		setSkybox(pSkyTexture: ITexture): bool {
			if (pSkyTexture.textureType !== ETextureTypes.TEXTURE_CUBE_MAP) {
				return null;
			}

			this._pDeferredSkyTexture = pSkyTexture;

			return true;
		}

		setFXAA(bValue: bool = true): void {
			var pEffect: IEffect = this._pDeferredView.renderMethod.effect;

			if (bValue) {
				pEffect.addComponent("akra.system.fxaa", 2);
			}
			else {
				pEffect.delComponent("akra.system.fxaa", 2);
			}
		}




		destroy(): void {
			super.destroy();

			this._pDeferredDepthTexture.destroyResource();

			this._pDefferedColorTextures[0].destroyResource();
			this._pDefferedColorTextures[1].destroyResource();

			this._pDeferredView.destroy();
			this._pDeferredView = null;

			this._pDeferredSkyTexture = null;
		}



		_onRender(pTechnique: IRenderTechnique, iPass:  number ): void {
			switch (iPass) {
				case 2:
					var pLightUniforms: UniformMap = this._pLightingUnifoms;
					var pLightPoints: ILightPoint[] = this._pLightPoints;
					var pCamera: ICamera = this.getCamera();
					var pDepthTexture: ITexture = this._pDeferredDepthTexture;
					var pDeferredTextures: ITexture[] = this._pDefferedColorTextures;

					this.createLightingUniforms(pCamera, pLightPoints, pLightUniforms);

					pTechnique.setState("lights.omni", pLightUniforms.omni.length);
					pTechnique.setState("lights.project", pLightUniforms.project.length);
					pTechnique.setState("lights.omniShadows", pLightUniforms.omniShadows.length);
					pTechnique.setState("lights.projectShadows", pLightUniforms.projectShadows.length);

					pTechnique.setForeign("nOmni", pLightUniforms.omni.length);
				    pTechnique.setForeign("nProject", pLightUniforms.project.length);
				    pTechnique.setForeign("nOmniShadows", pLightUniforms.omniShadows.length);
				    pTechnique.setForeign("nProjectShadows", pLightUniforms.projectShadows.length);

				    pTechnique.setStruct("points_omni", pLightUniforms.omni);
				    pTechnique.setStruct("points_project", pLightUniforms.project);
				    pTechnique.setStruct("points_omni_shadows", pLightUniforms.omniShadows);
				    pTechnique.setStruct("points_project_shadows", pLightUniforms.projectShadows);

				    for (var i:  number  = 0; i < pLightUniforms.textures.length; i++) {
				        pTechnique.setTextureBySemantics("TEXTURE" + i, pLightUniforms.textures[i]);
				    }

				    pTechnique.setShadowSamplerArray("project_shadow_sampler", pLightUniforms.samplersProject);
    				pTechnique.setShadowSamplerArray("omni_shadow_sampler", pLightUniforms.samplersOmni);

    				pTechnique.setVec2BySemantic("SCREEN_TEXTURE_RATIO",
                                     vec2(this.actualWidth / pDepthTexture.width, this.actualHeight / pDepthTexture.height));

				    pTechnique.setTextureBySemantics("DEFERRED_TEXTURE0", pDeferredTextures[0]);
				    pTechnique.setTextureBySemantics("DEFERRED_TEXTURE1", pDeferredTextures[1]);
				    pTechnique.setTextureBySemantics("SCENE_DEPTH_TEXTURE", pDepthTexture);

					break;
//case 1;
			}
		}

		private  /**@inline*/  resetUniforms(): void {
			var pUniforms = this._pLightingUnifoms;
			pUniforms.omni.clear();
		    pUniforms.project.clear();
		    pUniforms.omniShadows.clear();
		    pUniforms.projectShadows.clear();
		    pUniforms.textures.clear();
		    pUniforms.samplersProject.clear();
		    pUniforms.samplersOmni.clear();
		}

		private createLightingUniforms(pCamera: ICamera, pLightPoints: ILightPoint[], pUniforms: UniformMap): void {
			var pLight: ILightPoint;
			var pOmniLight: IOmniLight;
			var pProjectLight: IProjectLight;
		    var i:  number , j:  number ;
		    var pUniformData: IUniform;
		    var pCameraView: IMat4 = pCamera.viewMatrix;

		    var v4fLightPosition: IVec4 = vec4();
		    var v3fLightTransformPosition: IVec3 = vec3();
		    var v4fTemp: IVec4 = vec4();

		    var pShadowCaster: IShadowCaster;
		    var m4fShadow: IMat4, m4fToLightSpace: IMat4;

		    var iLastTextureIndex:  number  = 0;
		    var sTexture: string = "TEXTURE";

		    this.resetUniforms();

		    for (i = 0; i < pLightPoints.length; i++) {
		        pLight = pLightPoints[i];

		        if (!pLight.enabled) {
		            continue;
		        }

		        v4fLightPosition.set(pLight.worldPosition, 1.);
		        pCameraView.multiplyVec4(v4fLightPosition, v4fTemp)
		        v3fLightTransformPosition.set(v4fTemp.x, v4fTemp.y, v4fTemp.z);

		        if (pLight.type === < number >EEntityTypes.LIGHT_OMNI_DIRECTIONAL) {

		        	pOmniLight = <IOmniLight>pLight;

		            if (pLight.isShadowCaster()) {
		                pUniformData =  UniformOmniShadow.stackCeil ;
		                (<UniformOmniShadow>pUniformData).setLightData(pLight.params, v3fLightTransformPosition);

		                var pDepthCube: ITexture[] 					= pOmniLight.getDepthTextureCube();
		                var pShadowCasterCube: IShadowCasterCube 	= pOmniLight.getShadowCaster();
		                var pOptimizedProjCube: IMat4[] 			= pOmniLight.optimizedProjectionCube;

		                for (j = 0; j < 6; ++ j) {
		                    pShadowCaster = pShadowCasterCube[j];
		                    m4fToLightSpace = pShadowCaster.viewMatrix.multiply(pCamera.worldMatrix, mat4());
		                    pUniforms.textures.push(pDepthCube[j]);
		                    sTexture = "TEXTURE" + (pUniforms.textures.length - 1);

		                    (<UniformOmniShadow>pUniformData).setSampler(sTexture, j);
		                    pUniforms.samplersOmni.push((<UniformOmniShadow>pUniformData).SHADOW_SAMPLER[j]);
		                    (<UniformOmniShadow>pUniformData).setMatrix(m4fToLightSpace,pOptimizedProjCube[j], j);
		                }

		                pUniforms.omniShadows.push(<UniformOmniShadow>pUniformData);
		            }
		            else {
		                pUniformData =  UniformOmni.stackCeil ;
		                (<UniformOmni>pUniformData).setLightData(pLight.params, v3fLightTransformPosition);
		                pUniforms.omni.push(<UniformOmni>pUniformData);
		            }
		        }
		        else if (pLight.type === < number >EEntityTypes.LIGHT_PROJECT) {
		        	pProjectLight = <IProjectLight>pLight;

		            if (pLight.isShadowCaster()) {
		                pUniformData =  UniformProjectShadow.stackCeil ;
		                (<UniformProjectShadow>pUniformData).setLightData(pLight.params, v3fLightTransformPosition);

		                pShadowCaster = pProjectLight.getShadowCaster();
		                m4fToLightSpace = pShadowCaster.viewMatrix.multiply(pCamera.worldMatrix, mat4());
		                pUniforms.textures.push(pProjectLight.getDepthTexture());
		                sTexture = "TEXTURE" + (pUniforms.textures.length - 1);

		                (<UniformProjectShadow>pUniformData).setSampler(sTexture);
		                pUniforms.samplersProject.push((<UniformProjectShadow>pUniformData).SHADOW_SAMPLER);
		                (<UniformProjectShadow>pUniformData).setMatrix(m4fToLightSpace, pShadowCaster.projectionMatrix, pProjectLight.optimizedProjection);
		                pUniforms.projectShadows.push(<UniformProjectShadow>pUniformData);
		            }
		            else {
		                pUniformData =  UniformProject.stackCeil ;
		                (<UniformProject>pUniformData).setLightData(pLight.params, v3fLightTransformPosition);
		                pShadowCaster = pProjectLight.getShadowCaster();
		                m4fShadow = pShadowCaster.projViewMatrix.multiply(pCamera.worldMatrix, mat4());
		                (<UniformProject>pUniformData).setMatrix(m4fShadow);
		                pUniforms.project.push(<UniformProject>pUniformData);
		            }

		        }
		        else {
		        	logger.setSourceLocation( "DSViewport2.ts" , 342 ); logger.criticalError("Invalid light point type detected."); ;
		        }
		    }
		}
	}
}












/* Define the number of priority groups for the render system's render targets. */







module akra.render {

	export class RenderTarget implements IRenderTarget {
		/**@protected*/  _sName: string;
		/**@protected*/  _pRenderer: IRenderer;

		/**@protected*/  _iPriority:  number  =  4 ;

		/**@protected*/  _iWidth:  number ;
		/**@protected*/  _iHeight:  number ;

		/**@protected*/  _iColorDepth:  number ;
		/**@protected*/  _pDepthBuffer: IDepthBuffer = null;
		/**@protected*/  _pDepthPixelBuffer: IPixelBuffer = null;

		/**@protected*/  _pFrameStats: IFrameStats;

		/**@protected*/  _pTimer: IUtilTimer;
		/**@protected*/  _fLastSecond:  number ;
		/**@protected*/  _fLastTime:  number ;
		/**@protected*/  _iFrameCount:  number ;

		/**@protected*/  _isActive: bool = true;
		/**@protected*/  _isAutoUpdate: bool = true;

		/**@protected*/  _bHwGamma: bool = false;

		/**@protected*/  _pViewportList: IViewport[];


		/**@inline*/  get name(): string { return this._sName; }
		/**@inline*/  set name(sName: string) { this._sName = sName; }

		/**@inline*/  get width():  number  { return this._iWidth; }
		/**@inline*/  get height():  number  { return this._iHeight; }
		/**@inline*/  get colorDepth():  number  { return this._iColorDepth; }

		/**@inline*/  get totalViewports():  number  { return this._pViewportList.length; }
		/**@inline*/  get totalFrames():  number  { return this._iFrameCount; }

		/**@inline*/  get priority():  number  { return this._iPriority; }


		constructor (pRenderer: IRenderer) {
			this._pRenderer = pRenderer;
			this._pTimer = pRenderer.getEngine().getTimer();

			this.resetStatistics();
		}

		/**@inline*/  getRenderer(): IRenderer { return this._pRenderer; }

		destroy(): void {
			var pViewport: IViewport;

			for (var i in this._pViewportList) {
				pViewport = this._pViewportList[i];
				this.viewportRemoved(pViewport)
				pViewport.destroy();
			}

			this.detachDepthBuffer();

			logger.setSourceLocation( "render/RenderTarget.ts" , 88 ); logger.log("RenderTarget '%s'\n Average FPS: %s\n Best FPS: %s\n Worst FPS: %s", this._sName, this._pFrameStats.fps.avg, this._pFrameStats.fps.best, this._pFrameStats.fps.worst);
                                ;
		}

		getDepthBuffer(): IDepthBuffer {
			return this._pDepthBuffer;
		}

		attachDepthBuffer(pBuffer: IDepthBuffer): bool {
			var isOk: bool = false;

			if ((isOk = pBuffer.isCompatible(this))) {
				this.detachDepthBuffer();
				this._pDepthBuffer = pBuffer;
				this._pDepthBuffer._notifyRenderTargetAttached(this);
			}

			return isOk;
		}

		attachDepthPixelBuffer(pBuffer: IPixelBuffer): bool {

			if(this._iWidth !== pBuffer.width ||
			   this._iHeight !== pBuffer.height) {
				return false;
			}

			var eFormat: EPixelFormats = pBuffer.format;
			if(eFormat !== EPixelFormats.DEPTH ||
			   eFormat !== EPixelFormats.DEPTH_BYTE){
				return false;
			}

			this.detachDepthPixelBuffer();
			this._pDepthPixelBuffer = pBuffer;

			return true;
		}

		detachDepthPixelBuffer(): void {
			if(this._pDepthPixelBuffer){
				this._pDepthPixelBuffer = null;
			}
		}

		detachDepthBuffer(): void {
			if (this._pDepthBuffer) {
				this._pDepthBuffer._notifyRenderTargetDetached( this );
				this._pDepthBuffer = null;
			}
		}

		attachDepthTexture(pTexture: ITexture): bool {
			return false;
		}

		detachDepthTexture(): void {

		}

		_detachDepthBuffer(): void {
			this._pDepthBuffer = null;
		}


		_beginUpdate(): void {
			this.preUpdate();

			this._pFrameStats.polygonsCount = 0;
		}

		_updateAutoUpdatedViewports(bUpdateStatistics: bool = true): void {
	        var pViewport: IViewport;

	        for (var i in this._pViewportList) {
				pViewport = this._pViewportList[i];

				if(pViewport.isAutoUpdated()) {
					this._updateViewport(pViewport, bUpdateStatistics);
				}
			}
		}

		_endUpdate(): void {
			this.postUpdate();
			this.updateStats();
		}

		_updateViewport(iZIndex:  number , bUpdateStatistics: bool = true): void;
		_updateViewport(pViewportPtr: IViewport, bUpdateStatistics: bool = true): void;
		_updateViewport(pViewportPtr: any, bUpdateStatistics: bool = true): void {
			var pViewport: IViewport;
			var iZIndex:  number

			if (isNumber(arguments[0])) {
				iZIndex = < number >arguments[0];
				pViewport = this._pViewportList[iZIndex];

				logger.setSourceLocation( "render/RenderTarget.ts" , 186 ); logger.assert(isDefAndNotNull(pViewport), "No viewport with given z-index : %s", iZIndex, "RenderTarget::_updateViewport");
                                     ;
			}
			else {
				pViewport = <IViewport>arguments[0];
			}

			logger.setSourceLocation( "render/RenderTarget.ts" , 193 ); logger.assert(pViewport.getTarget() == this, "RenderTarget::_updateViewport the requested viewport is not bound to the rendertarget!");
                                                                                             ;

			this.viewportPreUpdate(pViewport);

			pViewport.update();

			if (bUpdateStatistics) {
				this._pFrameStats.polygonsCount += pViewport._getNumRenderedPolygons();
			}

			this.viewportPostUpdate(pViewport);
		}

		addViewport(pCamera: ICamera, csRenderMethod: string = null, iZIndex:  number  = 0, fLeft:  number  = 0., fTop:  number  = 0., fWidth:  number  = 1., fHeight:  number  = 1.): IViewport;
		addViewport(pCamera: ICamera, eType:  number  = -1, iZIndex:  number  = 0, fLeft:  number  = 0., fTop:  number  = 0., fWidth:  number  = 1., fHeight:  number  = 1.): IViewport;
		addViewport(pCamera: ICamera, csRenderMethod: any = null, iZIndex:  number  = 0, fLeft:  number  = 0., fTop:  number  = 0., fWidth:  number  = 1., fHeight:  number  = 1.): IViewport {
			var pViewport: IViewport = this._pViewportList[iZIndex];

			if (isDefAndNotNull(pViewport)) {
				logger.setSourceLocation( "render/RenderTarget.ts" , 213 ); logger.criticalError("Can't create another viewport for %s with Z-index %s 					because a viewport exists with this Z-Order already.", this._sName, iZIndex, "RenderTarget::addViewport"); ;
			}

			if (isNumber(arguments[1]) && < number >arguments[1] >= 0) {
				pViewport = new DSViewport(pCamera, this, null, fLeft, fTop, fWidth, fHeight, iZIndex);
			}
			else {
				pViewport = new Viewport(pCamera, this, isNumber(arguments[1])? null: csRenderMethod,
					fLeft, fTop, fWidth, fHeight, iZIndex);
			}

			this._pViewportList[iZIndex] = pViewport;

			this.viewportAdded(pViewport);

			return pViewport;
		}


		removeViewport(iZIndex:  number ): bool {
			var pViewport: IViewport = this._pViewportList[iZIndex];

			if (isDefAndNotNull(pViewport)) {
				this.viewportRemoved(pViewport);

				this._pViewportList.splice(iZIndex, 1);
				pViewport = null;

				return true;
			}

			return false;
		}

		removeAllViewports():  number  {
			var pViewport: IViewport;
			var iTotal:  number ;

			for (var i in this._pViewportList) {
				pViewport = this._pViewportList[i];
	            this.viewportRemoved(pViewport);
	        }

	        iTotal = this._pViewportList.length;

        	(<any>this._pViewportList).clear();

        	return iTotal;
		}

		/**@inline*/  getStatistics(): IFrameStats {
			return this._pFrameStats;
		}

		/**@inline*/  getLastFPS():  number  {
			return this._pFrameStats.fps.last;
		}

		/**@inline*/  getAverageFPS():  number  {
			return this._pFrameStats.fps.avg;
		}

		/**@inline*/  getBestFPS():  number  {
			return this._pFrameStats.fps.best;
		}

		/**@inline*/  getWorstFPS():  number  {
			return this._pFrameStats.fps.worst;
		}

		/**@inline*/  getPolygonCount():  number  {
			return this._pFrameStats.polygonsCount;
		}

		/**@inline*/  getBestFrameTime():  number  {
			return this._pFrameStats.time.best;
		}

		/**@inline*/  getWorstFrameTime():  number  {
			return this._pFrameStats.time.worst;
		}

		resetStatistics(): void {
			var pStats: IFrameStats = this._pFrameStats;
			pStats.fps.avg = 0.;
			pStats.fps.best = 0.;
			pStats.fps.last = 0.;
			pStats.fps.worst = 999.;

			pStats.polygonsCount = 0;

			pStats.time.best = 9999999;
			pStats.time.worst = 0;

//FIXME: get right time!!!
			this._fLastTime = this._pTimer.appTime;
			this._fLastSecond = this._fLastTime;
			this._iFrameCount = 0;
		}

		updateStats(): void {
			this._iFrameCount ++;

			var fThisTime:  number  = this._pTimer.appTime;

			var fFrameTime:  number  = fThisTime - this._fLastTime;

			this._fLastTime = fThisTime;

			this._pFrameStats.time.best = math.min(this._pFrameStats.time.best, fFrameTime);
			this._pFrameStats.time.worst = math.min(this._pFrameStats.time.worst, fFrameTime);

			if (fThisTime - this._fLastTime > 1) {
				this._pFrameStats.fps.last = < number >this._iFrameCount / < number >(fThisTime - this._fLastSecond);

				if (this._pFrameStats.fps.avg == 0.) {
					this._pFrameStats.fps.avg = this._pFrameStats.fps.last;
				}
				else {
					this._pFrameStats.fps.avg = (this._pFrameStats.fps.avg + this._pFrameStats.fps.last) / 2.;

					this._pFrameStats.fps.best = math.max(this._pFrameStats.fps.best, this._pFrameStats.fps.last);
					this._pFrameStats.fps.worst = math.max(this._pFrameStats.fps.worst, this._pFrameStats.fps.last);

					this._fLastSecond = fThisTime;
					this._iFrameCount = 0;
				}
			}
		}

		getCustomAttribute(sName: string): any {
			return null;
		}

		getViewport(iIndex:  number ): IViewport {
			logger.setSourceLocation( "render/RenderTarget.ts" , 348 ); logger.assert(iIndex < this._pViewportList.length, "Index out of bounds"); ;

			for (var i in this._pViewportList) {
				if (iIndex --) {
					continue;
				}

				return this._pViewportList[i];
			}

			return null;
		}

		getViewportByZIndex(iZIndex:  number ): IViewport {
			var pViewport: IViewport = this._pViewportList[iZIndex];

			logger.setSourceLocation( "render/RenderTarget.ts" , 365 ); logger.assert(isDefAndNotNull(pViewport), "No viewport with given z-index : " + String(iZIndex), "RenderTarget::getViewportByZIndex");
                                                           ;

			return pViewport;
		}

		/**@inline*/  hasViewportByZIndex(iZIndex:  number ): bool {
			return isDefAndNotNull(this._pViewportList[iZIndex]);
		}

		/**@inline*/  isActive(): bool {
			return this._isActive;
		}

		setActive(bValue: bool = true): void {
			this._isActive = bValue;
		}

		/**@inline*/  setAutoUpdated(isAutoUpdate: bool = true): void {
			this._isAutoUpdate = isAutoUpdate;
		}

		_notifyCameraRemoved(pCamera: ICamera): void {
			var isRemoved: bool = false;
			for (var i in this._pViewportList) {
				var pViewport: IViewport = this._pViewportList[i];

				if (pViewport.getCamera() === pCamera) {
					pViewport.setCamera(null);
					isRemoved = true;
				}
			}

			if (isRemoved) {
				this.cameraRemoved(pCamera);
			}
		}

		/**@inline*/  setAutoUpdare(bValue: bool = true): void {
			this._isAutoUpdate = bValue;
		}

		/**@inline*/  isAutoUpdated(): bool {
			return this._isAutoUpdate;
		}

		/**@inline*/  isPrimary(): bool {
// RenderWindow will override and return true for the primary window
			return false;
		}

		update(): void {
			this.updateImpl();
		}

		readPixels(ppDest?: IPixelBox, eFramebuffer?: EFramebuffer): IPixelBox {
			return null;
		}


		/**@protected*/  updateImpl(): void {
			this._beginUpdate();
			this._updateAutoUpdatedViewports(true);
			this._endUpdate();
		}

		private _iGuid: number = eval("this._iGuid || akra.sid()"); private _pUnicastSlotMap: IEventSlotMap = null; private _pBroadcastSlotList: IEventSlotListMap = null; private static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable {return RenderTarget._pEventTable; } getGuid(): number {return this._iGuid < 0? (this._iGuid = sid()): this._iGuid; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
			preUpdate (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).preUpdate; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
			viewportPreUpdate (pViewport): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).viewportPreUpdate; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport) : _broadcast[i].listener (_recivier, pViewport) ; } } } ; ;
			viewportPostUpdate (pViewport): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).viewportPostUpdate; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport) : _broadcast[i].listener (_recivier, pViewport) ; } } } ; ;
			viewportAdded (pViewport): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).viewportAdded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport) : _broadcast[i].listener (_recivier, pViewport) ; } } } ; ;
			viewportRemoved (pViewport): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).viewportRemoved; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport) : _broadcast[i].listener (_recivier, pViewport) ; } } } ; ;
			postUpdate (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).postUpdate; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ;

			cameraRemoved (pCamera): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).cameraRemoved; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pCamera) : _broadcast[i].listener (_recivier, pCamera) ; } } } ; ;
		;
	}
}



module  akra.render {


	export var SShaderPrefixes = {
		k_Sampler    : "A_s_",
		k_Header     : "A_h_",
		k_Attribute  : "A_a_",
		k_Offset     : "A_o_",
		k_Texture    : "TEXTURE",
		k_Texcoord   : "TEXCOORD",
		k_Texmatrix  : "TEXMATRIX",
		k_Temp       : "TEMP_",
		k_BlendType  : "AUTO_BLEND_TYPE_"
	};

	export var ZEROSAMPLER:  number  = 19;

	export var SSystemSemantics = {
		MODEL_MATRIX: 		"MODEL_MATRIX",
		VIEW_MATRIX: 		"VIEW_MATRIX",
		PROJ_MATRIX: 		"PROJ_MATRIX",
		NORMAL_MATRIX: 		"NORMAL_MATRIX",
		BIND_MATRIX: 		"BIND_SHAPE_MATRIX",
		RENDER_OBJECT_ID: 	"RENDER_OBJECT_ID"
	}

	export interface IRenderTargetPriorityMap {
		[index:  number ]: IRenderTarget;
	}

	export class Renderer implements IRenderer {
		private _pEngine: IEngine;
		private _pRenderTargets: IRenderTarget[];
		private _pPrioritisedRenderTargets: IRenderTargetPriorityMap;

		constructor (pEngine: IEngine) {
			this._pEngine = pEngine;
		}


		/**@inline*/  getEngine(): IEngine { return this. _pEngine; }

	    hasCapability(eCapability: ERenderCapabilities): bool {
	      return false;
	    }


		debug(bValue?: bool): bool {
			return false;
		}

		enableAPITrace(): bool {
			return false;
		}

		isDebug(): bool {
			return false;
		}

		isValid(): bool {
			return false;
		}

		/**@inline*/  getError(): string {
			return null;
		}

		clearFrameBuffer(iBuffer:  number , cColor: IColor, iDepth:  number ): void {

		}

 		attachRenderTarget(pTarget: IRenderTarget): bool {
 			for(var i:  number  = 0; i < this._pRenderTargets.length; i++){
       			if(this._pRenderTargets[i] === pTarget){
       				return false;
       			}
       		}

 			this._pRenderTargets.push(pTarget);
 			return true;
 		}

        detachRenderTarget(pTarget: IRenderTarget): bool {
       		for(var i:  number  = 0; i < this._pRenderTargets.length; i++){
       			if(this._pRenderTargets[i] === pTarget){
       				this._pRenderTargets.splice(i, 1);
       				return true;
       			}
       		}

       		return false;
        }

        destroyRenderTarget(pTarget: IRenderTarget): void {
        	var hasTarget: bool = this.detachRenderTarget(pTarget);
        	if(hasTarget){
        		pTarget.destroy();
        		pTarget = null;
        	}
        }

        getActiveProgram(): IShaderProgram {
        	logger.setSourceLocation( "render/Renderer.ts" , 131 ); logger.criticalError("Renderer::getActiveProgram() is uncompleted method!"); ;
        	return null;
        }

		/**@inline*/  _disableAllTextureUnits(): void {
			this._disableTextureUnitsFrom(0);
		}

		/**@inline*/  _disableTextureUnitsFrom(iUnit:  number ): void {

		}

		_initRenderTargets(): void {
// Init stats
	        for(var i:  number  = 0; i < this._pRenderTargets.length; ++ i) {
	            this._pRenderTargets[i].resetStatistics();
	        }
		}

		_updateAllRenderTargets(): void {
			var pTarget: IRenderTarget;
			for (var i in this._pPrioritisedRenderTargets) {
				pTarget = this._pPrioritisedRenderTargets[i];

				if (pTarget.isActive() && pTarget.isAutoUpdated()) {
					pTarget.update();
				}
			}
		}

		_setViewport(pViewport: IViewport): void {

		}

		_getViewport(): IViewport {
			return null;
		}
	}
};





module akra.webgl {
	export class WebGLRenderer extends render.Renderer implements IWebGLRenderer {
		private _pCanvas: HTMLCanvasElement;

		private _pWebGLContext: WebGLRenderingContext;
		private _pWebGLFramebufferList: WebGLFramebuffer[];

		constructor (pEngine: IEngine);
		constructor (pEngine: IEngine, sCanvas: string);
		constructor (pEngine: IEngine, pCanvas: HTMLCanvasElement);
		constructor (pEngine: IEngine, pCanvas?: any) {
			super(pEngine);

			if (isDef(pCanvas)) {

//get HTMLCanvasElement by id
				if (isString(pCanvas)) {
					this._pCanvas = <HTMLCanvasElement>document.getElementById(pCanvas);
				}
				else {
					this._pCanvas = <HTMLCanvasElement>pCanvas;
				}
			}
			else {
				this._pCanvas = <HTMLCanvasElement>document.createElement('canvas');
			}

			this._pWebGLContext = createContext(this._pCanvas);
			this._pWebGLFramebufferList = new Array( 32 );


			for (var i:  number  = 0; i < this._pWebGLFramebufferList.length; ++ i) {
				this._pWebGLFramebufferList[i] = this._pWebGLContext.createFramebuffer();
			}
		}

		/**@inline*/  getHTMLCanvas(): HTMLCanvasElement {
			return this._pCanvas;
		}

		/**@inline*/  getWebGLContext(): WebGLRenderingContext {
			return this._pWebGLContext;
		}


/** Buffer Objects. */

		/**@inline*/  bindWebGLBuffer(eTarget:  number , pBuffer: WebGLBuffer): void {
			this._pWebGLContext.bindBuffer(eTarget, pBuffer);
		}

		/**@inline*/  createWebGLBuffer(): WebGLBuffer {
			return this._pWebGLContext.createBuffer();
		}

		/**@inline*/  deleteWebGLBuffer(pBuffer: WebGLBuffer): void {
			this._pWebGLContext.deleteBuffer(pBuffer);
		}

/** Texture Objects. */

		/**@inline*/  bindWebGLTexture(eTarget:  number , pTexture: WebGLTexture): void {
			this._pWebGLContext.bindTexture(eTarget, pTexture);
		}

		/**@inline*/  activateWebGLTexture(iSlot:  number ): void {
			this._pWebGLContext.activeTexture(iSlot);
		}

		/**@inline*/  createWebGLTexture(): WebGLTexture {
			return this._pWebGLContext.createTexture();
		}

		/**@inline*/  deleteWebGLTexture(pTexture: WebGLTexture): void {
			this._pWebGLContext.deleteTexture(pTexture);
		}

/** Framebuffer Objects */

		/**@inline*/  createWebGLFramebuffer(): WebGLFramebuffer {

			if (this._pWebGLFramebufferList.length === 0) {
				logger.setSourceLocation( "webgl/WebGLRenderer.ts" , 89 ); logger.criticalError("WebGL framebuffer limit exidit"); ;
			}

			return this._pWebGLFramebufferList.pop();
		}

		/**@inline*/  bindWebGLFramebuffer(eTarget:  number , pBuffer: WebGLFramebuffer): void {
			this._pWebGLContext.bindFramebuffer(eTarget, pBuffer);
		}

		/**@inline*/  deleteWebGLFramebuffer(pBuffer: WebGLFramebuffer): void {
			this._pWebGLFramebufferList.push(pBuffer);
		}

/** Renderbuffer Objects */

		/**@inline*/  createWebGLRenderbuffer(): WebGLRenderbuffer {
			return this._pWebGLContext.createRenderbuffer();
		}

		/**@inline*/  bindWebGLRenderbuffer(eTarget:  number , pBuffer: WebGLRenderbuffer): void {
			this._pWebGLContext.bindRenderbuffer(eTarget, pBuffer);
		}

		/**@inline*/  deleteWebGLRenderbuffer(pBuffer: WebGLRenderbuffer): void {
			this._pWebGLContext.deleteRenderbuffer(pBuffer);
		}


		/**@inline*/  createWebGLProgram(): WebGLProgram {
			return this._pWebGLContext.createProgram();
		}

		/**@inline*/  deleteWebGLProgram(pProgram: WebGLProgram): void {
			this._pWebGLContext.deleteProgram(pProgram);
		}

		/**@inline*/  useWebGLProgram(pProgram: WebGLProgram): void {
			this._pWebGLContext.useProgram(pProgram);
		}

		/**@inline*/  disableAllWebGLVertexAttribs(): void {

//TODO: check attrib array from last shader program
			var i: number  = 0;
			for(i = 0; i < 16; i++) {
				this._pWebGLContext.disableVertexAttribArray(i);
			}

		}
	}
}



module akra.webgl {

	export function computeLog(iValue:  number ):  number  {
	    var i:  number  = 0;
/* Error! */

	    if (iValue === 0) return -1;

	    for (;;) {
	        if (iValue & 1) {
/* Error! */

	            if (iValue !== 1) return -1;
	                return i;
	        }
	        iValue = iValue >> 1;
	        i++;
	    }
	}

	export class WebGLTextureBuffer extends WebGLPixelBuffer implements IPixelBuffer {
		/**@protected*/  _eTarget:  number  = null;
		/**@protected*/  _eFaceTarget:  number  = null;
		/**@protected*/  _pWebGLTexture: WebGLTexture = null;
		/**@protected*/  _iFace:  number  = 0;
		/**@protected*/  _iLevel:  number  = 0;
		/**@protected*/  _bSoftwareMipmap: bool = false;
		/**@protected*/  _pRTTList: IRenderTexture[] = null;

		constructor () {
			super();
		}

		_clearRTT(iZOffset:  number ): void {
			this._pRTTList[iZOffset] = null;
		}

		create(iFlags:  number ): bool;
		create(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats, iFlags:  number ): bool;
		create(eTarget:  number , pTexture: WebGLTexture, iWidth:  number , iHeight:  number , iInternalFormat:  number , iFormat:  number ,
			   iFace:  number , iLevel:  number , iFlags:  number , bSoftwareMipmap: bool): bool;
		create(): bool {
			if(arguments.length < 6) {
				logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 53 ); logger.criticalError("Invalid number of params. For WebGLTextureBuffer"); ;
			}

			var eTarget:  number  = arguments[0];
			var pTexture: WebGLTexture = arguments[1];
			var iWidth:  number  = arguments[2];
			var iHeight:  number  = arguments[3];
			var iInternalFormat:  number  = arguments[4];
			var iFormat:  number  = arguments[5];
			var iFace:  number  = arguments[6];
			var iLevel:  number  = arguments[7];
			var iFlags:  number  = arguments[8];
			var bSoftwareMipmap: bool = arguments[9];

			var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer();

			pWebGLRenderer.bindWebGLTexture(eTarget, pTexture);

			this._eTarget = eTarget;
			this._pWebGLTexture = pTexture;
			this._iFace = iFace;
			this._iLevel = iLevel;
			this._bSoftwareMipmap = bSoftwareMipmap;

			this._eFaceTarget = eTarget;

			if(eTarget ===  0x8513 ){
				this._eFaceTarget =  0x8515  + iFace;
			}

			this._iWidth = iLevel === 0 ? iWidth : iWidth / Math.pow(2.0, iLevel);
			this._iHeight = iLevel === 0 ? iHeight : iHeight / Math.pow(2.0, iLevel);
			this._iDepth = 1;

			this._iWebGLInternalFormat = iInternalFormat;
			this._eFormat = webgl.getClosestAkraFormat(iInternalFormat, iFormat);

			this._iRowPitch = this._iWidth;
			this._iSlicePitch = this._iHeight * this._iWidth;
			this.byteLength = pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);

			this._pBuffer = new pixelUtil.PixelBox(this._iWidth, this._iHeight, this._iDepth, this._eFormat);

			if(this._iWidth === 0 || this._iHeight === 0 || this._iDepth === 0){
// We are invalid, do not allocate a buffer
				return false;
			}

// Is this a render target?
	        if ( (((this._iFlags) & (ETextureFlags.RENDERTARGET)) != 0) ) {
// Create render target for each slice
	            this._pRTTList = new WebGLRenderTexture[];
	            for(var iZOffset:  number  = 0; iZOffset < this._iDepth; ++iZOffset) {
	                var pRenderTexture: WebGLRenderTexture = new WebGLRenderTexture(pWebGLRenderer, this);
	                this._pRTTList.push(pRenderTexture);
	                pWebGLRenderer.attachRenderTarget(pRenderTexture);
	            }
	        }

	        var pProgram: IShaderProgram = <IShaderProgram>this.getManager().shaderProgramPool.findResource("WEBGL_blit_texture_buffer");

	        if(isNull(pProgram)){
	        	pProgram = <IShaderProgram>this.getManager().shaderProgramPool.createResource("WEBGL_blit_texture_buffer");
	        	pProgram.create(
	        	"																									\n	        	attribute vec2 POSITION;																			\n				attribute vec3 TEXCOORD;																			\n				                      																				\n				varying vec3 texcoord;																				\n				                   																					\n				void main(void){																					\n				    texcoord = TEXCOORD;																			\n				    gl_Position = vec4(POSITION, 0., 1.);															\n				}																									\n				",
				"													\n				#ifdef GL_ES                        				\n				    precision highp float;          				\n				#endif												\n				varying vec3 texcoord;              				\n				uniform sampler2D uSampler;        					\n																	\n				void main(void) {  									\n					vec4 color;										\n					color = texture2D(uSampler, texcoord.xy);      	\n				    gl_FragColor = color;           				\n				}                                   				\n				");
	        }

			return true;
		}

		destroy(): void {
			if ( (((this._iFlags) & (ETextureFlags.RENDERTARGET)) != 0) ) {
// Delete all render targets that are not yet deleted via _clearSliceRTT because the rendertarget
// was deleted by the user.
	            var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer();
	            for (var i:  number  = 0; i < this._pRTTList.length; i++) {
	                pWebGLRenderer.destroyRenderTarget(this._pRTTList[i]);
	            }
	        }
    	}

//upload(download) data to(from) videocard.
		/**@protected*/  upload(pData: IPixelBox, pDestBox: IBox): void {
			var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);

			if(pixelUtil.isCompressed(pData.format)) {
				if(pData.format !== this._eFormat || !pData.isConsecutive()){
					logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 166 ); logger.criticalError("Compressed images must be consecutive, in the source format"); ;
				}

				var iWebGLFormat:  number  = webgl.getClosestWebGLInternalFormat(this._eFormat);
// Data must be consecutive and at beginning of buffer as PixelStorei not allowed
// for compressed formats
            	if (pDestBox.left === 0 && pDestBox.top === 0) {
	                pWebGLContext.compressedTexImage2D(this._eFaceTarget, this._iLevel,
	                                       			   iWebGLFormat,
	                                       			   pDestBox.width,
	                                       			   pDestBox.height,
	                                       			   0,
	                                       			   pData.data);
	            }
	            else {
	                pWebGLContext.compressedTexSubImage2D(this._eFaceTarget, this._iLevel,
	                                          			  pDestBox.left, pDestBox.top,
	                                          			  pDestBox.width, pDestBox.height,
	                                          			  iWebGLFormat, pData.data);

	            }
			}
			else if(this._bSoftwareMipmap) {
				if (pData.width !== pData.rowPitch) {
// TODO
	                logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 191 ); logger.criticalError("Unsupported texture format"); ;
	            }

	            if (pData.height * pData.width !== pData.slicePitch) {
// TODO
	                logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 196 ); logger.criticalError("Unsupported texture format"); ;
	            }

	            pWebGLContext.pixelStorei( 0x0CF5 , 1);
	            this.buildMipmaps(pData);
			}
			else {
				if(pData.width !== pData.rowPitch) {
// TODO
	                logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 205 ); logger.criticalError("Unsupported texture format"); ;
	            }

	            if(pData.height * pData.width !== pData.slicePitch) {
// TODO
	                logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 210 ); logger.criticalError("Unsupported texture format"); ;
	            }

	            if ((pData.width * pixelUtil.getNumElemBytes(pData.format)) & 3) {
// Standard alignment of 4 is not right
	                pWebGLContext.pixelStorei( 0x0CF5 , 1);
	            }

	            pWebGLContext.texSubImage2D(this._eFaceTarget,
	                            			this._iLevel,
	                            			pDestBox.left, pDestBox.top,
	                            			pDestBox.width, pDestBox.height,
	                            			webgl.getWebGLOriginFormat(pData.format),
	                            			webgl.getWebGLOriginDataType(pData.format),
	                            			pData.data);
	        }

	        if ( (((this._iFlags) & (ETextureFlags.AUTOMIPMAP)) != 0)  && !this._bSoftwareMipmap && (this._iLevel === 0)) {
	            pWebGLContext.generateMipmap(this._eFaceTarget);
	        }

	        pWebGLContext.pixelStorei( 0x0CF5 , 4);

	        this.notifyAltered();
		}

		/**@protected*/  download(pData: IPixelBox): void {
// if(data.getWidth() != getWidth() ||
//     data.getHeight() != getHeight() ||
//     data.getDepth() != getDepth())
//     OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, "only download of entire buffer is supported by GL",
//         "GLTextureBuffer::download");
// glBindTexture( mTarget, mTextureID );
// if(PixelUtil::isCompressed(data.format))
// {
//     if(data.format != mFormat || !data.isConsecutive())
//         OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, 
//         "Compressed images must be consecutive, in the source format",
//         "GLTextureBuffer::download");
//     // Data must be consecutive and at beginning of buffer as PixelStorei not allowed
//     // for compressed formate
//     glGetCompressedTexImageNV(mFaceTarget, mLevel, data.data);
// } 
// else
// {
//     if((data.getWidth()*PixelUtil::getNumElemBytes(data.format)) & 3) {
//         // Standard alignment of 4 is not right
//         glPixelStorei(GL_PACK_ALIGNMENT, 1);
//     }
//     // We can only get the entire texture
//     glGetTexImageNV(mFaceTarget, mLevel, 
//         GLES2PixelUtil::getGLOriginFormat(data.format), GLES2PixelUtil::getGLOriginDataType(data.format),
//         data.data);
//     // Restore defaults
//     glPixelStorei(GL_PACK_ALIGNMENT, 4);
// }
			logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 266 ); logger.criticalError("Downloading texture buffers is not supported by OpenGL ES"); ;
		}

		/**@protected*/  buildMipmaps(pData: IPixelBox): void {
			var iWidth:  number  = 0;
	        var iHeight:  number  = 0;
	        var iLogW:  number  = 0;
	        var iLogH:  number  = 0;
	        var iLevel:  number  = 0;
	        var pScaled: IPixelBox = new pixelUtil.PixelBox();

	        pScaled.data = pData.data;
	        pScaled.left = pData.left;
	        pScaled.right = pData.right;
	        pScaled.top = pData.top;
	        pScaled.bottom = pData.bottom;
	        pScaled.front = pData.front;
	        pScaled.back = pData.back;

	        iWidth = pData.width;
	        iHeight = pData.height;

	        iLogW = computeLog(iWidth);
	        iLogH = computeLog(iHeight);
	        iLevel = (iLogW > iLogH ? iLogW : iLogH);

	        var mip:  number  = 0;
	        var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

	        for (mip = 0; mip <= iLevel; mip++) {
	           	var iWebGLFormat:  number  = webgl.getWebGLOriginFormat(pScaled.format);
	            var iWebGLDataType:  number  = webgl.getWebGLOriginDataType(pScaled.format);

	            pWebGLContext.texImage2D(this._eFaceTarget,
	            						 mip,
	            						 iWebGLFormat,
	            						 iWidth, iHeight,
                         				 0,
	                         			 iWebGLFormat,
	                        			 iWebGLDataType,
	                        			 pScaled.data);

	            if (mip !== 0) {
	                pScaled.data = null;
	            }

	            if (iWidth > 1) {
	                iWidth = iWidth / 2;
	            }

	            if (iHeight > 1) {
	                iHeight = iHeight / 2;
	            }

	            var iSizeInBytes:  number  = pixelUtil.getMemorySize(iWidth, iHeight, 1, pData.format);
	            pScaled = new pixelUtil.PixelBox(iWidth, iHeight, 1, pData.format);
	            pScaled.data = new Uint8Array(iSizeInBytes);
	            pData.scale(pScaled, EFilters.LINEAR);
        	}

// Delete the scaled data for the last level

	        if (iLevel > 0) {
	            pScaled.data = null;
	        }
		}

		_bindToFramebuffer(iAttachment:  number , iZOffset:  number ): void {
			logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 335 ); logger.assert(iZOffset < this._iDepth); ;
			var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
			pWebGLContext.framebufferTexture2D( 0x8D40 , iAttachment, this._eFaceTarget, this._pWebGLTexture, this._iLevel);
		}

		_copyFromFramebuffer(iZOffset:  number ): void {
			var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);
			pWebGLContext.copyTexSubImage2D(this._eFaceTarget, this._iLevel, 0, 0, 0, 0, this._iWidth, this._iHeight);
		}

		/**@inline*/  _getTarget():  number  {
			return this._eTarget;
		}

		/**@inline*/  _getWebGLTexture(): WebGLTexture {
			return this._pWebGLTexture;
		}

		blit(pSource: IPixelBuffer): bool;
		blit(pSource: IPixelBuffer, pSrcBox: IBox, pDestBox: IBox): bool;
		blit(pSource: IPixelBuffer, pSrcBox?: IBox, pDestBox?: IBox): bool {
			if (arguments.length == 1) {
				return this.blit(pSource,
		            new geometry.Box(0, 0, 0, pSource.width, pSource.height, pSource.depth),
		            new geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth)
		        );
			}
			else {
				var pSourceTexture: WebGLTextureBuffer = <WebGLTextureBuffer>pSource;
// TODO: Check for FBO support first
// Destination texture must be 2D or Cube
// Source texture must be 2D
				if (! (((pSourceTexture.getFlags()) & (ETextureFlags.RENDERTARGET)) != 0)  &&
					pSourceTexture._getTarget() ===  0x0DE1 ) {

					return this.blitFromTexture(pSourceTexture, pSrcBox, pDestBox);
				}
				else {
					return super.blit(pSource, pSrcBox, pDestBox);
				}
			}
		}

//-----------------------------------------------------------------------------  
// Very fast texture-to-texture blitter and hardware bi/trilinear scaling implementation using FBO
// Destination texture must be 1D, 2D, 3D, or Cube
// Source texture must be 1D, 2D or 3D
// Supports compressed formats as both source and destination format, it will use the hardware DXT compressor
// if available.
	    blitFromTexture(pSource: WebGLTextureBuffer, pSrcBox: IBox, pDestBox: IBox): bool {
	    	var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			pWebGLRenderer._disableTextureUnitsFrom(0);
			pWebGLRenderer.activateWebGLTexture( 0x84C0 );

// Disable alpha, depth and scissor testing, disable blending, 
// and disable culling
        	pWebGLContext.disable( 0x0B71 );
	        pWebGLContext.disable( 0x0C11 );
	        pWebGLContext.disable( 0x0BE2 );
	        pWebGLContext.disable( 0x0B44 );

// Set up source texture
        	pWebGLRenderer.bindWebGLTexture(pSource._getTarget(), pSource._getWebGLTexture());

// Set filtering modes depending on the dimensions and source
	        if(pSrcBox.width === pDestBox.width &&
	           pSrcBox.height === pDestBox.height &&
	           pSrcBox.depth === pDestBox.depth) {
// Dimensions match -- use nearest filtering (fastest and pixel correct)
	            pWebGLContext.texParameteri(pSource._getTarget(),  0x2801 ,  0x2600 );
	            pWebGLContext.texParameteri(pSource._getTarget(),  0x2800 ,  0x2600 );
	        }
	        else {
// Dimensions don't match -- use bi or trilinear filtering depending on the
// source texture.
	            if( (((pSource.getFlags()) & (ETextureFlags.AUTOMIPMAP)) != 0) ) {
// Automatic mipmaps, we can safely use trilinear filter which
// brings greatly improved quality for minimisation.
	                pWebGLContext.texParameteri(pSource._getTarget(),  0x2801 ,  0x2703 );
	                pWebGLContext.texParameteri(pSource._getTarget(),  0x2800 ,  0x2601 );
	            }
	            else {
// Manual mipmaps, stay safe with bilinear filtering so that no
// intermipmap leakage occurs.
	                pWebGLContext.texParameteri(pSource._getTarget(),  0x2801 ,  0x2601 );
	                pWebGLContext.texParameteri(pSource._getTarget(),  0x2800 ,  0x2601 );
	            }
	        }
// Clamp to edge (fastest)
	        pWebGLContext.texParameteri(pSource._getTarget(),  0x2802 ,  0x812F );
	        pWebGLContext.texParameteri(pSource._getTarget(),  0x2803 ,  0x812F );

//Store old binding so it can be restored later
	        var pOldFramebuffer: WebGLFramebuffer = pWebGLContext.getParameter( 0x8CA6 );

	        var pFramebuffer: WebGLFramebuffer = pWebGLRenderer.createWebGLFramebuffer();
	        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pFramebuffer);

	        var pTempWebGLTexture: WebGLTexture = null;

	        if(!webgl.checkFBOAttachmentFormat(this._eFormat) || pSource === this){
// If target format not directly supported, create intermediate texture
	        	var iGLTempFormat:  number  = webgl.getClosestWebGLInternalFormat(webgl.getSupportedAlternative(this._eFormat));

	        	pTempWebGLTexture = pWebGLRenderer.createWebGLTexture();
	        	pWebGLRenderer.bindWebGLTexture( 0x0DE1 , pTempWebGLTexture);
// Allocate temporary texture of the size of the destination area
	        	pWebGLContext.texImage2D( 0x0DE1 , 0, iGLTempFormat,
                         				 math.ceilingPowerOfTwo(pDestBox.width),
                         				 math.ceilingPowerOfTwo(pDestBox.height),
             				             0,  0x1908 ,  0x1401 , null);

	        	pWebGLContext.framebufferTexture2D( 0x8D40 ,  0x8CE0 ,
                                      			   0x0DE1 , pTempWebGLTexture, 0);
// Set viewport to size of destination slice
	        	pWebGLContext.viewport(0, 0, pDestBox.width, pDestBox.height);
	        }
	        else {
// We are going to bind directly, so set viewport to size and position of destination slice
	        	pWebGLContext.viewport(pDestBox.left, pDestBox.top, pDestBox.width, pDestBox.height);
	        }

//Get WebGL program
	        var pWebGLShaderProgram: WebGLShaderProgram = <WebGLShaderProgram>this.getManager().shaderProgramPool.findResource("WEBGL_blit_texture_buffer");
	        pWebGLRenderer.disableAllWebGLVertexAttribs();
	        pWebGLRenderer.useWebGLProgram(pWebGLShaderProgram);

	        var iPosAttrIndex:  number  = 0;
	        var iTexAttrIndex:  number  = 0;

	        iPosAttrIndex = pWebGLShaderProgram.getWebGLAttributeLocation("POSITION");
	        iTexAttrIndex = pWebGLShaderProgram.getWebGLAttributeLocation("TEXCOORD");

	        pWebGLContext.enableVertexAttribArray(iPosAttrIndex);
	        pWebGLContext.enableVertexAttribArray(iTexAttrIndex);

	        var pSquareVertices: Float32Array = new Float32Array([ -1.0, -1.0,
											                		1.0, -1.0,
											               		   -1.0,  1.0,
											                		1.0,  1.0 ]);
	        var pTexCoords: Float32Array = new Float32Array(12);

	        var pPositionBuffer: WebGLBuffer = pWebGLRenderer.createWebGLBuffer();
	        var pTexCoordsBuffer: WebGLBuffer = pWebGLRenderer.createWebGLBuffer();

	        pWebGLRenderer.bindWebGLBuffer( 0x8892 , pPositionBuffer);
	        pWebGLContext.bufferData( 0x8892 , pSquareVertices,  0x88E0 );
            pWebGLContext.vertexAttribPointer(iPosAttrIndex, 2,  0x1406 , false, 0, 0);

            pWebGLShaderProgram.setInt("uSampler", 0);

// Process each destination slice
	        var iSlice:  number  = 0;
	        for(iSlice = pDestBox.front; iSlice < pDestBox.back; ++iSlice) {
	            if(isNull(pTempWebGLTexture)) {
// Bind directly
	                this._bindToFramebuffer( 0x8CE0 , iSlice);
	            }

/// Calculate source texture coordinates
	            var u1:  number  = < number >pSrcBox.left / < number >pSource.width;
	            var v1:  number  = < number >pSrcBox.top / < number >pSource.height;
	            var u2:  number  = < number >pSrcBox.right / < number >pSource.width;
	            var v2:  number  = < number >pSrcBox.bottom / < number >pSource.height;
/// Calculate source slice for this destination slice
	            var w:  number  = < number >(iSlice - pDestBox.front) / < number >pDestBox.depth;
/// Get slice # in source
	            w = w * < number >pSrcBox.depth + pSrcBox.front;
/// Normalise to texture coordinate in 0.0 .. 1.0
	            w = (w + 0.5) / < number >pSource.depth;

	            pTexCoords[0] = u1;
	            pTexCoords[1] = v1;
	            pTexCoords[2] = w;

	            pTexCoords[3] = u2;
	            pTexCoords[4] = v1;
	            pTexCoords[5] = w;

	            pTexCoords[6] = u2;
	            pTexCoords[7] = v2;
	            pTexCoords[8] = w;

  	            pTexCoords[9]  = u1;
	            pTexCoords[10] = v2;
	            pTexCoords[11] = w;

/// Finally we're ready to rumble	
	            pWebGLRenderer.bindWebGLTexture(pSource._getTarget(), pSource._getWebGLTexture());

	            pWebGLContext.enable(pSource._getTarget());

	            pWebGLRenderer.bindWebGLBuffer( 0x8892 , pTexCoordsBuffer);
		        pWebGLContext.bufferData( 0x8892 , pTexCoords,  0x88E0 );
	            pWebGLContext.vertexAttribPointer(iTexAttrIndex, 3,  0x1406 , false, 0, 0);

	            pWebGLContext.drawArrays( 0x0005 , 0, 4);
	            pWebGLContext.disable(pSource._getTarget());


	            if(!isNull(pTempWebGLTexture)) {
	            	if(pSource === this) {
//set width, height and _pWebGLTexture
	            		pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);

	            		this._pWebGLTexture = pTempWebGLTexture;
	            		this._iWidth = math.ceilingPowerOfTwo(pDestBox.width);
	            		this._iHeight = math.ceilingPowerOfTwo(pDestBox.height);
	            	}
	            	else {
// Copy temporary texture
		                pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);

		                switch(this._eTarget) {
		                    case  0x0DE1 :
		                    case  0x8513 :
		                        pWebGLContext.copyTexSubImage2D(this._eFaceTarget, this._iLevel,
		                                            			pDestBox.left, pDestBox.top,
		                                           				0, 0, pDestBox.width, pDestBox.height);
		                        break;
		                }
	            	}
	            }
	        }

	        pWebGLContext.disableVertexAttribArray(iPosAttrIndex);
	        pWebGLContext.disableVertexAttribArray(iTexAttrIndex);

	        pWebGLRenderer.deleteWebGLBuffer(pPositionBuffer);
	        pWebGLRenderer.deleteWebGLBuffer(pTexCoordsBuffer);

// Finish up 
	        if(!isNull(pTempWebGLTexture)) {
// Generate mipmaps
	            if( (((this._iFlags) & (ETextureFlags.AUTOMIPMAP)) != 0) ) {
	                pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);
	                pWebGLContext.generateMipmap(this._eTarget);
	            }
	        }

// Reset source texture to sane state
	        pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);

// Detach texture from temporary framebuffer
	        pWebGLContext.framebufferRenderbuffer( 0x8D40 ,  0x8CE0 ,
	                                  			  0x8D41 , null);
// Restore old framebuffer
	        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pOldFramebuffer);
	        if(pSource !== this) {
	        	pWebGLRenderer.deleteWebGLTexture(pTempWebGLTexture);
	    	}
	        pWebGLRenderer.deleteWebGLFramebuffer(pFramebuffer);

	        pTempWebGLTexture = null;
	        this.notifyAltered();

	    	return true;
	    }

		blitFromMemory(pSource: IPixelBox): bool;
		blitFromMemory(pSource: IPixelBox, pDestBox?: IBox): bool;
		blitFromMemory(): bool {
			if(arguments.length === 1){
				return super.blitFromMemory(arguments[0]);
			}

// Fall back to normal GLHardwarePixelBuffer::blitFromMemory in case 
// - FBO is not supported
// - Either source or target is luminance due doesn't looks like supported by hardware
// - the source dimensions match the destination ones, in which case no scaling is needed
// TODO: Check that extension is NOT available

			var pSourceOrigin: IPixelBox = arguments[0];
			var pDestBox: IBox = arguments[1];

			if(pixelUtil.isLuminance(pSourceOrigin.format) ||
	           pixelUtil.isLuminance(this._eFormat) ||
	           (pSourceOrigin.width === pDestBox.width &&
	            pSourceOrigin.height === pDestBox.height &&
	            pSourceOrigin.depth === pDestBox.depth)) {

	            return super.blitFromMemory(pSourceOrigin, pDestBox);
	        }

	        if(!this._pBuffer.contains(pDestBox)) {
	            logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 626 ); logger.criticalError("Destination box out of range"); ;
	        }

		    var pSource: IPixelBox;
// First, convert the srcbox to a OpenGL compatible pixel format
	        if(getWebGLOriginFormat(pSourceOrigin.format) === 0){
// Convert to buffer internal format
	        	var iSizeInBytes:  number  = pixelUtil.getMemorySize(pSourceOrigin.width, pSourceOrigin.height,
	        													pSourceOrigin.depth, this._eFormat);
	        	pSource = new pixelUtil.PixelBox(pSourceOrigin.width, pSourceOrigin.height,
	        									 pSourceOrigin.depth, this._eFormat, new Uint8Array(iSizeInBytes));

	        	pixelUtil.bulkPixelConversion(pSourceOrigin, pSource);
	        }
	        else {
// No conversion needed
	        	pSource = pSourceOrigin;
	        }

	        var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

// Create temporary texture to store source data
	        var pTempWebGLTexture: WebGLTexture = null;
	        var eTarget:  number  =  0x0DE1 ;
	        var iWidth:  number  = math.ceilingPowerOfTwo(pSource.width);
	        var iHeight:  number  = math.ceilingPowerOfTwo(pSource.height);
	        var iWebGLFormat: number  = getClosestWebGLInternalFormat(pSource.format);
	        var iWebGLDataType:  number  = getWebGLOriginDataType(pSource.format);

	        pTempWebGLTexture = pWebGLRenderer.createWebGLTexture();

	        if(isNull(pTempWebGLTexture)){
	        	logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 659 ); logger.error("Can not create WebGL texture"); ;
	        	return false;
	        }

	        pWebGLRenderer.bindWebGLTexture(eTarget, pTempWebGLTexture);
	        pWebGLContext.texImage2D(eTarget, 0, iWebGLFormat, iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, null);

	        var pTextureBufferPool: IResourcePool = this.getManager().textureBufferPool;
	        var pTempTexBuffer: WebGLTextureBuffer = <WebGLTextureBuffer>pTextureBufferPool.createResource(".temp");

	        pTempTexBuffer.create(eTarget, pTempWebGLTexture, iWidth, iHeight,
								  iWebGLFormat, pSource.format, 0, 0,
								  ETextureFlags.AUTOMIPMAP | EHardwareBufferFlags.STATIC,
								  false);

// Upload data to 0,0,0 in temporary texture
	        var pTempBoxTarget: IBox = new geometry.Box(0, 0, 0, pSource.width, pSource.height, pSource.depth);
	        pTempTexBuffer.upload(pSource, pTempBoxTarget);

//Blit
	        this.blitFromTexture(pTempTexBuffer, pTempBoxTarget, pDestBox);

//Delete temp data
	        pTextureBufferPool.destroyResource(pTempTexBuffer);

	        pWebGLRenderer.deleteWebGLTexture(pTempWebGLTexture);
	        pTempWebGLTexture = null;
	        pTempBoxTarget = null;

			return true;
		}

		getRenderTarget(): IRenderTarget;
		getRenderTarget(iZOffest:  number ): IRenderTarget;
		getRenderTarget(iZOffest?:  number  = 0): IRenderTarget {
			logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 694 ); logger.assert( (((this._iFlags) & (ETextureFlags.RENDERTARGET)) != 0) ); ;
        	logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 695 ); logger.assert(iZOffest < this._iDepth); ;
        	return this._pRTTList[iZOffest];
		}

		resize(iSize:  number ): bool;
		resize(iWidth:  number , iHeight?:  number ): bool {
			if(arguments.length === 1){
				logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 702 ); logger.criticalError("resize with one parametr not available for WebGLTextureBuffer"); ;
				return false;
			}
			var pSrcBox: IBox = new geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
			var pDestBox: IBox = new geometry.Box(0, 0, 0, iWidth, iHeight, this._iDepth);

			return this.blitFromTexture(this, pSrcBox, pDestBox);
		}

	}
}





module akra.webgl {
	export class WebGLInternalTexture extends core.pool.resources.Texture {
		private _pSurfaceList: WebGLTextureBuffer[] = null;
		private _pWebGLTexture: WebGLTexture = null;

		constructor () {
            super();
        }

        getWebGLTextureTarget():  number  {
        	switch(this._eTextureType) {
        		case ETextureTypes.TEXTURE:
        		case ETextureTypes.TEXTURE_2D:
        			return  0x0DE1 ;
        		case ETextureTypes.TEXTURE_CUBE_MAP:
        			return  0x8513 ;
        		default:
        			return 0;
        	}
        }

        /**@protected*/  createInternalTextureImpl(cFillColor?: IColor = null): bool {
        	if(!isNull(cFillColor)){
        		logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 36 ); logger.warning("Texture can create with filled only by default(black) color"); ;
//TODO: must implement filling by color
        	}

        	var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

// Convert to nearest power-of-two size if required
	        this._iWidth = math.ceilingPowerOfTwo(this._iWidth);
	        this._iHeight = math.ceilingPowerOfTwo(this._iHeight);
	        this._iDepth = math.ceilingPowerOfTwo(this._iDepth);

// Adjust format if required
	        this._eFormat = this.getNativeFormat(this._eTextureType, this._eFormat, this._iFlags);

// Check requested number of mipmaps
	        var nMaxMips = webgl.getMaxMipmaps(this._iWidth, this._iHeight, this._iDepth, this._eFormat);

	        if(pixelUtil.isCompressed(this._eFormat) && (this._nMipLevels === 0)){
	            this._nRequestedMipLevels = 0;
	        }

	        this._nMipLevels = this._nRequestedMipLevels;

	        if (this._nMipLevels > nMaxMips) {
	            this._nMipLevels = nMaxMips;
	        }

	        var iWebGLTarget:  number  = this.getWebGLTextureTarget();

	        this._pWebGLTexture = pWebGLRenderer.createWebGLTexture();
	        pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);

	        this._isMipmapsHardwareGenerated = pWebGLRenderer.hasCapability(ERenderCapabilities.AUTOMIPMAP);

// Set some misc default parameters, these can of course be changed later
	        pWebGLContext.texParameteri(iWebGLTarget,
	                        0x2801 ,  0x2600 );
	        pWebGLContext.texParameteri(iWebGLTarget,
	                        0x2800 ,  0x2600 );
	        pWebGLContext.texParameteri(iWebGLTarget,
	                        0x2802 ,  0x812F );
	        pWebGLContext.texParameteri(iWebGLTarget,
	                        0x2803 ,  0x812F );

	        var iWebGLFormat:  number  = webgl.getClosestWebGLInternalFormat(this._eFormat);
	        var iWebGLDataType:  number  = webgl.getWebGLOriginDataType(this._eFormat);
	        var iWidth:  number  = this._iWidth;
	        var iHeight:  number  = this._iHeight;
	        var iDepth:  number  = this._iDepth;

	        if (pixelUtil.isCompressed(this._eFormat)) {
// Compressed formats
	            var iSize:  number  = pixelUtil.getMemorySize(iWidth, iHeight, iDepth, this._eFormat);

// Provide temporary buffer filled with zeroes as glCompressedTexImageXD does not
// accept a 0 pointer like normal glTexImageXD
// Run through this process for every mipmap to pregenerate mipmap pyramid

//TODO: можем мы можем подать просто null, надо проверить
	            var pTmpData: Uint8Array = new Uint8Array(iSize);
	            var pEmptyData: Uint8Array;
	            var mip:  number  = 0;

	            for (mip = 0; mip <= this._nMipLevels; mip++) {
	                iSize = pixelUtil.getMemorySize(iWidth, iHeight, iDepth, this._eFormat);

	                pEmptyData = pTmpData.subarray(0, iSize);

					switch(this._eTextureType){
						case ETextureTypes.TEXTURE:
						case ETextureTypes.TEXTURE_2D:
	                        pWebGLContext.compressedTexImage2D( 0x0DE1 , mip, iWebGLFormat,
	                        								   iWidth, iHeight, 0, pTmpData);
	                        break;
						case ETextureTypes.TEXTURE_CUBE_MAP:
							var iFace:  number  = 0;
							for(iFace = 0; iFace < 6; iFace++) {
								pWebGLContext.compressedTexImage2D( 0x8515  + iFace, mip, iWebGLFormat,
																   iWidth, iHeight, 0, pTmpData);
							}
							break;
	                    default:
	                        break;
	                };

	                if(iWidth > 1) iWidth = iWidth / 2;
	                if(iHeight > 1) iHeight = iHeight / 2;
	                if(iDepth > 1) iDepth = iDepth / 2;

	            }
	            pTmpData = null;
	            pEmptyData = null;
	        }
	        else {
	        	var mip:  number  = 0;
// Run through this process to pregenerate mipmap pyramid
	            for (mip = 0; mip <= this._nMipLevels; mip++) {
// Normal formats
					switch(this._eTextureType){
						case ETextureTypes.TEXTURE:
						case ETextureTypes.TEXTURE_2D:
	                        pWebGLContext.texImage2D( 0x0DE1 , mip, iWebGLFormat,
	                                     			 iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, null);
	                        break;
						case ETextureTypes.TEXTURE_CUBE_MAP:
							var iFace:  number  = 0;
							for(iFace = 0; iFace < 6; iFace++) {
								pWebGLContext.texImage2D( 0x8515  + iFace, mip, iWebGLFormat,
	                                     			 	 iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, null);
							}
							break;
	                    default:
	                        break;
	                }

	                if(iWidth > 1) iWidth = iWidth / 2;
	                if(iHeight > 1) iHeight = iHeight / 2;
	                if(iDepth > 1) iDepth = iDepth / 2;
	            }
	        }

	        this._createSurfaceList();

// Get final internal format
        	this._eFormat = this.getBuffer(0,0).format;

            return false;
        }

        /**@protected*/  freeInternalTextureImpl(): bool {
        	var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);
			this._pWebGLTexture = null;

			for(var i:  number  = 0; i < this._pSurfaceList.length; i++) {
				this._pSurfaceList[i].release();
			}

			this._pSurfaceList = null;

            return true;
        }

        _createSurfaceList(): void {
        	this._pSurfaceList = new Array();

// For all faces and mipmaps, store surfaces as IPixelBuffer
        	var bWantGeneratedMips: bool =  (((this._iFlags) & (ETextureFlags.AUTOMIPMAP)) != 0) ;

// Do mipmapping in software? (uses GLU) For some cards, this is still needed. Of course,
// only when mipmap generation is desired.
        	var bDoSoftware: bool = bWantGeneratedMips && !this._isMipmapsHardwareGenerated && this._nMipLevels !== 0;

        	var iFace:  number  = 0;
        	var mip:  number  = 0;
        	var pTextureBufferPool: IResourcePool = this.getManager().textureBufferPool;
        	var sResourceName: string = this.findResourceName();

        	for(iFace = 0; iFace < this._nMipLevels; iFace++) {
        		var iWidth:  number  = this._iWidth;
        		var iHeight:  number  = this._iHeight;

        		for(mip = 0; mip <= this._nMipLevels; mip++) {
        			var pBuf: WebGLTextureBuffer = <WebGLTextureBuffer>pTextureBufferPool.createResource(sResourceName + "_" + iFace + "_" + mip);
        			pBuf.create(this.getWebGLTextureTarget(),
        						this._pWebGLTexture,
        						iWidth, iHeight,
        						webgl.getClosestWebGLInternalFormat(this._eFormat),
        						webgl.getWebGLOriginDataType(this._eFormat),
        						iFace,
        						mip,
        						this._iFlags,
        						bDoSoftware && mip === 0);

        			this._pSurfaceList.push(pBuf);

//check error
        			if(pBuf.width === 0 ||
        			   pBuf.height === 0 ||
        			   pBuf.depth === 0) {
        				logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 222 ); logger.criticalError("Zero sized texture surface on texture " + sResourceName + " face " + iFace + " mipmap " + mip + ". The GL driver probably refused to create the texture.");
                                                                                        ;
        			}

        		}
        	}
        }

        getBuffer(iFace?:  number  = 1, iMipmap?:  number  = 0): IPixelBuffer {
            if (iFace >= this.getNumFaces()) {
	            logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 231 ); logger.criticalError("Face index out of range"); ;
	        }

	        if (iMipmap > this._nMipLevels) {
	            logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 235 ); logger.criticalError("Mipmap index out of range"); ;
	        }

	        var idx:  number  = iFace * (this._nMipLevels + 1) + iMipmap;
	        logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 239 ); logger.assert(idx < this._pSurfaceList.length); ;

	        return this._pSurfaceList[idx];
        }



        getNativeFormat(eTextureType?: ETextureTypes = this._eTextureType,
                        eFormat?: EPixelFormats = this._eFormat,
                        iFlags?:  number  = this._iFlags): EPixelFormats {

        	var pRenderer: IRenderer = this.getManager().getEngine().getRenderer();

			if (pixelUtil.isCompressed(eFormat) &&
            	!pRenderer.hasCapability(ERenderCapabilities.TEXTURE_COMPRESSION_DXT) &&
            	!pRenderer.hasCapability(ERenderCapabilities.TEXTURE_COMPRESSION_PVRTC)) {

	            return EPixelFormats.A8R8G8B8;
	        }
// if floating point textures not supported, revert to PF_A8R8G8B8
	        if (pixelUtil.isFloatingPoint(eFormat) &&
	            pRenderer.hasCapability(ERenderCapabilities.TEXTURE_FLOAT)) {

	            return EPixelFormats.A8R8G8B8;
	        }

// Check if this is a valid rendertarget format
	        if ( (((iFlags) & (ETextureFlags.RENDERTARGET)) != 0) ) {
/// Get closest supported alternative
/// If mFormat is supported it's returned
	            return webgl.getSupportedAlternative(eFormat);
	        }

// Supported
	        return eFormat;
        }

        createRenderTexture(): bool {
// Create the GL texture
// This already does everything necessary
            return this.createInternalTexture();
        }

	}
}


































module akra {
	export interface IBufferDataModifier {
		(pData: ArrayBufferView): void;
	}
}







module akra.data {

	enum EVertexDataLimits {
		k_MaxElementsSize = 256
	};

	export class VertexData implements IVertexData {
		private _pVertexBuffer: IVertexBuffer;
		private _iOffset:  number ;
		private _iStride:  number ;
		private _iLength:  number ;
		private _pVertexDeclaration: IVertexDeclaration;
		private _iId:  number ;

		/**@inline*/  get id():  number  { return this._iId; }
		/**@inline*/  get length():  number  { return this._iLength; };
		/**@inline*/  get byteOffset():  number  { return this._iOffset; };
		/**@inline*/  get byteLength():  number  { return this._iLength * this._iStride; };
		/**@inline*/  get buffer(): IVertexBuffer { return this._pVertexBuffer; };
		/**@inline*/  get stride():  number  { return this._iStride; };
		/**@inline*/  get startIndex():  number  {
			var iIndex:  number  = this.byteOffset / this.stride;
    		logger.setSourceLocation( "data/VertexData.ts" , 34 ); logger.assert(iIndex % 1 == 0, "cannot calc first element index"); ;
   			return iIndex;
   		};


		constructor (pVertexBuffer: IVertexBuffer, id:  number , iOffset:  number , iCount:  number , nSize:  number );
		constructor (pVertexBuffer: IVertexBuffer, id:  number , iOffset:  number , iCount:  number , pDecl: IVertexDeclaration);
		constructor (pVertexBuffer: IVertexBuffer, id:  number , iOffset:  number , iCount:  number , pDecl: any) {

			this._pVertexBuffer = pVertexBuffer;
			this._iOffset = iOffset;
			this._iLength = iCount;
			this._iId = id;
			this._pVertexDeclaration = null;
			this._iStride = 0;

			if (isInt(pDecl)) {
				this._iStride = < number >pDecl;
			}
			else {
				this.setVertexDeclaration(pDecl);
			}

			logger.setSourceLocation( "data/VertexData.ts" , 58 ); logger.assert(pVertexBuffer.byteLength >= this.byteLength + this.byteOffset, "vertex data out of array linits");
                                      ;
		}


		getVertexDeclaration(): IVertexDeclaration {
			return this._pVertexDeclaration;
		}

		setVertexDeclaration(pDecl: IVertexDeclaration): bool {
			if (this._pVertexDeclaration) {
				logger.setSourceLocation( "data/VertexData.ts" , 68 ); logger.error("vertex declaration already exists"); ;

				return false;
			}

			var iStride:  number  = pDecl.stride;

		    this._pVertexDeclaration = pDecl.clone();


		    logger.setSourceLocation( "data/VertexData.ts" , 79 ); logger.assert(iStride < <number>EVertexDataLimits.k_MaxElementsSize, "stride max is 255 bytes");
                                 ;
		    logger.setSourceLocation( "data/VertexData.ts" , 81 ); logger.assert(iStride <= this.stride, "stride in VertexDeclaration grather than stride in construtor");
                                                                       ;

		    return true;
		}

		/**@inline*/  getVertexElementCount():  number  {
			return this._pVertexDeclaration.length;
		}

		hasSemantics(sUsage: string): bool {
			if (this._pVertexDeclaration != null) {
		        return this._pVertexDeclaration.hasSemantics(sUsage);
		    }

		    return false;
		}

		destroy(): void {
			this._pVertexDeclaration = null;
    		this._iLength = 0;
		}

		extend(pDecl: IVertexDeclaration, pData: ArrayBufferView = null): bool {
			pDecl = createVertexDeclaration(pDecl);

			if (isNull(pData)) {
				pData = new Uint8Array(this.length * pDecl.stride);
			}
			else {
				pData = new Uint8Array(pData.buffer);
			}

		    logger.setSourceLocation( "data/VertexData.ts" , 113 ); logger.assert(this.length === pData.byteLength / pDecl.stride, 'invalid data size for extending'); ;

		    var nCount:  number  = this._iLength;
//strides modifications
		    var nStrideNew:  number  = pDecl.stride;
		    var nStridePrev:  number  = this.stride;
		    var nStrideNext:  number  = nStridePrev + nStrideNew;
//total bytes after extending
		    var nTotalSize:  number  = nStrideNext * this.length;
		    var pDeclNew: IVertexDeclaration = this.getVertexDeclaration().clone();

//data migration
		    var pDataPrev: Uint8Array = new Uint8Array(<ArrayBuffer>this.getData());
		    var pDataNext: Uint8Array = new Uint8Array(nTotalSize);

		    for (var i:  number  = 0, iOffset:  number ; i < nCount; ++i) {
		        iOffset = i * nStrideNext;
		        pDataNext.set(pDataPrev.subarray(i * nStridePrev, (i + 1) * nStridePrev), iOffset);
		        pDataNext.set((<Uint8Array>pData).subarray(i * nStrideNew, (i + 1) * nStrideNew), iOffset + nStridePrev);
		    }

		    if (!pDeclNew.extend(pDecl)) {
		        return false;
		    }

		    if (!this.resize(nCount, pDeclNew)) {
		        return false;
		    }

		    return this.setData(pDataNext, 0, nStrideNext);
		}


		resize(nCount:  number , pDecl?: IVertexDeclaration): bool;
		resize(nCount:  number , iStride?:  number ): bool;
		resize(nCount:  number , pDecl?: any) {
			var iStride:  number  = 0;
		    var iOldOffset:  number  = this.byteOffset;
		    var pOldVertexBuffer: IVertexBuffer;
		    var pOldVertexDeclaration: IVertexDeclaration;
		    var iOldStride:  number

		    if (arguments.length == 2) {
		        if (isInt(pDecl)) {
		            iStride = < number >pDecl;
		        }
		        else {
		            iStride = (<IVertexDeclaration>pDecl).stride;
		        }

		        if (nCount * iStride <= this.byteLength) {
		            this._iLength = nCount;
		            this._iStride = iStride;
		            this._pVertexDeclaration = null;

		            if (!isInt(pDecl)) {
		                this.setVertexDeclaration(pDecl);
		            }

		            return true;
		        }
		        else {
		            pOldVertexBuffer = this.buffer;

		            pOldVertexBuffer.freeVertexData(this);

		            if (pOldVertexBuffer.getEmptyVertexData(nCount, pDecl, this) !== this) {
		                return false;
		            }

		            if (this.byteOffset != iOldOffset) {
		                logger.setSourceLocation( "data/VertexData.ts" , 184 ); logger.warning("vertex data moved from " + iOldOffset + " ---> " + this.byteOffset); ;
		                this.relocation(this, iOldOffset, this.byteOffset);
		            }

		            return true;
		        }
		    }
		    else if (arguments.length == 1) {
		        if (nCount <= this.length) {
		            this._iLength = nCount;
		            return true;
		        }
		        else {
		            pOldVertexBuffer = this.buffer;
		            pOldVertexDeclaration = this.getVertexDeclaration();
		            iOldStride = this.stride;

		            pOldVertexBuffer.freeVertexData(this);

		            if (pOldVertexBuffer.getEmptyVertexData(nCount, iOldStride, this) == null) {
		                return false;
		            }

		            this.setVertexDeclaration(pOldVertexDeclaration);

		            if (this.byteOffset != iOldOffset) {
		                logger.setSourceLocation( "data/VertexData.ts" , 210 ); logger.warning("vertex data moved from " + iOldOffset + " ---> " + this.byteOffset); ;
		                this.relocation(this, iOldOffset, this.byteOffset);
		            }

		            return true;
		        }
		    }

		    return false;
		}

		applyModifier(sUsage: string, fnModifier: IBufferDataModifier): bool {
			var pData = this.getTypedData(sUsage);
		    fnModifier(pData);
		    return this.setData(pData, sUsage);
		}

		setData(pData: ArrayBufferView, iOffset:  number , iSize?:  number , nCountStart?:  number , nCount?:  number ): bool;
		setData(pData: ArrayBufferView, sUsage?: string, iSize?:  number , nCountStart?:  number , nCount?:  number ): bool;
		setData(pData: ArrayBufferView, iOffset?: any, iSize?:  number , nCountStart?:  number , nCount?:  number ): bool {
			var iStride:  number ;
			var pVertexBuffer: IVertexBuffer = this._pVertexBuffer;
			var pBackupBuf: Uint8Array;
			var pDataU8: Uint8Array;
			var k:  number ;
			var iOffsetBuffer:  number ;
			var pDeclaration: IVertexDeclaration = this._pVertexDeclaration;
			var pElement: IVertexElement;

			switch (arguments.length) {
		        case 5:
		            iStride = this.stride;
		            pDataU8 = new Uint8Array(pData.buffer);
		            if (iStride != iSize) {
//FIXME: очень тормознутое место, крайне медленно работает...
						if(pVertexBuffer.isBackupPresent() && nCount > 1) {
							pBackupBuf = new Uint8Array(this._pVertexBuffer.byteLength);
							this._pVertexBuffer.readData(pBackupBuf);

							iOffsetBuffer = this.byteOffset;

							for (var i = nCountStart; i < nCount + nCountStart; i++) {
								for(k = 0; k < iSize; k++) {
									pBackupBuf[iStride * i + iOffset + iOffsetBuffer + k] =
										pDataU8[iSize * (i - nCountStart) + k];
								}
							}

							pVertexBuffer.writeData(pBackupBuf, 0, pVertexBuffer.byteLength);
						}
						else {
							for (var i:  number  = nCountStart; i < nCount + nCountStart; i++) {
								pVertexBuffer.writeData(
/*pData.buffer.slice*/
										                      pDataU8.subarray(
											iSize * (i - nCountStart),
											iSize * (i - nCountStart) + iSize),
										iStride * i + iOffset + this.byteOffset,
										iSize);
							}
						}
		            }
		            else {
		                pVertexBuffer.writeData(
/*pData.buffer.slice*/

		                	pDataU8.subarray(0, iStride * nCount),
		                	iOffset + this.byteOffset,
		                    iStride * nCount);
		            }
		            return true;
		        case 4:
		            pElement = null;

		            if (isString(arguments[1])) {
		                pElement = pDeclaration.findElement(arguments[1]);

		                if (pElement) {
		                    return this.setData(
		                        pData,
		                        pElement.offset,
		                        pElement.size,
		                        arguments[2],
		                        arguments[3]);
		                }

		                return false;
		            }

		            nCountStart = nCountStart || 0;

		            if (!nCount) {
		                nCount = pData.byteLength / iSize;
		            }

		            return this.setData(pData, iOffset, iSize, nCountStart, nCount);


		        case 2:
		        case 3:
		            var pDeclaration = this._pVertexDeclaration,
		                pElement = null;

		            if (isString(arguments[1])) {
		                pElement = pDeclaration.findElement(arguments[1]);

		                if (pElement) {
		                    arguments[2] = arguments[2] || 0;

		                    if (!arguments[3]) {
		                        arguments[3] = pData.buffer.byteLength / pElement.size;
		                    }

		                    return this.setData(
		                    	pData,
		                        pElement.offset,
		                        pElement.size,
		                        arguments[2],
		                        arguments[3])
		                }
		                return false
		            }
		            else if (arguments.length === 3) {

		                nCountStart = nCountStart || 0;

		                if (!nCount) {
		                    nCount = pData.byteLength / iSize;
		                }

		                return this.setData(pData, iOffset, iSize, nCountStart, nCount);
		            }

		            return false;
		        case 1:
		            return this.setData(pData, this._pVertexDeclaration[0].eUsage);
		        default:
		            return false;
		    }
		}


		getData(): ArrayBuffer;
		getData(iOffset:  number , iSize:  number , iFrom?:  number , iCount?:  number ): ArrayBuffer;
		getData(sUsage: string): ArrayBuffer;
		getData(sUsage: string, iFrom:  number , iCount:  number ): ArrayBuffer;
		getData(iOffset?: any, iSize?: any, iFrom?: any, iCount?: any): ArrayBuffer {
			switch (arguments.length) {
		        case 4:
		        case 2:
		            if (isString(arguments[0])) {
						return null;
		            }

		            iFrom = iFrom || 0;
		            iCount = iCount || this._iLength;
		            iCount = math.min(iCount, this._iLength);

		            var iStride:  number  = this.stride;
		            var pBufferData: Uint8Array = new Uint8Array(iSize * this.length);

		            for (var i:  number  = iFrom; i < iCount; i++) {
		            	this._pVertexBuffer.readData(iStride * i + iOffset + this.byteOffset, iSize,
		            		pBufferData.subarray(i * iSize, i * iSize + iSize));
//pBufferData.set(new Uint8Array(), i * iSize);
		            }

		            return pBufferData.buffer;
		        case 3:
		        case 1:
		            var pDeclaration: IVertexDeclaration = this._pVertexDeclaration,
		                pElement: IVertexElement = null;

		            if (isString("string")) {
		                pElement = pDeclaration.findElement(arguments[0]);

		                if (pElement) {
		                    return this.getData(
		                        pElement.offset,
		                        pElement.size,
		                        arguments[1],
		                        arguments[2]
		                        )
		                }
		                return null;
		            }

		            return null;

		        case 0:
		            return this.getData(0, this._pVertexDeclaration.stride);
		        default:
		            return null;
		    }
		}

		getTypedData(sUsage: string, iFrom?:  number , iCount?:  number ): ArrayBufferView {
		    sUsage = sUsage || this._pVertexDeclaration[0].sUsage;

		    var pVertexElement: IVertexElement = this._pVertexDeclaration.findElement(sUsage);

		    if (pVertexElement) {
		        return util.abtota(this.getData(sUsage, iFrom, iCount), pVertexElement.type);
		    }

		    return null;
		}

		/**@inline*/  getBufferHandle():  number  {
			return this._pVertexBuffer.resourceHandle;
		}

		toString(): string {
		    if ( DEBUG ) {

			    var s: string = "";

			    s += "          VERTEX DATA  #" + this.id + "\n";
			    s += "---------------+-----------------------\n";
			    s += "        BUFFER : " + this.getBufferHandle() + "\n";
			    s += "          SIZE : " + this.byteLength + " b.\n";
			    s += "        OFFSET : " + this.byteOffset + " b.\n";
			    s += "---------------+-----------------------\n";
			    s += " MEMBERS COUNT : " + this.length + " \n";
			    s += "        STRIDE : " + this.stride + " \n";
			    s += "---------------+-----------------------\n";
			    s += this.getVertexDeclaration().toString();

			    return s;
		    }

		    return null;
		}



		private _iGuid: number = eval("this._iGuid || akra.sid()"); private _pUnicastSlotMap: IEventSlotMap = null; private _pBroadcastSlotList: IEventSlotListMap = null; private static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable {return VertexData._pEventTable; } getGuid(): number {return this._iGuid < 0? (this._iGuid = sid()): this._iGuid; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
			relocation (pTarget, iFrom, iTo): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).relocation; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pTarget, iFrom, iTo) : _broadcast[i].listener (_recivier, pTarget, iFrom, iTo) ; } } } ; ;
		;


// BEGIN_EVENT_TABLE(VertexData);

// relocation(pTarget: IVertexData, iFrom: uint, iTo: uint): void {
// 	EMIT_BROADCAST(relocation, CALL(pTarget, iFrom, iTo));
// }

// END_EVENT_TABLE();
	}

}











module akra.core.pool.resources {
	export class MemoryBuffer extends HardwareBuffer {

		/**@protected*/  _pData: Uint8Array;

		/**@inline*/  get byteLength():  number  {
			return this._pData.byteLength;
		}

		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.DYNAMIC): bool {

			((iFlags) &= ~(EHardwareBufferFlags.BACKUP_COPY | EHardwareBufferFlags.DISCARDABLE | EHardwareBufferFlags.ALIGNMENT))
                                   ;

			var isCreated: bool = super.create(iFlags | EHardwareBufferFlags.SOFTWARE);

			this._pData = new Uint8Array(iByteSize);

			return isCreated;
		}

		destroy(): void {
			super.destroy();
			this._pData = null;
		}

		resize(iSize:  number ): bool {
			var pData: Uint8Array = new Uint8Array(iSize);
			pData.set(this._pData);
			this._pData = pData;
			this.notifyAltered();

			return true;
		}

		lockImpl(iOffset:  number , iLength:  number , iLockFlags:  number ): Uint8Array {
			return this._pData.subarray(iOffset, iOffset + iLength);
		}

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;
		readData(iOffset: any, iSize?: any, ppDest?: any): bool {
			if (arguments.length < 3) {
				ppDest = arguments[0];
				iOffset = 0;
				iSize = ppDest.byteLength;
			}

			logger.setSourceLocation( "MemoryBuffer.ts" , 55 ); logger.assert((iOffset + iSize) <= this.byteLength); ;
			memcpy((<ArrayBufferView>ppDest).buffer, 0, this._pData.buffer, iOffset, iSize);

			return true;
		}

		writeData(pData: Uint8Array, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: ArrayBufferView, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: any, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool {
			logger.setSourceLocation( "MemoryBuffer.ts" , 64 ); logger.assert((iOffset + iSize) <= this.byteLength); ;

			if (arguments.length < 3) {
				iOffset = 0;
				iSize = pData.byteLength;
			}


			memcpy(this._pData.buffer, 0, (<ArrayBufferView>pData).buffer, iOffset, iSize);
			this.notifyAltered();

			return true;
		}
	}
}



module akra.core.pool.resources {
	interface IBufferHole {
		start:  number ;
		end:  number ;
	}

	export class VertexBuffer extends HardwareBuffer implements IVertexBuffer {
		/**@protected*/  _pVertexDataArray: IVertexData[] = [];
		/**@protected*/  _iDataCounter:  number  = 0;

		/**@inline*/  get type(): EVertexBufferTypes { return EVertexBufferTypes.UNKNOWN; }
		/**@inline*/  get length():  number  { return this._pVertexDataArray.length; }

/*pManager: IResourcePoolManager*/
		constructor (                                  ) {
/*pManager*/
			super(            );

		}

		create(iByteSize:  number , iFlags?:  number , pData?: Uint8Array): bool;
		create(iByteSize:  number , iFlags?:  number , pData?: ArrayBufferView): bool;
		create(iByteSize:  number , iFlags?:  number , pData?: any): bool {
			super.create(iFlags || 0);

			if ( (((iFlags) & (EHardwareBufferFlags.BACKUP_COPY)) != 0) ) {
				this._pBackupCopy = new MemoryBuffer();
				this._pBackupCopy.create(iByteSize);
				this._pBackupCopy.writeData(pData, 0, iByteSize);
			}

			return true;
		}

		destroy(): void {
			super.destroy();

			this._pBackupCopy.destroy();
			this.freeVertexData();

			this._iDataCounter = 0;
		}

		getVertexData(i:  number ): IVertexData;
		getVertexData(iOffset:  number , iCount:  number , pElements: IVertexElement[]): IVertexData;
		getVertexData(iOffset:  number , iCount:  number , pDecl: IVertexDeclaration): IVertexData;
		getVertexData(iOffset:  number , iCount?:  number , pData?: any): IVertexData {
			if (arguments.length < 2) {
				return this._pVertexDataArray[< number >arguments[0]];
			}

			var pDecl: IVertexDeclaration = createVertexDeclaration(pData);
			var pVertexData: IVertexData = new data.VertexData(this, this._iDataCounter ++, iOffset, iCount, pDecl);

			this._pVertexDataArray.push(pVertexData);
			this.notifyAltered();

			return pVertexData;
		}


		getEmptyVertexData(iCount:  number , pElements: IVertexElement[], ppVertexDataIn?: IVertexData): IVertexData;
		getEmptyVertexData(iCount:  number , pDecl: IVertexDeclaration, ppVertexDataIn?: IVertexData): IVertexData;
		getEmptyVertexData(iCount:  number , pSize:  number , ppVertexDataIn?: IVertexData): IVertexData;
		getEmptyVertexData(iCount:  number , pDeclData: any, ppVertexDataIn?: IVertexData): IVertexData {
			var pDecl: IVertexDeclaration;
			var pHole: IBufferHole[] = [];
			var i:  number ;
			var pVertexData: IVertexData;
			var iTemp:  number ;
			var iStride:  number  = 0;
			var iAligStart:  number ;

			while(true) {

				pHole[0] = {start:0, end: this.byteLength};

				for(var k:  number  = 0; k < this._pVertexDataArray.length; ++ k) {
					pVertexData = this._pVertexDataArray[k];

					for(i = 0; i < pHole.length; i++) {
//Полностью попадает внутрь
						if(pVertexData.byteOffset > pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength < pHole[i].end) {
							iTemp = pHole[i].end;
							pHole[i].end=pVertexData.byteOffset;
							pHole.splice(i + 1, 0, {start: pVertexData.byteOffset + pVertexData.byteLength, end: iTemp});
							i--;
						}
						else if(pVertexData.byteOffset == pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength < pHole[i].end) {
							pHole[i].start = pVertexData.byteOffset + pVertexData.byteLength;
						}
						else if(pVertexData.byteOffset > pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength == pHole[i].end) {

						}
						else if(pVertexData.byteOffset == pHole[i].start &&
							pVertexData.byteLength == (pHole[i].end - pHole[i].start)) {
							pHole.splice(i, 1);
							i--;
						}
//Перекрывает снизу
						else if(pVertexData.byteOffset < pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength > pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength < pHole[i].end) {
							pHole[i].start = pVertexData.byteOffset + pVertexData.byteLength;
						}
						else if(pVertexData.byteOffset < pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength > pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength == pHole[i].end) {
							pHole.splice(i,1);
							i--;
						}
//Перекрывается сверху
						else if(pVertexData.byteOffset + pVertexData.byteLength > pHole[i].end &&
							pVertexData.byteOffset > pHole[i].start && pVertexData.byteOffset < pHole[i].end) {
							pHole[i].end=pVertexData.byteOffset;
						}
						else if(pVertexData.byteOffset + pVertexData.byteLength > pHole[i].end &&
							pVertexData.byteOffset == pHole[i].start && pVertexData.byteOffset < pHole[i].end) {
							pHole.splice(i,1);
							i--;
						}
//полнстью перекрывает
						else if(pVertexData.byteOffset < pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength > pHole[i].end) {
							i--;
						}
					}
				}


				pHole.sort((a: IBufferHole, b: IBufferHole): number => ((a.end - a.start) - (b.end - b.start)));



				if(isInt(pDeclData)) {
					pDecl = createVertexDeclaration(pDeclData);
					iStride = pDecl.stride;
				}
				else {
					iStride = pDeclData;
				}

				for (i = 0; i < pHole.length; i++) {
					iAligStart = this.isAligned() ?
						math.alignUp(pHole[i].start, math.nok(iStride,4)):
						math.alignUp(pHole[i].start, iStride);

					if((pHole[i].end - iAligStart) >= iCount * iStride) {
						if(arguments.length == 2) {
							pVertexData = new data.VertexData(this, this._iDataCounter ++, iAligStart, iCount, pDeclData);
							this._pVertexDataArray.push(pVertexData);

							this.notifyAltered();
							return pVertexData;
						}
						else if(arguments.length == 3) {
							((<any>ppVertexDataIn).constructor).call(ppVertexDataIn, this, iAligStart, iCount, pDeclData);
							this._pVertexDataArray.push(ppVertexDataIn);

							this.notifyAltered();
							return ppVertexDataIn;
						}

						return null;
					}
				}

				if (this.resize(math.max(this.byteLength * 2, this.byteLength + iCount * iStride)) == false) {
					break;
				}
			}

			return null;
		}


		freeVertexData(): bool;
		freeVertexData(pVertexData?: IVertexData): bool {
			if(arguments.length == 0) {
				for(var i:  number  = 0; i < this._pVertexDataArray.length; i ++) {
					this._pVertexDataArray[Number(i)].destroy();
				}

				this._pVertexDataArray = null;
			}
			else {
				for(var i:  number  = 0; i < this._pVertexDataArray.length; i ++) {
					if(this._pVertexDataArray[i] == pVertexData) {
						pVertexData.destroy();

						this._pVertexDataArray.splice(i, 1);
						this.notifyAltered();
						return true;
					}
				}

				return false;
			}

			this.notifyAltered();
			return true;
		}

		allocateData(pElements: IVertexElement[], pData: ArrayBufferView): IVertexData;
		allocateData(pDecl: IVertexDeclaration, pData: ArrayBufferView): IVertexData;
		allocateData(pDeclData: any, pData: ArrayBufferView): IVertexData {
			var pDecl: IVertexDeclaration = createVertexDeclaration(pDeclData);

			var pVertexData: IVertexData;
		    var iCount:  number  = pData.byteLength / pDecl.stride;

		    logger.setSourceLocation( "core/pool/resources/VertexBuffer.ts" , 221 ); logger.assert(iCount === math.floor(iCount), 'Data size should be a multiple of the vertex declaration.'); ;

		    pVertexData = this.getEmptyVertexData(iCount, pDecl);
		    pVertexData.setData(pData, 0, pDecl.stride);

		    return pVertexData;
		}

	}
}







module akra.webgl {

	export class WebGLVertexBuffer extends core.pool.resources.VertexBuffer implements IVertexBuffer {
		/**@protected*/  _iByteSize:  number ;

		/**@protected*/  _pWebGLBuffer: WebGLBuffer;

		private _pLockData: Uint8Array = null;


		/**@inline*/  get type(): EVertexBufferTypes { return EVertexBufferTypes.VBO; }
		/**@inline*/  get byteLength():  number  { return this._iByteSize; }

/*pManager: IResourcePoolManager*/
		constructor (                                  ) {
/*pManager*/
			super(            );
		}

		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: Uint8Array = null): bool;
		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: ArrayBufferView = null): bool;
		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: any = null): bool {

			iByteSize = math.max(iByteSize,  1024 );

			if ( (((iFlags) & (EHardwareBufferFlags.READABLE)) != 0) ) {
	            ((iFlags) |= (EHardwareBufferFlags.BACKUP_COPY)) ;
	        }

			super.create(iByteSize, iFlags, pData);

			var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
		    var i:  number ;

		    logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 45 ); logger.assert(this._pWebGLBuffer == null, "webgl buffer already allocated"); ;

			this._iByteSize = iByteSize;
		    this._iFlags = iFlags;
		    pWebGLContext = pWebGLRenderer.getWebGLContext();

		    logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 51 ); logger.assert(pWebGLContext !== null, "cannot grab webgl context"); ;

//Софтварного рендеринга буфера у нас нет
		    logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 54 ); logger.assert(!this.isSoftware(), "no sftware rendering"); ;

//Если есть локальная копия то буфер можно читать
		    if (this.isBackupPresent()) {
		        ((this._iFlags) |= (EHardwareBufferFlags.READABLE)) ;
		    }

			logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 62 ); logger.assert(!pData || pData.byteLength <= iByteSize, "Размер переданного массива больше переданного размера буфера");
                                                                                                                         ;


		    this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();

		    if (!this._pWebGLBuffer) {
		        logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 68 ); logger.criticalError("Не удалось создать буфер"); ;

		        this.destroy();
		        return false;
		    }

		    pWebGLRenderer.bindWebGLBuffer( 0x8892 , this._pWebGLBuffer);
		    pWebGLContext.bufferData( 0x8892 , this._iByteSize, getWebGLUsage(this._iFlags));

		    if (pData) {
		        pWebGLContext.bufferSubData(
		        	0x8892 , 0, isArrayBuffer(pData)? pData: pData.buffer);
		    }

		    return true;
		}

		destroy(): void {
			super.destroy();

			var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getEngine().getRenderer();

			pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);

			this._pWebGLBuffer = null;
			this._iByteSize = 0;
		}

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;
		readData(iOffset: any, iSize?: any, ppDest?: any): bool {
			logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 99 ); logger.assert(!isNull(this._pWebGLBuffer), "Буффер еще не создан"); ;

		    if (!this.isBackupPresent()) {
		    	return false;
		    }

			if (arguments.length === 1) {
				this._pBackupCopy.readData(arguments[0]);
			}
			else {
				this._pBackupCopy.readData(iOffset, iSize, ppDest);
			}

		    return true;
		}

		writeData(pData: Uint8Array, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: ArrayBufferView, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: any, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool {

			logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 119 ); logger.assert(!isNull(this._pWebGLBuffer), "WebGL buffer not exists"); ;

		    var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getEngine().getRenderer();
		    var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

		    pWebGLRenderer.bindWebGLBuffer( 0x8892 , this._pWebGLBuffer);

			logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 126 ); logger.assert(pData.byteLength <= iSize, "Размер переданного массива больше переданного размера"); ;
			logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 127 ); logger.assert(this.byteLength >= iOffset + iSize, "Данные выйдут за предел буфера"); ;

			var pU8Data: Uint8Array = null;

			if (isArrayBuffer(pData)) {
				pU8Data = new Uint8Array(pData);
			}
			else {
				pU8Data = new Uint8Array(pData.buffer, pData.byteOffset, pData.byteLength);
			}

			pU8Data = pU8Data.subarray(0, iSize);

			pWebGLContext.bufferSubData( 0x8892 , iOffset, pU8Data);

			if (this.isBackupPresent()) {
		        this._pBackupCopy.writeData(pU8Data, iOffset);
		    }

		    this.notifyAltered();

			return true;
		}

		resize(iSize:  number ): bool {
			var eUsage:  number ;
			var pData: Uint8Array;
			var iMax:  number  = 0;
			var pVertexData: IVertexData;

		    var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getEngine().getRenderer();
		    var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			if(this.isBackupPresent()) {
				return false;
			}

			if(iSize < this.byteLength) {
				for(var k:  number  = 0; k < this._pVertexDataArray.length; ++ k) {
					pVertexData = this._pVertexDataArray[k];

					if(pVertexData.byteOffset + pVertexData.byteLength > iMax) {
						iMax = pVertexData.byteOffset + pVertexData.byteLength;
					}
				}

				logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 174 ); logger.assert(iMax <= iSize, "Уменьшение невозможно. Страая разметка не укладывается в новый размер");
                                                                                                                                         ;
			}

			if(pWebGLContext.isBuffer(this._pWebGLBuffer)) {
				pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);
			}

			eUsage = getWebGLUsage(this._iFlags);

		    this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();

		    if (!this._pWebGLBuffer) {
		        logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 186 ); logger.criticalError("Не удалось создать буфер"); ;

		        this.destroy();
		        return false;
		    }


		    pWebGLRenderer.bindWebGLBuffer( 0x8892 , this._pWebGLBuffer);
			pWebGLContext.bufferData( 0x8892 , iSize, eUsage);

			pData = new Uint8Array(this._iByteSize);

			if (this.readData(pData)) {
				logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 199 ); logger.warning("cannot read data from buffer"); ;
				return false;
			}


			this.writeData(pData, 0, this._iByteSize);
			this._pBackupCopy.resize(iSize);
			this._iByteSize = iSize;

			this.notifyAltered();

			return true;
		}

		/**@inline*/  getWebGLBuffer(): WebGLBuffer {
			return this._pWebGLBuffer;
		}

		/**@protected*/  lockImpl(iOffset:  number , iSize:  number , iLockFlags:  number ): any {
	        var pRetData: Uint8Array = new Uint8Array(iSize);

            this.readData(iOffset, iSize, pRetData);

            this._pLockData = pRetData;

	        return pRetData;
		}

		/**@protected*/  unlockImpl(): void {
			this.writeData(this._pLockData, this._iLockStart, this._iLockSize);
		}

		/**@protected*/  copyBackupToRealImpl(pRealData: Uint8Array, pBackupData: Uint8Array, iLockFlags:  number ): void {
			pRealData.set(pBackupData);
		}
	}
}

























module akra {
	export interface ITexture {} ;

	export interface ISampler2d {
		TEXTURE: string;
	}
}











module akra.webgl {

    export interface WebGLUniformLocationMap {
        [index: string]: WebGLUniformLocation;
    }

	export class WebGLShaderProgram extends core.pool.ResourcePoolItem implements IShaderProgram {
		/**@protected*/  _pWebGLProgram: WebGLProgram;
		/**@protected*/  _pWebGLUniformLocations: WebGLUniformLocationMap;
		/**@protected*/  _pWebGLAttributeLocations: IntMap;

		/**@protected*/  _pWebGLAttributesInfo: WebGLActiveInfo[];

		create(csVertex?: string, csPixel?: string): bool {
			if (arguments.length > 0) {
				return this.compile(csVertex ||  "void main(void){gl_Position = vec4(0., 0., 0., 1.);}" , csPixel ||  "void main(void){}" );
			}

            return false;
		}

        destroy(): void {
            var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer();

            pWebGLRenderer.deleteWebGLProgram(this._pWebGLProgram);

            this._pWebGLUniformLocations = null;
            this._pWebGLAttributeLocations = null;
            this._pWebGLAttributesInfo = null;

            this.notifyDestroyed();
            this.notifyDisabled();
        }

    	compile(csVertex: string =  "void main(void){gl_Position = vec4(0., 0., 0., 1.);}" , csPixel: string =  "void main(void){}" ): bool {
    		var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
			var pWebGLProgram: WebGLProgram = this._pWebGLProgram = pWebGLRenderer.createWebGLProgram();

			var pWebGLVs: WebGLShader = this.createWebGLShader( 0x8B31 , csVertex);
			var pWebGLFs: WebGLShader = this.createWebGLShader( 0x8B30 , csPixel);

/** because, if not all units correctly activated, can obtained wronf link status */

			pWebGLRenderer._disableAllTextureUnits();

			pWebGLContext.attachShader(pWebGLProgram, pWebGLVs);
			pWebGLContext.attachShader(pWebGLProgram, pWebGLFs);

			pWebGLContext.linkProgram(pWebGLProgram);

			if (!this.isLinked()) {
				logger.setSourceLocation( "WebGLShaderProgram.ts" , 67 ); logger.error("cannot link GLSL program(guid: %d)", this.getGuid()); ;


				if (hasExtension( "WEBGL_debug_shaders" )) {
					logger.setSourceLocation( "WebGLShaderProgram.ts" , 73 ); logger.log("translated(from GLSL) VS shader: \n %s\ntranslated(from GLSL) PS shader: \n%s", pWebGLContext.getTranslatedShaderSource(pWebGLVs), pWebGLContext.getTranslatedShaderSource(pWebGLFs));
                                                        ;
				}

				var sInfo: string = pWebGLContext.getProgramInfoLog(pWebGLProgram);

				logger.setSourceLocation( "WebGLShaderProgram.ts" , 78 ); logger.log("shader program errors: \n %s\n\nvertex code:\n %s\n\n pixel code: %s", sInfo, csVertex, csPixel); ;


				return false;
			}

			pWebGLContext.validateProgram(pWebGLProgram);

			if (!this.isValid()) {
				logger.setSourceLocation( "WebGLShaderProgram.ts" , 87 ); logger.warning("GLSL program not valid(guid: %d)", this.getGuid()); ;

				logger.setSourceLocation( "WebGLShaderProgram.ts" , 89 ); logger.log(pWebGLContext.getProgramInfoLog(pWebGLProgram)); ;
			}

			this.obtainWebGLUniforms();
			this.obtainWebGLAttributes();

            this.notifyCreated();
            this.notifyRestored();

			return true;
    	}

    	isLinked(): bool {
    		var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;
    		return isDefAndNotNull(this._pWebGLProgram) &&
    			<bool>pWebGLContext.getProgramParameter(this._pWebGLProgram,  0x8B82 );
    	}

    	isValid(): bool {
    		var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;
    		return isDefAndNotNull(this._pWebGLProgram) &&
    			<bool>pWebGLContext.getProgramParameter(this._pWebGLProgram,  0x8B83 );
    	}

    	isActive(): bool {
    		var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;
    		return (isDefAndNotNull(this._pWebGLProgram) &&
    			<WebGLProgram>pWebGLContext.getParameter( 0x8B8D ) === this._pWebGLProgram);
    	}

    	setFloat(sName: string, fValue:  number ): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
			var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;
    		pWebGLContext.uniform1f(iLoc, fValue);
    		return true;
    	}

    	setInt(sName: string, iValue:  number ): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
			var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;
    		pWebGLContext.uniform1i(iLoc, iValue);

    		return true;
    	}

    	setVec2(sName: string, v2fValue: IVec2): bool;
    	setVec2(sName: string, x:  number , y:  number ): bool;
    	/**@inline*/  setVec2(sName: string, x?, y?): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		if (arguments.length == 2) {
    			pWebGLContext.uniform2f(iLoc, arguments[1].x, arguments[1].y);
    		}
    		else {
    			pWebGLContext.uniform2f(iLoc, arguments[1], arguments[2]);
    		}

    		return true;
    	}


    	setVec2i(sName: string, v2iValue: IVec2): bool;
    	setVec2i(sName: string, x:  number , y:  number ): bool;
    	/**@inline*/  setVec2i(sName: string, x?, y?): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		if (arguments.length == 2) {
    			pWebGLContext.uniform2i(iLoc, arguments[1].x, arguments[1].y);
    		}
    		else {
    			pWebGLContext.uniform2i(iLoc, arguments[1], arguments[2]);
    		}

    		return true;
    	}

    	setVec3(sName: string, v3fValue: IVec3): bool;
    	setVec3(sName: string, x:  number , y:  number , z:  number ): bool;
    	/**@inline*/  setVec3(sName: string, x?, y?, z?): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		if (arguments.length == 2) {
    			pWebGLContext.uniform3f(iLoc, arguments[1].x, arguments[1].y, arguments[1].z);
    		}
    		else {
    			pWebGLContext.uniform3f(iLoc, arguments[1], arguments[2], arguments[3]);
    		}

    		return true;
    	}

    	setVec3i(sName: string, v3iValue: IVec3): bool;
    	setVec3i(sName: string, x:  number , y:  number , z:  number ): bool;
    	/**@inline*/  setVec3i(sName: string, x?, y?, z?): bool {
			var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		if (arguments.length == 2) {
    			pWebGLContext.uniform3i(iLoc, arguments[1].x, arguments[1].y, arguments[1].z);
    		}
    		else {
    			pWebGLContext.uniform3i(iLoc, arguments[1], arguments[2], arguments[3]);
    		}

    		return true;
    	}

    	setVec4(sName: string, v4fValue: IVec4): bool;
    	setVec4(sName: string, x:  number , y:  number , z:  number , w:  number ): bool;
    	/**@inline*/  setVec4(sName: string, x?, y?, z?, w?): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		if (arguments.length == 2) {
    			pWebGLContext.uniform4f(iLoc, arguments[1].x, arguments[1].y, arguments[1].z, arguments[1].w);
    		}
    		else {
    			pWebGLContext.uniform4f(iLoc, arguments[1], arguments[2], arguments[3], arguments[3]);
    		}

    		return true;
    	}

    	setVec4i(sName: string, v4iValue: IVec4): bool;
    	setVec4i(sName: string, x:  number , y:  number , z:  number , w:  number ): bool;
    	/**@inline*/  setVec4i(sName: string, x?, y?, z?, w?): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		if (arguments.length == 2) {
    			pWebGLContext.uniform4i(iLoc, arguments[1].x, arguments[1].y, arguments[1].z, arguments[1].w);
    		}
    		else {
    			pWebGLContext.uniform4i(iLoc, arguments[1], arguments[2], arguments[3], arguments[3]);
    		}

    		return true;
    	}


    	/**@inline*/  setMat3(sName: string, m3fValue: IMat3): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		pWebGLContext.uniformMatrix3fv(iLoc, false, m3fValue.data);

    		return true;
    	}

    	setMat4(sName: string, m4fValue: IMat4): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		pWebGLContext.uniformMatrix4fv(iLoc, false, m4fValue.data);

    		return true;
    	}

    	/**@inline*/  setFloat32Array(sName: string, pValue: Float32Array): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		pWebGLContext.uniform1fv(iLoc, pValue);

    		return true;
    	}

    	/**@inline*/  setInt32Array(sName: string, pValue: Int32Array): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		pWebGLContext.uniform1iv(iLoc, pValue);

    		return true;
    	}

    	/**@inline*/  setVec2Array(sName: string, pValue: IVec2[]): bool {
    		return false;
    	}

    	/**@inline*/  setVec2iArray(sName: string, pValue: IVec2[]): bool {
    		return false;
    	}

    	/**@inline*/  setVec3Array(sName: string, pValue: IVec3[]): bool {
    		return false;
    	}

    	/**@inline*/  setVec3iArray(sName: string, pValue: IVec3[]): bool {
    		return false;
    	}

    	/**@inline*/  setVec4Array(sName: string, pValue: IVec4[]): bool {
    		return false;
    	}

    	/**@inline*/  setVec4iArray(sName: string, pValue: IVec4[]): bool {
    		return false;
    	}



    	/**@inline*/  setMat3Array(sName: string, pValue: IMat3[]): bool {
    		return false;
    	}

    	/**@inline*/  setMat4Array(sName: string, pValue: IMat4[]): bool {
    		return false;
    	}

    	/**@inline*/  setStruct(sName: string, pData: Object): bool {
    		return false;
    	}

    	/**@inline*/  setSampler2D(sName: string, pData: ISampler2d): bool {
    		return false;
    	}

    	/**@inline*/  setSampler2DToStruct(sName: string, pData: ISampler2d): bool {
    		return false;
    	}

    	/**@inline*/  setTexture(sName: string, pData: ITexture): bool {
    		return false;
    	}

//applyVertexBuffer(sName: string, pBuffer: IVertexBuffer);
    	applyVertexData(sName: string, pData: IVertexData): bool {
    		var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		var pVertexBuffer: IVertexBuffer = <IVertexBuffer>pData.buffer;
    		var iStride:  number  = pData.stride;

    		if (pVertexBuffer.type !== EVertexBufferTypes.VBO) {
    			return false
    		}

    		var pVertexDecl: IVertexDeclaration = pData.getVertexDeclaration();
    		var pVertexElement: IVertexElement;
    		var iLoc:  number ;

    		for (var i:  number  = 0; i < pVertexDecl.length; ++ i) {
    			pVertexElement = pVertexDecl[i];
    			iLoc = this.getWebGLAttributeLocation(pVertexElement.usage);

    			if (iLoc < 0) {
    				logger.setSourceLocation( "WebGLShaderProgram.ts" , 353 ); logger.warning("founded invalid GLSL attribute location(guid: %s): %s", this.getGuid(), pVertexElement.usage);
                              ;
    				continue;
    			}

    			pWebGLRenderer.bindWebGLBuffer( 0x8892 , (<WebGLVertexBuffer>pVertexBuffer).getWebGLBuffer());
    			pWebGLContext.vertexAttribPointer(iLoc,
    											  pVertexElement.count,
    											  pVertexElement.type,
    											  false,
    											  iStride,
    											  pVertexElement.offset);
    		}

    		return true;
    	}


        /**@inline*/  applyBufferMap(pMap: IBufferMap): void {
            logger.setSourceLocation( "WebGLShaderProgram.ts" , 371 ); logger.criticalError("WebGLShaderProgram::applyBufferMap() is uncompleted method!"); ;
        }


    	/**@inline*/  getWebGLAttributeLocation(sName: string):  number  {
    		return this._pWebGLAttributeLocations[sName] || -1;
    	}

    	/**@inline*/  getWebGLUniformLocation(sName: string): WebGLUniformLocation {

			var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName];

			if (!isDef(iLoc)) {
				logger.setSourceLocation( "WebGLShaderProgram.ts" , 384 ); logger.warning("could not find location for GLSL attribute(guid: %s): %s", this.getGuid(), sName); ;
			}

			return null;

    	}

    	/**@inline*/  getWebGLProgram(): WebGLProgram {
    		return this._pWebGLProgram;
    	}

    	/**@protected*/  createWebGLShader(eType:  number , csCode: string): WebGLShader {
    		var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
			var pWebGLShader: WebGLShader = pWebGLContext.createShader(eType);

			pWebGLContext.shaderSource(pWebGLShader, csCode);
			pWebGLContext.compileShader(pWebGLShader);

			if (!pWebGLContext.getShaderParameter(pWebGLShader,  0x8B81 )) {
				logger.setSourceLocation( "WebGLShaderProgram.ts" , 406 ); logger.error("cannot compile GLSL shader(guid: %d)", this.getGuid()); ;

				var sInfo: string = pWebGLContext.getShaderInfoLog(pWebGLShader);
				var sCode: string = pWebGLContext.getShaderSource(pWebGLShader) || csCode;

				logger.setSourceLocation( "WebGLShaderProgram.ts" , 411 ); logger.log("shader errors: \n %s \n----------\n %s", sInfo, sCode); ;

				return null;
			}

			return pWebGLShader;
    	}

    	/**@protected*/  obtainWebGLUniforms(): void {
    		var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		var nUniforms:  number  = pWebGLContext.getProgramParameter(this._pWebGLProgram,  0x8B86 );
    		var pUniformLocations: WebGLUniformLocationMap = {};
    		var iLoc: WebGLUniformLocation;
    		var pUniformInfo: WebGLActiveInfo;

    		for (var i:  number  = 0; i < nUniforms; ++ i) {
    			pUniformInfo = pWebGLContext. getActiveUniform(this._pWebGLProgram, i);
				iLoc = pWebGLContext.getUniformLocation(this._pWebGLProgram, pUniformInfo.name);
				pUniformLocations[pUniformInfo.name] = iLoc;
    		}

    		this._pWebGLUniformLocations = pUniformLocations;
    	}

    	/**@protected*/  obtainWebGLAttributes(): void {
    		var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		var nAttributes:  number  = pWebGLContext.getProgramParameter(this._pWebGLProgram,  0x8B89 );
    		var pAttributeLocations: IntMap = <IntMap>{};
    		var pAttributesInfo: WebGLActiveInfo[] = [];
    		var iLoc:  number ;
    		var pAttributeInfo: WebGLActiveInfo;

    		for (var i:  number  = 0; i < nAttributes; ++ i) {
    			pAttributeInfo = pWebGLContext.getActiveAttrib(this._pWebGLProgram, i);
				iLoc = pWebGLContext.getAttribLocation(this._pWebGLProgram, pAttributeInfo.name);

				if (iLoc < 0 || !isDef(iLoc)) {
					logger.setSourceLocation( "WebGLShaderProgram.ts" , 450 ); logger.warning("could not get GLSL attribute location(guid: %s): %s", this.getGuid(), pAttributeInfo.name); ;
				}


				pAttributeLocations[pAttributeInfo.name] = iLoc;
				pAttributesInfo[iLoc] = pAttributeInfo;
    		}

    		this._pWebGLAttributeLocations = pAttributeLocations;
    		this._pWebGLAttributesInfo = pAttributesInfo;
    	}
	}
}





module akra.webgl {
	export class WebGLVertexTexture extends core.pool.resources.VertexBuffer implements IVertexBuffer {
		/**@protected*/  _iWidth:  number  = 0;
		/**@protected*/  _iHeight:  number  = 0;

		/**@protected*/  _pWebGLTexture: WebGLTexture;
		/**@protected*/  _eWebGLFormat:  number ;
		/**@protected*/  _eWebGLType:  number ;

		/**@protected*/  _ePixelFormat: EPixelFormats = EPixelFormats.FLOAT32_RGBA;
//переменная нужна, чтобы проигнорировать обновление копии, обычно, это не требуется
		/**@protected*/  _bForceUpdateBackupCopy: bool = true;

		private _pLockData: Uint8Array = null;

		/**@inline*/  get type(): EVertexBufferTypes { return EVertexBufferTypes.TBO; }
		/**@inline*/  get byteLength():  number  { return pixelUtil.getMemorySize(this._iWidth, this._iHeight, 1, this._ePixelFormat); }


/*pManager: IResourcePoolManager*/
		constructor (                                  ) {
/*pManager*/
			super(            );
		}

		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: Uint8Array = null): bool;
		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: ArrayBufferView = null): bool;
		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: any = null): bool {

			var iMinWidth:  number  =  32 ;
			var iWidth:  number , iHeight:  number ;
			var pTextureData: Uint8Array = null;
			var pDataU8: Uint8Array = pData;

			iByteSize = math.max(iByteSize, pixelUtil.getMemorySize(iMinWidth, iMinWidth, 1, this._ePixelFormat));

			if ( (((iFlags) & (EHardwareBufferFlags.READABLE)) != 0) ) {
	            ((iFlags) |= (EHardwareBufferFlags.BACKUP_COPY)) ;
	        }

			super.create(iByteSize, iFlags, pData);

			var pPOTSize:  number [] = math.calcPOTtextureSize(math.ceil(iByteSize / pixelUtil.getNumElemBytes(this._ePixelFormat)));
			var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer();
		    var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
		    var i:  number ;

		    iWidth = pPOTSize[0];
		    iHeight = pPOTSize[1];

		    logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 61 ); logger.assert(this._pWebGLTexture == null, "webgl texture already allocated"); ;

			this._iWidth = iWidth;
			this._iHeight = iHeight;
		    this._iFlags = iFlags;

		    logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 67 ); logger.assert(pWebGLContext !== null, "cannot grab webgl context"); ;

//Софтварного рендеринга буфера у нас нет
		    logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 70 ); logger.assert(!this.isSoftware(), "no sftware rendering"); ;

//Если есть локальная копия то буфер можно читать
		    if (this.isBackupPresent()) {
		        ((this._iFlags) |= (EHardwareBufferFlags.READABLE)) ;
		    }

			logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 78 ); logger.assert(!pData || pData.byteLength <= iByteSize, "Размер переданного массива больше переданного размера буфера");
                                                                                                                         ;

		    this._pWebGLTexture = pWebGLRenderer.createWebGLTexture();
		    this._eWebGLFormat = getWebGLOriginFormat(this._ePixelFormat);
		    this._eWebGLType = getWebGLOriginDataType(this._ePixelFormat);

		    if (!this._pWebGLTexture) {
		        logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 85 ); logger.criticalError("Не удалось создать буфер"); ;

		        this.destroy();
		        return false;
		    }

		    if (pData) {

		    	if (pData.BYTES_PER_ELEMENT > 1) {
		    		pDataU8 = new Uint8Array(pData, pData.byteOffset, pData.byteLength);
		    	}

		    	pTextureData = new Uint8Array(this.byteLength);
		    	pTextureData.set(pDataU8);
		    }

		    pWebGLRenderer.bindWebGLTexture( 0x0DE1 , this._pWebGLTexture);
		    pWebGLContext.texImage2D( 0x0DE1 , 0, this._eWebGLFormat,
		    	this._iWidth, this._iHeight, 0,  this._eWebGLFormat, this._eWebGLType, pTextureData);


		    var pProgram: IShaderProgram = <IShaderProgram>this.getManager().shaderProgramPool.findResource("WEBGL_update_vertex_texture");

	        if (isNull(pProgram)) {
	        	pProgram = <IShaderProgram>this.getManager().shaderProgramPool.createResource("WEBGL_update_vertex_texture");
	        	pProgram.create(
	        	"																									\n	        	uniform sampler2D sourceTexture;																	\n				attribute vec4  VALUE;																				\n				attribute float INDEX;																				\n				attribute float SHIFT;																				\n				                      																				\n				uniform vec2 size;																					\n				varying vec4 color;																					\n				                   																					\n				void main(void){																					\n				    vec4 value = VALUE;																				\n				    float  serial = INDEX;																			\n				                          																			\n				    int shift = int(SHIFT);																			\n				    if (shift != 0) {																				\n				        color = texture2D(sourceTexture,                                        					\n				            vec2((mod(serial, size.x) +.5 ) / size.x, (floor(serial / size.x) + .5) / size.y)		\n				            );																						\n																													\n																													\n				        if (shift == 1) {																			\n				            color = vec4(color.r, value.gba);														\n				        }																							\n				        else if (shift == 2) {																		\n				            color = vec4(color.rg, value.ba);														\n				        }																							\n				        else if (shift == 3) {																		\n				            color = vec4(color.rgb, value.a);														\n				        }																							\n				        else if (shift == -1) {																		\n				            color = vec4(value.r, color.gba);														\n				        }																							\n				        else if (shift == -2) {																		\n				            color = vec4(value.rg, color.ba);														\n				        }																							\n				        else {																						\n				            color = vec4(value.rgb, color.a);														\n				        }																							\n				    }																								\n				    else {																							\n				        color = value;																				\n				    }																								\n				    gl_Position = vec4(2. * (mod(serial, size.x) + .5) / size.x - 1.,								\n				                    2. * (floor(serial / size.x)  + .5) / size.y - 1., 0., 1.);						\n				}																									\n				",
				"									\n				#ifdef GL_ES                        \n				    precision highp float;          \n				#endif								\n				varying vec4 color;                 \n				                                    \n				void main(void) {                   \n				    gl_FragColor = color;           \n				}                                   \n				");
	        }

		    return true;
		}

		destroy(): void {
			super.destroy();

			var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer();
			pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);

			this._pWebGLTexture = null;
		}

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;
		readData(iOffset: any, iSize?: any, ppDest?: any): bool {
			logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 184 ); logger.assert(!isNull(this._pWebGLTexture), "Буффер еще не создан"); ;

		    if (!this.isBackupPresent()) {
		    	return false;
		    }

			if (arguments.length === 1) {
				this._pBackupCopy.readData(arguments[0]);
			}
			else {
				this._pBackupCopy.readData(iOffset, iSize, ppDest);
			}

		    return true;
		}

		writeData(pData: Uint8Array, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: ArrayBufferView, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: any, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool {

/*предпологается, что float*/
			var iTypeSize:  number  		= pixelUtil.getComponentTypeBits(this._ePixelFormat) / 8,
/*число float'ов в пикселе*/
		        nElementsPerPix:  number  	= pixelUtil.getComponentCount(this._ePixelFormat),
/*номер float'a с которого начинается обновление*/
		        iFrom:  number ,
/*исло float'ов для обновления*/
		        iCount:  number ;
/*данные для обновления*/
			var pBufferData: Float32Array;

/*смещение внутри первого пикселя*/
		    var iLeftShift:  number ,
/*смещение внутри последнего пикселя*/
		        iRightShift:  number ,
/*пиксель с которого начинается о��новление*/
		        iBeginPix:  number ,
/*пиксель на котором заканчивается обновление*/
		        iEndPix:  number ,
/*число пикселей*/
		        nPixels:  number ,
		        nElements:  number ;

		    var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer();
		    var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

		    var pDataU8: Uint8Array = pData;

		    logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 222 ); logger.assert(bDiscardWholeBuffer === false, "Discard option temporary unsupported."); ;

		    if (pData.BYTES_PER_ELEMENT > 1) {
		    	pDataU8 = new Uint8Array(pData.buffer, pData.byteOffset, pData.byteLength);
		    }

		    iOffset = iOffset || 0;
		    iSize = iSize || pData.byteLength;

		    pDataU8 = pDataU8.subarray(0, iSize);

		    if (this.byteLength < iOffset + iSize) {
		        this.resize(iOffset + iSize);
		    }

		    if (this.isBackupPresent() && this._bForceUpdateBackupCopy) {
		        this._pBackupCopy.writeData(pDataU8, iOffset);
		    }

		    this._bForceUpdateBackupCopy = true;

		    logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 243 ); logger.assert(iOffset % iTypeSize === 0 && iSize % iTypeSize === 0, "Incorrect data size or offset"); ;

		    iFrom 	= iOffset / iTypeSize;
		    iCount 	= iSize / iTypeSize;

		    iLeftShift 	= iFrom % nElementsPerPix;
		    iRightShift = ((iFrom + iCount) % nElementsPerPix);
		    iBeginPix 	= Math.floor(iFrom / nElementsPerPix);
		    iEndPix 	= Math.floor((iFrom + iCount) / nElementsPerPix);
		    nPixels 	= Math.ceil((iFrom + iCount) / nElementsPerPix) - Math.floor(iFrom / nElementsPerPix);
		    nElements 	= nPixels * nElementsPerPix;

		    pBufferData = new Float32Array(pDataU8.buffer, pDataU8.byteOffset);

		    if (iLeftShift === 0 && iRightShift === 0) {
		        var iWidth:  number  	= this._iWidth;
		        var iYmin:  number  		= Math.floor(iBeginPix / iWidth);
		        var iYmax:  number  		= Math.ceil(iEndPix / iWidth);
		        var iXbegin:  number  	= iBeginPix % iWidth;
		        var iXend:  number  		= iEndPix % iWidth;
		        var iHeight:  number  	= iYmax - iYmin;

		        var iBeginElement:  number  	= 0,
		        	iEndElement:  number  	= 0;

//hack: if iEndPixel is first pixel from next row

		        iXend = (iXend === 0 ? iWidth : iXend);

//FIX THIS, move this function from here...
		        function updatePixelRect(iX:  number , iY:  number , iW:  number , iH:  number ): void {
		            iBeginElement = iEndElement;
		            iEndElement = iW * iH * nElementsPerPix + iEndElement;

		            pWebGLRenderer.bindWebGLTexture( 0x0DE1 , this._pWebGLTexture);

		            pWebGLContext.texSubImage2D( 0x0DE1 , 0, iX, iY, iW, iH,
		            	this._eWebGLFormat, this._eWebGLType, pBufferData.subarray(iBeginElement, iEndElement));
		        };

		        if (iHeight === 1) {
		            updatePixelRect(iXbegin, iYmin, iXend - iXbegin, 1);
		        }
		        else {

		            updatePixelRect(iXbegin, iYmin, iWidth - iXbegin, 1);

		            if (iHeight > 2) {
		                updatePixelRect(0, iYmin + 1, iWidth, iHeight - 2);
		            }

		            updatePixelRect(0, iYmax - 1, iXend, 1);
		        }
		    }
		    else if (this.isBackupPresent()) {
		        var iRealOffset:  number  	= iBeginPix * nElementsPerPix * iTypeSize;
		        var iRealSize:  number  	= nElements * iTypeSize;
		        var pTempData: Uint8Array = <Uint8Array>this._pBackupCopy.lock(iRealOffset, iRealSize);
//var iTotalSize: uint 	= iRealOffset + iRealSize;

		        this._bForceUpdateBackupCopy = false;

		        return this.writeData(pTempData, iRealOffset, iRealSize);
		    }
		    else {

		        var pMarkupDataIndex: Float32Array = new Float32Array(nPixels);
		        var pMarkupDataShift: Float32Array = new Float32Array(nPixels);
		        var pRealData: Float32Array = new Float32Array(nElements);

		        pMarkupDataIndex[0] = iBeginPix;
		        pMarkupDataShift[0] = iLeftShift;

		        pMarkupDataIndex[nPixels - 1] = iBeginPix + nPixels - 1;
		        pMarkupDataShift[nPixels - 1] = -iRightShift;

		        for (var i:  number  = 1; i < nPixels - 1; ++i) {
		            pMarkupDataIndex[i] = iBeginPix + i;
		        }

		        for (var i:  number  = 0; i < iCount; i++) {
		            pRealData[iLeftShift + i] = pBufferData[i];
		        }

		        var pShaderSource;
		        var pWebGLFramebuffer: WebGLFramebuffer = pWebGLRenderer.createWebGLFramebuffer();
		        var pWebGLProgram: WebGLShaderProgram = <WebGLShaderProgram>this.getManager().shaderProgramPool.findResource("WEBGL_update_vertex_texture");

		        var pValueBuffer: WebGLBuffer 		= pWebGLRenderer.createWebGLBuffer();
		        var pMarkupIndexBuffer: WebGLBuffer = pWebGLRenderer.createWebGLBuffer();
		        var pMarkupShiftBuffer: WebGLBuffer = pWebGLRenderer.createWebGLBuffer();

		        logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 335 ); logger.assert(isDef(pWebGLProgram), "cound not find WEBGL_update_vertex_texture program"); ;

		        pWebGLRenderer.disableAllWebGLVertexAttribs();

		        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pWebGLFramebuffer);
		        pWebGLRenderer.useWebGLProgram(pWebGLProgram.getWebGLProgram());

//FIXME: set weblg states (GL_DEPTH_FUNC, GL_***)

		        pWebGLContext.framebufferTexture2D( 0x8D40 ,  0x8CE0 ,
		        	0x0DE1 , this._pWebGLTexture, 0);

		        pWebGLRenderer.bindWebGLBuffer( 0x8892 , pValueBuffer);
		        pWebGLContext.bufferData( 0x8892 , pRealData,  0x88E0 );
		        pWebGLContext.vertexAttribPointer(pWebGLProgram.getWebGLAttributeLocation("VALUE"), 4,  0x1406 , false, 0, 0);

		        pWebGLRenderer.bindWebGLBuffer( 0x8892 , pMarkupIndexBuffer);
		        pWebGLContext.bufferData( 0x8892 , pMarkupDataIndex,  0x88E0 );
		        pWebGLContext.vertexAttribPointer(pWebGLProgram.getWebGLAttributeLocation("INDEX"), 1,  0x1406 , false, 0, 0);


		        pWebGLRenderer.bindWebGLBuffer( 0x8892 , pMarkupShiftBuffer);
		        pWebGLContext.bufferData( 0x8892 , pMarkupDataShift,  0x88E0 );
		        pWebGLContext.vertexAttribPointer(pWebGLProgram.getWebGLAttributeLocation("SHIFT"), 1,  0x1406 , false, 0, 0);

		        pWebGLRenderer.bindWebGLTexture( 0x0DE1 , this._pWebGLTexture);
		        pWebGLRenderer.activateWebGLTexture( 0x84C0 );


		        pWebGLContext.uniform2i("size", this._iWidth, this._iHeight);
		        pWebGLContext.uniform1i("sourceTexture", 0);



		        pWebGLContext.viewport(0, 0, this._iWidth, this._iHeight);
		        pWebGLContext.drawArrays(0, 0, nPixels);
		        pWebGLContext.flush();

		        pWebGLContext.framebufferTexture2D( 0x8D40 ,  0x8CE0 ,  0x0DE1 , null, 0);

		        pWebGLRenderer.bindWebGLBuffer( 0x8892 , null);

		        pWebGLRenderer.deleteWebGLBuffer(pValueBuffer);
		        pWebGLRenderer.deleteWebGLBuffer(pMarkupShiftBuffer);
		        pWebGLRenderer.deleteWebGLBuffer(pMarkupIndexBuffer);

		        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , null);
		        pWebGLRenderer.deleteWebGLFramebuffer(pWebGLFramebuffer);
		    }

		    return true;
		}

		resize(iSize:  number ): bool {
			var eUsage:  number ;
			var pData: Uint8Array;
			var iMax:  number  = 0;
			var pVertexData: IVertexData;
		    var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			if(this.isBackupPresent()) {
				return false;
			}

			if(iSize < this.byteLength) {
				for(var k:  number  = 0; k < this._pVertexDataArray.length; ++ k) {
					pVertexData = this._pVertexDataArray[k];

					if(pVertexData.byteOffset + pVertexData.byteLength > iMax) {
						iMax = pVertexData.byteOffset + pVertexData.byteLength;
					}
				}

				logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 410 ); logger.assert(iMax <= iSize, "Уменьшение невозможно. Страая разметка не укладывается в новый размер");
                                                                                                                                         ;
			}

			if(pWebGLContext.isTexture(this._pWebGLTexture)) {
				pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);
			}


		    this._pWebGLTexture = pWebGLRenderer.createWebGLTexture();

		    if (!this._pWebGLTexture) {
		        logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 421 ); logger.criticalError("Не удалось создать текстуру"); ;

		        this.destroy();
		        return false;
		    }


		    pWebGLRenderer.bindWebGLTexture( 0x0DE1 , this._pWebGLTexture);

			pData = new Uint8Array(this.byteLength);

			if (this.readData(pData)) {
				logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 433 ); logger.warning("cannot read data from buffer"); ;
				return false;
			}


			this.writeData(pData, 0, this.byteLength);
			this._pBackupCopy.resize(iSize);

			this.notifyAltered();

			return true;
		}

		/**@protected*/  lockImpl(iOffset:  number , iSize:  number , iLockFlags:  number ): any {
	        var pRetData: Uint8Array = new Uint8Array(iSize);

            this.readData(iOffset, iSize, pRetData);

            this._pLockData = pRetData;

	        return pRetData;
		}

		/**@protected*/  unlockImpl(): void {
			this.writeData(this._pLockData, this._iLockStart, this._iLockSize);
		}

		/**@protected*/  copyBackupToRealImpl(pRealData: Uint8Array, pBackupData: Uint8Array, iLockFlags:  number ): void {
			pRealData.set(pBackupData);
		}
	}


}





















module akra {
	export interface IIndexData extends IBufferData, IBuffer {
		 type: EDataTypes;
		 length:  number ;
		 bytesPerIndex:  number ;
		 id:  number ;

		getData(iOffset:  number , iSize:  number ): ArrayBuffer;
		setData(pData: ArrayBufferView): bool;
		setData(pData: ArrayBufferView, iOffset:  number , iCount:  number ): bool;

		destroy(): void;

		getPrimitiveType(): EPrimitiveTypes;
		getPrimitiveCount():  number ;
		getBufferHandle():  number ;
	}
}






















module akra.data {
	export class IndexData implements IIndexData {
		private _pIndexBuffer: IIndexBuffer;
		private _iOffset:  number ;
		private _iLength:  number ;
		private _ePrimitiveType: EPrimitiveTypes;
		private _eElementsType: EDataTypes;
		private _iId:  number ;

		/**@inline*/  get id():  number  { return this._iId; }
		/**@inline*/  get type():  number  { return this._eElementsType; };
		/**@inline*/  get length():  number  { return this._iLength; };
		/**@inline*/  get bytesPerIndex():  number  { return getTypeSize(this._eElementsType); };
		/**@inline*/  get byteOffset():  number  { return this._iOffset; };
		/**@inline*/  get byteLength():  number  { return this._iLength * this.bytesPerIndex; };
		/**@inline*/  get buffer(): IIndexBuffer { return this._pIndexBuffer; };

		constructor (
			pIndexBuffer: IIndexBuffer,
			id:  number ,
			iOffset:  number ,
			iCount:  number ,
			ePrimitiveType: EPrimitiveTypes = EPrimitiveTypes.TRIANGLELIST,
			eElementsType: EDataTypes = EDataTypes.UNSIGNED_SHORT) {

			logger.setSourceLocation( "data/IndexData.ts" , 36 ); logger.assert(eElementsType == EDataTypes.UNSIGNED_SHORT || eElementsType == EDataTypes.UNSIGNED_BYTE || eElementsType == EDataTypes.UNSIGNED_INT, "supported only short, byte, uint data types.");
                                                                                             ;

			this._pIndexBuffer = pIndexBuffer;
			this._iOffset = iOffset;
			this._iLength = iCount;
			this._iId = id;

			logger.setSourceLocation( "data/IndexData.ts" , 43 ); logger.assert(pIndexBuffer.byteLength >= this.byteLength + this.byteOffset, "out of buffer limits."); ;
		}


		getData(iOffset:  number , iSize:  number ): ArrayBuffer {
			logger.setSourceLocation( "data/IndexData.ts" , 48 ); logger.assert(iOffset + iSize <= this.byteLength, "out of buffer limits"); ;
			var pBuffer: Uint8Array = new Uint8Array(iSize);

			if (this._pIndexBuffer.readData(this.byteOffset + iOffset, iSize, pBuffer)) {
				return pBuffer.buffer;
			}

			logger.setSourceLocation( "data/IndexData.ts" , 55 ); logger.error("cannot read data from index buffer"); ;

			return null;
		}

		setData(pData: ArrayBufferView, iOffset:  number  = 0, iCount:  number  = pData.byteLength / this.bytesPerIndex): bool {
			logger.setSourceLocation( "data/IndexData.ts" , 61 ); logger.assert((iOffset + iCount) * this.bytesPerIndex <= this.byteLength, "out of buffer limits."); ;

			return this._pIndexBuffer.writeData(
				pData,
				this.byteOffset + iOffset * this.bytesPerIndex,
				iCount * this.bytesPerIndex);
		}

		destroy(): void {
			this._pIndexBuffer = null;
			this._iOffset = undefined;
			this._iLength = undefined;
			this._eElementsType = undefined;
			this._eElementsType = undefined;
		}

		/**@inline*/  getPrimitiveType(): EPrimitiveTypes {
			return this._ePrimitiveType;
		}

		/**@inline*/  getPrimitiveCount(iIndexCount:  number  = this.length):  number  {
			return IndexData.getPrimitiveCount(this._ePrimitiveType, iIndexCount);
		}

		/**@inline*/  getBufferHandle():  number  {
			return this._pIndexBuffer.resourceHandle;
		}

		static getPrimitiveCount(eType: EPrimitiveTypes, nVertices:  number ):  number  {
			switch (eType) {
	            case EPrimitiveTypes.POINTLIST:
	                return nVertices;
	            case EPrimitiveTypes.LINELIST:
	            	return nVertices / 2;
	            case EPrimitiveTypes.LINESTRIP:
	            	return nVertices - 1;
	            case EPrimitiveTypes.LINELOOP:
	            	return nVertices;
	            case EPrimitiveTypes.TRIANGLELIST:
	                return nVertices / 3;
	            case EPrimitiveTypes.TRIANGLEFAN:
	            case EPrimitiveTypes.TRIANGLESTRIP:
	            	return nVertices - 2;
	        }

	        logger.setSourceLocation( "data/IndexData.ts" , 106 ); logger.error("unhandled case detected.."); ;

	        return 0;
		}
	}
}



module akra.core.pool.resources {

	interface IBufferHole {
		start:  number ;
		end:  number ;
	}

	export class IndexBuffer extends HardwareBuffer implements IIndexBuffer {
		/**@protected*/  _pIndexDataArray: IIndexData[] = [];
		/**@protected*/  _iDataCounter:  number  = 0;

		/**@inline*/  get length():  number  {
			return this._pIndexDataArray.length;
		}

/*pManager: IResourcePoolManager*/
		constructor (                                  ) {
/*pManager*/
			super(            );

		}

		create(iByteSize:  number , iFlags?:  number , pData?: Uint8Array): bool;
		create(iByteSize:  number , iFlags?:  number , pData?: ArrayBufferView): bool;
		create(iByteSize:  number , iFlags?:  number , pData?: any): bool {
			super.create(iFlags || 0);

			if ( (((iFlags) & (EHardwareBufferFlags.BACKUP_COPY)) != 0) ) {
				this._pBackupCopy = new MemoryBuffer();
				this._pBackupCopy.create(iByteSize);
				this._pBackupCopy.writeData(pData, 0, iByteSize);
			}

			return true;
		}

		destroy(): void {
			super.destroy();

			this._pBackupCopy.destroy();
			this.freeIndexData();

			this._iDataCounter = 0;
		}

		getIndexData(iOffset:  number , iCount:  number , ePrimitiveType: EPrimitiveTypes, eElementsType: EDataTypes): IIndexData {
			var pIndexData: IIndexData = new data.IndexData(this, this._iDataCounter ++, iOffset, iCount, ePrimitiveType, eElementsType);
			this._pIndexDataArray.push(pIndexData);
			return pIndexData;
		}

		getEmptyIndexData(iCount:  number , ePrimitiveType: EPrimitiveTypes, eElementsType: EDataTypes): IIndexData {
			var pHole: IBufferHole[] = new Array();
			var i:  number ;
			var pIndexData: IIndexData;

			pHole[0] = {start: 0, end: this.byteLength};

//console.log(pHole[0].end);
			for(var k:  number  = 0; k < this._pIndexDataArray.length; ++ k) {

				pIndexData = this._pIndexDataArray[k];

				for (i = 0; i < pHole.length; i ++) {
//console.log("pHole:",pHole[i].start,pHole[i].end);
//Полностью попадает внутрь
					if (pIndexData.byteOffset > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength < pHole[i].end) {
						var iTemp:  number  = pHole[i].end;

						pHole[i].end = pIndexData.byteOffset;
						pHole.splice(i + 1, 0, {start: pIndexData.byteOffset + pIndexData.byteLength, end: iTemp});

						i--;
					}
					else if(pIndexData.byteOffset == pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength < pHole[i].end) {
						pHole[i].start = pIndexData.byteOffset + pIndexData.byteLength;
					}
					else if(pIndexData.byteOffset > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength == pHole[i].end) {

					}
					else if(pIndexData.byteOffset == pHole[i].start && pIndexData.byteLength == (pHole[i].end - pHole[i].start)) {
						pHole.splice(i, 1);
						i--;
					}
//Перекрывает снизу
					else if(pIndexData.byteOffset<pHole[i].start &&
						pIndexData.byteOffset + pIndexData.byteLength > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength < pHole[i].end) {
						pHole[i].start = pIndexData.byteOffset + pIndexData.byteLength;
					}
					else if(pIndexData.byteOffset < pHole[i].start &&
						pIndexData.byteOffset + pIndexData.byteLength > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength == pHole[i].end) {
						pHole.splice(i, 1);
						i--;
					}
//Перекрывается сверху
					else if(pIndexData.byteOffset + pIndexData.byteLength>pHole[i].end &&
						pIndexData.byteOffset > pHole[i].start && pIndexData.byteOffset < pHole[i].end) {
						pHole[i].end = pIndexData.byteOffset;
					}
					else if(pIndexData.byteOffset + pIndexData.byteLength > pHole[i].end &&
						pIndexData.byteOffset == pHole[i].start && pIndexData.byteOffset < pHole[i].end) {
						pHole.splice(i, 1);
						i--;
					}
//полнстью перекрывает
					else if(pIndexData.byteOffset < pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength > pHole[i].end) {
						i--;
					}
				}
			}

			pHole.sort((a: IBufferHole, b: IBufferHole): number => ((a.end - a.start) - (b.end - b.start)));

			for (i = 0; i < pHole.length; i ++) {
				if((pHole[i].end - pHole[i].start) >= iCount * getTypeSize(eElementsType)) {
					pIndexData = new data.IndexData(this, this._iDataCounter ++, pHole[i].start, iCount, ePrimitiveType, eElementsType);

					this._pIndexDataArray.push(pIndexData);

					return pIndexData;
				}
			}

			return null;
		}

		freeIndexData(): bool;
		freeIndexData(pIndexData?: IIndexData): bool {
			if(arguments.length == 0) {
				for(var i:  number  = 0; i < this._pIndexDataArray.length; i ++) {
					this._pIndexDataArray[Number(i)].destroy();
				}

				this._pIndexDataArray = null;
			}
			else {
				for (var i:  number  = 0; i < this._pIndexDataArray.length; i ++) {
					if(this._pIndexDataArray[i] == pIndexData) {
						pIndexData.destroy();

						this._pIndexDataArray.splice(i,1);
						this.notifyAltered();
						return true;
					}
				}

				return false;
			}

			this.notifyAltered();
			return true;
		}

		allocateData(ePrimitiveType: EPrimitiveTypes, eElementsType: EDataTypes, pData: ArrayBufferView): IIndexData {
			var pIndexData: IIndexData;
		    var iCount:  number  = pData.byteLength / getTypeSize(eElementsType);

		    logger.setSourceLocation( "core/pool/resources/IndexBuffer.ts" , 164 ); logger.assert(iCount === math.floor(iCount), "data size should be a multiple of the vertex declaration"); ;

		    pIndexData = this.getEmptyIndexData(iCount, ePrimitiveType, eElementsType);
		    pIndexData.setData(pData);

		    return pIndexData;
		}

	}
}







module akra.webgl {

	interface IBufferHole {
		start:  number ;
		end:  number ;
	}

	export class WebGLIndexBuffer extends core.pool.resources.IndexBuffer implements IIndexBuffer {
		/**@protected*/  _iByteSize:  number ;
		/**@protected*/  _pWebGLBuffer: WebGLBuffer;

		private _pLockData: Uint8Array = null;

		/**@inline*/  get byteLength():  number  { return this._iByteSize; }

/*pManager: IResourcePoolManager*/
		constructor (                                  ) {
/*pManager*/
			super(            );
		}

		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: Uint8Array = null): bool;
		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: ArrayBufferView = null): bool;
		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: any = null): bool {

			iByteSize = math.max(iByteSize,  1024 );

			if ( (((iFlags) & (EHardwareBufferFlags.READABLE)) != 0) ) {
	            ((iFlags) |= (EHardwareBufferFlags.BACKUP_COPY)) ;
	        }

			super.create(iByteSize, iFlags, pData);

			var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
		    var i:  number ;

		    logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 45 ); logger.assert(this._pWebGLBuffer == null, "webgl buffer already allocated"); ;

			this._iByteSize = iByteSize;
		    this._iFlags = iFlags;
		    pWebGLContext = pWebGLRenderer.getWebGLContext();

		    logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 51 ); logger.assert(pWebGLContext !== null, "cannot grab webgl context"); ;

//Софтварного рендеринга буфера у нас нет
		    logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 54 ); logger.assert(!this.isSoftware(), "no sftware rendering"); ;

//Если есть локальная копия то буфер можно читать
		    if (this.isBackupPresent()) {
		        ((this._iFlags) |= (EHardwareBufferFlags.READABLE)) ;
		    }

			logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 62 ); logger.assert(!pData || pData.byteLength <= iByteSize, "Размер переданного массива больше переданного размера буфера");
                                                                                                                         ;


		    this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();

		    if (!this._pWebGLBuffer) {
		        logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 68 ); logger.criticalError("cannot create WebGL index buffer"); ;

		        this.destroy();
		        return false;
		    }

		    pWebGLRenderer.bindWebGLBuffer( 0x8893 , this._pWebGLBuffer);
		    pWebGLContext.bufferData( 0x8893 , this._iByteSize, getWebGLUsage(this._iFlags));

		    if (pData) {
		        pWebGLContext.bufferSubData(
		        	0x8893 , 0, isArrayBuffer(pData)? pData: pData.buffer);
		    }

		    return true;
		}

		destroy(): void {
			super.destroy();

			var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getEngine().getRenderer();

			pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);

			this._pWebGLBuffer = null;
			this._iByteSize = 0;
		}

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;
		readData(iOffset: any, iSize?: any, ppDest?: any): bool {
			logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 99 ); logger.assert(!isNull(this._pWebGLBuffer), "WebGL buffer not exists"); ;

		    if (!this.isBackupPresent()) {
		    	return false;
		    }

			if (arguments.length === 1) {
				this._pBackupCopy.readData(arguments[0]);
			}
			else {
				this._pBackupCopy.readData(iOffset, iSize, ppDest);
			}

		    return true;
		}

		writeData(pData: Uint8Array, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: ArrayBufferView, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: any, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool {

			logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 119 ); logger.assert(!isNull(this._pWebGLBuffer), "WebGL buffer not exists"); ;

		    var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getEngine().getRenderer();
		    var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

		    pWebGLRenderer.bindWebGLBuffer( 0x8893 , this._pWebGLBuffer);

			logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 126 ); logger.assert(pData.byteLength <= iSize, "Размер переданного массива больше переданного размера"); ;
			logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 127 ); logger.assert(this.byteLength >= iOffset + iSize, "Данные выйдут за предел буфера"); ;

			var pU8Data: Uint8Array = null;

			if (isArrayBuffer(pData)) {
				pU8Data = new Uint8Array(pData);
			}
			else {
				pU8Data = new Uint8Array(pData.buffer, pData.byteOffset, pData.byteLength);
			}

			pU8Data = pU8Data.subarray(0, iSize);

			pWebGLContext.bufferSubData( 0x8893 , iOffset, pU8Data);

			if (this.isBackupPresent()) {
		        this._pBackupCopy.writeData(pU8Data, iOffset);
		    }

		    this.notifyAltered();

			return true;
		}

		resize(iSize:  number ): bool {
			var eUsage:  number ;
			var pData: Uint8Array;
			var iMax:  number  = 0;
			var pIndexData: IIndexData;

		    var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getEngine().getRenderer();
		    var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			if(this.isBackupPresent()) {
				return false;
			}

			if(iSize < this.byteLength) {
				for(var k:  number  = 0; k < this._pIndexDataArray.length; ++ k) {
					pIndexData = this._pIndexDataArray[k];

					if(pIndexData.byteOffset + pIndexData.byteLength > iMax) {
						iMax = pIndexData.byteOffset + pIndexData.byteLength;
					}
				}

				logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 174 ); logger.assert(iMax <= iSize, "Уменьшение невозможно. Страая разметка не укладывается в новый размер");
                                                                                                                                         ;
			}

			if(pWebGLContext.isBuffer(this._pWebGLBuffer)) {
				pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);
			}

			eUsage = getWebGLUsage(this._iFlags);

		    this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();

		    if (!this._pWebGLBuffer) {
		        logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 186 ); logger.criticalError("cannot create WebGL index buffer"); ;

		        this.destroy();
		        return false;
		    }


		    pWebGLRenderer.bindWebGLBuffer( 0x8893 , this._pWebGLBuffer);
			pWebGLContext.bufferData( 0x8893 , iSize, eUsage);

			pData = new Uint8Array(this._iByteSize);

			if (this.readData(pData)) {
				logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 199 ); logger.warning("cannot read data from buffer"); ;
				return false;
			}


			this.writeData(pData, 0, this._iByteSize);
			this._pBackupCopy.resize(iSize);
			this._iByteSize = iSize;

			this.notifyAltered();

			return true;
		}

		/**@inline*/  getWebGLBuffer(): WebGLBuffer {
			return this._pWebGLBuffer;
		}

		/**@protected*/  lockImpl(iOffset:  number , iSize:  number , iLockFlags:  number ): any {
	        var pRetData: Uint8Array = new Uint8Array(iSize);

            this.readData(iOffset, iSize, pRetData);

            this._pLockData = pRetData;

	        return pRetData;
		}

		/**@protected*/  unlockImpl(): void {
			this.writeData(this._pLockData, this._iLockStart, this._iLockSize);
		}

		/**@protected*/  copyBackupToRealImpl(pRealData: Uint8Array, pBackupData: Uint8Array, iLockFlags:  number ): void {
			pRealData.set(pBackupData);
		}
	}
}













module akra.webgl {
	export class WebGLInternalRenderBuffer extends WebGLPixelBuffer {
		/**@protected*/  _pWebGLRenderbuffer: WebGLRenderbuffer = null;

		constructor() {
			super();
		}
		create(iFlags:  number ): bool;
		create(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats, iFlags:  number ): bool;
		create(iWebGLFormat:  number , iWidth:  number , iHeight:  number , bCreateStorage: bool): bool;
		create(): bool {
			if(arguments.length !== 4){
				logger.setSourceLocation( "webgl/WebGLInternalRenderbuffer.ts" , 20 ); logger.criticalError("Invalid number of arguments. For PixelBuffer it must be four"); ;
			}

			var iWebGLFormat:  number  = arguments[0];
			var iWidth:  number  = arguments[1];
			var iHeight:  number  = arguments[2];
			var bCreateStorage: bool = arguments[3];

			var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			super.create(iWidth, iHeight, 1, webgl.getClosestAkraFormat(iWebGLFormat, EPixelFormats.A8R8G8B8), 0);

			this._iWebGLInternalFormat = iWebGLFormat;
			this._pWebGLRenderbuffer = pWebGLRenderer.createWebGLRenderbuffer();

			pWebGLRenderer.bindWebGLRenderbuffer( 0x8D41 , this._pWebGLRenderbuffer);

			if(bCreateStorage) {
				pWebGLContext.renderbufferStorage( 0x8D41 , iWebGLFormat, iWidth, iHeight);
			}

			this.notifyCreated();
			return true;
		}

		destroy(): void {
			super.destroy();
			var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer();

			pWebGLRenderer.deleteWebGLRenderbuffer(this._pWebGLRenderbuffer);
			this._pWebGLRenderbuffer = null;
		}

		_bindToFramebuffer(iAttachment:  number , iZOffset:  number ): void {
			logger.setSourceLocation( "webgl/WebGLInternalRenderbuffer.ts" , 55 ); logger.assert(iZOffset < this._iDepth); ;

			var pWebGLRenderer: IWebGLRenderer = <IWebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			pWebGLContext.framebufferRenderbuffer( 0x8D40 , iAttachment,  0x8D41 , this._pWebGLRenderbuffer);
		}
	}

}

















module akra.core.pool.resources {
	export class DepthBuffer extends ResourcePoolItem implements IDepthBuffer {
		/**@protected*/  _iBitDepth:  number  = 0;
		/**@protected*/  _iWidth:  number  = 0;
		/**@protected*/  _iHeight:  number  = 0;
		/**@protected*/  _isManual: bool = false;
		/**@protected*/  _pAttachedRenderTargetsList: IRenderTarget[] = null;

		constructor() {
            super();
        }

        /**@inline*/  get bitDepth():  number  {
			return this._iBitDepth;
		}

		/**@inline*/  get width():  number  {
			return this._iWidth;
		}

		/**@inline*/  get height():  number  {
			return this._iHeight;
		}

        create(iBitDepth:  number , iWidth:  number , iHeight:  number , isManual: bool): bool {
        	this._iBitDepth = iBitDepth;
        	this._iWidth = iWidth;
        	this._iHeight = iHeight;
        	this._isManual = isManual;
        	this._pAttachedRenderTargetsList = [];

        	this.notifyCreated();

        	return true;
        }

        destroy(): void {
        	this.detachFromAllRenderTargets();
        	this._pAttachedRenderTargetsList = null;
        }

        destroyResource(): bool {
			this.destroy();
			this.notifyDestroyed();
			return true;
		}

        isManual(): bool{
        	return this._isManual;
        }

		isCompatible(pTarget: IRenderTarget): bool {
			if( this._iWidth >= pTarget.width &&
				this._iHeight >= pTarget.height ){
				return true;
			}

			return false;
		}

		_notifyRenderTargetAttached(pTarget: IRenderTarget): void {
			logger.setSourceLocation( "core/pool/resources/DepthBuffer.ts" , 70 ); logger.assert(this._pAttachedRenderTargetsList.indexOf(pTarget) === -1, "RenderTarget alrady has been attached to this DepthBuffer");
                                                                   ;

			this._pAttachedRenderTargetsList.push(pTarget);
		}

		_notifyRenderTargetDetached(pTarget: IRenderTarget): void {
			var index:  number  = this._pAttachedRenderTargetsList.indexOf(pTarget);
			logger.setSourceLocation( "core/pool/resources/DepthBuffer.ts" , 78 ); logger.assert(index !== -1, "Can not detach RenderTarget from DepthBuffer beacuse it hasn`t been attached to it");
                                                                                            ;

			this._pAttachedRenderTargetsList.splice(index, 1);
		}

		/**@protected*/  detachFromAllRenderTargets(): void {
			var i:  number  = 0;
			for(i = 0; i < this._pAttachedRenderTargetsList.length; i++) {
//If we call, detachDepthBuffer, we'll invalidate the iterators
				this._pAttachedRenderTargetsList[i].detachDepthBuffer();
			}

			this._pAttachedRenderTargetsList.clear();
		}
	}
}




































module akra.render {
	export class RenderTexture extends RenderTarget implements IRenderTexture {
		/**@protected*/  _pBuffer: IPixelBuffer = null;
		/**@protected*/  _iZOffset:  number  = 0;

		constructor(pRenderer: IRenderer, pBuffer: IPixelBuffer, iZOffset:  number ){
			super(pRenderer);
			this._pBuffer = pBuffer;
			this._iZOffset = iZOffset;
			this._iWidth = pBuffer.width;
			this._iHeight = pBuffer.height;
			this._iColorDepth = pixelUtil.getNumElemBits(pBuffer.format);
		}

		destroy(): void {
			this._pBuffer._clearRTT(this._iZOffset);
			this._pBuffer = null;
		}

		/**@inline*/  suggestPixelFormat(): EPixelFormats {
			return this._pBuffer.format;
		}

		copyContentsToMemory(pDest: IPixelBox, eBuffer: EFramebuffer): void {
			if(eBuffer === EFramebuffer.AUTO){
				eBuffer = EFramebuffer.FRONT;
			}

			if(eBuffer !== EFramebuffer.FRONT) {
				logger.setSourceLocation( "render/RenderTexture.ts" , 41 ); logger.criticalError("Invalid buffer."); ;
			}

			this._pBuffer.blitToMemory(pDest);
		}
	}
}













module akra.webgl {
	export class WebGLRenderTexture extends render.RenderTexture {
		/**@protected*/  _pFrameBuffer: WebGLInternalFrameBuffer = null;

		constructor(pRenderer: IRenderer, pTarget: IPixelBuffer){
			super(pRenderer, pTarget, 0);
			this._pFrameBuffer = new WebGLInternalFrameBuffer(pRenderer);

			this._pFrameBuffer.bindSurface( 0x8CE0 , pTarget);

			this._iWidth = this._pFrameBuffer.width;
			this._iHeight = this._pFrameBuffer.height;

		}

		destroy(): void {
			super.destroy();
		}

		requiresTextureFlipping(): bool {
			return true;
		}

		getCustomAttribute(sName: string): any {
			if(sName === "FBO") {
				return this._pFrameBuffer;
			}
		}

		swapBuffers(): void {
			this._pFrameBuffer.swapBuffers();
		}

		attachDepthBuffer(pDepthBuffer: IDepthBuffer): bool {
			var bResult: bool = false;
			bResult = super.attachDepthBuffer(pDepthBuffer);

			if(bResult){
				this._pFrameBuffer.attachDepthBuffer(pDepthBuffer);
			}

			return bResult;
		}

		attachDepthPixelBuffer(pBuffer: IPixelBuffer): bool {
			var bResult: bool = false;

			bResult = super.attachDepthPixelBuffer(pBuffer);
			if(bResult) {
				if(pBuffer.format !== EPixelFormats.DEPTH_BYTE){
					this.detachDepthPixelBuffer();
					return false;
				}

				this._pFrameBuffer.bindSurface( 0x8D00 , pBuffer);
				(<WebGLPixelBuffer>pBuffer).addRef();
			}

			return bResult;

		}

		detachDepthPixelBuffer(): void {
			this._pFrameBuffer.unbindSurface( 0x8D00 );
			(<WebGLPixelBuffer>this._pDepthPixelBuffer).release();
			super.detachDepthPixelBuffer();
		}

		detachDepthBuffer(): void {
			this._pFrameBuffer.detachDepthBuffer();
			super.detachDepthBuffer();
		}
	}
}















module akra.webgl {
	export interface IWebGLAttachments {
		[webGLAttachment:  number ] : WebGLPixelBuffer;
	}

	export class WebGLInternalFrameBuffer {
		private _pWebGLRenderer: WebGLRenderer = null;
		private _pWebGLFramebuffer: WebGLFramebuffer = null;
		private _pAttachments: IWebGLAttachments = null;

		constructor(pWebGLRenderer: IRenderer) {
			this._pWebGLRenderer = <WebGLRenderer>pWebGLRenderer;

			this._pWebGLFramebuffer = this._pWebGLRenderer.createWebGLFramebuffer();
			this._pAttachments = <IWebGLAttachments>{};

			for(var i:  number  = 0; i < webgl.maxColorAttachments; i++) {
				this._pAttachments[ 0x8CE0  + i] = null;
			}

			this._pAttachments[ 0x8D00 ] = null;
			this._pAttachments[ 0x8D20 ] = null;
			this._pAttachments[ 0x821A ] = null;
		}

		destroy(): void {
			this._pWebGLRenderer.deleteWebGLFramebuffer(this._pWebGLFramebuffer);
			this._pWebGLFramebuffer = null;
		}

		/**@inline*/  get width():  number  {
        	return this._pAttachments[ 0x8CE0 ].width;
		}

		/**@inline*/  get height():  number  {
			return this._pAttachments[ 0x8CE0 ].height;
		}

		/**@inline*/  get format():  number  {
			return this._pAttachments[ 0x8CE0 ].format;
		}

		/**@inline*/  getColorAttachment(iAttachment:  number ): WebGLPixelBuffer {
			return this._pAttachments[ 0x8CE0  + iAttachment];
		}

		/**@inline*/  getAttachment(iWebGLAttachment:  number ): WebGLPixelBuffer {
			return this._pAttachments[iWebGLAttachment];
		}

		bindSurface(iWebGLAttachment:  number , pSurface: IPixelBuffer): void {
			if(!isDef(this._pAttachments[iWebGLAttachment])){
				return;
			}
			this.releaseAttachment(iWebGLAttachment);
			this._pAttachments[iWebGLAttachment] = <WebGLPixelBuffer>pSurface;
			if(this.checkAttachment(iWebGLAttachment)){
				this.bind();
				(<WebGLPixelBuffer>pSurface)._bindToFramebuffer(iWebGLAttachment, 0);
				(<WebGLPixelBuffer>pSurface).addRef();
			}
		}

		unbindSurface(iWebGLAttachment:  number ): void {
			if(!isDef(this._pAttachments[iWebGLAttachment])){
				return;
			}
			var pWebGLContext: WebGLRenderingContext = this._pWebGLRenderer.getWebGLContext();
			this.releaseAttachment(iWebGLAttachment);
			this._pAttachments[iWebGLAttachment] = null;
			pWebGLContext.framebufferRenderbuffer( 0x8D40 , iWebGLAttachment,
									  			  0x8D41 , null);
		}

		/**@inline*/  bindColorSurface(iAttachment:  number , pSurface: IPixelBuffer): void {
			this.bindSurface( 0x8CE0  + iAttachment, pSurface);
		}

		/**@inline*/  bind(): void {
			this._pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , this._pWebGLFramebuffer);
		}

		attachDepthBuffer(pDepthBuffer: IDepthBuffer): void {
			if(!isNull(pDepthBuffer)) {
				var pDepthRenderBuffer: WebGLInternalRenderBuffer = (<WebGLDepthBuffer>pDepthBuffer).depthBuffer;
				var pStencilRenderBuffer: WebGLInternalRenderBuffer = (<WebGLDepthBuffer>pDepthBuffer).stencilBuffer;

				if(!isNull(pDepthRenderBuffer)){
					pDepthRenderBuffer._bindToFramebuffer( 0x8D00 , 0);
					this.releaseAttachment( 0x8D00 );
					this._pAttachments[ 0x8D00 ] = pDepthRenderBuffer;
					pDepthRenderBuffer.addRef();
				}

				if(!isNull(pStencilRenderBuffer)){
					pStencilRenderBuffer._bindToFramebuffer( 0x8D20 , 0);
					this.releaseAttachment( 0x8D20 );
					this._pAttachments[ 0x8D20 ] = pStencilRenderBuffer;
					pDepthRenderBuffer.addRef();
				}

				if( !this.checkAttachment( 0x8D00 ) ||
					!this.checkAttachment( 0x8D20 ) ) {
					logger.setSourceLocation( "webgl/WebGLInternalFrameBuffer.ts" , 117 ); logger.error("Invalid frame buffer depthbuffer attachment. Wrong size."); ;
					return;
				}

			}
			else {
				var pWebGLContext: WebGLRenderingContext = this._pWebGLRenderer.getWebGLContext();

				pWebGLContext.framebufferRenderbuffer( 0x8D40 ,  0x8D00 ,
										  			  0x8D41 , null);

				pWebGLContext.framebufferRenderbuffer( 0x8D40 ,  0x8D20 ,
										  			  0x8D41 , null);

				this.releaseAttachment( 0x8D00 );
				this.releaseAttachment( 0x8D20 );
				this._pAttachments[ 0x8D00 ] = null;
				this._pAttachments[ 0x8D20 ] = null;
			}
		}

		detachDepthBuffer(): void {
			var pWebGLContext: WebGLRenderingContext = this._pWebGLRenderer.getWebGLContext();

			this._pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , this._pWebGLFramebuffer);

			pWebGLContext.framebufferRenderbuffer( 0x8D40 ,  0x8D00 ,
									  			  0x8D41 , null);

			pWebGLContext.framebufferRenderbuffer( 0x8D40 ,  0x8D20 ,
									  			  0x8D41 , null);

			this.releaseAttachment( 0x8D00 );
			this.releaseAttachment( 0x8D20 );
			this._pAttachments[ 0x8D00 ] = null;
			this._pAttachments[ 0x8D20 ] = null;
		}

		swapBuffers(): void {

		}

		private checkAttachment(iWebGLAttachment:  number ): bool{
			if(iWebGLAttachment ===  0x8CE0 ){
				var isOk: bool = true;

				for(var i:  number  = 1; i < webgl.maxColorAttachments; i++) {
					isOk = this.checkAttachment( 0x8CE0  + i);
					if(!isOk) return false;
				}

				isOk = this.checkAttachment( 0x8D00 );
				if(!isOk) return false;
				isOk = this.checkAttachment( 0x8D20 );
				if(!isOk) return false;
				isOk = this.checkAttachment( 0x821A );
				if(!isOk) return false;

				return true;
			}
			else {
				var pBuffer: IPixelBuffer = this._pAttachments[iWebGLAttachment];
				if(isNull(pBuffer)) return true;

				if(this.width === 0 && this.height === 0) return true;

				if(this.width !== pBuffer.width && this.height !== pBuffer.height) return false;

				if(iWebGLAttachment >  0x8CE0  &&
				   iWebGLAttachment <  0x8CE0  + webgl.maxColorAttachments) {

					if (!isNull(this._pAttachments[ 0x8CE0 ]) &&
						this.format !== pBuffer.format) return false;
				}

				return true;
			}
		}

		private  /**@inline*/  releaseAttachment(iWebGLAttachment): void {
			if(!isNull(this._pAttachments[iWebGLAttachment])){
				this._pAttachments[iWebGLAttachment].release();
			}
		}
	}
}



module akra.webgl {
	export class WebGLDepthBuffer extends core.pool.resources.DepthBuffer {
		/**@protected*/  _pDepthBuffer: WebGLInternalRenderBuffer = null;
		/**@protected*/  _pStencilBuffer: WebGLInternalRenderBuffer = null;

		constructor() {
			super();
		}

		/**@inline*/  get depthBuffer(): WebGLInternalRenderBuffer {
			return this._pDepthBuffer;
		}

		/**@inline*/  get stencilBuffer(): WebGLInternalRenderBuffer {
			return this._pStencilBuffer;
		}

		create(iBitDepth:  number , iWidth:  number , iHeight:  number , bManual: bool): bool;
		create(pDepth: WebGLInternalRenderBuffer, pStencil: WebGLInternalRenderBuffer,
			   iWidth:  number , iHeight:  number , isManual: bool): bool;
		create(): bool {
			if(arguments.length !== 5){
				logger.setSourceLocation( "webgl/WebGLDepthBuffer.ts" , 30 ); logger.criticalError("Invalid number of arguments. For WebGLDepthBuffer it must be five"); ;
			}

			super.create(0, arguments[2], arguments[3], arguments[4]);
			var pDepth: WebGLInternalRenderBuffer = arguments[0];
			var pStencil: WebGLInternalRenderBuffer = arguments[1];

			this._pDepthBuffer = pDepth;
			this._pStencilBuffer = pStencil;

			if(!isNull(pDepth)) {
				switch(pDepth._getWebGLFormat()) {
					case  0x81A5 :
						this._iBitDepth = 16;
						break;
					case  0x81A6 :
		            case  0x81A7 :
	            	case  0x88F0 :
	            		if (webgl.hasExtension( "OES_depth24" ) ||
	            			webgl.hasExtension( "OES_depth32" ) ||
	            			webgl.hasExtension( "OES_packed_depth_stencil" )){

	            			this._iBitDepth = 32;
	            		}
	            		break;
				}
			}

			return true;
		}

		destroy(): void {
			super.destroy();

			if(!isNull(this._pStencilBuffer) && this._pStencilBuffer !== this._pDepthBuffer){
				this._pStencilBuffer.release();
			}

			if(!isNull(this._pDepthBuffer)){
				this._pDepthBuffer.release();
			}

			this._pStencilBuffer = null;
			this._pDepthBuffer = null;
		}

		isCompatible(pTarget: IRenderTarget): bool {
			if( this._iWidth >= pTarget.width &&
				this._iHeight >= pTarget.height ){
				return true;
			}

			return false;
		}


	}
}





module akra.core.pool {
//is this class really singleton??
    export class ResourcePoolManager implements IResourcePoolManager {
//all predefined pools
        private pSurfaceMaterialPool: IResourcePool;
        private pEffectPool: IResourcePool;
        private pRenderMethodPool: IResourcePool;
        private pVertexBufferPool: IResourcePool;
        private pIndexBufferPool: IResourcePool;
// private pColladaPool: IResourcePool;
        private pImagePool: IResourcePool;
        private pTexturePool: IResourcePool;
        private pVideoBufferPool: IResourcePool;
        private pShaderProgramPool: IResourcePool;
        private pComponentPool: IResourcePool;
        private pTextureBufferPool: IResourcePool;
        private pRenderBufferPool: IResourcePool;
        private pDepthBufferPool: IResourcePool;

/** Списки пулов по семействам ресурсов */

    	private pResourceFamilyList: IResourcePool[][] = null;
/** Карта пулов по коду ресурса */

    	private pResourceTypeMap: IResourcePool[] = null;
/** Ресурс для ожидания остальных */

    	private pWaiterResource: IResourcePoolItem = null;

        private pEngine: IEngine;

        get surfaceMaterialPool(): IResourcePool { return this.pSurfaceMaterialPool; }
        get effectPool(): IResourcePool { return this.pEffectPool; }
        get renderMethodPool(): IResourcePool { return this.pRenderMethodPool; }
        get vertexBufferPool(): IResourcePool { return this.pVertexBufferPool; }
        get indexBufferPool(): IResourcePool { return this.pIndexBufferPool; }
// get colladaPool(): IResourcePool { return this.pColladaPool; }
        get imagePool(): IResourcePool { return this.pImagePool; }
        get texturePool(): IResourcePool { return this.pTexturePool; }
        get videoBufferPool(): IResourcePool { return this.pVideoBufferPool; }
        get shaderProgramPool(): IResourcePool { return this.pShaderProgramPool; }
        get componentPool(): IResourcePool { return this.pComponentPool; }
        get textureBufferPool(): IResourcePool {return this.pTextureBufferPool; }
        get renderBufferPool(): IResourcePool {return this.pRenderBufferPool; }
        get depthBufferPool(): IResourcePool {return this.pDepthBufferPool; }

    	constructor(pEngine: IEngine) {
//super();

            this.pEngine = pEngine;

    		this.pResourceFamilyList = new Array(EResourceFamilies.TOTAL_RESOURCE_FAMILIES);

    		for (var i = 0; i < EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i++) {
		        this.pResourceFamilyList[i] = new Array();
		    }

		    this.pResourceTypeMap = new Array();
/*this*/
		    this.pWaiterResource = new pool.ResourcePoolItem(        );

            this.createDeviceResource();
    	}

        initialize(): bool {
            this.registerDeviceResources();
            return true;
        }

        destroy(): void {
            this.unregisterDeviceResources();
        }

        registerResourcePool(pCode: IResourceCode, pPool: IResourcePool): void {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 110 ); logger.assert(pCode.family >= 0 && pCode.family < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid code familyi index");
                                             ;

            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 112 ); logger.assert(!isDef(this.pResourceTypeMap[pCode.toNumber()]), "Resource type code already registered"); ;

            this.pResourceTypeMap[pCode.toNumber()] = pPool;
            this.pResourceFamilyList[pCode.family].push(pPool);
        }

    	unregisterResourcePool(pCode: IResourceCode): IResourcePool {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 119 ); logger.assert(pCode.family >= 0, "invalid family index"); ;
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 120 ); logger.assert(pCode.family < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index"); ;

            var iCode = pCode.toNumber();
            var pPool = null;
            if (this.pResourceTypeMap[iCode] != undefined) {
                pPool = this.pResourceTypeMap[iCode];
                delete this.pResourceTypeMap[iCode];
            }

            if (pPool != null) {
                for (var i in this.pResourceFamilyList[pCode.family]) {
                    if (this.pResourceFamilyList[pCode.family][i] == pPool) {
                        delete this.pResourceFamilyList[pCode.family][i];
                        return pPool;
                    }
                }
            }

            return pPool;
        }


        destroyResourceFamily(eFamily: EResourceFamilies): void {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 143 ); logger.assert(eFamily < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index"); ;


            for (var i in this.pResourceFamilyList[eFamily]) {
                this.pResourceFamilyList[eFamily][i].destroyAll();
            }
        }

        restoreResourceFamily(eFamily: EResourceFamilies): void {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 152 ); logger.assert(eFamily >= 0, "invalid family index"); ;
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 153 ); logger.assert(eFamily < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index"); ;

            for (var i in this.pResourceFamilyList[eFamily]) {
                this.pResourceFamilyList[eFamily][i].restoreAll();
            }
        }

        disableResourceFamily(eFamily: EResourceFamilies): void {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 161 ); logger.assert(eFamily >= 0, "invalid family index"); ;
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 162 ); logger.assert(eFamily < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index"); ;

            for (var i in this.pResourceFamilyList[eFamily]) {
                this.pResourceFamilyList[eFamily][i].disableAll();
            }
        }

        cleanResourceFamily(eFamily: EResourceFamilies): void  {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 170 ); logger.assert(eFamily >= 0, "invalid family index"); ;
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 171 ); logger.assert(eFamily < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index"); ;

            for (var i in this.pResourceFamilyList[eFamily]) {
                this.pResourceFamilyList[eFamily][i].clean();
            }
        }

        destroyResourceType(pCode: IResourceCode): void {
            if (isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                this.pResourceTypeMap[pCode.toNumber()].destroyAll();
            }
        }

        restoreResourceType(pCode: IResourceCode): void {
            if (isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                this.pResourceTypeMap[pCode.toNumber()].restoreAll();
            }
        }

        disableResourceType(pCode: IResourceCode): void {
            if (isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                this.pResourceTypeMap[pCode.toNumber()].disableAll();
            }
        }

        cleanResourceType(pCode: IResourceCode): void {
            if (isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                this.pResourceTypeMap[pCode.toNumber()].clean();
            }
        }

        findResourcePool(pCode: IResourceCode): IResourcePool {
            if (isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                return this.pResourceTypeMap[pCode.toNumber()];
            }

            return null;
        }

        findResourceHandle(pCode: IResourceCode, sName: string):  number  {
            var pPool: IResourcePool = this.findResourcePool(pCode);
            var iHandle:  number  = INVALID_INDEX;

            if (!isNull(pPool)) {
                iHandle = pPool.findResourceHandle(sName);
            }

            return iHandle;
        }

        findResource(pCode: IResourceCode, sName: string): IResourcePoolItem;
        findResource(pCode: IResourceCode, iHandle:  number ): IResourcePoolItem;
        findResource(pCode, sName): IResourcePoolItem {
            var pPool: IResourcePool = this.findResourcePool(pCode);
            var pResult: IResourcePoolItem = null;
            var iHandle:  number ;

            if (isString(arguments[1])) {
                iHandle = pPool.findResourceHandle(sName);
            }
            else if (isInt(arguments[1])) {
                iHandle = arguments[1];
            }

            if (pPool != null && iHandle != INVALID_INDEX) {
                pResult = pPool.getResource(iHandle);
            }

            return pResult;
        }

        monitorInitResources(fnMonitor: IResourceWatcherFunc): void {
            var me: IResourcePoolManager = this;

            this.pWaiterResource.setStateWatcher(EResourceItemEvents.LOADED, function () {
                fnMonitor.apply(me, arguments);
            });
        }

        setLoadedAllRoutine(fnCallback: Function): void {
            var pPool: IResourcePool;
            var pResource: IResourcePoolItem;
            var iHandleResource:  number ;
            var pWaiterResouse: IResourcePoolItem = this.pWaiterResource;

            var fnResCallback = function (iFlagBit?:  number , iResourceFlags?:  number , isSetting?: bool) {
                if (iFlagBit == <number>EResourceItemEvents.LOADED && isSetting) {
                    fnCallback();
                }
            };

            pWaiterResouse.notifyLoaded();

            for (var n:  number  = 0; n < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES; n ++) {
                for (var i:  number  = 0; i < ResourcePoolManager.pTypedResourseTotal[n]; i ++) {
                    pPool = this.findResourcePool(new ResourceCode(n, i));

                    if (pPool) {
                        var pResources: IResourcePoolItem[] = pPool.getResources();
                        var pResource: IResourcePoolItem;

                        for (var i:  number  = 0; i < pResources.length; ++ i) {
                            pResource = pResources[i];
                            pWaiterResouse.sync(pResource, EResourceItemEvents.LOADED);
                        }
                    }

                }
            }

            if (pWaiterResouse.isResourceLoaded()) {
                fnCallback();
            }
            else {
                pWaiterResouse.setChangesNotifyRoutine(fnResCallback);
            }
        }

        destroyAll(): void {
            for (var i:  number  = 0; i < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i ++) {
                this.destroyResourceFamily(<EResourceFamilies><number>i);
            }
        }

        restoreAll(): void {
            for (var i:  number  = 0; i < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i ++) {
                this.restoreResourceFamily(<EResourceFamilies><number>i);
            }
        }

        disableAll(): void {
            for (var i:  number  = 0; i < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i ++) {
                this.disableResourceFamily(<EResourceFamilies><number>i);
            }
        }


        clean(): void {
            for (var i:  number  = 0; i < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i ++) {
                this.cleanResourceFamily(<EResourceFamilies><number>i);
            }
        }

        createDeviceResources(): bool {
            return true;
        }

        destroyDeviceResources(): bool {
            this.disableDeviceResources();

// then destroy...
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 322 ); logger.log("Destroying Video Device Resources\n"); ;

            this.destroyResourceFamily(EResourceFamilies.VIDEO_RESOURCE);

            return true;
        }

        restoreDeviceResources(): bool {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 330 ); logger.log("Restoring Video Device Resources\n"); ;
            this.restoreResourceFamily(EResourceFamilies.VIDEO_RESOURCE);
            return true;
        }

        disableDeviceResources(): bool {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 336 ); logger.log("Disabling Video Device Resources\n"); ;
            this.disableResourceFamily(EResourceFamilies.VIDEO_RESOURCE);
            return true;
        }

        /**@inline*/  getEngine(): IEngine { return this.pEngine; }

        /**@inline*/  createRenderMethod(sResourceName: string): IRenderMethod {
            return <IRenderMethod>this.renderMethodPool.createResource(sResourceName);
        }

        /**@inline*/  createTexture(sResourceName: string): ITexture {
            return <ITexture>this.texturePool.createResource(sResourceName);
        }

        /**@inline*/  createEffect(sResourceName: string): IEffect {
            return <IEffect>this.effectPool.createResource(sResourceName);
        }

        /**@inline*/  createSurfaceMaterial(sResourceName: string): ISurfaceMaterial {
            return <ISurfaceMaterial>this.surfaceMaterialPool.createResource(sResourceName);
        }

        /**@inline*/  createVertexBuffer(sResourceName: string): IVertexBuffer {
            return <IVertexBuffer>this.vertexBufferPool.createResource(sResourceName);
        }

        /**@inline*/  createVideoBuffer(sResourceName: string): IVertexBuffer {
            return <IVertexBuffer>this.videoBufferPool.createResource(sResourceName);
        }

        /**@inline*/  createModel(sResourceName: string): IModel {
// return <IModel>this.colladaPool.createResource(sResourceName);   
            return null;
        }

        /**@inline*/  loadModel(sFilename: string, pOptions: any = null): IModel {
// if (util.pathinfo(sFilename).ext.toLowerCase() === "dae") {
//     var pCollada: ICollada = <ICollada>this.colladaPool.findResource(sFilename);

//     if (isNull(pCollada)) {
//         pCollada = <ICollada>this.colladaPool.createResource(sFilename);
//     }

//     if (!pCollada.isResourceLoaded()) {
//         pCollada.loadResource(sFilename, pOptions);
//     }

//     return pCollada;
// }

            return null;
        }



        private createDeviceResource(): void {
            this.pSurfaceMaterialPool = new ResourcePool(this, resources.SurfaceMaterial);
            this.pSurfaceMaterialPool.initialize(16);

            this.pEffectPool = new ResourcePool(this, resources.Effect);
            this.pEffectPool.initialize(16);

            this.pRenderMethodPool = new ResourcePool(this, resources.RenderMethod);
            this.pRenderMethodPool.initialize(16);



// this.pColladaPool = new ResourcePool(this, resources.Collada);
// this.pColladaPool.initialize(0);

            this.pImagePool = new ResourcePool(this, resources.Img);
            this.pImagePool.initialize(16);


            this.pTexturePool = new ResourcePool(this, webgl.WebGLInternalTexture);
            this.pTexturePool.initialize(16);

            this.pIndexBufferPool = new ResourcePool(this, webgl.WebGLIndexBuffer);
            this.pIndexBufferPool.initialize(16);

            this.pVertexBufferPool = new ResourcePool(this, webgl.WebGLVertexBuffer);
            this.pVertexBufferPool.initialize(16);

            this.pVideoBufferPool = new ResourcePool(this, webgl.WebGLVertexTexture);
            this.pVideoBufferPool.initialize(16);

            this.pTextureBufferPool = new ResourcePool(this, webgl.WebGLTextureBuffer);
            this.pTextureBufferPool.initialize(16);

            this.pShaderProgramPool = new ResourcePool(this, webgl.WebGLShaderProgram);
            this.pShaderProgramPool.initialize(16);

            this.pRenderBufferPool = new ResourcePool(this, webgl.WebGLInternalRenderBuffer);
            this.pRenderBufferPool.initialize(16);

            this.pDepthBufferPool = new ResourcePool(this, webgl.WebGLDepthBuffer);
            this.pDepthBufferPool.initialize(16);



            this.pComponentPool = new ResourcePool(this, resources.Component);
            this.pComponentPool.initialize(16);
        }

        private registerDeviceResources(): void {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 444 ); logger.log("Registering Video Device Resources\n"); ;
            this.pTexturePool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.TEXTURE_RESOURCE));
            this.pVertexBufferPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.VERTEXBUFFER_RESOURCE));
            this.pIndexBufferPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.INDEXBUFFER_RESOURCE));
            this.pEffectPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.EFFECT_RESOURCE));
            this.pRenderMethodPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.RENDERMETHOD_RESOURCE));
// this.pColladaPool.registerResourcePool(
//     new ResourceCode(
//         <number>EResourceFamilies.VIDEO_RESOURCE,
//         <number>EVideoResources.MODEL_RESOURCE));
            this.pImagePool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.IMAGE_RESOURCE));
            this.pSurfaceMaterialPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.SURFACEMATERIAL_RESOURCE));
            this.pVideoBufferPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.VIDEOBUFFER_RESOURCE));
            this.pShaderProgramPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.SHADERPROGRAM_RESOURCE));
            this.pComponentPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.COMPONENT_RESOURCE));
        }

        private unregisterDeviceResources(): void {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 492 ); logger.log("Unregistering Video Device Resources"); ;

            this.pTexturePool.unregisterResourcePool();
            this.pVertexBufferPool.unregisterResourcePool();
            this.pIndexBufferPool.unregisterResourcePool();
            this.pEffectPool.unregisterResourcePool();
            this.pRenderMethodPool.unregisterResourcePool();
// this.pColladaPool.unregisterResourcePool();
            this.pImagePool.unregisterResourcePool();
            this.pSurfaceMaterialPool.unregisterResourcePool();
            this.pVideoBufferPool.unregisterResourcePool();
            this.pShaderProgramPool.unregisterResourcePool();
            this.pComponentPool.unregisterResourcePool();
        }

    	static private pTypedResourseTotal:  number [] = [
	        <number>EVideoResources.TOTAL_VIDEO_RESOURCES,
	        <number>EAudioResources.TOTAL_AUDIO_RESOURCES,
	        <number>EGameResources.TOTAL_GAME_RESOURCES
	    ];
    }
}
















module akra {
	export interface IScene2d extends IScene {

	}
}





















// #include "OcTree.ts"
// #include "LightGraph.ts"












module akra {
	export interface IMesh {} ;

	export interface ISceneModel extends ISceneObject {
		mesh: IMesh;

	}
}















module akra {
	export interface INode {} ;
	export interface IJoint {} ;

	export interface IJointMap{
		[index: string]: IJoint;
	}



	export interface ISkeleton {
		 totalBones:  number ;
		 totalNodes:  number ;
		 name: string;
		 root: IJoint;

		getRootJoint(): IJoint;
		getRootJoints(): IJoint[];
		getJointMap(): IJointMap;
		getNodeList(): ISceneNode[];
		addRootJoint(pJoint: IJoint): bool;
		update(): bool;
		findJoint(sName: string): IJoint;
		findJointByName(sName: string): IJoint;
		attachMesh(pMesh: IMesh): bool;
		detachMesh(): void;

	}
}



















module akra {

	export interface IRect3d {} ;
	export interface IMesh {} ;
	export interface ISkin {} ;
	export interface IRenderData {} ;

	export interface IMeshSubset extends IEventProvider, IRenderableObject {
		name: string;

		 mesh: IMesh;
		 skin: ISkin;
		 data: IRenderData;
		 boundingBox: IRect3d;
         boundingSphere: ISphere;

		createBoundingBox(): bool;
		deleteBoundingBox(): bool;
		showBoundingBox(): bool;
		hideBoundingBox(): bool;

		createBoundingSphere(): bool;
		deleteBoundingSphere(): bool;
		showBoundingSphere(): bool;
		hideBoundingSphere(): bool;

		computeNormals(): void;
		computeTangents(): void;
		computeBinormals(): void;

		isSkinned(): bool;
		getSkin(): ISkin;
		setSkin(pSkin: ISkin): bool;

/** @deprecated */

		applyFlexMaterial(csMaterial: string, pMaterial?: IMaterial): bool;
/** @deprecated */

		getFlexMaterial(iMaterial:  number ): IMaterial;
/** @deprecated */

		getFlexMaterial(csName: string): IMaterial;
/** @deprecated */

		setFlexMaterial(iMaterial:  number ): bool;
/** @deprecated */

		setFlexMaterial(csName: string): bool;

		show(): void;
		hide(): void;

		destroy(): void;
	}
}






module akra {
	export interface ISkeleton {} ;
	export interface INode {} ;
	export interface IMesh {} ;
	export interface IEngine {} ;
	export interface INodeMap {} ;
	export interface IMat4 {} ;
	export interface IVertexData {} ;

// export interface INodeMap {
// 	[index: string]: INode;
// }

	export interface ISkin {
		 data: IRenderDataCollection;
		 skeleton: ISkeleton;
		 totalBones:  number ;

/**
		 * Set binding matrix. 
		 * @see <bind_shape_matrix> in Collada.
		 */

		setBindMatrix(m4fMatrix: IMat4): void;

/**
		 * @see <bind_shape_matrix> in Collada.
		 */

		getBindMatrix(): IMat4;

/**
		 * Bone offset matrices.
		 * @see Bone offset matrices in Collada.
		 */

		getBoneOffsetMatrices(): IMat4[];
		getBoneOffsetMatrix(sBoneName: string): IMat4;
		setBoneOffsetMatrices(pMatrices: IMat4[]): void;

		setSkeleton(pSkeleton: ISkeleton): bool;

/**
		 * Make a skin dependent on scene node whose names match the
		 * names of the bones that affect the skin.
		 */

		attachToScene(pRootNode: ISceneNode): bool;

// /**
//  * Bind skin to skeleton or scene.
//  */
// bind(pSkeleton: ISkeleton): bool;
// bind(pNode: ISceneNode): bool;

/**
		 * Set names of bones, that affect to skin.
		 */

		setBoneNames(pNames: string[]): bool;


/**
		 * Weights.
		 */

		setWeights(pWeights: Float32Array): bool;
		getWeights(): IVertexData;

/**
		 * разметка влияний на вершины
		 * пары: {число влияний, адресс индексов влияний}
		 */

		getInfluenceMetaData(): IVertexData;
/**
		 * инф. о вляиниях на вершины
		 * пары: {индекс матрицы кости, индекс веса}
		 */

		getInfluences(): IVertexData;
		setIfluences(pInfluencesCount:  number [], pInfluences: Float32Array): bool;

/**
		 * Short way to call setWeights() && setIfluences();
		 */

		setVertexWeights(pInfluencesCount:  number [], pInfluences: Float32Array, pWeights: Float32Array): bool;

/**
		 * Recalculate skin matrices and fill it to video memory.
		 */

		applyBoneMatrices(bForce?: bool): bool;

/**
		 * Is skin ready to use?
		 */

		isReady(): bool;

/**
		 * Data with result matrices.
		 */

		getBoneTransforms(): IVertexData;

/**
		 * Check, is this skin affect to data?
		 */

		isAffect(pData: IVertexData): bool;

/**
		 * Add skin info to data with vertices.
		 */

		attach(pData: IVertexData): void;
	}
}











module akra {
    export interface IVertexBuffer {} ;
    export interface IVertexDeclaration {} ;
    export interface IRenderDataType {} ;
    export interface IBuffer {} ;
    export interface IReferenceCounter {} ;

	export enum ERenderDataBufferOptions {
        VB_READABLE       =  (1 << (EHardwareBufferFlags.BACKUP_COPY)) ,
        RD_ADVANCED_INDEX = < number >ERenderDataOptions.ADVANCED_INDEX,
        RD_SINGLE_INDEX   = < number >ERenderDataOptions.SINGLE_INDEX,
        RD_RENDERABLE     = < number >ERenderDataOptions.RENDERABLE
    };

// export interface IRenderDataType {
//     new (): IRenderData;
// }

/*IHardwareBuffer*/
	export interface IRenderDataCollection extends                    IBuffer, IReferenceCounter {
		 buffer: IVertexBuffer;

        getEngine(): IEngine;
        getOptions():  number ;

        getData(sUsage: string): IVertexData;
        getData(iOffset:  number ): IVertexData;
        getRenderData(iSubset:  number ): IRenderData;
        getEmptyRenderData(ePrimType: EPrimitiveTypes, iOptions:  number ): IRenderData;
        getDataLocation(sSemantics: string):  number ;

        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBufferView, isCommon?: bool):  number ;
        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBuffer, isCommon?: bool):  number ;
        allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBufferView, isCommon?: bool):  number ;
        allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBuffer, isCommon?: bool):  number ;

        destroy(): void;

        _draw(): void;
        _draw(iSubset:  number ): void;

// _setup(eOptions?: int): void;

        _allocateData(pVertexDecl: IVertexDeclaration, iSize:  number ): IVertexData;
        _allocateData(pVertexDecl: IVertexDeclaration, pData: ArrayBufferView): IVertexData;
        _allocateData(pVertexDecl: IVertexDeclaration, pData: ArrayBuffer): IVertexData;
        _allocateData(pDeclData: IVertexElementInterface[], iSize:  number ): IVertexData;
        _allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBufferView): IVertexData;
        _allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBuffer): IVertexData;
	}
}



























module akra.model {

	export class Skin implements ISkin {
		private _pMesh: IMesh;

		private _pSkeleton: ISkeleton = null;

// name of bones/nodes
		private _pNodeNames: string[] = null;

//bind matrix from collada
		private _m4fBindMatrix: IMat4;

//BONE_MATRIX = WORLD_MATRIX x OFFSET_MATRIX
		private _pBoneTransformMatrices: IMat4[]  = null;

/**
		 * Common buffer for all transform matrices.
		 * _pBoneOffsetMatrixBuffer = [_pBoneTransformMatrices[0], ..., _pBoneTransformMatrices[N]]
		 */

		private _pBoneOffsetMatrixBuffer: Float32Array = null;

// bone offset matrices from collada
		private _pBoneOffsetMatrices: IMat4[] = null;

/**
		 * Pointers to nodes, that affect to this skin.
		 */

		private _pAffectingNodes: ISceneNode[] = null;

/**
		 * Format:
		 * BONE_INF_COUNT - number of bones, that influence to the vertex.
		 * BONE_INF_LOC - address of influence, pointer to InfData structire list.
		 * ..., [BONE_INF_COUNT: float, BONE_INF_LOC: float], ...
		 * 
		 */

		private _pInfMetaData: IVertexData = null;

/**
		 * Format:
		 * BONE_INF_DATA - bone matrix address, pointer to BONE_MATRIX list
		 * BONE_WEIGHT_IND - bone weight address, pointer to BONE_WEIGHT list
		 * ..., [BONE_INF_DATA: float, BONE_WEIGHT_IND: float], ...
		 */

		private _pInfData: IVertexData = null;

/**
		 * Format:
		 * ..., [BONE_MATRIX: matrix4], ...
		 */

		private _pBoneTransformMatrixData: IVertexData = null;

/**
		 * Format:
		 * ..., [BONE_WEIGHT: float], ...
		 */

		private _pWeightData: IVertexData = null;

/**
		 * Links to VertexData, that contain meta from this skin.
		 */

		private _pTiedData: IVertexData[] = [];



		/**@inline*/  get data(): IRenderDataCollection {
			return this._pMesh.data;
		}

		/**@inline*/  get skeleton(): ISkeleton{
			return this._pSkeleton;
		}

		/**@inline*/  set skeleton(pSkeleton: ISkeleton) {
			if (isNull(pSkeleton) || pSkeleton.totalBones < this.totalBones) {
				logger.setSourceLocation( "Skin.ts" , 88 ); logger.warning("cannnot set skeletonm because skeleton has to little bones"); ;
		        return;
		    }

		    for (var i:  number  = 0, nMatrices:  number  = this.totalBones; i < nMatrices; i++) {
		        this._pAffectingNodes[i] = pSkeleton.findJoint(this._pNodeNames[i]);
		        logger.setSourceLocation( "Skin.ts" , 94 ); logger.assert(isDefAndNotNull(this._pAffectingNodes[i]), "joint<" + this._pNodeNames[i] + "> must exists..."); ;
		    }


		    this._pSkeleton = pSkeleton;
		}

		/**@inline*/  get totalBones():  number  {
			return this._pNodeNames.length;
		}

		constructor(pMesh: IMesh) {
		    logger.setSourceLocation( "Skin.ts" , 106 ); logger.assert(isDefAndNotNull(pMesh), "you must specify mesh for skin"); ;

		    this._pMesh = pMesh;
		}

		setBindMatrix(m4fMatrix: IMat4): void {
			this._m4fBindMatrix.set(m4fMatrix);
		}

		getBindMatrix(): IMat4 {
			return this._m4fBindMatrix;
		}

		getBoneOffsetMatrices(): IMat4[] {
			return this._pBoneOffsetMatrices;
		}

		getBoneOffsetMatrix(sBoneName: string): IMat4 {
			var pBoneNames: string[] = this._pNodeNames;

			for (var i = 0; i < pBoneNames.length; i++) {
			    if (pBoneNames[i] === sBoneName) {
			        return this._pBoneOffsetMatrices[i];
			    }
			};

			return null;
		}

		setSkeleton(pSkeleton: ISkeleton): bool {
			if (!pSkeleton || pSkeleton.totalBones < this.totalBones) {
			    return false;
			}

			for (var i:  number  = 0, nMatrices = this.totalBones; i < nMatrices; i++) {
			    this._pAffectingNodes[i] = pSkeleton.findJoint(this._pNodeNames[i]);
			    logger.setSourceLocation( "Skin.ts" , 142 ); logger.assert(!isNull(this._pAffectingNodes[i]), "joint<" + this._pNodeNames[i] + "> must exists..."); ;
			}

			this._pSkeleton = pSkeleton;

			return true;
		}

		attachToScene(pRootNode: ISceneNode): bool {
			for (var i:  number  = 0, nMatrices:  number  = this.totalBones; i < nMatrices; i++) {
			    this._pAffectingNodes[i] = <ISceneNode>pRootNode.findEntity(this._pNodeNames[i]);
			    logger.setSourceLocation( "Skin.ts" , 153 ); logger.assert(isDefAndNotNull(this._pAffectingNodes[i]), "node<" + this._pNodeNames[i] + "> must exists..."); ;
			}

			return true;
		}

		setBoneNames(pNames: string[]): bool {
			if (isNull(pNames)) {
				return false;
			}

			this._pNodeNames = pNames;
			this._pAffectingNodes = new Array(pNames.length);

			return true;
		}

		setBoneOffsetMatrices(pMatrices: IMat4[]): void {
			var pMatrixNames: string[] = this._pNodeNames;

			logger.setSourceLocation( "Skin.ts" , 176 ); logger.assert(isDefAndNotNull(pMatrices) && isDefAndNotNull(pMatrixNames) && pMatrixNames.length === pMatrices.length, "number of matrix names must equal matrices data length:\n" + pMatrixNames.length + " / " + pMatrices.length);
                                ;

			var nMatrices:  number  = pMatrixNames.length;
			var pData: IRenderDataCollection = this.data;
			var pMatrixData: Float32Array = new Float32Array(nMatrices * 16);

//FIXME: правильно положить матрицы...			this._pBoneOffsetMatrices = pMatrices;
			this._pBoneTransformMatrixData = pData._allocateData([VE_MAT4("BONE_MATRIX")], pMatrixData);
			this._pBoneTransformMatrices = new Array(nMatrices);

			for (var i:  number  = 0; i < nMatrices; i++) {
			    this._pBoneTransformMatrices[i] = new Mat4(pMatrixData.subarray(i * 16, (i + 1) * 16), true);
			}


			this._pBoneOffsetMatrixBuffer = pMatrixData;
		}

		setWeights(pWeights: Float32Array): bool {
			this._pWeightData = this.data._allocateData([VE_FLOAT("BONE_WEIGHT")], pWeights);

			return this._pWeightData !== null;
		}

		getWeights(): IVertexData {
			return this._pWeightData;
		}

		getInfluenceMetaData(): IVertexData {
			return this._pInfMetaData;
		}

		getInfluences(): IVertexData {
			return this._pInfData;
		}

		setIfluences(pInfluencesCount:  number [], pInfluences: Float32Array): bool {
			logger.setSourceLocation( "Skin.ts" , 213 ); logger.assert(this._pInfMetaData == null && this._pInfData == null, "vertex weights already setuped."); ;
			logger.setSourceLocation( "Skin.ts" , 214 ); logger.assert(!isNull(this.getWeights()), "you must set weight data before setup influences"); ;

			var pData: IRenderDataCollection = this.data;
			var pInfluencesMeta: Float32Array = new Float32Array(pInfluencesCount.length * 2);

			var iInfLoc:  number  = 0;
			var iTransformLoc:  number  = 0;
			var iWeightsLoc:  number  = 0;

//получаем копию массива влияний
			pInfluences = new Float32Array(pInfluences);

//вычисляем адресса матриц транфсормации и весов
			iTransformLoc = this._pBoneTransformMatrixData.byteOffset / EDataTypeSizes.BYTES_PER_FLOAT;
			iWeightsLoc = this._pWeightData.byteOffset / EDataTypeSizes.BYTES_PER_FLOAT;


			for (var i:  number  = 0, n:  number  = pInfluences.length; i < n; i += 2) {
			    pInfluences[i] = pInfluences[i] * 16 + iTransformLoc;
			    pInfluences[i + 1] += iWeightsLoc;
			}

//запоминаем модифицированную информацию о влияниях
			this._pInfData = pData._allocateData([
//адрес матрицы кости			                                         VE_FLOAT('BONE_INF_DATA'),
//адрес весового коэффициента			                                         VE_FLOAT('BONE_WEIGHT_IND')
			                                     ],
			                                     pInfluences);

			iInfLoc = this._pInfData.byteOffset / EDataTypeSizes.BYTES_PER_FLOAT;

//подсчет мета данных, которые укажут, где взять влияния на кость..
			for (var i:  number  = 0, j:  number  = 0, n:  number  = iInfLoc; i < pInfluencesMeta.length; i += 2) {
			    var iCount:  number  = pInfluencesCount[j++];
//число влияний на вершину			    pInfluencesMeta[i] = iCount;
//адресс начала информации о влияниях 			    pInfluencesMeta[i + 1] = n;
//(пары индекс коэф. веса и индекс матрицы)
			    n += 2 * iCount;
			}

//influences meta: разметка влияний
			this._pInfMetaData = pData._allocateData([
//число костей и весов, влияющих на вершину			                                             VE_FLOAT('BONE_INF_COUNT'),
//адресс начала влияний на вершину			                                             VE_FLOAT('BONE_INF_LOC'),
			                                         ], pInfluencesMeta);

			return this._pInfMetaData !== null &&
			       this._pInfData !== null;
		}

		setVertexWeights(pInfluencesCount:  number [], pInfluences: Float32Array, pWeights: Float32Array): bool {
			logger.setSourceLocation( "Skin.ts" , 265 ); logger.assert(arguments.length > 1, 'you must specify all parameters'); ;

//загружаем веса 
			if (pWeights) {
			    this.setWeights(pWeights);
			}

			return this.setIfluences(pInfluencesCount, pInfluences);
		}

		applyBoneMatrices(bForce: bool = false): bool {
			var pData: Float32Array;
			var bResult: bool;
			var pNode: ISceneNode;
			var isUpdated: bool = false;

			for (var i:  number  = 0, nMatrices = this.totalBones; i < nMatrices; ++i) {
			    pNode = this._pAffectingNodes[i];

			    if (pNode.isWorldMatrixNew() || bForce) {
			        pNode.worldMatrix.multiply(this._pBoneOffsetMatrices[i], this._pBoneTransformMatrices[i]);
			        isUpdated = true;
			    }
			}

			if (isUpdated) {
			    pData = this._pBoneOffsetMatrixBuffer;
			    return this._pBoneTransformMatrixData.setData(pData, 0, pData.byteLength);
			}

			return false;
		}

		isReady(): bool {
			return !(isNull(this._pInfMetaData) || isNull(this._pInfData) || isNull(this._pWeightData) ||
			         isNull(this._pBoneOffsetMatrixBuffer) || isNull(this._pBoneOffsetMatrices) ||
			         isNull(this._pNodeNames) ||
			         isNull(this._m4fBindMatrix));
		}

		getBoneTransforms(): IVertexData {
			return this._pBoneTransformMatrixData;
		}

		isAffect(pData: IVertexData): bool {
			if (isDefAndNotNull(pData)) {
			    for (var i:  number  = 0; i < this._pTiedData.length; i++) {
			        if (this._pTiedData[i] === pData) {
			            return true;
			        }
			    }
			}

			return false;
		}

		attach(pData: IVertexData): void {
			logger.setSourceLocation( "Skin.ts" , 323 ); logger.assert(pData.stride === 16, "you cannot add skin to mesh with POSITION: {x, y, z}" + "\nyou need POSITION: {x, y, z, w}");
                                                                         ;

			pData.getVertexDeclaration().append(VE_FLOAT(DeclUsages.BLENDMETA, 12));

			this._pTiedData.push(pData);
		}



		static debugMeshSubset(pSubMesh: IMeshSubset) {
			var pMesh: IMesh = pSubMesh.mesh;
			var pSkin: ISkin = pSubMesh.skin;
			var pMatData: IVertexData = pSkin.getBoneTransforms();
			var pPosData: Float32Array;
			var pEngine: IEngine = pMesh.getEngine();

			pPosData = <Float32Array>(pSubMesh.data._getData("POSITION")).getTypedData(DeclUsages.BLENDMETA);

			var pVideoBuffer: IVertexBuffer = pSubMesh.mesh.data.buffer;
			var iFrom:  number  = 2618, iTo:  number  = 2619;
			var pWeights: Float32Array = <Float32Array>pSkin.getWeights().getTypedData('BONE_WEIGHT');

			logger.setSourceLocation( "Skin.ts" , 345 ); logger.log('===== debug vertices from ', iFrom, 'to', iTo, ' ======'); ;
			logger.setSourceLocation( "Skin.ts" , 346 ); logger.log('transformation data location:', pMatData.byteOffset / 4.); ;
			logger.setSourceLocation( "Skin.ts" , 347 ); logger.log('155 weight: ', pSkin.getWeights().getTypedData('BONE_WEIGHT')[155]); ;
			logger.setSourceLocation( "Skin.ts" , 348 ); logger.log('vertices info ===================>'); ;

			for (var i:  number  = iFrom; i < iTo; i++) {
			    logger.setSourceLocation( "Skin.ts" , 351 ); logger.log(pPosData[i], '<< inf meta location'); ;

			    var pMetaData: Float32Array = new Float32Array(8);
			    if (!pVideoBuffer.readData(4 * pPosData[i], 8, pMetaData)) {
			    	logger.setSourceLocation( "Skin.ts" , 355 ); logger.error("cannot read back meta data"); ;
			    }

			    logger.setSourceLocation( "Skin.ts" , 358 ); logger.log(pMetaData[0], '<< count'); ;
			    logger.setSourceLocation( "Skin.ts" , 359 ); logger.log(pMetaData[1], '<< inf. location'); ;

			    for (var j:  number  = 0; j < pMetaData[0]; ++j) {
			        var pInfData = new Float32Array(8);
			        if (!pVideoBuffer.readData(4 * (pMetaData[1] + 2 * j), 8, pInfData)) {
			        	logger.setSourceLocation( "Skin.ts" , 364 ); logger.error("cannot read influence data"); ;
			        }

			        logger.setSourceLocation( "Skin.ts" , 367 ); logger.log(pInfData[0], '<< matrix location'); ;
			        logger.setSourceLocation( "Skin.ts" , 368 ); logger.log(pInfData[1], '/', pInfData[1] - 30432, '<< weight location / index'); ;

			        var pWeightData = new Float32Array(4);

			        if (!pVideoBuffer.readData(4 * (pInfData[1]), 4, pWeightData)) {
			        	logger.setSourceLocation( "Skin.ts" , 373 ); logger.error("cannot read weight data"); ;
			        }

			        logger.setSourceLocation( "Skin.ts" , 376 ); logger.log(pWeightData[0], '<< weight'); ;

			        var pMatrixData = new Float32Array(4 * 16);
			        if (!pVideoBuffer.readData(4 * (pInfData[0]), 4 * 16, pMatrixData)) {
			        	logger.setSourceLocation( "Skin.ts" , 380 ); logger.error("cannot read matrix data"); ;
			        }

			        logger.setSourceLocation( "Skin.ts" , 383 ); logger.log(pMatrixData.toString()); ;
			    }
			}

			logger.setSourceLocation( "Skin.ts" , 387 ); logger.log('#############################################'); ;

			for (var i:  number  = 0; i < pPosData.length; i++) {
			    var pMetaData: Float32Array = new Float32Array(8);
			    if(!pVideoBuffer.readData(4 * pPosData[i], 8, pMetaData)) {
			    	logger.setSourceLocation( "Skin.ts" , 392 ); logger.error("cannot read meta data"); ;
			    }

			    for (var j:  number  = 0; j < pMetaData[0]; ++j) {
			        var pInfData: Float32Array = new Float32Array(8);

			        if (!pVideoBuffer.readData(4 * (pMetaData[1] + 2 * j), 8, pInfData)) {
			        	logger.setSourceLocation( "Skin.ts" , 399 ); logger.error("cannot read influence data"); ;
			        }

			        var iWeightsIndex:  number  = pInfData[1] - 30432;

			        var fWeightOrigin:  number  = pWeights[iWeightsIndex];
			        var pWeightData:  number  = new Float32Array(4);
			        if (!pVideoBuffer.readData(4 * (pInfData[1]), 4, pWeightData)) {
			        	logger.setSourceLocation( "Skin.ts" , 407 ); logger.error("cannot read weight data"); ;
			        }
			        var fWeight:  number  = pWeightData[0];

			        if (Math.abs(fWeight - fWeightOrigin) > 0.001) {
			            alert("1");
			            logger.setSourceLocation( "Skin.ts" , 413 ); logger.log("weight with index", iWeightsIndex, "has wrong weight", fWeightOrigin, "/", fWeightOrigin); ;
			        }

//var pWeightData: Float32Array = new Float32Array(pVideoBuffer.getData(4 * (pInfData[1]), 4));
//var pMatrixData: Float32Array = new Float32Array(pVideoBuffer.getData(4 * (pInfData[0]), 4 * 16));
			    }
			}

			logger.setSourceLocation( "Skin.ts" , 421 ); logger.log('##############################################'); ;
// var pBoneTransformMatrices = pSkin._pBoneTransformMatrixData;
// var pBonetmData = pBoneTransformMatrices.getTypedData('BONE_MATRIX');

// for (var i = 0; i < pBonetmData.length; i += 16) {
//     LOG('bone transform matrix data >>> ');
//     LOG(Mat4.str(pBonetmData.subarray(i, i + 16)));
// };


//for (var i = 0; i < pMesh.length; i++) {
// var i = pMesh.length - 1;
//     var pPosData = pMesh[i].data.getData('POSITION').getTypedData('POSITION');
//     var pIndData = pMesh[i].data._pIndexData.getTypedData('INDEX0');

//     var j = pIndData[pIndData.length - 1];
//     var j0 = pMesh[i].data.getData('POSITION').byteOffset/4;

//     j -= j0;
//     j/=4;

//     LOG('last index >> ', j);
//     LOG('pos data size', pPosData.length);

//     var pVertex = pPosData.subarray(j * 3, j * 3 + 3);

//     LOG('last vertex in submesh >> ', pVertex[0], pVertex[1], pVertex[2]);

//         var pSceneNode = pEngine.appendMesh(
//             pEngine.pCubeMesh.clone(a.Mesh.GEOMETRY_ONLY|a.Mesh.SHARED_GEOMETRY),
//             pEngine.getRootNode());

//         pSceneNode.setPosition(pVertex);
//         pSceneNode.setScale(0.1);
//     var pMeta = pSkin.getInfluenceMetaData().getTypedData('BONE_INF_COUNT');
//     LOG(pMeta[j], 'count << ');

//};
		}

	}



	export function createSkin(pMesh: IMesh): ISkin {
		return new Skin(pMesh);
	}
}









































module akra {

	export interface IRay2d {} ;

	export interface ISegment2d{
		ray: IRay2d;
		distance:  number ;

		point: IVec2;
		normal: IVec2;
	};
}



module akra.geometry{
	export class Segment2d implements ISegment2d{
		ray: IRay2d;
		distance:  number ;

		constructor(){
			this.ray = new Ray2d();
			this.distance = 0.;
		};

		get point(): IVec2{
			return this.ray.point;
		};
		set point(v2fPoint: IVec2){
			this.ray.point.set(v2fPoint);
		};

		get normal(): IVec2{
			return this.ray.normal;
		};
		set normal(v2fNormal: IVec2){
			this.ray.normal.set(v2fNormal);
		};
	};
}












module akra {

	export interface IRay3d {} ;

	export interface ISegment3d{
		ray: IRay3d;
		distance:  number ;

		point: IVec3;
		normal: IVec3;
	};
}



module akra.geometry{
	export class Segment3d implements ISegment3d{
		ray: IRay3d;
		distance:  number ;

		constructor(){
			this.ray = new Ray3d();
			this.distance = 0.;
		};

		get point(): IVec3{
			return this.ray.point;
		};
		set point(v3fPoint: IVec3){
			this.ray.point.set(v3fPoint);
		};

		get normal(): IVec3{
			return this.ray.normal;
		};
		set normal(v3fNormal: IVec3){
			this.ray.normal.set(v3fNormal);
		};
	};
}































module akra.geometry {
	export function computeBoundingBox(pVertexData: IVertexData, pBoundingBox: IRect3d): bool;
	export function computeDataForCascadeBoundingBox(pBoundingBox: IRect3d, ppVertexes:  number [], ppIndexes:  number [], fMinSize?:  number ): bool;
	export function computeBoundingSphere(pVertexData: IVertexData, pSphere: ISphere, bFastMethod?: bool, pBoundingBox?: IRect3d): bool;
	export function computeBoundingSphereFast(pVertexData: IVertexData, pSphere: ISphere, pBoundingBox: IRect3d = null): bool;
	export function computeBoundingSphereMinimal(pVertexData: IVertexData, pSphere: ISphere): bool;
	export function computeGeneralizingSphere(pSphereA: ISphere, pSphereB: ISphere, pSphereDest?: ISphere): bool;
	export function computeDataForCascadeBoundingSphere(pBoundingSphere: ISphere, ppVertexes:  number [], ppIndexes:  number [], fMinSize?:  number ): bool;

/**
	 * Computes a coordinate-axis oriented bounding box.
	 */

	export function computeBoundingBox (pVertexData, pBoundingBox): bool {
		var fX0:  number  = 0, fY0:  number  = 0, fZ0:  number  = 0,
			fX1:  number  = 0, fY1:  number  = 0, fZ1:  number  = 0;
		var fTemp:  number , pTempData: Float32Array;
		var i:  number  = 0;
		var pVertexDeclaration: IVertexDeclaration, pVertexElement: IVertexElement, pData: ArrayBuffer;
		var nStride:  number , nCount:  number ;


		pVertexDeclaration = pVertexData.getVertexDeclaration();

		if(isNull(pVertexDeclaration))
			return false;

		pVertexElement = pVertexDeclaration.findElement(DeclUsages.POSITION, 3);

		if(isNull(pVertexElement))
			return false;

		nCount = pVertexData.length;
		nStride = pVertexElement.size;

		pData = pVertexData.getData(pVertexElement.offset, pVertexElement.size);

		if (isNull(pData))
			return false;

		pTempData = new Float32Array(pData, 0, 3);
		fX0 = fX1 = pTempData[0];
		fY0 = fY1 = pTempData[1];
		fZ0 = fZ1 = pTempData[2];

		for (i = nStride; i < nStride * nCount; i += nStride) {

			pTempData = new Float32Array(pData, i, 3);
			fTemp = pTempData[0];
//Min			fX0 = fX0 > fTemp ? fTemp : fX0;
//Max			fX1 = fX1 > fTemp ? fX1 : fTemp;

			fTemp = pTempData[1];
//Min			fY0 = fY0 > fTemp ? fTemp : fY0;
//Max			fY1 = fY1 > fTemp ? fY1 : fTemp;

			fTemp = pTempData[2];
//Min			fZ0 = fZ0 > fTemp ? fTemp : fZ0;
//Max			fZ1 = fZ1 > fTemp ? fZ1 : fTemp;
		}

		pBoundingBox.set(fX0,fX1,fY0,fY1,fZ0,fZ1);

	    return true;
	};

/** расчет данных для отрисовки бокса */

	export function computeDataForCascadeBoundingBox(pBoundingBox: IRect3d, ppVertexes:  number [], ppIndexes:  number [], fMinSize:  number  = .25): bool {

		var pInd:  number [];
		var pPoints: IVec3[][];
		var i:  number , j:  number , k:  number ;

		pPoints = new Array(8);

		for(i = 0; i < 8; i ++) {
			pPoints[i] = new Array(4);
			for(j = 0; j < 4; j++)
				pPoints[i][j] = new Vec3(0);
		}

//Выставление точек Rect3d
		pPoints[0][0].set([pBoundingBox.x0,pBoundingBox.y0,pBoundingBox.z0]);
		pPoints[1][0].set([pBoundingBox.x0,pBoundingBox.y1,pBoundingBox.z0]);
		pPoints[2][0].set([pBoundingBox.x0,pBoundingBox.y0,pBoundingBox.z1]);
		pPoints[3][0].set([pBoundingBox.x0,pBoundingBox.y1,pBoundingBox.z1]);
		pPoints[4][0].set([pBoundingBox.x1,pBoundingBox.y0,pBoundingBox.z0]);
		pPoints[5][0].set([pBoundingBox.x1,pBoundingBox.y1,pBoundingBox.z0]);
		pPoints[6][0].set([pBoundingBox.x1,pBoundingBox.y0,pBoundingBox.z1]);
		pPoints[7][0].set([pBoundingBox.x1,pBoundingBox.y1,pBoundingBox.z1]);

		var fTempFunc = function(pPoints: IVec3[][], iPoint:  number , iToPoint1:  number , iToPoint2:  number , iToPoint3:  number ): void {
			for(var i = 0;i < 3; i ++) {
				pPoints[arguments[i + 2]][0].subtract(pPoints[iPoint][0], pPoints[iPoint][i+1]);

				if(pPoints[iPoint][i + 1].length() > fMinSize) {
					pPoints[iPoint][i + 1].scale(0.1);
				}

				pPoints[iPoint][i + 1].add(pPoints[iPoint][0]);
			}
		}

		fTempFunc(pPoints,0,1,2,4);
		fTempFunc(pPoints,1,0,3,5);
		fTempFunc(pPoints,2,0,3,6);
		fTempFunc(pPoints,3,1,2,7);
		fTempFunc(pPoints,4,0,5,6);
		fTempFunc(pPoints,5,1,4,7);
		fTempFunc(pPoints,6,2,4,7);
		fTempFunc(pPoints,7,3,5,6);

		for(i = 0; i < 8; i++) {
			for(j = 0; j < 4; j++) {
				ppVertexes[i * 12 + j * 3 + 0] = pPoints[i][j].x;
				ppVertexes[i * 12 + j * 3 + 1] = pPoints[i][j].y;
				ppVertexes[i * 12 + j * 3 + 2] = pPoints[i][j].z;
			}
		}

		pInd = [
			0, 1, 0, 2, 0, 3,
			4, 5, 4, 6, 4, 7,
			8, 9, 8,10, 8,11,
			12,13,12,14,12,15,
			16,17,16,18,16,19,
			20,21,20,22,20,23,
			24,25,24,26,24,27,
			28,29,28,30,28,31
		];

		for(var i:  number  = 0; i < pInd.length; ++ i) {
			ppIndexes[i] = pInd[i];
		}

		return true;
	}


/** подсчет обобщающей сферы над двумя сферами */

	export function computeGeneralizingSphere (pSphereA: ISphere, pSphereB: ISphere, pSphereDest?: ISphere): bool {
	    if (!isDef(pSphereDest)) {
	        pSphereDest = pSphereA;
	    }

	    var fR1:  number  = pSphereA.radius;
	    var fR2:  number  = pSphereB.radius;
	    var v3fC1: IVec3 = pSphereA.center;
	    var v3fC2: IVec3 = pSphereB.center;

	    var v3fD: IVec3 = new Vec3;

	    v3fC1.subtract(v3fC2, v3fD);

	    var fD:  number  = v3fD.length();

	    if (fD < fR1 && fR1 > fR2) {
	        pSphereDest.set(pSphereA);
	        return false;
	    }

	    if (fD < fR2) {
	        pSphereDest.set(pSphereB);
	        return false;
	    }

	    var v3fN: IVec3 = new Vec3;
	    v3fD.normalize(v3fN);

	    pSphereDest.radius = v3fD.add(v3fN.scale(fR1 + fR2)).length() / 2.0;

	    var v3fTemp: IVec3 = v3fD;
	    pSphereDest.center = v3fC1.add(v3fC2, v3fTemp).add(v3fN.scale((fR1 - fR2) / (fR1 + fR2))).scale(.5);

	    return true;
	}

/** расчет данных для отрисовки сферы */

	export function computeDataForCascadeBoundingSphere(
		pBoundingSphere: ISphere,
		ppVertexes:  number [],
		ppIndexes:  number [],
		fMinSize:  number  = 0.25): bool {

		var fTheta:  number , fDelta:  number , fAlpha:  number ;
		var nCount:  number  = 10;
		var i:  number , j:  number , k:  number , a;

		fDelta = 2 * Math.PI / nCount;

		for(i = 0; i <= nCount / 2; i ++) {
			fTheta=-Math.PI+(i*fDelta);
			for(j = 0; j <= nCount; j++) {
				fAlpha = j * fDelta;
				ppVertexes[(i*(nCount+1)+j)*3+0] = pBoundingSphere.center.x + pBoundingSphere.radius * Math.sin(fTheta) * Math.cos(fAlpha);
				ppVertexes[(i*(nCount+1)+j)*3+1] = pBoundingSphere.center.y + pBoundingSphere.radius * Math.sin(fTheta) * Math.sin(fAlpha);
				ppVertexes[(i*(nCount+1)+j)*3+2] = pBoundingSphere.center.z + pBoundingSphere.radius * Math.cos(fTheta);
			}
		}

		for(i = 0; i < nCount / 2; i++) {
			for(j = 0; j < nCount; j++) {
				ppIndexes[(i * (nCount) + j) * 12 + 0] = i * (nCount + 1) + j;
				ppIndexes[(i * (nCount) + j) * 12 + 1] = i * (nCount + 1) + j + 1;

				ppIndexes[(i * (nCount) + j) * 12 + 2] = i * (nCount + 1) + j + 2 + nCount;
				ppIndexes[(i * (nCount) + j) * 12 + 3] = i * (nCount + 1) + j;

				ppIndexes[(i * (nCount) + j) * 12 + 4] = i * (nCount + 1) + j + 1;
				ppIndexes[(i * (nCount) + j) * 12 + 5] = i * (nCount + 1) + j + 2 + nCount;

				ppIndexes[(i * (nCount) + j) * 12 + 6] = i * (nCount + 1) + j;
				ppIndexes[(i * (nCount) + j) * 12 + 7] = i * (nCount + 1) + j + 1 + nCount;

				ppIndexes[(i * (nCount) + j) * 12 + 8] = i * (nCount + 1) + j +2 + nCount;
				ppIndexes[(i * (nCount) + j) * 12 + 9] = i * (nCount + 1) + j +1 + nCount;

				ppIndexes[(i * (nCount) + j) * 12 + 10 ] = i *(nCount + 1) + j +2 + nCount;
				ppIndexes[(i * (nCount) + j) * 12 + 11 ] = i *(nCount + 1) + j;
			}
		}

		return true;
	}

/** 
	 * Computes a bounding sphere.
	 * При использование быстрого вычисления, опционально можно получить баундинг бокс. 
	 */

	export function computeBoundingSphere(pVertexData: IVertexData, pSphere: ISphere, bFastMethod: bool = true, pBoundingBox: IRect3d = null) {
		if(bFastMethod) {
			return computeBoundingSphereFast(pVertexData, pSphere, pBoundingBox);
		}
		else {
			return computeBoundingSphereMinimal(pVertexData, pSphere);
		}

	}

/**
	 * Computes a bounding sphere - not minimal. Also if it need compute dounding box
	 */

	export function computeBoundingSphereFast(pVertexData: IVertexData, pSphere: ISphere, pBoundingBox: IRect3d = null): bool {
	    var i:  number ;
		var pVertexDeclaration: IVertexDeclaration, pVertexElement: IVertexElement;
		var nCount:  number , nStride:  number ;
		var pData: ArrayBuffer, pTempData: Float32Array;

		pVertexDeclaration = pVertexData.getVertexDeclaration();

		if(isNull(pVertexDeclaration)) {
			return false;
		}


		pVertexElement = pVertexDeclaration.findElement(DeclUsages.POSITION, 3);

		if(isNull(pVertexElement)) {
			return false;
		}

		nCount = pVertexData.length;
		nStride = pVertexElement.size;

		pData = pVertexData.getData(pVertexElement.offset, pVertexElement.size);

		if (isNull(pData)) {
			return false;
		}

		if (isNull(pBoundingBox)) {
			pBoundingBox =  Rect3d.stackCeil ;
		}

		if (pBoundingBox.isClear()) {
			if(!computeBoundingBox(pVertexData, pBoundingBox)) {
				return false;
			}
	    }

	    var fCenterX:  number  = (pBoundingBox.x0 + pBoundingBox.x1) / 2;
	    var fCenterY:  number  = (pBoundingBox.y0 + pBoundingBox.y1) / 2;
	    var fCenterZ:  number  = (pBoundingBox.z0 + pBoundingBox.z1) / 2;
	    var fRadius:  number  = 0;
	    var fDistance:  number  = 0;

	    for (i = 0; i < nStride * nCount; i += nStride) {
			pTempData = new Float32Array(pData, i, 3);
	        fDistance = (pTempData[0] - fCenterX) * (pTempData[0] - fCenterX) +
	            (pTempData[1] - fCenterY) * (pTempData[1] - fCenterY) +
	            (pTempData[2] - fCenterZ) * (pTempData[2] - fCenterZ);
	        fRadius = fDistance > fRadius ? fDistance : fRadius;
	    }

		pSphere.set(fCenterX, fCenterY, fCenterZ ,Math.sqrt(fRadius));

	    return true;
	}



/**
	 * Computes a bounding sphere - minimal.
	 */

	export function computeBoundingSphereMinimal (pVertexData: IVertexData, pSphere: ISphere): bool {
	    var i:  number  = 0, j:  number  = 0, k:  number  = 0;
	    var points:  number [] = [];
	    var length:  number  = 0;
	    var isAdd: bool = false;
	    var isNew: bool = true;
	    var fDiametr:  number  = 0;
	    var fDistance:  number  = 0;

		var pVertexDeclaration: IVertexDeclaration, pVertexElement: IVertexElement;
		var nCount:  number , nStride:  number ;
		var pData: ArrayBuffer, pTempData1: Float32Array, pTempData2: Float32Array;

		pVertexDeclaration = pVertexData.getVertexDeclaration();

		if (isNull(pVertexData)) {
			return false;
		}

		if(isNull(pVertexDeclaration)) {
			return false;
		}

		pVertexElement = pVertexDeclaration.findElement(DeclUsages.POSITION,3);

		if(isNull(pVertexElement))
			return false;

		nCount = pVertexData.length;
		nStride = pVertexElement.size;

		pData = pVertexData.getData(pVertexElement.offset, pVertexElement.size);

		if (!pData)
			return false;


	    for (i = 0; i < nStride * nCount; i += nStride) {
	        isNew = true;
	        isAdd = false;
	        pTempData1 = new Float32Array(pData, i, 3);

	        for (k = 0; k < points.length; k += 3) {
	            if (points[k] == pTempData1[0] &&
	                points[k + 1] == pTempData1[1] &&
	                points[k + 2] == pTempData1[2]) {
	                isNew = false;
	                break;
	            }
	        }

	        if (isNew) {
	            for (j = i + nStride; j < nStride * nCount; j += nStride) {
	                pTempData2 = new Float32Array(pData, j, 3);
	                fDistance = (pTempData1[0] - pTempData2[0]) * (pTempData1[0] - pTempData2[0]) +
	                    (pTempData1[1] - pTempData2[1]) * (pTempData1[1] - pTempData2[1]) +
	                    (pTempData1[2] - pTempData2[2]) * (pTempData1[2] - pTempData2[2]);
	                if (fDistance > fDiametr) {
	                    fDiametr = fDistance;
	                    isAdd = true;
	                    points[0] = pTempData2[0];
	                    points[1] = pTempData2[1];
	                    points[2] = pTempData2[2];
	                    length = 3;
	                }
	                else if (fDistance.toFixed(7) == fDiametr.toFixed(7)) {
	                    isAdd = true;
	                    for (k = 0; k < points.length; k += 3) {
	                        if (points[k] == pTempData2[0] &&
	                            points[k + 1] == pTempData2[1] &&
	                            points[k + 2] == pTempData2[2]) {
	                            isNew = false;
	                            break;
	                        }
	                    }
	                    if (isNew) {
	                        points[length] = pTempData2[0];
	                        points[length + 1] = pTempData2[1];
	                        points[length + 2] = pTempData2[2];
	                        length += 3;
	                    }
	                }
	            }
	            if (isAdd) {
	                points[length] = pTempData1[0];
	                points[length + 1] = pTempData1[1];
	                points[length + 2] = pTempData1[2];
	                length += 3
	            }
	        }
	    }

	    var fX:  number  = 0, fY:  number  = 0, fZ:  number  = 0;

	    for (i = 0; i < points.length; i += 3) {
	        fX += points[i];
	        fY += points[i + 1];
	        fZ += points[i + 2];
	    }

	    var x:  number  = pSphere.center.x = fX / points.length * 3;
	    var y:  number  = pSphere.center.y = fY / points.length * 3;
	    var z:  number  = pSphere.center.z = fZ / points.length * 3;

	    pSphere.radius = Math.sqrt((points[0] - x) * (points[0] - x) +
	                                    (points[1] - y) * (points[1] - y) +
	                                    (points[2] - z) * (points[2] - z));
	    return true;
	}

}





module akra.model {
	export class MeshSubset extends render.RenderableObject implements IMeshSubset {
		/**@protected*/  _pRenderData: IRenderData = null;
		/**@protected*/  _sName: string = null;
		/**@protected*/  _pMesh: IMesh = null;
		/**@protected*/  _pSkin: ISkin = null;
		/**@protected*/  _pBoundingBox: IRect3d = null;
		/**@protected*/  _pBoundingSphere: ISphere = null;

		/**@inline*/  get boundingBox(): IRect3d { return this._pBoundingBox; }
		/**@inline*/  get boundingSphere(): ISphere { return this._pBoundingSphere; }
		/**@inline*/  get data(): IRenderData { return this._pRenderData; }
		/**@inline*/  get skin(): ISkin { return this._pSkin; }
		/**@inline*/  get name(): string { return this._sName; }
		/**@inline*/  get mesh(): IMesh { return this._pMesh; }


		constructor (pMesh: IMesh, pRenderData: IRenderData, sName: string = null) {
			super();
			this.setup(pMesh, pRenderData, sName);
		}

		/**@protected*/  setup(pMesh: IMesh, pRenderData: IRenderData, sName: string): void {
			logger.setSourceLocation( "MeshSubset.ts" , 38 ); logger.assert(this._pMesh === null, "mesh subset already prepared"); ;

			this._pMesh = pMesh;
			this._pRenderData = pRenderData;
			this._sName = sName;

			super._setup(pMesh.getEngine().getRenderer(), sName);
		}

		createBoundingBox(): bool {
			var pVertexData: IVertexData;
			var pNewBoundingBox: IRect3d;

			pNewBoundingBox = new geometry.Rect3d();
			pVertexData = this.data._getData(DeclUsages.POSITION);

			if(isNull(pVertexData))
				return false;

			if(geometry.computeBoundingBox(pVertexData, pNewBoundingBox) == false)
				return false;

			this._pBoundingBox = pNewBoundingBox;

			return true;
		}

		deleteBoundingBox(): bool {
			this._pBoundingBox = null;

			return true;
		}

		showBoundingBox(): bool {
			var pMaterial: IMaterial;
			var iData:  number ;
			var iCurrentIndexSet:  number ;
			var pPoints:  number [],
				pIndexes:  number  [];

			if (isNull(this._pBoundingBox)) {
				return false;
			}

			pPoints = new Array();
			pIndexes = new Array();

			geometry.computeDataForCascadeBoundingBox(this._pBoundingBox, pPoints, pIndexes, 10.0);

			iCurrentIndexSet = this.data.getIndexSet();

			if(!this.data.selectIndexSet(".BoundingBox")) {
				this.data.addIndexSet(true, EPrimitiveTypes.LINELIST, ".BoundingBox");

				iData = this.data.allocateData(
						[VE_FLOAT3(DeclUsages.POSITION)],
						new Float32Array(pPoints));

				this.data.allocateIndex([VE_FLOAT(DeclUsages.INDEX0)], new Float32Array(pIndexes));

				this.data.index(iData,DeclUsages.INDEX0);

				this.applyFlexMaterial(".MaterialBoundingBox");

//TODO: некорректно задавать так boundingBox, т.к. надо рендерится со своим рендер методом, а его никто не выбирает. 
				pMaterial = this.getFlexMaterial(".MaterialBoundingBox");
				pMaterial.emissive = new Color(0.0, 0.0, 1.0, 1.0);
				pMaterial.diffuse  = new Color(0.0, 0.0, 1.0, 1.0);
			}
			else {
				this.data._getData(DeclUsages.POSITION).setData(new Float32Array(pPoints),DeclUsages.POSITION);
			}

			this.data.setRenderable(this.data.getIndexSet(), true);
			this.data.selectIndexSet(iCurrentIndexSet);

			return true;
		}

		hideBoundingBox(): bool {
			var iCurrentIndexSet:  number ;
			iCurrentIndexSet = this.data.getIndexSet();

			if(!this.data.selectIndexSet(".BoundingBox")) {
				return false;
			}
			else {
				this.data.setRenderable(this.data.getIndexSet(), false);
			}

			return this.data.selectIndexSet(iCurrentIndexSet);
		}

		createBoundingSphere(): bool {
			var pVertexData: IVertexData;
			var pNewBoundingSphere: ISphere;

			pNewBoundingSphere = new geometry.Sphere();
			pVertexData = this.data._getData(DeclUsages.POSITION);

			if(!pVertexData) {
				return false;
			}

			if(!geometry.computeBoundingSphere(pVertexData, pNewBoundingSphere, false, this._pBoundingBox)) {
				return false;
			}

			this._pBoundingSphere = pNewBoundingSphere;

			return true;
		}


		deleteBoundingSphere(): bool {
			this._pBoundingSphere = null;
			return true;
		}



		showBoundingSphere(): bool {
			var pMaterial: IMaterial;
			var iData:  number ;
			var iCurrentIndexSet:  number ;
			var pPoints:  number [], pIndexes:  number [];

			if(isNull(this._pBoundingSphere)) {
				return false;
			}

			pPoints = new Array();
			pIndexes = new Array();
			geometry.computeDataForCascadeBoundingSphere(this._pBoundingSphere, pPoints, pIndexes);

			iCurrentIndexSet = this.data.getIndexSet();
			if(!this.data.selectIndexSet(".BoundingSphere")) {
				this.data.addIndexSet(false, EPrimitiveTypes.LINELIST, ".BoundingSphere");

				iData = this.data.allocateData([VE_FLOAT3(DeclUsages.POSITION)], new Float32Array(pPoints));

				this.data.allocateIndex([VE_FLOAT(DeclUsages.INDEX0)], new Float32Array(pIndexes));
				this.data.index(iData,DeclUsages.INDEX0);

				this.applyFlexMaterial(".MaterialBoundingSphere");

				pMaterial = this.getFlexMaterial(".MaterialBoundingSphere");
				pMaterial.emissive = new Color(0.0, 0.0, 1.0, 1.0);
				pMaterial.diffuse  = new Color(0.0, 0.0, 1.0, 1.0);
			}
			else {
				this.data._getData(DeclUsages.POSITION).setData(new Float32Array(pPoints), DeclUsages.POSITION);
			}

			this.data.setRenderable(this.data.getIndexSet(), true);
			this.data.selectIndexSet(iCurrentIndexSet);

			return true;
		}

		hideBoundingSphere(): bool{
			var iCurrentIndexSet:  number  = this.data.getIndexSet();

			if(!this.data.selectIndexSet(".BoundingSphere")) {
				return false;
			}
			else {
				this.data.setRenderable(this.data.getIndexSet(), false);
			}

			return this.data.selectIndexSet(iCurrentIndexSet);
		}


		computeNormals () {
//TODO: calc normals
		}

		computeTangents () {
//TODO: compute normals
		}

		computeBinormals () {
//TODO: calc binormals
		}

		isSkinned() {
		    return this._pSkin !== null;
		}

		getSkin() {
		    return this._pSkin;
		}

		applyFlexMaterial(sMaterial: string, pMaterialData: IMaterial = null): bool {
		    if (this._pMesh.addFlexMaterial(sMaterial, pMaterialData)) {
		        return this.setFlexMaterial(sMaterial);
		    }

		    return false;
		}

		getFlexMaterial(csName: string): IMaterial;
		getFlexMaterial(iMaterial:  number ): IMaterial;
		getFlexMaterial(iMaterial): IMaterial {
		    return this._pMesh.getFlexMaterial(< number >iMaterial);
		}

		hasFlexMaterial (): bool {
		    return this._pRenderData.hasSemantics(DeclUsages.MATERIAL);
		}

		setFlexMaterial (iMaterial:  number ): bool;
		setFlexMaterial (csName: string): bool;
		setFlexMaterial (iMaterial): bool {
		    var pRenderData: IRenderData = this._pRenderData;
		    var pIndexData: IBufferData = pRenderData.getIndices();
		    var pMatFlow: IDataFlow = pRenderData._getFlow(DeclUsages.MATERIAL);
		    var eSemantics: string = DeclUsages.INDEX10;
		    var pIndexDecl: IVertexDeclaration, pFloatArray: Float32Array;
		    var iMatFlow:  number ;
		    var pMaterial: IMaterial = this._pMesh.getFlexMaterial(iMaterial);
		    var iMat:  number  = (<IFlexMaterial>pMaterial).data.byteOffset;

		    if (isNull(pMaterial)) {
		        return false;
		    }


		    if (pMatFlow) {
		        iMatFlow = pMatFlow.flow;
		        eSemantics = pMatFlow.mapper.semantics;
		        pIndexData = pMatFlow.mapper.data;

		        pRenderData._addData((<IFlexMaterial>pMaterial).data, iMatFlow);

		        return pRenderData.index(iMat, eSemantics, true);
		    }

		    pIndexDecl = createVertexDeclaration([VE_FLOAT(eSemantics)]);
		    pFloatArray = new Float32Array((<IVertexData>pIndexData).length);
		    iMatFlow = pRenderData._addData((<IFlexMaterial>pMaterial).data);

		    logger.setSourceLocation( "MeshSubset.ts" , 281 ); logger.assert(iMatFlow >= 0, "cannot add data flow with material for mesh subsset"); ;

		    if (!pRenderData.allocateIndex(pIndexDecl, pFloatArray)) {
		        logger.setSourceLocation( "MeshSubset.ts" , 284 ); logger.log("cannot allocate index for material!!!"); ;
		        return false;
		    }

		    return pRenderData.index(iMat, eSemantics, true);
		}

		_draw (): void {
		    this._pRenderData._draw();
		}

		show(): void {
		    this.data.setRenderable(true);
		}

		hide(): void {
		    this.data.setRenderable(false);
		}


//исходим из того, что данные скина 1:1 соотносятся с вершинами.
		setSkin(pSkin: ISkin): bool {

		    var pPosData: IVertexData;
		    var pPositionFlow: IDataFlow;
		    var pMetaData: Float32Array;
//мета данные разметки
		    var pInfMetaData: IVertexData;
//адресс мета данных во флотах
		    var iInfMetaDataLoc:  number ;
//шаг мета данных во флотах
		    var iInfMetaDataStride:  number ;

/*
		     Получаем данные вершин, чтобы проложить в {W} компоненту адерсс мета информации,
		     о влиянии на данную вершины.
		     */


//получаем поток данных с вершиными
		    pPositionFlow = this.data._getFlow(DeclUsages.POSITION);
		    logger.setSourceLocation( "MeshSubset.ts" , 324 ); logger.assert(isDefAndNotNull(pPositionFlow), "skin require position with indices in mesh subset"); ;

		    pPosData = pPositionFlow.data;

//проверяем, что данные еще не подвязаны к другому Skin'у
		    if (pPosData.hasSemantics(DeclUsages.BLENDMETA)) {
//тоже самый skin?
		        if (pSkin.isAffect(pPosData)) {
		            this._pSkin = pSkin;
		            return true;
		        }

		        logger.setSourceLocation( "MeshSubset.ts" , 336 ); logger.error("mesh subset already has another skin"); ;
		        return false;
		    }

//проверяем, что текущий подмеш пренадлежит мешу, на который натягивается skin,
//или его клону.
		    logger.setSourceLocation( "MeshSubset.ts" , 343 ); logger.assert(this.data.buffer == pSkin.data, "can not bind to skin mesh subset that does not belong skin's mesh.");

//подвязывем скин, к данным с вершинами текущего подмеша.
//т.е. добавляем разметку в конец каждого пикселя
		    pSkin.attach(pPosData);

//получаем данные разметки
		    pMetaData = <Float32Array>pPosData.getTypedData(DeclUsages.BLENDMETA);

//если по каким то причинам нет разметки...
		    logger.setSourceLocation( "MeshSubset.ts" , 353 ); logger.assert(isDefAndNotNull(pMetaData), "you must specify location for storage blending data"); ;

//выставляем разметку мета данных вершин, так чтобы они адрессовали сразу на данные
		    pInfMetaData = pSkin.getInfluenceMetaData();
		    iInfMetaDataLoc = pInfMetaData.byteOffset / EDataTypeSizes.BYTES_PER_FLOAT;
		    iInfMetaDataStride = pInfMetaData.stride / EDataTypeSizes.BYTES_PER_FLOAT;

		    for (var i:  number  = 0; i < pMetaData.length; ++ i) {
		        pMetaData[i] = iInfMetaDataLoc + i * iInfMetaDataStride;
		    }

//обновляем адресса мета данных вершин
		    pPosData.setData(pMetaData, DeclUsages.BLENDMETA);

//trace(this.data.toString());
		    this._pSkin = pSkin;

		    return true;
		}


		private _iGuid: number = eval("this._iGuid || akra.sid()"); private _pUnicastSlotMap: IEventSlotMap = null; private _pBroadcastSlotList: IEventSlotListMap = null; private static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable {return MeshSubset._pEventTable; } getGuid(): number {return this._iGuid < 0? (this._iGuid = sid()): this._iGuid; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
		;
	}
}










module akra.model {

	class Mesh implements IMesh extends util.ReferenceCounter {
        private _sName: string;
        private _pFlexMaterials: IMaterial[] = null;
        private _pBuffer: IRenderDataCollection = null;
        private _pEngine: IEngine;
        private _eOptions:  number  = 0;
        private _pSkeleton: ISkeleton = null;
        private _pBoundingBox: IRect3d = null;
        private _pBoundingSphere: ISphere = null;
        private _pSubMeshes: IMeshSubset[] = [];
        private _bShadow: bool = false;

        /**@inline*/  get length():  number  {
            return this._pSubMeshes.length;
        }

        /**@inline*/  get flexMaterials(): IMaterial[] {
            return this._pFlexMaterials;
        }

        /**@inline*/  get name(): string{
            return this._sName;
        }

        /**@inline*/  get data(): IRenderDataCollection {
            return this._pBuffer;
        }

        /**@inline*/  get skeleton(): ISkeleton {
            return this._pSkeleton;
        }

        /**@inline*/  set skeleton(pSkeleton: ISkeleton){
            this._pSkeleton = pSkeleton;
        }

        /**@inline*/  get boundingBox(): IRect3d {
            if (isNull(this._pBoundingBox)) {
                if (!this.createBoundingBox()) {
                    logger.setSourceLocation( "model/Mesh.ts" , 66 ); logger.warning("could not compute bounding box fo mesh"); ;
                }
            }

            return this._pBoundingBox;
        }

        /**@inline*/  get boundingSphere(): ISphere {
            if (isNull(this._pBoundingSphere)) {
                if (!this.createBoundingSphere()) {
                    logger.setSourceLocation( "model/Mesh.ts" , 76 ); logger.warning("could not compute bounding sphere for mesh"); ;
                }
            }

            return this._pBoundingSphere;
        }

        constructor(pEngine: IEngine, eOptions:  number , sName: string, pDataBuffer: IRenderDataCollection) {
            super();

            this._sName = sName || null;
            this._pEngine = pEngine;
            this.setup(sName, eOptions, pDataBuffer);
        }

        setSkeleton(pSkeleton: ISkeleton): void {
            this.skeleton = pSkeleton;
        }

        getOptions():  number  {
            return this._eOptions;
        }

        getEngine(): IEngine {
            return this._pEngine;
        }

        _drawSubset(iSubset:  number ): void {
            this._pBuffer._draw(iSubset);
        }

        _draw(): void {
            for (var i:  number  = 0; i < this.length; i++) {
                this._pSubMeshes[i]._draw();
            };
        }

        isReadyForRender(): bool {
            for (var i:  number  = 0; i < this._pSubMeshes.length; ++ i) {
                if (!this._pSubMeshes[i].isReadyForRender()) {
                    return false;
                }
            }

            return true;
        }

        private setup(sName: string, eOptions:  number , pDataCollection?: IRenderDataCollection): bool {
            logger.setSourceLocation( "model/Mesh.ts" , 124 ); logger.assert(this._pBuffer === null, "mesh already setuped."); ;

            if (isNull(pDataCollection)) {
                this._pBuffer = this._pEngine.createRenderDataCollection(eOptions);
            }
            else {
                logger.setSourceLocation( "model/Mesh.ts" , 131 ); logger.assert(pDataCollection.getEngine() === this.getEngine(), "you can not use a buffer with a different context");
                                                                        ;

                this._pBuffer = pDataCollection;
                eOptions |= pDataCollection.getOptions();
            }

            this._pBuffer.addRef();
            this._eOptions = eOptions || 0;
            this._sName = sName ||  "unknown" ;

            return true;
        }

        createSubset(sName: string, ePrimType: EPrimitiveTypes, eOptions:  number  = 0): IMeshSubset {
            var pData: IRenderData;
//TODO: modify options and create options for data dactory.
            pData = this._pBuffer.getEmptyRenderData(ePrimType, eOptions);
            pData.addRef();

            if (isNull(pData)) {
                return null;
            }

            return this.appendSubset(sName, pData);
        }

        appendSubset(sName: string, pData: IRenderData): IMeshSubset {
            logger.setSourceLocation( "model/Mesh.ts" , 158 ); logger.assert(pData.buffer === this._pBuffer, "invalid data used"); ;

            var pSubMesh: IMeshSubset = new MeshSubset(this, pData, sName);
            this._pSubMeshes.push(pSubMesh);

            this.connect(pSubMesh,  "shadow" ,  "shadow" , EEventTypes.UNICAST);

            return pSubMesh;
        }

        replaceFlexMaterials(pFlexMaterials: IMaterial[]): void {
            this._pFlexMaterials = pFlexMaterials;
        }

        freeSubset(sName: string): bool {
            logger.setSourceLocation( "model/Mesh.ts" , 173 ); logger.error("Метод freeSubset не реализован"); ;
            return false;
        }

        getFlexMaterial(iMaterial:  number ): IMaterial;
        getFlexMaterial(sName: string): IMaterial;
        getFlexMaterial(arg) {
            if (!this._pFlexMaterials) {
                return null;
            }

            if (typeof arguments[0] === 'number') {
                return this._pFlexMaterials[arguments[0]] || null;
            }
            else {
                for (var i = 0, pMaterials = this._pFlexMaterials; i < pMaterials.length; ++ i) {
                    if (pMaterials[i].name === <string>arguments[0]) {
                        return pMaterials[i];
                    }
                }
            }

            return null;
        }

        addFlexMaterial(sName: string, pMaterialData: IMaterial = null): bool {
            var pMaterial: IMaterial;
            var pMaterialId:  number ;

            logger.setSourceLocation( "model/Mesh.ts" , 202 ); logger.assert(arguments.length < 7, "only base material supported now..."); ;
//debug_assert(this.getFlexMaterial(sName) === null, 'material with name <' + sName + '> already exists');

            sName = sName || 'unknown';

            pMaterial = this.getFlexMaterial(sName);

            if (pMaterial) {
                if (pMaterialData) {
                   pMaterial.set(pMaterialData);
                }
                return true;
            }

            if (!this._pFlexMaterials) {
                this._pFlexMaterials = [];
            }

            pMaterialId = this._pFlexMaterials.length;
            pMaterial = material._createFlex(
                sName,
                this._pBuffer._allocateData(material.VERTEX_DECL, null)
            );

            if (!pMaterialData) {
                pMaterialData = material.create(null, material.DEFAULT)
            }

            pMaterial.set(pMaterialData);
//pMaterial.id = pMaterialId;
            this._pFlexMaterials.push(pMaterial);
            return true;
        }

        setFlexMaterial(iMaterial:  number ): bool;
        setFlexMaterial(csName: string): bool;
        setFlexMaterial(iMaterial): bool {
            var bResult: bool = true;
            for (var i:  number  = 0; i < this.length; ++ i) {
                if (!this._pSubMeshes[i].setFlexMaterial(< number >iMaterial)) {
                    logger.setSourceLocation( "model/Mesh.ts" , 243 ); logger.warning("cannot set material<" + iMaterial + "> for mesh<" + this.name + "> subset<" + this._pSubMeshes[i].name + ">");
                                                                     ;
                    bResult = false;
                }
            }

            return bResult;
        }

        destroy(): void {
            this._pFlexMaterials = null;
            this._pSubMeshes = null;
/*this*/
            this._pBuffer.destroy(        );
        }

        getSubset(sName: string): IMeshSubset;
        getSubset(i:  number ): IMeshSubset;
        getSubset(i: any): IMeshSubset {
            if (isInt(arguments[0])) {
                return this._pSubMeshes[arguments[0]];
            }
            else {
                for (var i = 0; i < this.length; ++ i) {
                    if (this._pSubMeshes[i].name === <string>arguments[0]) {
                        return this._pSubMeshes[i];
                    }
                }
            }
            return null;
        }

        setSkin(pSkin: ISkin): void {
            for (var i = 0; i < this.length; ++ i) {
                this._pSubMeshes[i].setSkin(pSkin);
            };
        }

        createSkin(): ISkin {
            var pSkin: ISkin = createSkin(this);
            this.setSkin(pSkin);
            return pSkin;
        }

        clone(iCloneOptions:  number ): IMesh {
            var pClone: IMesh = null;
            var pRenderData: IRenderData;
            var pSubMesh: IMeshSubset;

            if (iCloneOptions & EMeshCloneOptions.SHARED_GEOMETRY) {
                pClone = this.getEngine().createMesh(this.name, this.getOptions(), this.data);

                for (var i = 0; i < this.length; ++ i) {
                    pRenderData = this._pSubMeshes[i].data;
                    pRenderData.addRef();
                    pClone.appendSubset(this._pSubMeshes[i].name, pRenderData);
                }

                pClone.replaceFlexMaterials(this.flexMaterials);

//trace('created clone', pClone);
            }
            else {
//TODO: clone mesh data.
            }

            if (iCloneOptions & EMeshCloneOptions.GEOMETRY_ONLY) {
                return pClone;
            }
            else {
//TODO: clone mesh shading
            }

            return pClone;
        }

        createAndShowSubBoundingBox(): void {
            for(var i = 0; i < this.length; i++) {
                var pSubMesh: IMeshSubset = this.getSubset(i);
                pSubMesh.createBoundingBox();
                pSubMesh.showBoundingBox();
//console.log("SubMesh" + i);
            }
        }

        createAndShowSubBoundingSphere(): void {
            for(var i = 0; i < this.length; i ++) {
                var pSubMesh: IMeshSubset = this.getSubset(i);
                pSubMesh.createBoundingSphere();
                pSubMesh.showBoundingSphere();
//console.log("SubMesh" + i);
            }
        }

        createBoundingBox(): bool {
            var pVertexData: IVertexData;
            var pSubMesh: IMeshSubset;
            var pNewBoundingBox: IRect3d;
            var pTempBoundingBox: IRect3d;
            var i:  number ;

            pNewBoundingBox = new geometry.Rect3d();
            pTempBoundingBox = new geometry.Rect3d();

            pSubMesh = this.getSubset(0);
            pVertexData = pSubMesh.data._getData(DeclUsages.POSITION);

            if(isNull(pVertexData)) {
                return false;

            }

            if(geometry.computeBoundingBox(pVertexData, pNewBoundingBox)== false)
                return false;

            if (pSubMesh.isSkinned()) {
                pNewBoundingBox.transform(pSubMesh.skin.getBindMatrix());
                pNewBoundingBox.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
            }

            for(i = 1; i < this.length; i++) {

                pSubMesh = this.getSubset(i);
                pVertexData = pSubMesh.data._getData(DeclUsages.POSITION);
//trace(pSubMesh.name);

                if(!pVertexData) {
                    return false;
                }

                if(geometry.computeBoundingBox(pVertexData, pTempBoundingBox) == false) {
                    return false;
                }

//trace('>>> before box >>');
                if (pSubMesh.isSkinned()) {
//trace('calc skinned box');
                    pTempBoundingBox.transform(pSubMesh.skin.getBindMatrix());
                    pTempBoundingBox.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
                }
// trace('<<< after box <<');

                pNewBoundingBox.x0 = Math.min(pNewBoundingBox.x0, pTempBoundingBox.x0);
                pNewBoundingBox.y0 = Math.min(pNewBoundingBox.y0, pTempBoundingBox.y0);
                pNewBoundingBox.z0 = Math.min(pNewBoundingBox.z0, pTempBoundingBox.z0);

                pNewBoundingBox.x1 = Math.max(pNewBoundingBox.x1, pTempBoundingBox.x1);
                pNewBoundingBox.y1 = Math.max(pNewBoundingBox.y1, pTempBoundingBox.y1);
                pNewBoundingBox.z1 = Math.max(pNewBoundingBox.z1, pTempBoundingBox.z1);
            }

            this._pBoundingBox = pNewBoundingBox;
            return true;
        }

        deleteBoundingBox(): bool {
            this._pBoundingBox = null;
            return true;
        }

        showBoundingBox(): bool {
            var pSubMesh: IMeshSubset;
            var pMaterial: IMaterial;
            var iData:  number ;
            var pPoints:  number [], pIndexes:  number [];

            if(isNull(this._pBoundingBox)) {
                return false;
            }

            pPoints = new Array();
            pIndexes = new Array();

            geometry.computeDataForCascadeBoundingBox(this._pBoundingBox,pPoints,pIndexes,0.1);

            pSubMesh = this.getSubset(".BoundingBox");

            if(!pSubMesh) {
                pSubMesh = this.createSubset(".BoundingBox", EPrimitiveTypes.LINELIST, EHardwareBufferFlags.STATIC);

                if(isNull(pSubMesh)) {
                    return false;
                }

                iData = pSubMesh.data.allocateData([VE_FLOAT3(DeclUsages.POSITION)], new Float32Array(pPoints));

                pSubMesh.data.allocateIndex([VE_FLOAT(DeclUsages.INDEX0)], new Float32Array(pIndexes));

                pSubMesh.data.index(iData, DeclUsages.INDEX0);

// pSubMesh.applyFlexMaterial(".MaterialBoundingBox");
/*getFlexMaterial(".MaterialBoundingBox");*/
                pMaterial = pSubMesh.material;
                pMaterial.emissive = new Color(1.0, 1.0, 1.0, 1.0);
                pMaterial.diffuse = new Color(1.0, 1.0, 1.0, 1.0);
                pMaterial.ambient = new Color(1.0, 1.0, 1.0, 1.0);
                pMaterial.specular = new Color(1.0, 1.0, 1.0, 1.0);

                pSubMesh.effect.create();
                pSubMesh.effect.addComponent("akra.system.mesh_texture");
                pSubMesh.effect.addComponent("akra.system.prepareForDeferredShading");
            }
            else {
                pSubMesh.data._getData(DeclUsages.POSITION).setData(new Float32Array(pPoints), DeclUsages.POSITION);
            }

            pSubMesh.data.setRenderable(pSubMesh.data.getIndexSet(), true);
            return true;
        }

        hideBoundingBox(): bool {
            var pSubMesh: IMeshSubset = this.getSubset(".BoundingBox");

            if(!pSubMesh) {
                return false;
            }

//TODO: hide bounding box!!
            return false;
//return pSubMesh.data.setRenderable(this.data.getIndexSet(), false);
        }

        createBoundingSphere(): bool {
            var pVertexData: IVertexData;
            var pSubMesh: IMeshSubset;
            var pNewBoundingSphere: ISphere,
                pTempBoundingSphere: ISphere;
            var i:  number ;

            pNewBoundingSphere = new geometry.Sphere();
            pTempBoundingSphere = new geometry.Sphere();


            pSubMesh = this.getSubset(0);
            pVertexData = pSubMesh.data._getData(DeclUsages.POSITION);

            if(!pVertexData) {
                return false;
            }


            if(geometry.computeBoundingSphere(pVertexData,pNewBoundingSphere) == false) {
                return false;
            }

            if (pSubMesh.isSkinned()) {
                pNewBoundingSphere.transform(pSubMesh.skin.getBindMatrix());
                pNewBoundingSphere.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
            }

            for(i = 1; i < this.length; i++) {

                pSubMesh = this.getSubset(i);
                pVertexData = pSubMesh.data._getData(DeclUsages.POSITION);

                if(isNull(pVertexData))
                    return false;

                if(geometry.computeBoundingSphere(pVertexData, pTempBoundingSphere)== false)
                    return false;


                if (pSubMesh.isSkinned()) {
                    pTempBoundingSphere.transform(pSubMesh.skin.getBindMatrix());
                    pTempBoundingSphere.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
// trace(pTempBoundingSphere.fRadius, '<<<');
                }


                geometry.computeGeneralizingSphere(pNewBoundingSphere, pTempBoundingSphere)
            }
// trace(pNewBoundingSphere, '<<<<<<<<<<<<<<<<<<<<<<<<<')
            this._pBoundingSphere = pNewBoundingSphere;

            return true;
        }

        deleteBoundingSphere(): bool {
            this._pBoundingSphere = null;
            return true;
        }

        showBoundingSphere(): bool {
            var pSubMesh : IMeshSubset, pMaterial: IMaterial;
            var iData:  number ;
            var pPoints:  number [], pIndexes:  number [];

            if(!this._pBoundingSphere) {
                return false;
            }

            pPoints = new Array();
            pIndexes = new Array();

            geometry.computeDataForCascadeBoundingSphere(this._pBoundingSphere,pPoints,pIndexes);

            pSubMesh = this.getSubset(".BoundingSphere");

            if(!pSubMesh) {
                pSubMesh = this.createSubset(".BoundingSphere", EPrimitiveTypes.LINELIST, EHardwareBufferFlags.STATIC);

                if(isNull(pSubMesh))
                    return false;

                iData=pSubMesh.data.allocateData(
                    [VE_FLOAT3(DeclUsages.POSITION)],
                    new Float32Array(pPoints));

                pSubMesh.data.allocateIndex([VE_FLOAT(DeclUsages.INDEX0)], new Float32Array(pIndexes));
                pSubMesh.data.index(iData, DeclUsages.INDEX0);

// pSubMesh.applyFlexMaterial(".MaterialBoundingSphere");
//pSubMesh.getFlexMaterial(".MaterialBoundingSphere");                pMaterial = pSubMesh.material;
                pMaterial.emissive = new Color(1.0, 0.0, 0.0, 1.0);
                pMaterial.diffuse  = new Color(1.0, 0.0, 0.0, 1.0);
                pMaterial.ambient  = new Color(1.0, 0.0, 0.0, 1.0);
                pMaterial.specular = new Color(1.0, 0.0, 0.0, 1.0);
            }
            else {
                pSubMesh.data._getData(DeclUsages.POSITION).setData(new Float32Array(pPoints),DeclUsages.POSITION);
            }

            pSubMesh.data.setRenderable(pSubMesh.data.getIndexSet(), true);
            return true;
        }

        hideBoundingSphere(): bool {
            var pSubMesh: IMeshSubset;

            pSubMesh = this.getSubset(".BoundingSphere");

            if(!pSubMesh) {
                return false;
            }

//TODO: hide bounding sphere
            return false;
//return pSubMeshs.data.setRenderable(this.data.getIndexSet(),false);
        }

        /**@inline*/  hasShadow(): bool {
            return this._bShadow;
        }

        setShadow(bValue: bool = true): void {
            for (var i:  number  = 0; i < this._pSubMeshes.length; ++ i) {
                this._pSubMeshes[i].setShadow(bValue);
            }
        }

        toSceneModel(pParent: ISceneNode, sName: string = null): ISceneModel {
            if (isNull(pParent)) {
                return null;
            }

            var pSceneModel: ISceneModel = pParent.scene.createModel(sName);

            if (!pSceneModel.create()) {
                return null;
            }

            pSceneModel.mesh = this;
            pSceneModel.attachToParent(pParent);

            return pSceneModel;
        }

        private _iGuid: number = eval("this._iGuid || akra.sid()"); private _pUnicastSlotMap: IEventSlotMap = null; private _pBroadcastSlotList: IEventSlotListMap = null; private static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable {return Mesh._pEventTable; } getGuid(): number {return this._iGuid < 0? (this._iGuid = sid()): this._iGuid; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
             shadow(pSubMesh: IMeshSubset, bShadow: bool): void {

                this._bShadow = bShadow;

                if (!bShadow) {
                    for (var i:  number  = 0; i < this._pSubMeshes.length; ++ i) {
                        if (this._pSubMeshes[i].hasShadow()) {
                            this._bShadow = true;
                            break;
                        }
                    }
                }

                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).shadow; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pSubMesh, bShadow) : _broadcast[i].listener (_recivier, pSubMesh, bShadow) ; } } ;
            }
        ;

	}

    export function createMesh(pEngine: IEngine, sName: string = null, eOptions:  number  = 0, pDataBuffer: IRenderDataCollection = null): IMesh {
        return new Mesh(pEngine, eOptions, sName, pDataBuffer);
    }
}










module akra.scene {
	export class SceneModel extends SceneObject implements ISceneModel {
		private _pMesh: IMesh;

		constructor (pScene: IScene3d) {
			super(pScene);

			this.type = EEntityTypes.MODEL;
		}

		/**@inline*/  get mesh(): IMesh {
			return this._pMesh;
		}

		/**@inline*/  set mesh(pMesh: IMesh) {
			if (!isNull(this._pMesh)) {
				this.accessLocalBounds().set(0.01, 0.01, 0.01);
				this._pMesh = null;
			}

			if (!isNull(pMesh)) {
				this.accessLocalBounds().set(pMesh.boundingBox);
				this._pMesh = pMesh;
			}
		}

		/**@inline*/  get totalRenderable():  number  {
			return isNull(this._pMesh)? 0: this._pMesh.length;
		}

		/**@inline*/  getRenderable(i:  number  = 0): IRenderableObject {
			return this._pMesh.getSubset(i);
		}

		/**@inline*/  hasShadow(): bool {
			return this._pMesh.hasShadow();
		}

		/**@inline*/  setShadow(bValue: bool = true): void {
			this._pMesh.setShadow(bValue);
		}

		toString(isRecursive: bool = false, iDepth:  number  = 0) {

		    if (!isRecursive) {
		        var sData: string = "<model" + (this.name? " " + this.name: "") + "(" + String(isNull(this._pMesh)) + ")" +  '>';

		        if (!isNull(this._pMesh)) {
		            sData += "( " + this._pMesh.name + " )";
		        }

		        return sData;
		    }

		    return super.toString(isRecursive, iDepth);

		};

	}

	export  /**@inline*/  function isModel(pEntity: IEntity): bool {
		return pEntity.type === EEntityTypes.MODEL;
	}
}













module akra {
	export interface IEngine {} ;

	export interface IJoint extends ISceneNode {
		boneName: string;
// getEngine(): IEngine;
		create(): bool;
// toString(isRecursive: bool, iDepth: int): string;
	}
}








module akra.scene {
	export class Joint extends SceneNode implements IJoint {
		private _sBone: string = null;
// private _iUpdated: int = 0;
// private _pEngine: IEngine = null;

		constructor (pScene: IScene3d) {
			super(pScene);
			this.type = EEntityTypes.JOINT;
		}

		/**@inline*/  get boneName(): string{
			return this._sBone;
		}

		/**@inline*/  set boneName(sBone: string){
			return this._sBone;
		}

// getEngine(): IEngine {
// 	return this._pEngine;
// }

		create(): bool {
			this._m4fLocalMatrix = new Mat4(1);
			this._m4fWorldMatrix = new Mat4(1);

			this._v3fWorldPosition  = new Vec3();
			this._v3fTranslation    = new Vec3(0, 0, 0);
			this._v3fScale          = new Vec3(1);
			this._qRotation         = new Quat4(0, 1);


//maybe custom
			this.setInheritance(ENodeInheritance.ALL);
			return true;
		}

		toString(isRecursive: bool = false, iDepth:  number  = 0): string {
			isRecursive = isRecursive || false;

			if (!isRecursive) {
			    return "<joint" + (this._sName ? (' ' + this._sName) : "") + ">";
			}

			return Node.prototype.toString.call(this, isRecursive, iDepth);
		}
	}

	export  /**@inline*/  function isJoint(pEntity: IEntity): bool {
		return pEntity.type == EEntityTypes.JOINT;
	}
}





module akra.scene {

	export class Scene3d implements IScene3d {
		/**@protected*/  _pRootNode: ISceneNode;
		/**@protected*/  _pSceneManager: ISceneManager;
// protected _pNodeList: ISceneNode[];
// protected _pObjectList: ISceneObject[];

		/**@protected*/  _pDisplayLists: IDisplayList[] = [];
		/**@protected*/  _pDisplayListsCount:  number  = 0;
		/**@protected*/  _isUpdated: bool = false;

		type: ESceneTypes = ESceneTypes.TYPE_3D;

		/**@inline*/  get totalDL():  number  {
			return this._pDisplayListsCount;
		}

		constructor (pSceneManager: ISceneManager) {
			this._pSceneManager = pSceneManager;
			this._pRootNode = this.createNode("root-node");
			this._pRootNode.create();

			var i:  number ;

// this._pNodeList = [];
// this._pObjectList = [];

//TODO передача пользовательских параметров в OcTree

// i = this.addDisplayList(new OcTree);
// debug_assert(i == DL_DEFAULT, "invalid default list index");

//TODO передача пользовательских параметров в LightGraph

// i = this.addDisplayList(new LightGraph);
// debug_assert(i == DL_LIGHTING, "invalid lighting list index");

		}

		/**@inline*/  isUpdated(): bool {
			return this._isUpdated;
		}

		/**@inline*/  getRootNode(): ISceneNode {
			return this._pRootNode;
		}

		recursivePreUpdate(): void {
			this._isUpdated = false;
			this._pRootNode.recursivePreUpdate();
		}

		recursiveUpdate(): void {
			this._isUpdated = this._pRootNode.recursiveUpdate();
		}

		updateCamera(): bool {
			return false;
		}

		updateScene(): bool {
			return false;
		}


		createNode(sName: string = null): ISceneNode {
			var pNode: ISceneNode = new SceneNode(this);

			if (!pNode.create()) {
				logger.setSourceLocation( "Scene3d.ts" , 88 ); logger.error("cannot create scene node.."); ;
				return null;
			}

			return this.setupNode(pNode, sName);
		}

		createModel(sName: string = null): ISceneModel {
			var pNode: ISceneModel = new SceneModel(this);

			if (!pNode.create()) {
				logger.setSourceLocation( "Scene3d.ts" , 99 ); logger.error("cannot create model.."); ;
				return null;
			}

			return <ISceneModel>this.setupNode(pNode, sName);
		}

		createCamera(sName: string = null): ICamera {
			var pCamera: ICamera = new objects.Camera(this);

			if (!pCamera.create()) {
				logger.setSourceLocation( "Scene3d.ts" , 110 ); logger.error("cannot create camera.."); ;
				return null;
			}

			return <ICamera>this.setupNode(pCamera, sName);
		}

		createLightPoint(sName: string = null): ILightPoint {
			return null;
		}

		createSprite(sName: string = null): ISprite {
			return null;
		}

		createJoint(sName: string = null): IJoint {
			return <IJoint>this.setupNode(new Joint(this), sName);
		}

		createText3d(sName: string = null): IText3d {
			return null;
		}

// inline getAllNodes(): ISceneNode[] {
// 	return this._pNodeList;
// }

// inline getAllObjects(): ISceneObject[] {
// 	return this._pObjectList;
// }

		/**@inline*/  getDisplayList(i:  number ): IDisplayList {
			logger.setSourceLocation( "Scene3d.ts" , 142 ); logger.assert(isDefAndNotNull(this._pDisplayLists[i]), "display list not defined"); ;
			return this._pDisplayLists[i];
		}

		getDisplayListByName(csName: string):  number  {
			for (var i:  number  = 0; i < this._pDisplayLists.length; ++ i) {
				if (this._pDisplayLists[i].name === csName) {
					return i;
				}
			}

			return -1;
		}


// _findObjects(pCamera: ICamera, csList: string = null): ISceneObject[] {
// 	var pList: IDisplayList = this._pDisplayListMap[csList || DEFAULT_DLIST];

// 	debug_assert(!isNull(pList), "display list not founded.");

// 	return pList.findObjects(pCamera);
// }

		_render(pCamera: ICamera, pViewport: IViewport): void {

		}

		private setupNode(pNode: ISceneNode, sName: string = null): ISceneNode {
			pNode.name = sName;

// this.connect(pNode, SIGNAL(attached), SLOT(nodeAttachment), EEventTypes.UNICAST);
// this.connect(pNode, SIGNAL(detached), SLOT(nodeDetachment), EEventTypes.UNICAST);

			return pNode;
		}

		delDisplayList(index:  number ): bool {
			var pLists: IDisplayList[] = this._pDisplayLists;

			for (var i:  number  = 0; i < pLists.length; ++ i) {
				if (i === index && isDefAndNotNull(pLists[i])) {
					pLists[i] = null;
					this._pDisplayListsCount --;

					this.displayListRemoved(pLists[i], i);

					return true;
				}
			};

			return false;
		}

		/**@inline*/  addDisplayList(pList: IDisplayList):  number  {
			logger.setSourceLocation( "Scene3d.ts" , 197 ); logger.assert(isDefAndNotNull(this.getDisplayListByName(pList.name)), "DL with name <" + pList.name + "> already exists");
                                                       ;


			var pLists: IDisplayList[] = this._pDisplayLists;
			var iIndex:  number  = this._pDisplayLists.length;

			for (var i:  number  = 0; i < pLists.length; ++ i) {
				if (pLists[i] === null) {
					pLists[i] = pList;
					iIndex = i;
					break;
				}
			};

			if (iIndex == this._pDisplayLists.length) {
				this._pDisplayLists.push(pList);
			}

			pList._setup(this);

			this.displayListAdded(pList, iIndex);

			this._pDisplayListsCount ++;

			return iIndex;
		}

		private _iGuid: number = eval("this._iGuid || akra.sid()"); private _pUnicastSlotMap: IEventSlotMap = null; private _pBroadcastSlotList: IEventSlotListMap = null; private static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable {return Scene3d._pEventTable; } getGuid(): number {return this._iGuid < 0? (this._iGuid = sid()): this._iGuid; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;

		nodeAttachment (pNode: ISceneNode): void {
// this._pNodeList.push(pNode);

// if (SceneObject.isSceneObject(pNode)) {
// 	this._pObjectList.push(<ISceneObject>pNode);
// }
// console.warn("------>here");
			this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).nodeAttachment; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pNode) : _broadcast[i].listener (_recivier, pNode) ; } } ;
		}

		nodeDetachment (pNode: ISceneNode): void {

// for (var i: int = 0; i < this._pNodeList.length; ++ i) {
// 	if (pNode == this._pNodeList[i]) {
// 		this._pNodeList.splice(i, 1);
// 		break;
// 	}
// };

// if (SceneObject.isSceneObject(pNode)) {
// 	for (var i: int = 0; i < this._pObjectList.length; ++ i) {
// 		if (<ISceneObject>pNode == this._pObjectList[i]) {
// 			this._pObjectList.splice(i, 1);
// 			break;
// 		}
// 	};
// }


			this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).nodeDetachment; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pNode) : _broadcast[i].listener (_recivier, pNode) ; } } ;
		}


		displayListAdded (list, index): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).displayListAdded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, list, index) : _broadcast[i].listener (_recivier, list, index) ; } } } ; ;
		displayListRemoved (list, index): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).displayListRemoved; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, list, index) : _broadcast[i].listener (_recivier, list, index) ; } } } ; ;

// BROADCAST(nodeAttachment, CALL(pNode));
// BROADCAST(nodeDetachment, CALL(pNode));
		;
	}
}



module akra.scene {
    export class SceneManager implements ISceneManager {
        private _pEngine: IEngine = null;
        private _pSceneList: IScene[] = [];
        private _pTimer: IUtilTimer;

        private _fUpdateTimeCount:  number  = 0.;
        private _fMillisecondsPerTick:  number  = 0.0333;


        constructor (pEngine: IEngine) {
            this._pEngine = pEngine;
            this._pTimer = pEngine.getTimer();
        }

        update(): void {
            var isSceneUpdated: bool = false;
// add the real time elapsed to our
// internal delay counter
            this._fUpdateTimeCount += this._pTimer.elapsedTime;
// is there an update ready to happen?

            var fUpdateTime:  number  = this._fUpdateTimeCount;

            while (this._fUpdateTimeCount > this._fMillisecondsPerTick) {
// update the scene
                this.notifyUpdateScene();

// subtract the time interval
// emulated with each tick
                this._fUpdateTimeCount -= this._fMillisecondsPerTick;
            }

            if (fUpdateTime !== this._fUpdateTimeCount) {
                this.notifyPreUpdateScene();
            }
        }

        notifyUpdateScene(): void {

// update the scene attached to the root node
            for (var i = 0; i < this._pSceneList.length; ++ i) {
                var pScene: IScene = this._pSceneList[i];

                if (pScene.type != ESceneTypes.TYPE_3D) {
                    continue;
                }

                (<IScene3d>pScene).recursiveUpdate();
            }
        }

        notifyPreUpdateScene(): void {
            for (var i = 0; i < this._pSceneList.length; ++ i) {
                var pScene: IScene = this._pSceneList[i];

                if (pScene.type != ESceneTypes.TYPE_3D) {
                    continue;
                }

                (<IScene3d>pScene).recursivePreUpdate();
            }
        }

        createScene3D(): IScene3d {
            var pScene: IScene3d = new Scene3d(this);
            this._pSceneList.push(pScene);

            return pScene;
        }

        createScene2D(): IScene2d {
            return null;
        }

        getScene3D(IScene:  number  = 0): IScene3d {
            var pScene: IScene = this._pSceneList[IScene];

            if (pScene && pScene.type === ESceneTypes.TYPE_3D) {
                return <IScene3d>pScene;
            }

            return null;
        }

        getScene2D(IScene?:  number ): IScene2d {
            var pScene: IScene = this._pSceneList[IScene];

            if (pScene && pScene.type === ESceneTypes.TYPE_2D) {
                return pScene;
            }

            return null;
        }

        getScene(IScene?:  number , eType?: ESceneTypes): IScene {
            return this._pSceneList[IScene] || null;
        }


        initialize(): bool {
//this.initText2Dlayer();
            return true;
        }

        destroy(): void {

        }
    }
}





/** @inline */
/*
        draw2DText(iX: int = 0, iY: int = 0, sText: string = "", pFont: IFont2d = new util.Font2d()): IString2d {
            return (new a.String2D(iX, iY, pFont, sStr, this.pTextLayer));
        }

        

        private initText2Dlayer(): void {
            var pCanvas: HTMLCanvasElement = this.pEngine.canvas;
            var x: int = findPosX(pCanvas);
            var y: int = findPosY(pCanvas);

            var pDiv: HTMLDivElement = <HTMLDivElement>document.createElement('div');
            var pStyle: CSSStyleDeclaration = pDiv.style;
            var pScreen: IScreenInfo = info.screen;

            var iBorder: int = 0;

            pDiv.setAttribute("id", "akra-canvas-overlay");

            pStyle.width = String(pScreen.width) + "px";
            pStyle.height = String(pScreen.height) + "px";
            
            if (pCanvas.style.border != "none") {
                iBorder = parseInt(pCanvas.style.border);
            }

            pStyle.position = 'absolute';
            pStyle.left = String(x) + 'px';
            pStyle.top = String(y) + 'px';

            pStyle.overflow = 'hidden';
            pStyle.whiteSpace = 'nowrap';

            if (pCanvas.style.zIndex) {
                pStyle.zIndex = pCanvas.style.zIndex + 1;
            }
            else {
                pStyle.zIndex = 2;
            }

            document.body.appendChild(pDiv);

            this.pTextLayer = pDiv;
        }
*/









module akra.util {

	export class UtilTimer implements IUtilTimer {
		private isTimerInitialized: bool = false;
		private isTimerStopped: bool = false;
		private fTicksPerSec:  number  = 0.;
		private iStopTime:  number  = 0;
		private iLastElapsedTime:  number  = 0;
		private iBaseTime:  number  = 0;

		get absoluteTime():  number  {
			return this.execCommand(EUtilTimerCommands.TIMER_GET_ABSOLUTE_TIME);
		}

		get appTime():  number  {
			return this.execCommand(EUtilTimerCommands.TIMER_GET_APP_TIME);
		}

		get elapsedTime():  number  {
			return this.execCommand(EUtilTimerCommands.TIMER_GET_ELAPSED_TIME);
		}

		start(): bool {
			return this.execCommand(EUtilTimerCommands.TIMER_START) === 0;
		}
        stop(): bool {
        	return this.execCommand(EUtilTimerCommands.TIMER_STOP) === 0;
        }

        reset(): bool {
        	return this.execCommand(EUtilTimerCommands.TIMER_RESET) === 0;
        }

        execCommand(eCommand: EUtilTimerCommands):  number  {
		    var fTime:  number  = 0.;
		    var fElapsedTime:  number  = 0.;
		    var iTime:  number ;

		    if (this.isTimerInitialized == false) {
		        this.isTimerInitialized = true;
		        this.fTicksPerSec = 1000;
		    }

// Get either the current time or the stop time, depending
// on whether we're stopped and what command was sent
		    if (this.iStopTime != 0 && eCommand != EUtilTimerCommands.TIMER_START &&
		    	eCommand != EUtilTimerCommands.TIMER_GET_ABSOLUTE_TIME) {
		        iTime = this.iStopTime;
		    }
		    else {
		        iTime = (new Date()).getTime();
		    }

// Return the elapsed time
		    if (eCommand == EUtilTimerCommands.TIMER_GET_ELAPSED_TIME) {
		        fElapsedTime = (iTime - this.iLastElapsedTime) / this.fTicksPerSec;
		        this.iLastElapsedTime = iTime;
		        return fElapsedTime;
		    }

// Return the current time
		    if (eCommand == EUtilTimerCommands.TIMER_GET_APP_TIME) {
		        var fAppTime = ( iTime - this.iBaseTime ) / this.fTicksPerSec;
		        return fAppTime;
		    }

// Reset the timer
		    if (eCommand == EUtilTimerCommands.TIMER_RESET) {
		        this.iBaseTime = iTime;
		        this.iLastElapsedTime = iTime;
		        this.iStopTime = 0;
		        this.isTimerStopped = false;
		        return 0;
		    }

// Start the timer
		    if (eCommand == EUtilTimerCommands.TIMER_START) {
		        if (this.isTimerStopped) {
		            this.iBaseTime += iTime - this.iStopTime;
		        }
		        this.iStopTime = 0;
		        this.iLastElapsedTime = iTime;
		        this.isTimerStopped = false;
		        return 0;
		    }

// Stop the timer
		    if (eCommand == EUtilTimerCommands.TIMER_STOP) {
		        if (!this.isTimerStopped) {
		            this.iStopTime = iTime;
		            this.iLastElapsedTime = iTime;
		            this.isTimerStopped = true;
		        }
		        return 0;
		    }

// Advance the timer by 1/10th second
		    if (eCommand == EUtilTimerCommands.TIMER_ADVANCE) {
		        this.iStopTime += this.fTicksPerSec / 10;
		        return 0;
		    }

		    if (eCommand == EUtilTimerCommands.TIMER_GET_ABSOLUTE_TIME) {
		        fTime = iTime / this.fTicksPerSec;
		        return  fTime;
		    }

// Invalid command specified		    return -1;
        }

        static start(): UtilTimer {
        	var pTimer: UtilTimer = new UtilTimer;

        	if (pTimer.start()) {
        		return pTimer;
        	}

        	logger.setSourceLocation( "util/UtilTimer.ts" , 123 ); logger.error('cannot start util timer'); ;

        	return null;
        }
	}
}



//include sub creation classes.






















module akra.render {
	export interface IIndexSet {
		sName: string;
		pMap: IBufferMap;
		pIndexData: IBufferData;
		pAttribData: IVertexData;
		pI2IDataCache: IntMap;
		pAdditionCache: IntMap;
	};

	export class RenderData extends util.ReferenceCounter implements IRenderData {
/**
		 * Options.
		 */

		private _eOptions:  number  = 0;
/**
		 * Buffer, that create this class.
		 */

		private _pBuffer: IRenderDataCollection = null;
/**
		 * ID of this data.
		 */

		private _iId:  number  = -1;
/**
		 * Buffer with indices.
	     * If the data is the simplest mesh, with no more
	     * than one index, the type will be IndexBuffer,
	     * otherwise VertexBuffer.
	     */

		private _pIndexBuffer: IHardwareBuffer = null;
/**
		 * Buffer with attributes.
		 */

		private _pAttribBuffer: IVertexBuffer = null;
/**
	      * Data with indices.
	      * If _pIndexBuffer has type IndexBuffer, indices data
	      * has type IndexData, otherwise VertexData.
	      */

		private _pIndexData: IBufferData = null;
/**
	     * Data with attributes.
	     */

		private _pAttribData: IVertexData = null;
/**
	     * Buffer map for current index set.
	     */

		private _pMap: IBufferMap = null;
/**
	     * Buffer maps of all index sets.
	     */

		private _pIndicesArray: IIndexSet[] = [];
/**
	     * Current index set.
	     */

		private _iIndexSet:  number  = 0;
		private _iRenderable:  number  = 1;


		/**@inline*/  get buffer(): IRenderDataCollection {
			return this._pBuffer;
		}

		/**@inline*/  private get indexSet(): IIndexSet {
			return this._pIndicesArray[this._iIndexSet];
		}

		constructor(pCollection: IRenderDataCollection = null) {
			super();
			this._pBuffer = pCollection;
		}

/**
		 * Allocate data for rendering.
		 */

        allocateData(pDataDecl: IVertexElementInterface[], pData: ArrayBuffer, hasIndex: bool = true):  number ;
        allocateData(pDataDecl: IVertexElementInterface[], pData: ArrayBufferView, hasIndex: bool = true):  number ;
        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBuffer, hasIndex: bool = true):  number ;
        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBufferView, hasIndex: bool = true):  number ;
        allocateData(pDecl: any, pData: any, hasIndex: bool = true):  number {
        	var pDataDecl: IVertexDeclaration = createVertexDeclaration(<IVertexElementInterface[]>pDecl);
        	var eType: ERenderDataTypes = ERenderDataTypes.INDEXED;

		    if (!hasIndex || this.useSingleIndex()) {
		        eType = ERenderDataTypes.DIRECT;
		    }
		    else if (this.useAdvancedIndex()) {
		        eType = ERenderDataTypes.I2I;
		    }

		    return this._allocateData(pDataDecl, pData, eType);
        }

/**
         * Remove data from this render data.
         */

        releaseData(iDataLocation:  number ): void {
//TODO: release data.
        }

/**
		 * Allocate attribute.
		 * Attribute - data without index.
		 */

        allocateAttribute(pAttrDecl: IVertexDeclaration, pData: ArrayBuffer): bool;
        allocateAttribute(pAttrDecl: IVertexDeclaration, pData: ArrayBufferView): bool;
        allocateAttribute(pAttrDecl: IVertexDeclaration, pData: any): bool {
        	var pIndexData = this._pIndexData;
		    var pAttribData: IVertexData = this._pAttribData;
		    var pAttribBuffer: IVertexBuffer = this._pAttribBuffer;
		    var pBuffer: IRenderDataCollection = this._pBuffer;

		    if (!pAttribData) {
		        if (!pAttribBuffer) {
		            pAttribBuffer = pBuffer.getEngine().getResourceManager().createVertexBuffer('render_data_attrs_' + sid());
		            pAttribBuffer.create(EHardwareBufferFlags.BACKUP_COPY);
		            this._pAttribBuffer = pAttribBuffer;
		        }

		        this._pAttribData = this._pAttribBuffer.allocateData(pAttrDecl, pData);
		        this._pIndicesArray[this._iIndexSet].pAttribData = this._pAttribData;
		        this._pMap.flow(this._pAttribData);
		        return this._pAttribData !== null;
		    }

		    if (!pAttribData.extend(pAttrDecl, pData)) {
		        logger.setSourceLocation( "RenderData.ts" , 135 ); logger.log('invalid data for allocation:', arguments); ;
		        logger.setSourceLocation( "RenderData.ts" , 136 ); logger.warning('cannot allocate attribute in data subset..'); ;
		        return false;
		    }

		    return true;
        }

/**
		 * Allocate index.
		 */

		allocateIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBuffer): bool;
		allocateIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBuffer): bool;
		allocateIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBufferView): bool;
		allocateIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBufferView): bool;
		allocateIndex(pDecl: any, pData: any): bool{
			var pAttrDecl: IVertexDeclaration = createVertexDeclaration(<IVertexElementInterface[]>pDecl);
			if (this.useAdvancedIndex()) {
		        return this._allocateAdvancedIndex(pAttrDecl, pData);
		    }
		    return this._allocateIndex(pAttrDecl, pData);
		}

				getAdvancedIndexData(sSemantics: string): IVertexData {
			return this._getData(sSemantics, true);
		}

/**
		 * Add new set of indices.
		 */

        addIndexSet(usePreviousDataSet: bool = true, ePrimType:EPrimitiveTypes = EPrimitiveTypes.TRIANGLELIST, sName: string = null):  number  {

// if (this._pIndexData === null) {
//     return false;
// }


        	if (usePreviousDataSet) {
        	    this._pMap = this._pMap.clone(false);

        	    if (!this._pMap) {
        	        return -1;
        	    }
        	}
        	else {
        	    this._pMap = this._pBuffer.getEngine().createBufferMap();
        	    this._pAttribData = null;
        	}

        	this._pMap.primType = ePrimType;
        	this._pIndexData = null;
        	this._iIndexSet = this._pIndicesArray.length;
        	this._pIndicesArray.push({
        	                             pMap        	: this._pMap,
        	                             pIndexData  	: this._pIndexData,
        	                             pAttribData 	: this._pAttribData,
        	                             sName       	: sName,
        	                             pI2IDataCache	: <IntMap> null,
										 pAdditionCache	: <IntMap> null
        	                         });

        	return  this._iIndexSet;
        }

        getNumIndexSet():  number  {
        	return this._pIndicesArray.length;
        }

        getIndexSetName(iSet:  number  = this._iIndexSet): string {
        	return this._pIndicesArray[iSet].sName;
        }

/**
         * Select set of indices.
         */

        selectIndexSet(iSet:  number ): bool;
        selectIndexSet(sName: string): bool;
        selectIndexSet(a): bool {
        	var iSet:  number  = -1;

        	if (isString(arguments[0])) {
        		for (var i:  number  = 0; i < this._pIndicesArray.length; ++ i) {
        			if (this._pIndicesArray[i].sName === <string>arguments[0]) {
        				iSet = i;
        				break;
        			}
        		};

        		if (iSet < 0) {
        			return false;
        		}
        	}

        	var pIndexSet = this._pIndicesArray[iSet];

        	if (pIndexSet) {
        	    this._pMap = pIndexSet.pMap;
        	    this._pIndexData = pIndexSet.pIndexData;
        	    this._pAttribData = pIndexSet.pAttribData;
        	    this._iIndexSet = iSet;
        	    return true;
        	}

        	return false;
        }

/**
         * Get number of current index set.
         */

        getIndexSet():  number  {
        	return this._iIndexSet;
        }

/**
		 * Specifies uses advanced index.
		 */

        useAdvancedIndex(): bool {
        	return (this._eOptions & ERenderDataOptions.ADVANCED_INDEX) != 0;
        }

        useSingleIndex(): bool {
        	return (this._eOptions & ERenderDataOptions.SINGLE_INDEX) != 0;
        }

        useMultiIndex(): bool {
        	return (this._eOptions & ERenderDataOptions.SINGLE_INDEX) == 0;
        }

        setRenderable(bValue: bool): void;
        setRenderable(iIndexSet:  number , bValue: bool): void;
        setRenderable(iIndexSet: any, bValue?: bool = true): void {
        	if (arguments.length < 2) {
//mark all render data as renderable or not
        		if (<bool>arguments[0]) {
        			((this._eOptions) |= (ERenderDataOptions.RENDERABLE))
        		}
        		else {
        			((this._eOptions) &= ~(ERenderDataOptions.RENDERABLE)) ;
        		}
        	}

//mark index set is renderable or not
        	(bValue ? ((this._iRenderable) |= (1 << ((< number >iIndexSet))) ) : ((this._iRenderable) &= ~ (1 << ((< number >iIndexSet))) ) ) ;
        }

        isRenderable(iIndexSet?:  number ): bool;
        isRenderable(): bool;
        isRenderable(iIndexSet?:  number ): bool {
        	if (arguments.length > 0) {
//is this index set renderable ?
        		return  ((this._iRenderable & (1 << (iIndexSet)) ) != 0) ;
        	}

//is this data renderable ?
        	return this._eOptions & ERenderDataOptions.RENDERABLE ? true : false;
        }

/**
         * Check whether the semantics used in this data set.
         */

        hasSemantics(sSemantics: string, bSearchComplete: bool = true): bool {
        	return this._getFlow(sSemantics, bSearchComplete) !== null;
        }

/**
         * Get data location.
         */

        getDataLocation(sSemantics: string):  number ;
        getDataLocation(iDataLocation:  number ):  number ;
        getDataLocation(sSemantics?):  number  {
        	var pData: IVertexData = this._getData(<string>sSemantics);

        	return pData ? pData.byteLength : -1;
        }

/**
         * Get indices that uses in current index set.
         */

        getIndices(): IBufferData {
        	return this._pIndexData;
        }

/**
         * Get number of primitives for rendering.
         */

        getPrimitiveCount():  number  {
        	return this._pMap.primCount;
        }

/**
         * Setup index.
         */

        index(sData: string, sSemantics: string, useSame?: bool, iBeginWith?:  number ): bool;
        index(iData:  number , sSemantics: string, useSame?: bool, iBeginWith?:  number ): bool;
        index(data: any, sSemantics: string, useSame?: bool, iBeginWith?:  number ): bool {
        	iBeginWith = iBeginWith || 0;
        	useSame = useSame || false;

            var iData:  number  = < number >arguments[0];
        	var iFlow:  number  = -1;
        	var iAddition:  number , iRealAddition:  number , iPrevAddition:  number ;
        	var pFlow: IDataFlow;
        	var pData: IVertexData, pRealData: IVertexData;
        	var pFloat32Array: Float32Array;
        	var iIndexOffset:  number ;
        	var pIndexData: IBufferData = this._pIndexData;
        	var sData: string;
        	var iStride:  number ;
        	var iTypeSize:  number  = EDataTypeSizes.BYTES_PER_FLOAT;

        	if (this.useAdvancedIndex()) {
        	    pRealData = this._getData(<string>arguments[0]);
        	    iAddition = pRealData.byteLength;
        	    iStride = pRealData.stride;
//индекс, который подал юзер
        	    pData = this._getData(sSemantics, true);

        	    pData.applyModifier(sSemantics, function (pTypedData: Float32Array) {
        	        for (var i:  number  = 0; i < pTypedData.length; i++) {
        	            pTypedData[i] = (pTypedData[i] * iStride + iAddition) / iTypeSize;
        	        }
        	        ;
        	    });

        	    iData = pData.byteLength;
        	    sSemantics = "INDEX_" + sSemantics;
        	}
        	else if (isString(arguments[0])) {
        	    if (arguments[0] === "TEXCOORD") {
        	        iData = this.getDataLocation("TEXCOORD0");
        	    }
        	    else {
        	    	iData = this.getDataLocation(<string>arguments[0]);
        		}

        	    logger.setSourceLocation( "RenderData.ts" , 370 ); logger.assert(iData >= 0, "cannot find data with semantics: " + arguments[0]); ;
        	}

        	pFlow = this._getFlow(iData);

        	if (pFlow === null) {
        	    return false;
        	}

        	iFlow = pFlow.flow;
        	iIndexOffset = (<IVertexData>pIndexData).getVertexDeclaration().findElement(sSemantics).offset;
        	pFloat32Array = <Float32Array>(<IVertexData>pIndexData).getTypedData(sSemantics);
        	iAddition = iData;

        	if (!pFloat32Array) {
        	    return false;
        	}


        	iStride = pFlow.data.stride;

        	if (this.indexSet.pAdditionCache[iIndexOffset] !== iAddition) {
        	    if (!useSame) {
        	        iPrevAddition = this.indexSet.pAdditionCache[iIndexOffset] || 0;
        	        iRealAddition = iAddition - iPrevAddition;

        	        for (var i = 0; i < pFloat32Array.length; i++) {
        	            pFloat32Array[i] = (pFloat32Array[i] * iStride + iRealAddition) / iTypeSize;
        	        }
        	        ;
        	    }
        	    else {
        	        iRealAddition = iAddition;
        	        for (var i = 0; i < pFloat32Array.length; i++) {
        	            pFloat32Array[i] = (iBeginWith + iRealAddition) / iTypeSize;
        	        }
        	        ;
        	    }

//remeber addition, that we added to index.
        	    this.indexSet.pAdditionCache[iIndexOffset] = iAddition;

        	    if (!(<IVertexData>pIndexData).setData(pFloat32Array, sSemantics)) {
        	        return false;
        	    }
        	}

        	return this._pMap.mapping(iFlow, <IVertexData>pIndexData, sSemantics);
        }


/*Setup.*/

		_setup(pCollection: IRenderDataCollection, iId:  number , ePrimType: EPrimitiveTypes = EPrimitiveTypes.TRIANGLELIST, eOptions:  number  = 0): bool {
			if (this._pBuffer === null && arguments.length < 2) {
		        return false;
		    }

		    this.setRenderable(true);

		    this._eOptions |= eOptions;
		    this._pBuffer = pCollection;
		    this._iId = iId;

//setup buffer map
		    this._pMap = pCollection.getEngine().createBufferMap();
		    this._pMap.primType = ePrimType;

//setup default index set
		    this._pIndicesArray.push({
		                                 sName       	: ".main",
		                                 pMap        	: <IBufferMap>this._pMap,
		                                 pIndexData  	: <IBufferData>null,
		                                 pAttribData 	: <IVertexData>null,
		                                 pI2IDataCache	: <IntMap>{},
		                                 pAdditionCache : <IntMap>null
		                             });

		    logger.setSourceLocation( "RenderData.ts" , 447 ); logger.assert(this.useSingleIndex() === false, "single indexed data not implimented"); ;

		    return true;
		}


        private _allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBuffer, eType: ERenderDataTypes):  number ;
        private _allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBufferView, eType: ERenderDataTypes):  number ;
        private _allocateData(pDataDecl: IVertexDeclaration, pData: any, eType: ERenderDataTypes):  number  {
        	if (eType === ERenderDataTypes.DIRECT) {
		        return this.allocateAttribute(pDataDecl, pData)? 0: -1;
		    }

		    var iFlow:  number ;
		    var pVertexData: IVertexData = this._pBuffer._allocateData(pDataDecl, pData);
		    var iOffset:  number  = pVertexData.byteLength;

		    iFlow = this._addData(pVertexData, undefined, eType);

		    if (iFlow < 0) {
		        logger.setSourceLocation( "RenderData.ts" , 467 ); logger.log("invalid data", pDataDecl, pData); ;
		        logger.setSourceLocation( "RenderData.ts" , 468 ); logger.error("cannot allocate data for submesh"); ;
		        return -1;
		    }

		    return iOffset;
        }

/**
		 * Add vertex data to this render data.
		 */

        _addData(pVertexData: IVertexData, iFlow?:  number , eType: ERenderDataTypes = ERenderDataTypes.DIRECT):  number  {

		    if ((arguments.length < 3 && this.useAdvancedIndex()) ||
		        arguments[2] === ERenderDataTypes.I2I) {
		        return this._registerData(pVertexData);
		    }

		    return (!isDef(iFlow) ? this._pMap.flow(pVertexData) :
		            this._pMap.flow(iFlow, pVertexData));
		}

/**
		 * Register data in this render.
		 * Necessary for index to index mode, when data realy
		 * not using in this render data for building final buffer map.
		 */

		private _registerData(pVertexData: IVertexData):  number  {
		    'use strict';
		    var iOffset:  number  = pVertexData.byteLength;
		    var pDataDecl: IVertexDeclaration = pVertexData.getVertexDeclaration();

//необходимо запоминать расположение данных, которые подаются,
//т.к. иначе их потом нельзя будет найти среди других данных
		    for (var i:  number  = 0; i < pDataDecl.length; i++) {
		        this.indexSet.pI2IDataCache[pDataDecl[i].eUsage] = iOffset;
		    }


		    return 0;
		};


/**
		 * Allocate advanced index.
		 */

		 private _allocateAdvancedIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBuffer): bool;
		 private _allocateAdvancedIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBufferView): bool;
		 private _allocateAdvancedIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBuffer): bool;
		 private _allocateAdvancedIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBufferView): bool;
		 private _allocateAdvancedIndex(pAttrDecl: any, pData: any): bool {

		    var pDecl: IVertexDeclaration = createVertexDeclaration(<IVertexElementInterface[]>pAttrDecl);
		    var nCount:  number  = pData.byteLength / pDecl.stride;
//TODO: remove index dublicates
		    var iIndLoc:  number  = this._allocateData(pAttrDecl, pData, ERenderDataTypes.INDEXED);
		    var pI2IData: Float32Array = new Float32Array(nCount);
		    var pI2IDecl: IVertexElementInterface[] = [];

		    for (var i:  number  = 0; i < pDecl.length; i++) {
		        pI2IDecl.push(VE_FLOAT('INDEX_' + pDecl[i].eUsage, 0));
		    }
		    ;

		    for (var i:  number  = 0; i < pI2IData.length; i++) {
		        pI2IData[i] = i;
		    }
		    ;

		    if (!this._allocateIndex(pI2IDecl, pI2IData)) {
		        this.releaseData(iIndLoc);
		        pI2IData = null;
		        pI2IDecl = null;
		        logger.setSourceLocation( "RenderData.ts" , 540 ); logger.warning('cannot allocate index for index in render data subset'); ;
		        return false;
		    }

		    return true;
		};



/**
		 * Create IndexBuffer/IndexData for storage indices.
		 */

		private _createIndex(pAttrDecl: IVertexDeclaration, pData:ArrayBuffer): bool;
		private _createIndex(pAttrDecl: IVertexDeclaration, pData:ArrayBufferView): bool;
		private _createIndex(pAttrDecl: IVertexDeclaration, pData:ArrayBufferView): bool{
		    'use strict';

		    if (!this._pIndexBuffer) {
		        if (this.useMultiIndex()) {
		            this._pIndexBuffer = this._pBuffer.getEngine().getResourceManager().createVertexBuffer('subset_' + sid());
		            this._pIndexBuffer.create(EHardwareBufferFlags.BACKUP_COPY);
		        }
		        else {
//TODO: add support for sinle indexed mesh.
		        }
		    }

		    this._pIndexData = (<IVertexBuffer>this._pIndexBuffer).allocateData(pAttrDecl, pData);
		    this.indexSet.pIndexData = this._pIndexData;
		    this.indexSet.pAdditionCache = <IntMap>{};
		    return this._pIndexData !== null;
		};

/**
		 * Allocate index.
		 */

		private _allocateIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBuffer): bool;
		private _allocateIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBufferView): bool;
		private _allocateIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBuffer): bool;
		private _allocateIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBufferView): bool;
		private _allocateIndex(pDecl: any, pData: any): bool {
		    'use strict';

		    var pAttrDecl: IVertexDeclaration = createVertexDeclaration(<IVertexElementInterface[]> pDecl);
		    var pIndexData: IBufferData = this._pIndexData;
		    var pIndexBuffer: IHardwareBuffer = this._pIndexBuffer;
		    var pBuffer: IRenderDataCollection = this._pBuffer;


		    for (var i:  number  = 0; i < pAttrDecl.length; i++) {
		        if (pAttrDecl[i].eType !== EDataTypes.FLOAT) {
		            return false;
		        }
		    }


		    if (!this._pIndexData) {
		        return this._createIndex(pAttrDecl, pData);
		    }

		    if (!(<IVertexData>this._pIndexData).extend(pAttrDecl, pData)) {
		        logger.setSourceLocation( "RenderData.ts" , 601 ); logger.log('invalid data for allocation:', arguments); ;
		        logger.setSourceLocation( "RenderData.ts" , 602 ); logger.warning('cannot allocate index in data subset..'); ;
		        return false;
		    }

		    return true;
		};


		_setIndexLength(iLength:  number ): bool {
			var bResult: bool = (<IVertexData>this._pIndexData).resize(iLength);

			if(bResult) {
				this._pMap._length = iLength;
			}

			return bResult;
		}


/**
         * Get data flow by semantics or data location.
         */

        _getFlow(iDataLocation:  number ): IDataFlow;
        _getFlow(sSemantics: string, bSearchComplete?: bool): IDataFlow;
        _getFlow(a, b?): IDataFlow {
        	if (typeof arguments[0] === 'string') {
		        return this._pMap.getFlow(arguments[0], arguments[1]);
		    }

		    for (var i:  number  = 0, n = this._pMap.limit; i < n; ++i) {
		        var pFlow = this._pMap.getFlow(i, false);

		        if (pFlow.data && pFlow.data.byteLength === arguments[0]) {
		            return pFlow;
		        }
		    }

		    return null;
        }

/**
         * Get data by semantics or location.
         */

        _getData(iDataLocation:  number , bSearchOnlyInCurrentMap?: bool): IVertexData;
        _getData(sSemanticsn: string, bSearchOnlyInCurrentMap?: bool): IVertexData;
        _getData(a, b?): IVertexData {
        	var pFlow: IDataFlow;

        	if (this.useAdvancedIndex() && arguments.length < 2) {
        	    if (typeof arguments[0] === 'string') {
        	        return this._getData(this.indexSet.pI2IDataCache[arguments[0]]);
        	    }

        	    return this._pBuffer.getData(<string>arguments[0]);
        	}

        	if (typeof arguments[0] === 'string') {
        	    for (var i = 0, n = this._pMap.limit; i < n; ++i) {
        	        pFlow = this._pMap.getFlow(i, false);
        	        if (pFlow.data != null && pFlow.data.hasSemantics(arguments[0])) {
        	            return pFlow.data;
        	        }
        	    }

//this._pBuffer._getData(arguments[0]);        	    return null;
        	}

        	pFlow = this._getFlow(arguments[0]);
        	return pFlow === null ? null : pFlow.data;
        }



/**
         * Draw this data.
         */

        _draw(): void {
        	for (var i:  number  = 0; i < this._pIndicesArray.length; i++) {
        	    if (this.isRenderable(i)) {
        	        this._pIndicesArray[i].pMap._draw();
        	    }
        	}
        }

//applyMe(): bool;

        toString(): string {
        	var s: string;
        	s = 'RENDER DATA SUBSET: #' + this._iId + '\n';
        	s += '        ATTRIBUTES: ' + (this._pAttribData ? 'TRUE' : 'FALSE') + '\n';
        	s += '----------------------------------------------------------------\n';
        	s += this._pMap.toString();

        	return s;
        }
	}
}



module akra.render {

	class RenderDataCollection extends util.ReferenceCounter implements IRenderDataCollection {
		private _pDataBuffer: IVertexBuffer = null;
		private _pEngine: IEngine = null;
		private _eDataOptions:  number  = 0;
		private _pDataArray: IRenderData[] = [];

		/**@inline*/  get buffer(): IVertexBuffer {
			return this._pDataBuffer;
		}

        /**@inline*/  get length():  number  {
            return this._pDataArray.length;
        }

        /**@inline*/  get byteLength():  number  {
            return this._pDataBuffer.byteLength;
        }


        constructor (pEngine: IEngine, iOptions:  number  = 0) {
            super();
            this._pEngine = pEngine;

            this.setup(iOptions);
        }

        clone(pSrc: IRenderDataCollection): bool {
            logger.setSourceLocation( "render/RenderDataCollection.ts" , 37 ); logger.criticalError("TODO: RenderDataCollection::clone();"); ;

            return false;
        }

        getEngine(): IEngine {
        	return this._pEngine;
        }

        getOptions():  number  {
        	return this._eDataOptions;
        }

/**
         * Find VertexData with given semantics/usage.
         */

        getData(sUsage: string): IVertexData;
        getData(iOffset:  number ): IVertexData;
        getData(a?): IVertexData {
        	var pBuffer: IVertexBuffer = this._pDataBuffer;
            var pData: IVertexData;
            var n:  number ;

        	if (!isNull(pBuffer)) {
        	    n = this._pDataBuffer.length;

        	    if (isString(arguments[0])) {
        	        for (var i:  number  = 0; i < n; i++) {
                        pData = pBuffer.getVertexData(i);
        	            if (pData.hasSemantics(<string>arguments[0])) {
        	                return pData;
        	            }
        	        };
        	    }
        	    else {
        	        for (var i:  number  = 0; i < n; i++) {
                        pData = pBuffer.getVertexData(i);
        	            if (pData.byteLength === < number >arguments[0]) {
        	                return pData;
        	            }
        	        };
        	    }
        	}

        	return null;
        }

/**
         * Положить данные в буфер.
         */

        _allocateData(pVertexDecl: IVertexDeclaration, iSize:  number ): IVertexData;
        _allocateData(pVertexDecl: IVertexDeclaration, pData: ArrayBufferView): IVertexData;
        _allocateData(pVertexDecl: IVertexDeclaration, pData: ArrayBuffer): IVertexData;
        _allocateData(pDeclData: IVertexElementInterface[], iSize:  number ): IVertexData;
        _allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBufferView): IVertexData;
        _allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBuffer): IVertexData;
        _allocateData(pDecl, pData) {
        	if (!this._pDataBuffer) {
        	    this.createDataBuffer();
        	}

        	var pVertexDecl: IVertexDeclaration = createVertexDeclaration(<IVertexElementInterface[]>pDecl);
        	var pVertexData: IVertexData;

        	if ((arguments.length < 2) || isNumber(arguments[1]) || isNull(arguments[1])) {
        	    pVertexData = this._pDataBuffer.getEmptyVertexData(< number >pData || 1, pVertexDecl);
        	}
        	else {
        	    pVertexData = this._pDataBuffer.allocateData(pVertexDecl, <ArrayBufferView>pData);
        	}

        	logger.setSourceLocation( "render/RenderDataCollection.ts" , 108 ); logger.assert(pVertexData !== null, "cannot allocate data:\n" + pVertexDecl.toString()); ;

        	return pVertexData;
        }

        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBufferView, isCommon: bool = true):  number ;
        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBuffer, isCommon: bool = true):  number ;
        allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBufferView, isCommon: bool = true):  number ;
        allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBuffer, isCommon: bool = true):  number ;

        allocateData(pDecl?, pData?, isCommon: bool = true):  number  {
        	    var pVertexData: IVertexData;
        	    var pDataDecl: IVertexDeclaration = createVertexDeclaration(<IVertexElementInterface[]>pDecl);



        	    for (var i:  number  = 0; i < pDataDecl.length; i++) {
        	        if (this.getData(pDataDecl[i].eUsage) !== null && pDataDecl[i].nCount !== 0) {
        	            logger.setSourceLocation( "render/RenderDataCollection.ts" , 127 ); logger.warning("data buffer already contains data with similar vertex decloration <" + pDataDecl[i].eUsage + ">.");
                                                    ;
        	        }
        	    };



        	    pVertexData = this._allocateData(pDataDecl, <ArrayBufferView>pData);

        	    if (isCommon) {
        	        for (var i:  number  = 0; i < this._pDataArray.length; ++ i) {
        	            this._pDataArray[i]._addData(pVertexData);
        	        }
        	    }

        	    return pVertexData.byteLength;
        }

        getDataLocation(sSemantics: string):  number  {
        	if (this._pDataBuffer) {
        	    var pData: IVertexData;

        	    for (var i:  number  = 0, n:  number  = this._pDataBuffer.length; i < n; i++) {
                    pData = this._pDataBuffer.getVertexData(i);
        	        if (pData.hasSemantics(sSemantics)) {
        	            return pData.byteLength;
        	        }
        	    };
        	}

        	return -1;
        }

        private createDataBuffer() {
//TODO: add support for eOptions
            var iVbOption:  number  = 0;
            var iOptions:  number  = this._eDataOptions;

            if (iOptions & ERenderDataBufferOptions.VB_READABLE) {
                (true ? ((iVbOption) |= (1 << (((1 << (EHardwareBufferFlags.READABLE)) ))) ) : ((iVbOption) &= ~ (1 << (((1 << (EHardwareBufferFlags.READABLE)) ))) ) ) ;
            }
//trace('creating new video buffer for render data buffer ...');
            this._pDataBuffer = this._pEngine.getResourceManager().createVideoBuffer("render_data_buffer" + "_" + sid());
            this._pDataBuffer.create(iVbOption);
            this._pDataBuffer.addRef();
            return this._pDataBuffer !== null;
        };

        getRenderData(iSubset:  number ): IRenderData {
        	return this._pDataArray[iSubset];
        }

        getEmptyRenderData(ePrimType: EPrimitiveTypes, iOptions:  number  = 0): IRenderData {

        	var iSubsetId:  number  = this._pDataArray.length;
        	var pDataset: IRenderData = new RenderData(this);

        	iOptions |= this._eDataOptions;

        	if (!pDataset._setup(this, iSubsetId, ePrimType, iOptions)) {
        	    logger.setSourceLocation( "render/RenderDataCollection.ts" , 186 ); logger.error("cannot setup submesh..."); ;
        	}


        	this._pDataArray.push(pDataset);

        	return pDataset;
        }

        _draw(): void;
        _draw(iSubset?:  number ): void {
        	if (arguments.length > 0) {
        	    this._pDataArray[iSubset]._draw();
        	}

        	for (var i:  number  = 0; i < this._pDataArray.length; i++) {
        	    this._pDataArray[i]._draw();
        	};
        }

        destroy(): void {
        	this._pDataArray = null

            if (this._pDataBuffer) {
// this._pDataBuffer.release();
                this._pDataBuffer.destroy();
                this._pDataBuffer = null;
            }

            this._pEngine = null;
            this._eDataOptions = 0;
        }

        private setup(eOptions:  number  = 0) {
            this._eDataOptions = eOptions;
        };

// inline isValid(): bool { return true; }
// inline isDynamic(): bool { return false; }
// inline isStatic(): bool { return false; }
// inline isStream(): bool { return false; }
// inline isReadable(): bool { return true; }
// inline isBackupPresent(): bool { return true; }

	}

    export function createRenderDataCollection(pEngine: IEngine, iOptions:  number  = 0): IRenderDataCollection {
        return new RenderDataCollection(pEngine, iOptions);
    }
}























module akra.util {
	export interface IBuffersCompatibleMap {
		[handle:  number ]: IVertexData;
	}

	class BufferMap implements IBufferMap extends ReferenceCounter{
		private _pFlows: IDataFlow[] = null;
		private _pMappers: IDataMapper[] = null;
		private _pIndex: IIndexData = null;
		private _nLength:  number  = 0;
		private _ePrimitiveType: EPrimitiveTypes;
		private _pCompleteFlows: IDataFlow[] = null;
		private _nCompleteFlows:  number  = 0;
		private _nCompleteVideoBuffers:  number  = 0;
		private _pCompleteVideoBuffers: IVertexBuffer[] = null;
		private _nUsedFlows:  number  = 0;
		private _pEngine: IEngine = null;
		private _nStartIndex:  number  = 0;
		private _pBuffersCompatibleMap: IBuffersCompatibleMap = null;

		constructor(pEngine: IEngine){
			super();
			this._pEngine = pEngine;
			this.reset();
		}

		/**@inline*/  get primType(): EPrimitiveTypes{
			return this._pIndex ? this._pIndex.getPrimitiveType() : this._ePrimitiveType;
		}

		/**@inline*/  set primType(eType: EPrimitiveTypes){
			this._ePrimitiveType = eType;
		}

		/**@inline*/  get primCount():  number  {
			return data.IndexData.getPrimitiveCount(this._ePrimitiveType, this.length);
		}

		/**@inline*/  get index(): IIndexData {
			return this._pIndex;
		}

		/**@inline*/  set index(pIndexData: IIndexData) {
			if (this._pIndex === pIndexData) {
	            return;
	        }

	        this._pIndex = pIndexData;
	        this.update();
		}

		/**@inline*/  get limit():  number  {
			return this._pFlows.length;
		}

		/**@inline*/  get length():  number  {
			return (this._pIndex? this._pIndex.getPrimitiveCount(): this._nLength);
		}

		/**@inline*/  set length(nLength:  number ) {
			this._nLength = Math.min(this._nLength, nLength);
		}

		/**@inline*/  set _length(nLength:  number ) {
			this._nLength = nLength;
		}

		/**@inline*/  get startIndex():  number  {
			return this._nStartIndex;
		}

		/**@inline*/  get size():  number {
			return this._nCompleteFlows;
		}

		/**@inline*/  get flows(): IDataFlow[] {
			return this._pCompleteFlows;
		}

		/**@inline*/  get mappers(): IDataMapper[] {
			return this._pMappers;
		}

		/**@inline*/  get offset():  number  {
			return (this._pIndex? this._pIndex.byteOffset: 0);
		}

		_draw(): void {
			this._pEngine.getRenderer().getActiveProgram().applyBufferMap(this);
			isNull(this._pIndex)? this.drawArrays(): this.drawElements();
		}

		private  /**@inline*/  drawArrays(): void {

			(<IWebGLRenderer>this._pEngine.getRenderer()).getWebGLContext().drawArrays(
				webgl.getWebGLPrimitiveType(this._ePrimitiveType),
				this._nStartIndex,
				this._nLength);

		}

		private  /**@inline*/  drawElements(): void {

			(<IWebGLRenderer>this._pEngine.getRenderer()).getWebGLContext().drawElements(
				this.primCount,
				this._pIndex.getPrimitiveCount(),
				webgl.getWebGLPrimitiveType(this._ePrimitiveType),
				this._pIndex.byteOffset / 4);
//FIXME: offset of drawElement() in Glintptr = long long = 32 byte???

		}

		getFlow(sSemantics: string, bComplete: bool = true): IDataFlow;
		getFlow(iFlow:  number , bComplete: bool = true): IDataFlow;
		getFlow(iFlow: any, bComplete: bool = true): IDataFlow {

		    if (isString(arguments[0])) {
		        var nTotal:  number ;
		        var pFlows: IDataFlow[];

		        if (bComplete) {
		            pFlows = this._pCompleteFlows;
		            nTotal = this._nCompleteFlows;
		        }
		        else {
		            pFlows = this._pFlows;
		            nTotal = this._pFlows.length;
		        }

		        for (var i:  number  = 0; i < nTotal; ++ i) {
		            if (!pFlows[i].data) {
		                continue;
		            }
		            if (pFlows[i].data.hasSemantics(arguments[0])) {
		                return pFlows[i];
		            }
		        }

		        return null;
		    }

		    if (bComplete) {

		        for (var i:  number  = 0, pFlows = this._pCompleteFlows; i < this._nCompleteFlows; ++ i) {
		            if (pFlows[i].flow == iFlow) {
		                return pFlows[i];
		            }
		        }

		        return null;
		    }

		    return this._pFlows[iFlow];
		}

		reset(): void {
			this._pIndex = null
		    this._ePrimitiveType = EPrimitiveTypes.TRIANGLELIST;


		    var nFlowLimit:  number  = 16;

/*webgl.maxVertexTextureImageUnits*/
			nFlowLimit = Math.min(16                                    , webgl.maxVertexAttributes);


		    this._pMappers = [];
		    this._pFlows = new Array(nFlowLimit);
		    for (var i = 0; i < nFlowLimit; i++) {
		        this._pFlows[i] = {
		            flow: i,
		            data:  null,
		            type:  EDataFlowTypes.UNMAPPABLE,
		            mapper:null
		        };
		    }

		    this._nLength = MAX_INT32;
		    this._pCompleteFlows = new Array(nFlowLimit);
		    this._nCompleteFlows = 0;
		    this._nStartIndex = MAX_INT32;
		    this._pBuffersCompatibleMap = <IBuffersCompatibleMap>{};

		    this._pCompleteVideoBuffers = new Array(nFlowLimit);
		    this._nCompleteVideoBuffers = 0;
		    this._nUsedFlows = 0;
		}

		flow(pVertexData: IVertexData):  number ;
		flow(iFlow:  number , pVertexData: IVertexData):  number ;
		flow(iFlow, pData?):  number  {
			var pFlow: IDataFlow;
			var pVertexData: IVertexData;

		    if (arguments.length < 2) {
		        pVertexData = <IVertexData>arguments[0];
		        iFlow = (this._nUsedFlows ++);
		    }
// trace(iFlow, '<<==', pVertexData.getVertexDeclaration().toString());
// console.log((new Error).stack);
		    pFlow = this._pFlows[iFlow];

		    logger.setSourceLocation( "util/BufferMap.ts" , 218 ); logger.assert(iFlow < this.limit, 'Invalid strem. Maximum allowable number of stream ' + this.limit + '.');
                                                                                  ;

		    if (!pVertexData || pFlow.data === pVertexData) {
		        return -1;
		    }

		    if (pVertexData.buffer instanceof core.pool.resources.VertexBuffer) {
		        pFlow.type = EDataFlowTypes.UNMAPPABLE;
		        this.length = pVertexData.length;
//this.startIndex = pVertexData.getStartIndex();
		        logger.setSourceLocation( "util/BufferMap.ts" , 229 ); logger.assert(this.checkData(pVertexData), 'You can use several unmappable data flows from one buffer.');
                                                                           ;

		        this.pushEtalon(pVertexData);
		    }
		    else {
		        pFlow.type = EDataFlowTypes.MAPPABLE;
		    }

		    pFlow.data = pVertexData;

		    return this.update()? iFlow: -1;
		}

		checkData(pData: IVertexData): bool {
			var pEtalon = this._pBuffersCompatibleMap[pData.getBufferHandle()];
		    if (!pEtalon || pEtalon.byteOffset === pData.byteOffset) {
		        return true;
		    }
		    return false;
		}

		/**@protected*/  findMapping(pMap, eSemantics, iAddition): IDataMapper {
		    logger.setSourceLocation( "util/BufferMap.ts" , 251 ); logger.assert(this.checkData(pMap), 'You can use several different maps from one buffer.'); ;
		    for (var i = 0, pMappers = this._pMappers, pExistsMap; i < pMappers.length; i++) {
		        pExistsMap = pMappers[i].data;
		        if (pExistsMap === pMap) {
//если уже заданные маппинг менял свой стартовый индекс(например при расширении)
//то необходимо сменить стартовый индекс на новый
		            if (pMappers[i].semantics === eSemantics && pMappers[i].addition == iAddition) {
		                return pMappers[i];
		            }
		        }
		        else {
		            logger.setSourceLocation( "util/BufferMap.ts" , 263 ); logger.assert(pExistsMap.getStartIndex() === pMap.getStartIndex(), 'You can not use maps with different indexing');
                                                                 ;
		        }
		    }
		    return null;
		};


		mapping(iFlow:  number , pMap: IVertexData, eSemantics: string, iAddition?:  number ): bool {
			iAddition = iAddition || 0;

		    var pMapper: IDataMapper = this.findMapping(pMap, eSemantics, iAddition);
		    var pFlow: IDataFlow     = this._pFlows[iFlow];

		    logger.setSourceLocation( "util/BufferMap.ts" , 277 ); logger.assert(pFlow.data && pFlow.type === EDataFlowTypes.MAPPABLE, 'Cannot mapping empty/unmappable flow.');
                                                  ;
		    logger.setSourceLocation( "util/BufferMap.ts" , 278 ); logger.assert(isDef(pMap), 'Passed empty mapper.'); ;

		    if (!eSemantics) {
		        eSemantics = pMap.getVertexDeclaration()[0].eUsage;
		    }
		    else if (pMap.hasSemantics(eSemantics) === false) {
		        logger.setSourceLocation( "util/BufferMap.ts" , 284 ); logger.error('Passed mapper does not have semantics: ' + eSemantics + '.'); ;
		        return false;
		    }

		    if (pMapper) {
		        if (pFlow.mapper === pMapper) {
		            return pMapper.semantics === eSemantics &&
		                pMapper.addition === iAddition? true: false;
		        }
		    }
		    else {
		        pMapper = {data: pMap, semantics: eSemantics, addition: iAddition};

		        this._pMappers.push(pMapper);
		        this.length = pMap.length;
//this.startIndex = pMap.getStartIndex();
		        this.pushEtalon(pMap);
		    }

		    pFlow.mapper = pMapper;

		    return this.update();
		}

		private pushEtalon(pData: IVertexData): void {
			this._pBuffersCompatibleMap[pData.getBufferHandle()] = pData;
		}

		update(): bool {
			var pFlows: IDataFlow[] = this._pFlows;
		    var pFlow, pMapper;
		    var isMappable: bool = false;
		    var pCompleteFlows: IDataFlow[] = this._pCompleteFlows;
		    var nCompleteFlows:  number  = 0;
		    var pCompleteVideoBuffers: IVertexBuffer[] = this._pCompleteVideoBuffers;
		    var nCompleteVideoBuffers:  number  = 0;
		    var nUsedFlows:  number  = 0;
		    var pVideoBuffer: IVertexBuffer;
		    var isVideoBufferAdded: bool = false;
		    var nStartIndex:  number  = MAX_INT32, nCurStartxIndex:  number ;

		    for (var i:  number  = 0; i < pFlows.length; i++) {
		        pFlow = pFlows[i];
		        pMapper = pFlow.mapper;
		        isMappable = (pFlow.type === EDataFlowTypes.MAPPABLE);

		        if (pFlow.data) {
		            nUsedFlows ++;
		        }

		        if (pFlow.data === null || (isMappable && pMapper === null)) {
		            continue;
		        }

		        pCompleteFlows[nCompleteFlows ++] = pFlow;

		        if (isMappable) {
		            nCurStartxIndex = pMapper.data.getStartIndex();
		            pVideoBuffer = pFlow.data.buffer;
		            for (var j = 0; j < nCompleteVideoBuffers; j++) {
		                if (pCompleteVideoBuffers[j] === pVideoBuffer) {
		                    isVideoBufferAdded = true;
		                    break;
		                }
		            }
		            if (!isVideoBufferAdded) {
		                pCompleteVideoBuffers[nCompleteVideoBuffers ++] = pVideoBuffer;
		            }
		        }
		        else {
		            nCurStartxIndex = pFlow.data.getStartIndex();
		        }

		        if (nStartIndex === MAX_INT32) {
		            nStartIndex = nCurStartxIndex;
		            continue;
		        }

		        logger.setSourceLocation( "util/BufferMap.ts" , 363 ); logger.assert(nStartIndex == nCurStartxIndex, 'You can not use a maps or unmappable buffers having different starting index.');
                                                                                              ;
		    }

		    this._nStartIndex = nStartIndex;
		    this._nCompleteFlows = nCompleteFlows;
		    this._nCompleteVideoBuffers = nCompleteVideoBuffers;
		    this._nUsedFlows = nUsedFlows;

		    return true;
		}
		clone(bWithMapping?: bool): IBufferMap {
			bWithMapping = isDef(bWithMapping) ? bWithMapping : true;

		    var pMap: IBufferMap = new BufferMap(this._pEngine);
		    for (var i = 0, pFlows = this._pFlows; i < pFlows.length; ++ i) {
		        if (pFlows[i].data === null) {
		            continue;
		        }

		        if (pMap.flow(pFlows[i].flow, pFlows[i].data) < 0) {
		            pMap = null;
		            return null;
		        }

		        if (!bWithMapping) {
		            continue;
		        }

		        if (pFlows[i].mapper) {
	                pMap.mapping(pFlows[i].flow,
	                pFlows[i].mapper.data,
	                pFlows[i].mapper.semantics,
	                pFlows[i].mapper.addition);
		        }
		    }

		    return pMap;
		}
		toString(): string {
			function _an(sValue, n:  number , bBackward?: bool) {
		        sValue = String(sValue);
		        bBackward = bBackward || false;

		        if (sValue.length < n) {
		            for (var i = 0, l = sValue.length; i < n - l; ++ i) {
		                if (!bBackward) {
		                    sValue += ' ';
		                }
		                else {
		                    sValue = ' ' + sValue;
		                }
		            }
		        }

		        return sValue;
		    }

		    var s = '\n\n', t;
		    s += '      Complete Flows     : OFFSET / SIZE   |   BUFFER / OFFSET   :      Mapping  / Shift    : OFFSET |    Additional    \n';
		    t  = '-------------------------:-----------------+---------------------:--------------------------:--------+------------------\n';
// = '#%1 [ %2 ]           :     %6 / %7     |       %3 / %4       :         %5       :        |                  \n';
// = '#%1 [ %2 ]           :     %6 / %7     |       %3 / %4       :         %5       :        |                  \n';
		    s += t;

		    for (var i:  number  = 0; i < this._nCompleteFlows; ++ i) {
		        var pFlow: IDataFlow = this._pCompleteFlows[i];
		        var pMapper: IDataMapper = pFlow.mapper;
		        var pVertexData: IVertexData = pFlow.data;
		        var pDecl: IVertexDeclaration = pVertexData.getVertexDeclaration();
//trace(pMapper); window['pMapper'] = pMapper;
		        s += '#' + _an(pFlow.flow, 2) + ' ' +
		            _an('[ ' + (pDecl.element(0).usage !== DeclUsages.END? pDecl.element(0).usage: '<end>') + ' ]', 20) +
		            ' : ' + _an(pDecl.element(0).offset, 6, true) + ' / ' + _an(pDecl.element(0).size, 6) +
		            ' | ' +
		            _an(pVertexData.getBufferHandle(), 8, true) + ' / ' + _an(pVertexData.byteOffset, 8) +
		            ' : ' +
		            (pMapper? _an(pMapper.semantics, 15, true) + ' / ' + _an(pMapper.addition, 7) + ': ' +
		                _an(pMapper.data.getVertexDeclaration().findElement(pMapper.semantics).offset, 6) :
		            _an('-----', 25) + ': ' + _an('-----', 6)) + ' |                  \n';


		        for (var j = 1; j < pDecl.length; ++ j) {
		            s += '    ' +
		            _an('[ ' + (pDecl.element(j).usage !== DeclUsages.END? pDecl.element(j).usage: '<end>') + ' ]', 20) + ' : ' + _an(pDecl[j].iOffset, 6, true) + ' / ' + _an(pDecl[j].iSize, 6) +
		                  ' |                     :                          :        |                  \n';
		        }
		        s += t;
		    };
		    s += '=================================================================\n';
		    s += '      PRIMITIVE TYPE : ' + '0x' + Number(this.primType).toString(16) + '\n';
		    s += '     PRIMITIVE COUNT : ' + this.primCount + '\n';
		    s += '         START INDEX : ' + this.startIndex + '\n';
		    s += '              LENGTH : ' + this.length + '\n';
		    s += '  USING INDEX BUFFER : ' + (this.index? 'TRUE': 'FALSE') + '\n';
		    s += '=================================================================\n';

		    return s + '\n\n';
		}
	}

	export function createBufferMap(pEngine: IEngine): IBufferMap {
		return new BufferMap(pEngine);
	}
}










module akra {
	export interface ISceneNode {} ;
	export interface IJoint {} ;
	export interface IAnimationFrame {} ;
	export interface IAnimationTrack {} ;

	export interface IAnimationTarget{
		target: ISceneNode;
		index:  number ;
		name: string;
		track?: IAnimationTrack;
	}

	export interface IAnimationBase extends IEventProvider {
		duration:  number ;
		name: string;


		play(fRealTime:  number ): void;
		stop(fRealTime:  number ): void;

		attach(pTarget: ISceneNode): void;

		frame(sName: string, fRealTime:  number ): IAnimationFrame;
		apply(fRealTime:  number ): void;

		addTarget(sName: string, pTarget: ISceneNode): IAnimationTarget;
		setTarget(sName: string, pTarget: ISceneNode): IAnimationTarget;
		getTarget(sTargetName: string): IAnimationTarget;
		getTargetList(): IAnimationTarget[];
		getTargetByName(sName: string): IAnimationTarget;
		targetNames(): string[];
		targetList(): ISceneNode[];
		jointList(): IJoint[];
		grab(pAnimationBase: IAnimationBase, bRewrite?: bool): void;

		createAnimationMask(): FloatMap;

	}
}






module akra {
	export interface IAnimationBase {} ;
	export interface IEngine {} ;
	export interface ISceneNode {} ;

	export interface IAnimationController{
		 totalAnimations:  number ;
		 active: IAnimationBase;

		getEngine(): IEngine;
		setOptions(eOptions): void;
		addAnimation(pAnimation: IAnimationBase): bool;

		removeAnimation(): bool;

		findAnimation(pAnimation: string): IAnimationBase;
		findAnimation(pAnimation:  number ): IAnimationBase;
		findAnimation(pAnimation: IAnimationBase): IAnimationBase;

		getAnimation(iAnim:  number ): IAnimationBase;

		setAnimation(iAnimation:  number , pAnimation: IAnimationBase): void;
		bind(pTarget: ISceneNode): void;
		play(pAnimation: IAnimationBase, fRealTime:  number ): bool;

		update(fTime:  number ): void;
	}
}




module akra.animation {
	export class AnimationController implements IAnimationController {
		private _pEngine: IEngine;
		private _pAnimations: IAnimationBase[] = [];
		private _eOptions = 0;
	    private _pActiveAnimation: IAnimationBase = null;
	    private _fnPlayAnimation: Function = null;

	    /**@inline*/  get totalAnimations():  number {
			return this._pAnimations.length;
		}

		/**@inline*/  get active(): IAnimationBase{
			return this._pActiveAnimation;
		}

		constructor(pEngine: IEngine, iOptions:  number  = 0){
			this._pEngine = pEngine;


			this.setOptions(iOptions);
		}

		getEngine(): IEngine {
			return this._pEngine;
		}

		setOptions(iOptions:  number ): void {

		}

		addAnimation(pAnimation: IAnimationBase): bool {
			if (this.findAnimation(pAnimation.name)) {
				logger.setSourceLocation( "animation/AnimationController.ts" , 41 ); logger.warning("Animation with name <" + pAnimation.name + "> already exists in this controller"); ;
				return false;
			}

//LOG('animation controller :: add animation >> ', pAnimation.name);

			this._pAnimations.push(pAnimation);
			this._pActiveAnimation = pAnimation;
		}

		removeAnimation(): bool {
			var pAnimation = this.findAnimation(arguments[0]);
		    var pAnimations = this._pAnimations;

			for (var i = 0; i < pAnimations.length; ++ i) {
				if (pAnimations[i] === pAnimation) {
					pAnimations.splice(i, 1);
					logger.setSourceLocation( "animation/AnimationController.ts" , 58 ); logger.log("animation controller :: remove animation >> ", pAnimation.name); ;
					return true;
				}
			}

			return false;
		}

		findAnimation(pAnimation: string): IAnimationBase;
		findAnimation(pAnimation:  number ): IAnimationBase;
		findAnimation(pAnimation: IAnimationBase): IAnimationBase;
		findAnimation(pAnimation: any): IAnimationBase {
			var pAnimations: IAnimationBase[] = this._pAnimations;
		    var iAnimation:  number ;
		    var sAnimation: string;

			if (isString(arguments[0])) {
				sAnimation = arguments[0];

				for (var i = 0; i < pAnimations.length; ++ i) {
					if (pAnimations[i].name === sAnimation) {
						return pAnimations[i];
					}
				}

				return null;
			}

			if (typeof arguments[0] === 'number') {
				iAnimation = arguments[0];
				return pAnimations[iAnimation] || null;
			}

			return arguments[0];
		}

		getAnimation(iAnim:  number ): IAnimationBase {
			return this._pAnimations[iAnim];
		}

		setAnimation(iAnimation:  number , pAnimation: IAnimationBase): void {
			logger.setSourceLocation( "animation/AnimationController.ts" , 99 ); logger.assert(iAnimation < this._pAnimations.length, 'invalid animation slot'); ;

			this._pAnimations[iAnimation] = pAnimation;
		}

		bind(pTarget: ISceneNode): void {
			var pAnimations: IAnimationBase[] = this._pAnimations;

		    for (var i:  number  = 0; i < pAnimations.length; ++ i) {
		        pAnimations[i].attach(pTarget);
		    }
		}

		play(pAnimation: IAnimationBase, fRealTime:  number ): bool {
			var pAnimationNext: IAnimationBase = this.findAnimation(arguments[0]);
			var pAnimationPrev: IAnimationBase = this._pActiveAnimation;

			if (pAnimationNext && pAnimationNext !== pAnimationPrev) {
				if (this._fnPlayAnimation) {
					this._fnPlayAnimation(pAnimationNext);
				}
//LOG('controller::play(', pAnimationNext.name, ')', pAnimationNext);
				if (pAnimationPrev) {
					pAnimationPrev.stop(fRealTime);
				}

				pAnimationNext.play(fRealTime);

				this._pActiveAnimation = pAnimationNext;

				return true;
			}

			return false;
		}

		update(fTime:  number ): void {
			if (this._pActiveAnimation) {
				this._pActiveAnimation.apply(fTime);
			}
		}
	}


	export function createController(pEngine: IEngine, iOptions:  number ): IAnimationController {
		return new AnimationController(pEngine, iOptions);
	}
}













module akra.model {

	class Skeleton implements ISkeleton{
		private _sName: string;
		private _pRootJoints: IJoint[] = [];
		private _pJointMap: IJointMap = null;
		private _pNodeList: ISceneNode[]  = null;
		private _pMeshNode: ISceneModel = null;
		private _iFlags: bool = false;


		/**@inline*/  get totalBones():  number {
			return Object.keys(this._pJointMap).length;
		}

		/**@inline*/  get totalNodes():  number {
			return this._pNodeList.length;
		}

		/**@inline*/  get name(): string{
			return this._sName;
		}

		/**@inline*/  get root(): IJoint {
			return this._pRootJoints[0] || null;
		}

		constructor (sName: string = null) {
			this._sName = sName;
		}

		getRootJoint(): IJoint {
			return this.getRootJoints()[0];
		}

		getRootJoints(): IJoint[] {
			return this._pRootJoints;
		}

		getJointMap(): IJointMap {
			return this._pJointMap;
		}

		getNodeList(): ISceneNode[]{
			return this._pNodeList;
		}

		addRootJoint(pJoint: IJoint): bool {
			logger.setSourceLocation( "model/Skeleton.ts" , 56 ); logger.assert(pJoint instanceof scene.Joint, 'node must be joint'); ;

		    var pRootJoints = this._pRootJoints;

			for (var i = 0; i < pRootJoints.length; i++) {
				if (pJoint.childOf(pRootJoints[i])) {
					return false;
				}
				else if (pRootJoints[i].childOf(pJoint)) {
					pRootJoints.splice(i, 1);
				}
			};

			this._pRootJoints.push(pJoint);

			return this.update();
		}

		update(): bool {
			var pRootJoints = this._pRootJoints;
		    var pJointList = this._pJointMap = <IJointMap>{};
		    var pNodeList = this._pNodeList = [];
//var pNotificationJoints = this._pNotificationJoints = [];

		    function findNodes (pNode) {
		    	var sJoint;

		    	if (pNode) {
			    	sJoint = pNode.boneName;

			    	if (sJoint) {
			    		logger.setSourceLocation( "model/Skeleton.ts" , 88 ); logger.assert(!pJointList[sJoint], 'joint with name<' + sJoint + '> already exists in skeleton <' + this._sName + '>');
                                                                                             ;
			    		pJointList[sJoint] = pNode;
			    	}

			    	pNodeList.push(pNode);

			    	findNodes(pNode.sibling());
			    	findNodes(pNode.child());
		    	}
		    }

		    for (var i = 0; i < pRootJoints.length; i++) {
		    	findNodes(pRootJoints[i]);
		    };

// for (var sJoint in pJointList) {
// 	var pJoint = pJointList[sJoint];

//    	if (pJoint.sibling() == null && pJoint.child() == null) {
//    		pNotificationJoints.push(pJoint);
//    	}
//    };    

			return true;
		}

		findJoint(sName: string): IJoint {
			return this._pJointMap[sName];
		}

		findJointByName(sName: string): IJoint {
			for (var s in this._pJointMap) {
				if (this._pJointMap[s].name === sName) {
					return this._pJointMap[s];
				}
			}

			return null;
		}

		attachMesh(pMesh: IMesh): bool {
			if (isNull(this.root)) {
				return false;
			}

		    if (this._pMeshNode == null) {
		    	this._pMeshNode = this.root.scene.createModel();
		    	this._pMeshNode.setInheritance(ENodeInheritance.ALL);
		    	this._pMeshNode.attachToParent(this.root);
		    }

		    this._pMeshNode.name = this.name + "[mesh-container]";
		    this._pMeshNode.mesh = (pMesh);

		    return true;
		}

		detachMesh(): void {
//TODO: write detach method.
		}
	}

	export function createSkeleton(sName: string = null): ISkeleton {
		return new Skeleton(sName);
	}
}








module akra.core {
	export class Engine implements IEngine {

		private _pResourceManager: IResourcePoolManager;
		private _pSceneManager: ISceneManager;
		private _pParticleManager: IParticleManager;
		private _pRenderer: IRenderer;

/** stop render loop?*/

		private _pTimer: IUtilTimer;
		private _iAppPausedCount:  number  = 0;


/** is paused? */

		private _isActive: bool = false;
/** frame rendering sync / render next frame? */

		private _isFrameMoving: bool = true;



		constructor () {
			this._pResourceManager = new pool.ResourcePoolManager(this);
			this._pSceneManager = new scene.SceneManager(this);
			this._pParticleManager = null;


			this._pRenderer = new webgl.WebGLRenderer(this);



			if (!this._pResourceManager.initialize()) {
				logger.setSourceLocation( "core/Engine.ts" , 60 ); logger.error('cannot initialize ResourcePoolManager'); ;
			}

			if (!this._pSceneManager.initialize()) {
				logger.setSourceLocation( "core/Engine.ts" , 64 ); logger.error("cannot initialize SceneManager"); ;
			}

			this._pTimer = util.UtilTimer.start();
			this.pause(false);
		}

		getSceneManager(): ISceneManager {
			return this._pSceneManager;
		}

		getParticleManager(): IParticleManager {
			return null;
		}

		getResourceManager(): IResourcePoolManager {
			return null;
		}

		getRenderer(): IRenderer {
			return this._pRenderer;
		}

		/**@inline*/  isActive(): bool {
			return this._isActive;
		}

		exec(bValue: bool = true): void {
			var pRenderer: IRenderer = this._pRenderer;
			var pEngine: IEngine = this;
// var pCanvas: HTMLCanvasElement = null;


// pCanvas = (<IWebGLRenderer>pRenderer).getHTMLCanvas();


			logger.setSourceLocation( "core/Engine.ts" , 100 ); logger.assert(!isNull(pRenderer)); ;

	        pRenderer._initRenderTargets();

// Infinite loop, until broken out of by frame listeners
// or break out by calling queueEndRendering()
	        this._isActive = bValue;

	        function render(iTime:  number ): void {

				if (pRenderer.isValid()) {
					logger.setSourceLocation( "core/Engine.ts" , 111 ); logger.error(pRenderer.getError()); ;
				}

	        	if (!pEngine.isActive()) {
	                return;
	            }

	            if (!pEngine.renderFrame()) {
	                logger.setSourceLocation( "core/Engine.ts" , 119 ); logger.error("Engine::exec() error."); ;
	                return;
	            }

/*, pCanvas*/
	            requestAnimationFrame(render             );
	        }

	        render(0);
		}

		/**@inline*/  getTimer(): IUtilTimer { return this._pTimer; }

		renderFrame(): bool {
		    var fElapsedAppTime:  number  	= this._pTimer.elapsedTime;

		    if (0. == fElapsedAppTime && this._isFrameMoving) {
		        return true;
		    }

// FrameMove (animate) the scene
		    if (this._isFrameMoving) {
		    	this._pSceneManager.update();
		    }

// Render the scene as normal
	    	this.frameStarted();
		    this._pRenderer._updateAllRenderTargets();
		    this.frameEnded();

			return true;
		}

		play(): bool {
			if (!this._isActive) {
				this._iAppPausedCount = 0;
				this._isActive = true;

				if (this._isFrameMoving) {
		            this._pTimer.start();
		        }
	        }

	        return this._isActive;
		}

		pause(isPause: bool = false): bool {
			this._iAppPausedCount += ( isPause ? +1 : -1 );
		    this._isActive = ( this._iAppPausedCount ? false : true );

// Handle the first pause request (of many, nestable pause requests)
		    if (isPause && ( 1 == this._iAppPausedCount )) {
// Stop the scene from animating
		        if (this._isFrameMoving) {
		            this._pTimer.stop();
		        }
		    }

		    if (0 == this._iAppPausedCount) {
// Restart the timers
		        if (this._isFrameMoving) {
		            this._pTimer.start();
		        }
		    }

		    return !this._isActive;
		}

		/**@inline*/  createMesh(sName: string = null, eOptions:  number  = 0, pDataBuffer: IRenderDataCollection = null): IMesh {
			return model.createMesh(this, sName, eOptions, pDataBuffer);
		}

		/**@inline*/  createRenderDataCollection(iOptions:  number  = 0): IRenderDataCollection {
			return render.createRenderDataCollection(this, iOptions);
		}

		/**@inline*/  createBufferMap(): IBufferMap {
			return util.createBufferMap(this);
		}

		/**@inline*/  createAnimationController(iOptions:  number  = 0): IAnimationController {
			return animation.createController(this, iOptions);
		}

		private _iGuid: number = eval("this._iGuid || akra.sid()"); private _pUnicastSlotMap: IEventSlotMap = null; private _pBroadcastSlotList: IEventSlotListMap = null; private static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable {return Engine._pEventTable; } getGuid(): number {return this._iGuid < 0? (this._iGuid = sid()): this._iGuid; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
			frameStarted (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).frameStarted; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
			frameEnded (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).frameEnded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		;

	}

}

module akra {
	createEngine = function (): IEngine {
		return new core.Engine();
	}
}

/*
		private initDefaultStates(): bool {
			this.pRenderState = {
		        mesh            : {
		            isSkinning : false
		        },
		        isAdvancedIndex : false,
		        lights          : {
		            omni : 0,
		            project : 0,
		            omniShadows : 0,
		            projectShadows : 0
		        }
		    };

			return true;
		}
 */




// #include "util/ObjectArray.ts"
// #include "util/ObjectList.ts"




module akra {
	var pEngine = createEngine();
	var pSceneManager: ISceneManager = pEngine.getSceneManager();
	var pScene3D: IScene3d = pSceneManager.createScene3D();

	var pOctree: IOcTree = new scene.OcTree();
	pOctree.create(new geometry.Rect3d(1000,1000,1000),5,100);

	var i:  number  = pScene3D.addDisplayList(pOctree);
	logger.setSourceLocation( "C:/WebServers/home/akra/www/akra-engine-core/src2/tests/common/culling/octree.ts" , 18 ); logger.assert(i == 0 , "invalid default list index"); ;

	var pLightGraph: ILightGraph = new scene.LightGraph();

	i = pScene3D.addDisplayList(pLightGraph);
	logger.setSourceLocation( "C:/WebServers/home/akra/www/akra-engine-core/src2/tests/common/culling/octree.ts" , 23 ); logger.assert(i == 1 , "invalid default list index"); ;

// var pObject: ISceneObject = new scene.SceneObject(pScene3D);
// pObject.create();
// pObject.accessLocalBounds().set(0,100,0,100,0,100);
// pObject.attachToParent(pScene3D.getRootNode());

//pScene3D.recursiveUpdate();

// var pObject2: ISceneObject = new scene.SceneObject(pScene3D);
// pObject2.create();
// pObject2.accessLocalBounds().set(0,10,0,10,-500,-400);
// pObject2.attachToParent(pScene3D.getRootNode());

// var pObject3: ISceneObject = new scene.SceneObject(pScene3D);
// pObject3.create();
// pObject3.accessLocalBounds().set(0,10,0,10,-500,-475);
// pObject3.attachToParent(pScene3D.getRootNode());

// var pObject4: ISceneObject = new scene.SceneObject(pScene3D);
// pObject4.create();
// pObject4.accessLocalBounds().set(0,10,0,10,-475,-450);
// pObject4.attachToParent(pScene3D.getRootNode());

	var pObject5: ISceneObject = new scene.SceneObject(pScene3D);
	pObject5.create();
	pObject5.accessLocalBounds().set(0,10,0,10,-300,-100);
	pObject5.attachToParent(pScene3D.getRootNode());

	pScene3D.recursiveUpdate();
//pScene3D.recursiveUpdate();

	var pCamera: ICamera = new scene.objects.Camera(pScene3D);
	pCamera.create();
	pCamera.attachToParent(pScene3D.getRootNode());

	pScene3D.recursiveUpdate();

	var pLight: IProjectLight = new scene.light.ProjectLight(pScene3D);
	pLight.create();
	pLight.attachToParent(pScene3D.getRootNode());

//var pResult: any = pOctree._buildSearchResults(pCamera.searchRect, pCamera.frustum);
	var pResult: any = pCamera.display( 0 );

	console.log(pOctree);
	console.log(pOctree._toSimpleObject());
	console.warn(pResult);
	console.warn(pCamera);
	console.log(scene.objects.Camera._pEventTable);
}
