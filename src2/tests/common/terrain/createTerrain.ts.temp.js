var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
// #define CRYPTO_API 1
var akra;
(function (akra) {
    (function (ELogLevel) {
        ELogLevel._map = [];
        ELogLevel.NONE = 0x0000;
        ELogLevel.LOG = 0x0001;
        ELogLevel.INFORMATION = 0x0002;
        ELogLevel.WARNING = 0x0004;
        ELogLevel.ERROR = 0x0008;
        ELogLevel.CRITICAL = 0x0010;
        ELogLevel.ALL = 0x001F;
    })(akra.ELogLevel || (akra.ELogLevel = {}));
    var ELogLevel = akra.ELogLevel;
})(akra || (akra = {}));
/*I ## */
/*I ## */
/*I ## */
/*I ## */
var akra;
(function (akra) {
    akra.DEBUG = true;
    akra.logger;
    akra.typeOf;
    akra.typeOf = function /** @no-inline */typeOf(x) {
        var s = typeof x;
        if(s === "object") {
            if(x) {
                if(x instanceof Array) {
                    return 'array';
                } else if(x instanceof Object) {
                    return s;
                }
                var sClassName = Object.prototype.toString.call(x);
                if(sClassName == '[object Window]') {
                    return 'object';
                }
                if((sClassName == '[object Array]' || typeof x.length == 'number' && typeof x.splice != 'undefined' && typeof x.propertyIsEnumerable != 'undefined' && !x.propertyIsEnumerable('splice'))) {
                    return 'array';
                }
                if((sClassName == '[object Function]' || typeof x.call != 'undefined' && typeof x.propertyIsEnumerable != 'undefined' && !x.propertyIsEnumerable('call'))) {
                    return 'function';
                }
            } else {
                return 'null';
            }
        } else if(s == 'function' && typeof x.call == 'undefined') {
            return 'object';
        }
        return s;
    };
    /** @inline */
    akra.isDef = function /** @inline */(x) {
        return x !== undefined;
    };
    /** @inline */
    akra.isEmpty = function /** @inline */(x) {
        return x.length == 0;
    };
    // Note that undefined == null.
    /** @inline */
    akra.isDefAndNotNull = function /** @inline */(x) {
        return x != null;
    };
    /** @inline */
    akra.isNull = function /** @inline */(x) {
        return x === null;
    };
    /** @inline */
    akra.isBoolean = function /** @inline */(x) {
        return typeof x === "boolean";
    };
    /** @inline */
    akra.isString = function /** @inline */(x) {
        return typeof x === "string";
    };
    /** @inline */
    akra.isNumber = function /** @inline */(x) {
        return typeof x === "number";
    };
    /** @inline */
    akra.isFloat = akra.isNumber;
    /** @inline */
    akra.isInt = akra.isNumber;
    /** @inline */
    akra.isFunction = function /** @inline */(x) {
        return akra.typeOf(x) === "function";
    };
    /** @inline */
    akra.isObject = function /** @no-inline */(x) {
        var type = akra.typeOf(x);
        return type == "object" || type == "array" || type == "function";
    };
    akra.isArrayBuffer = function /** @inline */(x) {
        return x instanceof ArrayBuffer;
    };
    akra.isTypedArray = function /** @inline */(x) {
        return typeof x === "object" && typeof x.byteOffset === "number";
    };
    /** @inline */
    akra.isArray = function /** @no-inline */(x) {
        return akra.typeOf(x) == "array";
    };
    ;
    // if (!isDef(console.assert)) {
    //     console.assert = function (isOK?: bool, ...pParams: any[]): void {
    //         if (!isOK) {
    //             trace('---------------------------');
    //             trace.apply(null, pParams);
    //             throw new Error("[assertion failed]");
    //         }
    //     }
    // }
    // export var trace = console.log.bind(console);
    // export var assert = console.assert.bind(console);
    // export var warning = console.warn.bind(console);
    // export var error = console.error.bind(console);
    // export var debug_print = (pArg:any, ...pParams: any[]): void => {
    //         trace.apply(null, arguments);
    // }
    // export var debug_assert = (isOK: bool, ...pParams: any[]): void => {
    //         assert.apply(null, arguments);
    // }
    // export var debug_warning = (pArg:any, ...pParams: any[]): void => {
    //         warning.apply(null, arguments);
    // }
    // export var debug_error = (pArg:any, ...pParams: any[]): void => {
    //         error.apply(null, arguments);
    // }
    function /** @no-inline */genArray(pType, nSize) {
        var tmp = new Array(nSize);
        for(var i = 0; i < nSize; ++i) {
            tmp[i] = (pType ? new pType() : null);
        }
        return tmp;
    }
    akra.genArray = genArray;
    /**@const*/ akra.INVALID_INDEX = 0xffff;
    // (-2147483646);
    /**@const*/ akra.MIN_INT32 = 0xffffffff;
    // ( 2147483647);
    /**@const*/ akra.MAX_INT32 = 0x7fffffff;
    // (-32768);
    /**@const*/ akra.MIN_INT16 = 0xffff;
    // ( 32767);
    /**@const*/ akra.MAX_INT16 = 0x7fff;
    // (-128);
    /**@const*/ akra.MIN_INT8 = 0xff;
    // ( 127);
    /**@const*/ akra.MAX_INT8 = 0x7f;
    /**@const*/ akra.MIN_UINT32 = 0;
    /**@const*/ akra.MAX_UINT32 = 0xffffffff;
    /**@const*/ akra.MIN_UINT16 = 0;
    /**@const*/ akra.MAX_UINT16 = 0xffff;
    /**@const*/ akra.MIN_UINT8 = 0;
    /**@const*/ akra.MAX_UINT8 = 0xff;
    /**@const*/ akra.SIZE_FLOAT64 = 8;
    /**@const*/ akra.SIZE_REAL64 = 8;
    /**@const*/ akra.SIZE_FLOAT32 = 4;
    /**@const*/ akra.SIZE_REAL32 = 4;
    /**@const*/ akra.SIZE_INT32 = 4;
    /**@const*/ akra.SIZE_UINT32 = 4;
    /**@const*/ akra.SIZE_INT16 = 2;
    /**@const*/ akra.SIZE_UINT16 = 2;
    /**@const*/ akra.SIZE_INT8 = 1;
    /**@const*/ akra.SIZE_UINT8 = 1;
    /**@const*/ akra.SIZE_BYTE = 1;
    /**@const*/ akra.SIZE_UBYTE = 1;
    //1.7976931348623157e+308
    /**@const*/ akra.MAX_FLOAT64 = Number.MAX_VALUE;
    //-1.7976931348623157e+308
    /**@const*/ akra.MIN_FLOAT64 = -Number.MAX_VALUE;
    //5e-324
    /**@const*/ akra.TINY_FLOAT64 = Number.MIN_VALUE;
    //    export const MAX_REAL64: number = Number.MAX_VALUE;   //1.7976931348623157e+308
    //    export const MIN_REAL64: number = -Number.MAX_VALUE;  //-1.7976931348623157e+308
    //    export const TINY_REAL64: number = Number.MIN_VALUE;  //5e-324
    //3.4e38
    /**@const*/ akra.MAX_FLOAT32 = 3.4e38;
    //-3.4e38
    /**@const*/ akra.MIN_FLOAT32 = -3.4e38;
    //1.5e-45
    /**@const*/ akra.TINY_FLOAT32 = 1.5e-45;
    //    export const MAX_REAL32: number = 3.4e38;     //3.4e38
    //    export const MIN_REAL32: number = -3.4e38;    //-3.4e38
    //    export const TINY_REAL32: number = 1.5e-45;   //1.5e-45
    /**@const*/ akra.DEFAULT_MATERIAL_NAME = "default";
    (function (EDataTypes) {
        EDataTypes._map = [];
        EDataTypes.BYTE = 0x1400;
        EDataTypes.UNSIGNED_BYTE = 0x1401;
        EDataTypes.SHORT = 0x1402;
        EDataTypes.UNSIGNED_SHORT = 0x1403;
        EDataTypes.INT = 0x1404;
        EDataTypes.UNSIGNED_INT = 0x1405;
        EDataTypes.FLOAT = 0x1406;
    })(akra.EDataTypes || (akra.EDataTypes = {}));
    var EDataTypes = akra.EDataTypes;
    ;
    (function (EDataTypeSizes) {
        EDataTypeSizes._map = [];
        EDataTypeSizes.BYTES_PER_BYTE = 1;
        EDataTypeSizes.BYTES_PER_UNSIGNED_BYTE = 1;
        EDataTypeSizes.BYTES_PER_UBYTE = 1;
        EDataTypeSizes.BYTES_PER_SHORT = 2;
        EDataTypeSizes.BYTES_PER_UNSIGNED_SHORT = 2;
        EDataTypeSizes.BYTES_PER_USHORT = 2;
        EDataTypeSizes.BYTES_PER_INT = 4;
        EDataTypeSizes.BYTES_PER_UNSIGNED_INT = 4;
        EDataTypeSizes.BYTES_PER_UINT = 4;
        EDataTypeSizes.BYTES_PER_FLOAT = 4;
    })(akra.EDataTypeSizes || (akra.EDataTypeSizes = {}));
    var EDataTypeSizes = akra.EDataTypeSizes;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
        function /** @no-inline */getTypeSize(eType) {
        switch(eType) {
            case 5120 /* BYTE */ :
            case 5121 /* UNSIGNED_BYTE */ :
                return 1;
            case 5122 /* SHORT */ :
            case 5123 /* UNSIGNED_SHORT */ :
                //case EImageTypes.UNSIGNED_SHORT_4_4_4_4:
                //case EImageTypes.UNSIGNED_SHORT_5_5_5_1:
                //case EImageTypes.UNSIGNED_SHORT_5_6_5:
                return 2;
            case 5124 /* INT */ :
            case 5125 /* UNSIGNED_INT */ :
            case 5126 /* FLOAT */ :
                return 4;
            default:
                akra.logger.setSourceLocation("common.ts", 401);
                akra.logger.error('unknown data/image type used');
                ;
        }
    }
    akra.getTypeSize = getTypeSize;
    akra.sid = function /** @inline */() {
        return (++akra.sid._iTotal);
    };
    akra.sid._iTotal = 0;
    function /** @no-inline */now() {
        return (new Date()).getTime();
    }
    akra.now = now;
    function /** @inline */memcpy(pDst, iDstOffset, pSrc, iSrcOffset, nLength) {
        var dstU8 = new Uint8Array(pDst, iDstOffset, nLength);
        var srcU8 = new Uint8Array(pSrc, iSrcOffset, nLength);
        dstU8.set(srcU8);
    }
    akra.memcpy = memcpy;
    ;
    //export function
    (window).URL = (window).URL ? (window).URL : (window).webkitURL ? (window).webkitURL : null;
    (window).BlobBuilder = (window).WebKitBlobBuilder || (window).MozBlobBuilder || (window).BlobBuilder;
    (window).requestFileSystem = (window).requestFileSystem || (window).webkitRequestFileSystem;
    (window).requestAnimationFrame = (window).requestAnimationFrame || (window).webkitRequestAnimationFrame || (window).mozRequestAnimationFrame;
    (window).WebSocket = (window).WebSocket || (window).MozWebSocket;
    (window).storageInfo = (window).storageInfo || (window).webkitStorageInfo;
    Worker.prototype.postMessage = (Worker).prototype.webkitPostMessage || Worker.prototype.postMessage;
})(akra || (akra = {}));
;
function /** @no-inline */utf8_encode(argString) {
    // Encodes an ISO-8859-1 string to UTF-8
    //
    // version: 1109.2015
    // discuss at: http://phpjs.org/functions/utf8_encode
    // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +   improved by: sowberry
    // +    tweaked by: Jack
    // +   bugfixed by: Onno Marsman
    // +   improved by: Yves Sucaet
    // +   bugfixed by: Onno Marsman
    // +   bugfixed by: Ulrich
    // +   bugfixed by: Rafal Kukawski
    // *     example 1: utf8_encode('Kevin van Zonneveld');
    // *     returns 1: 'Kevin van Zonneveld'
    if(argString === null || typeof argString === "undefined") {
        return "";
    }
    // .replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    var string = (argString + "");
    var utftext = "", start, end, stringl = 0;
    start = end = 0;
    stringl = string.length;
    for(var n = 0; n < stringl; n++) {
        var c1 = string.charCodeAt(n);
        var enc = null;
        if(c1 < 128) {
            end++;
        } else if(c1 > 127 && c1 < 2048) {
            enc = String.fromCharCode((c1 >> 6) | 192) + String.fromCharCode((c1 & 63) | 128);
        } else {
            enc = String.fromCharCode((c1 >> 12) | 224) + String.fromCharCode(((c1 >> 6) & 63) | 128) + String.fromCharCode((c1 & 63) | 128);
        }
        if(enc !== null) {
            if(end > start) {
                utftext += string.slice(start, end);
            }
            utftext += enc;
            start = end = n + 1;
        }
    }
    if(end > start) {
        utftext += string.slice(start, stringl);
    }
    return utftext;
}
function /** @no-inline */utf8_decode(str_data) {
    // http://kevin.vanzonneveld.net
    // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
    // +      input by: Aman Gupta
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +   improved by: Norman "zEh" Fuchs
    // +   bugfixed by: hitwork
    // +   bugfixed by: Onno Marsman
    // +      input by: Brett Zamir (http://brett-zamir.me)
    // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // *     example 1: utf8_decode('Kevin van Zonneveld');
    // *     returns 1: 'Kevin van Zonneveld'
        var tmp_arr = [], i = 0, ac = 0, c1 = 0, c2 = 0, c3 = 0;
    str_data += "";
    while(i < str_data.length) {
        c1 = str_data.charCodeAt(i);
        if(c1 < 128) {
            tmp_arr[ac++] = String.fromCharCode(c1);
            i++;
        } else if(c1 > 191 && c1 < 224) {
            c2 = str_data.charCodeAt(i + 1);
            tmp_arr[ac++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
            i += 2;
        } else {
            c2 = str_data.charCodeAt(i + 1);
            c3 = str_data.charCodeAt(i + 2);
            tmp_arr[ac++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
            i += 3;
        }
    }
    return tmp_arr.join("");
}
var akra;
(function (akra) {
    (function (libs) {
        /**
        * Encodes an ISO-8859-1 string to UTF-8
        * @treturn String
        */
        String.prototype.toUTF8 = function /** @no-inline */() {
            return utf8_encode(this);
        };
        /**
        * Converts a UTF-8 encoded string to ISO-8859-1
        * @treturn String
        */
        String.prototype.fromUTF8 = function /** @no-inline */() {
            return utf8_decode(this);
        };
        String.prototype.replaceAt = function /** @no-inline */(n, chr) {
            return this.substr(0, n) + chr + this.substr(n + chr.length);
        };
        Object.defineProperty(Array.prototype, 'first', {
            enumerable: false,
            configurable: true,
            get: function /** @no-inline */() {
                return this[0];
            }
        });
        Object.defineProperty(Array.prototype, 'last', {
            enumerable: false,
            configurable: true,
            get: function /** @no-inline */() {
                return this[this.length - 1];
            }
        });
        Object.defineProperty(Array.prototype, 'el', {
            enumerable: false,
            configurable: true,
            value: function /** @no-inline */(i) {
                i = i || 0;
                return this[i < 0 ? this.length + i : i];
            }
        });
        Object.defineProperty(Array.prototype, 'clear', {
            enumerable: false,
            configurable: true,
            value: function /** @no-inline */() {
                this.length = 0;
            }
        });
        Object.defineProperty(Array.prototype, 'swap', {
            enumerable: false,
            configurable: true,
            value: function /** @no-inline */(i, j) {
                if(i < this.length && j < this.length) {
                    var t = this[i];
                    this[i] = this[j];
                    this[j] = t;
                }
            }
        });
        Object.defineProperty(Array.prototype, 'insert', {
            enumerable: false,
            configurable: true,
            value: function /** @no-inline */(pElement) {
                if(typeof pElement.length === 'number') {
                    for(var i = 0, n = pElement.length; i < n; ++i) {
                        this.push(pElement[i]);
                    }
                    ;
                } else {
                    this.push(pElement);
                }
                return this;
            }
        });
        Number.prototype.toHex = function /** @no-inline */(iLength) {
            var sValue = this.toString(16);
            for(var i = 0; i < iLength - sValue.length; ++i) {
                sValue = '0' + sValue;
            }
            return sValue;
        };
        Number.prototype.printBinary = function /** @no-inline */(isPretty) {
            if (typeof isPretty === "undefined") { isPretty = true; }
            var res = "";
            for(var i = 0; i < 32; ++i) {
                if(i && (i % 4) == 0 && isPretty) {
                    res = ' ' + res;
                }
                (this >> i & 0x1 ? res = '1' + res : res = '0' + res);
            }
            return res;
        };
    })(akra.libs || (akra.libs = {}));
    var libs = akra.libs;
})(akra || (akra = {}));
var akra;
(function (akra) {
    /**
    * FLAG(x)
    * Сдвиг единицы на @a x позиций влево.
    */
    /**
    * TEST_BIT(value, bit)
    * Проверка того что у @a value бит под номером @a bit равен единице.
    */
    /**
    * TEST_ALL(value, set)
    * Проверка того что у @a value равны единице все биты,
    * которые равны единице у @a set.
    */
    /**
    * TEST_ANY(value, set)
    * Проверка того что у @a value равны единице хотя бы какие то из битов,
    * которые равны единице у @a set.
    */
    /**
    * SET_BIT(value, bit)
    * Выставляет бит под номером @a bit у числа @a value равным единице
    */
    /**
    * CLEAR_BIT(value, bit)
    * Выставляет бит под номером @a bit у числа @a value равным нулю
    */
    /**
    * SET_ALL(value, set)
    * Выставляет все биты у числа @a value равными единице,
    * которые равны единице у числа @a set
    */
    /**
    * CLEAR_ALL(value, set)
    * Выставляет все биты у числа @a value равными нулю,
    * которые равны единице у числа @a set
    */
    //#define SET_ALL(value, set, setting) (setting ? SET_ALL(value, set) : CLEAR_ALL(value, set))
    (function (bf) {
        /**
        * Сдвиг единицы на @a x позиций влево.
        * @inline
        */
        bf.flag = function /** @inline */(x) {
            return (1 << (x));
        };
        /**
        * Проверка того что у @a value бит под номером @a bit равен единице.
        * @inline
        */
        bf.testBit = function /** @inline */(value, bit) {
            return ((value & bf.flag(bit)) != 0);
        };
        /**
        * Проверка того что у @a value равны единице все биты,
        * которые равны единице у @a set.
        * @inline
        */
        bf.testAll = function /** @inline */(value, set) {
            return (((value) & (set)) == (set));
        };
        /**
        * Проверка того что у @a value равны единице хотя бы какие то из битов,
        * которые равны единице у @a set.
        * @inline
        */
        bf.testAny = function /** @inline */(value, set) {
            return (((value) & (set)) != 0);
        };
        /**
        * Выставляет бит под номером @a bit у числа @a value равным единице
        * @inline
        */
        bf.setBit = function /** @inline */(value, bit, setting) {
            if (typeof setting === "undefined") { setting = true; }
            return (setting ? ((value) |= bf.flag((bit))) : bf.clearBit(value, bit));
        };
        /**
        *
        * @inline
        */
        bf.clearBit = function /** @inline */(value, bit) {
            return ((value) &= ~bf.flag((bit)));
        };
        /**
        * Выставляет бит под номером @a bit у числа @a value равным нулю
        * @inline
        */
        bf.setAll = function /** @inline */(value, set, setting) {
            if (typeof setting === "undefined") { setting = true; }
            return (setting ? bf.setAll(value, set) : bf.clearAll(value, set));
        };
        /**
        * Выставляет все биты у числа @a value равными единице,
        * которые равны единице у числа @a set
        * @inline
        */
        bf.clearAll = function /** @inline */(value, set) {
            return ((value) &= ~(set));
        };
        /**
        * Выставляет все биты у числа @a value равными нулю,
        * которые равны единице у числа @a set
        * @inline
        */
        bf.equal = function /** @no-inline */(value, src) {
            value = src;
        };
        /**
        * Прирасваивает числу @a value число @a src
        * @inline
        */
        bf.isEqual = function /** @inline */(value, src) {
            return value == src;
        };
        /**
        * Если число @a value равно числу @a src возвращается true
        * @inline
        */
        bf.isNotEqaul = function /** @inline */(value, src) {
            return value != src;
        };
        /**
        * Прирасваивает числу @a value число @a src
        * @inline
        */
        bf.set = function /** @no-inline */(value, src) {
            value = src;
        };
        /**
        * Обнуляет число @a value
        * @inline
        */
        bf.clear = function /** @no-inline */(value) {
            value = 0;
        };
        /**
        * Выставляет все биты у числа @a value равными единице,
        * которые равны единице у числа @a src
        * @inline
        */
        bf.setFlags = function /** @inline */(value, src) {
            return (value |= src);
        };
        /**
        * Выставляет все биты у числа @a value равными нулю,
        * которые равны единице у числа @a src
        * @inline
        */
        bf.clearFlags = function /** @inline */(value, src) {
            return value &= ~src;
        };
        /**
        * Проверяет равно ли число @a value нулю. Если равно возвращает true.
        * Если не равно возвращает false.
        * @inline
        */
        bf.isEmpty = function /** @inline */(value) {
            return (value == 0);
        };
        /**
        * Возвращает общее количество бит числа @a value.
        * На самом деле возвращает всегда 32.
        * @inline
        */
        bf.totalBits = function /** @inline */(value) {
            return 32;
        };
        /**
        * Возвращает общее количество ненулевых бит числа @a value.
        * @inline
        */
        bf.totalSet = function /** @no-inline */(value) {
            var count = 0;
            var total = bf.totalBits(value);
            for(var i = total; i; --i) {
                count += (value & 1);
                value >>= 1;
            }
            return (count);
        };
        /**
        * Convert N bit colour channel value to P bits. It fills P bits with the
        * bit pattern repeated. (this is /((1<<n)-1) in fixed point)
        */
        function /** @inline */fixedToFixed(value, n, p) {
            if(n > p) {
                // Less bits required than available; this is easy
                value >>= n - p;
            } else if(n < p) {
                // More bits required than are there, do the fill
                // Use old fashioned division, probably better than a loop
                if(value == 0) {
                    value = 0;
                } else if(value == ((1) << n) - 1) {
                    value = (1 << p) - 1;
                } else {
                    value = value * (1 << p) / ((1 << n) - 1);
                }
            }
            return value;
        }
        bf.fixedToFixed = fixedToFixed;
        /**
        * Convert floating point colour channel value between 0.0 and 1.0 (otherwise clamped)
        * to integer of a certain number of bits. Works for any value of bits between 0 and 31.
        */
        function /** @inline */floatToFixed(value, bits) {
            if(value <= 0.0) {
                return 0;
            } else if(value >= 1.0) {
                return (1 << bits) - 1;
            } else {
                return (value * (1 << bits));
            }
        }
        bf.floatToFixed = floatToFixed;
        /**
        * Fixed point to float
        */
        function /** @inline */fixedToFloat(value, bits) {
            return value / ((1 << bits) - 1);
        }
        bf.fixedToFloat = fixedToFloat;
        /**
        * Write a n*8 bits integer value to memory in native endian.
        */
        function /** @inline */intWrite(pDest, n, value) {
            switch(n) {
                case 1:
                    pDest[0] = value;
                    break;
                case 2:
                    pDest[1] = ((value >> 8) & 0xFF);
                    pDest[0] = (value & 0xFF);
                    break;
                case 3:
                    pDest[2] = ((value >> 16) & 0xFF);
                    pDest[1] = ((value >> 8) & 0xFF);
                    pDest[0] = (value & 0xFF);
                    break;
                case 4:
                    pDest[3] = ((value >> 24) & 0xFF);
                    pDest[2] = ((value >> 16) & 0xFF);
                    pDest[1] = ((value >> 8) & 0xFF);
                    pDest[0] = (value & 0xFF);
                    break;
            }
        }
        bf.intWrite = intWrite;
        /**
        * Read a n*8 bits integer value to memory in native endian.
        */
        function /** @inline */intRead(pSrc, n) {
            switch(n) {
                case 1:
                    return pSrc[0];
                case 2:
                    return pSrc[0] | pSrc[1] << 8;
                case 3:
                    return pSrc[0] | pSrc[1] << 8 | pSrc[2] << 16;
                case 4:
                    return pSrc[0] | pSrc[1] << 8 | pSrc[2] << 16 | pSrc[3] << 32;
            }
            return 0;
        }
        bf.intRead = intRead;
                //float32/uint32 union
        var _u32 = new Uint32Array(1);
        var _f32 = new Float32Array(_u32.buffer);
        function /** @inline */floatToHalf(f) {
            _f32[0] = f;
            return floatToHalfI(_u32[0]);
        }
        bf.floatToHalf = floatToHalf;
        function /** @inline */floatToHalfI(i) {
            var s = (i >> 16) & 0x00008000;
            var e = ((i >> 23) & 0x000000ff) - (127 - 15);
            var m = i & 0x007fffff;
            if(e <= 0) {
                if(e < -10) {
                    return 0;
                }
                m = (m | 0x00800000) >> (1 - e);
                return (s | (m >> 13));
            } else if(e == 0xff - (127 - 15)) {
                // Inf
                if(m == 0) {
                    return (s | 0x7c00);
                } else// NAN
                 {
                    m >>= 13;
                    return (s | 0x7c00 | m | (m == 0));
                }
            } else {
                // Overflow
                if(e > 30) {
                    return (s | 0x7c00);
                }
                return (s | (e << 10) | (m >> 13));
            }
        }
        bf.floatToHalfI = floatToHalfI;
        /**
        * Convert a float16 (NV_half_float) to a float32
        * Courtesy of OpenEXR
        */
        function /** @inline */halfToFloat(y) {
            _u32[0] = halfToFloatI(y);
            return _f32[0];
        }
        bf.halfToFloat = halfToFloat;
        /** Converts a half in uint16 format to a float
        in uint32 format
        */
        function /** @inline */halfToFloatI(y) {
            var s = (y >> 15) & 0x00000001;
            var e = (y >> 10) & 0x0000001f;
            var m = y & 0x000003ff;
            if(e == 0) {
                // Plus or minus zero
                if(m == 0) {
                    return s << 31;
                } else// Denormalized number -- renormalize it
                 {
                    while(!(m & 0x00000400)) {
                        m <<= 1;
                        e -= 1;
                    }
                    e += 1;
                    m &= ~0x00000400;
                }
            } else if(e == 31) {
                //Inf
                if(m == 0) {
                    return (s << 31) | 0x7f800000;
                } else//NaN
                 {
                    return (s << 31) | 0x7f800000 | (m << 13);
                }
            }
            e = e + (127 - 15);
            m = m << 13;
            return (s << 31) | (e << 23) | m;
        }
        bf.halfToFloatI = halfToFloatI;
    })(akra.bf || (akra.bf = {}));
    var bf = akra.bf;
})(akra || (akra = {}));
var akra;
(function (akra) {
    // #include "Singleton.ts"
    (function (util) {
        /* extends Singleton*/
        var Logger = (function () {
            function /** @no-inline */Logger() {
                //super();
                this._eUnknownCode = 0;
                this._sUnknownMessage = "Unknown code";
                this._eLogLevel = 31 /* ALL */ ;
                this._pGeneralRoutineMap = {
                };
                this._pCurrentSourceLocation = {
                    file: "",
                    line: 0
                };
                this._pLastLogEntity = {
                    code: this._eUnknownCode,
                    location: this._pCurrentSourceLocation,
                    message: this._sUnknownMessage,
                    info: null
                };
                this._pCodeFamilyMap = {
                };
                this._pCodeFamilyList = [];
                this._pCodeInfoMap = {
                };
                this._pCodeFamilyRoutineDMap = {
                };
                this._nFamilyGenerator = 0;
            }
            Logger._sDefaultFamilyName = "CodeFamily";
            Logger.prototype.init = function /** @no-inline */() {
                //TODO: Load file
                return true;
            };
            Logger.prototype.setLogLevel = function /** @no-inline */(eLevel) {
                this._eLogLevel = eLevel;
            };
            Logger.prototype.getLogLevel = function /** @no-inline */() {
                return this._eLogLevel;
            };
            Logger.prototype.registerCode = function /** @no-inline */(eCode, sMessage) {
                if (typeof sMessage === "undefined") { sMessage = this._sUnknownMessage; }
                if(this.isUsedCode(eCode)) {
                    return false;
                }
                var sFamilyName = this.getFamilyName(eCode);
                if(akra.isNull(sFamilyName)) {
                    return false;
                }
                var pCodeInfo = {
                    code: eCode,
                    message: sMessage,
                    familyName: sFamilyName
                };
                this._pCodeInfoMap[eCode] = pCodeInfo;
                return true;
            };
            Logger.prototype.setUnknownCode = function /** @no-inline */(eCode, sMessage) {
                this._eUnknownCode = eCode;
                this._sUnknownMessage = sMessage;
            };
            Logger.prototype.registerCodeFamily = function /** @no-inline */(eCodeMin, eCodeMax, sFamilyName) {
                if(!akra.isDef(sFamilyName)) {
                    sFamilyName = this.generateFamilyName();
                }
                if(this.isUsedFamilyName(sFamilyName)) {
                    return false;
                }
                if(!this.isValidCodeInterval(eCodeMin, eCodeMax)) {
                    return false;
                }
                var pCodeFamily = {
                    familyName: sFamilyName,
                    codeMin: eCodeMin,
                    codeMax: eCodeMax
                };
                this._pCodeFamilyMap[sFamilyName] = pCodeFamily;
                this._pCodeFamilyList.push(pCodeFamily);
                return true;
            };
            Logger.prototype.getFamilyName = function /** @no-inline */(eCode) {
                var i = 0;
                var pCodeFamilyList = this._pCodeFamilyList;
                var pCodeFamily;
                for(i = 0; i < pCodeFamilyList.length; i++) {
                    pCodeFamily = pCodeFamilyList[i];
                    if(pCodeFamily.codeMin <= eCode && pCodeFamily.codeMax >= eCode) {
                        return pCodeFamily.familyName;
                    }
                }
                return null;
            };
            Logger.prototype.setCodeFamilyRoutine = function /** @no-inline */() {
                var sFamilyName = null;
                var fnLogRoutine = null;
                var eLevel = 1 /* LOG */ ;
                if(akra.isInt(arguments[0])) {
                    sFamilyName = this.getFamilyName(arguments[0]);
                    fnLogRoutine = arguments[1];
                    eLevel = arguments[2];
                    if(akra.isNull(sFamilyName)) {
                        return false;
                    }
                } else if(akra.isString(arguments[0])) {
                    sFamilyName = arguments[0];
                    fnLogRoutine = arguments[1];
                    eLevel = arguments[2];
                }
                if(!this.isUsedFamilyName(sFamilyName)) {
                    return false;
                }
                var pCodeFamilyRoutineMap = this._pCodeFamilyRoutineDMap[sFamilyName];
                if(!akra.isDef(pCodeFamilyRoutineMap)) {
                    pCodeFamilyRoutineMap = this._pCodeFamilyRoutineDMap[sFamilyName] = {
                    };
                }
                if(akra.bf.testAll(eLevel, 1 /* LOG */ )) {
                    pCodeFamilyRoutineMap[1 /* LOG */ ] = fnLogRoutine;
                }
                if(akra.bf.testAll(eLevel, 2 /* INFORMATION */ )) {
                    pCodeFamilyRoutineMap[2 /* INFORMATION */ ] = fnLogRoutine;
                }
                if(akra.bf.testAll(eLevel, 4 /* WARNING */ )) {
                    pCodeFamilyRoutineMap[4 /* WARNING */ ] = fnLogRoutine;
                }
                if(akra.bf.testAll(eLevel, 8 /* ERROR */ )) {
                    pCodeFamilyRoutineMap[8 /* ERROR */ ] = fnLogRoutine;
                }
                if(akra.bf.testAll(eLevel, 16 /* CRITICAL */ )) {
                    pCodeFamilyRoutineMap[16 /* CRITICAL */ ] = fnLogRoutine;
                }
                return true;
            };
            Logger.prototype.setLogRoutine = function /** @no-inline */(fnLogRoutine, eLevel) {
                if(akra.bf.testAll(eLevel, 1 /* LOG */ )) {
                    this._pGeneralRoutineMap[1 /* LOG */ ] = fnLogRoutine;
                }
                if(akra.bf.testAll(eLevel, 2 /* INFORMATION */ )) {
                    this._pGeneralRoutineMap[2 /* INFORMATION */ ] = fnLogRoutine;
                }
                if(akra.bf.testAll(eLevel, 4 /* WARNING */ )) {
                    this._pGeneralRoutineMap[4 /* WARNING */ ] = fnLogRoutine;
                }
                if(akra.bf.testAll(eLevel, 8 /* ERROR */ )) {
                    this._pGeneralRoutineMap[8 /* ERROR */ ] = fnLogRoutine;
                }
                if(akra.bf.testAll(eLevel, 16 /* CRITICAL */ )) {
                    this._pGeneralRoutineMap[16 /* CRITICAL */ ] = fnLogRoutine;
                }
            };
            Logger.prototype.setSourceLocation = function /** @no-inline */() {
                var sFile;
                var iLine;
                if(arguments.length === 2) {
                    sFile = arguments[0];
                    iLine = arguments[1];
                } else {
                    if(akra.isDef(arguments[0]) && !(akra.isNull(arguments[0]))) {
                        sFile = arguments[0].file;
                        iLine = arguments[0].line;
                    } else {
                        sFile = "";
                        iLine = 0;
                    }
                }
                this._pCurrentSourceLocation.file = sFile;
                this._pCurrentSourceLocation.line = iLine;
            };
            Logger.prototype.log = function /** @no-inline */() {
                var pArgs = [];
                for (var _i = 0; _i < (arguments.length - 0); _i++) {
                    pArgs[_i] = arguments[_i + 0];
                }
                if(!akra.bf.testAll(this._eLogLevel, 1 /* LOG */ )) {
                    return;
                }
                var fnLogRoutine = this._pGeneralRoutineMap[1 /* LOG */ ];
                if(!akra.isDef(fnLogRoutine)) {
                    return;
                }
                var pLogEntity = this._pLastLogEntity;
                pLogEntity.code = this._eUnknownCode;
                pLogEntity.location = this._pCurrentSourceLocation;
                pLogEntity.info = pArgs;
                pLogEntity.message = this._sUnknownMessage;
                fnLogRoutine.call(null, pLogEntity);
            };
            Logger.prototype.info = function /** @no-inline */() {
                if(!akra.bf.testAll(this._eLogLevel, 2 /* INFORMATION */ )) {
                    return;
                }
                var pLogEntity;
                var fnLogRoutine;
                pLogEntity = this.prepareLogEntity.apply(this, arguments);
                fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, 2 /* INFORMATION */ );
                if(akra.isNull(fnLogRoutine)) {
                    return;
                }
                fnLogRoutine.call(null, pLogEntity);
            };
            Logger.prototype.warning = function /** @no-inline */() {
                if(!akra.bf.testAll(this._eLogLevel, 4 /* WARNING */ )) {
                    return;
                }
                var pLogEntity;
                var fnLogRoutine;
                pLogEntity = this.prepareLogEntity.apply(this, arguments);
                fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, 4 /* WARNING */ );
                if(akra.isNull(fnLogRoutine)) {
                    return;
                }
                fnLogRoutine.call(null, pLogEntity);
            };
            Logger.prototype.error = function /** @no-inline */() {
                if(!akra.bf.testAll(this._eLogLevel, 8 /* ERROR */ )) {
                    return;
                }
                var pLogEntity;
                var fnLogRoutine;
                pLogEntity = this.prepareLogEntity.apply(this, arguments);
                fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, 8 /* ERROR */ );
                if(akra.isNull(fnLogRoutine)) {
                    return;
                }
                fnLogRoutine.call(null, pLogEntity);
            };
            Logger.prototype.criticalError = function /** @no-inline */() {
                var pLogEntity;
                var fnLogRoutine;
                pLogEntity = this.prepareLogEntity.apply(this, arguments);
                fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, 16 /* CRITICAL */ );
                var sSystemMessage = "A Critical error has occured! Code: " + pLogEntity.code.toString();
                if(akra.bf.testAll(this._eLogLevel, 16 /* CRITICAL */ ) && !akra.isNull(fnLogRoutine)) {
                    fnLogRoutine.call(null, pLogEntity);
                }
                alert(sSystemMessage);
                throw new Error(sSystemMessage);
            };
            Logger.prototype.assert = function /** @no-inline */() {
                var bCondition = arguments[0];
                if(!bCondition) {
                    var pLogEntity;
                    var fnLogRoutine;
                    var pArgs = [];
                    for(var i = 1; i < arguments.length; i++) {
                        pArgs[i - 1] = arguments[i];
                    }
                    pLogEntity = this.prepareLogEntity.apply(this, pArgs);
                    fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, 16 /* CRITICAL */ );
                    var sSystemMessage = "A error has occured! Code: " + pLogEntity.code.toString() + "\n Accept to exit, refuse to continue.";
                    if(akra.bf.testAll(this._eLogLevel, 16 /* CRITICAL */ ) && !akra.isNull(fnLogRoutine)) {
                        fnLogRoutine.call(null, pLogEntity);
                    }
                    if(confirm(sSystemMessage)) {
                        throw new Error(sSystemMessage);
                    }
                }
            };
            Logger.prototype.generateFamilyName = function /** @no-inline */() {
                var sSuffix = (this._nFamilyGenerator++);
                var sName = Logger._sDefaultFamilyName + sSuffix;
                if(this.isUsedFamilyName(sName)) {
                    return this.generateFamilyName();
                } else {
                    return sName;
                }
            };
            Logger.prototype.isValidCodeInterval = function /** @no-inline */(eCodeMin, eCodeMax) {
                if(eCodeMin > eCodeMax) {
                    return false;
                }
                var i = 0;
                var pCodeFamilyList = this._pCodeFamilyList;
                var pCodeFamily;
                for(i = 0; i < pCodeFamilyList.length; i++) {
                    pCodeFamily = pCodeFamilyList[i];
                    if((pCodeFamily.codeMin <= eCodeMin && pCodeFamily.codeMax >= eCodeMin) || (pCodeFamily.codeMin <= eCodeMax && pCodeFamily.codeMax >= eCodeMax)) {
                        return false;
                    }
                }
                return true;
            };
            Logger.prototype.isUsedFamilyName = function /** @inline */(sFamilyName) {
                return akra.isDef(this._pCodeFamilyMap[sFamilyName]);
            };
            Logger.prototype.isUsedCode = function /** @inline */(eCode) {
                return akra.isDef(this._pCodeInfoMap[eCode]);
            };
            Logger.prototype.isLogEntity = function /** @no-inline */(pObj) {
                if(akra.isObject(pObj) && akra.isDef(pObj.code) && akra.isDef(pObj.location)) {
                    return true;
                }
                return false;
            };
            Logger.prototype.isLogCode = function /** @inline */(eCode) {
                return akra.isInt(eCode);
            };
            Logger.prototype.prepareLogEntity = function /** @no-inline */() {
                var eCode = this._eUnknownCode;
                var sMessage = this._sUnknownMessage;
                var pInfo = null;
                if(arguments.length === 1 && this.isLogEntity(arguments[0])) {
                    var pEntity = arguments[0];
                    eCode = pEntity.code;
                    pInfo = pEntity.info;
                    this.setSourceLocation(pEntity.location);
                    if(!akra.isDef(pEntity.message)) {
                        var pCodeInfo = this._pCodeInfoMap[eCode];
                        if(akra.isDef(pCodeInfo)) {
                            sMessage = pCodeInfo.message;
                        }
                    }
                } else {
                    if(this.isLogCode(arguments[0])) {
                        eCode = arguments[0];
                        if(arguments.length > 1) {
                            pInfo = new Array(arguments.length - 1);
                            var i = 0;
                            for(i = 0; i < pInfo.length; i++) {
                                pInfo[i] = arguments[i + 1];
                            }
                        }
                    } else {
                        eCode = this._eUnknownCode;
                        if(arguments.length > 0) {
                            pInfo = new Array(arguments.length);
                            var i = 0;
                            for(i = 0; i < pInfo.length; i++) {
                                pInfo[i] = arguments[i];
                            }
                        } else {
                            pInfo = null;
                        }
                    }
                    var pCodeInfo = this._pCodeInfoMap[eCode];
                    if(akra.isDef(pCodeInfo)) {
                        sMessage = pCodeInfo.message;
                    }
                }
                var pLogEntity = this._pLastLogEntity;
                pLogEntity.code = eCode;
                pLogEntity.location = this._pCurrentSourceLocation;
                pLogEntity.message = sMessage;
                pLogEntity.info = pInfo;
                return pLogEntity;
            };
            Logger.prototype.getCodeRoutineFunc = function /** @no-inline */(eCode, eLevel) {
                var pCodeInfo = this._pCodeInfoMap[eCode];
                var fnLogRoutine;
                if(!akra.isDef(pCodeInfo)) {
                    fnLogRoutine = this._pGeneralRoutineMap[eLevel];
                    return akra.isDef(fnLogRoutine) ? fnLogRoutine : null;
                }
                var pCodeFamilyRoutineMap = this._pCodeFamilyRoutineDMap[pCodeInfo.familyName];
                if(!akra.isDef(pCodeFamilyRoutineMap) || !akra.isDef(pCodeFamilyRoutineMap[eLevel])) {
                    fnLogRoutine = this._pGeneralRoutineMap[eLevel];
                    return akra.isDef(fnLogRoutine) ? fnLogRoutine : null;
                }
                fnLogRoutine = pCodeFamilyRoutineMap[eLevel];
                return fnLogRoutine;
            };
            return Logger;
        })();
        util.Logger = Logger;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        util.logger = new util.Logger();
        util.logger.init();
        util.logger.setUnknownCode(0, "Unknown code.");
        util.logger.setLogLevel(31 /* ALL */ );
        //Default code families
        util.logger.registerCodeFamily(0, 100, "SystemCodes");
        util.logger.registerCodeFamily(2000, 2199, "ParserSyntaxErrors");
        util.logger.registerCodeFamily(2200, 2500, "EffectSyntaxErrors");
        //Default log routines
        function /** @no-inline */sourceLocationToString(pLocation) {
            var sLocation = "[" + pLocation.file + ":" + pLocation.line.toString() + "]: ";
            return sLocation;
        }
        function /** @no-inline */logRoutine(pLogEntity) {
            var pArgs = pLogEntity.info;
            pArgs.unshift(sourceLocationToString(pLogEntity.location));
            console["log"].apply(console, pArgs);
        }
        function /** @no-inline */warningRoutine(pLogEntity) {
            var pArgs = pLogEntity.info;
            pArgs.unshift("Code: " + pLogEntity.code.toString());
            pArgs.unshift(sourceLocationToString(pLogEntity.location));
            console["warn"].apply(console, pArgs);
        }
        function /** @no-inline */errorRoutine(pLogEntity) {
            var pArgs = pLogEntity.info;
            pArgs.unshift(pLogEntity.message);
            pArgs.unshift("Error code: " + pLogEntity.code.toString() + ".");
            pArgs.unshift(sourceLocationToString(pLogEntity.location));
            console["error"].apply(console, pArgs);
        }
        util.logger.setLogRoutine(logRoutine, 1 /* LOG */  | 2 /* INFORMATION */ );
        util.logger.setLogRoutine(warningRoutine, 4 /* WARNING */ );
        util.logger.setLogRoutine(errorRoutine, 8 /* ERROR */  | 16 /* CRITICAL */ );
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.logger = akra.util.logger;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    akra.createEngine;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    (function (EEventTypes) {
        EEventTypes._map = [];
        EEventTypes._map[0] = "BROADCAST";
        EEventTypes.BROADCAST = 0;
        EEventTypes._map[1] = "UNICAST";
        EEventTypes.UNICAST = 1;
    })(akra.EEventTypes || (akra.EEventTypes = {}));
    var EEventTypes = akra.EEventTypes;
    ;
    // callOnce(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool;
    })(akra || (akra = {}));
var akra;
(function (akra) {
    (function (ESceneTypes) {
        ESceneTypes._map = [];
        ESceneTypes._map[0] = "TYPE_3D";
        ESceneTypes.TYPE_3D = 0;
        ESceneTypes._map[1] = "TYPE_2D";
        ESceneTypes.TYPE_2D = 1;
    })(akra.ESceneTypes || (akra.ESceneTypes = {}));
    var ESceneTypes = akra.ESceneTypes;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    ;
    /** Семейства ресурсов */
    (function (EResourceFamilies) {
        EResourceFamilies._map = [];
        EResourceFamilies.VIDEO_RESOURCE = 0;
        EResourceFamilies._map[1] = "AUDIO_RESOURCE";
        EResourceFamilies.AUDIO_RESOURCE = 1;
        EResourceFamilies._map[2] = "GAME_RESOURCE";
        EResourceFamilies.GAME_RESOURCE = 2;
        EResourceFamilies._map[3] = "TOTAL_RESOURCE_FAMILIES";
        EResourceFamilies.TOTAL_RESOURCE_FAMILIES = 3;
    })(akra.EResourceFamilies || (akra.EResourceFamilies = {}));
    var EResourceFamilies = akra.EResourceFamilies;
    ;
    /** Члены семейства видео ресурсов */
    (function (EVideoResources) {
        EVideoResources._map = [];
        EVideoResources._map[0] = "TEXTURE_RESOURCE";
        EVideoResources.TEXTURE_RESOURCE = 0;
        EVideoResources._map[1] = "VIDEOBUFFER_RESOURCE";
        EVideoResources.VIDEOBUFFER_RESOURCE = 1;
        EVideoResources._map[2] = "VERTEXBUFFER_RESOURCE";
        EVideoResources.VERTEXBUFFER_RESOURCE = 2;
        EVideoResources._map[3] = "INDEXBUFFER_RESOURCE";
        EVideoResources.INDEXBUFFER_RESOURCE = 3;
        EVideoResources._map[4] = "EFFECT_RESOURCE";
        EVideoResources.EFFECT_RESOURCE = 4;
        EVideoResources._map[5] = "RENDERMETHOD_RESOURCE";
        EVideoResources.RENDERMETHOD_RESOURCE = 5;
        EVideoResources._map[6] = "MODEL_RESOURCE";
        EVideoResources.MODEL_RESOURCE = 6;
        EVideoResources._map[7] = "EFFECTFILEDATA_RESOURCE";
        EVideoResources.EFFECTFILEDATA_RESOURCE = 7;
        EVideoResources._map[8] = "IMAGE_RESOURCE";
        EVideoResources.IMAGE_RESOURCE = 8;
        EVideoResources._map[9] = "SURFACEMATERIAL_RESOURCE";
        EVideoResources.SURFACEMATERIAL_RESOURCE = 9;
        EVideoResources._map[10] = "SHADERPROGRAM_RESOURCE";
        EVideoResources.SHADERPROGRAM_RESOURCE = 10;
        EVideoResources._map[11] = "COMPONENT_RESOURCE";
        EVideoResources.COMPONENT_RESOURCE = 11;
        EVideoResources._map[12] = "EFFECTDATA_RESOURCE";
        EVideoResources.EFFECTDATA_RESOURCE = 12;
        EVideoResources._map[13] = "TOTAL_VIDEO_RESOURCES";
        EVideoResources.TOTAL_VIDEO_RESOURCES = 13;
    })(akra.EVideoResources || (akra.EVideoResources = {}));
    var EVideoResources = akra.EVideoResources;
    ;
    (function (EAudioResources) {
        EAudioResources._map = [];
        EAudioResources._map[0] = "TOTAL_AUDIO_RESOURCES";
        EAudioResources.TOTAL_AUDIO_RESOURCES = 0;
    })(akra.EAudioResources || (akra.EAudioResources = {}));
    var EAudioResources = akra.EAudioResources;
    ;
    (function (EGameResources) {
        EGameResources._map = [];
        EGameResources._map[0] = "TOTAL_GAME_RESOURCES";
        EGameResources.TOTAL_GAME_RESOURCES = 0;
    })(akra.EGameResources || (akra.EGameResources = {}));
    var EGameResources = akra.EGameResources;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    //API SPECIFIFC CONSTANTS
    (function (EPrimitiveTypes) {
        EPrimitiveTypes._map = [];
        EPrimitiveTypes.POINTLIST = 0;
        EPrimitiveTypes._map[1] = "LINELIST";
        EPrimitiveTypes.LINELIST = 1;
        EPrimitiveTypes._map[2] = "LINELOOP";
        EPrimitiveTypes.LINELOOP = 2;
        EPrimitiveTypes._map[3] = "LINESTRIP";
        EPrimitiveTypes.LINESTRIP = 3;
        EPrimitiveTypes._map[4] = "TRIANGLELIST";
        EPrimitiveTypes.TRIANGLELIST = 4;
        EPrimitiveTypes._map[5] = "TRIANGLESTRIP";
        EPrimitiveTypes.TRIANGLESTRIP = 5;
        EPrimitiveTypes._map[6] = "TRIANGLEFAN";
        EPrimitiveTypes.TRIANGLEFAN = 6;
    })(akra.EPrimitiveTypes || (akra.EPrimitiveTypes = {}));
    var EPrimitiveTypes = akra.EPrimitiveTypes;
    ;
    (function (ERenderCapabilitiesCategory) {
        ERenderCapabilitiesCategory._map = [];
        ERenderCapabilitiesCategory.C_COMMON = 0;
        ERenderCapabilitiesCategory.C_COMMON_2 = 1;
        ERenderCapabilitiesCategory.C_WEBGL = 2;
        ERenderCapabilitiesCategory.COUNT = 3;
    })(akra.ERenderCapabilitiesCategory || (akra.ERenderCapabilitiesCategory = {}));
    var ERenderCapabilitiesCategory = akra.ERenderCapabilitiesCategory;
    (function (ERenderCapabilities) {
        ERenderCapabilities._map = [];
        ERenderCapabilities.AUTOMIPMAP = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 0));
        ERenderCapabilities.BLENDING = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 1));
        /// Supports anisotropic texture filtering
        ERenderCapabilities.ANISOTROPY = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 2));
        /// Supports fixed-function DOT3 texture blend
        ERenderCapabilities.DOT3 = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 3));
        /// Supports cube mapping
        ERenderCapabilities.CUBEMAPPING = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 4));
        /// Supports hardware stencil buffer
        ERenderCapabilities.HWSTENCIL = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 5));
        /// Supports hardware vertex and index buffers
        ERenderCapabilities.VBO = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 7));
        /// Supports vertex programs (vertex shaders)
        ERenderCapabilities.VERTEX_PROGRAM = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 9));
        /// Supports fragment programs (pixel shaders)
        ERenderCapabilities.FRAGMENT_PROGRAM = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 10));
        /// Supports performing a scissor test to exclude areas of the screen
        ERenderCapabilities.SCISSOR_TEST = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 11));
        /// Supports separate stencil updates for both front and back faces
        ERenderCapabilities.TWO_SIDED_STENCIL = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 12));
        /// Supports wrapping the stencil value at the range extremeties
        ERenderCapabilities.STENCIL_WRAP = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 13));
        /// Supports hardware occlusion queries
        ERenderCapabilities.HWOCCLUSION = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 14));
        /// Supports user clipping planes
        ERenderCapabilities.USER_CLIP_PLANES = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 15));
        /// Supports the VET_UBYTE4 vertex element type
        ERenderCapabilities.VERTEX_FORMAT_UBYTE4 = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 16));
        /// Supports infinite far plane projection
        ERenderCapabilities.INFINITE_FAR_PLANE = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 17));
        /// Supports hardware render-to-texture (bigger than framebuffer)
        ERenderCapabilities.HWRENDER_TO_TEXTURE = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 18));
        /// Supports float textures and render targets
        ERenderCapabilities.TEXTURE_FLOAT = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 19));
        /// Supports non-power of two textures
        ERenderCapabilities.NON_POWER_OF_2_TEXTURES = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 20));
        /// Supports 3d (volume) textures
        ERenderCapabilities.TEXTURE_3D = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 21));
        /// Supports basic point sprite rendering
        ERenderCapabilities.POINT_SPRITES = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 22));
        /// Supports extra point parameters (minsize, maxsize, attenuation)
        ERenderCapabilities.POINT_EXTENDED_PARAMETERS = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 23));
        /// Supports vertex texture fetch
        ERenderCapabilities.VERTEX_TEXTURE_FETCH = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 24));
        /// Supports mipmap LOD biasing
        ERenderCapabilities.MIPMAP_LOD_BIAS = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 25));
        /// Supports hardware geometry programs
        ERenderCapabilities.GEOMETRY_PROGRAM = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 26));
        /// Supports rendering to vertex buffers
        ERenderCapabilities.HWRENDER_TO_VERTEX_BUFFER = ((0 /* C_COMMON */  << (32 - 4)) | (1 << 27));
        /// Supports compressed textures
        ERenderCapabilities.TEXTURE_COMPRESSION = ((1 /* C_COMMON_2 */  << (32 - 4)) | (1 << 0));
        /// Supports compressed textures in the DXT/ST3C formats
        ERenderCapabilities.TEXTURE_COMPRESSION_DXT = ((1 /* C_COMMON_2 */  << (32 - 4)) | (1 << 1));
        /// Supports compressed textures in the VTC format
        ERenderCapabilities.TEXTURE_COMPRESSION_VTC = ((1 /* C_COMMON_2 */  << (32 - 4)) | (1 << 2));
        /// Supports compressed textures in the PVRTC format
        ERenderCapabilities.TEXTURE_COMPRESSION_PVRTC = ((1 /* C_COMMON_2 */  << (32 - 4)) | (1 << 3));
        /// Supports fixed-function pipeline
        ERenderCapabilities.FIXED_FUNCTION = ((1 /* C_COMMON_2 */  << (32 - 4)) | (1 << 4));
        /// Supports MRTs with different bit depths
        ERenderCapabilities.MRT_DIFFERENT_BIT_DEPTHS = ((1 /* C_COMMON_2 */  << (32 - 4)) | (1 << 5));
        /// Supports Alpha to Coverage (A2C)
        ERenderCapabilities.ALPHA_TO_COVERAGE = ((1 /* C_COMMON_2 */  << (32 - 4)) | (1 << 6));
        /// Supports Blending operations other than +
        ERenderCapabilities.ADVANCED_BLEND_OPERATIONS = ((1 /* C_COMMON_2 */  << (32 - 4)) | (1 << 7));
        /// Supports a separate depth buffer for RTTs. D3D 9 & 10, OGL w/FBO (FBO implies this flag)
        ERenderCapabilities.RTT_SEPARATE_DEPTHBUFFER = ((1 /* C_COMMON_2 */  << (32 - 4)) | (1 << 8));
        /// Supports using the MAIN depth buffer for RTTs. D3D 9&10, OGL w/FBO support unknown
        /// (undefined behavior?), OGL w/ copy supports it
        ERenderCapabilities.RTT_MAIN_DEPTHBUFFER_ATTACHABLE = ((1 /* C_COMMON_2 */  << (32 - 4)) | (1 << 9));
        /// Supports attaching a depth buffer to an RTT that has width & height less or equal than RTT's.
        /// Otherwise must be of _exact_ same resolution. D3D 9, OGL 3.0 (not 2.0, not D3D10)
        ERenderCapabilities.RTT_DEPTHBUFFER_RESOLUTION_LESSEQUAL = ((1 /* C_COMMON_2 */  << (32 - 4)) | (1 << 10));
        /// Supports using vertex buffers for instance data
        ERenderCapabilities.VERTEX_BUFFER_INSTANCE_DATA = ((1 /* C_COMMON_2 */  << (32 - 4)) | (1 << 11));
        /// Supports using vertex buffers for instance data
        ERenderCapabilities.CAN_GET_COMPILED_SHADER_BUFFER = ((1 /* C_COMMON_2 */  << (32 - 4)) | (1 << 12));
        // ***** GL Specific Caps *****
        /// Supports openGL GLEW version 1.5
        ERenderCapabilities.GL1_5_NOVBO = ((2 /* C_WEBGL */  << (32 - 4)) | (1 << 1));
        /// Support for Frame Buffer Objects (FBOs)
        ERenderCapabilities.FBO = ((2 /* C_WEBGL */  << (32 - 4)) | (1 << 2));
        /// Support for Frame Buffer Objects ARB implementation (regular FBO is higher precedence)
        ERenderCapabilities.FBO_ARB = ((2 /* C_WEBGL */  << (32 - 4)) | (1 << 3));
        /// Support for Frame Buffer Objects ATI implementation (ARB FBO is higher precedence)
        ERenderCapabilities.FBO_ATI = ((2 /* C_WEBGL */  << (32 - 4)) | (1 << 4));
        /// Support for PBuffer
        ERenderCapabilities.PBUFFER = ((2 /* C_WEBGL */  << (32 - 4)) | (1 << 5));
        /// Support for GL 1.5 but without HW occlusion workaround
        ERenderCapabilities.GL1_5_NOHWOCCLUSION = ((2 /* C_WEBGL */  << (32 - 4)) | (1 << 6));
        /// Support for point parameters ARB implementation
        ERenderCapabilities.POINT_EXTENDED_PARAMETERS_ARB = ((2 /* C_WEBGL */  << (32 - 4)) | (1 << 7));
        /// Support for point parameters EXT implementation
        ERenderCapabilities.POINT_EXTENDED_PARAMETERS_EXT = ((2 /* C_WEBGL */  << (32 - 4)) | (1 << 8));
        /// Support for Separate Shader Objects
        ERenderCapabilities.SEPARATE_SHADER_OBJECTS = ((2 /* C_WEBGL */  << (32 - 4)) | (1 << 9));
    })(akra.ERenderCapabilities || (akra.ERenderCapabilities = {}));
    var ERenderCapabilities = akra.ERenderCapabilities;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EUtilTimerCommands) {
        EUtilTimerCommands._map = [];
        EUtilTimerCommands._map[0] = "TIMER_RESET";
        //! <to reset the timer
        EUtilTimerCommands.TIMER_RESET = 0;
        EUtilTimerCommands._map[1] = "TIMER_START";
        //! <to start the timer
        EUtilTimerCommands.TIMER_START = 1;
        EUtilTimerCommands._map[2] = "TIMER_STOP";
        //! <to stop (or pause) the timer
        EUtilTimerCommands.TIMER_STOP = 2;
        EUtilTimerCommands._map[3] = "TIMER_ADVANCE";
        //! <to advance the timer by 0.1 seconds
        EUtilTimerCommands.TIMER_ADVANCE = 3;
        EUtilTimerCommands._map[4] = "TIMER_GET_ABSOLUTE_TIME";
        //! <to get the absolute system time
        EUtilTimerCommands.TIMER_GET_ABSOLUTE_TIME = 4;
        EUtilTimerCommands._map[5] = "TIMER_GET_APP_TIME";
        //! <to get the current time
        EUtilTimerCommands.TIMER_GET_APP_TIME = 5;
        EUtilTimerCommands._map[6] = "TIMER_GET_ELAPSED_TIME";
        EUtilTimerCommands.TIMER_GET_ELAPSED_TIME = 6;//! to get the time that elapsed between TIMER_GETELAPSEDTIME calls
        
    })(akra.EUtilTimerCommands || (akra.EUtilTimerCommands = {}));
    var EUtilTimerCommands = akra.EUtilTimerCommands;
    //static start(): IUtilTimer;
    })(akra || (akra = {}));
var akra;
(function (akra) {
    (function (ENodeCreateMode) {
        ENodeCreateMode._map = [];
        ENodeCreateMode._map[0] = "k_Default";
        ENodeCreateMode.k_Default = 0;
        ENodeCreateMode._map[1] = "k_Necessary";
        ENodeCreateMode.k_Necessary = 1;
        ENodeCreateMode._map[2] = "k_Not";
        ENodeCreateMode.k_Not = 2;
    })(akra.ENodeCreateMode || (akra.ENodeCreateMode = {}));
    var ENodeCreateMode = akra.ENodeCreateMode;
    (function (EParserCode) {
        EParserCode._map = [];
        EParserCode._map[0] = "k_Pause";
        EParserCode.k_Pause = 0;
        EParserCode._map[1] = "k_Ok";
        EParserCode.k_Ok = 1;
        EParserCode._map[2] = "k_Error";
        EParserCode.k_Error = 2;
    })(akra.EParserCode || (akra.EParserCode = {}));
    var EParserCode = akra.EParserCode;
    (function (EParserType) {
        EParserType._map = [];
        EParserType._map[0] = "k_LR0";
        EParserType.k_LR0 = 0;
        EParserType._map[1] = "k_LR1";
        EParserType.k_LR1 = 1;
        EParserType._map[2] = "k_LALR";
        EParserType.k_LALR = 2;
    })(akra.EParserType || (akra.EParserType = {}));
    var EParserType = akra.EParserType;
    (function (EParseMode) {
        EParseMode._map = [];
        EParseMode.k_AllNode = 0x0001;
        EParseMode.k_Negate = 0x0002;
        EParseMode.k_Add = 0x0004;
        EParseMode.k_Optimize = 0x0008;
        EParseMode.k_DebugMode = 0x0010;
    })(akra.EParseMode || (akra.EParseMode = {}));
    var EParseMode = akra.EParseMode;
    (function (ETokenType) {
        ETokenType._map = [];
        ETokenType.k_NumericLiteral = 1;
        ETokenType._map[2] = "k_CommentLiteral";
        ETokenType.k_CommentLiteral = 2;
        ETokenType._map[3] = "k_StringLiteral";
        ETokenType.k_StringLiteral = 3;
        ETokenType._map[4] = "k_PunctuatorLiteral";
        ETokenType.k_PunctuatorLiteral = 4;
        ETokenType._map[5] = "k_WhitespaceLiteral";
        ETokenType.k_WhitespaceLiteral = 5;
        ETokenType._map[6] = "k_IdentifierLiteral";
        ETokenType.k_IdentifierLiteral = 6;
        ETokenType._map[7] = "k_KeywordLiteral";
        ETokenType.k_KeywordLiteral = 7;
        ETokenType._map[8] = "k_Unknown";
        ETokenType.k_Unknown = 8;
        ETokenType._map[9] = "k_End";
        ETokenType.k_End = 9;
    })(akra.ETokenType || (akra.ETokenType = {}));
    var ETokenType = akra.ETokenType;
    (function (EOperationType) {
        EOperationType._map = [];
        EOperationType.k_Error = 100;
        EOperationType._map[101] = "k_Shift";
        EOperationType.k_Shift = 101;
        EOperationType._map[102] = "k_Reduce";
        EOperationType.k_Reduce = 102;
        EOperationType._map[103] = "k_Success";
        EOperationType.k_Success = 103;
        EOperationType._map[104] = "k_Pause";
        EOperationType.k_Pause = 104;
        EOperationType._map[105] = "k_Ok";
        EOperationType.k_Ok = 105;
    })(akra.EOperationType || (akra.EOperationType = {}));
    var EOperationType = akra.EOperationType;
    // _getLexer(): ILexer;
    // _getSource(): string;
    // _getIndex(): uint;
    // _getTypeMap(): BoolMap;
    // _getStack(): uint[];
    // _getToken(): IToken;
    // _getCallback(): IFinishFunc;
    // _getCaller(): any;
    // _setParserState(sSource: string,
    //                 iIndex: uint,
    //                 sFileName: string,
    //                 pTree: IParseTree,
    //                 pTypes: BoolMap,
    //                 pStack: uint[],
    //                 pToken: IToken,
    //                 fnCallback: IFinishFunc,
    //                 pCaller: any): void;
    })(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    ;
    ;
    /**
    * Отражает состояние ресурса
    **/
    (function (EResourceItemEvents) {
        EResourceItemEvents._map = [];
        EResourceItemEvents._map[0] = "CREATED";
        //ресур создан
        EResourceItemEvents.CREATED = 0;
        EResourceItemEvents._map[1] = "LOADED";
        //ресур заполнен данным и готов к использованию
        EResourceItemEvents.LOADED = 1;
        EResourceItemEvents._map[2] = "DISABLED";
        //ресур в данный момент отключен для использования
        EResourceItemEvents.DISABLED = 2;
        EResourceItemEvents._map[3] = "ALTERED";
        //ресур был изменен после загрузки
        EResourceItemEvents.ALTERED = 3;
        EResourceItemEvents._map[4] = "TOTALRESOURCEFLAGS";
        EResourceItemEvents.TOTALRESOURCEFLAGS = 4;
    })(akra.EResourceItemEvents || (akra.EResourceItemEvents = {}));
    var EResourceItemEvents = akra.EResourceItemEvents;
    ;
})(akra || (akra = {}));
// totalAnimations: uint;
// totalMeshes: uint;
// node: ISceneNode;
// getAnimation(iAnim: uint): IAnimationBase;
// setAnimation(iAnim: uint, pAnimation: IAnimationBase): void;
// addAnimation(pAnimation: IAnimationBase): void;
// getAnimationController(): IAnimationController;
// getMesh(iMesh: uint): IMesh;
// addMesh(pMesh: IMesh): void;
// addNode(pNode: ISceneNode): void;
// addSkeleton(pSkeleton: ISkeleton): void;
// addToScene(pScene: IScene3d): bool;
//    attachToScene(pNode: ISceneNode): bool;
// getRootNodes(): ISceneNode[];
// loadResource(sFilename?: string, pOptions?: IColladaLoadOptions, fnCallback?: (pModel: IModel) => void): bool;
// loadAnimation(sFilename: string): bool;
// //instead old method: applyShadow();
// _setup(): bool;
// _notifyFileLoaded(): uint;
// _notifyFileLoad(): uint;
// _totalFiles(): uint;
var akra;
(function (akra) {
    (function (EResourceCodes) {
        EResourceCodes._map = [];
        EResourceCodes.INVALID_CODE = 0xFFFFFFFF;
    })(akra.EResourceCodes || (akra.EResourceCodes = {}));
    var EResourceCodes = akra.EResourceCodes;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            var ResourceCode = (function () {
                function /** @no-inline */ResourceCode(iFamily, iType) {
                    this.iValue = (4294967295 /* INVALID_CODE */ );
                    switch(arguments.length) {
                        case 0:
                            this.iValue = 4294967295 /* INVALID_CODE */ ;
                            break;
                        case 1:
                            if(arguments[0] instanceof ResourceCode) {
                                this.iValue = arguments[0].iValue;
                            } else {
                                this.iValue = arguments[0];
                            }
                            break;
                        case 2:
                            this.family = arguments[0];
                            this.type = arguments[1];
                            break;
                    }
                }
                Object.defineProperty(ResourceCode.prototype, "family", {
                    get: function /** @no-inline */() {
                        return this.iValue >> 16;
                    },
                    set: function /** @no-inline */(iNewFamily) {
                        this.iValue &= 0x0000FFFF;
                        this.iValue |= iNewFamily << 16;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourceCode.prototype, "type", {
                    get: function /** @no-inline */() {
                        return this.iValue & 0x0000FFFF;
                    },
                    set: function /** @no-inline */(iNewType) {
                        this.iValue &= 0xFFFF0000;
                        this.iValue |= iNewType & 0x0000FFFF;
                    },
                    enumerable: true,
                    configurable: true
                });
                ResourceCode.prototype.setInvalid = function /** @no-inline */() {
                    this.iValue = 4294967295 /* INVALID_CODE */ ;
                };
                ResourceCode.prototype.less = function /** @no-inline */(pSrc) {
                    return this.iValue < pSrc.valueOf();
                };
                ResourceCode.prototype.eq = function /** @no-inline */(pSrc) {
                    this.iValue = pSrc.valueOf();
                    return this;
                };
                ResourceCode.prototype.valueOf = function /** @no-inline */() {
                    return this.iValue;
                };
                ResourceCode.prototype.toNumber = function /** @no-inline */() {
                    return this.iValue;
                };
                return ResourceCode;
            })();
            pool.ResourceCode = ResourceCode;            
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var ReferenceCounter = (function () {
            function /** @no-inline */ReferenceCounter(pSrc) {
                this.nReferenceCount = 0;
            }
            ReferenceCounter.prototype.referenceCount = /** @inline */
            function /** @no-inline */() {
                return this.nReferenceCount;
            };
            ReferenceCounter.prototype.destructor = /** @inline */
            function /** @no-inline */() {
                util.logger.setSourceLocation("util/ReferenceCounter.ts", 26);
                util.logger.assert(this.nReferenceCount === 0, 'object is used');
                ;
            };
            ReferenceCounter.prototype.release = function /** @no-inline */() {
                util.logger.setSourceLocation("util/ReferenceCounter.ts", 30);
                util.logger.assert(this.nReferenceCount > 0, 'object is used');
                ;
                this.nReferenceCount--;
                return this.nReferenceCount;
            };
            ReferenceCounter.prototype.addRef = function /** @no-inline */() {
                util.logger.setSourceLocation("util/ReferenceCounter.ts", 36);
                util.logger.assert(this.nReferenceCount != akra.MIN_INT32, 'reference fail');
                ;
                this.nReferenceCount++;
                return this.nReferenceCount;
            };
            ReferenceCounter.prototype.eq = /** @inline */
            function /** @no-inline */(pSrc) {
                return this;
            };
            return ReferenceCounter;
        })();
        util.ReferenceCounter = ReferenceCounter;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    /*console.error(this.getEventTable());*/
    /**event, signal, slot*/
    /**event, signal, slot*/
    (function (events) {
        var EventTable = (function () {
            function EventTable() {
                this.broadcast = {
                };
                this.unicast = {
                };
            }
            EventTable.prototype.addDestination = function /** @no-inline */(iGuid, sSignal, pTarget, sSlot, eType) {
                if (typeof eType === "undefined") { eType = 0 /* BROADCAST */ ; }
                if(eType === 0 /* BROADCAST */ ) {
                    this.findBroadcastSignalMap(iGuid, sSignal).push({
                        target: pTarget,
                        callback: sSlot,
                        listener: null
                    });
                    return true;
                } else {
                    this.unicast[iGuid] = this.unicast[iGuid] || {
                    };
                    //console.log(iGuid, sSignal, pTarget, sSlot, eType);
                    //console.warn(this.unicast);
                    if(!akra.isDef(this.unicast[iGuid][sSignal])) {
                        this.unicast[iGuid][sSignal] = {
                            target: pTarget,
                            callback: sSlot,
                            listener: null
                        };
                        return true;
                    }
                }
                return false;
            };
            EventTable.prototype.removeDestination = function /** @no-inline */(iGuid, sSignal, pTarget, sSlot, eType) {
                if (typeof eType === "undefined") { eType = 0 /* BROADCAST */ ; }
                if(eType === 0 /* BROADCAST */ ) {
                    var pList = this.findBroadcastSignalMap(iGuid, sSignal);
                    for(var i = 0; i < pList.length; ++i) {
                        if(pList[i].target === pTarget && pList[i].callback === sSlot) {
                            pList.splice(i, 1);
                            return true;
                        }
                    }
                } else {
                    if(this.unicast[iGuid] && this.unicast[iGuid][sSignal]) {
                        delete this.unicast[iGuid][sSignal];
                        return true;
                    }
                }
                akra.logger.setSourceLocation("events/events.ts", 109);
                akra.logger.warning("cannot remove destination for GUID <%s> with signal <%s>", iGuid, sSignal);
                ;
                return false;
            };
            EventTable.prototype.addListener = function /** @no-inline */(iGuid, sSignal, fnListener, eType) {
                if (typeof eType === "undefined") { eType = 0 /* BROADCAST */ ; }
                if(eType === 0 /* BROADCAST */ ) {
                    this.findBroadcastSignalMap(iGuid, sSignal).push({
                        target: null,
                        callback: null,
                        listener: fnListener
                    });
                    return true;
                } else {
                    this.unicast[iGuid] = this.unicast[iGuid] || {
                    };
                    if(!akra.isDef(this.unicast[iGuid][sSignal])) {
                        this.unicast[iGuid][sSignal] = {
                            target: null,
                            callback: null,
                            listener: fnListener
                        };
                        return true;
                    }
                }
                akra.logger.setSourceLocation("events/events.ts", 125);
                akra.logger.warning("cannot add listener for GUID <%s> with signal <%s>", iGuid, sSignal);
                ;
                return false;
            };
            EventTable.prototype.removeListener = function /** @no-inline */(iGuid, sSignal, fnListener, eType) {
                if (typeof eType === "undefined") { eType = 0 /* BROADCAST */ ; }
                if(eType === 0 /* BROADCAST */ ) {
                    var pList = this.findBroadcastSignalMap(iGuid, sSignal);
                    for(var i = 0; i < pList.length; ++i) {
                        if(pList[i].listener === fnListener) {
                            pList.splice(i, 1);
                            return true;
                        }
                    }
                } else {
                    if(this.unicast[iGuid] && this.unicast[iGuid][sSignal]) {
                        delete this.unicast[iGuid][sSignal];
                        return true;
                    }
                }
                return false;
            };
            EventTable.prototype.findBroadcastList = function /** @no-inline */(iGuid) {
                this.broadcast[iGuid] = this.broadcast[iGuid] || {
                };
                return this.broadcast[iGuid];
            };
            EventTable.prototype.findUnicastList = function /** @no-inline */(iGuid) {
                //console.error(iGuid,this.unicast[iGuid]);
                this.unicast[iGuid] = this.unicast[iGuid] || {
                };
                return this.unicast[iGuid];
            };
            EventTable.prototype.findBroadcastSignalMap = function /** @no-inline */(iGuid, sSignal) {
                this.broadcast[iGuid] = this.broadcast[iGuid] || {
                };
                this.broadcast[iGuid][sSignal] = this.broadcast[iGuid][sSignal] || [];
                return this.broadcast[iGuid][sSignal];
            };
            return EventTable;
        })();
        events.EventTable = EventTable;        
    })(akra.events || (akra.events = {}));
    var events = akra.events;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            var ResourcePool = (function (_super) {
                __extends(ResourcePool, _super);
                function /** @no-inline */ResourcePool(pManager, tTemplate) {
                                _super.call(this);
                    this.pManager = null;
                    /** Конструктор для создания данных в пуле ресурсов */
                    this.tTemplate = null;
                    this.sExt = null;
                    this.pRegistrationCode = new pool.ResourceCode(4294967295 /* INVALID_CODE */ );
                    /*{[index: number]: string;}*/
                    this.pNameMap = new Array();
                    this.pDataPool = null;
                    this._iGuid = eval("this._iGuid || akra.sid()");
                    this._pUnicastSlotMap = null;
                    this._pBroadcastSlotList = null;
                    this.pManager = pManager;
                    this.tTemplate = tTemplate;
                    this.pDataPool = new pool.DataPool(this.pManager, tTemplate);
                }
                Object.defineProperty(ResourcePool.prototype, "iFourcc", {
                    get: function /** @inline */() {
                        return (this.sExt.charCodeAt(3) << 24) | (this.sExt.charCodeAt(2) << 16) | (this.sExt.charCodeAt(1) << 8) | (this.sExt.charCodeAt(0));
                    },
                    set: function /** @no-inline */(iNewFourcc) {
                        this.sExt = String.fromCharCode((iNewFourcc & 0x000000FF), (iNewFourcc & 0x0000FF00) >>> 8, (iNewFourcc & 0x00FF0000) >>> 16, (iNewFourcc & 0xFF000000) >>> 24);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePool.prototype, "manager", {
                    get: function /** @inline */() {
                        return this.pManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                ResourcePool.prototype.registerResourcePool = /** Добавление данного пула в менеджер ресурсво по его коду */
                function /** @no-inline */(pCode) {
                    this.pRegistrationCode.eq(pCode);
                    this.pManager.registerResourcePool(this.pRegistrationCode, this);
                };
                ResourcePool.prototype.unregisterResourcePool = /** Удаление данного пула в менеджер ресурсво по его коду */
                function /** @no-inline */() {
                    this.pManager.unregisterResourcePool(this.pRegistrationCode);
                    this.pRegistrationCode.setInvalid();
                };
                ResourcePool.prototype.findResourceHandle = /** По имени ресурса возвращает его хендл */
                function /** @no-inline */(sName) {
                    // look up the name in our map
                    var iNewHandle = akra.INVALID_INDEX;
                    for(var iHandle = 0; iHandle < this.pNameMap.length; ++iHandle) {
                        if(this.pNameMap[iHandle] === sName) {
                            return iHandle;
                        }
                    }
                    return iNewHandle;
                };
                ResourcePool.prototype.findResourceName = /**
                * Get resource name by handle.
                * @inline
                */
                function /** @no-inline */(iHandle) {
                    return this.pNameMap[iHandle];
                };
                ResourcePool.prototype.setResourceName = function /** @no-inline */(iHandle, sName) {
                    this.pNameMap[iHandle] = sName;
                };
                ResourcePool.prototype.initialize = function /** @no-inline */(iGrowSize) {
                    this.pDataPool.initialize(iGrowSize);
                };
                ResourcePool.prototype.destroy = /** @inline */
                function /** @no-inline */() {
                    this.pDataPool.destroy();
                };
                ResourcePool.prototype.clean = function /** @no-inline */() {
                    this.pDataPool.forEach(ResourcePool.callbackClean);
                };
                ResourcePool.prototype.destroyAll = function /** @no-inline */() {
                    this.pDataPool.forEach(ResourcePool.callbackDestroy);
                };
                ResourcePool.prototype.restoreAll = function /** @no-inline */() {
                    this.pDataPool.forEach(ResourcePool.callbackRestore);
                };
                ResourcePool.prototype.disableAll = function /** @no-inline */() {
                    this.pDataPool.forEach(ResourcePool.callbackDisable);
                };
                ResourcePool.prototype.isInitialized = /** @inline */
                function /** @no-inline */() {
                    return this.pDataPool.isInitialized();
                };
                ResourcePool.prototype.createResource = function /** @no-inline */(sResourceName) {
                    var iHandle = this.internalCreateResource(sResourceName);
                    if(iHandle !== akra.INVALID_INDEX) {
                        var pResource = this.getResource(iHandle);
                        pResource.setResourcePool(this);
                        pResource.setResourceHandle(iHandle);
                        pResource.setResourceCode(this.pRegistrationCode);
                        this.createdResource(pResource);
                        return pResource;
                    }
                    return null;
                };
                ResourcePool.prototype.loadResource = function /** @no-inline */(sResourceName) {
                    // does the resource already exist?
                    var pResource = this.findResource(sResourceName);
                    if(pResource == null) {
                        // create a new resource
                        pResource = this.createResource(sResourceName);
                        if(pResource != null) {
                            // attempt to load the desired data
                            if(pResource.loadResource(sResourceName)) {
                                // ok!
                                return pResource;
                            }
                            // loading failed.
                            // destroy the resource we created
                            // destroyResource(pResource);
                            pResource.release();
                            pResource = null;
                        }
                    }
                    return pResource;
                };
                ResourcePool.prototype.saveResource = function /** @no-inline */(pResource) {
                    if(pResource != null) {
                        // save the resource using it's own name as the file path
                        return pResource.saveResource();
                    }
                    return false;
                };
                ResourcePool.prototype.destroyResource = function /** @no-inline */(pResource) {
                    if(pResource != null) {
                        var iReferenceCount = pResource.referenceCount();
                        akra.logger.setSourceLocation("ResourcePool.ts", 181);
                        akra.logger.assert(iReferenceCount == 0, "destruction of non-zero reference count!");
                        ;
                        if(iReferenceCount <= 0) {
                            var iHandle = pResource.resourceHandle;
                            this.internalDestroyResource(iHandle);
                        }
                    }
                };
                ResourcePool.prototype.findResource = function /** @no-inline */(sName) {
                    // look up the name in our map
                    for(var iHandle = 0; iHandle < this.pNameMap.length; ++iHandle) {
                        if(this.pNameMap[iHandle] == sName) {
                            if(iHandle != akra.INVALID_INDEX) {
                                var pResource = this.getResource(iHandle);
                                return pResource;
                            }
                        }
                    }
                    return null;
                };
                ResourcePool.prototype.getResource = function /** @no-inline */(iHandle) {
                    var pResource = this.internalGetResource(iHandle);
                    if(pResource != null) {
                        pResource.addRef();
                    }
                    return pResource;
                };
                ResourcePool.prototype.getResources = function /** @no-inline */() {
                    var pResources = [];
                    for(var iHandleResource in this.pNameMap) {
                        pResources.push(this.getResource(parseInt(iHandleResource)));
                    }
                    return pResources;
                };
                ResourcePool.prototype.internalGetResource = function /** @no-inline */(iHandle) {
                    return this.pDataPool.getPtr(iHandle);
                };
                ResourcePool.prototype.internalDestroyResource = function /** @no-inline */(iHandle) {
                    // get a pointer to the resource and call it's destruction handler
                    var pResource = this.pDataPool.getPtr(iHandle);
                    pResource.destroyResource();
                    delete this.pNameMap[iHandle];
                    // free the resource slot associated with the handle
                    this.pDataPool.release(iHandle);
                };
                ResourcePool.prototype.internalCreateResource = function /** @no-inline */(sResourceName) {
                    var iHandle = this.pDataPool.nextHandle();
                    // make sure this name is not already in use
                    for(var iter in this.pNameMap) {
                        akra.logger.setSourceLocation("ResourcePool.ts", 248);
                        akra.logger.assert((this.pNameMap[iter] != sResourceName), "A resource with this name already exists: " + sResourceName);
                        ;
                    }
                    // add this resource name to our map of handles
                    this.pNameMap[iHandle] = sResourceName;
                    // get a pointer to the resource and call it's creation function
                    var pResource = this.pDataPool.getPtr(iHandle);
                    pResource.createResource();
                    return iHandle;
                };
                ResourcePool.callbackDestroy = function /** @no-inline */callbackDestroy(pPool, iHandle, pResource) {
                    pResource.destroyResource();
                };
                ResourcePool.callbackDisable = function /** @no-inline */callbackDisable(pPool, iHandle, pResource) {
                    pResource.disableResource();
                };
                ResourcePool.callbackRestore = function /** @no-inline */callbackRestore(pPool, iHandle, pResource) {
                    pResource.restoreResource();
                };
                ResourcePool.callbackClean = function /** @no-inline */callbackClean(pPool, iHandle, pResource) {
                    if(pResource.referenceCount() == 0) {
                        pPool.release(iHandle);
                    }
                };
                ResourcePool._pEventTable = new akra.events.EventTable();
                ResourcePool.prototype.getEventTable = function /** @inline */() {
                    return ResourcePool._pEventTable;
                };
                ResourcePool.prototype.getGuid = function /** @no-inline */() {
                    return this._iGuid < 0 ? (this._iGuid = akra.sid()) : this._iGuid;
                };
                ResourcePool.prototype.connect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                    return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
                };
                ResourcePool.prototype.disconnect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                    return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
                };
                ResourcePool.prototype.bind = function /** @inline */(sSignal, fnListener, eType) {
                    return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType);
                };
                ResourcePool.prototype.unbind = function /** @inline */(sSignal, fnListener, eType) {
                    return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType);
                };
                ResourcePool.prototype.createdResource = function /** @no-inline */(pResource) {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                    var _broadcast = (this._pBroadcastSlotList).createdResource;
                    var _recivier = this;
                    if(akra.isDef(_broadcast)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pResource) : _broadcast[i].listener(_recivier, pResource);
                        }
                    }
                };
                return ResourcePool;
            })(akra.util.ReferenceCounter);
            pool.ResourcePool = ResourcePool;            
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            var PoolGroup = (function () {
                function /** @no-inline */PoolGroup(pManager, tTemplate, iMaxCount) {
                    /** Число свободных элементов группы */
                    this.iTotalOpen = 0;
                    /** Первый свободный элемент группы */
                    this.iFirstOpen = 0;
                    /** Колмичество элементов в группе */
                    this.iMaxCount = 0;
                    /** Список свободных элементов группы */
                    this.pNextOpenList = null;
                    /** Массив элементов группы */
                    this.pMemberList = null;
                    this.pManager = pManager;
                    this.tTemplate = tTemplate;
                    this.iMaxCount = iMaxCount;
                }
                Object.defineProperty(PoolGroup.prototype, "manager", {
                    get: function /** @inline */() {
                        return this.pManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(PoolGroup.prototype, "totalOpen", {
                    get: /**
                    * Возвращает количесвто свободных мест в группе
                    * @inline
                    */
                    function /** @no-inline */() {
                        return this.iTotalOpen;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(PoolGroup.prototype, "totalUsed", {
                    get: /**
                    * Возвращает количесвто занятых мест в группе
                    * @inline
                    */
                    function /** @no-inline */() {
                        return this.iMaxCount - this.iTotalOpen;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(PoolGroup.prototype, "firstOpen", {
                    get: /**
                    * Номер первого свободного элемента в группе
                    * @inline
                    */
                    function /** @no-inline */() {
                        return this.iFirstOpen;
                    },
                    enumerable: true,
                    configurable: true
                });
                PoolGroup.prototype.create = /** Создание группы, создается массив элементов, инициализирется список свободный и т.д. */
                function /** @no-inline */() {
                    var i;
                    akra.logger.setSourceLocation("DataPool.ts", 70);
                    akra.logger.assert(this.pMemberList == null && this.pNextOpenList == null, "Group has already been created");
                    ;
                    this.pNextOpenList = new Array(this.iMaxCount);
                    akra.logger.setSourceLocation("DataPool.ts", 74);
                    akra.logger.assert(this.pNextOpenList != null, "tragic memory allocation failure!");
                    ;
                    this.pMemberList = new Array(this.iMaxCount);
                    for(i = 0; i < this.iMaxCount; i++) {
                        this.pMemberList[i] = new this.tTemplate(this.pManager);
                    }
                    akra.logger.setSourceLocation("DataPool.ts", 83);
                    akra.logger.assert(this.pNextOpenList != null, "tragic memory allocation failure!");
                    ;
                    for(i = 0; i < this.iMaxCount - 1; i++) {
                        this.pNextOpenList[i] = i + 1;
                    }
                    this.pNextOpenList[i] = i;
                    this.iTotalOpen = this.iMaxCount;
                    this.iFirstOpen = 0;
                };
                PoolGroup.prototype.destroy = /**
                * Удаление группы: удаление массива элементов, списка совбодных элементов и т.д.
                * Выдается ошибка если группа не пуста
                * */
                function /** @no-inline */() {
                    akra.logger.setSourceLocation("DataPool.ts", 99);
                    akra.logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created");
                    ;
                    akra.logger.setSourceLocation("DataPool.ts", 100);
                    akra.logger.assert(this.iTotalOpen == this.iMaxCount, "Group is not empty");
                    ;
                    delete this.pMemberList;
                    this.pMemberList = null;
                    delete this.pNextOpenList;
                    this.pNextOpenList = null;
                    this.iTotalOpen = 0;
                    this.iMaxCount = 0;
                };
                PoolGroup.prototype.nextMember = /** Возвращает номер следующего совбодного элемента в списке, и помечает его как используемый */
                function /** @no-inline */() {
                    akra.logger.setSourceLocation("DataPool.ts", 114);
                    akra.logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created");
                    ;
                    akra.logger.setSourceLocation("DataPool.ts", 115);
                    akra.logger.assert(this.iTotalOpen != null, "no open slots");
                    ;
                    //Возвращает номер первого свободного элемента в группе,
                    //и изменяет номер первого свободного на следующего свободного
                    var iSlot = this.iFirstOpen;
                    this.iFirstOpen = this.pNextOpenList[iSlot];
                    this.iTotalOpen--;
                    akra.logger.setSourceLocation("DataPool.ts", 123);
                    akra.logger.assert(this.iFirstOpen != akra.INVALID_INDEX, "Invalid Open Index");
                    ;
                    akra.logger.setSourceLocation("DataPool.ts", 124);
                    akra.logger.assert(this.isOpen(iSlot), "invalid index");
                    ;
                    //помечаем что элемент который отдали является используемым
                    this.pNextOpenList[iSlot] = akra.INVALID_INDEX;
                    return iSlot;
                };
                PoolGroup.prototype.addMember = /** Добавляем новый элемент в список */
                function /** @no-inline */(pMember) {
                    var iSlot = this.nextMember();
                    this.pMemberList[iSlot] = pMember;
                    return iSlot;
                };
                PoolGroup.prototype.release = /** Исключение элемента из списка по его номеру */
                function /** @no-inline */(iIndex) {
                    akra.logger.setSourceLocation("DataPool.ts", 142);
                    akra.logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created");
                    ;
                    akra.logger.setSourceLocation("DataPool.ts", 143);
                    akra.logger.assert(iIndex < this.iMaxCount, "invalid index");
                    ;
                    akra.logger.setSourceLocation("DataPool.ts", 144);
                    akra.logger.assert(this.isOpen(iIndex) == false, "invalid index to release");
                    ;
                    this.pNextOpenList[iIndex] = this.iTotalOpen > 0 ? this.iFirstOpen : iIndex;
                    this.iTotalOpen++;
                    this.iFirstOpen = iIndex;
                };
                PoolGroup.prototype.isOpen = /** Проверить свободна ли эта ячейка в группе */
                function /** @no-inline */(iIndex) {
                    akra.logger.setSourceLocation("DataPool.ts", 154);
                    akra.logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created");
                    ;
                    akra.logger.setSourceLocation("DataPool.ts", 155);
                    akra.logger.assert(iIndex < this.iMaxCount, "invalid index");
                    ;
                    return this.pNextOpenList[iIndex] != akra.INVALID_INDEX;
                };
                PoolGroup.prototype.member = /** Получение элемента по его номеру */
                function /** @no-inline */(iIndex) {
                    akra.logger.setSourceLocation("DataPool.ts", 162);
                    akra.logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created");
                    ;
                    akra.logger.setSourceLocation("DataPool.ts", 163);
                    akra.logger.assert(iIndex < this.iMaxCount, "invalid index");
                    ;
                    return this.pMemberList[iIndex];
                };
                PoolGroup.prototype.memberPtr = function /** @no-inline */(iIndex) {
                    akra.logger.setSourceLocation("DataPool.ts", 168);
                    akra.logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created");
                    ;
                    akra.logger.setSourceLocation("DataPool.ts", 169);
                    akra.logger.assert(iIndex < this.iMaxCount, "invalid index");
                    ;
                    return this.pMemberList[iIndex];
                };
                return PoolGroup;
            })();
            pool.PoolGroup = PoolGroup;            
            var DataPool = (function () {
                function /** @no-inline */DataPool(pManager, tTemplate) {
                    this.bInitialized = false;
                    /** Массив групп */
                    this.pGroupList = [];
                    /** Общее число ячеек */
                    this.iTotalMembers = 0;
                    /** Количесвто свободных ячеек */
                    this.iTotalOpen = 0;
                    /** Количесвто элементов в группе */
                    this.iGroupCount = 0;
                    /**
                    * Номер элемента состоит из номер группы сдвинутого на _iIndexShift
                    * и номера элемента в этой группе, который можно вырезать маской _iIndexMask
                    */
                    this.iIndexMask = 0;
                    /**
                    * Номер элемента состоит из номер группы сдвинутого на _iIndexShift
                    * и номера элемента в этой группе, который можно вырезать маской _iIndexMask
                    */
                    this.iIndexShift = 0;
                    this.pManager = pManager;
                    this.tTemplate = tTemplate;
                }
                Object.defineProperty(DataPool.prototype, "manager", {
                    get: function /** @inline */() {
                        return this.pManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                DataPool.prototype.initialize = function /** @no-inline */(iGrowSize) {
                    akra.logger.setSourceLocation("DataPool.ts", 209);
                    akra.logger.assert(this.isInitialized() == false, "the cDataPool is already initialized");
                    ;
                    this.bInitialized = true;
                    this.iGroupCount = akra.math.nearestPowerOfTwo(iGrowSize);
                    this.iIndexShift = akra.math.lowestBitSet(this.iGroupCount);
                    this.iIndexShift = akra.math.clamp(this.iIndexShift, 1, 15);
                    this.iGroupCount = 1 << this.iIndexShift;
                    this.iIndexMask = this.iGroupCount - 1;
                };
                DataPool.prototype.isInitialized = /** @inline */
                function /** @no-inline */() {
                    return this.bInitialized;
                };
                DataPool.prototype.destroy = function /** @no-inline */() {
                    this.clear();
                    this.bInitialized = false;
                };
                DataPool.prototype.release = function /** @no-inline */(iHandle) {
                    akra.logger.setSourceLocation("DataPool.ts", 233);
                    akra.logger.assert(this.isInitialized() == true, "the cDataPool is not initialized");
                    ;
                    if(this.isHandleValid(iHandle) == true) {
                        akra.logger.setSourceLocation("DataPool.ts", 236);
                        akra.logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created");
                        ;
                        var iGroupIndex = this.getGroupNumber(iHandle);
                        var iItemIndex = this.getItemIndex(iHandle);
                        var pGroup = this.getGroup(iGroupIndex);
                        pGroup.release(iItemIndex);
                        var pGroupBack = this.pGroupList[this.pGroupList.length - 1];
                        if(pGroupBack.totalOpen == this.iGroupCount) {
                            pGroupBack.destroy();
                            this.pGroupList.splice(this.pGroupList.length - 1, 1);
                        }
                        this.iTotalOpen++;
                    }
                };
                DataPool.prototype.clear = function /** @no-inline */() {
                    // destroy all groups in the list
                    for(var iGroupIter = 0; iGroupIter < this.pGroupList.length; ++iGroupIter) {
                        this.pGroupList[iGroupIter].destroy();
                    }
                    // now clear the list itself
                    this.pGroupList.clear();
                };
                DataPool.prototype.add = function /** @no-inline */(pMembers) {
                    akra.logger.setSourceLocation("DataPool.ts", 265);
                    akra.logger.assert(this.isInitialized() == true, "the cDataPool is not initialized");
                    ;
                    var iGroupNumber = {
                        value: 0
                    };
                    var pOpenGroup = this.findOpenGroup(iGroupNumber);
                    var iIndex = pOpenGroup.addMember(pMembers);
                    this.iTotalOpen--;
                    return this.buildHandle(iGroupNumber.value, iIndex);
                };
                DataPool.prototype.forEach = function /** @no-inline */(fFunction) {
                    akra.logger.setSourceLocation("DataPool.ts", 278);
                    akra.logger.assert(this.isInitialized() == true, "the cDataPool is not initialized");
                    ;
                    // iterate through every group
                    var iGroupNumber = 0;
                    for(var iGroupIter = 0; iGroupIter < this.pGroupList.length; iGroupIter++) {
                        var nCallbackCount = this.pGroupList[iGroupIter].totalUsed;
                        var iItemIndex = 0;
                        while(nCallbackCount != 0 && iItemIndex < this.iGroupCount) {
                            if(this.pGroupList[iGroupIter].isOpen(iItemIndex) == false) {
                                fFunction(this, this.buildHandle(iGroupNumber, iItemIndex), this.pGroupList[iGroupIter].member(iItemIndex));
                                nCallbackCount--;
                            }
                            ++iItemIndex;
                        }
                        ++iGroupNumber;
                    }
                };
                DataPool.prototype.nextHandle = function /** @no-inline */() {
                    akra.logger.setSourceLocation("DataPool.ts", 305);
                    akra.logger.assert(this.isInitialized() == true, "the cDataPool is not initialized");
                    ;
                    var iGroupNumber = {
                        value: 0
                    };
                    var pOpenGroup = this.findOpenGroup(iGroupNumber);
                    var iIndex = pOpenGroup.nextMember();
                    this.iTotalOpen--;
                    return this.buildHandle(iGroupNumber.value, iIndex);
                };
                DataPool.prototype.isHandleValid = function /** @no-inline */(iHandle) {
                    akra.logger.setSourceLocation("DataPool.ts", 317);
                    akra.logger.assert(this.isInitialized() == true, "the cDataPool is not initialized");
                    ;
                    if(iHandle !== akra.INVALID_INDEX) {
                        akra.logger.setSourceLocation("DataPool.ts", 320);
                        akra.logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created");
                        ;
                        var pGroup = this.getGroup(this.getGroupNumber(iHandle));
                        return !pGroup.isOpen(this.getItemIndex(iHandle));
                    }
                    return false;
                };
                DataPool.prototype.get = function /** @no-inline */(iHandle) {
                    akra.logger.setSourceLocation("DataPool.ts", 331);
                    akra.logger.assert(this.isInitialized() == true, "the cDataPool is not initialized");
                    ;
                    akra.logger.setSourceLocation("DataPool.ts", 332);
                    akra.logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created");
                    ;
                    var pGroup = this.getGroup(this.getGroupNumber(iHandle));
                    var iItemIndex = this.getItemIndex(iHandle);
                    return pGroup.member(iItemIndex);
                };
                DataPool.prototype.getPtr = function /** @no-inline */(iHandle) {
                    akra.logger.setSourceLocation("DataPool.ts", 341);
                    akra.logger.assert(this.isInitialized() == true, "the cDataPool is not initialized");
                    ;
                    akra.logger.setSourceLocation("DataPool.ts", 342);
                    akra.logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created");
                    ;
                    var pGroup = this.getGroup(this.getGroupNumber(iHandle));
                    var iItemIndex = this.getItemIndex(iHandle);
                    return pGroup.memberPtr(iItemIndex);
                };
                DataPool.prototype.getGenericPtr = function /** @no-inline */(iHandle) {
                    akra.logger.setSourceLocation("DataPool.ts", 351);
                    akra.logger.assert(this.isInitialized() == true, "the cDataPool is not initialized");
                    ;
                    return this.getPtr(iHandle);
                };
                DataPool.prototype.getGroupNumber = /**
                * @inline
                * Получение номера группы по номеру элемента
                */
                function /** @no-inline */(iHandle) {
                    return iHandle >> this.iIndexShift;
                };
                DataPool.prototype.getItemIndex = /**
                * @inline
                * Получение номера элеменат в группе по его номеру
                */
                function /** @no-inline */(iHandle) {
                    return iHandle & this.iIndexMask;
                };
                DataPool.prototype.buildHandle = /**
                * @inline
                * Полученяи номера элеменат по его номеру группы и группе
                */
                function /** @no-inline */(iGroup, iIndex) {
                    return (iGroup << this.iIndexShift) + iIndex;
                };
                DataPool.prototype.addGroup = /** Добавление группы в пул */
                function /** @no-inline */() {
                    // append a new group to the list to start things off
                    var pNewGroup = new PoolGroup(this.pManager, this.tTemplate, this.iGroupCount);
                    this.pGroupList.push(pNewGroup);
                    // gain access to the new group and innitialize it
                    pNewGroup.create();
                    // increment our internal counters
                    this.iTotalMembers += this.iGroupCount;
                    this.iTotalOpen += this.iGroupCount;
                    return pNewGroup;
                };
                DataPool.prototype.findOpenGroup = /** Поиск первой группы которая имеет свободную область */
                function /** @no-inline */(pGroupNumber) {
                    pGroupNumber.value = 0;
                    //найдем и вренем первую группу имеющую свободную группу
                    for(var iGroupIter = 0; iGroupIter < this.pGroupList.length; iGroupIter++) {
                        if(this.pGroupList[iGroupIter].totalOpen > 0) {
                            return this.pGroupList[iGroupIter];
                        }
                        pGroupNumber.value++;
                    }
                    //свободных областей нет, поэтому мы должны добавить новую группу в пул,
                    //но пержде чем содавать убедимся что не достигли максимума
                    akra.logger.setSourceLocation("DataPool.ts", 411);
                    akra.logger.assert((this.pGroupList.length + 1) < akra.MAX_UINT16, "the cDataPool is full!!!!");
                    ;
                    //добавим новую группу
                    return this.addGroup();
                };
                DataPool.prototype.getGroup = /**
                * @inline
                * Возвращает группу по ее номеру
                */
                function /** @no-inline */(iIndex) {
                    akra.logger.setSourceLocation("DataPool.ts", 422);
                    akra.logger.assert(iIndex < this.pGroupList.length, "Invalid group index requested");
                    ;
                    return this.pGroupList[iIndex];
                };
                return DataPool;
            })();
            pool.DataPool = DataPool;            
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            var ResourcePoolItem = (function (_super) {
                __extends(ResourcePoolItem, _super);
                /** Constructor of ResourcePoolItem class */
                /*pManager: IResourcePoolManager*/
                function /** @no-inline */ResourcePoolItem() {
                                _super.call(this);
                    this.pResourcePool = null;
                    this.iResourceHandle = 0;
                    this.iResourceFlags = 0;
                    this._iGuid = eval("this._iGuid || akra.sid()");
                    this._pUnicastSlotMap = null;
                    this._pBroadcastSlotList = null;
                    //this.pManager = pManager;
                    this.pResourceCode = new pool.ResourceCode(0);
                    this.pCallbackFunctions = [];
                    this.pStateWatcher = [];
                    this.pCallbackSlots = akra.genArray(null, 4 /* TOTALRESOURCEFLAGS */ );
                }
                Object.defineProperty(ResourcePoolItem.prototype, "resourceCode", {
                    get: function /** @inline */() {
                        return this.pResourceCode;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolItem.prototype, "resourcePool", {
                    get: function /** @inline */() {
                        return this.pResourcePool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolItem.prototype, "resourceHandle", {
                    get: function /** @inline */() {
                        return this.iResourceHandle;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolItem.prototype, "resourceFlags", {
                    get: function /** @inline */() {
                        return this.iResourceFlags;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolItem.prototype, "alteredFlag", {
                    get: function /** @inline */() {
                        return akra.bf.testBit(this.iResourceFlags, 3 /* ALTERED */ );
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolItem.prototype, "manager", {
                    get: function /** @inline */() {
                        return this.getManager();
                    },
                    enumerable: true,
                    configurable: true
                });
                ResourcePoolItem.prototype.getEngine = function /** @inline */() {
                    var pManager = this.getManager();
                    if(pManager) {
                        return pManager.getEngine();
                    }
                    return null;
                };
                ResourcePoolItem.prototype.getManager = function /** @inline */() {
                    return this.pResourcePool ? this.pResourcePool.manager : null;
                };
                ResourcePoolItem.prototype.createResource = function /** @no-inline */() {
                    return false;
                };
                ResourcePoolItem.prototype.destroyResource = function /** @no-inline */() {
                    return false;
                };
                ResourcePoolItem.prototype.disableResource = function /** @no-inline */() {
                    return false;
                };
                ResourcePoolItem.prototype.restoreResource = function /** @no-inline */() {
                    return false;
                };
                ResourcePoolItem.prototype.loadResource = function /** @no-inline */(sFilename) {
                    if (typeof sFilename === "undefined") { sFilename = null; }
                    return false;
                };
                ResourcePoolItem.prototype.saveResource = function /** @no-inline */(sFilename) {
                    if (typeof sFilename === "undefined") { sFilename = null; }
                    return false;
                };
                ResourcePoolItem.prototype.setChangesNotifyRoutine = function /** @no-inline */(fn) {
                    for(var i = 0; i < this.pCallbackFunctions.length; i++) {
                        if(this.pCallbackFunctions[i] == fn) {
                            return;
                        }
                    }
                    this.pCallbackFunctions.push(fn);
                };
                ResourcePoolItem.prototype.delChangesNotifyRoutine = function /** @no-inline */(fn) {
                    for(var i = 0; i < this.pCallbackFunctions.length; i++) {
                        if(this.pCallbackFunctions[i] == fn) {
                            this.pCallbackFunctions[i] = null;
                        }
                    }
                };
                ResourcePoolItem.prototype.setStateWatcher = function /** @no-inline */(eEvent, fnWatcher) {
                    this.pStateWatcher[eEvent] = fnWatcher;
                };
                ResourcePoolItem.prototype.sync = function /** @no-inline */(pResourceItem, eSignal, eSlot) {
                    eSlot = akra.isDef(eSlot) ? eSlot : eSignal;
                    eSlot = ResourcePoolItem.parseEvent(eSlot);
                    eSignal = ResourcePoolItem.parseEvent(eSignal);
                    var pSlots = this.pCallbackSlots, pSignSlots;
                    var me = this;
                    var n;
                    var fn;
                    var bState;
                    if(akra.isNull(pSlots[eSlot])) {
                        pSlots[eSlot] = [];
                    }
                    pSignSlots = pSlots[eSlot];
                    n = pSignSlots.length;
                    bState = akra.bf.testBit(pResourceItem.resourceFlags, eSignal);
                    fn = function /** @no-inline */(eFlag, iResourceFlags, isSet) {
                        if(eFlag == eSignal) {
                            pSignSlots[n].bState = isSet;
                            me.notifyStateChange(eSlot, this);
                            for(var i = 0; i < pSignSlots.length; ++i) {
                                if(pSignSlots[i].bState === false) {
                                    if(akra.bf.testBit(me.resourceFlags, eFlag)) {
                                        me.setResourceFlag(eFlag, false);
                                    }
                                    return;
                                }
                            }
                            me.setResourceFlag(eFlag, true);
                        }
                    };
                    pSignSlots.push({
                        bState: bState,
                        fn: fn,
                        pResourceItem: pResourceItem
                    });
                    fn.call(pResourceItem, eSignal, pResourceItem.resourceFlags, bState);
                    pResourceItem.setChangesNotifyRoutine(fn);
                    return true;
                };
                ResourcePoolItem.prototype.unsync = function /** @no-inline */(pResourceItem, eSignal, eSlot) {
                    eSlot = akra.isDef(eSlot) ? eSlot : eSignal;
                    eSlot = ResourcePoolItem.parseEvent(eSlot);
                    eSignal = ResourcePoolItem.parseEvent(eSignal);
                    var pSlots = this.pCallbackSlots, pSignSlots;
                    var me = this;
                    var isRem = false;
                    pSignSlots = pSlots[eSlot];
                    for(var i = 0, n = pSignSlots.length; i < n; ++i) {
                        if(pSignSlots[i].pResourceItem === pResourceItem) {
                            pSignSlots[i].pResourceItem.delChangesNotifyRoutine(pSignSlots[i].fn);
                            pSignSlots.splice(i, 1);
                            --n;
                            --i;
                            isRem = true;
                        }
                    }
                    return isRem;
                };
                ResourcePoolItem.prototype.isResourceCreated = function /** @inline */() {
                    return akra.bf.testBit(this.iResourceFlags, 0 /* CREATED */ );
                };
                ResourcePoolItem.prototype.isResourceLoaded = function /** @inline */() {
                    return akra.bf.testBit(this.iResourceFlags, 1 /* LOADED */ );
                };
                ResourcePoolItem.prototype.isResourceDisabled = function /** @inline */() {
                    return akra.bf.testBit(this.iResourceFlags, 2 /* DISABLED */ );
                };
                ResourcePoolItem.prototype.isResourceAltered = function /** @inline */() {
                    return akra.bf.testBit(this.iResourceFlags, 3 /* ALTERED */ );
                };
                ResourcePoolItem.prototype.setAlteredFlag = function /** @no-inline */(isOn) {
                    if (typeof isOn === "undefined") { isOn = true; }
                    //notify always, when altered called
                    if(this.setResourceFlag(3 /* ALTERED */ , isOn) || isOn) {
                        isOn ? this.altered() : this.saved();
                        return true;
                    }
                    return false;
                };
                ResourcePoolItem.prototype.setResourceName = function /** @inline */(sName) {
                    if(this.pResourcePool != null) {
                        this.pResourcePool.setResourceName(this.iResourceHandle, sName);
                    }
                };
                ResourcePoolItem.prototype.findResourceName = function /** @no-inline */() {
                    if(this.pResourcePool != null) {
                        return this.pResourcePool.findResourceName(this.iResourceHandle);
                    }
                    return null;
                };
                ResourcePoolItem.prototype.release = function /** @no-inline */() {
                    var iRefCount = _super.prototype.release.call(this);
                    if(iRefCount == 0) {
                        //Если у нас есть менеджер попросим его удалить нас
                        if(this.pResourcePool != null) {
                            this.pResourcePool.destroyResource(this);
                        }
                    }
                    return iRefCount;
                };
                ResourcePoolItem.prototype.notifyCreated = function /** @inline */() {
                    if(this.setResourceFlag(0 /* CREATED */ , true)) {
                        this.created();
                    }
                };
                ResourcePoolItem.prototype.notifyDestroyed = function /** @inline */() {
                    if(this.setResourceFlag(0 /* CREATED */ , false)) {
                        this.destroyed();
                    }
                };
                ResourcePoolItem.prototype.notifyLoaded = function /** @inline */() {
                    this.setAlteredFlag(false);
                    // LOG("ResourcePoolItem::notifyLoaded();");
                    if(this.setResourceFlag(1 /* LOADED */ , true)) {
                        // LOG("ResourcePoolItem::loaded();");
                        this.loaded();
                    }
                };
                ResourcePoolItem.prototype.notifyUnloaded = function /** @inline */() {
                    if(this.setResourceFlag(1 /* LOADED */ , false)) {
                        this.unloaded();
                    }
                };
                ResourcePoolItem.prototype.notifyRestored = function /** @inline */() {
                    if(this.setResourceFlag(2 /* DISABLED */ , false)) {
                        this.restored();
                    }
                };
                ResourcePoolItem.prototype.notifyDisabled = function /** @inline */() {
                    if(this.setResourceFlag(2 /* DISABLED */ , true)) {
                        this.disabled();
                    }
                };
                ResourcePoolItem.prototype.notifyAltered = function /** @inline */() {
                    this.setAlteredFlag(true);
                };
                ResourcePoolItem.prototype.notifySaved = function /** @inline */() {
                    this.setAlteredFlag(false);
                };
                ResourcePoolItem.prototype.setResourceCode = /**
                * Назначение кода ресурсу
                * @inline
                */
                function /** @no-inline */(pCode) {
                    this.pResourceCode.eq(pCode);
                };
                ResourcePoolItem.prototype.setResourcePool = /**
                * Чтобы ресурс знал какому пулу ресурсов принадлжит
                * @inline
                */
                function /** @no-inline */(pPool) {
                    this.pResourcePool = pPool;
                };
                ResourcePoolItem.prototype.setResourceHandle = /**
                * Назначение хендла ресурсу
                * @inline
                */
                function /** @no-inline */(iHandle) {
                    this.iResourceHandle = iHandle;
                };
                ResourcePoolItem.prototype.notifyStateChange = function /** @no-inline */(eEvent, pTarget) {
                    if (typeof pTarget === "undefined") { pTarget = null; }
                    if(!this.pStateWatcher[eEvent]) {
                        return;
                    }
                    var pSignSlots = this.pCallbackSlots[eEvent];
                    var nTotal = pSignSlots.length, nLoaded = 0;
                    for(var i = 0; i < nTotal; ++i) {
                        if(pSignSlots[i].bState) {
                            ++nLoaded;
                        }
                    }
                    this.pStateWatcher[eEvent](nLoaded, nTotal, pTarget);
                };
                ResourcePoolItem.prototype.setResourceFlag = function /** @no-inline */(iFlagBit, isSetting) {
                    var iTempFlags = this.iResourceFlags;
                    this.iResourceFlags = akra.bf.setBit(this.iResourceFlags, iFlagBit, isSetting);
                    // LOG("before !=", iFlagBit, "(" + EResourceItemEvents.LOADED + ")", iTempFlags, "==>", this.iResourceFlags);
                    if(iTempFlags != this.iResourceFlags) {
                        // LOG("!+");
                        for(var i = 0; i < this.pCallbackFunctions.length; i++) {
                            if(this.pCallbackFunctions[i]) {
                                this.pCallbackFunctions[i].call(this, iFlagBit, this.iResourceFlags, isSetting);
                            }
                        }
                        return true;
                    }
                    return false;
                };
                ResourcePoolItem.parseEvent = function /** @no-inline */parseEvent(pEvent) {
                    if(akra.isInt(pEvent)) {
                        return pEvent;
                    }
                    switch(pEvent.toLowerCase()) {
                        case 'loaded':
                            return 1 /* LOADED */ ;
                        case 'created':
                            return 0 /* CREATED */ ;
                        case 'disabled':
                            return 2 /* DISABLED */ ;
                        case 'altered':
                            return 3 /* ALTERED */ ;
                        default:
                            akra.logger.setSourceLocation("../ResourcePoolItem.ts", 381);
                            akra.logger.error('Использовано неизвестное событие для ресурса.');
                            ;
                            return 0;
                    }
                };
                ResourcePoolItem._pEventTable = new akra.events.EventTable();
                ResourcePoolItem.prototype.getEventTable = function /** @inline */() {
                    return ResourcePoolItem._pEventTable;
                };
                ResourcePoolItem.prototype.getGuid = function /** @no-inline */() {
                    return this._iGuid < 0 ? (this._iGuid = akra.sid()) : this._iGuid;
                };
                ResourcePoolItem.prototype.connect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                    return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
                };
                ResourcePoolItem.prototype.disconnect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                    return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
                };
                ResourcePoolItem.prototype.bind = function /** @inline */(sSignal, fnListener, eType) {
                    return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType);
                };
                ResourcePoolItem.prototype.unbind = function /** @inline */(sSignal, fnListener, eType) {
                    return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType);
                };
                ResourcePoolItem.prototype.created = function /** @no-inline */() {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                    var _broadcast = (this._pBroadcastSlotList).created;
                    var _recivier = this;
                    if(akra.isDef(_broadcast)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                ResourcePoolItem.prototype.destroyed = function /** @no-inline */() {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                    var _broadcast = (this._pBroadcastSlotList).destroyed;
                    var _recivier = this;
                    if(akra.isDef(_broadcast)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                ResourcePoolItem.prototype.loaded = function /** @no-inline */() {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                    var _broadcast = (this._pBroadcastSlotList).loaded;
                    var _recivier = this;
                    if(akra.isDef(_broadcast)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                ResourcePoolItem.prototype.unloaded = function /** @no-inline */() {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                    var _broadcast = (this._pBroadcastSlotList).unloaded;
                    var _recivier = this;
                    if(akra.isDef(_broadcast)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                ResourcePoolItem.prototype.restored = function /** @no-inline */() {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                    var _broadcast = (this._pBroadcastSlotList).restored;
                    var _recivier = this;
                    if(akra.isDef(_broadcast)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                ResourcePoolItem.prototype.disabled = function /** @no-inline */() {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                    var _broadcast = (this._pBroadcastSlotList).disabled;
                    var _recivier = this;
                    if(akra.isDef(_broadcast)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                ResourcePoolItem.prototype.altered = function /** @no-inline */() {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                    var _broadcast = (this._pBroadcastSlotList).altered;
                    var _recivier = this;
                    if(akra.isDef(_broadcast)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                ResourcePoolItem.prototype.saved = function /** @no-inline */() {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                    var _broadcast = (this._pBroadcastSlotList).saved;
                    var _recivier = this;
                    if(akra.isDef(_broadcast)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                return ResourcePoolItem;
            })(akra.util.ReferenceCounter);
            pool.ResourcePoolItem = ResourcePoolItem;            
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var RenderMethod = (function (_super) {
                    __extends(RenderMethod, _super);
                    function RenderMethod() {
                        _super.apply(this, arguments);

                    }
                    RenderMethod.prototype.isEqual = function /** @no-inline */(pRenderMethod) {
                        return false;
                    };
                    return RenderMethod;
                })(pool.ResourcePoolItem);
                resources.RenderMethod = RenderMethod;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    (function (ESurfaceMaterialTextures) {
        ESurfaceMaterialTextures._map = [];
        ESurfaceMaterialTextures.TEXTURE0 = 0;
        ESurfaceMaterialTextures._map[1] = "TEXTURE1";
        ESurfaceMaterialTextures.TEXTURE1 = 1;
        ESurfaceMaterialTextures._map[2] = "TEXTURE2";
        ESurfaceMaterialTextures.TEXTURE2 = 2;
        ESurfaceMaterialTextures._map[3] = "TEXTURE3";
        ESurfaceMaterialTextures.TEXTURE3 = 3;
        ESurfaceMaterialTextures._map[4] = "TEXTURE4";
        ESurfaceMaterialTextures.TEXTURE4 = 4;
        ESurfaceMaterialTextures._map[5] = "TEXTURE5";
        ESurfaceMaterialTextures.TEXTURE5 = 5;
        ESurfaceMaterialTextures._map[6] = "TEXTURE6";
        ESurfaceMaterialTextures.TEXTURE6 = 6;
        ESurfaceMaterialTextures._map[7] = "TEXTURE7";
        ESurfaceMaterialTextures.TEXTURE7 = 7;
        ESurfaceMaterialTextures._map[8] = "TEXTURE8";
        ESurfaceMaterialTextures.TEXTURE8 = 8;
        ESurfaceMaterialTextures._map[9] = "TEXTURE9";
        ESurfaceMaterialTextures.TEXTURE9 = 9;
        ESurfaceMaterialTextures._map[10] = "TEXTURE10";
        ESurfaceMaterialTextures.TEXTURE10 = 10;
        ESurfaceMaterialTextures._map[11] = "TEXTURE11";
        ESurfaceMaterialTextures.TEXTURE11 = 11;
        ESurfaceMaterialTextures._map[12] = "TEXTURE12";
        ESurfaceMaterialTextures.TEXTURE12 = 12;
        ESurfaceMaterialTextures._map[13] = "TEXTURE13";
        ESurfaceMaterialTextures.TEXTURE13 = 13;
        ESurfaceMaterialTextures._map[14] = "TEXTURE14";
        ESurfaceMaterialTextures.TEXTURE14 = 14;
        ESurfaceMaterialTextures._map[15] = "TEXTURE15";
        ESurfaceMaterialTextures.TEXTURE15 = 15;
        ESurfaceMaterialTextures.DIFFUSE = ESurfaceMaterialTextures.TEXTURE0;
        ESurfaceMaterialTextures._map[NaN] = "AMBIENT";
        ESurfaceMaterialTextures.AMBIENT = NaN;
        ESurfaceMaterialTextures._map[NaN] = "SPECULAR";
        ESurfaceMaterialTextures.SPECULAR = NaN;
        ESurfaceMaterialTextures._map[NaN] = "EMISSIVE";
        ESurfaceMaterialTextures.EMISSIVE = NaN;
        ESurfaceMaterialTextures.EMISSION = ESurfaceMaterialTextures.EMISSIVE;
    })(akra.ESurfaceMaterialTextures || (akra.ESurfaceMaterialTextures = {}));
    var ESurfaceMaterialTextures = akra.ESurfaceMaterialTextures;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    /**@const*/ akra.DeclarationUsages = {
        POSITION: "POSITION",
        POSITION1: "POSITION1",
        POSITION2: "POSITION2",
        POSITION3: "POSITION3",
        BLENDWEIGHT: "BLENDWEIGHT",
        BLENDINDICES: "BLENDINDICES",
        BLENDMETA: "BLENDMETA",
        NORMAL: "NORMAL",
        NORMAL1: "NORMAL1",
        NORMAL2: "NORMAL2",
        NORMAL3: "NORMAL3",
        PSIZE: "PSIZE",
        TEXCOORD: "TEXCOORD",
        TEXCOORD1: "TEXCOORD1",
        TEXCOORD2: "TEXCOORD2",
        TEXCOORD3: "TEXCOORD3",
        TEXCOORD4: "TEXCOORD4",
        TEXCOORD5: "TEXCOORD5",
        TANGENT: "TANGENT",
        BINORMAL: "BINORMAL",
        TESSFACTOR: "TESSFACTOR",
        COLOR: "COLOR",
        FOG: "FOG",
        DEPTH: "DEPTH",
        SAMPLE: "SAMPLE",
        INDEX: "INDEX",
        INDEX0: "INDEX0",
        INDEX1: "INDEX1",
        INDEX2: "INDEX2",
        INDEX3: "INDEX3",
        INDEX10: //system indices starts from 10
        "INDEX10",
        INDEX11: "INDEX11",
        INDEX12: "INDEX12",
        INDEX13: "INDEX13",
        MATERIAL: "MATERIAL",
        MATERIAL1: "MATERIAL1",
        MATERIAL2: "MATERIAL2",
        DIFFUSE: "DIFFUSE",
        AMBIENT: "AMBIENT",
        SPECULAR: "SPECULAR",
        EMISSIVE: "EMISSIVE",
        SHININESS: "SHININESS",
        UNKNOWN: "UNKNOWN",
        END: "\a\n\r"
    };
    /**@const*/ akra.DeclUsages = akra.DeclarationUsages;
    function /** @no-inline */VE_CUSTOM(sUsage, eType, iCount, iOffset) {
        if (typeof eType === "undefined") { eType = 5126 /* FLOAT */ ; }
        if (typeof iCount === "undefined") { iCount = 1; }
        return {
            count: iCount,
            type: eType,
            usage: sUsage,
            offset: iOffset
        };
    }
    akra.VE_CUSTOM = VE_CUSTOM;
    function /** @no-inline */VE_FLOAT(sName, iOffset) {
        return VE_CUSTOM(sName, 5126 /* FLOAT */ , 1, iOffset);
    }
    akra.VE_FLOAT = VE_FLOAT;
    ;
    function /** @no-inline */VE_FLOAT2(sName, iOffset) {
        if (typeof iOffset === "undefined") { iOffset = 2; }
        return VE_CUSTOM(sName, 5126 /* FLOAT */ , 2, iOffset);
    }
    akra.VE_FLOAT2 = VE_FLOAT2;
    ;
    function /** @no-inline */VE_FLOAT3(sName, iOffset) {
        if (typeof iOffset === "undefined") { iOffset = 3; }
        return VE_CUSTOM(sName, 5126 /* FLOAT */ , 3, iOffset);
    }
    akra.VE_FLOAT3 = VE_FLOAT3;
    ;
    function /** @no-inline */VE_FLOAT4(sName, iOffset) {
        if (typeof iOffset === "undefined") { iOffset = 4; }
        return VE_CUSTOM(sName, 5126 /* FLOAT */ , 4, iOffset);
    }
    akra.VE_FLOAT4 = VE_FLOAT4;
    ;
    function /** @no-inline */VE_FLOAT4x4(sName, iOffset) {
        if (typeof iOffset === "undefined") { iOffset = 16; }
        return VE_CUSTOM(sName, 5126 /* FLOAT */ , 16, iOffset);
    }
    akra.VE_FLOAT4x4 = VE_FLOAT4x4;
    ;
    function /** @no-inline */VE_VEC2(sName, iOffset) {
        if (typeof iOffset === "undefined") { iOffset = 2; }
        return VE_CUSTOM(sName, 5126 /* FLOAT */ , 2, iOffset);
    }
    akra.VE_VEC2 = VE_VEC2;
    ;
    function /** @no-inline */VE_VEC3(sName, iOffset) {
        if (typeof iOffset === "undefined") { iOffset = 3; }
        return VE_CUSTOM(sName, 5126 /* FLOAT */ , 3, iOffset);
    }
    akra.VE_VEC3 = VE_VEC3;
    ;
    function /** @no-inline */VE_VEC4(sName, iOffset) {
        if (typeof iOffset === "undefined") { iOffset = 4; }
        return VE_CUSTOM(sName, 5126 /* FLOAT */ , 4, iOffset);
    }
    akra.VE_VEC4 = VE_VEC4;
    ;
    function /** @no-inline */VE_MAT4(sName, iOffset) {
        if (typeof iOffset === "undefined") { iOffset = 16; }
        return VE_CUSTOM(sName, 5126 /* FLOAT */ , 16, iOffset);
    }
    akra.VE_MAT4 = VE_MAT4;
    ;
    function /** @no-inline */VE_INT(sName, iOffset) {
        return VE_CUSTOM(sName, 5124 /* INT */ , 1, iOffset);
    }
    akra.VE_INT = VE_INT;
    ;
    function /** @no-inline */VE_END(iOffset) {
        if (typeof iOffset === "undefined") { iOffset = 0; }
        return VE_CUSTOM(akra.DeclUsages.END, 5121 /* UNSIGNED_BYTE */ , 0, iOffset);
    }
    akra.VE_END = VE_END;
    ;
    akra.createVertexDeclaration;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (data) {
        var VertexElement = (function () {
            function /** @no-inline */VertexElement(nCount, eType, eUsage, //mark invalid offset, for determine true offset in VertexDeclaration::_update();
            iOffset) {
                if (typeof nCount === "undefined") { nCount = 1; }
                if (typeof eType === "undefined") { eType = 5126 /* FLOAT */ ; }
                if (typeof eUsage === "undefined") { eUsage = akra.DeclarationUsages.POSITION; }
                if (typeof iOffset === "undefined") { iOffset = akra.MAX_INT32; }
                // this properties is readonly for public usage.
                this.size = 0;
                this.index = 0;
                this.semantics = akra.DeclarationUsages.UNKNOWN;
                this.count = nCount;
                this.type = eType;
                this.usage = eUsage;
                this.offset = iOffset;
                this.update();
            }
            VertexElement.prototype.update = function /** @no-inline */() {
                this.size = this.count * akra.getTypeSize(this.type);
                this.index = 0;
                this.semantics = null;
                var pMatches = this.usage.match(/^(.*?\w)(\d+)$/i);
                if(!akra.isNull(pMatches)) {
                    this.semantics = pMatches[1];
                    this.index = parseInt(pMatches[2]);
                    // To avoid the colosseum between the "usage" of the element as POSITION & POSITION0,
                    // given that this is the same thing, here are the elements with index 0
                    // for "usage" with the POSITION.
                    if(this.index === 0) {
                        this.usage = this.semantics;
                    }
                } else {
                    this.semantics = this.usage;
                }
            };
            VertexElement.prototype.clone = function /** @no-inline */() {
                return new VertexElement(this.count, this.type, this.usage, this.offset);
            };
            VertexElement.hasUnknownOffset = function /** @inline */hasUnknownOffset(pElement) {
                return pElement.offset === akra.MAX_INT32;
            };
            VertexElement.prototype.toString = function /** @no-inline */() {
                function /** @no-inline */_an(data, n, bBackward) {
                    if (typeof bBackward === "undefined") { bBackward = false; }
                    var s = String(data);
                    for(var i = 0, t = n - s.length; i < t; ++i) {
                        if(bBackward) {
                            s = " " + s;
                        } else {
                            s += " ";
                        }
                    }
                    return s;
                }
                var s = "[ USAGE: " + _an(this.usage, 12) + ", OFFSET " + _an(this.offset, 4) + " ]";
                return s;
            };
            return VertexElement;
        })();
        data.VertexElement = VertexElement;        
    })(akra.data || (akra.data = {}));
    var data = akra.data;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.VertexElement = akra.VertexElement;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (data) {
        var VertexDeclaration = (function () {
            function /** @no-inline */VertexDeclaration(pElements) {
                //readonly property for public usage
                this.stride = 0;
                this._pElements = [];
                if(arguments.length > 0) {
                    this.append.apply(this, arguments);
                }
            }
            Object.defineProperty(VertexDeclaration.prototype, "length", {
                get: function /** @inline */() {
                    return this._pElements.length;
                },
                enumerable: true,
                configurable: true
            });
            VertexDeclaration.prototype.element = function /** @inline */(i) {
                return this._pElements[i] || null;
            };
            VertexDeclaration.prototype.append = function /** @no-inline */(pData) {
                var iOffset;
                var pElements;
                if(!akra.isArray(arguments[0])) {
                    pElements = arguments;
                } else {
                    pElements = arguments[0];
                }
                for(var i = 0; i < pElements.length; ++i) {
                    iOffset = pElements[i].offset;
                    if(data.VertexElement.hasUnknownOffset(pElements[i])) {
                        //calculation offset
                        if(i > 0) {
                            iOffset = this._pElements[i - 1].offset + this._pElements[i - 1].size;
                        } else {
                            iOffset = 0;
                        }
                    }
                    this._pElements.push(new data.VertexElement(pElements[i].count, pElements[i].type, pElements[i].usage, iOffset));
                }
                return this._update();
            };
            VertexDeclaration.prototype._update = function /** @no-inline */() {
                var iStride;
                for(var i = 0; i < this.length; ++i) {
                    //move "END" element to end of declaration
                    if(this._pElements[i].usage === akra.DeclUsages.END) {
                        this._pElements.swap(i, i + 1);
                    }
                    //recalc total stride
                    iStride = this._pElements[i].size + this._pElements[i].offset;
                    if(this.stride < iStride) {
                        this.stride = iStride;
                    }
                }
                var pLast = this._pElements.last;
                if(pLast.usage === akra.DeclUsages.END && pLast.offset < this.stride) {
                    pLast.offset = this.stride;
                }
                return true;
            };
            VertexDeclaration.prototype.extend = function /** @no-inline */(pDecl) {
                var pElement;
                for(var i = 0; i < this.length; ++i) {
                    for(var j = 0; j < pDecl.length; ++j) {
                        if(pDecl.element(j).usage == this._pElements[i].usage) {
                            akra.logger.setSourceLocation("data/VertexDeclaration.ts", 103);
                            akra.logger.log('inconsistent declarations:', this, pDecl);
                            ;
                            akra.logger.setSourceLocation("data/VertexDeclaration.ts", 104);
                            akra.logger.error('The attempt to combine the declaration containing the exact same semantics.');
                            ;
                            return false;
                        }
                    }
                }
                for(var i = 0; i < pDecl.length; i++) {
                    pElement = pDecl.element(i).clone();
                    pElement.offset += this.stride;
                    this._pElements.push(pElement);
                }
                return this._update();
            };
            VertexDeclaration.prototype.hasSemantics = function /** @inline */(sSemantics) {
                return this.findElement(sSemantics) !== null;
            };
            VertexDeclaration.prototype.findElement = function /** @no-inline */(sSemantics, iCount) {
                if (typeof iCount === "undefined") { iCount = akra.MAX_INT32; }
                sSemantics = sSemantics.toUpperCase();
                for(var i = 0; i < this.length; ++i) {
                    if(this._pElements[i].usage === sSemantics && (iCount === akra.MAX_INT32 || this._pElements[i].count == iCount)) {
                        return this._pElements[i];
                    }
                }
                return null;
            };
            VertexDeclaration.prototype.clone = function /** @no-inline */() {
                var pElements = [];
                var pDecl;
                for(var i = 0; i < this.length; ++i) {
                    pElements.push(this._pElements[i].clone());
                }
                pDecl = new VertexDeclaration(pElements);
                if(pDecl._update()) {
                    return pDecl;
                }
                return null;
            };
            VertexDeclaration.prototype.toString = ///DEBUG!!!
            function /** @no-inline */() {
                var s = "";
                s += "  VERTEX DECLARATION ( " + this.stride + " b. ) \n";
                s += "---------------------------------------\n";
                for(var i = 0; i < this.length; ++i) {
                    s += this._pElements[i].toString() + '\n';
                }
                return s;
            };
            return VertexDeclaration;
        })();
        data.VertexDeclaration = VertexDeclaration;        
    })(akra.data || (akra.data = {}));
    var data = akra.data;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.VertexDeclaration = akra.data.VertexDeclaration;
    akra.createVertexDeclaration = function /** @no-inline */(pData) {
        if(!(pData instanceof akra.VertexDeclaration)) {
            if(!(pData instanceof Array)) {
                pData = [
                    pData
                ];
            }
            pData = new akra.VertexDeclaration(pData);
        }
        return pData;
    };
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var Color = (function () {
            function /** @no-inline */Color(r, g, b, a) {
                this.set.apply(this, arguments);
            }
            Object.defineProperty(Color.prototype, "rgba", {
                get: function /** @no-inline */() {
                    var val32 = 0;
                    // Convert to 32bit pattern
                    val32 = (this.a * 255) << 24;
                    val32 += (this.b * 255) << 16;
                    val32 += (this.g * 255) << 8;
                    val32 += (this.r * 255);
                    return val32;
                },
                set: function /** @no-inline */(c) {
                    var val32 = c;
                    // Convert from 32bit pattern
                    this.a = ((val32 >> 24) & 0xFF) / 255.0;
                    this.b = ((val32 >> 16) & 0xFF) / 255.0;
                    this.g = ((val32 >> 8) & 0xFF) / 255.0;
                    this.r = (val32 & 0xFF) / 255.0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "argb", {
                get: function /** @no-inline */() {
                    var val32 = 0;
                    // Convert to 32bit pattern
                    val32 = (this.b * 255) << 24;
                    val32 += (this.g * 255) << 16;
                    val32 += (this.r * 255) << 8;
                    val32 += (this.a * 255);
                    return val32;
                },
                set: function /** @no-inline */(c) {
                    var val32 = c;
                    // Convert from 32bit pattern
                    this.b = ((val32 >> 24) & 0xFF) / 255.0;
                    this.g = ((val32 >> 16) & 0xFF) / 255.0;
                    this.r = ((val32 >> 8) & 0xFF) / 255.0;
                    this.a = (val32 & 0xFF) / 255.0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "bgra", {
                get: function /** @no-inline */() {
                    var val32 = 0;
                    // Convert to 32bit pattern
                    val32 = (this.a * 255) << 24;
                    val32 += (this.r * 255) << 16;
                    val32 += (this.g * 255) << 8;
                    val32 += (this.b * 255);
                    return val32;
                },
                set: function /** @no-inline */(c) {
                    var val32 = c;
                    // Convert from 32bit pattern
                    this.a = ((val32 >> 24) & 0xFF) / 255.0;
                    this.r = ((val32 >> 16) & 0xFF) / 255.0;
                    this.g = ((val32 >> 8) & 0xFF) / 255.0;
                    this.b = (val32 & 0xFF) / 255.0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "abgr", {
                get: function /** @no-inline */() {
                    var val32 = 0;
                    // Convert to 32bit pattern
                    val32 = (this.r * 255) << 24;
                    val32 += (this.g * 255) << 16;
                    val32 += (this.b * 255) << 8;
                    val32 += (this.a * 255);
                    return val32;
                },
                set: function /** @no-inline */(c) {
                    var val32 = c;
                    // Convert from 32bit pattern
                    this.r = ((val32 >> 24) & 0xFF) / 255.0;
                    this.g = ((val32 >> 16) & 0xFF) / 255.0;
                    this.b = ((val32 >> 8) & 0xFF) / 255.0;
                    this.a = (val32 & 0xFF) / 255.0;
                },
                enumerable: true,
                configurable: true
            });
            Color.prototype.set = function /** @no-inline */(r, g, b, a) {
                switch(arguments.length) {
                    case 0:
                        this.r = this.g = this.b = 0.;
                        this.a = 1.;
                        break;
                    case 1:
                        if(akra.isInt(arguments[0])) {
                            this.r = this.g = this.b = r;
                            this.a = 1.;
                        } else if(akra.isDef(arguments[0].buffer)) {
                            var c = arguments[0];
                            this.r = c[0];
                            this.g = c[1];
                            this.b = c[2];
                            this.a = c[3];
                        } else {
                            var v = arguments[0];
                            this.r = v.r;
                            this.g = v.g;
                            this.b = v.b;
                            this.a = v.a;
                        }
                        break;
                    case 2:
                        this.r = this.g = this.b = r;
                        this.a = g;
                        break;
                    case 3:
                    case 4:
                        this.r = r;
                        this.g = g;
                        this.b = b;
                        this.a = akra.isDef(a) ? a : 1.;
                        break;
                }
                return this;
            };
            Color.prototype.saturate = function /** @no-inline */() {
                if(this.r < 0.) {
                    this.r = 0.;
                } else if(this.r > 1.) {
                    this.r = 1.;
                }
                if(this.g < 0.) {
                    this.g = 0.;
                } else if(this.g > 1.) {
                    this.g = 1.;
                }
                if(this.b < 0.) {
                    this.b = 0.;
                } else if(this.b > 1.) {
                    this.b = 1.;
                }
                if(this.a < 0.) {
                    this.a = 0.;
                } else if(this.a > 1.) {
                    this.a = 1.;
                }
                return this;
            };
            Color.prototype.saturateCopy = /** As saturate, except that this colour value is unaffected and
            the saturated colour value is returned as a copy. */
            function /** @no-inline */() {
                var ret = new Color(this);
                ret.saturate();
                return ret;
            };
            Color.prototype.add = function /** @no-inline */(cColor, ppDest) {
                if (typeof ppDest === "undefined") { ppDest = new Color(); }
                ppDest.r = this.r + cColor.r;
                ppDest.g = this.g + cColor.g;
                ppDest.b = this.b + cColor.b;
                ppDest.a = this.a + cColor.a;
                return ppDest;
            };
            Color.prototype.subtract = function /** @no-inline */(cColor, ppDest) {
                if (typeof ppDest === "undefined") { ppDest = new Color(); }
                ppDest.r = this.r - cColor.r;
                ppDest.g = this.g - cColor.g;
                ppDest.b = this.b - cColor.b;
                ppDest.a = this.a - cColor.a;
                return ppDest;
            };
            Color.prototype.multiply = function /** @no-inline */(fScalar, ppDest) {
                if (typeof ppDest === "undefined") { ppDest = new Color(); }
                if(akra.isNumber(fScalar)) {
                    var f = fScalar;
                    ppDest.r = this.r * f;
                    ppDest.g = this.g * f;
                    ppDest.b = this.b * f;
                    ppDest.a = this.a * f;
                } else {
                    var c = arguments[0];
                    ppDest.r = this.r * c.r;
                    ppDest.g = this.g * c.g;
                    ppDest.b = this.b * c.b;
                    ppDest.a = this.a * c.a;
                }
                return ppDest;
            };
            Color.prototype.divide = function /** @no-inline */(fScalar, ppDest) {
                if (typeof ppDest === "undefined") { ppDest = new Color(); }
                if(akra.isNumber(fScalar)) {
                    var f = fScalar;
                    ppDest.r = this.r / f;
                    ppDest.g = this.g / f;
                    ppDest.b = this.b / f;
                    ppDest.a = this.a / f;
                } else {
                    var c = arguments[0];
                    ppDest.r = this.r / c.r;
                    ppDest.g = this.g / c.g;
                    ppDest.b = this.b / c.b;
                    ppDest.a = this.a / c.a;
                }
                return ppDest;
            };
            Color.prototype.setHSB = function /** @no-inline */(fHue, fSaturation, fBrightness) {
                // wrap hue
                if(fHue > 1.0) {
                    fHue -= fHue;
                } else if(fHue < 0.0) {
                    fHue += fHue + 1;
                }
                // clamp saturation / fBrightness
                fSaturation = akra.math.min(fSaturation, 1.0);
                fSaturation = akra.math.max(fSaturation, 0.0);
                fBrightness = akra.math.min(fBrightness, 1.0);
                fBrightness = akra.math.max(fBrightness, 0.0);
                if(fBrightness == 0.0) {
                    // early exit, this has to be black
                    this.r = this.g = this.b = 0.0;
                    return;
                }
                if(fSaturation == 0.0) {
                    // early exit, this has to be grey
                    this.r = this.g = this.b = fBrightness;
                    return;
                }
                var fHueDomain = fHue * 6.0;
                if(fHueDomain >= 6.0) {
                    // wrap around, and allow mathematical errors
                    fHueDomain = 0.0;
                }
                var domain = fHueDomain;
                var f1 = fBrightness * (1 - fSaturation);
                var f2 = fBrightness * (1 - fSaturation * (fHueDomain - domain));
                var f3 = fBrightness * (1 - fSaturation * (1 - (fHueDomain - domain)));
                switch(domain) {
                    case 0:
                        // red domain; green ascends
                        this.r = fBrightness;
                        this.g = f3;
                        this.b = f1;
                        break;
                    case 1:
                        // yellow domain; red descends
                        this.r = f2;
                        this.g = fBrightness;
                        this.b = f1;
                        break;
                    case 2:
                        // green domain; blue ascends
                        this.r = f1;
                        this.g = fBrightness;
                        this.b = f3;
                        break;
                    case 3:
                        // cyan domain; green descends
                        this.r = f1;
                        this.g = f2;
                        this.b = fBrightness;
                        break;
                    case 4:
                        // blue domain; red ascends
                        this.r = f3;
                        this.g = f1;
                        this.b = fBrightness;
                        break;
                    case 5:
                        // magenta domain; blue descends
                        this.r = fBrightness;
                        this.g = f1;
                        this.b = f2;
                        break;
                }
                return this;
            };
            Color.prototype.getHSB = function /** @no-inline */(pHsb) {
                if (typeof pHsb === "undefined") { pHsb = [
                    0., 
                    0., 
                    0.
                ]; }
                var vMin = akra.math.min(this.r, akra.math.min(this.g, this.b));
                var vMax = akra.math.max(this.r, akra.math.max(this.g, this.b));
                var delta = vMax - vMin;
                var brightness = vMax;
                var hue = 0.;
                var saturation;
                if(akra.math.isRealEqual(delta, 0.0, 1e-6)) {
                    // grey
                    hue = 0.;
                    saturation = 0.;
                } else {
                    // a colour
                    saturation = delta / vMax;
                    var deltaR = (((vMax - this.r) / 6.0) + (delta / 2.0)) / delta;
                    var deltaG = (((vMax - this.g) / 6.0) + (delta / 2.0)) / delta;
                    var deltaB = (((vMax - this.b) / 6.0) + (delta / 2.0)) / delta;
                    if(akra.math.isRealEqual(this.r, vMax)) {
                        hue = deltaB - deltaG;
                    } else if(akra.math.isRealEqual(this.g, vMax)) {
                        hue = 0.3333333 + deltaR - deltaB;
                    } else if(akra.math.isRealEqual(this.b, vMax)) {
                        hue = 0.6666667 + deltaG - deltaR;
                    }
                    if(hue < 0.0) {
                        hue += 1.0;
                    }
                    if(hue > 1.0) {
                        hue -= 1.0;
                    }
                }
                pHsb[0] = hue;
                pHsb[1] = saturation;
                pHsb[2] = brightness;
                return pHsb;
            };
            Color.toFloat32Array = function /** @no-inline */toFloat32Array(pValue) {
                var pArr = new Float32Array(4);
                pArr[0] = pValue.r;
                pArr[1] = pValue.g;
                pArr[2] = pValue.b;
                pArr[3] = pValue.a;
                return pArr;
            };
            Color.BLACK = new Color(0);
            Color.isEqual = function /** @no-inline */isEqual(c1, c2) {
                return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b && c1.a === c2.a;
            };
            return Color;
        })();
        util.Color = Color;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.Color = akra.util.Color;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (material) {
        var Material = (function () {
            function /** @no-inline */Material(sName, pMat) {
                if (typeof sName === "undefined") { sName = null; }
                this.name = null;
                this.diffuse = new akra.Color(.5);
                this.ambient = new akra.Color(.5);
                this.specular = new akra.Color(.5);
                this.emissive = new akra.Color(.5);
                this.shininess = 50.;
                this.name = sName;
                if(akra.isDefAndNotNull(pMat)) {
                    this.set(pMat);
                }
            }
            Material.prototype.set = function /** @no-inline */(pMat) {
                //this.name = pMat.name;
                this.diffuse.set(pMat.diffuse);
                this.ambient.set(pMat.ambient);
                this.specular.set(pMat.specular);
                this.emissive.set(pMat.emissive);
                this.shininess = pMat.shininess;
                return this;
            };
            Material.prototype.isEqual = function /** @no-inline */(pMat) {
                return akra.Color.isEqual(this.diffuse, pMat.diffuse) && akra.Color.isEqual(this.ambient, pMat.ambient) && akra.Color.isEqual(this.specular, pMat.specular) && akra.Color.isEqual(this.emissive, pMat.emissive) && this.shininess === pMat.shininess;
            };
            return Material;
        })();
        material.Material = Material;        
        var FlexMaterial = (function () {
            function /** @no-inline */FlexMaterial(sName, pData) {
                this.name = null;
                this._pData = pData;
                this.name = sName;
            }
            Object.defineProperty(FlexMaterial.prototype, "diffuse", {
                get: function /** @inline */() {
                    return new akra.Color(this._pData.getTypedData(akra.DeclUsages.DIFFUSE, 0, 1));
                },
                set: function /** @inline */(pValue) {
                    this._pData.setData(akra.Color.toFloat32Array(pValue), akra.DeclUsages.DIFFUSE);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(FlexMaterial.prototype, "ambient", {
                get: function /** @inline */() {
                    return new akra.Color(this._pData.getTypedData(akra.DeclUsages.AMBIENT, 0, 1));
                },
                set: function /** @inline */(pValue) {
                    this._pData.setData(akra.Color.toFloat32Array(pValue), akra.DeclUsages.AMBIENT);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(FlexMaterial.prototype, "specular", {
                get: function /** @inline */() {
                    return new akra.Color(this._pData.getTypedData(akra.DeclUsages.SPECULAR, 0, 1));
                },
                set: function /** @inline */(pValue) {
                    this._pData.setData(akra.Color.toFloat32Array(pValue), akra.DeclUsages.SPECULAR);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(FlexMaterial.prototype, "emissive", {
                get: function /** @inline */() {
                    return new akra.Color(this._pData.getTypedData(akra.DeclUsages.EMISSIVE, 0, 1));
                },
                set: function /** @inline */(pValue) {
                    this._pData.setData(akra.Color.toFloat32Array(pValue), akra.DeclUsages.EMISSIVE);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(FlexMaterial.prototype, "shininess", {
                get: function /** @inline */() {
                    return this._pData.getTypedData(akra.DeclUsages.SHININESS, 0, 1)[0];
                },
                set: function /** @inline */(pValue) {
                    this._pData.setData(new Float32Array([
                        pValue
                    ]), akra.DeclUsages.SHININESS);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(FlexMaterial.prototype, "data", {
                get: function /** @inline */() {
                    return this._pData;
                },
                enumerable: true,
                configurable: true
            });
            FlexMaterial.prototype.set = function /** @no-inline */(pMat) {
                //this.name =
                this.diffuse = pMat.diffuse;
                this.ambient = pMat.ambient;
                this.specular = pMat.specular;
                this.emissive = pMat.emissive;
                this.shininess = pMat.shininess;
                return this;
            };
            FlexMaterial.prototype.isEqual = function /** @no-inline */(pMat) {
                return akra.Color.isEqual(this.diffuse, pMat.diffuse) && akra.Color.isEqual(this.ambient, pMat.ambient) && akra.Color.isEqual(this.specular, pMat.specular) && akra.Color.isEqual(this.emissive, pMat.emissive) && this.shininess === pMat.shininess;
            };
            return FlexMaterial;
        })();        
        /**@const*/ material.VERTEX_DECL = akra.createVertexDeclaration([
            {
                count: 17,
                type: 5126 /* FLOAT */ ,
                usage: akra.DeclUsages.MATERIAL
            }, 
            {
                count: 4,
                type: 5126 /* FLOAT */ ,
                usage: akra.DeclUsages.DIFFUSE,
                offset: 0
            }, 
            {
                count: 4,
                type: 5126 /* FLOAT */ ,
                usage: akra.DeclUsages.AMBIENT
            }, 
            {
                count: 4,
                type: 5126 /* FLOAT */ ,
                usage: akra.DeclUsages.SPECULAR
            }, 
            {
                count: 4,
                type: 5126 /* FLOAT */ ,
                usage: akra.DeclUsages.EMISSIVE
            }, 
            {
                count: 1,
                type: 5126 /* FLOAT */ ,
                usage: akra.DeclUsages.SHININESS
            }
        ]);
        /**@const*/ material.DEFAULT = new Material();
        function /** @no-inline */create(sName, pMat) {
            if (typeof sName === "undefined") { sName = null; }
            if (typeof pMat === "undefined") { pMat = null; }
            return new Material(sName, pMat);
        }
        material.create = create;
        function /** @no-inline */_createFlex(sName, pData) {
            return new FlexMaterial(sName, pData);
        }
        material._createFlex = _createFlex;
    })(akra.material || (akra.material = {}));
    var material = akra.material;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.Material = akra.material.Material;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var SurfaceMaterial = (function (_super) {
                    __extends(SurfaceMaterial, _super);
                    function /** @no-inline */SurfaceMaterial() {
                                        _super.call(this);
                        /**@protected*/ this._pMaterial = new akra.Material();
                        /**@protected*/ this._nTotalTextures = 0;
                        /**@protected*/ this._iTextureFlags = 0;
                        /**@protected*/ this._iTextureMatrixFlags = 0;
                        /**@protected*/ this._pTextures = new Array(SurfaceMaterial.MAX_TEXTURES_PER_SURFACE);
                        /**@protected*/ this._pTexcoords = new Array(SurfaceMaterial.MAX_TEXTURES_PER_SURFACE);
                        /**@protected*/ this._pTextureMatrices = new Array(SurfaceMaterial.MAX_TEXTURES_PER_SURFACE);
                        for(var i = 0; i < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE; ++i) {
                            this._pTexcoords[i] = i;
                        }
                    }
                    Object.defineProperty(SurfaceMaterial.prototype, "totalTextures", {
                        get: function /** @inline */() {
                            return this._nTotalTextures;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SurfaceMaterial.prototype, "material", {
                        get: function /** @inline */() {
                            return this._pMaterial;
                        },
                        set: function /** @inline */(pMaterial) {
                            this._pMaterial.set(pMaterial);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SurfaceMaterial.prototype, "textureFlags", {
                        get: function /** @inline */() {
                            return this._iTextureFlags;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SurfaceMaterial.prototype, "textureMatrixFlags", {
                        get: function /** @inline */() {
                            return this._iTextureMatrixFlags;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    SurfaceMaterial.prototype.setTexture = function /** @no-inline */(iIndex, pTexture, iTexcoord) {
                        if (typeof iTexcoord === "undefined") { iTexcoord = 0; }
                        akra.logger.setSourceLocation("resources/SurfaceMaterial.ts", 40);
                        akra.logger.assert(iIndex < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE, "invalid texture slot");
                        ;
                        var pRmgr = this.getManager();
                        var pTexture = null;
                        this._pTexcoords[iIndex] = iTexcoord;
                        if(akra.isString(arguments[0])) {
                            pTexture = this._pTextures[iIndex];
                            if(pTexture) {
                                //realise first
                                if(pTexture.release() == 0) {
                                    this._pTextures[iIndex] = null;
                                    //pTexture.destroyResource();
                                                                    } else {
                                    akra.logger.setSourceLocation("resources/SurfaceMaterial.ts", 58);
                                    akra.logger.warning("cannot destroy resource...");
                                }
                                ((this._iTextureFlags) &= ~(1 << (iIndex)));
                                --this._nTotalTextures;
                            }
                            this._pTextures[iIndex] = pRmgr.texturePool.loadResource(arguments[0]);
                            if(this._pTextures[iIndex]) {
                                ((this._iTextureFlags) |= (1 << (iIndex)));
                                ++this._nTotalTextures;
                                this.sync(this._pTextures[iIndex], 1 /* LOADED */ );
                            }
                            return true;
                        } else if(arguments[0] instanceof resources.Texture) {
                            if(!this._pTextures[iIndex] || pTexture != this._pTextures[iIndex]) {
                                if(this._pTextures[iIndex]) {
                                    // realise first
                                    // DisplayManager.texturePool().releaseResource(this._pTextures[iIndex]);
                                    if(this._pTextures[iIndex].release() == 0) {
                                        // this._pTextureMatrices[iIndex].destroyResource();
                                        this._pTextures[iIndex] = null;
                                    } else {
                                        akra.logger.setSourceLocation("resources/SurfaceMaterial.ts", 89);
                                        akra.logger.warning("cannot destroy resource...");
                                        ;
                                    }
                                    ((this._iTextureFlags) &= ~(1 << (iIndex)));
                                    --this._nTotalTextures;
                                }
                                this._pTextures[iIndex] = pTexture;
                                this._pTextures[iIndex].addRef();
                                ((this._iTextureFlags) |= (1 << (iIndex)));
                                ++this._nTotalTextures;
                                this.sync(this._pTextures[iIndex], 1 /* LOADED */ );
                                // var me = this;
                                // trace('me get texture :)');
                                // pTexture.setChangesNotifyRoutine(function() {
                                //                 if (pTexture.isResourceLoaded()) {
                                //                     trace(arguments);
                                //                     trace('Texture <', pTexture.findResourceName(), '> loaded');
                                //                     if (me.isResourceLoaded()) {
                                //                         trace('Surface material loaded too.')
                                //                     }
                                //                 }
                                //             });
                                                            }
                            return true;
                        } else //similar to [cPoolHandle texture]
                        if(akra.isNumber(arguments[0])) {
                            if(!this._pTextures[iIndex] || this._pTextures[iIndex].resourceHandle != arguments[0]) {
                                if(this._pTextures[iIndex]) {
                                    //TheGameHost.displayManager().texturePool().releaseResource(m_pTextures[index]);
                                    if(this._pTextures[iIndex].release() === 0) {
                                        // this._pTextures[iIndex].destroyResource();
                                        this._pTextures[iIndex] = null;
                                    } else {
                                        akra.logger.setSourceLocation("resources/SurfaceMaterial.ts", 128);
                                        akra.logger.warning("cannot destroy resource...");
                                        ;
                                    }
                                    ((this._iTextureFlags) &= ~(1 << (iIndex)));
                                    --this._nTotalTextures;
                                }
                                this._pTextures[iIndex] = pRmgr.texturePool.getResource(arguments[0]);
                                if(this._pTextures[iIndex]) {
                                    ((this._iTextureFlags) |= (1 << (iIndex)));
                                    ++this._nTotalTextures;
                                    this.sync(this._pTextures[iIndex], 1 /* LOADED */ );
                                }
                            }
                            return true;
                        }
                        this._pTexcoords[iIndex] = iIndex;
                        return false;
                    };
                    SurfaceMaterial.prototype.setTextureMatrix = function /** @no-inline */(iIndex, m4fValue) {
                        akra.logger.setSourceLocation("resources/SurfaceMaterial.ts", 154);
                        akra.logger.assert(iIndex < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE, "invalid texture slot");
                        ;
                        if(!m4fValue) {
                            this._pTextureMatrices[iIndex] = new akra.Mat4();
                        } else {
                            this._pTextureMatrices[iIndex] = new akra.Mat4(m4fValue);
                        }
                        ((this._iTextureMatrixFlags) |= (1 << (iIndex)));
                        return true;
                    };
                    SurfaceMaterial.prototype.setMaterial = function /** @inline */(pMaterial) {
                        this._pMaterial.set(pMaterial);
                    };
                    SurfaceMaterial.prototype.isEqual = function /** @no-inline */(pSurfaceMaterial) {
                        if(this._nTotalTextures === pSurfaceMaterial.totalTextures && this._iTextureFlags === pSurfaceMaterial.textureFlags && this._iTextureMatrixFlags === pSurfaceMaterial.textureMatrixFlags) {
                            if((this._pMaterial && this._pMaterial.isEqual(pSurfaceMaterial.material)) || (pSurfaceMaterial.material === null)) {
                                for(var i = 0; i < this._pTextures.length; i++) {
                                    if(this._pTextures[i] !== pSurfaceMaterial.texture[i]) {
                                        return false;
                                    }
                                }
                                ;
                                for(var i = 0; i < this._pTextureMatrices.length; ++i) {
                                    for(var j = 0; j < this._pTextureMatrices[i].data.length; j++) {
                                        if(this._pTextureMatrices[i].data[j] !== pSurfaceMaterial.textureMatrix[i].data[j]) {
                                            return false;
                                        }
                                    }
                                    ;
                                }
                                return true;
                            }
                        }
                        return false;
                    };
                    SurfaceMaterial.prototype.texture = function /** @inline */(iSlot) {
                        akra.logger.setSourceLocation("resources/SurfaceMaterial.ts", 202);
                        akra.logger.assert((iSlot >= 0 && iSlot < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE), "invalid texture slot");
                        ;
                        return this._pTextures[iSlot];
                    };
                    SurfaceMaterial.prototype.texcoord = function /** @inline */(iSlot) {
                        akra.logger.setSourceLocation("resources/SurfaceMaterial.ts", 208);
                        akra.logger.assert((iSlot >= 0 && iSlot < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE), "invalid texture slot");
                        ;
                        return this._pTexcoords[iSlot];
                    };
                    SurfaceMaterial.prototype.textureMatrix = function /** @inline */(iSlot) {
                        akra.logger.setSourceLocation("resources/SurfaceMaterial.ts", 214);
                        akra.logger.assert((iSlot >= 0 && iSlot < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE), "invalid texture slot");
                        ;
                        return this._pTextureMatrices[iSlot];
                    };
                    SurfaceMaterial.MAX_TEXTURES_PER_SURFACE = 16;
                    return SurfaceMaterial;
                })(pool.ResourcePoolItem);
                resources.SurfaceMaterial = SurfaceMaterial;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var Effect = (function (_super) {
                    __extends(Effect, _super);
                    function Effect() {
                        _super.apply(this, arguments);

                    }
                    Effect.prototype.isEqual = function /** @no-inline */(pEffect) {
                        return false;
                    };
                    Effect.prototype.isReplicated = function /** @no-inline */() {
                        return false;
                    };
                    Effect.prototype.isMixid = function /** @no-inline */() {
                        return false;
                    };
                    Effect.prototype.isParameterUsed = function /** @no-inline */(pParam, iPass) {
                        return false;
                    };
                    Effect.prototype.create = function /** @no-inline */() {
                        return;
                    };
                    Effect.prototype.replicable = function /** @no-inline */(bValue) {
                        return;
                    };
                    Effect.prototype.miscible = function /** @no-inline */(bValue) {
                        return;
                    };
                    Effect.prototype.getComponent = function /** @no-inline */(i) {
                        return null;
                    };
                    Effect.prototype.addComponent = function /** @no-inline */(sComponent, nShift, isSet) {
                        return false;
                    };
                    Effect.prototype.delComponent = function /** @no-inline */(pComponent, nShift, isSet) {
                        return false;
                    };
                    Effect.prototype.findParameter = function /** @no-inline */(pParam, iPass) {
                        return null;
                    };
                    return Effect;
                })(pool.ResourcePoolItem);
                resources.Effect = Effect;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EPixelFormats) {
        EPixelFormats._map = [];
        /*Unknown pixel format.*/
        EPixelFormats.UNKNOWN = 0;
        /*8-bit pixel format, all bits luminance.*/
        EPixelFormats.L8 = 1;
        EPixelFormats.BYTE_L = EPixelFormats.L8;
        /*16-bit pixel format, all bits luminance.*/
        EPixelFormats.L16 = 2;
        EPixelFormats.SHORT_L = EPixelFormats.L16;
        /*8-bit pixel format, all bits alpha.*/
        EPixelFormats.A8 = 3;
        EPixelFormats.BYTE_A = EPixelFormats.A8;
        /*8-bit pixel format, 4 bits alpha, 4 bits luminance.*/
        EPixelFormats.A4L4 = 4;
        /*2 byte pixel format, 1 byte luminance, 1 byte alpha*/
        EPixelFormats.BYTE_LA = 5;
        /*16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.*/
        EPixelFormats.R5G6B5 = 6;
        /*16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.*/
        EPixelFormats.B5G6R5 = 7;
        /*8-bit pixel format, 2 bits blue, 3 bits green, 3 bits red.*/
        EPixelFormats.R3G3B2 = 31;
        /*16-bit pixel format, 4 bits for alpha, red, green and blue.*/
        EPixelFormats.A4R4G4B4 = 8;
        /*16-bit pixel format, 5 bits for blue, green, red and 1 for alpha.*/
        EPixelFormats.A1R5G5B5 = 9;
        /*24-bit pixel format, 8 bits for red, green and blue.*/
        EPixelFormats.R8G8B8 = 10;
        /*24-bit pixel format, 8 bits for blue, green and red.*/
        EPixelFormats.B8G8R8 = 11;
        /*32-bit pixel format, 8 bits for alpha, red, green and blue.*/
        EPixelFormats.A8R8G8B8 = 12;
        /*32-bit pixel format, 8 bits for blue, green, red and alpha.*/
        EPixelFormats.A8B8G8R8 = 13;
        /*32-bit pixel format, 8 bits for blue, green, red and alpha.*/
        EPixelFormats.B8G8R8A8 = 14;
        /*32-bit pixel format, 8 bits for red, green, blue and alpha.*/
        EPixelFormats.R8G8B8A8 = 28;
        /*32-bit pixel format, 8 bits for red, 8 bits for green, 8 bits for blue like A8R8G8B8, but alpha will get discarded*/
        EPixelFormats.X8R8G8B8 = 26;
        /*32-bit pixel format, 8 bits for blue, 8 bits for green, 8 bits for red like A8B8G8R8, but alpha will get discarded*/
        EPixelFormats.X8B8G8R8 = 27;
        /*3 byte pixel format, 1 byte for red, 1 byte for green, 1 byte for blue*/
        EPixelFormats.BYTE_RGB = EPixelFormats.R8G8B8;
        /*3 byte pixel format, 1 byte for blue, 1 byte for green, 1 byte for red*/
        EPixelFormats.BYTE_BGR = EPixelFormats.B8G8R8;
        /*4 byte pixel format, 1 byte for blue, 1 byte for green, 1 byte for red and one byte for alpha*/
        EPixelFormats.BYTE_BGRA = EPixelFormats.B8G8R8A8;
        /*4 byte pixel format, 1 byte for red, 1 byte for green, 1 byte for blue, and one byte for alpha*/
        EPixelFormats.BYTE_RGBA = EPixelFormats.R8G8B8A8;
        /*32-bit pixel format, 2 bits for alpha, 10 bits for red, green and blue.*/
        EPixelFormats.A2R10G10B10 = 15;
        /*32-bit pixel format, 10 bits for blue, green and red, 2 bits for alpha.*/
        EPixelFormats.A2B10G10R10 = 16;
        /*DDS (DirectDraw Surface) DXT1 format.*/
        EPixelFormats.DXT1 = 17;
        /*DDS (DirectDraw Surface) DXT2 format.*/
        EPixelFormats.DXT2 = 18;
        /*DDS (DirectDraw Surface) DXT3 format.*/
        EPixelFormats.DXT3 = 19;
        /*DDS (DirectDraw Surface) DXT4 format.*/
        EPixelFormats.DXT4 = 20;
        /*DDS (DirectDraw Surface) DXT5 format.*/
        EPixelFormats.DXT5 = 21;
        /*16-bit pixel format, 16 bits (float) for red*/
        EPixelFormats.FLOAT16_R = 32;
        /*48-bit pixel format, 16 bits (float) for red, 16 bits (float) for green, 16 bits (float) for blue*/
        EPixelFormats.FLOAT16_RGB = 22;
        /*64-bit pixel format, 16 bits (float) for red, 16 bits (float) for green, 16 bits (float) for blue, 16 bits (float) for alpha*/
        EPixelFormats.FLOAT16_RGBA = 23;
        /*32-bit pixel format, 32 bits (float) for red*/
        EPixelFormats.FLOAT32_R = 33;
        /*96-bit pixel format, 32 bits (float) for red, 32 bits (float) for green, 32 bits (float) for blue*/
        EPixelFormats.FLOAT32_RGB = 24;
        /*128-bit pixel format, 32 bits (float) for red, 32 bits (float) for green, 32 bits (float) for blue, 32 bits (float) for alpha*/
        EPixelFormats.FLOAT32_RGBA = 25;
        /*32-bit, 2-channel s10e5 floating point pixel format, 16-bit green, 16-bit red*/
        EPixelFormats.FLOAT16_GR = 35;
        /*64-bit, 2-channel floating point pixel format, 32-bit green, 32-bit red*/
        EPixelFormats.FLOAT32_GR = 36;
        /*Float Depth texture format*/
        EPixelFormats.DEPTH = 29;
        /*Byte Depth texture format */
        EPixelFormats.DEPTH_BYTE = 44;
        /*64-bit pixel format, 16 bits for red, green, blue and alpha*/
        EPixelFormats.SHORT_RGBA = 30;
        /*32-bit pixel format, 16-bit green, 16-bit red*/
        EPixelFormats.SHORT_GR = 34;
        /*48-bit pixel format, 16 bits for red, green and blue*/
        EPixelFormats.SHORT_RGB = 37;
        /*PVRTC (PowerVR) RGB 2 bpp.*/
        EPixelFormats.PVRTC_RGB2 = 38;
        /*PVRTC (PowerVR) RGBA 2 bpp.*/
        EPixelFormats.PVRTC_RGBA2 = 39;
        /*PVRTC (PowerVR) RGB 4 bpp.*/
        EPixelFormats.PVRTC_RGB4 = 40;
        /*PVRTC (PowerVR) RGBA 4 bpp.*/
        EPixelFormats.PVRTC_RGBA4 = 41;
        /*8-bit pixel format, all bits red.*/
        EPixelFormats.R8 = 42;
        /*16-bit pixel format, 8 bits red, 8 bits green.*/
        EPixelFormats.RG8 = 43;
        EPixelFormats.TOTAL = 45;
    })(akra.EPixelFormats || (akra.EPixelFormats = {}));
    var EPixelFormats = akra.EPixelFormats;
    ;
    /**
    * Flags defining some on/off properties of pixel formats
    */
    (function (EPixelFormatFlags) {
        EPixelFormatFlags._map = [];
        // This format has an alpha channel
        EPixelFormatFlags.HASALPHA = 0x00000001;
        // This format is compressed. This invalidates the values in elemBytes,
        // elemBits and the bit counts as these might not be fixed in a compressed format.
        EPixelFormatFlags.COMPRESSED = 0x00000002;
        // This is a floating point format
        EPixelFormatFlags.FLOAT = 0x00000004;
        // This is a depth format (for depth textures)
        EPixelFormatFlags.DEPTH = 0x00000008;
        // Format is in native endian. Generally true for the 16, 24 and 32 bits
        // formats which can be represented as machine integers.
        EPixelFormatFlags.NATIVEENDIAN = 0x00000010;
        // This is an intensity format instead of a RGB one. The luminance
        // replaces R,G and B. (but not A)
        EPixelFormatFlags.LUMINANCE = 0x00000020;
    })(akra.EPixelFormatFlags || (akra.EPixelFormatFlags = {}));
    var EPixelFormatFlags = akra.EPixelFormatFlags;
    /** Pixel component format */
    (function (EPixelComponentTypes) {
        EPixelComponentTypes._map = [];
        /*Byte per component (8 bit fixed 0.0..1.0)*/
        EPixelComponentTypes.BYTE = 0;
        /*Short per component (16 bit fixed 0.0..1.0))*/
        EPixelComponentTypes.SHORT = 1;
        /*16 bit float per component*/
        EPixelComponentTypes.FLOAT16 = 2;
        /*32 bit float per component*/
        EPixelComponentTypes.FLOAT32 = 3;
        /*Number of pixel types*/
        EPixelComponentTypes.COUNT = 4;
    })(akra.EPixelComponentTypes || (akra.EPixelComponentTypes = {}));
    var EPixelComponentTypes = akra.EPixelComponentTypes;
    ;
    (function (EFilters) {
        EFilters._map = [];
        EFilters._map[0] = "NEAREST";
        EFilters.NEAREST = 0;
        EFilters._map[1] = "LINEAR";
        EFilters.LINEAR = 1;
        EFilters._map[2] = "BILINEAR";
        EFilters.BILINEAR = 2;
        EFilters._map[3] = "BOX";
        EFilters.BOX = 3;
        EFilters._map[4] = "TRIANGLE";
        EFilters.TRIANGLE = 4;
        EFilters._map[5] = "BICUBIC";
        EFilters.BICUBIC = 5;
    })(akra.EFilters || (akra.EFilters = {}));
    var EFilters = akra.EFilters;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EImageFlags) {
        EImageFlags._map = [];
        EImageFlags.COMPRESSED = 0x00000001;
        EImageFlags.CUBEMAP = 0x00000002;
        EImageFlags.TEXTURE_3D = 0x00000004;
    })(akra.EImageFlags || (akra.EImageFlags = {}));
    var EImageFlags = akra.EImageFlags;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var Img = (function (_super) {
                    __extends(Img, _super);
                    function /** @no-inline */Img() {
                                        _super.call(this);
                        /**@protected*/ this._iWidth = 0;
                        /**@protected*/ this._iHeight = 0;
                        /**@protected*/ this._iDepth = 0;
                        /**@protected*/ this._nMipMaps = 0;
                        /**@protected*/ this._iFlags = 0;
                        /**@protected*/ this._eFormat = 0 /* UNKNOWN */ ;
                        /**@protected*/ this._pBuffer = null;
                    }
                    Object.defineProperty(Img.prototype, "byteLength", {
                        get: function /** @inline */() {
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Img.prototype, "width", {
                        get: function /** @inline */() {
                            return this._iWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Img.prototype, "height", {
                        get: function /** @inline */() {
                            return this._iHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Img.prototype, "depth", {
                        get: function /** @inline */() {
                            return this._iDepth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Img.prototype, "numFaces", {
                        get: function /** @inline */() {
                            if(this.hasFlag(2 /* CUBEMAP */ )) {
                                return 6;
                            }
                            return 1;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Img.prototype, "numMipMaps", {
                        get: function /** @inline */() {
                            return this._nMipMaps;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Img.prototype, "format", {
                        get: function /** @inline */() {
                            return this._eFormat;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Img.prototype.createResource = function /** @no-inline */() {
                        // innitialize the resource (called once)
                        akra.logger.setSourceLocation("resources/Img.ts", 61);
                        akra.logger.assert(!this.isResourceCreated(), "The resource has already been created.");
                        ;
                        // signal that the resource is now created,
                        // but has not been enabled
                        this.notifyCreated();
                        this.notifyDisabled();
                        return true;
                    };
                    Img.prototype.destroyResource = function /** @no-inline */() {
                        // destroy the resource
                        //
                        // we permit redundant calls to destroy, so there are no asserts here
                        //
                        if(this.isResourceCreated()) {
                            // disable the resource
                            this.disableResource();
                            this.freeMemory();
                            this.notifyUnloaded();
                            this.notifyDestroyed();
                            return (true);
                        }
                        return (false);
                    };
                    Img.prototype.restoreResource = function /** @no-inline */() {
                        akra.logger.setSourceLocation("resources/Img.ts", 93);
                        akra.logger.assert(this.isResourceCreated(), "The resource has not been created.");
                        ;
                        this.notifyRestored();
                        return true;
                    };
                    Img.prototype.disableResource = function /** @no-inline */() {
                        akra.logger.setSourceLocation("resources/Img.ts", 101);
                        akra.logger.assert(this.isResourceCreated(), "The resource has not been created.");
                        ;
                        this.notifyDisabled();
                        return true;
                    };
                    Img.prototype.loadResource = function /** @no-inline */(sFilename) {
                        return false;
                    };
                    Img.prototype.saveResource = function /** @no-inline */(sFilename) {
                        return false;
                    };
                    Img.prototype.create = function /** @no-inline */(iWidth, iHeight, iDepth, eFormat, iFlags) {
                        return false;
                    };
                    Img.prototype.freeMemory = function /** @no-inline */() {
                        this._iWidth = 0;
                        this._iHeight = 0;
                        this._iDepth = 0;
                        this._pBuffer = null;
                    };
                    Img.prototype.set = function /** @no-inline */(pSrc) {
                        this.freeMemory();
                        this._iWidth = pSrc.width;
                        this._iHeight = pSrc.height;
                        this._iDepth = pSrc.depth;
                        this._eFormat = pSrc.format;
                        this._iFlags = pSrc.getFlags();
                        this._iPixelSize = akra.math.ceil(pSrc.getBPP() / 8);
                        this._nMipMaps = pSrc.numMipMaps;
                        this._pBuffer = new Uint8Array(pSrc.getData());
                        return this;
                    };
                    Img.prototype.flipY = function /** @no-inline */(pDest) {
                        return this;
                    };
                    Img.prototype.flipX = function /** @no-inline */(pDest) {
                        return this;
                    };
                    Img.prototype.loadFromMemory = function /** @no-inline */(pData, iWidth, iHeight, iDepth, eFormat) {
                        return false;
                    };
                    Img.prototype.loadRawData = function /** @no-inline */(pData, iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps) {
                        return false;
                    };
                    Img.prototype.loadDynamicImage = function /** @no-inline */(pData, iWidth, iHeight, iDepth, eFormat, bAutoDelete, iNumFaces, iNumMipMaps) {
                        if (typeof bAutoDelete === "undefined") { bAutoDelete = false; }
                        if (typeof iNumFaces === "undefined") { iNumFaces = 1; }
                        if (typeof iNumMipMaps === "undefined") { iNumMipMaps = 0; }
                        return null;
                    };
                    Img.prototype.load = function /** @no-inline */(sFilename) {
                        return false;
                    };
                    Img.prototype.convert = function /** @no-inline */(eFormat) {
                        return false;
                    };
                    Img.prototype.getRawSpan = //Gets the physical width in bytes of each row of pixels.
                    function /** @no-inline */() {
                        return 0;
                    };
                    Img.prototype.getBPP = function /** @no-inline */() {
                        return 0;
                    };
                    Img.prototype.getFlags = function /** @no-inline */() {
                        return 0;
                    };
                    Img.prototype.getData = function /** @no-inline */() {
                        return null;
                    };
                    Img.prototype.hasFlag = function /** @no-inline */(eFlag) {
                        return false;
                    };
                    Img.prototype.hasAlpha = function /** @no-inline */() {
                        return false;
                    };
                    Img.prototype.isCompressed = function /** @no-inline */() {
                        return false;
                    };
                    Img.prototype.isLumiance = function /** @no-inline */() {
                        return false;
                    };
                    Img.prototype.getColorAt = function /** @no-inline */(pColor, x, y, z) {
                        return null;
                    };
                    Img.prototype.setColorAt = function /** @no-inline */(pColor, x, y, z) {
                    };
                    Img.prototype.getPixels = function /** @no-inline */(nFace, iMipMap) {
                        return null;
                    };
                    Img.prototype.scale = function /** @no-inline */(pDest, eFilter) {
                        return null;
                    };
                    Img.prototype.resize = function /** @no-inline */(iWidth, iHeight, eFilter) {
                        return null;
                    };
                    Img.prototype.generatePerlinNoise = function /** @no-inline */(fScale, iOctaves, fFalloff) {
                    };
                    Img.prototype.randomChannelNoise = function /** @no-inline */(iChannel, iMinRange, iMaxRange) {
                    };
                    return Img;
                })(pool.ResourcePoolItem);
                resources.Img = Img;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var Component = (function (_super) {
                    __extends(Component, _super);
                    function Component() {
                        _super.apply(this, arguments);

                    }
                    return Component;
                })(pool.ResourcePoolItem);
                resources.Component = Component;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    (function (ERenderDataTypes) {
        ERenderDataTypes._map = [];
        /*<! положить данные в текстуру, и больше ничего не делать.*/
        ERenderDataTypes.ISOLATED = 0;
        ERenderDataTypes._map[1] = "INDEXED";
        /*<! обычные даннае из текстуры, доступные по индексу.*/
        ERenderDataTypes.INDEXED = 1;
        ERenderDataTypes._map[2] = "I2I";
        /*<! данные по 2йному индексу.*/
        ERenderDataTypes.I2I = 2;
        ERenderDataTypes._map[3] = "DIRECT";
        /*<! непосредственно данные для атрибута.*/
        ERenderDataTypes.DIRECT = 3;
    })(akra.ERenderDataTypes || (akra.ERenderDataTypes = {}));
    var ERenderDataTypes = akra.ERenderDataTypes;
    ;
    (function (ERenderDataOptions) {
        ERenderDataOptions._map = [];
        /*<! использовать индекс на индекс упаковку данных*/
        ERenderDataOptions.ADVANCED_INDEX = (1 << (0x10));
        ERenderDataOptions.SINGLE_INDEX = (1 << (0x11));
        /*<! создать RenderData как классические данные, с данными только в аттрибутах, без использования видео буфферов.*/
        /*<! определяет, будет ли объект редерится*/
        ERenderDataOptions.RENDERABLE = (1 << (0x12));
    })(akra.ERenderDataOptions || (akra.ERenderDataOptions = {}));
    var ERenderDataOptions = akra.ERenderDataOptions;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EHardwareBufferFlags) {
        EHardwareBufferFlags._map = [];
        EHardwareBufferFlags.STATIC = 0x01;
        EHardwareBufferFlags.DYNAMIC = 0x02;
        EHardwareBufferFlags.STREAM = 0x80;
        EHardwareBufferFlags.READABLE = 0x04;
        EHardwareBufferFlags.BACKUP_COPY = 0x08;
        /** indicate, that buffer does not use GPU memory or other specific memory. */
        EHardwareBufferFlags.SOFTWARE = 0x10;
        /** Indicate, tha buffer uses specific data aligment */
        EHardwareBufferFlags.ALIGNMENT = 0x20;
        /** Indicates that the application will be refilling the contents
        of the buffer regularly (not just updating, but generating the
        contents from scratch), and therefore does not mind if the contents
        of the buffer are lost somehow and need to be recreated. This
        allows and additional level of optimisation on the buffer.
        This option only really makes sense when combined with
        DYNAMIC and without READING.
        */
        EHardwareBufferFlags.DISCARDABLE = 0x40;
        EHardwareBufferFlags.STATIC_READABLE = EHardwareBufferFlags.STATIC | EHardwareBufferFlags.READABLE;
        EHardwareBufferFlags.DYNAMIC_DISCARDABLE = EHardwareBufferFlags.DYNAMIC | EHardwareBufferFlags.DISCARDABLE;
    })(akra.EHardwareBufferFlags || (akra.EHardwareBufferFlags = {}));
    var EHardwareBufferFlags = akra.EHardwareBufferFlags;
    (function (ELockFlags) {
        ELockFlags._map = [];
        ELockFlags.READ = 0x01;
        ELockFlags.WRITE = 0x02;
        ELockFlags.DISCARD = 0x04;
        ELockFlags.NO_OVERWRITE = 0x08;
        ELockFlags.NORMAL = ELockFlags.READ | ELockFlags.WRITE;
    })(akra.ELockFlags || (akra.ELockFlags = {}));
    var ELockFlags = akra.ELockFlags;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    (function (EMeshOptions) {
        EMeshOptions._map = [];
        EMeshOptions.HB_READABLE = 4 /* READABLE */ ;
        EMeshOptions.RD_ADVANCED_INDEX = 65536 /* ADVANCED_INDEX */ ;
    })(akra.EMeshOptions || (akra.EMeshOptions = {}));
    var EMeshOptions = akra.EMeshOptions;
    ;
    (function (EMeshCloneOptions) {
        EMeshCloneOptions._map = [];
        /*<! copy only geometry*/
        EMeshCloneOptions.GEOMETRY_ONLY = 0x00;
        /*<! use shared geometry*/
        EMeshCloneOptions.SHARED_GEOMETRY = 0x01;
    })(akra.EMeshCloneOptions || (akra.EMeshCloneOptions = {}));
    var EMeshCloneOptions = akra.EMeshCloneOptions;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    ;
    (function (ERenderDataBufferOptions) {
        ERenderDataBufferOptions._map = [];
        ERenderDataBufferOptions.VB_READABLE = (1 << (8 /* BACKUP_COPY */ ));
        ERenderDataBufferOptions.RD_ADVANCED_INDEX = 65536 /* ADVANCED_INDEX */ ;
        ERenderDataBufferOptions.RD_SINGLE_INDEX = 131072 /* SINGLE_INDEX */ ;
        ERenderDataBufferOptions.RD_RENDERABLE = 262144 /* RENDERABLE */ ;
    })(akra.ERenderDataBufferOptions || (akra.ERenderDataBufferOptions = {}));
    var ERenderDataBufferOptions = akra.ERenderDataBufferOptions;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    (function (EEntityTypes) {
        EEntityTypes._map = [];
        EEntityTypes._map[0] = "UNKNOWN";
        EEntityTypes.UNKNOWN = 0;
        EEntityTypes._map[1] = "NODE";
        EEntityTypes.NODE = 1;
        EEntityTypes._map[2] = "JOINT";
        EEntityTypes.JOINT = 2;
        EEntityTypes._map[3] = "SCENE_NODE";
        EEntityTypes.SCENE_NODE = 3;
        EEntityTypes._map[4] = "CAMERA";
        EEntityTypes.CAMERA = 4;
        EEntityTypes.LIGHT_PROJECT = 37;
        EEntityTypes._map[38] = "LIGHT_OMNI_DIRECTIONAL";
        EEntityTypes.LIGHT_OMNI_DIRECTIONAL = 38;
        EEntityTypes.SCENE_OBJECT = 64;
        EEntityTypes._map[65] = "MODEL";
        EEntityTypes.MODEL = 65;
        EEntityTypes._map[66] = "TERRAIN_SECTION";
        EEntityTypes.TERRAIN_SECTION = 66;
        EEntityTypes._map[67] = "TEXT3D";
        EEntityTypes.TEXT3D = 67;
        EEntityTypes._map[68] = "SPRITE";
        EEntityTypes.SPRITE = 68;
        EEntityTypes._map[69] = "EMITTER";
        EEntityTypes.EMITTER = 69;
        EEntityTypes.OBJECTS_LIMIT = 128;
    })(akra.EEntityTypes || (akra.EEntityTypes = {}));
    var EEntityTypes = akra.EEntityTypes;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    (function (ENodeInheritance) {
        ENodeInheritance._map = [];
        //inheritance only position
        ENodeInheritance.POSITION = 0;
        ENodeInheritance._map[1] = "ROTSCALE";
        //inheritance rotation and scale only
        ENodeInheritance.ROTSCALE = 1;
        ENodeInheritance._map[2] = "ALL";
        //inheritance all
        ENodeInheritance.ALL = 2;
    })(akra.ENodeInheritance || (akra.ENodeInheritance = {}));
    var ENodeInheritance = akra.ENodeInheritance;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        (function (EEntityStates) {
            EEntityStates._map = [];
            //обновился ли сам узел?
            EEntityStates.k_Updated = 0x01;
            //есть ли среди потомков обновленные узлы
            EEntityStates.k_DescendantsUpdtated = 0x02;
            //если ли обновленные узлы среди братьев или их потомках
            EEntityStates.k_SiblingsUpdated = 0x04;
        })(util.EEntityStates || (util.EEntityStates = {}));
        var EEntityStates = util.EEntityStates;
        var Entity = (function (_super) {
            __extends(Entity, _super);
            function Entity() {
                _super.apply(this, arguments);

                /**@protected*/ this._sName = null;
                /**@protected*/ this._pParent = null;
                /**@protected*/ this._pSibling = null;
                /**@protected*/ this._pChild = null;
                /**@protected*/ this._eType = 0 /* UNKNOWN */ ;
                /**@protected*/ this._iStateFlags = 0;
                this._iGuid = eval("this._iGuid || akra.sid()");
                this._pUnicastSlotMap = null;
                this._pBroadcastSlotList = null;
            }
            Object.defineProperty(Entity.prototype, "name", {
                get: function /** @inline */() {
                    return this._sName;
                },
                set: function /** @inline */(sName) {
                    this._sName = sName;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Entity.prototype, "parent", {
                get: function /** @inline */() {
                    return this._pParent;
                },
                set: function /** @inline */(pParent) {
                    this.attachToParent(pParent);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Entity.prototype, "sibling", {
                get: function /** @inline */() {
                    return this._pSibling;
                },
                set: function /** @inline */(pSibling) {
                    this._pSibling = pSibling;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Entity.prototype, "child", {
                get: function /** @inline */() {
                    return this._pChild;
                },
                set: function /** @inline */(pChild) {
                    this._pChild = pChild;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Entity.prototype, "type", {
                get: function /** @inline */() {
                    return this._eType;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Entity.prototype, "depth", {
                get: function /** @no-inline */() {
                    var iDepth = -1;
                    for(var pEntity = this; pEntity; pEntity = pEntity.parent , ++iDepth) {
                    }
                    ;
                    return iDepth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Entity.prototype, "root", {
                get: function /** @no-inline */() {
                    for(var pEntity = this, iDepth = -1; pEntity.parent; pEntity = pEntity.parent , ++iDepth) {
                    }
                    ;
                    return pEntity;
                },
                enumerable: true,
                configurable: true
            });
            Entity.prototype.create = function /** @no-inline */() {
                return true;
            };
            Entity.prototype.destroy = function /** @no-inline */() {
                // destroy anything attached to this node
                //	destroySceneObject();
                // promote any children up to our parent
                this.promoteChildren();
                // now remove ourselves from our parent
                this.detachFromParent();
                // we should now be removed from the tree, and have no dependants
                util.logger.setSourceLocation("util/Entity.ts", 65);
                util.logger.assert(this.referenceCount() == 0, "Attempting to delete a scene node which is still in use");
                ;
                util.logger.setSourceLocation("util/Entity.ts", 66);
                util.logger.assert(this._pSibling == null, "Failure Destroying Node");
                ;
                util.logger.setSourceLocation("util/Entity.ts", 67);
                util.logger.assert(this._pChild == null, "Failure Destroying Node");
                ;
            };
            Entity.prototype.findEntity = function /** @no-inline */(sName) {
                var pEntity = null;
                if(this._sName === sName) {
                    return this;
                }
                if(this._pSibling) {
                    pEntity = this._pSibling.findEntity(sName);
                }
                if(pEntity == null && this._pChild) {
                    pEntity = this._pChild.findEntity(sName);
                }
                return pEntity;
            };
            Entity.prototype.explore = function /** @no-inline */(fn) {
                if(fn(this) === false) {
                    return;
                }
                if(this._pSibling) {
                    this._pSibling.explore(fn);
                }
                if(this._pChild) {
                    this._pChild.explore(fn);
                }
            };
            Entity.prototype.childOf = function /** @no-inline */(pParent) {
                for(var pEntity = this; pEntity; pEntity = pEntity.parent) {
                    if(pEntity.parent === pParent) {
                        return true;
                    }
                }
                return false;
            };
            Entity.prototype.siblingCount = /**
            * Returns the current number of siblings of this object.
            */
            function /** @no-inline */() {
                var iCount = 0;
                if(this._pParent) {
                    var pNextSibling = this._pParent.child;
                    if(pNextSibling) {
                        while(pNextSibling) {
                            pNextSibling = pNextSibling.sibling;
                            ++iCount;
                        }
                    }
                }
                return iCount;
            };
            Entity.prototype.childCount = /**
            * Returns the current number of children of this object
            */
            function /** @no-inline */() {
                var iCount = 0;
                var pNextChild = this.child;
                if(pNextChild) {
                    ++iCount;
                    while(pNextChild) {
                        pNextChild = pNextChild.sibling;
                        ++iCount;
                    }
                }
                return iCount;
            };
            Entity.prototype.isUpdated = function /** @inline */() {
                return ((this._iStateFlags & (1 << (1 /* k_Updated */ ))) != 0);
            };
            Entity.prototype.hasUpdatedSubNodes = function /** @inline */() {
                return ((this._iStateFlags & (1 << (2 /* k_DescendantsUpdtated */ ))) != 0);
            };
            Entity.prototype.recursiveUpdate = function /** @no-inline */() {
                // var bUpdated: bool = false;
                // update myself
                if(this.update()) {
                    ((this._iStateFlags) |= (1 /* k_Updated */ ));
                    // bUpdated = true;
                                    }
                // update my sibling
                if(this._pSibling && this._pSibling.recursiveUpdate()) {
                    ((this._iStateFlags) |= (4 /* k_SiblingsUpdated */ ));
                    // bUpdated = true;
                                    }
                // update my child
                if(this._pChild && this._pChild.recursiveUpdate()) {
                    ((this._iStateFlags) |= (2 /* k_DescendantsUpdtated */ ));
                    // bUpdated = true;
                                    }
                /*bUpdated*/
                /* */
                return (this._iStateFlags != 0);
            };
            Entity.prototype.recursivePreUpdate = function /** @no-inline */() {
                // clear the flags from the previous update
                this.prepareForUpdate();
                // update my sibling
                if(this._pSibling) {
                    this._pSibling.recursivePreUpdate();
                }
                // update my child
                if(this._pChild) {
                    this._pChild.recursivePreUpdate();
                }
            };
            Entity.prototype.prepareForUpdate = function /** @no-inline */() {
                //this._iStateFlags = 0;
                            };
            Entity.prototype.hasParent = /** Parent is not undef */
            function /** @inline */() {
                return akra.isDefAndNotNull(this._pParent);
            };
            Entity.prototype.hasChild = /** Child is not undef*/
            function /** @inline */() {
                return akra.isDefAndNotNull(this._pChild);
            };
            Entity.prototype.hasSibling = /** Sibling is not undef */
            function /** @inline */() {
                return akra.isDefAndNotNull(this._pSibling);
            };
            Entity.prototype.isASibling = /**
            * Checks to see if the provided item is a sibling of this object
            */
            function /** @no-inline */(pSibling) {
                if(!pSibling) {
                    return false;
                }
                // if the sibling we are looking for is me, or my FirstSibling, return true
                if(this == pSibling || this._pSibling == pSibling) {
                    return true;
                }
                // if we have a sibling, continue searching
                if(this._pSibling) {
                    return this._pSibling.isASibling(pSibling);
                }
                // it's not us, and we have no sibling to check. This is not a sibling of ours.
                return false;
            };
            Entity.prototype.isAChild = /** Checks to see if the provided item is a child of this object. (one branch depth only) */
            function /** @no-inline */(pChild) {
                if(!pChild) {
                    return (false);
                }
                // if the sibling we are looking for is my FirstChild return true
                if(this._pChild == pChild) {
                    return (true);
                }
                // if we have a child, continue searching
                if(this._pChild) {
                    return (this._pChild.isASibling(pChild));
                }
                // it's not us, and we have no child to check. This is not a sibling of ours.
                return (false);
            };
            Entity.prototype.isInFamily = /**
            * Checks to see if the provided item is a child or sibling of this object. If SearchEntireTree
            * is TRUE, the check is done recursivly through all siblings and children. SearchEntireTree
            * is FALSE by default.
            */
            function /** @no-inline */(pEntity, bSearchEntireTree) {
                if(!pEntity) {
                    return (false);
                }
                // if the model we are looking for is me or my immediate family, return true
                if(this == pEntity || this._pChild == pEntity || this._pSibling == pEntity) {
                    return (true);
                }
                // if not set to seach entire tree, just check my siblings and kids
                if(!bSearchEntireTree) {
                    if(this.isASibling(pEntity)) {
                        return (true);
                    }
                    if(this._pChild && this._pChild.isASibling(pEntity)) {
                        return (true);
                    }
                } else// seach entire Tree!!!
                 {
                    if(this._pSibling && this._pSibling.isInFamily(pEntity, bSearchEntireTree)) {
                        return (true);
                    }
                    if(this._pChild && this._pChild.isInFamily(pEntity, bSearchEntireTree)) {
                        return (true);
                    }
                }
                return (false);
            };
            Entity.prototype.addSibling = /**
            * Adds the provided ModelSpace object to the descendant list of this object. The provided
            * ModelSpace object is removed from any parent it may already belong to.
            */
            function /** @no-inline */(pSibling) {
                if(pSibling) {
                    // replace objects current sibling pointer with this new one
                    pSibling.sibling = this._pSibling;
                    this.sibling = pSibling;
                }
                return pSibling;
            };
            Entity.prototype.addChild = /**
            * Adds the provided ModelSpace object to the descendant list of this object. The provided
            * ModelSpace object is removed from any parent it may already belong to.
            */
            function /** @no-inline */(pChild) {
                if(pChild) {
                    // Replace the new child's sibling pointer with our old first child.
                    pChild.sibling = this._pChild;
                    // the new child becomes our first child pointer.
                    this._pChild = pChild;
                }
                return pChild;
            };
            Entity.prototype.removeChild = /**
            * Removes a specified child object from this parent object. If the child is not the
            * FirstChild of this object, all of the Children are searched to find the object to remove.
            */
            function /** @no-inline */(pChild) {
                if(this._pChild && pChild) {
                    if(this._pChild == pChild) {
                        this._pChild = pChild.sibling;
                        pChild.sibling = null;
                    } else {
                        var pTempNode = this._pChild;
                        // keep searching until we find the node who's sibling is our target
                        // or we reach the end of the sibling chain
                        while(pTempNode && (pTempNode.sibling != pChild)) {
                            pTempNode = pTempNode.sibling;
                        }
                        // if we found the proper item, set it's FirstSibling to be the FirstSibling of the child
                        // we are removing
                        if(pTempNode) {
                            pTempNode.sibling = pChild.sibling;
                            pChild.sibling = null;
                        }
                    }
                }
                return pChild;
            };
            Entity.prototype.removeAllChildren = /** Removes all Children from this parent object */
            function /** @no-inline */() {
                // keep removing children until end of chain is reached
                while(!akra.isNull(this._pChild)) {
                    var pNextSibling = this._pChild.sibling;
                    this._pChild.detachFromParent();
                    this._pChild = pNextSibling;
                }
            };
            Entity.prototype.attachToParent = /** Attaches this object ot a new parent. Same as calling the parent's addChild() routine. */
            function /** @no-inline */(pParent) {
                if(pParent != this._pParent) {
                    this.detachFromParent();
                    if(pParent) {
                        this._pParent = pParent;
                        this._pParent.addChild(this);
                        this._pParent.addRef();
                        this.attached();
                        return true;
                    }
                }
                return false;
            };
            Entity.prototype.detachFromParent = function /** @no-inline */() {
                // tell our current parent to release us
                if(this._pParent) {
                    this._pParent.removeChild(this);
                    //TODO: разобраться что за херня!!!!
                    if(this._pParent) {
                        this._pParent.release();
                    }
                    this._pParent = null;
                    // my world matrix is now my local matrix
                    this.detached();
                    return true;
                }
                return false;
            };
            Entity.prototype.promoteChildren = /**
            * Attaches this object's children to it's parent, promoting them up the tree
            */
            function /** @no-inline */() {
                // Do I have any children to promote?
                while(!akra.isNull(this._pChild)) {
                    var pNextSibling = this._pChild.sibling;
                    this._pChild.attachToParent(this._pParent);
                    this._pChild = pNextSibling;
                }
            };
            Entity.prototype.relocateChildren = function /** @no-inline */(pParent) {
                if(pParent != this) {
                    // Do I have any children to relocate?
                    while(!akra.isNull(this._pChild)) {
                        var pNextSibling = this._pChild.sibling;
                        this._pChild.attachToParent(pParent);
                        this._pChild = pNextSibling;
                    }
                }
            };
            Entity.prototype.update = function /** @no-inline */() {
                return false;
            };
            Entity.prototype.toString = function /** @no-inline */(isRecursive, iDepth) {
                if (typeof isRecursive === "undefined") { isRecursive = false; }
                if (typeof iDepth === "undefined") { iDepth = 0; }
                if(!isRecursive) {
                    return '<entity' + (this._sName ? ' ' + this._sName : "") + '>';
                }
                var pSibling = this.sibling;
                var pChild = this.child;
                var s = "";
                for(var i = 0; i < iDepth; ++i) {
                    s += ':  ';
                }
                s += '+----[depth: ' + this.depth + ']' + this.toString() + '\n';
                if(pChild) {
                    s += pChild.toString(true, iDepth + 1);
                }
                if(pSibling) {
                    s += pSibling.toString(true, iDepth);
                }
                return s;
            };
            Entity._pEventTable = new akra.events.EventTable();
            Entity.prototype.getEventTable = function /** @inline */() {
                return Entity._pEventTable;
            };
            Entity.prototype.getGuid = function /** @no-inline */() {
                return this._iGuid < 0 ? (this._iGuid = akra.sid()) : this._iGuid;
            };
            Entity.prototype.connect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            Entity.prototype.disconnect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            Entity.prototype.bind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType);
            };
            Entity.prototype.unbind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType);
            };
            Entity.prototype.attached = function /** @no-inline */() {
                var _recivier = this;
                this._pUnicastSlotMap = this._pUnicastSlotMap || this.getEventTable().findUnicastList(this._iGuid);
                var _unicast = (this._pUnicastSlotMap).attached;
                if(akra.isDef(_unicast)) {
                    _unicast.target ? _unicast.target[_unicast.callback](_recivier) : _unicast.listener(_recivier);
                }
            };
            Entity.prototype.detached = function /** @no-inline */() {
                var _recivier = this;
                this._pUnicastSlotMap = this._pUnicastSlotMap || this.getEventTable().findUnicastList(this._iGuid);
                var _unicast = (this._pUnicastSlotMap).detached;
                if(akra.isDef(_unicast)) {
                    _unicast.target ? _unicast.target[_unicast.callback](_recivier) : _unicast.listener(_recivier);
                }
            };
            return Entity;
        })(util.ReferenceCounter);
        util.Entity = Entity;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
;
var akra;
(function (akra) {
    (function (math) {
        var Vec2 = (function () {
            function /** @no-inline */Vec2(fValue1, fValue2) {
                this.x = 0.;
                this.y = 0.;
                var nArgumentsLength = arguments.length;
                var v2fVec = this;
                // if (<any>this === window || <any>this === akra || <any>this === akra.math) {
                //     v2fVec = Vec2.stack[Vec2.stackPosition ++];
                //     if(Vec2.stackPosition == Vec2.stackSize){
                //         Vec2.stackPosition = 0;
                //     }
                // }
                switch(nArgumentsLength) {
                    case 1:
                        v2fVec.set(arguments[0]);
                        break;
                    case 2:
                        v2fVec.set(arguments[0], arguments[1]);
                        break;
                    default:
                        v2fVec.x = v2fVec.y = 0.;
                        break;
                }
            }
            Object.defineProperty(Vec2.prototype, "xx", {
                get: function /** @no-inline */() {
                    return math.vec2(this.x, this.x);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.x = v2fVec.x;
                    this.x = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec2.prototype, "xy", {
                get: function /** @no-inline */() {
                    return math.vec2(this.x, this.y);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.x = v2fVec.x;
                    this.y = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec2.prototype, "yx", {
                get: function /** @no-inline */() {
                    return math.vec2(this.y, this.x);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.y = v2fVec.x;
                    this.x = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec2.prototype, "yy", {
                get: function /** @no-inline */() {
                    return math.vec2(this.y, this.y);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.y = v2fVec.x;
                    this.y = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Vec2.prototype.set = function /** @no-inline */(fValue1, fValue2) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 0:
                        this.x = this.y = 0.;
                        break;
                    case 1:
                        if(akra.isFloat(arguments[0])) {
                            this.x = this.y = arguments[0];
                        } else if(arguments[0] instanceof Vec2) {
                            var v2fVec = arguments[0];
                            this.x = v2fVec.x;
                            this.y = v2fVec.y;
                        } else {
                            var pArray = arguments[0];
                            this.x = pArray[0];
                            this.y = pArray[1];
                        }
                        break;
                    case 2:
                        this.x = arguments[0];
                        this.y = arguments[1];
                        break;
                }
                ;
                return this;
            };
            Vec2.prototype.clear = function /** @inline */() {
                this.x = this.y = 0.;
                return this;
            };
            Vec2.prototype.add = function /** @no-inline */(v2fVec, v2fDestination) {
                if(!akra.isDef(v2fDestination)) {
                    v2fDestination = this;
                }
                v2fDestination.x = this.x + v2fVec.x;
                v2fDestination.y = this.y + v2fVec.y;
                return v2fDestination;
            };
            Vec2.prototype.subtract = function /** @no-inline */(v2fVec, v2fDestination) {
                if(!akra.isDef(v2fDestination)) {
                    v2fDestination = this;
                }
                v2fDestination.x = this.x - v2fVec.x;
                v2fDestination.y = this.y - v2fVec.y;
                return v2fDestination;
            };
            Vec2.prototype.dot = function /** @inline */(v2fVec) {
                return this.x * v2fVec.x + this.y * v2fVec.y;
            };
            Vec2.prototype.isEqual = function /** @no-inline */(v2fVec, fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if(fEps === 0.) {
                    if(this.x != v2fVec.x || this.y != v2fVec.y) {
                        return false;
                    }
                } else {
                    if(math.abs(this.x - v2fVec.x) > fEps || math.abs(this.y - v2fVec.y) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Vec2.prototype.isClear = function /** @no-inline */(fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if(fEps === 0.) {
                    if(this.x != 0. || this.y != 0.) {
                        return false;
                    }
                } else {
                    if(math.abs(this.x) > fEps || math.abs(this.y) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Vec2.prototype.negate = function /** @no-inline */(v2fDestination) {
                if(!akra.isDef(v2fDestination)) {
                    v2fDestination = this;
                }
                v2fDestination.x = -this.x;
                v2fDestination.y = -this.y;
                return v2fDestination;
            };
            Vec2.prototype.scale = function /** @no-inline */(fScale, v2fDestination) {
                if(!akra.isDef(v2fDestination)) {
                    v2fDestination = this;
                }
                v2fDestination.x = this.x * fScale;
                v2fDestination.y = this.y * fScale;
                return v2fDestination;
            };
            Vec2.prototype.normalize = function /** @no-inline */(v2fDestination) {
                if(!akra.isDef(v2fDestination)) {
                    v2fDestination = this;
                }
                var x = this.x, y = this.y;
                var fLength = math.sqrt(x * x + y * y);
                if(fLength !== 0.) {
                    var fInvLength = 1. / fLength;
                    x *= fInvLength;
                    y *= fInvLength;
                }
                v2fDestination.x = x;
                v2fDestination.y = y;
                return v2fDestination;
            };
            Vec2.prototype.length = function /** @inline */() {
                var x = this.x, y = this.y;
                return math.sqrt(x * x + y * y);
            };
            Vec2.prototype.lengthSquare = function /** @inline */() {
                var x = this.x, y = this.y;
                return x * x + y * y;
            };
            Vec2.prototype.direction = function /** @no-inline */(v2fVec, v2fDestination) {
                if(!akra.isDef(v2fDestination)) {
                    v2fDestination = this;
                }
                var x = v2fVec.x - this.x;
                var y = v2fVec.y - this.y;
                var fLength = math.sqrt(x * x + y * y);
                if(fLength !== 0.) {
                    var fInvLength = 1. / fLength;
                    x *= fInvLength;
                    y *= fInvLength;
                }
                v2fDestination.x = x;
                v2fDestination.y = y;
                return v2fDestination;
            };
            Vec2.prototype.mix = function /** @no-inline */(v2fVec, fA, v2fDestination) {
                if(!akra.isDef(v2fDestination)) {
                    v2fDestination = this;
                }
                fA = math.clamp(fA, 0., 1.);
                var fA1 = 1. - fA;
                var fA2 = fA;
                v2fDestination.x = fA1 * this.x + fA2 * v2fVec.x;
                v2fDestination.y = fA1 * this.y + fA2 * v2fVec.y;
                return v2fDestination;
            };
            Vec2.prototype.toString = function /** @inline */() {
                return "[x: " + this.x + ", y: " + this.y + "]";
            };
            Object.defineProperty(Vec2, "stackCeil", {
                get: function /** @no-inline */() {
                    Vec2.stackPosition = Vec2.stackPosition === Vec2.stackSize - 1 ? 0 : Vec2.stackPosition;
                    return Vec2.stack[Vec2.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            Vec2.stackSize = 100;
            Vec2.stackPosition = 0;
            Vec2.stack = (function /** @no-inline */() {
                var pStack = new Array(Vec2.stackSize);
                for(var i = 0; i < Vec2.stackSize; i++) {
                    pStack[i] = new Vec2();
                }
                return pStack;
            })();
            return Vec2;
        })();
        math.Vec2 = Vec2;        
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
;
;
var akra;
(function (akra) {
    (function (math) {
        var Vec3 = (function () {
            function /** @no-inline */Vec3(fValue1, fValue2, fValue3) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 2:
                        this.set(arguments[0], arguments[1]);
                        break;
                    case 3:
                        this.set(arguments[0], arguments[1], arguments[2]);
                        break;
                    default:
                        this.x = this.y = this.z = 0.;
                        break;
                }
            }
            Object.defineProperty(Vec3.prototype, "xx", {
                get: function /** @no-inline */() {
                    return math.vec2(this.x, this.x);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.x = v2fVec.x;
                    this.x = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xy", {
                get: function /** @no-inline */() {
                    return math.vec2(this.x, this.y);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.x = v2fVec.x;
                    this.y = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xz", {
                get: function /** @no-inline */() {
                    return math.vec2(this.x, this.z);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.x = v2fVec.x;
                    this.z = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yx", {
                get: function /** @no-inline */() {
                    return math.vec2(this.y, this.x);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.y = v2fVec.x;
                    this.x = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yy", {
                get: function /** @no-inline */() {
                    return math.vec2(this.y, this.y);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.y = v2fVec.x;
                    this.y = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yz", {
                get: function /** @no-inline */() {
                    return math.vec2(this.y, this.z);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.y = v2fVec.x;
                    this.z = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zx", {
                get: function /** @no-inline */() {
                    return math.vec2(this.z, this.x);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.z = v2fVec.x;
                    this.x = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zy", {
                get: function /** @no-inline */() {
                    return math.vec2(this.z, this.y);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.z = v2fVec.x;
                    this.y = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zz", {
                get: function /** @no-inline */() {
                    return math.vec2(this.z, this.z);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.z = v2fVec.x;
                    this.z = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xxx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.x, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.x = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xxy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.x, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.x = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xxz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.x, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.x = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xyx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.y, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.y = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xyy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.y, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.y = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xyz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.y, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.y = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xzx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.z, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.z = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xzy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.z, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.z = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "xzz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.z, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.z = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yxx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.x, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.x = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yxy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.x, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.x = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yxz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.x, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.x = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yyx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.y, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.y = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yyy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.y, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.y = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yyz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.y, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.y = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yzx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.z, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.z = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yzy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.z, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.z = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "yzz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.z, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.z = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zxx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.x, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.x = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zxy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.x, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.x = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zxz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.x, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.x = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zyx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.y, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.y = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zyy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.y, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.y = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zyz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.y, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.y = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zzx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.z, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.z = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zzy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.z, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.z = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec3.prototype, "zzz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.z, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.z = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Vec3.prototype.set = function /** @no-inline */(fValue1, fValue2, fValue3) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 0:
                        this.x = this.y = this.z = 0.;
                        break;
                    case 1:
                        if(akra.isFloat(arguments[0])) {
                            this.x = this.y = this.z = arguments[0];
                        } else if(arguments[0] instanceof Vec3) {
                            var v3fVec = arguments[0];
                            this.x = v3fVec.x;
                            this.y = v3fVec.y;
                            this.z = v3fVec.z;
                        } else {
                            var pArray = arguments[0];
                            this.x = pArray[0];
                            this.y = pArray[1];
                            this.z = pArray[2];
                        }
                        break;
                    case 2:
                        if(akra.isFloat(arguments[0])) {
                            var fValue = arguments[0];
                            var v2fVec = arguments[1];
                            this.x = fValue;
                            this.y = v2fVec.x;
                            this.z = v2fVec.y;
                        } else {
                            var v2fVec = arguments[0];
                            var fValue = arguments[1];
                            this.x = v2fVec.x;
                            this.y = v2fVec.y;
                            this.z = fValue;
                        }
                        break;
                    case 3:
                        this.x = arguments[0];
                        this.y = arguments[1];
                        this.z = arguments[2];
                        break;
                }
                return this;
            };
            Vec3.prototype.clear = function /** @inline */() {
                this.x = this.y = this.z = 0.;
                return this;
            };
            Vec3.prototype.add = function /** @no-inline */(v3fVec, v3fDestination) {
                if(!akra.isDef(v3fDestination)) {
                    v3fDestination = this;
                }
                v3fDestination.x = this.x + v3fVec.x;
                v3fDestination.y = this.y + v3fVec.y;
                v3fDestination.z = this.z + v3fVec.z;
                return v3fDestination;
            };
            Vec3.prototype.subtract = function /** @no-inline */(v3fVec, v3fDestination) {
                if(!akra.isDef(v3fDestination)) {
                    v3fDestination = this;
                }
                v3fDestination.x = this.x - v3fVec.x;
                v3fDestination.y = this.y - v3fVec.y;
                v3fDestination.z = this.z - v3fVec.z;
                return v3fDestination;
            };
            Vec3.prototype.dot = function /** @inline */(v3fVec) {
                return this.x * v3fVec.x + this.y * v3fVec.y + this.z * v3fVec.z;
            };
            Vec3.prototype.cross = function /** @no-inline */(v3fVec, v3fDestination) {
                if(!akra.isDef(v3fDestination)) {
                    v3fDestination = this;
                }
                var x1 = this.x, y1 = this.y, z1 = this.z;
                var x2 = v3fVec.x, y2 = v3fVec.y, z2 = v3fVec.z;
                v3fDestination.x = y1 * z2 - z1 * y2;
                v3fDestination.y = z1 * x2 - x1 * z2;
                v3fDestination.z = x1 * y2 - y1 * x2;
                return v3fDestination;
            };
            Vec3.prototype.isEqual = function /** @no-inline */(v3fVec, fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if(fEps === 0.) {
                    if(this.x != v3fVec.x || this.y != v3fVec.y || this.z != v3fVec.z) {
                        return false;
                    }
                } else {
                    if(math.abs(this.x - v3fVec.x) > fEps || math.abs(this.y - v3fVec.y) > fEps || math.abs(this.z - v3fVec.z) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Vec3.prototype.isClear = function /** @no-inline */(fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if(fEps === 0.) {
                    if(this.x != 0. || this.y != 0. || this.z != 0.) {
                        return false;
                    }
                } else {
                    if(math.abs(this.x) > fEps || math.abs(this.y) > fEps || math.abs(this.z) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Vec3.prototype.negate = function /** @no-inline */(v3fDestination) {
                if(!akra.isDef(v3fDestination)) {
                    v3fDestination = this;
                }
                v3fDestination.x = -this.x;
                v3fDestination.y = -this.y;
                v3fDestination.z = -this.z;
                return v3fDestination;
            };
            Vec3.prototype.scale = function /** @no-inline */(fScale, v3fDestination) {
                if(!akra.isDef(v3fDestination)) {
                    v3fDestination = this;
                }
                if(akra.isNumber(arguments[0])) {
                    var fScale = arguments[0];
                    v3fDestination.x = this.x * fScale;
                    v3fDestination.y = this.y * fScale;
                    v3fDestination.z = this.z * fScale;
                } else {
                    var v3fScale = arguments[0];
                    v3fDestination.x = this.x * v3fScale.x;
                    v3fDestination.y = this.y * v3fScale.y;
                    v3fDestination.z = this.z * v3fScale.z;
                }
                return v3fDestination;
            };
            Vec3.prototype.normalize = function /** @no-inline */(v3fDestination) {
                if(!v3fDestination) {
                    v3fDestination = this;
                }
                var x = this.x, y = this.y, z = this.z;
                var fLength = math.sqrt(x * x + y * y + z * z);
                if(fLength !== 0.) {
                    var fInvLength = 1. / fLength;
                    x *= fInvLength;
                    y *= fInvLength;
                    z *= fInvLength;
                }
                v3fDestination.x = x;
                v3fDestination.y = y;
                v3fDestination.z = z;
                return v3fDestination;
            };
            Vec3.prototype.length = function /** @inline */() {
                var x = this.x, y = this.y, z = this.z;
                return math.sqrt(x * x + y * y + z * z);
            };
            Vec3.prototype.lengthSquare = function /** @inline */() {
                var x = this.x, y = this.y, z = this.z;
                return x * x + y * y + z * z;
            };
            Vec3.prototype.direction = function /** @no-inline */(v3fVec, v3fDestination) {
                if(!akra.isDef(v3fDestination)) {
                    v3fDestination = this;
                }
                var x = v3fVec.x - this.x;
                var y = v3fVec.y - this.y;
                var z = v3fVec.z - this.z;
                var fLength = math.sqrt(x * x + y * y + z * z);
                if(fLength !== 0.) {
                    var fInvLength = 1. / fLength;
                    x *= fInvLength;
                    y *= fInvLength;
                    z *= fInvLength;
                }
                v3fDestination.x = x;
                v3fDestination.y = y;
                v3fDestination.z = z;
                return v3fDestination;
            };
            Vec3.prototype.mix = function /** @no-inline */(v3fVec, fA, v3fDestination) {
                if(!akra.isDef(v3fDestination)) {
                    v3fDestination = this;
                }
                fA = math.clamp(fA, 0., 1.);
                var fA1 = 1. - fA;
                var fA2 = fA;
                v3fDestination.x = fA1 * this.x + fA2 * v3fVec.x;
                v3fDestination.y = fA1 * this.y + fA2 * v3fVec.y;
                v3fDestination.z = fA1 * this.z + fA2 * v3fVec.z;
                return v3fDestination;
            };
            Vec3.prototype.toString = function /** @inline */() {
                return "[x: " + this.x + " ,y: " + this.y + ", z: " + this.z + "]";
            };
            Vec3.prototype.toTranslationMatrix = function /** @no-inline */(m4fDestination) {
                if(!akra.isDef(m4fDestination)) {
                    m4fDestination = new math.Mat4(1.);
                } else {
                    m4fDestination.set(1.);
                }
                var pData = m4fDestination.data;
                pData[12] = this.x;
                pData[13] = this.y;
                pData[14] = this.z;
                return m4fDestination;
            };
            Vec3.prototype.vec3TransformCoord = function /** @no-inline */(m4fTransformation, v3fDestination) {
                if(!v3fDestination) {
                    v3fDestination = this;
                }
                var pData = m4fTransformation.data;
                var x = this.x;
                var y = this.y;
                var z = this.z;
                var w;
                x = pData[0] * x + pData[4] * y + pData[8] * z + pData[12];
                y = pData[1] * x + pData[5] * y + pData[9] * z + pData[13];
                z = pData[2] * x + pData[6] * y + pData[10] * z + pData[14];
                w = pData[2] * x + pData[7] * y + pData[11] * z + pData[15];
                var fInvW = 1. / w;
                v3fDestination.x = x * fInvW;
                v3fDestination.y = y * fInvW;
                v3fDestination.z = z * fInvW;
                return v3fDestination;
            };
            Object.defineProperty(Vec3, "stackCeil", {
                get: function /** @no-inline */() {
                    Vec3.stackPosition = Vec3.stackPosition === Vec3.stackSize - 1 ? 0 : Vec3.stackPosition;
                    return Vec3.stack[Vec3.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            Vec3.stackSize = 100;
            Vec3.stackPosition = 0;
            Vec3.stack = (function /** @no-inline */() {
                var pStack = new Array(Vec3.stackSize);
                for(var i = 0; i < Vec3.stackSize; i++) {
                    pStack[i] = new Vec3();
                }
                return pStack;
            })();
            return Vec3;
        })();
        math.Vec3 = Vec3;        
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (math) {
        var Vec4 = (function () {
            function /** @no-inline */Vec4(fValue1, fValue2, fValue3, fValue4) {
                var nArgumentsLength = arguments.length;
                var v4fVec = this;
                // if (<any>this === window || <any>this === akra || <any>this === akra.math) {
                //     v4fVec = Vec4.stack[Vec4.stackPosition ++];
                //     if(Vec4.stackPosition == Vec4.stackSize){
                //         Vec4.stackPosition = 0;
                //     }
                // }
                switch(nArgumentsLength) {
                    case 1:
                        v4fVec.set(arguments[0]);
                        break;
                    case 2:
                        v4fVec.set(arguments[0], arguments[1]);
                        break;
                    case 3:
                        v4fVec.set(arguments[0], arguments[1], arguments[2]);
                        break;
                    case 4:
                        v4fVec.set(arguments[0], arguments[1], arguments[2], arguments[3]);
                        break;
                    default:
                        v4fVec.x = v4fVec.y = v4fVec.z = v4fVec.w = 0.;
                        break;
                }
            }
            Object.defineProperty(Vec4.prototype, "xx", {
                get: function /** @no-inline */() {
                    return math.vec2(this.x, this.x);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.x = v2fVec.x;
                    this.x = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xy", {
                get: function /** @no-inline */() {
                    return math.vec2(this.x, this.y);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.x = v2fVec.x;
                    this.y = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xz", {
                get: function /** @no-inline */() {
                    return math.vec2(this.x, this.z);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.x = v2fVec.x;
                    this.z = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xw", {
                get: function /** @no-inline */() {
                    return math.vec2(this.x, this.w);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.x = v2fVec.x;
                    this.w = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yx", {
                get: function /** @no-inline */() {
                    return math.vec2(this.y, this.x);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.y = v2fVec.x;
                    this.x = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yy", {
                get: function /** @no-inline */() {
                    return math.vec2(this.y, this.y);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.y = v2fVec.x;
                    this.y = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yz", {
                get: function /** @no-inline */() {
                    return math.vec2(this.y, this.z);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.y = v2fVec.x;
                    this.z = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yw", {
                get: function /** @no-inline */() {
                    return math.vec2(this.y, this.w);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.y = v2fVec.x;
                    this.w = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zx", {
                get: function /** @no-inline */() {
                    return math.vec2(this.z, this.x);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.z = v2fVec.x;
                    this.x = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zy", {
                get: function /** @no-inline */() {
                    return math.vec2(this.z, this.y);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.z = v2fVec.x;
                    this.y = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zz", {
                get: function /** @no-inline */() {
                    return math.vec2(this.z, this.z);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.z = v2fVec.x;
                    this.z = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zw", {
                get: function /** @no-inline */() {
                    return math.vec2(this.z, this.w);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.z = v2fVec.x;
                    this.w = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wx", {
                get: function /** @no-inline */() {
                    return math.vec2(this.w, this.x);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.w = v2fVec.x;
                    this.x = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wy", {
                get: function /** @no-inline */() {
                    return math.vec2(this.w, this.y);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.w = v2fVec.x;
                    this.y = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wz", {
                get: function /** @no-inline */() {
                    return math.vec2(this.w, this.z);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.w = v2fVec.x;
                    this.z = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ww", {
                get: function /** @no-inline */() {
                    return math.vec2(this.w, this.w);
                },
                set: function /** @no-inline */(v2fVec) {
                    this.w = v2fVec.x;
                    this.w = v2fVec.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.x, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.x = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.x, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.x = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.x, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.x = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxw", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.x, this.w);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.x = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.y, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.y = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.y, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.y = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.y, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.y = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyw", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.y, this.w);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.y = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.z, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.z = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.z, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.z = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.z, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.z = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzw", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.z, this.w);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.z = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.w, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.w = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.w, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.w = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.w, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.w = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xww", {
                get: function /** @no-inline */() {
                    return math.vec3(this.x, this.w, this.w);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.x = v3fVec.x;
                    this.w = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.x, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.x = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.x, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.x = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.x, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.x = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxw", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.x, this.w);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.x = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.y, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.y = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.y, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.y = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.y, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.y = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyw", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.y, this.w);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.y = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.z, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.z = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.z, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.z = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.z, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.z = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzw", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.z, this.w);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.z = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.w, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.w = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.w, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.w = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.w, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.w = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yww", {
                get: function /** @no-inline */() {
                    return math.vec3(this.y, this.w, this.w);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.y = v3fVec.x;
                    this.w = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.x, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.x = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.x, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.x = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.x, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.x = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxw", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.x, this.w);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.x = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.y, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.y = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.y, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.y = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.y, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.y = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyw", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.y, this.w);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.y = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.z, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.z = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.z, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.z = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.z, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.z = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzw", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.z, this.w);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.z = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.w, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.w = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.w, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.w = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.w, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.w = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zww", {
                get: function /** @no-inline */() {
                    return math.vec3(this.z, this.w, this.w);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.z = v3fVec.x;
                    this.w = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.w, this.x, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.w = v3fVec.x;
                    this.x = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.w, this.x, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.w = v3fVec.x;
                    this.x = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.w, this.x, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.w = v3fVec.x;
                    this.x = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxw", {
                get: function /** @no-inline */() {
                    return math.vec3(this.w, this.x, this.w);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.w = v3fVec.x;
                    this.x = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.w, this.y, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.w = v3fVec.x;
                    this.y = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.w, this.y, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.w = v3fVec.x;
                    this.y = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.w, this.y, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.w = v3fVec.x;
                    this.y = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyw", {
                get: function /** @no-inline */() {
                    return math.vec3(this.w, this.y, this.w);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.w = v3fVec.x;
                    this.y = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.w, this.z, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.w = v3fVec.x;
                    this.z = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.w, this.z, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.w = v3fVec.x;
                    this.z = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.w, this.z, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.w = v3fVec.x;
                    this.z = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzw", {
                get: function /** @no-inline */() {
                    return math.vec3(this.w, this.z, this.w);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.w = v3fVec.x;
                    this.z = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwx", {
                get: function /** @no-inline */() {
                    return math.vec3(this.w, this.w, this.x);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.w = v3fVec.x;
                    this.w = v3fVec.y;
                    this.x = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwy", {
                get: function /** @no-inline */() {
                    return math.vec3(this.w, this.w, this.y);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.w = v3fVec.x;
                    this.w = v3fVec.y;
                    this.y = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwz", {
                get: function /** @no-inline */() {
                    return math.vec3(this.w, this.w, this.z);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.w = v3fVec.x;
                    this.w = v3fVec.y;
                    this.z = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "www", {
                get: function /** @no-inline */() {
                    return math.vec3(this.w, this.w, this.w);
                },
                set: function /** @no-inline */(v3fVec) {
                    this.w = v3fVec.x;
                    this.w = v3fVec.y;
                    this.w = v3fVec.z;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxxx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.x, this.x, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxxy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.x, this.x, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxxz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.x, this.x, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxxw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.x, this.x, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxyx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.x, this.y, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxyy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.x, this.y, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxyz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.x, this.y, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxyw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.x, this.y, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxzx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.x, this.z, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxzy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.x, this.z, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxzz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.x, this.z, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxzw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.x, this.z, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxwx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.x, this.w, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxwy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.x, this.w, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxwz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.x, this.w, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xxww", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.x, this.w, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyxx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.y, this.x, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyxy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.y, this.x, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyxz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.y, this.x, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyxw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.y, this.x, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyyx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.y, this.y, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyyy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.y, this.y, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyyz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.y, this.y, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyyw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.y, this.y, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyzx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.y, this.z, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyzy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.y, this.z, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyzz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.y, this.z, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyzw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.y, this.z, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xywx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.y, this.w, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xywy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.y, this.w, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xywz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.y, this.w, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xyww", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.y, this.w, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzxx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.z, this.x, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzxy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.z, this.x, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzxz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.z, this.x, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzxw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.z, this.x, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzyx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.z, this.y, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzyy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.z, this.y, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzyz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.z, this.y, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzyw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.z, this.y, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzzx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.z, this.z, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzzy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.z, this.z, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzzz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.z, this.z, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzzw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.z, this.z, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzwx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.z, this.w, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzwy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.z, this.w, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzwz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.z, this.w, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xzww", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.z, this.w, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwxx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.w, this.x, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwxy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.w, this.x, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwxz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.w, this.x, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwxw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.w, this.x, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwyx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.w, this.y, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwyy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.w, this.y, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwyz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.w, this.y, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwyw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.w, this.y, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwzx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.w, this.z, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwzy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.w, this.z, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwzz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.w, this.z, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwzw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.w, this.z, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwwx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.w, this.w, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwwy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.w, this.w, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwwz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.w, this.w, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "xwww", {
                get: function /** @no-inline */() {
                    return math.vec4(this.x, this.w, this.w, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.x = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxxx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.x, this.x, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxxy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.x, this.x, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxxz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.x, this.x, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxxw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.x, this.x, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxyx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.x, this.y, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxyy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.x, this.y, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxyz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.x, this.y, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxyw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.x, this.y, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxzx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.x, this.z, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxzy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.x, this.z, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxzz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.x, this.z, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxzw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.x, this.z, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxwx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.x, this.w, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxwy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.x, this.w, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxwz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.x, this.w, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yxww", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.x, this.w, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyxx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.y, this.x, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyxy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.y, this.x, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyxz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.y, this.x, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyxw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.y, this.x, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyyx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.y, this.y, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyyy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.y, this.y, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyyz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.y, this.y, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyyw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.y, this.y, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyzx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.y, this.z, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyzy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.y, this.z, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyzz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.y, this.z, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyzw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.y, this.z, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yywx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.y, this.w, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yywy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.y, this.w, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yywz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.y, this.w, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yyww", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.y, this.w, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzxx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.z, this.x, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzxy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.z, this.x, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzxz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.z, this.x, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzxw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.z, this.x, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzyx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.z, this.y, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzyy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.z, this.y, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzyz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.z, this.y, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzyw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.z, this.y, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzzx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.z, this.z, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzzy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.z, this.z, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzzz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.z, this.z, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzzw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.z, this.z, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzwx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.z, this.w, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzwy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.z, this.w, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzwz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.z, this.w, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "yzww", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.z, this.w, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywxx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.w, this.x, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywxy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.w, this.x, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywxz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.w, this.x, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywxw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.w, this.x, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywyx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.w, this.y, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywyy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.w, this.y, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywyz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.w, this.y, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywyw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.w, this.y, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywzx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.w, this.z, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywzy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.w, this.z, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywzz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.w, this.z, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywzw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.w, this.z, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywwx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.w, this.w, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywwy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.w, this.w, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywwz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.w, this.w, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "ywww", {
                get: function /** @no-inline */() {
                    return math.vec4(this.y, this.w, this.w, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.y = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxxx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.x, this.x, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxxy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.x, this.x, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxxz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.x, this.x, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxxw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.x, this.x, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxyx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.x, this.y, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxyy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.x, this.y, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxyz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.x, this.y, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxyw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.x, this.y, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxzx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.x, this.z, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxzy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.x, this.z, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxzz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.x, this.z, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxzw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.x, this.z, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxwx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.x, this.w, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxwy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.x, this.w, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxwz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.x, this.w, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zxww", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.x, this.w, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyxx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.y, this.x, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyxy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.y, this.x, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyxz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.y, this.x, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyxw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.y, this.x, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyyx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.y, this.y, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyyy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.y, this.y, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyyz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.y, this.y, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyyw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.y, this.y, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyzx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.y, this.z, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyzy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.y, this.z, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyzz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.y, this.z, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyzw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.y, this.z, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zywx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.y, this.w, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zywy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.y, this.w, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zywz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.y, this.w, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zyww", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.y, this.w, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzxx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.z, this.x, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzxy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.z, this.x, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzxz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.z, this.x, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzxw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.z, this.x, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzyx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.z, this.y, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzyy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.z, this.y, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzyz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.z, this.y, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzyw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.z, this.y, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzzx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.z, this.z, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzzy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.z, this.z, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzzz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.z, this.z, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzzw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.z, this.z, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzwx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.z, this.w, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzwy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.z, this.w, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzwz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.z, this.w, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zzww", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.z, this.w, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwxx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.w, this.x, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwxy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.w, this.x, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwxz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.w, this.x, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwxw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.w, this.x, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwyx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.w, this.y, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwyy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.w, this.y, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwyz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.w, this.y, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwyw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.w, this.y, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwzx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.w, this.z, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwzy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.w, this.z, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwzz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.w, this.z, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwzw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.w, this.z, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwwx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.w, this.w, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwwy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.w, this.w, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwwz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.w, this.w, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "zwww", {
                get: function /** @no-inline */() {
                    return math.vec4(this.z, this.w, this.w, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.z = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxxx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.x, this.x, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxxy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.x, this.x, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxxz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.x, this.x, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxxw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.x, this.x, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxyx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.x, this.y, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxyy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.x, this.y, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxyz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.x, this.y, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxyw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.x, this.y, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxzx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.x, this.z, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxzy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.x, this.z, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxzz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.x, this.z, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxzw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.x, this.z, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxwx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.x, this.w, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxwy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.x, this.w, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxwz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.x, this.w, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wxww", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.x, this.w, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.x = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyxx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.y, this.x, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyxy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.y, this.x, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyxz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.y, this.x, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyxw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.y, this.x, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyyx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.y, this.y, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyyy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.y, this.y, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyyz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.y, this.y, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyyw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.y, this.y, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyzx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.y, this.z, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyzy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.y, this.z, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyzz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.y, this.z, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyzw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.y, this.z, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wywx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.y, this.w, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wywy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.y, this.w, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wywz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.y, this.w, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wyww", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.y, this.w, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.y = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzxx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.z, this.x, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzxy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.z, this.x, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzxz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.z, this.x, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzxw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.z, this.x, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzyx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.z, this.y, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzyy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.z, this.y, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzyz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.z, this.y, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzyw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.z, this.y, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzzx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.z, this.z, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzzy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.z, this.z, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzzz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.z, this.z, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzzw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.z, this.z, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzwx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.z, this.w, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzwy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.z, this.w, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzwz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.z, this.w, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wzww", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.z, this.w, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.z = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwxx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.w, this.x, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwxy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.w, this.x, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwxz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.w, this.x, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwxw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.w, this.x, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.x = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwyx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.w, this.y, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwyy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.w, this.y, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwyz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.w, this.y, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwyw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.w, this.y, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.y = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwzx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.w, this.z, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwzy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.w, this.z, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwzz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.w, this.z, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwzw", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.w, this.z, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.z = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwwx", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.w, this.w, this.x);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.x = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwwy", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.w, this.w, this.y);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.y = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwwz", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.w, this.w, this.z);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.z = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Vec4.prototype, "wwww", {
                get: function /** @no-inline */() {
                    return math.vec4(this.w, this.w, this.w, this.w);
                },
                set: function /** @no-inline */(v4fVec) {
                    this.w = v4fVec.x;
                    this.w = v4fVec.y;
                    this.w = v4fVec.z;
                    this.w = v4fVec.w;
                },
                enumerable: true,
                configurable: true
            });
            Vec4.prototype.set = function /** @no-inline */(fValue1, fValue2, fValue3, fValue4) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 0:
                        this.x = this.y = this.z = this.w = 0.;
                        break;
                    case 1:
                        if(akra.isFloat(arguments[0])) {
                            this.x = this.y = this.z = this.w = arguments[0];
                        } else if(arguments[0] instanceof Vec4) {
                            var v4fVec = arguments[0];
                            this.x = v4fVec.x;
                            this.y = v4fVec.y;
                            this.z = v4fVec.z;
                            this.w = v4fVec.w;
                        } else //color
                        if(akra.isDef(arguments[0].r)) {
                            this.x = arguments[0].r;
                            this.y = arguments[0].g;
                            this.z = arguments[0].b;
                            this.w = arguments[0].a;
                        } else {
                            //array
                            var pArray = arguments[0];
                            this.x = pArray[0];
                            this.y = pArray[1];
                            this.z = pArray[2];
                            this.w = pArray[3];
                        }
                        break;
                    case 2:
                        if(akra.isFloat(arguments[0])) {
                            var fValue = arguments[0];
                            var v3fVec = arguments[1];
                            this.x = fValue;
                            this.y = v3fVec.x;
                            this.z = v3fVec.y;
                            this.w = v3fVec.z;
                        } else if(arguments[0] instanceof math.Vec2) {
                            var v2fVec1 = arguments[0];
                            var v2fVec2 = arguments[1];
                            this.x = v2fVec1.x;
                            this.y = v2fVec1.y;
                            this.z = v2fVec2.x;
                            this.w = v2fVec2.y;
                        } else {
                            var v3fVec = arguments[0];
                            var fValue = arguments[1];
                            this.x = v3fVec.x;
                            this.y = v3fVec.y;
                            this.z = v3fVec.z;
                            this.w = fValue;
                        }
                        break;
                    case 3:
                        if(akra.isFloat(arguments[0])) {
                            var fValue1 = arguments[0];
                            if(akra.isFloat(arguments[1])) {
                                var fValue2 = arguments[1];
                                var v2fVec = arguments[2];
                                this.x = fValue1;
                                this.y = fValue2;
                                this.z = v2fVec.x;
                                this.w = v2fVec.y;
                            } else {
                                var v2fVec = arguments[1];
                                var fValue2 = arguments[2];
                                this.x = fValue1;
                                this.y = v2fVec.x;
                                this.z = v2fVec.y;
                                this.w = fValue2;
                            }
                        } else {
                            var v2fVec = arguments[0];
                            var fValue1 = arguments[1];
                            var fValue2 = arguments[2];
                            this.x = v2fVec.x;
                            this.y = v2fVec.y;
                            this.z = fValue1;
                            this.w = fValue2;
                        }
                        break;
                    case 4:
                        this.x = arguments[0];
                        this.y = arguments[1];
                        this.z = arguments[2];
                        this.w = arguments[3];
                        break;
                }
                return this;
            };
            Vec4.prototype.clear = function /** @inline */() {
                this.x = this.y = this.z = this.w = 0.;
                return this;
            };
            Vec4.prototype.add = function /** @no-inline */(v4fVec, v4fDestination) {
                if(!akra.isDef(v4fDestination)) {
                    v4fDestination = this;
                }
                v4fDestination.x = this.x + v4fVec.x;
                v4fDestination.y = this.y + v4fVec.y;
                v4fDestination.z = this.z + v4fVec.z;
                v4fDestination.w = this.w + v4fVec.w;
                return v4fDestination;
            };
            Vec4.prototype.subtract = function /** @no-inline */(v4fVec, v4fDestination) {
                if(!akra.isDef(v4fDestination)) {
                    v4fDestination = this;
                }
                v4fDestination.x = this.x - v4fVec.x;
                v4fDestination.y = this.y - v4fVec.y;
                v4fDestination.z = this.z - v4fVec.z;
                v4fDestination.w = this.w - v4fVec.w;
                return v4fDestination;
            };
            Vec4.prototype.dot = function /** @inline */(v4fVec) {
                return this.x * v4fVec.x + this.y * v4fVec.y + this.z * v4fVec.z + this.w * v4fVec.w;
            };
            Vec4.prototype.isEqual = function /** @no-inline */(v4fVec, fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if(fEps === 0.) {
                    if(this.x != v4fVec.x || this.y != v4fVec.y || this.z != v4fVec.z || this.w != v4fVec.w) {
                        return false;
                    }
                } else {
                    if(math.abs(this.x - v4fVec.x) > fEps || math.abs(this.y - v4fVec.y) > fEps || math.abs(this.z - v4fVec.z) > fEps || math.abs(this.w - v4fVec.w) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Vec4.prototype.isClear = function /** @no-inline */(fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if(fEps === 0.) {
                    if(this.x != 0. || this.y != 0. || this.z != 0. || this.w != 0.) {
                        return false;
                    }
                } else {
                    if(math.abs(this.x) > fEps || math.abs(this.y) > fEps || math.abs(this.z) > fEps || math.abs(this.w) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Vec4.prototype.negate = function /** @no-inline */(v4fDestination) {
                if(!akra.isDef(v4fDestination)) {
                    v4fDestination = this;
                }
                v4fDestination.x = -this.x;
                v4fDestination.y = -this.y;
                v4fDestination.z = -this.z;
                v4fDestination.w = -this.w;
                return v4fDestination;
            };
            Vec4.prototype.scale = function /** @no-inline */(fScale, v4fDestination) {
                if(!akra.isDef(v4fDestination)) {
                    v4fDestination = this;
                }
                v4fDestination.x = this.x * fScale;
                v4fDestination.y = this.y * fScale;
                v4fDestination.z = this.z * fScale;
                v4fDestination.w = this.w * fScale;
                return v4fDestination;
            };
            Vec4.prototype.normalize = function /** @no-inline */(v4fDestination) {
                if(!akra.isDef(v4fDestination)) {
                    v4fDestination = this;
                }
                var x = this.x, y = this.y, z = this.z, w = this.w;
                var fLength = math.sqrt(x * x + y * y + z * z + w * w);
                if(fLength !== 0.) {
                    var fInvLength = 1. / fLength;
                    x *= fInvLength;
                    y *= fInvLength;
                    z *= fInvLength;
                    w *= fInvLength;
                }
                v4fDestination.x = x;
                v4fDestination.y = y;
                v4fDestination.z = z;
                v4fDestination.w = w;
                return v4fDestination;
            };
            Vec4.prototype.length = function /** @inline */() {
                var x = this.x, y = this.y, z = this.z, w = this.w;
                return math.sqrt(x * x + y * y + z * z + w * w);
            };
            Vec4.prototype.lengthSquare = function /** @inline */() {
                var x = this.x, y = this.y, z = this.z, w = this.w;
                return x * x + y * y + z * z + w * w;
            };
            Vec4.prototype.direction = function /** @no-inline */(v4fVec, v4fDestination) {
                if(!akra.isDef(v4fDestination)) {
                    v4fDestination = this;
                }
                var x = v4fVec.x - this.x;
                var y = v4fVec.y - this.y;
                var z = v4fVec.z - this.z;
                var w = v4fVec.w - this.w;
                var fLength = math.sqrt(x * x + y * y + z * z + w * w);
                if(fLength !== 0.) {
                    var fInvLength = 1. / fLength;
                    x *= fInvLength;
                    y *= fInvLength;
                    z *= fInvLength;
                    w *= fInvLength;
                }
                v4fDestination.x = x;
                v4fDestination.y = y;
                v4fDestination.z = z;
                v4fDestination.w = w;
                return v4fDestination;
            };
            Vec4.prototype.mix = function /** @no-inline */(v4fVec, fA, v4fDestination) {
                if(!akra.isDef(v4fDestination)) {
                    v4fDestination = this;
                }
                fA = math.clamp(fA, 0., 1.);
                var fA1 = 1. - fA;
                var fA2 = fA;
                v4fDestination.x = fA1 * this.x + fA2 * v4fVec.x;
                v4fDestination.y = fA1 * this.y + fA2 * v4fVec.y;
                v4fDestination.z = fA1 * this.z + fA2 * v4fVec.z;
                v4fDestination.w = fA1 * this.w + fA2 * v4fVec.w;
                return v4fDestination;
            };
            Vec4.prototype.toString = function /** @inline */() {
                return "[x: " + this.x + ", y: " + this.y + ", z: " + this.z + ", w: " + this.w + "]";
            };
            Object.defineProperty(Vec4, "stackCeil", {
                get: function /** @no-inline */() {
                    Vec4.stackPosition = Vec4.stackPosition === Vec4.stackSize - 1 ? 0 : Vec4.stackPosition;
                    return Vec4.stack[Vec4.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            Vec4.stackSize = 100;
            Vec4.stackPosition = 0;
            Vec4.stack = (function /** @no-inline */() {
                var pStack = new Array(Vec4.stackSize);
                for(var i = 0; i < Vec4.stackSize; i++) {
                    pStack[i] = new Vec4();
                }
                return pStack;
            })();
            return Vec4;
        })();
        math.Vec4 = Vec4;        
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
;
;
var akra;
(function (akra) {
    (function (math) {
        var Mat3 = (function () {
            function /** @no-inline */Mat3(fValue1, fValue2, fValue3, fValue4, fValue5, fValue6, fValue7, fValue8, fValue9) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 3:
                        this.set(arguments[0], arguments[1], arguments[2]);
                        break;
                    case 9:
                        this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]);
                        break;
                    default:
                        break;
                }
            }
            Mat3.prototype.set = function /** @no-inline */(fValue1, fValue2, fValue3, fValue4, fValue5, fValue6, fValue7, fValue8, fValue9) {
                this.data = this.data || new Float32Array(9);
                var pData = this.data;
                //без аргументов инициализируется нулями
                var nArgumentsLength = arguments.length;
                if(nArgumentsLength == 0) {
                    pData[0] = pData[3] = pData[6] = 0;
                    pData[1] = pData[4] = pData[7] = 0;
                    pData[2] = pData[5] = pData[8] = 0;
                }
                if(nArgumentsLength == 1) {
                    if(akra.isFloat(arguments[0])) {
                        var nValue = arguments[0];
                        pData[0] = nValue;
                        pData[3] = 0;
                        pData[6] = 0;
                        pData[1] = 0;
                        pData[4] = nValue;
                        pData[7] = 0;
                        pData[2] = 0;
                        pData[5] = 0;
                        pData[8] = nValue;
                    } else if(akra.isDef(arguments[0].data)) {
                        var pElements = arguments[0].data;
                        if(pElements.length === 9) {
                            //Mat3
                            pData[0] = pElements[0];
                            pData[3] = pElements[3];
                            pData[6] = pElements[6];
                            pData[1] = pElements[1];
                            pData[4] = pElements[4];
                            pData[7] = pElements[7];
                            pData[2] = pElements[2];
                            pData[5] = pElements[5];
                            pData[8] = pElements[8];
                        } else {
                            //Mat4
                            pData[0] = pElements[0];
                            pData[3] = pElements[4];
                            pData[6] = pElements[8];
                            pData[1] = pElements[1];
                            pData[4] = pElements[5];
                            pData[7] = pElements[9];
                            pData[2] = pElements[2];
                            pData[5] = pElements[6];
                            pData[8] = pElements[10];
                        }
                    } else if(arguments[0] instanceof math.Vec3) {
                        var v3fVec = arguments[0];
                        //диагональ
                        pData[0] = v3fVec.x;
                        pData[3] = 0;
                        pData[6] = 0;
                        pData[1] = 0;
                        pData[4] = v3fVec.y;
                        pData[7] = 0;
                        pData[2] = 0;
                        pData[5] = 0;
                        pData[8] = v3fVec.z;
                    } else {
                        var pElements = arguments[0];
                        if(pElements.length == 3) {
                            //ложим диагональ
                            pData[0] = pElements[0];
                            pData[3] = 0;
                            pData[6] = 0;
                            pData[1] = 0;
                            pData[4] = pElements[1];
                            pData[7] = 0;
                            pData[2] = 0;
                            pData[5] = 0;
                            pData[8] = pElements[2];
                        } else {
                            pData[0] = pElements[0];
                            pData[3] = pElements[3];
                            pData[6] = pElements[6];
                            pData[1] = pElements[1];
                            pData[4] = pElements[4];
                            pData[7] = pElements[7];
                            pData[2] = pElements[2];
                            pData[5] = pElements[5];
                            pData[8] = pElements[8];
                        }
                    }
                } else if(nArgumentsLength == 3) {
                    if(akra.isFloat(arguments[0])) {
                        //выставляем диагональ
                        pData[0] = arguments[0];
                        pData[3] = 0;
                        pData[6] = 0;
                        pData[1] = 0;
                        pData[4] = arguments[1];
                        pData[7] = 0;
                        pData[2] = 0;
                        pData[5] = 0;
                        pData[8] = arguments[2];
                    } else {
                        var pData1, pData2, pData3;
                        if(arguments[0] instanceof math.Vec3) {
                            var v3fVec1 = arguments[0];
                            var v3fVec2 = arguments[1];
                            var v3fVec3 = arguments[2];
                            //ложим по столбцам
                            pData[0] = v3fVec1.x;
                            pData[3] = v3fVec2.x;
                            pData[6] = v3fVec3.x;
                            pData[1] = v3fVec1.y;
                            pData[4] = v3fVec2.y;
                            pData[7] = v3fVec3.y;
                            pData[2] = v3fVec1.z;
                            pData[5] = v3fVec2.z;
                            pData[8] = v3fVec3.z;
                        } else {
                            var v3fVec1 = arguments[0];
                            var v3fVec2 = arguments[1];
                            var v3fVec3 = arguments[2];
                            //ложим по столбцам
                            pData[0] = v3fVec1[0];
                            pData[3] = v3fVec2[0];
                            pData[6] = v3fVec3[0];
                            pData[1] = v3fVec1[1];
                            pData[4] = v3fVec2[1];
                            pData[7] = v3fVec3[1];
                            pData[2] = v3fVec1[2];
                            pData[5] = v3fVec2[2];
                            pData[8] = v3fVec3[2];
                        }
                    }
                } else if(nArgumentsLength == 9) {
                    //просто числа
                    pData[0] = arguments[0];
                    pData[3] = arguments[3];
                    pData[6] = arguments[6];
                    pData[1] = arguments[1];
                    pData[4] = arguments[4];
                    pData[7] = arguments[7];
                    pData[2] = arguments[2];
                    pData[5] = arguments[5];
                    pData[8] = arguments[8];
                }
                return this;
            };
            Mat3.prototype.identity = function /** @no-inline */() {
                var pData = this.data;
                pData[0] = 1.;
                pData[3] = 0.;
                pData[6] = 0.;
                pData[1] = 0.;
                pData[4] = 1.;
                pData[7] = 0.;
                pData[2] = 0.;
                pData[5] = 0.;
                pData[8] = 1.;
                return this;
            };
            Mat3.prototype.add = function /** @no-inline */(m3fMat, m3fDestination) {
                if(!akra.isDef(m3fDestination)) {
                    m3fDestination = this;
                }
                var pData1 = this.data;
                var pData2 = m3fMat.data;
                var pDataDestination = m3fDestination.data;
                pDataDestination[0] = pData1[0] + pData2[0];
                pDataDestination[3] = pData1[3] + pData2[3];
                pDataDestination[6] = pData1[6] + pData2[6];
                pDataDestination[1] = pData1[1] + pData2[1];
                pDataDestination[4] = pData1[4] + pData2[4];
                pDataDestination[7] = pData1[7] + pData2[7];
                pDataDestination[2] = pData1[2] + pData2[2];
                pDataDestination[5] = pData1[5] + pData2[5];
                pDataDestination[8] = pData1[8] + pData2[8];
                return m3fDestination;
            };
            Mat3.prototype.subtract = function /** @no-inline */(m3fMat, m3fDestination) {
                if(!akra.isDef(m3fDestination)) {
                    m3fDestination = this;
                }
                var pData1 = this.data;
                var pData2 = m3fMat.data;
                var pDataDestination = m3fDestination.data;
                pDataDestination[0] = pData1[0] - pData2[0];
                pDataDestination[3] = pData1[3] - pData2[3];
                pDataDestination[6] = pData1[6] - pData2[6];
                pDataDestination[1] = pData1[1] - pData2[1];
                pDataDestination[4] = pData1[4] - pData2[4];
                pDataDestination[7] = pData1[7] - pData2[7];
                pDataDestination[2] = pData1[2] - pData2[2];
                pDataDestination[5] = pData1[5] - pData2[5];
                pDataDestination[8] = pData1[8] - pData2[8];
                return m3fDestination;
            };
            Mat3.prototype.multiply = function /** @no-inline */(m3fMat, m3fDestination) {
                var pData1 = this.data;
                var pData2 = m3fMat.data;
                if(!akra.isDef(m3fDestination)) {
                    m3fDestination = this;
                }
                var pDataDestination = m3fDestination.data;
                // Cache the matrix values (makes for huge speed increases!)
                                var a11 = pData1[0], a12 = pData1[3], a13 = pData1[6];
                var a21 = pData1[1], a22 = pData1[4], a23 = pData1[7];
                var a31 = pData1[2], a32 = pData1[5], a33 = pData1[8];
                var b11 = pData2[0], b12 = pData2[3], b13 = pData2[6];
                var b21 = pData2[1], b22 = pData2[4], b23 = pData2[7];
                var b31 = pData2[2], b32 = pData2[5], b33 = pData2[8];
                pDataDestination[0] = a11 * b11 + a12 * b21 + a13 * b31;
                pDataDestination[3] = a11 * b12 + a12 * b22 + a13 * b32;
                pDataDestination[6] = a11 * b13 + a12 * b23 + a13 * b33;
                pDataDestination[1] = a21 * b11 + a22 * b21 + a23 * b31;
                pDataDestination[4] = a21 * b12 + a22 * b22 + a23 * b32;
                pDataDestination[7] = a21 * b13 + a22 * b23 + a23 * b33;
                pDataDestination[2] = a31 * b11 + a32 * b21 + a33 * b31;
                pDataDestination[5] = a31 * b12 + a32 * b22 + a33 * b32;
                pDataDestination[8] = a31 * b13 + a32 * b23 + a33 * b33;
                return m3fDestination;
            };
            Mat3.prototype.multiplyVec3 = function /** @no-inline */(v3fVec, v3fDestination) {
                var pData = this.data;
                if(!akra.isDef(v3fDestination)) {
                    v3fDestination = v3fVec;
                }
                var x = v3fVec.x, y = v3fVec.y, z = v3fVec.z;
                v3fDestination.x = pData[0] * x + pData[3] * y + pData[6] * z;
                v3fDestination.y = pData[1] * x + pData[4] * y + pData[7] * z;
                v3fDestination.z = pData[2] * x + pData[5] * y + pData[8] * z;
                return v3fDestination;
            };
            Mat3.prototype.transpose = function /** @no-inline */(m3fDestination) {
                var pData = this.data;
                if(!akra.isDef(m3fDestination)) {
                    //быстрее будет явно обработать оба случая
                                        var a12 = pData[3], a13 = pData[6], a23 = pData[7];
                    pData[3] = pData[1];
                    pData[6] = pData[2];
                    pData[1] = a12;
                    pData[7] = pData[5];
                    pData[2] = a13;
                    pData[5] = a23;
                    return this;
                }
                var pDataDestination = m3fDestination.data;
                pDataDestination[0] = pData[0];
                pDataDestination[3] = pData[1];
                pDataDestination[6] = pData[2];
                pDataDestination[1] = pData[3];
                pDataDestination[4] = pData[4];
                pDataDestination[7] = pData[5];
                pDataDestination[2] = pData[6];
                pDataDestination[5] = pData[7];
                pDataDestination[8] = pData[8];
                return m3fDestination;
            };
            Mat3.prototype.determinant = function /** @no-inline */() {
                var pData = this.data;
                var a11 = pData[0], a12 = pData[3], a13 = pData[6];
                var a21 = pData[1], a22 = pData[4], a23 = pData[7];
                var a31 = pData[2], a32 = pData[5], a33 = pData[8];
                return a11 * (a22 * a33 - a23 * a32) - a12 * (a21 * a33 - a23 * a31) + a13 * (a21 * a32 - a22 * a31);
            };
            Mat3.prototype.inverse = function /** @no-inline */(m3fDestination) {
                if(!akra.isDef(m3fDestination)) {
                    m3fDestination = this;
                }
                var pData = this.data;
                var pDataDestination = m3fDestination.data;
                var a11 = pData[0], a12 = pData[3], a13 = pData[6];
                var a21 = pData[1], a22 = pData[4], a23 = pData[7];
                var a31 = pData[2], a32 = pData[5], a33 = pData[8];
                var A11 = a22 * a33 - a23 * a32;
                var A12 = a21 * a33 - a23 * a31;
                var A13 = a21 * a32 - a22 * a31;
                var A21 = a12 * a33 - a13 * a32;
                var A22 = a11 * a33 - a13 * a31;
                var A23 = a11 * a32 - a12 * a31;
                var A31 = a12 * a23 - a13 * a22;
                var A32 = a11 * a23 - a13 * a21;
                var A33 = a11 * a22 - a12 * a21;
                var fDeterminant = a11 * A11 - a12 * A12 + a13 * A13;
                if(fDeterminant == 0.) {
                    akra.logger.setSourceLocation("Mat3.ts", 445);
                    akra.logger.error("обращение матрицы с нулевым детеминантом:\n", this.toString());
                    ;
                    return m3fDestination.set(1.);
                    //чтоб все не навернулось
                                    }
                var fInverseDeterminant = 1. / fDeterminant;
                pDataDestination[0] = A11 * fInverseDeterminant;
                pDataDestination[3] = -A21 * fInverseDeterminant;
                pDataDestination[6] = A31 * fInverseDeterminant;
                pDataDestination[1] = -A12 * fInverseDeterminant;
                pDataDestination[4] = A22 * fInverseDeterminant;
                pDataDestination[7] = -A32 * fInverseDeterminant;
                pDataDestination[2] = A13 * fInverseDeterminant;
                pDataDestination[5] = -A23 * fInverseDeterminant;
                pDataDestination[8] = A33 * fInverseDeterminant;
                return m3fDestination;
            };
            Mat3.prototype.isEqual = function /** @no-inline */(m3fMat, fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                var pData1 = this.data;
                var pData2 = m3fMat.data;
                if(fEps == 0) {
                    if(pData1[0] != pData2[0] || pData1[3] != pData2[3] || pData1[6] != pData2[6] || pData1[1] != pData2[1] || pData1[4] != pData2[4] || pData1[7] != pData2[7] || pData1[2] != pData2[2] || pData1[5] != pData2[5] || pData1[8] != pData2[8]) {
                        return false;
                    }
                } else {
                    if(Math.abs(pData1[0] - pData2[0]) > fEps || Math.abs(pData1[3] - pData2[3]) > fEps || Math.abs(pData1[6] - pData2[6]) > fEps || Math.abs(pData1[1] - pData2[1]) > fEps || Math.abs(pData1[4] - pData2[4]) > fEps || Math.abs(pData1[7] - pData2[7]) > fEps || Math.abs(pData1[2] - pData2[2]) > fEps || Math.abs(pData1[5] - pData2[5]) > fEps || Math.abs(pData1[8] - pData2[8]) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Mat3.prototype.isDiagonal = function /** @no-inline */(fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                var pData = this.data;
                if(fEps == 0) {
                    if(pData[3] != 0 || pData[6] != 0 || pData[1] != 0 || pData[7] != 0 || pData[2] != 0 || pData[5] != 0) {
                        return false;
                    }
                } else {
                    if(Math.abs(pData[3]) > fEps || Math.abs(pData[6]) > fEps || Math.abs(pData[1]) > fEps || Math.abs(pData[7]) > fEps || Math.abs(pData[2]) > fEps || Math.abs(pData[5]) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Mat3.prototype.toMat4 = function /** @no-inline */(m4fDestination) {
                if(!akra.isDef(m4fDestination)) {
                    m4fDestination = new math.Mat4();
                }
                var pData = this.data;
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = pData[0];
                pDataDestination[4] = pData[3];
                pDataDestination[8] = pData[6];
                pDataDestination[12] = 0;
                pDataDestination[1] = pData[1];
                pDataDestination[5] = pData[4];
                pDataDestination[9] = pData[7];
                pDataDestination[13] = 0;
                pDataDestination[2] = pData[2];
                pDataDestination[6] = pData[5];
                pDataDestination[10] = pData[8];
                pDataDestination[14] = 0;
                pDataDestination[3] = 0;
                pDataDestination[7] = 0;
                pDataDestination[11] = 0;
                pDataDestination[15] = 1;
                return m4fDestination;
            };
            Mat3.prototype.toQuat4 = function /** @no-inline */(q4fDestination) {
                if(!akra.isDef(q4fDestination)) {
                    q4fDestination = new math.Quat4();
                }
                var pData = this.data;
                var a11 = pData[0], a12 = pData[3], a13 = pData[6];
                var a21 = pData[1], a22 = pData[4], a23 = pData[7];
                var a31 = pData[2], a32 = pData[5], a33 = pData[8];
                /*x^2*/
                var x2 = ((a11 - a22 - a33) + 1) / 4;
                /*y^2*/
                var y2 = ((a22 - a11 - a33) + 1) / 4;
                /*z^2*/
                var z2 = ((a33 - a11 - a22) + 1) / 4;
                /*w^2*/
                var w2 = ((a11 + a22 + a33) + 1) / 4;
                var fMax = Math.max(x2, Math.max(y2, Math.max(z2, w2)));
                if(fMax == x2) {
                    //максимальная компонента берется положительной
                    var x = Math.sqrt(x2);
                    q4fDestination.x = x;
                    q4fDestination.y = (a21 + a12) / 4 / x;
                    q4fDestination.z = (a31 + a13) / 4 / x;
                    q4fDestination.w = (a32 - a23) / 4 / x;
                } else if(fMax == y2) {
                    //максимальная компонента берется положительной
                    var y = Math.sqrt(y2);
                    q4fDestination.x = (a21 + a12) / 4 / y;
                    q4fDestination.y = y;
                    q4fDestination.z = (a32 + a23) / 4 / y;
                    q4fDestination.w = (a13 - a31) / 4 / y;
                } else if(fMax == z2) {
                    //максимальная компонента берется положительной
                    var z = Math.sqrt(z2);
                    q4fDestination.x = (a31 + a13) / 4 / z;
                    q4fDestination.y = (a32 + a23) / 4 / z;
                    q4fDestination.z = z;
                    q4fDestination.w = (a21 - a12) / 4 / z;
                } else {
                    //максимальная компонента берется положительной
                    var w = Math.sqrt(w2);
                    q4fDestination.x = (a32 - a23) / 4 / w;
                    q4fDestination.y = (a13 - a31) / 4 / w;
                    q4fDestination.z = (a21 - a12) / 4 / w;
                    q4fDestination.w = w;
                }
                return q4fDestination;
            };
            Mat3.prototype.toString = function /** @no-inline */() {
                var pData = this.data;
                return '[' + pData[0] + ', ' + pData[3] + ', ' + pData[6] + ',\n' + +pData[1] + ', ' + pData[4] + ', ' + pData[7] + ',\n' + +pData[2] + ', ' + pData[5] + ', ' + pData[8] + ']';
            };
            Mat3.prototype.decompose = function /** @no-inline */(q4fRotation, v3fScale) {
                //изначально предполагаем, что порядок умножения был rot * scale
                var m3fRotScale = this;
                var m3fRotScaleTransposed = this.transpose(math.mat3());
                var isRotScale = true;
                //понадобятся если порядок умножения был другим
                                var m3fScaleRot = null, m3fScaleRotTransposed = null;
                //было отражение или нет
                var scaleSign = (m3fRotScale.determinant() >= 0.) ? 1 : -1;
                var m3fResult = math.mat3();
                //first variant rot * scale
                // (rot * scale)T * (rot * scale) =
                // scaleT * rotT * rot * scale = scaleT *rot^-1 * rot * scale =
                // scaleT * scale
                m3fRotScaleTransposed.multiply(m3fRotScale, m3fResult);
                if(!m3fResult.isDiagonal(1e-4)) {
                    //предположение было неверным
                    isRotScale = false;
                    //просто переобозначения чтобы не было путаницы
                    m3fScaleRot = m3fRotScale;
                    m3fScaleRotTransposed = m3fRotScaleTransposed;
                    //second variant scale * rot
                    // (scale * rot) * (scale * rot)T =
                    // scale * rot * rotT * scaleT = scale *rot * rot^-1 * scaleT =
                    // scale * scaleT
                    m3fScaleRot.multiply(m3fScaleRotTransposed, m3fResult);
                }
                var pResultData = m3fResult.data;
                var x = math.sqrt(pResultData[0]);
                /*если было отражение, считается что оно было по y*/
                var y = math.sqrt(pResultData[4]) * scaleSign;
                var z = math.sqrt(pResultData[8]);
                v3fScale.x = x;
                v3fScale.y = y;
                v3fScale.z = z;
                var m3fInverseScale = math.mat3(1. / x, 1. / y, 1. / z);
                if(isRotScale) {
                    m3fRotScale.multiply(m3fInverseScale, math.mat3()).toQuat4(q4fRotation);
                    return true;
                } else {
                    m3fInverseScale.multiply(m3fScaleRot, math.mat3()).toQuat4(q4fRotation);
                    akra.logger.setSourceLocation("Mat3.ts", 674);
                    akra.logger.assert(false, "порядок умножения scale rot в данный момент не поддерживается");
                    ;
                    return false;
                }
            };
            Mat3.prototype.row = function /** @no-inline */(iRow, v3fDestination) {
                if(!akra.isDef(v3fDestination)) {
                    v3fDestination = new math.Vec3();
                }
                var pData = this.data;
                switch(iRow) {
                    case 1:
                        v3fDestination.x = pData[0];
                        v3fDestination.y = pData[3];
                        v3fDestination.z = pData[6];
                        break;
                    case 2:
                        v3fDestination.x = pData[1];
                        v3fDestination.y = pData[4];
                        v3fDestination.z = pData[7];
                        break;
                    case 3:
                        v3fDestination.x = pData[2];
                        v3fDestination.y = pData[5];
                        v3fDestination.z = pData[8];
                        break;
                }
                return v3fDestination;
            };
            Mat3.prototype.column = function /** @no-inline */(iColumn, v3fDestination) {
                if(!akra.isDef(v3fDestination)) {
                    v3fDestination = new math.Vec3();
                }
                var pData = this.data;
                switch(iColumn) {
                    case 1:
                        v3fDestination.x = pData[0];
                        v3fDestination.y = pData[1];
                        v3fDestination.z = pData[2];
                        break;
                    case 2:
                        v3fDestination.x = pData[3];
                        v3fDestination.y = pData[4];
                        v3fDestination.z = pData[5];
                        break;
                    case 3:
                        v3fDestination.x = pData[6];
                        v3fDestination.y = pData[7];
                        v3fDestination.z = pData[8];
                        break;
                }
                return v3fDestination;
            };
            Mat3.fromYawPitchRoll = function /** @no-inline */fromYawPitchRoll(fYaw, fPitch, fRoll, m3fDestination) {
                if(arguments.length <= 2) {
                    //Vec3 + m3fDestination
                    var v3fVec = arguments[0];
                    fYaw = v3fVec.x;
                    fPitch = v3fVec.y;
                    fRoll = v3fVec.z;
                    m3fDestination = arguments[1];
                }
                if(!akra.isDef(m3fDestination)) {
                    m3fDestination = new Mat3();
                }
                var pDataDestination = m3fDestination.data;
                var fSin1 = Math.sin(fYaw);
                var fSin2 = Math.sin(fPitch);
                var fSin3 = Math.sin(fRoll);
                var fCos1 = Math.cos(fYaw);
                var fCos2 = Math.cos(fPitch);
                var fCos3 = Math.cos(fRoll);
                pDataDestination[0] = fCos1 * fCos3 + fSin1 * fSin2 * fSin3;
                pDataDestination[3] = fCos3 * fSin1 * fSin2 - fCos1 * fSin3;
                pDataDestination[6] = fCos2 * fSin1;
                pDataDestination[1] = fCos2 * fSin3;
                pDataDestination[4] = fCos2 * fCos3;
                pDataDestination[7] = -fSin2;
                pDataDestination[2] = fCos1 * fSin2 * fSin3 - fCos3 * fSin1;
                pDataDestination[5] = fSin1 * fSin3 + fCos1 * fCos3 * fSin2;
                pDataDestination[8] = fCos1 * fCos2;
                return m3fDestination;
            };
            Mat3.fromXYZ = function /** @no-inline */fromXYZ(fX, fY, fZ, m3fDestination) {
                if(arguments.length <= 2) {
                    //Vec3 + m3fDestination
                    var v3fVec = arguments[0];
                    return Mat3.fromYawPitchRoll(v3fVec.y, v3fVec.x, v3fVec.z, arguments[1]);
                } else {
                    //fX fY fZ m3fDestination
                    var fX = arguments[0];
                    var fY = arguments[1];
                    var fZ = arguments[2];
                    return Mat3.fromYawPitchRoll(fY, fX, fZ, arguments[3]);
                }
            };
            Object.defineProperty(Mat3, "stackCeil", {
                get: function /** @no-inline */() {
                    Mat3.stackPosition = Mat3.stackPosition === Mat3.stackSize - 1 ? 0 : Mat3.stackPosition;
                    return Mat3.stack[Mat3.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            Mat3.stackSize = 100;
            Mat3.stackPosition = 0;
            Mat3.stack = (function /** @no-inline */() {
                var pStack = new Array(Mat3.stackSize);
                for(var i = 0; i < Mat3.stackSize; i++) {
                    pStack[i] = new Mat3();
                }
                return pStack;
            })();
            return Mat3;
        })();
        math.Mat3 = Mat3;        
        ;
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
;
;
var akra;
(function (akra) {
    (function (math) {
        var Mat4 = (function () {
            function /** @no-inline */Mat4(fValue1, fValue2, fValue3, fValue4, fValue5, fValue6, fValue7, fValue8, fValue9, fValue10, fValue11, fValue12, fValue13, fValue14, fValue15, fValue16) {
                var nArgumentsLength = arguments.length;
                if(nArgumentsLength === 2) {
                    if(akra.isBoolean(arguments[1])) {
                        if(arguments[1]) {
                            this.data = arguments[0];
                        } else {
                            this.data = new Float32Array(16);
                            this.set(arguments[0]);
                        }
                    } else {
                        this.data = new Float32Array(16);
                        this.set(arguments[0], arguments[1]);
                    }
                } else {
                    this.data = new Float32Array(16);
                    switch(nArgumentsLength) {
                        case 1:
                            if(arguments[0] instanceof math.Mat3) {
                                this.set(arguments[0], math.vec3(0.));
                            } else {
                                this.set(arguments[0]);
                            }
                            break;
                        case 4:
                            this.set(arguments[0], arguments[1], arguments[2], arguments[3]);
                            break;
                        case 16:
                            this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8], arguments[9], arguments[10], arguments[11], arguments[12], arguments[13], arguments[14], arguments[15]);
                            break;
                        default:
                            break;
                    }
                }
            }
            Mat4.prototype.set = function /** @no-inline */(fValue1, fValue2, fValue3, fValue4, fValue5, fValue6, fValue7, fValue8, fValue9, fValue10, fValue11, fValue12, fValue13, fValue14, fValue15, fValue16) {
                var nArgumentsLength = arguments.length;
                var pData = this.data;
                if(nArgumentsLength === 0) {
                    pData[0] = pData[4] = pData[8] = pData[12] = pData[1] = pData[5] = pData[9] = pData[13] = pData[2] = pData[6] = pData[10] = pData[14] = pData[3] = pData[7] = pData[11] = pData[15] = 0.;
                    return this;
                }
                if(nArgumentsLength === 1) {
                    if(akra.isFloat(arguments[0])) {
                        var fValue = arguments[0];
                        pData[0] = fValue;
                        pData[4] = 0.;
                        pData[8] = 0.;
                        pData[12] = 0.;
                        pData[1] = 0.;
                        pData[5] = fValue;
                        pData[9] = 0.;
                        pData[13] = 0.;
                        pData[2] = 0.;
                        pData[6] = 0.;
                        pData[10] = fValue;
                        pData[14] = 0.;
                        pData[3] = 0.;
                        pData[7] = 0.;
                        pData[11] = 0.;
                        pData[15] = fValue;
                    } else if(arguments[0] instanceof math.Vec4) {
                        var v4fVec = arguments[0];
                        pData[0] = v4fVec.x;
                        pData[4] = 0.;
                        pData[8] = 0.;
                        pData[12] = 0.;
                        pData[1] = 0.;
                        pData[5] = v4fVec.y;
                        pData[9] = 0.;
                        pData[13] = 0.;
                        pData[2] = 0.;
                        pData[6] = 0.;
                        pData[10] = v4fVec.z;
                        pData[14] = 0.;
                        pData[3] = 0.;
                        pData[7] = 0.;
                        pData[11] = 0.;
                        pData[15] = v4fVec.w;
                    } else if(akra.isDef(arguments[0].data)) {
                        var pMatrixData = arguments[0].data;
                        if(pMatrixData.length == 16) {
                            //Mat4
                            pData.set(pMatrixData);
                        } else {
                            //Mat3
                            pData[0] = pMatrixData[0];
                            pData[4] = pMatrixData[3];
                            pData[8] = pMatrixData[6];
                            pData[1] = pMatrixData[1];
                            pData[5] = pMatrixData[4];
                            pData[9] = pMatrixData[7];
                            pData[2] = pMatrixData[2];
                            pData[6] = pMatrixData[5];
                            pData[10] = pMatrixData[8];
                            pData[3] = 0.;
                            pData[7] = 0.;
                            pData[11] = 0.;
                            pData[15] = 1.;
                        }
                    } else {
                        //array
                        var pArray = arguments[0];
                        if(pArray.length === 4) {
                            pData[0] = pArray[0];
                            pData[4] = 0.;
                            pData[8] = 0.;
                            pData[12] = 0.;
                            pData[1] = 0.;
                            pData[5] = pArray[1];
                            pData[9] = 0.;
                            pData[13] = 0.;
                            pData[2] = 0.;
                            pData[6] = 0.;
                            pData[10] = pArray[2];
                            pData[14] = 0.;
                            pData[3] = 0.;
                            pData[7] = 0.;
                            pData[11] = 0.;
                            pData[15] = pArray[3];
                        } else {
                            //length == 16
                            pData[0] = pArray[0];
                            pData[4] = pArray[4];
                            pData[8] = pArray[8];
                            pData[12] = pArray[12];
                            pData[1] = pArray[1];
                            pData[5] = pArray[5];
                            pData[9] = pArray[9];
                            pData[13] = pArray[13];
                            pData[2] = pArray[2];
                            pData[6] = pArray[6];
                            pData[10] = pArray[10];
                            pData[14] = pArray[14];
                            pData[3] = pArray[3];
                            pData[7] = pArray[7];
                            pData[11] = pArray[11];
                            pData[15] = pArray[15];
                        }
                    }
                } else if(nArgumentsLength == 2) {
                    var pMatrixData = arguments[0];
                    var v3fTranslation = arguments[1];
                    pData[0] = pMatrixData[0];
                    pData[4] = pMatrixData[3];
                    pData[8] = pMatrixData[6];
                    pData[12] = v3fTranslation.x;
                    pData[1] = pMatrixData[1];
                    pData[5] = pMatrixData[4];
                    pData[9] = pMatrixData[7];
                    pData[13] = v3fTranslation.y;
                    pData[2] = pMatrixData[2];
                    pData[6] = pMatrixData[5];
                    pData[10] = pMatrixData[8];
                    pData[14] = v3fTranslation.z;
                    pData[3] = 0.;
                    pData[7] = 0.;
                    pData[11] = 0.;
                    pData[15] = 1.;
                } else if(nArgumentsLength == 4) {
                    if(akra.isFloat(arguments[0])) {
                        pData[0] = arguments[0];
                        pData[4] = 0;
                        pData[8] = 0;
                        pData[12] = 0;
                        pData[1] = 0;
                        pData[5] = arguments[1];
                        pData[9] = 0;
                        pData[13] = 0;
                        pData[2] = 0;
                        pData[6] = 0;
                        pData[10] = arguments[2];
                        pData[14] = 0;
                        pData[3] = 0;
                        pData[7] = 0;
                        pData[11] = 0;
                        pData[15] = arguments[3];
                    } else if(arguments[0] instanceof math.Vec4) {
                        var v4fColumn1 = arguments[0];
                        var v4fColumn2 = arguments[1];
                        var v4fColumn3 = arguments[2];
                        var v4fColumn4 = arguments[3];
                        pData[0] = v4fColumn1.x;
                        pData[4] = v4fColumn2.x;
                        pData[8] = v4fColumn3.x;
                        pData[12] = v4fColumn4.x;
                        pData[1] = v4fColumn1.y;
                        pData[5] = v4fColumn2.y;
                        pData[9] = v4fColumn3.y;
                        pData[13] = v4fColumn4.y;
                        pData[2] = v4fColumn1.z;
                        pData[6] = v4fColumn2.z;
                        pData[10] = v4fColumn3.z;
                        pData[14] = v4fColumn4.z;
                        pData[3] = v4fColumn1.w;
                        pData[7] = v4fColumn2.w;
                        pData[11] = v4fColumn3.w;
                        pData[15] = v4fColumn4.w;
                    } else {
                        //arrays
                        var v4fColumn1 = arguments[0];
                        var v4fColumn2 = arguments[1];
                        var v4fColumn3 = arguments[2];
                        var v4fColumn4 = arguments[3];
                        pData[0] = v4fColumn1[0];
                        pData[4] = v4fColumn2[0];
                        pData[8] = v4fColumn3[0];
                        pData[12] = v4fColumn4[0];
                        pData[1] = v4fColumn1[1];
                        pData[5] = v4fColumn2[1];
                        pData[9] = v4fColumn3[1];
                        pData[13] = v4fColumn4[1];
                        pData[2] = v4fColumn1[2];
                        pData[6] = v4fColumn2[2];
                        pData[10] = v4fColumn3[2];
                        pData[14] = v4fColumn4[2];
                        pData[3] = v4fColumn1[3];
                        pData[7] = v4fColumn2[3];
                        pData[11] = v4fColumn3[3];
                        pData[15] = v4fColumn4[3];
                    }
                } else {
                    //nArgumentsLength === 16
                    pData[0] = arguments[0];
                    pData[4] = arguments[4];
                    pData[8] = arguments[8];
                    pData[12] = arguments[12];
                    pData[1] = arguments[1];
                    pData[5] = arguments[5];
                    pData[9] = arguments[9];
                    pData[13] = arguments[13];
                    pData[2] = arguments[2];
                    pData[6] = arguments[6];
                    pData[10] = arguments[10];
                    pData[14] = arguments[14];
                    pData[3] = arguments[3];
                    pData[7] = arguments[7];
                    pData[11] = arguments[11];
                    pData[15] = arguments[15];
                }
                return this;
            };
            Mat4.prototype.identity = function /** @no-inline */() {
                var pData = this.data;
                pData[0] = 1.;
                pData[4] = 0.;
                pData[8] = 0.;
                pData[12] = 0.;
                pData[1] = 0.;
                pData[5] = 1.;
                pData[9] = 0.;
                pData[13] = 0.;
                pData[2] = 0.;
                pData[6] = 0.;
                pData[10] = 1.;
                pData[14] = 0.;
                pData[3] = 0.;
                pData[7] = 0.;
                pData[11] = 0.;
                pData[15] = 1.;
                return this;
            };
            Mat4.prototype.add = function /** @no-inline */(m4fMat, m4fDestination) {
                if(!akra.isDef(m4fDestination)) {
                    m4fDestination = this;
                }
                var pData1 = this.data;
                var pData2 = m4fMat.data;
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = pData1[0] + pData2[0];
                pDataDestination[4] = pData1[4] + pData2[4];
                pDataDestination[8] = pData1[8] + pData2[8];
                pDataDestination[12] = pData1[12] + pData2[12];
                pDataDestination[1] = pData1[1] + pData2[1];
                pDataDestination[5] = pData1[5] + pData2[5];
                pDataDestination[9] = pData1[9] + pData2[9];
                pDataDestination[13] = pData1[13] + pData2[13];
                pDataDestination[2] = pData1[2] + pData2[2];
                pDataDestination[6] = pData1[6] + pData2[6];
                pDataDestination[10] = pData1[10] + pData2[10];
                pDataDestination[14] = pData1[14] + pData2[14];
                pDataDestination[3] = pData1[3] + pData2[3];
                pDataDestination[7] = pData1[7] + pData2[7];
                pDataDestination[11] = pData1[11] + pData2[11];
                pDataDestination[15] = pData1[15] + pData2[15];
                return m4fDestination;
            };
            Mat4.prototype.subtract = function /** @no-inline */(m4fMat, m4fDestination) {
                if(!akra.isDef(m4fDestination)) {
                    m4fDestination = this;
                }
                var pData1 = this.data;
                var pData2 = m4fMat.data;
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = pData1[0] - pData2[0];
                pDataDestination[4] = pData1[4] - pData2[4];
                pDataDestination[8] = pData1[8] - pData2[8];
                pDataDestination[12] = pData1[12] - pData2[12];
                pDataDestination[1] = pData1[1] - pData2[1];
                pDataDestination[5] = pData1[5] - pData2[5];
                pDataDestination[9] = pData1[9] - pData2[9];
                pDataDestination[13] = pData1[13] - pData2[13];
                pDataDestination[2] = pData1[2] - pData2[2];
                pDataDestination[6] = pData1[6] - pData2[6];
                pDataDestination[10] = pData1[10] - pData2[10];
                pDataDestination[14] = pData1[14] - pData2[14];
                pDataDestination[3] = pData1[3] - pData2[3];
                pDataDestination[7] = pData1[7] - pData2[7];
                pDataDestination[11] = pData1[11] - pData2[11];
                pDataDestination[15] = pData1[15] - pData2[15];
                return m4fDestination;
            };
            Mat4.prototype.multiply = function /** @no-inline */(m4fMat, m4fDestination) {
                if(!akra.isDef(m4fDestination)) {
                    m4fDestination = this;
                }
                var pData1 = this.data;
                var pData2 = m4fMat.data;
                var pDataDestination = m4fDestination.data;
                //кешируем значения матриц для ускорения
                                var a11 = pData1[0], a12 = pData1[4], a13 = pData1[8], a14 = pData1[12];
                var a21 = pData1[1], a22 = pData1[5], a23 = pData1[9], a24 = pData1[13];
                var a31 = pData1[2], a32 = pData1[6], a33 = pData1[10], a34 = pData1[14];
                var a41 = pData1[3], a42 = pData1[7], a43 = pData1[11], a44 = pData1[15];
                var b11 = pData2[0], b12 = pData2[4], b13 = pData2[8], b14 = pData2[12];
                var b21 = pData2[1], b22 = pData2[5], b23 = pData2[9], b24 = pData2[13];
                var b31 = pData2[2], b32 = pData2[6], b33 = pData2[10], b34 = pData2[14];
                var b41 = pData2[3], b42 = pData2[7], b43 = pData2[11], b44 = pData2[15];
                pDataDestination[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
                pDataDestination[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
                pDataDestination[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
                pDataDestination[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
                pDataDestination[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
                pDataDestination[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
                pDataDestination[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
                pDataDestination[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
                pDataDestination[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
                pDataDestination[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
                pDataDestination[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
                pDataDestination[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
                pDataDestination[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
                pDataDestination[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
                pDataDestination[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
                pDataDestination[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
                return m4fDestination;
            };
            Mat4.prototype.multiplyLeft = function /** @inline */(m4fMat, m4fDestination) {
                if(!akra.isDef(m4fDestination)) {
                    m4fDestination = this;
                }
                return m4fMat.multiply(this, m4fDestination);
            };
            Mat4.prototype.multiplyVec4 = function /** @no-inline */(v4fVec, v4fDestination) {
                if(!akra.isDef(v4fDestination)) {
                    v4fDestination = v4fVec;
                }
                var pData = this.data;
                var x = v4fVec.x, y = v4fVec.y, z = v4fVec.z, w = v4fVec.w;
                v4fDestination.x = pData[0] * x + pData[4] * y + pData[8] * z + pData[12] * w;
                v4fDestination.y = pData[1] * x + pData[5] * y + pData[9] * z + pData[13] * w;
                v4fDestination.z = pData[2] * x + pData[6] * y + pData[10] * z + pData[14] * w;
                v4fDestination.w = pData[3] * x + pData[7] * y + pData[11] * z + pData[15] * w;
                return v4fDestination;
            };
            Mat4.prototype.transpose = function /** @no-inline */(m4fDestination) {
                var pData = this.data;
                if(!akra.isDef(m4fDestination)) {
                    var a12 = pData[4], a13 = pData[8], a14 = pData[12];
                    var a23 = pData[9], a24 = pData[13];
                    var a34 = pData[14];
                    pData[4] = pData[1];
                    pData[8] = pData[2];
                    pData[12] = pData[3];
                    pData[1] = a12;
                    pData[9] = pData[6];
                    pData[13] = pData[7];
                    pData[2] = a13;
                    pData[6] = a23;
                    pData[14] = pData[11];
                    pData[3] = a14;
                    pData[7] = a24;
                    pData[11] = a34;
                    return this;
                }
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = pData[0];
                pDataDestination[4] = pData[1];
                pDataDestination[8] = pData[2];
                pDataDestination[12] = pData[3];
                pDataDestination[1] = pData[4];
                pDataDestination[5] = pData[5];
                pDataDestination[9] = pData[6];
                pDataDestination[13] = pData[7];
                pDataDestination[2] = pData[8];
                pDataDestination[6] = pData[9];
                pDataDestination[10] = pData[10];
                pDataDestination[14] = pData[11];
                pDataDestination[3] = pData[12];
                pDataDestination[7] = pData[13];
                pDataDestination[11] = pData[14];
                pDataDestination[15] = pData[15];
                return m4fDestination;
            };
            Mat4.prototype.determinant = function /** @no-inline */() {
                var pData = this.data;
                var a11 = pData[0], a12 = pData[4], a13 = pData[8], a14 = pData[12];
                var a21 = pData[1], a22 = pData[5], a23 = pData[9], a24 = pData[13];
                var a31 = pData[2], a32 = pData[6], a33 = pData[10], a34 = pData[14];
                var a41 = pData[3], a42 = pData[7], a43 = pData[11], a44 = pData[15];
                return a41 * a32 * a23 * a14 - a31 * a42 * a23 * a14 - a41 * a22 * a33 * a14 + a21 * a42 * a33 * a14 + a31 * a22 * a43 * a14 - a21 * a32 * a43 * a14 - a41 * a32 * a13 * a24 + a31 * a42 * a13 * a24 + a41 * a12 * a33 * a24 - a11 * a42 * a33 * a24 - a31 * a12 * a43 * a24 + a11 * a32 * a43 * a24 + a41 * a22 * a13 * a34 - a21 * a42 * a13 * a34 - a41 * a12 * a23 * a34 + a11 * a42 * a23 * a34 + a21 * a12 * a43 * a34 - a11 * a22 * a43 * a34 - a31 * a22 * a13 * a44 + a21 * a32 * a13 * a44 + a31 * a12 * a23 * a44 - a11 * a32 * a23 * a44 - a21 * a12 * a33 * a44 + a11 * a22 * a33 * a44;
            };
            Mat4.prototype.inverse = function /** @no-inline */(m4fDestination) {
                if(!akra.isDef(m4fDestination)) {
                    m4fDestination = this;
                }
                var pData = this.data;
                var pDataDestination = m4fDestination.data;
                // Cache the matrix values (makes for huge speed increases!)
                                var a11 = pData[0], a12 = pData[4], a13 = pData[8], a14 = pData[12];
                var a21 = pData[1], a22 = pData[5], a23 = pData[9], a24 = pData[13];
                var a31 = pData[2], a32 = pData[6], a33 = pData[10], a34 = pData[14];
                var a41 = pData[3], a42 = pData[7], a43 = pData[11], a44 = pData[15];
                var b00 = a11 * a22 - a12 * a21;
                var b01 = a11 * a23 - a13 * a21;
                var b02 = a11 * a24 - a14 * a21;
                var b03 = a12 * a23 - a13 * a22;
                var b04 = a12 * a24 - a14 * a22;
                var b05 = a13 * a24 - a14 * a23;
                var b06 = a31 * a42 - a32 * a41;
                var b07 = a31 * a43 - a33 * a41;
                var b08 = a31 * a44 - a34 * a41;
                var b09 = a32 * a43 - a33 * a42;
                var b10 = a32 * a44 - a34 * a42;
                var b11 = a33 * a44 - a34 * a43;
                var fDeterminant = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                if(fDeterminant === 0.) {
                    akra.logger.setSourceLocation("Mat4.ts", 624);
                    akra.logger.assert(false, "обращение матрицы с нулевым детеминантом:\n" + this.toString());
                    ;
                    //чтоб все не навернулось		        return m4fDestination.set(1.);
                                    }
                var fInverseDeterminant = 1 / fDeterminant;
                pDataDestination[0] = (a22 * b11 - a23 * b10 + a24 * b09) * fInverseDeterminant;
                pDataDestination[4] = (-a12 * b11 + a13 * b10 - a14 * b09) * fInverseDeterminant;
                pDataDestination[8] = (a42 * b05 - a43 * b04 + a44 * b03) * fInverseDeterminant;
                pDataDestination[12] = (-a32 * b05 + a33 * b04 - a34 * b03) * fInverseDeterminant;
                pDataDestination[1] = (-a21 * b11 + a23 * b08 - a24 * b07) * fInverseDeterminant;
                pDataDestination[5] = (a11 * b11 - a13 * b08 + a14 * b07) * fInverseDeterminant;
                pDataDestination[9] = (-a41 * b05 + a43 * b02 - a44 * b01) * fInverseDeterminant;
                pDataDestination[13] = (a31 * b05 - a33 * b02 + a34 * b01) * fInverseDeterminant;
                pDataDestination[2] = (a21 * b10 - a22 * b08 + a24 * b06) * fInverseDeterminant;
                pDataDestination[6] = (-a11 * b10 + a12 * b08 - a14 * b06) * fInverseDeterminant;
                pDataDestination[10] = (a41 * b04 - a42 * b02 + a44 * b00) * fInverseDeterminant;
                pDataDestination[14] = (-a31 * b04 + a32 * b02 - a34 * b00) * fInverseDeterminant;
                pDataDestination[3] = (-a21 * b09 + a22 * b07 - a23 * b06) * fInverseDeterminant;
                pDataDestination[7] = (a11 * b09 - a12 * b07 + a13 * b06) * fInverseDeterminant;
                pDataDestination[11] = (-a41 * b03 + a42 * b01 - a43 * b00) * fInverseDeterminant;
                pDataDestination[15] = (a31 * b03 - a32 * b01 + a33 * b00) * fInverseDeterminant;
                return m4fDestination;
            };
            Mat4.prototype.trace = function /** @inline */() {
                var pData = this.data;
                return pData[0] + pData[5] + pData[10] + pData[15];
            };
            Mat4.prototype.isEqual = function /** @no-inline */(m4fMat, fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                var pData1 = this.data;
                var pData2 = m4fMat.data;
                if(fEps === 0.) {
                    if(pData1[0] != pData2[0] || pData1[4] != pData2[4] || pData1[8] != pData2[8] || pData1[12] != pData2[12] || pData1[1] != pData2[1] || pData1[5] != pData2[5] || pData1[9] != pData2[9] || pData1[13] != pData2[13] || pData1[2] != pData2[2] || pData1[6] != pData2[6] || pData1[10] != pData2[10] || pData1[14] != pData2[14] || pData1[3] != pData2[3] || pData1[7] != pData2[7] || pData1[11] != pData2[11] || pData1[15] != pData2[15]) {
                        return false;
                    }
                } else {
                    if(math.abs(pData1[0] - pData2[0]) > fEps || math.abs(pData1[4] - pData2[4]) > fEps || math.abs(pData1[8] - pData2[8]) > fEps || math.abs(pData1[12] - pData2[12]) > fEps || math.abs(pData1[1] - pData2[1]) > fEps || math.abs(pData1[5] - pData2[5]) > fEps || math.abs(pData1[9] - pData2[9]) > fEps || math.abs(pData1[13] - pData2[13]) > fEps || math.abs(pData1[2] - pData2[2]) > fEps || math.abs(pData1[6] - pData2[6]) > fEps || math.abs(pData1[10] - pData2[10]) > fEps || math.abs(pData1[14] - pData2[14]) > fEps || math.abs(pData1[3] - pData2[3]) > fEps || math.abs(pData1[7] - pData2[7]) > fEps || math.abs(pData1[11] - pData2[11]) > fEps || math.abs(pData1[15] - pData2[15]) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Mat4.prototype.isDiagonal = function /** @no-inline */(fEps) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                var pData = this.data;
                if(fEps === 0.) {
                    if(pData[4] !== 0. || pData[8] !== 0. || pData[12] != 0. || pData[1] !== 0. || pData[9] !== 0. || pData[13] != 0. || pData[2] !== 0. || pData[6] !== 0. || pData[14] != 0. || pData[3] !== 0. || pData[7] !== 0. || pData[11] != 0.) {
                        return false;
                    }
                } else {
                    if(math.abs(pData[4]) > fEps || math.abs(pData[8]) > fEps || math.abs(pData[12]) > fEps || math.abs(pData[1]) > fEps || math.abs(pData[9]) > fEps || math.abs(pData[13]) > fEps || math.abs(pData[2]) > fEps || math.abs(pData[6]) > fEps || math.abs(pData[14]) > fEps || math.abs(pData[3]) > fEps || math.abs(pData[7]) > fEps || math.abs(pData[11]) > fEps) {
                        return false;
                    }
                }
                return true;
            };
            Mat4.prototype.toMat3 = function /** @no-inline */(m3fDestination) {
                if(!akra.isDef(m3fDestination)) {
                    m3fDestination = new math.Mat3();
                }
                var pData = this.data;
                var pDataDestination = m3fDestination.data;
                pDataDestination[0] = pData[0];
                pDataDestination[3] = pData[4];
                pDataDestination[6] = pData[8];
                pDataDestination[1] = pData[1];
                pDataDestination[4] = pData[5];
                pDataDestination[7] = pData[9];
                pDataDestination[2] = pData[2];
                pDataDestination[5] = pData[6];
                pDataDestination[8] = pData[10];
                return m3fDestination;
            };
            Mat4.prototype.toQuat4 = function /** @no-inline */(q4fDestination) {
                if(!akra.isDef(q4fDestination)) {
                    q4fDestination = new math.Quat4();
                }
                var pData = this.data;
                var a11 = pData[0], a12 = pData[4], a13 = pData[8];
                var a21 = pData[1], a22 = pData[5], a23 = pData[9];
                var a31 = pData[2], a32 = pData[6], a33 = pData[10];
                /*x^2*/
                var x2 = ((a11 - a22 - a33) + 1.) / 4.;
                /*y^2*/
                var y2 = ((a22 - a11 - a33) + 1.) / 4.;
                /*z^2*/
                var z2 = ((a33 - a11 - a22) + 1.) / 4.;
                /*w^2*/
                var w2 = ((a11 + a22 + a33) + 1.) / 4.;
                var fMax = math.max(x2, math.max(y2, math.max(z2, w2)));
                if(fMax == x2) {
                    //максимальная компонента берется положительной
                    var x = math.sqrt(x2);
                    q4fDestination.x = x;
                    q4fDestination.y = (a21 + a12) / 4. / x;
                    q4fDestination.z = (a31 + a13) / 4. / x;
                    q4fDestination.w = (a32 - a23) / 4. / x;
                } else if(fMax == y2) {
                    //максимальная компонента берется положительной
                    var y = math.sqrt(y2);
                    q4fDestination.x = (a21 + a12) / 4. / y;
                    q4fDestination.y = y;
                    q4fDestination.z = (a32 + a23) / 4. / y;
                    q4fDestination.w = (a13 - a31) / 4. / y;
                } else if(fMax == z2) {
                    //максимальная компонента берется положительной
                    var z = math.sqrt(z2);
                    q4fDestination.x = (a31 + a13) / 4. / z;
                    q4fDestination.y = (a32 + a23) / 4. / z;
                    q4fDestination.z = z;
                    q4fDestination.w = (a21 - a12) / 4. / z;
                } else {
                    //максимальная компонента берется положительной
                    var w = math.sqrt(w2);
                    q4fDestination.x = (a32 - a23) / 4. / w;
                    q4fDestination.y = (a13 - a31) / 4. / w;
                    q4fDestination.z = (a21 - a12) / 4. / w;
                    q4fDestination.w = w;
                }
                return q4fDestination;
            };
            Mat4.prototype.toRotationMatrix = function /** @no-inline */(m4fDestination) {
                if(!akra.isDef(m4fDestination)) {
                    m4fDestination = new Mat4();
                }
                var pData = this.data;
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = pData[0];
                pDataDestination[4] = pData[4];
                pDataDestination[8] = pData[8];
                pDataDestination[12] = 0.;
                pDataDestination[1] = pData[1];
                pDataDestination[5] = pData[5];
                pDataDestination[9] = pData[9];
                pDataDestination[13] = 0.;
                pDataDestination[2] = pData[2];
                pDataDestination[6] = pData[6];
                pDataDestination[10] = pData[10];
                pDataDestination[14] = 0.;
                pDataDestination[3] = 0.;
                pDataDestination[7] = 0.;
                pDataDestination[11] = 0.;
                pDataDestination[15] = 1.;
                return m4fDestination;
            };
            Mat4.prototype.toString = function /** @no-inline */() {
                var pData = this.data;
                return '[' + pData[0] + ", " + pData[4] + ', ' + pData[8] + ', ' + pData[12] + ',\n' + pData[1] + ", " + pData[5] + ', ' + pData[9] + ', ' + pData[13] + ',\n' + pData[2] + ", " + pData[6] + ', ' + pData[10] + ', ' + pData[14] + ',\n' + pData[3] + ", " + pData[7] + ', ' + pData[11] + ', ' + pData[15] + ']';
            };
            Mat4.prototype.rotateRight = function /** @no-inline */(fAngle, v3fAxis, m4fDestination) {
                var pData = this.data;
                var x = v3fAxis.x, y = v3fAxis.y, z = v3fAxis.z;
                var fLength = Math.sqrt(x * x + y * y + z * z);
                if(fLength === 0.) {
                    akra.logger.setSourceLocation("Mat4.ts", 860);
                    akra.logger.assert(false, "попытка вращения вокруг оси нулевой длины. Угол " + fAngle + ". Ось " + v3fAxis.toString());
                    ;
                    if(akra.isDef(m4fDestination)) {
                        m4fDestination.set(this);
                    } else {
                        m4fDestination = this;
                    }
                    return m4fDestination;
                }
                var fInvLength = 1. / fLength;
                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;
                var a11 = pData[0], a12 = pData[4], a13 = pData[8];
                var a21 = pData[1], a22 = pData[5], a23 = pData[9];
                var a31 = pData[2], a32 = pData[6], a33 = pData[10];
                var fSin = math.sin(fAngle);
                var fCos = math.cos(fAngle);
                var fTmp = 1. - fCos;
                //build Rotation matrix
                                var b11 = fCos + fTmp * x * x, b12 = fTmp * x * y - fSin * z, b13 = fTmp * x * z + fSin * y;
                var b21 = fTmp * y * z + fSin * z, b22 = fCos + fTmp * y * y, b23 = fTmp * y * z - fSin * x;
                var b31 = fTmp * z * x - fSin * y, b32 = fTmp * z * y + fSin * x, b33 = fCos + fTmp * z * z;
                if(!akra.isDef(m4fDestination)) {
                    pData[0] = a11 * b11 + a12 * b21 + a13 * b31;
                    pData[4] = a11 * b12 + a12 * b22 + a13 * b32;
                    pData[8] = a11 * b13 + a12 * b23 + a13 * b33;
                    pData[1] = a21 * b11 + a22 * b21 + a23 * b31;
                    pData[5] = a21 * b12 + a22 * b22 + a23 * b32;
                    pData[9] = a21 * b13 + a22 * b23 + a23 * b33;
                    pData[2] = a31 * b11 + a32 * b21 + a33 * b31;
                    pData[6] = a31 * b12 + a32 * b22 + a33 * b32;
                    pData[10] = a31 * b13 + a32 * b23 + a33 * b33;
                    return this;
                }
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = a11 * b11 + a12 * b21 + a13 * b31;
                pDataDestination[4] = a11 * b12 + a12 * b22 + a13 * b32;
                pDataDestination[8] = a11 * b13 + a12 * b23 + a13 * b33;
                pDataDestination[12] = pData[12];
                pDataDestination[1] = a21 * b11 + a22 * b21 + a23 * b31;
                pDataDestination[5] = a21 * b12 + a22 * b22 + a23 * b32;
                pDataDestination[9] = a21 * b13 + a22 * b23 + a23 * b33;
                pDataDestination[13] = pData[13];
                pDataDestination[2] = a31 * b11 + a32 * b21 + a33 * b31;
                pDataDestination[6] = a31 * b12 + a32 * b22 + a33 * b32;
                pDataDestination[10] = a31 * b13 + a32 * b23 + a33 * b33;
                pDataDestination[14] = pData[14];
                pDataDestination[3] = pData[3];
                pDataDestination[7] = pData[7];
                pDataDestination[11] = pData[11];
                pDataDestination[15] = pData[15];
                return m4fDestination;
            };
            Mat4.prototype.rotateLeft = function /** @no-inline */(fAngle, v3fAxis, m4fDestination) {
                var pData = this.data;
                var x = v3fAxis.x, y = v3fAxis.y, z = v3fAxis.z;
                var fLength = Math.sqrt(x * x + y * y + z * z);
                if(fLength === 0.) {
                    akra.logger.setSourceLocation("Mat4.ts", 938);
                    akra.logger.assert(false, "попытка вращения вокруг оси нулевой длины. Угол " + fAngle + ". Ось " + v3fAxis.toString());
                    ;
                    if(akra.isDef(m4fDestination)) {
                        m4fDestination.set(this);
                    } else {
                        m4fDestination = this;
                    }
                    return m4fDestination;
                }
                var fInvLength = 1. / fLength;
                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;
                var a11 = pData[0], a12 = pData[4], a13 = pData[8], a14 = pData[12];
                var a21 = pData[1], a22 = pData[5], a23 = pData[9], a24 = pData[13];
                var a31 = pData[2], a32 = pData[6], a33 = pData[10], a34 = pData[14];
                var fSin = math.sin(fAngle);
                var fCos = math.cos(fAngle);
                var fTmp = 1. - fCos;
                //build Rotation matrix
                                var b11 = fCos + fTmp * x * x, b12 = fTmp * x * y - fSin * z, b13 = fTmp * x * z + fSin * y;
                var b21 = fTmp * y * z + fSin * z, b22 = fCos + fTmp * y * y, b23 = fTmp * y * z - fSin * x;
                var b31 = fTmp * z * x - fSin * y, b32 = fTmp * z * y + fSin * x, b33 = fCos + fTmp * z * z;
                if(!akra.isDef(m4fDestination)) {
                    pData[0] = b11 * a11 + b12 * a21 + b13 * a31;
                    pData[4] = b11 * a12 + b12 * a22 + b13 * a32;
                    pData[8] = b11 * a13 + b12 * a23 + b13 * a33;
                    pData[12] = b11 * a14 + b12 * a24 + b13 * a34;
                    pData[1] = b21 * a11 + b22 * a21 + b23 * a31;
                    pData[5] = b21 * a12 + b22 * a22 + b23 * a32;
                    pData[9] = b21 * a13 + b22 * a23 + b23 * a33;
                    pData[13] = b21 * a14 + b22 * a24 + b23 * a34;
                    pData[2] = b31 * a11 + b32 * a21 + b33 * a31;
                    pData[6] = b31 * a12 + b32 * a22 + b33 * a32;
                    pData[10] = b31 * a13 + b32 * a23 + b33 * a33;
                    pData[14] = b31 * a14 + b32 * a24 + b33 * a34;
                    return this;
                }
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = b11 * a11 + b12 * a21 + b13 * a31;
                pDataDestination[4] = b11 * a12 + b12 * a22 + b13 * a32;
                pDataDestination[8] = b11 * a13 + b12 * a23 + b13 * a33;
                pDataDestination[12] = b11 * a14 + b12 * a24 + b13 * a34;
                pDataDestination[1] = b21 * a11 + b22 * a21 + b23 * a31;
                pDataDestination[5] = b21 * a12 + b22 * a22 + b23 * a32;
                pDataDestination[9] = b21 * a13 + b22 * a23 + b23 * a33;
                pDataDestination[13] = b21 * a14 + b22 * a24 + b23 * a34;
                pDataDestination[2] = b31 * a11 + b32 * a21 + b33 * a31;
                pDataDestination[6] = b31 * a12 + b32 * a22 + b33 * a32;
                pDataDestination[10] = b31 * a13 + b32 * a23 + b33 * a33;
                pDataDestination[14] = b31 * a14 + b32 * a24 + b33 * a34;
                pDataDestination[3] = pData[3];
                pDataDestination[7] = pData[7];
                pDataDestination[11] = pData[11];
                pDataDestination[15] = pData[15];
                return m4fDestination;
            };
            Mat4.prototype.setTranslation = function /** @inline */(v3fTranslation) {
                var pData = this.data;
                pData[12] = v3fTranslation.x;
                pData[13] = v3fTranslation.y;
                pData[14] = v3fTranslation.z;
                return this;
            };
            Mat4.prototype.getTranslation = function /** @inline */(v3fTranslation) {
                if(!akra.isDef(v3fTranslation)) {
                    v3fTranslation = new math.Vec3();
                }
                var pData = this.data;
                v3fTranslation.x = pData[12];
                v3fTranslation.y = pData[13];
                v3fTranslation.z = pData[14];
                return v3fTranslation;
            };
            Mat4.prototype.translateRight = function /** @no-inline */(v3fTranslation, m4fDestination) {
                var pData = this.data;
                var x = v3fTranslation.x, y = v3fTranslation.y, z = v3fTranslation.z;
                if(!akra.isDef(m4fDestination)) {
                    pData[12] = pData[0] * x + pData[4] * y + pData[8] * z + pData[12];
                    pData[13] = pData[1] * x + pData[5] * y + pData[9] * z + pData[13];
                    pData[14] = pData[2] * x + pData[6] * y + pData[10] * z + pData[14];
                    pData[15] = pData[3] * x + pData[7] * y + pData[11] * z + pData[15];
                    //строго говоря последнюю строчку умножать не обязательно, так как она должна быть -> 0 0 0 1
                    return this;
                }
                var pDataDestination = m4fDestination.data;
                //кешируем матрицу вращений
                                var a11 = pData[0], a12 = pData[4], a13 = pData[8];
                var a21 = pData[0], a22 = pData[5], a23 = pData[9];
                var a31 = pData[0], a32 = pData[6], a33 = pData[10];
                var a41 = pData[0], a42 = pData[7], a43 = pData[11];
                pDataDestination[0] = a11;
                pDataDestination[4] = a12;
                pDataDestination[8] = a13;
                pDataDestination[12] = a11 * x + a12 * y + a13 * z + pData[12];
                pDataDestination[1] = a21;
                pDataDestination[5] = a22;
                pDataDestination[9] = a23;
                pDataDestination[13] = a21 * x + a22 * y + a23 * z + pData[13];
                pDataDestination[2] = a31;
                pDataDestination[6] = a32;
                pDataDestination[10] = a33;
                pDataDestination[14] = a31 * x + a32 * y + a33 * z + pData[14];
                pDataDestination[3] = a41;
                pDataDestination[7] = a42;
                pDataDestination[11] = a43;
                pDataDestination[15] = a41 * x + a42 * y + a43 * z + pData[15];
                return m4fDestination;
            };
            Mat4.prototype.translateLeft = function /** @no-inline */(v3fTranslation, m4fDestination) {
                var pData = this.data;
                var x = v3fTranslation.x, y = v3fTranslation.y, z = v3fTranslation.z;
                if(!akra.isDef(m4fDestination)) {
                    pData[12] = x + pData[12];
                    pData[13] = y + pData[13];
                    pData[14] = z + pData[14];
                    return this;
                }
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = pData[0];
                pDataDestination[4] = pData[4];
                pDataDestination[8] = pData[8];
                pDataDestination[12] = x + pData[12];
                pDataDestination[1] = pData[1];
                pDataDestination[5] = pData[5];
                pDataDestination[9] = pData[9];
                pDataDestination[13] = y + pData[13];
                pDataDestination[2] = pData[2];
                pDataDestination[6] = pData[6];
                pDataDestination[10] = pData[10];
                pDataDestination[14] = z + pData[14];
                pDataDestination[3] = pData[3];
                pDataDestination[7] = pData[7];
                pDataDestination[11] = pData[11];
                pDataDestination[15] = pData[15];
                return m4fDestination;
            };
            Mat4.prototype.scaleRight = function /** @no-inline */(v3fScale, m4fDestination) {
                var pData = this.data;
                var x = v3fScale.x, y = v3fScale.y, z = v3fScale.z;
                if(!akra.isDef(m4fDestination)) {
                    pData[0] *= x;
                    pData[4] *= y;
                    pData[8] *= z;
                    pData[1] *= x;
                    pData[5] *= y;
                    pData[9] *= z;
                    pData[2] *= x;
                    pData[6] *= y;
                    pData[10] *= z;
                    //скейлить эти компоненты необязательно, так как там должны лежать нули
                    pData[3] *= x;
                    pData[7] *= y;
                    pData[11] *= z;
                    return this;
                }
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = pData[0] * x;
                pDataDestination[4] = pData[4] * y;
                pDataDestination[8] = pData[8] * z;
                pDataDestination[12] = pData[12];
                pDataDestination[1] = pData[1] * x;
                pDataDestination[5] = pData[5] * y;
                pDataDestination[9] = pData[9] * z;
                pDataDestination[13] = pData[13];
                pDataDestination[2] = pData[2] * x;
                pDataDestination[6] = pData[6] * y;
                pDataDestination[10] = pData[10] * z;
                pDataDestination[14] = pData[14];
                //скейлить эти компоненты необязательно, так как там должны лежать нули
                pDataDestination[3] = pData[3] * x;
                pDataDestination[7] = pData[7] * y;
                pDataDestination[11] = pData[11] * z;
                pDataDestination[15] = pData[15];
                return m4fDestination;
            };
            Mat4.prototype.scaleLeft = function /** @no-inline */(v3fScale, m4fDestination) {
                var pData = this.data;
                var x = v3fScale.x, y = v3fScale.y, z = v3fScale.z;
                if(!akra.isDef(m4fDestination)) {
                    pData[0] *= x;
                    pData[4] *= x;
                    pData[8] *= x;
                    pData[12] *= x;
                    pData[1] *= y;
                    pData[5] *= y;
                    pData[9] *= y;
                    pData[13] *= y;
                    pData[2] *= z;
                    pData[6] *= z;
                    pData[10] *= z;
                    pData[14] *= z;
                    return this;
                }
                var pDataDestination = m4fDestination.data;
                pDataDestination[0] = pData[0] * x;
                pDataDestination[4] = pData[4] * x;
                pDataDestination[8] = pData[8] * x;
                pDataDestination[12] = pData[12] * x;
                pDataDestination[1] = pData[1] * y;
                pDataDestination[5] = pData[5] * y;
                pDataDestination[9] = pData[9] * y;
                pDataDestination[13] = pData[13] * y;
                pDataDestination[2] = pData[2] * z;
                pDataDestination[6] = pData[6] * z;
                pDataDestination[10] = pData[10] * z;
                pDataDestination[14] = pData[14] * z;
                pDataDestination[3] = pData[3];
                pDataDestination[7] = pData[7];
                pDataDestination[11] = pData[11];
                pDataDestination[15] = pData[15];
                return m4fDestination;
            };
            Mat4.prototype.decompose = function /** @inline */(q4fRotation, v3fScale, v3fTranslation) {
                this.getTranslation(v3fTranslation);
                var m3fRotScale = this.toMat3(math.mat3());
                return m3fRotScale.decompose(q4fRotation, v3fScale);
            };
            Mat4.prototype.row = function /** @no-inline */(iRow, v4fDestination) {
                if(!akra.isDef(v4fDestination)) {
                    v4fDestination = new math.Vec4();
                }
                var pData = this.data;
                switch(iRow) {
                    case 1:
                        v4fDestination.x = pData[0];
                        v4fDestination.y = pData[4];
                        v4fDestination.z = pData[8];
                        v4fDestination.w = pData[12];
                        break;
                    case 2:
                        v4fDestination.x = pData[1];
                        v4fDestination.y = pData[5];
                        v4fDestination.z = pData[9];
                        v4fDestination.w = pData[13];
                        break;
                    case 3:
                        v4fDestination.x = pData[2];
                        v4fDestination.y = pData[6];
                        v4fDestination.z = pData[10];
                        v4fDestination.w = pData[14];
                        break;
                    case 4:
                        v4fDestination.x = pData[3];
                        v4fDestination.y = pData[7];
                        v4fDestination.z = pData[11];
                        v4fDestination.w = pData[15];
                        break;
                }
                return v4fDestination;
            };
            Mat4.prototype.column = function /** @no-inline */(iColumn, v4fDestination) {
                if(!akra.isDef(v4fDestination)) {
                    v4fDestination = new math.Vec4();
                }
                var pData = this.data;
                switch(iColumn) {
                    case 1:
                        v4fDestination.x = pData[0];
                        v4fDestination.y = pData[1];
                        v4fDestination.z = pData[2];
                        v4fDestination.w = pData[3];
                        break;
                    case 2:
                        v4fDestination.x = pData[4];
                        v4fDestination.y = pData[5];
                        v4fDestination.z = pData[6];
                        v4fDestination.w = pData[7];
                        break;
                    case 3:
                        v4fDestination.x = pData[8];
                        v4fDestination.y = pData[9];
                        v4fDestination.z = pData[10];
                        v4fDestination.w = pData[11];
                        break;
                    case 4:
                        v4fDestination.x = pData[12];
                        v4fDestination.y = pData[13];
                        v4fDestination.z = pData[14];
                        v4fDestination.w = pData[15];
                        break;
                }
                return v4fDestination;
            };
            Mat4.prototype.unproj = function /** @no-inline */(v, v4fDestination) {
                if(!akra.isDef(v4fDestination)) {
                    v4fDestination = new math.Vec4();
                }
                var pData = this.data;
                var v3fScreen = v;
                var x, y, z;
                if(this.isOrthogonalProjection()) {
                    //orthogonal projection case
                    z = (v3fScreen.z - pData[14]) / pData[10];
                    y = (v3fScreen.y - pData[13]) / pData[5];
                    x = (v3fScreen.x - pData[12]) / pData[0];
                } else {
                    //frustum case
                    z = -pData[14] / (pData[10] + v3fScreen.z);
                    y = -(v3fScreen.y + pData[9]) * z / pData[5];
                    x = -(v3fScreen.x + pData[8]) * z / pData[0];
                }
                v4fDestination.x = x;
                v4fDestination.y = y;
                v4fDestination.z = z;
                v4fDestination.w = 1.;
                return v4fDestination;
            };
            Mat4.prototype.unprojZ = function /** @no-inline */(fZ) {
                var pData = this.data;
                if(this.isOrthogonalProjection()) {
                    //orthogonal projection case
                    return (fZ - pData[14]) / pData[10];
                } else {
                    //pData[__43] === -1
                    //frustum case
                    return -pData[14] / (pData[10] + fZ);
                }
            };
            Mat4.prototype.isOrthogonalProjection = function /** @inline */() {
                // var pData: Float32Array = this.data;
                // if(pData[__44] === 1){
                // 	//orthogonal projection
                // 	return true;
                // }
                // else{
                // 	//pData[__43] === -1
                // 	//frustum projection
                // 	return false;
                // }
                return ((this.data[15] === 1) ? true : false);
            };
            Mat4.fromYawPitchRoll = function /** @no-inline */fromYawPitchRoll(fYaw, fPitch, fRoll, m4fDestination) {
                if(arguments.length <= 2) {
                    //Vec3 + m4fDestination
                    var v3fVec = arguments[0];
                    fYaw = v3fVec.x;
                    fPitch = v3fVec.y;
                    fRoll = v3fVec.z;
                    m4fDestination = arguments[1];
                }
                if(!akra.isDef(m4fDestination)) {
                    m4fDestination = new Mat4();
                }
                var pDataDestination = m4fDestination.data;
                var fSin1 = Math.sin(fYaw);
                var fSin2 = Math.sin(fPitch);
                var fSin3 = Math.sin(fRoll);
                var fCos1 = Math.cos(fYaw);
                var fCos2 = Math.cos(fPitch);
                var fCos3 = Math.cos(fRoll);
                pDataDestination[0] = fCos1 * fCos3 + fSin1 * fSin2 * fSin3;
                pDataDestination[4] = fCos3 * fSin1 * fSin2 - fCos1 * fSin3;
                pDataDestination[8] = fCos2 * fSin1;
                pDataDestination[12] = 0.;
                pDataDestination[1] = fCos2 * fSin3;
                pDataDestination[5] = fCos2 * fCos3;
                pDataDestination[9] = -fSin2;
                pDataDestination[13] = 0.;
                pDataDestination[2] = fCos1 * fSin2 * fSin3 - fCos3 * fSin1;
                pDataDestination[6] = fSin1 * fSin3 + fCos1 * fCos3 * fSin2;
                pDataDestination[10] = fCos1 * fCos2;
                pDataDestination[14] = 0.;
                pDataDestination[3] = 0.;
                pDataDestination[7] = 0.;
                pDataDestination[11] = 0.;
                pDataDestination[15] = 1.;
                return m4fDestination;
            };
            Mat4.fromXYZ = function /** @no-inline */fromXYZ(fX, fY, fZ, m4fDestination) {
                if(arguments.length <= 2) {
                    //Vec3 + m4fDestination
                    var v3fVec = arguments[0];
                    return Mat4.fromYawPitchRoll(v3fVec.y, v3fVec.x, v3fVec.z, arguments[1]);
                } else {
                    //fX fY fZ m4fDestination
                    var fX = arguments[0];
                    var fY = arguments[1];
                    var fZ = arguments[2];
                    return Mat4.fromYawPitchRoll(fY, fX, fZ, arguments[3]);
                }
            };
            Mat4.frustum = function /** @no-inline */frustum(fLeft, fRight, fBottom, fTop, fNear, fFar, m4fDestination) {
                if(!akra.isDef(m4fDestination)) {
                    m4fDestination = new Mat4();
                }
                var pDataDestination = m4fDestination.data;
                var fRL = fRight - fLeft;
                var fTB = fTop - fBottom;
                var fFN = fFar - fNear;
                pDataDestination[0] = 2. * fNear / fRL;
                pDataDestination[4] = 0.;
                pDataDestination[8] = (fRight + fLeft) / fRL;
                pDataDestination[12] = 0.;
                pDataDestination[1] = 0.;
                pDataDestination[5] = 2. * fNear / fTB;
                pDataDestination[9] = (fTop + fBottom) / fTB;
                pDataDestination[13] = 0.;
                pDataDestination[2] = 0.;
                pDataDestination[6] = 0.;
                pDataDestination[10] = -(fFar + fNear) / fFN;
                pDataDestination[14] = -2. * fFar * fNear / fFN;
                pDataDestination[3] = 0.;
                pDataDestination[7] = 0.;
                pDataDestination[11] = -1.;
                pDataDestination[15] = 0.;
                return m4fDestination;
            };
            Mat4.perspective = function /** @inline */perspective(fFovy, fAspect, fNear, fFar, m4fDestination) {
                var fTop = fNear * math.tan(fFovy / 2.);
                var fRight = fTop * fAspect;
                return Mat4.frustum(-fRight, fRight, -fTop, fTop, fNear, fFar, m4fDestination);
            };
            Mat4.orthogonalProjectionAsymmetric = function /** @no-inline */orthogonalProjectionAsymmetric(fLeft, fRight, fBottom, fTop, fNear, fFar, m4fDestination) {
                if(!akra.isDef(m4fDestination)) {
                    m4fDestination = new Mat4();
                }
                var pDataDestination = m4fDestination.data;
                var fRL = fRight - fLeft;
                var fTB = fTop - fBottom;
                var fFN = fFar - fNear;
                pDataDestination[0] = 2. / fRL;
                pDataDestination[4] = 0.;
                pDataDestination[8] = 0.;
                pDataDestination[12] = -(fRight + fLeft) / fRL;
                pDataDestination[1] = 0.;
                pDataDestination[5] = 2. / fTB;
                pDataDestination[9] = 0.;
                pDataDestination[13] = -(fTop + fBottom) / fTB;
                pDataDestination[2] = 0.;
                pDataDestination[6] = 0.;
                pDataDestination[10] = -2. / fFN;
                pDataDestination[14] = -(fFar + fNear) / fFN;
                pDataDestination[3] = 0.;
                pDataDestination[7] = 0.;
                pDataDestination[11] = 0.;
                pDataDestination[15] = 1.;
                return m4fDestination;
            };
            Mat4.orthogonalProjection = function /** @inline */orthogonalProjection(fWidth, fHeight, fNear, fFar, m4fDestination) {
                var fRight = fWidth / 2.;
                var fTop = fHeight / 2.;
                return Mat4.orthogonalProjectionAsymmetric(-fRight, fRight, -fTop, fTop, fNear, fFar, m4fDestination);
            };
            Mat4.lookAt = function /** @no-inline */lookAt(v3fEye, v3fCenter, v3fUp, m4fDestination) {
                if(!akra.isDef(m4fDestination)) {
                    m4fDestination = new Mat4(1.);
                }
                var fEyeX = v3fEye.x, fEyeY = v3fEye.y, fEyeZ = v3fEye.z;
                var fCenterX = v3fCenter.x, fCenterY = v3fCenter.y, fCenterZ = v3fCenter.z;
                var fUpX = v3fUp.x, fUpY = v3fUp.y, fUpZ = v3fUp.z;
                var fLength;
                var fInvLength;
                if(fEyeX === fCenterX && fEyeY === fCenterY && fEyeZ === fCenterZ) {
                    return m4fDestination;
                }
                var fXNewX, fXNewY, fXNewZ;
                var fYNewX, fYNewY, fYNewZ;
                var fZNewX, fZNewY, fZNewZ;
                //ось Z направлена на наблюдателя
                fZNewX = fEyeX - fCenterX;
                fZNewY = fEyeY - fCenterY;
                fZNewZ = fEyeZ - fCenterZ;
                fLength = math.sqrt(fZNewX * fZNewX + fZNewY * fZNewY + fZNewZ * fZNewZ);
                fInvLength = 1. / fLength;
                //новая ось Z
                fZNewX = fZNewX * fInvLength;
                fZNewY = fZNewY * fInvLength;
                fZNewZ = fZNewZ * fInvLength;
                //новая ось X
                fXNewX = fUpY * fZNewZ - fUpZ * fZNewY;
                fXNewY = fUpZ * fZNewX - fUpX * fZNewZ;
                fXNewZ = fUpX * fZNewY - fUpY * fZNewX;
                fLength = math.sqrt(fXNewX * fXNewX + fXNewY * fXNewY + fXNewZ * fXNewZ);
                if(fLength) {
                    fInvLength = 1. / fLength;
                    fXNewX = fXNewX * fInvLength;
                    fXNewY = fXNewY * fInvLength;
                    fXNewZ = fXNewZ * fInvLength;
                }
                //новая ось Y
                fYNewX = fZNewY * fXNewZ - fZNewZ * fXNewY;
                fYNewY = fZNewZ * fXNewX - fZNewX * fXNewZ;
                fYNewZ = fZNewX * fXNewY - fZNewY * fXNewX;
                //нормировать ненужно, так как было векторное умножение двух ортонормированных векторов
                //положение камеры в новых осях
                var fEyeNewX = fEyeX * fXNewX + fEyeY * fXNewY + fEyeZ * fXNewZ;
                var fEyeNewY = fEyeX * fYNewX + fEyeY * fYNewY + fEyeZ * fYNewZ;
                var fEyeNewZ = fEyeX * fZNewX + fEyeY * fZNewY + fEyeZ * fZNewZ;
                var pDataDestination = m4fDestination.data;
                //lookAt matrix === camera view matrix
                //почему новый базис записывается по строкам?
                //это сзязано с тем, что это получающаяся матрица -
                //это viewMatrix камеры, а на эту матрицу умножается при рендеринге, то есть
                //модель должна испытать преобразования противоположные тем, которые испытывает камера
                //то есть вращение в другую сторону(базис по строкам) и сдвиг в противоположную сторону
                pDataDestination[0] = fXNewX;
                pDataDestination[4] = fXNewY;
                pDataDestination[8] = fXNewZ;
                /*отъезжаем в позицию камеры*/
                pDataDestination[12] = -fEyeNewX;
                pDataDestination[1] = fYNewX;
                pDataDestination[5] = fYNewY;
                pDataDestination[9] = fYNewZ;
                /*отъезжаем в позицию камеры*/
                pDataDestination[13] = -fEyeNewY;
                pDataDestination[2] = fZNewX;
                pDataDestination[6] = fZNewY;
                pDataDestination[10] = fZNewZ;
                /*отъезжаем в позицию камеры*/
                pDataDestination[14] = -fEyeNewZ;
                pDataDestination[3] = 0.;
                pDataDestination[7] = 0.;
                pDataDestination[11] = 0.;
                pDataDestination[15] = 1.;
                return m4fDestination;
            };
            Object.defineProperty(Mat4, "stackCeil", {
                get: function /** @no-inline */() {
                    Mat4.stackPosition = Mat4.stackPosition === Mat4.stackSize - 1 ? 0 : Mat4.stackPosition;
                    return Mat4.stack[Mat4.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            Mat4.stackSize = 100;
            Mat4.stackPosition = 0;
            Mat4.stack = (function /** @no-inline */() {
                var pStack = new Array(Mat4.stackSize);
                for(var i = 0; i < Mat4.stackSize; i++) {
                    pStack[i] = new Mat4();
                }
                return pStack;
            })();
            return Mat4;
        })();
        math.Mat4 = Mat4;        
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (math) {
        var Quat4 = (function () {
            function /** @no-inline */Quat4(fX, fY, fZ, fW) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 2:
                        this.set(arguments[0], arguments[1]);
                        break;
                    case 4:
                        this.set(arguments[0], arguments[1], arguments[2], arguments[3]);
                        break;
                    default:
                        this.x = this.y = this.z = 0.;
                        this.w = 1.;
                        break;
                }
            }
            Quat4.prototype.set = function /** @no-inline */(fX, fY, fZ, fW) {
                var nArgumentsLength = arguments.length;
                if(nArgumentsLength === 0) {
                    this.x = this.y = this.z = 0.;
                    this.w = 1.;
                }
                if(nArgumentsLength === 1) {
                    if(arguments[0] instanceof Quat4) {
                        var q4fQuat = arguments[0];
                        this.x = q4fQuat.x;
                        this.y = q4fQuat.y;
                        this.z = q4fQuat.z;
                        this.w = q4fQuat.w;
                    } else {
                        //Array
                        var pElements = arguments[0];
                        this.x = pElements[0];
                        this.y = pElements[1];
                        this.z = pElements[2];
                        this.w = pElements[3];
                    }
                } else if(nArgumentsLength === 2) {
                    //float float
                    //vec3 float
                    if(akra.isFloat(arguments[0])) {
                        //float float
                        var fValue = arguments[0];
                        this.x = fValue;
                        this.y = fValue;
                        this.z = fValue;
                        this.w = arguments[1];
                    } else {
                        //vec3 float
                        var v3fValue = arguments[0];
                        this.x = v3fValue.x;
                        this.y = v3fValue.y;
                        this.z = v3fValue.z;
                        this.w = arguments[1];
                    }
                } else if(nArgumentsLength === 4) {
                    this.x = arguments[0];
                    this.y = arguments[1];
                    this.z = arguments[2];
                    this.w = arguments[3];
                }
                return this;
            };
            Quat4.prototype.multiply = function /** @no-inline */(q4fQuat, q4fDestination) {
                if(!akra.isDef(q4fDestination)) {
                    q4fDestination = this;
                }
                var x1 = this.x, y1 = this.y, z1 = this.z, w1 = this.w;
                var x2 = q4fQuat.x, y2 = q4fQuat.y, z2 = q4fQuat.z, w2 = q4fQuat.w;
                q4fDestination.x = x1 * w2 + x2 * w1 + y1 * z2 - z1 * y2;
                q4fDestination.y = y1 * w2 + y2 * w1 + z1 * x2 - x1 * z2;
                q4fDestination.z = z1 * w2 + z2 * w1 + x1 * y2 - y1 * x2;
                q4fDestination.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
                return q4fDestination;
            };
            Quat4.prototype.multiplyVec3 = function /** @no-inline */(v3fVec, v3fDestination) {
                if(!akra.isDef(v3fDestination)) {
                    v3fDestination = v3fVec;
                }
                var q4fVec = math.quat4(v3fVec, 0);
                var qInverse = this.inverse(math.quat4());
                var qResult = this.multiply(q4fVec.multiply(qInverse), math.quat4());
                v3fDestination.x = qResult.x;
                v3fDestination.y = qResult.y;
                v3fDestination.z = qResult.z;
                return v3fDestination;
            };
            Quat4.prototype.conjugate = function /** @no-inline */(q4fDestination) {
                if(!akra.isDef(q4fDestination)) {
                    this.x = -this.x;
                    this.y = -this.y;
                    this.z = -this.z;
                    return this;
                }
                q4fDestination.x = -this.x;
                q4fDestination.y = -this.y;
                q4fDestination.z = -this.z;
                q4fDestination.w = this.w;
                return q4fDestination;
            };
            Quat4.prototype.inverse = function /** @no-inline */(q4fDestination) {
                if(!akra.isDef(q4fDestination)) {
                    q4fDestination = this;
                }
                var x = this.x, y = this.y, z = this.z, w = this.w;
                var fSqLength = x * x + y * y + z * z + w * w;
                if(fSqLength === 0.) {
                    q4fDestination.x = 0.;
                    q4fDestination.y = 0.;
                    q4fDestination.z = 0.;
                    q4fDestination.w = 0.;
                } else {
                    var fInvSqLength = 1. / fSqLength;
                    q4fDestination.x = -x * fInvSqLength;
                    q4fDestination.y = -y * fInvSqLength;
                    q4fDestination.z = -z * fInvSqLength;
                    q4fDestination.w = w * fInvSqLength;
                }
                return q4fDestination;
            };
            Quat4.prototype.length = function /** @inline */() {
                var x = this.x, y = this.y, z = this.z, w = this.w;
                return math.sqrt(x * x + y * y + z * z + w * w);
            };
            Quat4.prototype.normalize = function /** @no-inline */(q4fDestination) {
                if(!akra.isDef(q4fDestination)) {
                    q4fDestination = this;
                }
                var x = this.x, y = this.y, z = this.z, w = this.w;
                var fLength = math.sqrt(x * x + y * y + z * z + w * w);
                if(fLength === 0.) {
                    q4fDestination.x = 0.;
                    q4fDestination.y = 0.;
                    q4fDestination.z = 0.;
                    q4fDestination.w = 0.;
                } else {
                    var fInvLength = 1 / fLength;
                    q4fDestination.x = x * fInvLength;
                    q4fDestination.y = y * fInvLength;
                    q4fDestination.z = z * fInvLength;
                    q4fDestination.w = w * fInvLength;
                }
                return q4fDestination;
            };
            Quat4.prototype.calculateW = function /** @no-inline */(q4fDestination) {
                var x = this.x, y = this.y, z = this.z;
                if(!akra.isDef(q4fDestination)) {
                    this.w = math.sqrt(1. - x * x - y * y - z * z);
                    return this;
                }
                q4fDestination.x = x;
                q4fDestination.y = y;
                q4fDestination.z = z;
                q4fDestination.w = math.sqrt(1. - x * x - y * y - z * z);
                return q4fDestination;
            };
            Quat4.prototype.isEqual = function /** @no-inline */(q4fQuat, fEps, asMatrix) {
                if (typeof fEps === "undefined") { fEps = 0.; }
                if (typeof asMatrix === "undefined") { asMatrix = false; }
                var x1 = this.x, y1 = this.y, z1 = this.z, w1 = this.w;
                var x2 = q4fQuat.x, y2 = q4fQuat.y, z2 = q4fQuat.z, w2 = q4fQuat.w;
                var fLength1 = math.sqrt(x1 * x1 + y1 * y1 + z1 * z1 + w1 * w1);
                var fLength2 = math.sqrt(x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2);
                if(math.abs(fLength2 - fLength2) > fEps) {
                    return false;
                }
                var cosHalfTheta = (x1 * x2 + y1 * y2 + z1 * z2 + w1 * w2) / fLength1 / fLength2;
                if(asMatrix) {
                    cosHalfTheta = math.abs(cosHalfTheta);
                }
                if(1. - cosHalfTheta > fEps) {
                    return false;
                }
                return true;
            };
            Quat4.prototype.getYaw = function /** @no-inline */() {
                var fYaw;
                var x = this.x, y = this.y, z = this.z, w = this.w;
                var fx2 = x * 2.;
                var fy2 = y * 2.;
                if(math.abs(x) == math.abs(w)) {
                    //вырожденный случай обрабатывается отдельно
                    //
                    var wTemp = w * math.sqrt(2.);
                    //cos(Yaw/2)*cos(Roll/2) + sin(Yaw/2)*sin(Roll/2) = cos((Yaw-Roll)/2); Roll = 0;
                    //x==-w
                    //cos(Yaw/2)*cos(Roll/2) - sin(Yaw/2)*sin(Roll/2) = cos((Yaw+Roll)/2); Roll = 0;
                    var yTemp = y * math.sqrt(2.);
                    //sin(Yaw/2)*cos(Roll/2) - cos(Yaw/2)*sin(Roll/2) = sin((Yaw-Roll)/2); Roll = 0;
                    //x==-w
                    //sin(Yaw/2)*cos(Roll/2) + cos(Yaw/2)*sin(Roll/2) = sin((Yaw+Roll)/2); Roll = 0;
                    fYaw = math.atan2(yTemp, wTemp) * 2.;
                    //fRoll = 0;
                    //убираем дополнительный оборот
                    var pi = math.PI;
                    if(fYaw > pi) {
                        fYaw -= pi;
                        //fRoll = (x == w) ? -pi : pi;
                                            } else if(fYaw < -pi) {
                        fYaw += pi;
                        //fRoll = (x == w) ? pi : -pi;
                                            }
                } else {
                    //Math.atan2(sin(Yaw)*cos(Pitch),cos(Yaw)*cos(Pitch));
                    fYaw = math.atan2(fx2 * z + fy2 * w, 1. - (fx2 * x + fy2 * y));
                }
                return fYaw;
            };
            Quat4.prototype.getPitch = function /** @no-inline */() {
                var fPitch;
                var x = this.x, y = this.y, z = this.z, w = this.w;
                var fx2 = x * 2.;
                var fy2 = y * 2.;
                /*в очень редких случаях из-за ошибок округления получается результат > 1*/
                var fSinPitch = math.clamp(fx2 * w - fy2 * z, -1., 1.);
                fPitch = math.asin(fSinPitch);
                return fPitch;
            };
            Quat4.prototype.getRoll = function /** @no-inline */() {
                var fRoll;
                var x = this.x, y = this.y, z = this.z, w = this.w;
                var fx2 = x * 2.;
                var fz2 = z * 2.;
                if(math.abs(x) == math.abs(w)) {
                    //вырожденный случай обрабатывается отдельно
                    //
                    var wTemp = w * math.sqrt(2.);
                    //cos(Yaw/2)*cos(Roll/2) + sin(Yaw/2)*sin(Roll/2) = cos((Yaw-Roll)/2); Roll = 0;
                    //x==-w
                    //cos(Yaw/2)*cos(Roll/2) - sin(Yaw/2)*sin(Roll/2) = cos((Yaw+Roll)/2); Roll = 0;
                    var yTemp = y * math.sqrt(2.);
                    //sin(Yaw/2)*cos(Roll/2) - cos(Yaw/2)*sin(Roll/2) = sin((Yaw-Roll)/2); Roll = 0;
                    //x==-w
                    //sin(Yaw/2)*cos(Roll/2) + cos(Yaw/2)*sin(Roll/2) = sin((Yaw+Roll)/2); Roll = 0;
                    var fYaw = math.atan2(yTemp, wTemp) * 2.;
                    fRoll = 0.;
                    //убираем дополнительный оборот
                    var pi = math.PI;
                    if(fYaw > pi) {
                        //fYaw -= pi;
                        fRoll = (x == w) ? -pi : pi;
                    } else if(fYaw < -pi) {
                        //fYaw += pi;
                        fRoll = (x == w) ? pi : -pi;
                    }
                } else {
                    //Math.atan2(cos(Pitch) * sin(Roll),cos(Pitch)*cos(Roll));
                    fRoll = math.atan2(fx2 * y + fz2 * w, 1. - (fx2 * x + fz2 * z));
                }
                return fRoll;
            };
            Quat4.prototype.toYawPitchRoll = function /** @no-inline */(v3fDestination) {
                if(!akra.isDef(v3fDestination)) {
                    v3fDestination = new math.Vec3();
                }
                var fYaw, fPitch, fRoll;
                var x = this.x, y = this.y, z = this.z, w = this.w;
                var fx2 = x * 2.;
                var fy2 = y * 2.;
                var fz2 = z * 2.;
                var fw2 = w * 2.;
                /*в очень редких случаях из-за ошибок округления получается результат > 1*/
                var fSinPitch = math.clamp(fx2 * w - fy2 * z, -1., 1.);
                fPitch = math.asin(fSinPitch);
                //не известен знак косинуса, как следствие это потребует дополнительной проверки.
                //как показала практика - это не на что не влияет, просто один и тот же кватернион можно получить двумя разными вращениями
                if(math.abs(x) == math.abs(w)) {
                    //вырожденный случай обрабатывается отдельно
                    //
                    var wTemp = w * math.sqrt(2.);
                    //cos(Yaw/2)*cos(Roll/2) + sin(Yaw/2)*sin(Roll/2) = cos((Yaw-Roll)/2); Roll = 0;
                    //x==-w
                    //cos(Yaw/2)*cos(Roll/2) - sin(Yaw/2)*sin(Roll/2) = cos((Yaw+Roll)/2); Roll = 0;
                    var yTemp = y * math.sqrt(2.);
                    //sin(Yaw/2)*cos(Roll/2) - cos(Yaw/2)*sin(Roll/2) = sin((Yaw-Roll)/2); Roll = 0;
                    //x==-w
                    //sin(Yaw/2)*cos(Roll/2) + cos(Yaw/2)*sin(Roll/2) = sin((Yaw+Roll)/2); Roll = 0;
                    fYaw = math.atan2(yTemp, wTemp) * 2.;
                    fRoll = 0.;
                    //убираем дополнительный оборот
                    var pi = math.PI;
                    if(fYaw > pi) {
                        fYaw -= pi;
                        fRoll = (x == w) ? -pi : pi;
                    } else if(fYaw < -pi) {
                        fYaw += pi;
                        fRoll = (x == w) ? pi : -pi;
                    }
                } else {
                    //Math.atan2(sin(Yaw)*cos(Pitch),cos(Yaw)*cos(Pitch));
                    fYaw = math.atan2(fx2 * z + fy2 * w, 1. - (fx2 * x + fy2 * y));
                    //Math.atan2(cos(Pitch) * sin(Roll),cos(Pitch)*cos(Roll));
                    fRoll = math.atan2(fx2 * y + fz2 * w, 1. - (fx2 * x + fz2 * z));
                }
                v3fDestination.x = fYaw;
                v3fDestination.y = fPitch;
                v3fDestination.z = fRoll;
                return v3fDestination;
            };
            Quat4.prototype.toMat3 = function /** @no-inline */(m3fDestination) {
                if(!akra.isDef(m3fDestination)) {
                    m3fDestination = new math.Mat3();
                }
                var pDataDestination = m3fDestination.data;
                var x = this.x, y = this.y, z = this.z, w = this.w;
                //потом необходимо ускорить
                pDataDestination[0] = 1. - 2. * (y * y + z * z);
                pDataDestination[3] = 2. * (x * y - z * w);
                pDataDestination[6] = 2. * (x * z + y * w);
                pDataDestination[1] = 2. * (x * y + z * w);
                pDataDestination[4] = 1. - 2. * (x * x + z * z);
                pDataDestination[7] = 2. * (y * z - x * w);
                pDataDestination[2] = 2. * (x * z - y * w);
                pDataDestination[5] = 2. * (y * z + x * w);
                pDataDestination[8] = 1. - 2. * (x * x + y * y);
                return m3fDestination;
            };
            Quat4.prototype.toMat4 = function /** @no-inline */(m4fDestination) {
                if(!akra.isDef(m4fDestination)) {
                    m4fDestination = new math.Mat4();
                }
                var pDataDestination = m4fDestination.data;
                var x = this.x, y = this.y, z = this.z, w = this.w;
                //потом необходимо ускорить
                pDataDestination[0] = 1. - 2. * (y * y + z * z);
                pDataDestination[4] = 2. * (x * y - z * w);
                pDataDestination[8] = 2. * (x * z + y * w);
                pDataDestination[12] = 0.;
                pDataDestination[1] = 2. * (x * y + z * w);
                pDataDestination[5] = 1. - 2. * (x * x + z * z);
                pDataDestination[9] = 2. * (y * z - x * w);
                pDataDestination[13] = 0.;
                pDataDestination[2] = 2. * (x * z - y * w);
                pDataDestination[6] = 2. * (y * z + x * w);
                pDataDestination[10] = 1. - 2. * (x * x + y * y);
                pDataDestination[14] = 0.;
                pDataDestination[3] = 0.;
                pDataDestination[7] = 0.;
                pDataDestination[11] = 0.;
                pDataDestination[15] = 1.;
                return m4fDestination;
            };
            Quat4.prototype.toString = function /** @inline */() {
                return "[x: " + this.x + ", y: " + this.y + ", z: " + this.z + ", w: " + this.w + "]";
            };
            Quat4.prototype.mix = function /** @no-inline */(q4fQuat, fA, q4fDestination, bShortestPath) {
                if (typeof bShortestPath === "undefined") { bShortestPath = true; }
                if(!akra.isDef(q4fDestination)) {
                    q4fDestination = this;
                }
                fA = math.clamp(fA, 0, 1);
                var x1 = this.x, y1 = this.y, z1 = this.z, w1 = this.w;
                var x2 = q4fQuat.x, y2 = q4fQuat.y, z2 = q4fQuat.z, w2 = q4fQuat.w;
                //скалярное произведение
                var fCos = x1 * x2 + y1 * y2 + z1 * z2 + w1 * w2;
                if(fCos < 0. && bShortestPath) {
                    x2 = -x2;
                    y2 = -y2;
                    z2 = -z2;
                    w2 = -w2;
                }
                var k1 = 1. - fA;
                var k2 = fA;
                q4fDestination.x = x1 * k1 + x2 * k2;
                q4fDestination.y = y1 * k1 + y2 * k2;
                q4fDestination.z = z1 * k1 + z2 * k2;
                q4fDestination.w = w1 * k1 + w2 * k2;
                return q4fDestination;
            };
            Quat4.prototype.smix = function /** @no-inline */(q4fQuat, fA, q4fDestination, bShortestPath) {
                if (typeof bShortestPath === "undefined") { bShortestPath = true; }
                if(!akra.isDef(q4fDestination)) {
                    q4fDestination = this;
                }
                fA = math.clamp(fA, 0, 1);
                var x1 = this.x, y1 = this.y, z1 = this.z, w1 = this.w;
                var x2 = q4fQuat.x, y2 = q4fQuat.y, z2 = q4fQuat.z, w2 = q4fQuat.w;
                //скалярное произведение
                var fCos = x1 * x2 + y1 * y2 + z1 * z2 + w1 * w2;
                if(fCos < 0 && bShortestPath) {
                    fCos = -fCos;
                    x2 = -x2;
                    y2 = -y2;
                    z2 = -z2;
                    w2 = -w2;
                }
                var fEps = 1e-3;
                if(math.abs(fCos) < 1. - fEps) {
                    var fSin = math.sqrt(1. - fCos * fCos);
                    var fInvSin = 1. / fSin;
                    var fAngle = math.atan2(fSin, fCos);
                    var k1 = math.sin((1. - fA) * fAngle) * fInvSin;
                    var k2 = math.sin(fA * fAngle) * fInvSin;
                    q4fDestination.x = x1 * k1 + x2 * k2;
                    q4fDestination.y = y1 * k1 + y2 * k2;
                    q4fDestination.z = z1 * k1 + z2 * k2;
                    q4fDestination.w = w1 * k1 + w2 * k2;
                } else {
                    //два кватерниона или очень близки (тогда можно делать линейную интерполяцию)
                    //или два кватениона диаметрально противоположны, тогда можно интерполировать любым способом
                    //позже надо будет реализовать какой-нибудь, а пока тоже линейная интерполяция
                    var k1 = 1 - fA;
                    var k2 = fA;
                    var x = x1 * k1 + x2 * k2;
                    var y = y1 * k1 + y2 * k2;
                    var z = z1 * k1 + z2 * k2;
                    var w = w1 * k1 + w2 * k2;
                    // и нормализуем так-как мы сошли со сферы
                    var fLength = math.sqrt(x * x + y * y + z * z + w * w);
                    var fInvLen = fLength ? 1 / fLength : 0;
                    q4fDestination.x = x * fInvLen;
                    q4fDestination.y = y * fInvLen;
                    q4fDestination.z = z * fInvLen;
                    q4fDestination.w = w * fInvLen;
                }
                return q4fDestination;
            };
            Quat4.fromForwardUp = function /** @no-inline */fromForwardUp(v3fForward, v3fUp, q4fDestination) {
                if(!akra.isDef(q4fDestination)) {
                    q4fDestination = new Quat4();
                }
                var fForwardX = v3fForward.x, fForwardY = v3fForward.y, fForwardZ = v3fForward.z;
                var fUpX = v3fUp.x, fUpY = v3fUp.y, fUpZ = v3fUp.z;
                var m3fTemp = math.mat3();
                var pTempData = m3fTemp.data;
                pTempData[0] = fUpY * fForwardZ - fUpZ * fForwardY;
                pTempData[3] = fUpX;
                pTempData[6] = fForwardX;
                pTempData[1] = fUpZ * fForwardX - fUpX * fForwardZ;
                pTempData[4] = fUpY;
                pTempData[7] = fForwardY;
                pTempData[2] = fUpX * fForwardY - fUpY * fForwardX;
                pTempData[5] = fUpZ;
                pTempData[8] = fForwardZ;
                return m3fTemp.toQuat4(q4fDestination);
            };
            Quat4.fromAxisAngle = function /** @no-inline */fromAxisAngle(v3fAxis, fAngle, q4fDestination) {
                if(!akra.isDef(q4fDestination)) {
                    q4fDestination = new Quat4();
                }
                var x = v3fAxis.x, y = v3fAxis.y, z = v3fAxis.z;
                var fLength = math.sqrt(x * x + y * y + z * z);
                if(fLength === 0.) {
                    q4fDestination.x = q4fDestination.y = q4fDestination.z = 0;
                    q4fDestination.w = 1;
                    return q4fDestination;
                }
                var fInvLength = 1 / fLength;
                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;
                var fSin = math.sin(fAngle / 2);
                var fCos = math.cos(fAngle / 2);
                q4fDestination.x = x * fSin;
                q4fDestination.y = y * fSin;
                q4fDestination.z = z * fSin;
                q4fDestination.w = fCos;
                return q4fDestination;
            };
            Quat4.fromYawPitchRoll = function /** @no-inline */fromYawPitchRoll(fYaw, fPitch, fRoll, q4fDestination) {
                if(arguments.length <= 2) {
                    var v3fVec = arguments[0];
                    fYaw = v3fVec.x;
                    fPitch = v3fVec.y;
                    fRoll = v3fVec.z;
                    q4fDestination = arguments[1];
                }
                if(!akra.isDef(q4fDestination)) {
                    q4fDestination = new Quat4();
                }
                var fHalfYaw = fYaw * 0.5;
                var fHalfPitch = fPitch * 0.5;
                var fHalfRoll = fRoll * 0.5;
                var fCos1 = math.cos(fHalfYaw), fSin1 = math.sin(fHalfYaw);
                var fCos2 = math.cos(fHalfPitch), fSin2 = math.sin(fHalfPitch);
                var fCos3 = math.cos(fHalfRoll), fSin3 = math.sin(fHalfRoll);
                q4fDestination.x = fCos1 * fSin2 * fCos3 + fSin1 * fCos2 * fSin3;
                q4fDestination.y = fSin1 * fCos2 * fCos3 - fCos1 * fSin2 * fSin3;
                q4fDestination.z = fCos1 * fCos2 * fSin3 - fSin1 * fSin2 * fCos3;
                q4fDestination.w = fCos1 * fCos2 * fCos3 + fSin1 * fSin2 * fSin3;
                return q4fDestination;
            };
            Quat4.fromXYZ = function /** @no-inline */fromXYZ(fX, fY, fZ, q4fDestination) {
                if(arguments.length <= 2) {
                    //Vec3 + m4fDestination
                    var v3fVec = arguments[0];
                    return Quat4.fromYawPitchRoll(v3fVec.y, v3fVec.x, v3fVec.z, arguments[1]);
                } else {
                    //fX fY fZ m4fDestination
                    var fX = arguments[0];
                    var fY = arguments[1];
                    var fZ = arguments[2];
                    return Quat4.fromYawPitchRoll(fY, fX, fZ, arguments[3]);
                }
            };
            Object.defineProperty(Quat4, "stackCeil", {
                get: function /** @no-inline */() {
                    Quat4.stackPosition = Quat4.stackPosition === Quat4.stackSize - 1 ? 0 : Quat4.stackPosition;
                    return Quat4.stack[Quat4.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            Quat4.stackSize = 100;
            Quat4.stackPosition = 0;
            Quat4.stack = (function /** @no-inline */() {
                var pStack = new Array(Quat4.stackSize);
                for(var i = 0; i < Quat4.stackSize; i++) {
                    pStack[i] = new Quat4();
                }
                return pStack;
            })();
            return Quat4;
        })();
        math.Quat4 = Quat4;        
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (math) {
        //
        // BASIC MATH AND UNIT CONVERSION CONSTANTS
        //
        math.E = Math.E;
        math.LN2 = Math.LN2;
        math.LOG2E = Math.LOG2E;
        math.LOG10E = Math.LOG10E;
        math.PI = Math.PI;
        math.SQRT1_2 = Math.SQRT1_2;
        math.SQRT2 = Math.SQRT2;
        math.LN10 = Math.LN10;
        math.POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
        math.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY;
        math.FLOAT_PRECISION = (3.4e-8);
        math.TWO_PI = (2.0 * math.PI);
        math.HALF_PI = (math.PI / 2.0);
        math.QUARTER_PI = (math.PI / 4.0);
        math.EIGHTH_PI = (math.PI / 8.0);
        math.PI_SQUARED = (9.86960440108935861883449099987615113531369940724079);
        math.PI_INVERSE = (0.31830988618379067153776752674502872406891929148091);
        math.PI_OVER_180 = (math.PI / 180);
        math.PI_DIV_180 = (180 / math.PI);
        math.NATURAL_LOGARITHM_BASE = (2.71828182845904523536028747135266249775724709369996);
        math.EULERS_CONSTANT = (0.57721566490153286060651);
        math.SQUARE_ROOT_2 = (1.41421356237309504880168872420969807856967187537695);
        math.INVERSE_ROOT_2 = (0.707106781186547524400844362105198);
        math.SQUARE_ROOT_3 = (1.73205080756887729352744634150587236694280525381038);
        math.SQUARE_ROOT_5 = (2.23606797749978969640917366873127623544061835961153);
        math.SQUARE_ROOT_10 = (3.16227766016837933199889354443271853371955513932522);
        math.CUBE_ROOT_2 = (1.25992104989487316476721060727822835057025146470151);
        math.CUBE_ROOT_3 = (1.44224957030740838232163831078010958839186925349935);
        math.FOURTH_ROOT_2 = (1.18920711500272106671749997056047591529297209246382);
        math.NATURAL_LOG_2 = (0.69314718055994530941723212145817656807550013436026);
        math.NATURAL_LOG_3 = (1.09861228866810969139524523692252570464749055782275);
        math.NATURAL_LOG_10 = (2.30258509299404568401799145468436420760110148862877);
        math.NATURAL_LOG_PI = (1.14472988584940017414342735135305871164729481291531);
        math.BASE_TEN_LOG_PI = (0.49714987269413385435126828829089887365167832438044);
        math.NATURAL_LOGARITHM_BASE_INVERSE = (0.36787944117144232159552377016146086744581113103177);
        math.NATURAL_LOGARITHM_BASE_SQUARED = (7.38905609893065022723042746057500781318031557055185);
        math.GOLDEN_RATIO = ((math.SQUARE_ROOT_5 + 1.0) / 2.0);
        math.DEGREE_RATIO = (math.PI_DIV_180);
        math.RADIAN_RATIO = (math.PI_OVER_180);
        math.GRAVITY_CONSTANT = 9.81;
        //
        // MATH AND UNIT CONVERSION FUNCTION PROTOTYPES
        //
        math.abs = Math.abs;
        math.acos = Math.acos;
        math.asin = Math.asin;
        math.atan = Math.atan;
        math.atan2 = Math.atan2;
        math.exp = Math.exp;
        math.min = Math.min;
        math.random = Math.random;
        math.sqrt = Math.sqrt;
        math.log = Math.log;
        math.round = Math.round;
        math.floor = Math.floor;
        math.ceil = Math.ceil;
        math.sin = Math.sin;
        math.cos = Math.cos;
        math.tan = Math.tan;
        math.pow = Math.pow;
        math.max = Math.max;
        /*
        -----------------------------------------------------------------
        
        Floating Point Macros
        
        -----------------------------------------------------------------
        */
        // reinterpret a float as an int32
        /** @inline */
        math.fpBits = function /** @inline */(f) {
            return math.floor(f);
        };
        // reinterpret an int32 as a float
        /** @inline */
        math.intBits = function /** @inline */(i) {
            return i;
        };
        // return 0 or -1 based on the sign of the float
        /** @inline */
        math.fpSign = function /** @inline */(f) {
            return (f >> 31);
        };
        // extract the 8 bits of exponent as a signed integer
        // by masking out this bits, shifting down by 23,
        // and subtracting the bias value of 127
        /** @inline */
        math.fpExponent = function /** @inline */(f) {
            return (((math.fpBits(f) & 0x7fffffff) >> 23) - 127);
        };
        // return 0 or -1 based on the sign of the exponent
        /** @inline */
        math.fpExponentSign = function /** @inline */(f) {
            return (math.fpExponent(f) >> 31);
        };
        // get the 23 bits of mantissa without the implied bit
        /** @inline */
        math.fpPureMantissa = function /** @inline */(f) {
            return (math.fpBits(f) & 0x7fffff);
        };
        // get the 23 bits of mantissa with the implied bit replaced
        /** @inline */
        math.fpMantissa = function /** @inline */(f) {
            return (math.fpPureMantissa(f) | (1 << 23));
        };
        math.fpOneBits = 0x3F800000;
        // flipSign is a helper Macro to
        // invert the sign of i if flip equals -1,
        // if flip equals 0, it does nothing
        //export var flipSign = (i, flip) ((i^ flip) - flip)
        /** @inline */
        math.flipSign = function /** @inline */(i, flip) {
            return ((flip == -1) ? -i : i);
        };
        /**
        * Абсолютное значение числа
        * @inline
        */
        math.absoluteValue = math.abs;
        /**
        * Pow
        * @inline
        */
        math.raiseToPower = math.pow;
        /**
        * Число положительно?
        * @inline
        */
        math.isPositive = function /** @inline */(a) {
            return (a >= 0);
        };
        /**
        * Число отрицательно?
        * @inline
        */
        math.isNegative = function /** @inline */(a) {
            return (a < 0);
        };
        /**
        * Число одного знака?
        * @inline
        */
        math.sameSigns = function /** @inline */(a, b) {
            return (math.isNegative(a) == math.isNegative(b));
        };
        /**
        * Копировать знак
        * @inline
        */
        math.copySign = function /** @inline */(a, b) {
            return (math.isNegative(b) ? -math.absoluteValue(a) : math.absoluteValue(a));
        };
        /**
        * Растояние между а и b меньше epsilon?
        * @inline
        */
        math.deltaRangeTest = function /** @inline */(a, b, epsilon) {
            if (typeof epsilon === "undefined") { epsilon = 0.0000001; }
            return ((math.absoluteValue(a - b) < epsilon) ? true : false);
        };
        /**
        * Ограничивает value интервалом [low,high]
        * @inline
        */
        math.clamp = function /** @inline */(value, low, high) {
            return math.max(low, math.min(value, high));
        };
        /**
        * Ограничивает value интервалом [0,+Infinity]
        * @inline
        */
        math.clampPositive = function /** @inline */(value) {
            return (value < 0 ? 0 : value);
        };
        /**
        * Ограничивает value интервалом [-Infinity,0]
        * @inline
        */
        math.clampNegative = function /** @inline */(value) {
            return (value > 0 ? 0 : value);
        };
        /**
        * Ограничивает value интервалом [-1,1]
        * @inline
        */
        math.clampUnitSize = function /** @inline */(value) {
            return math.clamp(value, -1, 1);
        };
        /**
        * Номер с права начиная от нуля, самого левого установленного бита
        * @inline
        */
        math.highestBitSet = function /** @inline */(value) {
            return value == 0 ? (null) : (value < 0 ? 31 : ((math.log(value) / math.LN2) << 0));
        };
        /**
        * Номер с права начиная от нуля, самого правого установленного бита
        * @inline
        */
        math.lowestBitSet = function /** @no-inline */(value) {
            var temp;
            if(value == 0) {
                return null;
            }
            for(temp = 0; temp <= 31; temp++) {
                if(value & (1 << temp)) {
                    return temp;
                }
            }
            return null;
        };
        /**
        * Является ли число степенью двойки
        * @inline
        */
        math.isPowerOfTwo = function /** @inline */(value) {
            return (value > 0 && math.highestBitSet(value) == math.lowestBitSet(value));
        };
        /**
        * Округление до числа наиболее близкого к степени двойки
        * @inline
        */
        math.nearestPowerOfTwo = function /** @no-inline */(value) {
            if(value <= 1) {
                return 1;
            }
            var highestBit = math.highestBitSet(value);
            var roundingTest = value & (1 << (highestBit - 1));
            if(roundingTest != 0) {
                ++highestBit;
            }
            return 1 << highestBit;
        };
        /**
        * Округление до следующего числа являющегося к степени двойки
        * @inline
        */
        math.ceilingPowerOfTwo = function /** @no-inline */(value) {
            if(value <= 1) {
                return 1;
            }
            var highestBit = math.highestBitSet(value);
            var mask = value & ((1 << highestBit) - 1);
            highestBit += mask && 1;
            return 1 << highestBit;
        };
        /**
        * Округление до предыдущего числа являющегося к степени двойки
        * @inline
        */
        math.floorPowerOfTwo = function /** @no-inline */(value) {
            if(value <= 1) {
                return 1;
            }
            var highestBit = math.highestBitSet(value);
            return 1 << highestBit;
        };
        /**
        * Деление по модулю
        * @inline
        */
        math.modulus = function /** @inline */(e, divisor) {
            return (e - math.floor(e / divisor) * divisor);
        };
        /**
        *
        * @inline
        */
        math.mod = math.modulus;
        /**
        * Вырвнивание числа на alignment вверх
        * @inline
        */
        math.alignUp = function /** @no-inline */(value, alignment) {
            var iRemainder = math.modulus(value, alignment);
            if(iRemainder == 0) {
                return (value);
            }
            return (value + (alignment - iRemainder));
        };
        /**
        * Вырвнивание числа на alignment вниз
        * @inline
        */
        math.alignDown = function /** @no-inline */(value, alignment) {
            var remainder = math.modulus(value, alignment);
            if(remainder == 0) {
                return (value);
            }
            return (value - remainder);
        };
        /**
        * пнвертировать число
        * @inline
        */
        math.inverse = function /** @inline */(a) {
            return 1. / a;
        };
        /**
        * log base 2
        * @inline
        */
        math.log2 = function /** @inline */(f) {
            return math.log(f) / math.LN2;
        };
        /**
        * Округлени числа с определенной точностью, где округляется до значащих чисел как 1/(2^precision)
        * @inline
        */
        math.trimFloat = function /** @inline */(f, precision) {
            return f;
        };
        /**
        * Перевод дробного в целое с усеением
        * @inline
        */
        math.realToInt32_chop = function /** @inline */(a) {
            return math.round(a);
        };
        /**
        * Перевод дробного в целое до меньшего
        * @inline
        */
        math.realToInt32_floor = function /** @inline */(a) {
            return math.floor(a);
        };
        /**
        * Перевод дробного в целое до большего
        * @inline
        */
        math.realToInt32_ceil = function /** @inline */(a) {
            return math.ceil(a);
        };
        /**
        * Наибольший общий делитель
        * @inline
        */
        math.nod = function /** @no-inline */(n, m) {
            var p = n % m;
            while(p != 0) {
                n = m;
                m = p;
                p = n % m;
            }
            return m;
        };
        /**
        * Наименьшее общее кратное
        * @inline
        */
        math.nok = function /** @inline */(n, m) {
            return math.abs(n * m) / math.nod(n, m);
        };
        /**
        * Greatest common devider
        * @inline
        */
        math.gcd = math.nod;
        /**
        * Least common multiple
        * @inline
        */
        math.lcm = math.nok;
        // var pMat3Stack = new Array(100);
        // var iMat3StackIndex = 0;
        math.isRealEqual = function /** @no-inline */(a, b, tolerance) {
            if (typeof tolerance === "undefined") { tolerance = 1.19209e-007; }
            if(akra.math.abs(b - a) <= tolerance) {
                return true;
            } else {
                return false;
            }
        };
                                                function /** @no-inline */vec2(fValue1, fValue2) {
            var nArgumentsLength = arguments.length;
            var v2fVec = math.Vec2.stack[math.Vec2.stackPosition++];
            if(math.Vec2.stackPosition == math.Vec2.stackSize) {
                math.Vec2.stackPosition = 0;
            }
            switch(nArgumentsLength) {
                case 1:
                    v2fVec.set(arguments[0]);
                    break;
                case 2:
                    v2fVec.set(arguments[0], arguments[1]);
                    break;
                default:
                    v2fVec.x = v2fVec.y = 0.;
                    break;
            }
            return v2fVec;
        }
        math.vec2 = vec2;
        ;
                                                                function /** @no-inline */vec3(fValue1, fValue2, fValue3) {
            var nArgumentsLength = arguments.length;
            var v3fVec = math.Vec3.stack[math.Vec3.stackPosition++];
            if(math.Vec3.stackPosition == math.Vec3.stackSize) {
                math.Vec3.stackPosition = 0;
            }
            switch(nArgumentsLength) {
                case 1:
                    v3fVec.set(arguments[0]);
                    break;
                case 2:
                    v3fVec.set(arguments[0], arguments[1]);
                    break;
                case 3:
                    v3fVec.set(arguments[0], arguments[1], arguments[2]);
                    break;
                default:
                    v3fVec.x = v3fVec.y = v3fVec.z = 0.;
                    break;
            }
            return v3fVec;
        }
        math.vec3 = vec3;
        ;
                                                                                                function /** @no-inline */vec4(fValue1, fValue2, fValue3, fValue4) {
            var nArgumentsLength = arguments.length;
            var v4fVec = math.Vec4.stack[math.Vec4.stackPosition++];
            if(math.Vec4.stackPosition == math.Vec4.stackSize) {
                math.Vec4.stackPosition = 0;
            }
            switch(nArgumentsLength) {
                case 1:
                    v4fVec.set(arguments[0]);
                    break;
                case 2:
                    v4fVec.set(arguments[0], arguments[1]);
                    break;
                case 3:
                    v4fVec.set(arguments[0], arguments[1], arguments[2]);
                    break;
                case 4:
                    v4fVec.set(arguments[0], arguments[1], arguments[2], arguments[3]);
                    break;
                default:
                    v4fVec.x = v4fVec.y = v4fVec.z = v4fVec.w = 0.;
                    break;
            }
            return v4fVec;
        }
        math.vec4 = vec4;
        ;
                                                        function /** @no-inline */quat4(fX, fY, fZ, fW) {
            var nArgumentsLength = arguments.length;
            var q4fQuat = math.Quat4.stack[math.Quat4.stackPosition++];
            if(math.Quat4.stackPosition == math.Quat4.stackSize) {
                math.Quat4.stackPosition = 0;
            }
            switch(nArgumentsLength) {
                case 1:
                    q4fQuat.set(arguments[0]);
                    break;
                case 2:
                    q4fQuat.set(arguments[0], arguments[1]);
                    break;
                case 4:
                    q4fQuat.set(arguments[0], arguments[1], arguments[2], arguments[3]);
                    break;
                default:
                    q4fQuat.x = q4fQuat.y = q4fQuat.z = 0.;
                    q4fQuat.w = 1.;
                    break;
            }
            return q4fQuat;
        }
        math.quat4 = quat4;
        ;
                                                                                        function /** @no-inline */mat3(fValue1, fValue2, fValue3, fValue4, fValue5, fValue6, fValue7, fValue8, fValue9) {
            var nArgumentsLength = arguments.length;
            var m3fMat = math.Mat3.stack[math.Mat3.stackPosition++];
            if(math.Mat3.stackPosition == math.Mat3.stackSize) {
                math.Mat3.stackPosition = 0;
            }
            switch(nArgumentsLength) {
                case 1:
                    m3fMat.set(arguments[0]);
                    break;
                case 3:
                    m3fMat.set(arguments[0], arguments[1], arguments[2]);
                    break;
                case 9:
                    m3fMat.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]);
                    break;
                default:
                    m3fMat.set(0.);
                    break;
            }
            return m3fMat;
        }
        math.mat3 = mat3;
        ;
                                                                                                function /** @no-inline */mat4(fValue1, fValue2, fValue3, fValue4, fValue5, fValue6, fValue7, fValue8, fValue9, fValue10, fValue11, fValue12, fValue13, fValue14, fValue15, fValue16) {
            var nArgumentsLength = arguments.length;
            var m4fMat = math.Mat4.stack[math.Mat4.stackPosition++];
            if(math.Mat4.stackPosition == math.Mat4.stackSize) {
                math.Mat4.stackPosition = 0;
            }
            if(nArgumentsLength === 2) {
                if(akra.isBoolean(arguments[1])) {
                    if(arguments[1]) {
                        m4fMat.data = arguments[0];
                    } else {
                        m4fMat.set(arguments[0]);
                    }
                } else {
                    m4fMat.set(arguments[0], arguments[1]);
                }
            } else {
                switch(nArgumentsLength) {
                    case 1:
                        if(arguments[0] instanceof math.Mat3) {
                            m4fMat.set(arguments[0], vec3(0.));
                        } else {
                            m4fMat.set(arguments[0]);
                        }
                        break;
                    case 4:
                        m4fMat.set(arguments[0], arguments[1], arguments[2], arguments[3]);
                        break;
                    case 16:
                        m4fMat.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8], arguments[9], arguments[10], arguments[11], arguments[12], arguments[13], arguments[14], arguments[15]);
                        break;
                    default:
                        break;
                }
            }
            return m4fMat;
        }
        math.mat4 = mat4;
        ;
        function /** @no-inline */calcPOTtextureSize(nPixels) {
            var w, h;
            var n = nPixels;
            w = Math.ceil(Math.log(n) / Math.LN2 / 2.0);
            h = Math.ceil(Math.log(n / Math.pow(2, w)) / Math.LN2);
            w = Math.pow(2, w);
            h = Math.pow(2, h);
            n = w * h;
            return [
                w, 
                h, 
                n
            ];
        }
        math.calcPOTtextureSize = calcPOTtextureSize;
    })(akra.math || (akra.math = {}));
    var math = akra.math;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.Vec2 = akra.math.Vec2;
    akra.Vec3 = akra.math.Vec3;
    akra.Vec4 = akra.math.Vec4;
    akra.Mat3 = akra.math.Mat3;
    akra.Mat4 = akra.math.Mat4;
    akra.Quat4 = akra.math.Quat4;
    akra.vec2 = akra.math.vec2;
    akra.vec3 = akra.math.vec3;
    akra.vec4 = akra.math.vec4;
    akra.quat4 = akra.math.quat4;
    akra.mat3 = akra.math.mat3;
    akra.mat4 = akra.math.mat4;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        (function (ENodeUpdateFlags) {
            ENodeUpdateFlags._map = [];
            ENodeUpdateFlags.k_SetForDestruction = 0;
            ENodeUpdateFlags._map[1] = "k_NewOrientation";
            //if changed scale, otation or position
            ENodeUpdateFlags.k_NewOrientation = 1;
            ENodeUpdateFlags._map[2] = "k_NewWorldMatrix";
            // k_NewTranslation,
            // k_NewScale,
            ENodeUpdateFlags.k_NewWorldMatrix = 2;
            ENodeUpdateFlags._map[3] = "k_NewLocalMatrix";
            ENodeUpdateFlags.k_NewLocalMatrix = 3;
            ENodeUpdateFlags._map[4] = "k_RebuildInverseWorldMatrix";
            ENodeUpdateFlags.k_RebuildInverseWorldMatrix = 4;
            ENodeUpdateFlags._map[5] = "k_RebuildNormalMatrix";
            ENodeUpdateFlags.k_RebuildNormalMatrix = 5;
        })(scene.ENodeUpdateFlags || (scene.ENodeUpdateFlags = {}));
        var ENodeUpdateFlags = scene.ENodeUpdateFlags;
        ;
        var Node = (function (_super) {
            __extends(Node, _super);
            function Node() {
                _super.apply(this, arguments);

                /**@protected*/ this._m4fLocalMatrix = null;
                /**@protected*/ this._m4fWorldMatrix = null;
                /**@protected*/ this._m4fInverseWorldMatrix = null;
                /**@protected*/ this._m3fNormalMatrix = null;
                /**@protected*/ this._v3fWorldPosition = null;
                /**@protected*/ this._qRotation = null;
                /**@protected*/ this._v3fTranslation = null;
                /**@protected*/ this._v3fScale = null;
                /**@protected*/ this._iUpdateFlags = 0;
                /**@protected*/ this._eInheritance = 0 /* POSITION */ ;
            }
            Object.defineProperty(Node.prototype, "localOrientation", {
                get: function /** @inline */() {
                    return this._qRotation;
                },
                set: function /** @inline */(qOrient) {
                    ((this._iUpdateFlags) |= (1 << (1 /* k_NewOrientation */ )));
                    this._qRotation.set(qOrient);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "localPosition", {
                get: function /** @inline */() {
                    return this._v3fTranslation;
                },
                set: function /** @inline */(v3fPosition) {
                    ((this._iUpdateFlags) |= (1 << (1 /* k_NewOrientation */ )));
                    this._v3fTranslation.set(v3fPosition);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "localScale", {
                get: function /** @inline */() {
                    return this._v3fScale;
                },
                set: function /** @inline */(v3fScale) {
                    ((this._iUpdateFlags) |= (1 << (1 /* k_NewOrientation */ )));
                    this._v3fScale.set(v3fScale);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "localMatrix", {
                get: function /** @inline */() {
                    return this._m4fLocalMatrix;
                },
                set: function /** @inline */(m4fLocalMatrix) {
                    ((this._iUpdateFlags) |= (1 << (3 /* k_NewLocalMatrix */ )));
                    this._m4fLocalMatrix.set(m4fLocalMatrix);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "worldMatrix", {
                get: function /** @inline */() {
                    return this._m4fWorldMatrix;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "worldPosition", {
                get: function /** @inline */() {
                    return this._v3fWorldPosition;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "inverseWorldMatrix", {
                get: function /** @no-inline */() {
                    if(((this._iUpdateFlags & (1 << (4 /* k_RebuildInverseWorldMatrix */ ))) != 0)) {
                        this._m4fWorldMatrix.inverse(this._m4fInverseWorldMatrix);
                        ((this._iUpdateFlags) &= ~(1 << (4 /* k_RebuildInverseWorldMatrix */ )));
                    }
                    return this._m4fInverseWorldMatrix;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "normalMatrix", {
                get: function /** @no-inline */() {
                    if(((this._iUpdateFlags & (1 << (5 /* k_RebuildNormalMatrix */ ))) != 0)) {
                        this._m4fWorldMatrix.toMat3(this._m3fNormalMatrix).inverse().transpose();
                        ((this._iUpdateFlags) &= ~(1 << (5 /* k_RebuildNormalMatrix */ )));
                    }
                    return this._m3fNormalMatrix;
                },
                enumerable: true,
                configurable: true
            });
            Node.prototype.update = function /** @no-inline */() {
                // derived classes update the local matrix
                // then call this base function to complete
                // the update
                return this.recalcWorldMatrix();
            };
            Node.prototype.prepareForUpdate = function /** @no-inline */() {
                _super.prototype.prepareForUpdate.call(this);
                // clear the temporary flags
                ((this._iUpdateFlags) &= ~((1 << (3 /* k_NewLocalMatrix */ )) | (1 << (1 /* k_NewOrientation */ )) | (1 << (2 /* k_NewWorldMatrix */ ))));
            };
            Node.prototype.setInheritance = function /** @inline */(eInheritance) {
                this._eInheritance = eInheritance;
            };
            Node.prototype.getInheritance = function /** @inline */() {
                return this._eInheritance;
            };
            Node.prototype.isWorldMatrixNew = function /** @inline */() {
                return ((this._iUpdateFlags & (1 << (2 /* k_NewWorldMatrix */ ))) != 0);
            };
            Node.prototype.isLocalMatrixNew = function /** @inline */() {
                return ((this._iUpdateFlags & (1 << (3 /* k_NewLocalMatrix */ ))) != 0);
            };
            Node.prototype.recalcWorldMatrix = function /** @no-inline */() {
                var isParentMoved = this._pParent && (this._pParent).isWorldMatrixNew();
                var isOrientModified = ((this._iUpdateFlags & (1 << (1 /* k_NewOrientation */ ))) != 0);
                var isLocalModified = ((this._iUpdateFlags & (1 << (3 /* k_NewLocalMatrix */ ))) != 0);
                if(isOrientModified || isParentMoved || isLocalModified) {
                    var m4fLocal = this._m4fLocalMatrix;
                    var m4fWorld = this._m4fWorldMatrix;
                    var m4fParent = (this._pParent).worldMatrix;
                    var m4fOrient = Node._m4fTemp;
                    var v3fTemp = Node._v3fTemp;
                    var pWorldData = m4fWorld.data;
                    var pParentData = m4fParent.data;
                    var pOrientData = m4fOrient.data;
                    this._qRotation.toMat4(m4fOrient);
                    m4fOrient.setTranslation(this._v3fTranslation);
                    m4fOrient.scaleLeft(this._v3fScale);
                    m4fOrient.multiply(m4fLocal);
                    //console.error(m4fOrient.toString());
                    if(this._pParent) {
                        if(this._eInheritance === 2 /* ALL */ ) {
                            m4fParent.multiply(m4fOrient, m4fWorld);
                        } else if(this._eInheritance === 0 /* POSITION */ ) {
                            m4fWorld.set(m4fOrient);
                            pWorldData[12] = pParentData[12] + pOrientData[12];
                            pWorldData[13] = pParentData[13] + pOrientData[13];
                            pWorldData[14] = pParentData[14] + pOrientData[14];
                        } else if(this._eInheritance === 1 /* ROTSCALE */ ) {
                            var p11 = pParentData[0], p12 = pParentData[4], p13 = pParentData[8];
                            var p21 = pParentData[1], p22 = pParentData[5], p23 = pParentData[9];
                            var p31 = pParentData[2], p32 = pParentData[6], p33 = pParentData[10];
                            var l11 = pOrientData[0], l12 = pOrientData[4], l13 = pOrientData[8];
                            var l21 = pOrientData[1], l22 = pOrientData[5], l23 = pOrientData[9];
                            var l31 = pOrientData[2], l32 = pOrientData[6], l33 = pOrientData[10];
                            pWorldData[0] = p11 * l11 + p12 * l21 + p13 * l31;
                            pWorldData[4] = p11 * l12 + p12 * l22 + p13 * l32;
                            pWorldData[8] = p11 * l13 + p12 * l23 + p13 * l33;
                            pWorldData[12] = pOrientData[12];
                            pWorldData[1] = p21 * l11 + p22 * l21 + p23 * l31;
                            pWorldData[5] = p21 * l12 + p22 * l22 + p23 * l32;
                            pWorldData[9] = p21 * l13 + p22 * l23 + p23 * l33;
                            pWorldData[13] = pOrientData[13];
                            pWorldData[2] = p31 * l11 + p32 * l21 + p33 * l31;
                            pWorldData[6] = p31 * l12 + p32 * l22 + p33 * l32;
                            pWorldData[10] = p31 * l13 + p32 * l23 + p33 * l33;
                            pWorldData[14] = pOrientData[14];
                            pWorldData[3] = pOrientData[3];
                            pWorldData[7] = pOrientData[7];
                            pWorldData[11] = pOrientData[11];
                            pWorldData[15] = pOrientData[15];
                        }
                    } else {
                        m4fWorld.set(m4fOrient);
                    }
                    this._v3fWorldPosition.x = pWorldData[12];
                    this._v3fWorldPosition.y = pWorldData[13];
                    this._v3fWorldPosition.z = pWorldData[14];
                    // set the flag that our world matrix has changed
                    ((this._iUpdateFlags) |= (1 << (2 /* k_NewWorldMatrix */ )));
                    // and it's inverse & vectors are out of date
                    ((this._iUpdateFlags) |= (1 << (4 /* k_RebuildInverseWorldMatrix */ )));
                    ((this._iUpdateFlags) |= (1 << (5 /* k_RebuildNormalMatrix */ )));
                    return true;
                }
                return false;
            };
            Node.prototype.setPosition = function /** @no-inline */(fX, fY, fZ) {
                var pPos = arguments.length === 1 ? arguments[0] : akra.vec3(fX, fY, fZ);
                var v3fTranslation = this._v3fTranslation;
                v3fTranslation.set(pPos);
                ((this._iUpdateFlags) |= (1 << (1 /* k_NewOrientation */ )));
            };
            Node.prototype.addPosition = function /** @no-inline */(fX, fY, fZ) {
                var pPos = arguments.length === 1 ? arguments[0] : akra.vec3(fX, fY, fZ);
                var v3fTranslation = this._v3fTranslation;
                v3fTranslation.add(pPos);
                ((this._iUpdateFlags) |= (1 << (1 /* k_NewOrientation */ )));
            };
            Node.prototype.addRelPosition = function /** @no-inline */(fX, fY, fZ) {
                var pPos = arguments.length === 1 ? arguments[0] : akra.vec3(fX, fY, fZ);
                var v3fTranslation = this._v3fTranslation;
                this._qRotation.multiplyVec3(pPos);
                v3fTranslation.add(pPos);
                ((this._iUpdateFlags) |= (1 << (1 /* k_NewOrientation */ )));
            };
            Node.prototype.setRotationByMatrix = function /** @no-inline */(matrix) {
                matrix.toQuat4(this._qRotation);
                ((this._iUpdateFlags) |= (1 << (1 /* k_NewOrientation */ )));
            };
            Node.prototype.setRotationByAxisAngle = function /** @no-inline */(v3fAxis, fAngle) {
                akra.Quat4.fromAxisAngle(v3fAxis, fAngle, this._qRotation);
                ((this._iUpdateFlags) |= (1 << (1 /* k_NewOrientation */ )));
            };
            Node.prototype.setRotationByForwardUp = function /** @no-inline */(v3fForward, v3fUp) {
                akra.Quat4.fromForwardUp(v3fForward, v3fUp, this._qRotation);
                ((this._iUpdateFlags) |= (1 << (1 /* k_NewOrientation */ )));
            };
            Node.prototype.setRotationByEulerAngles = function /** @no-inline */(fYaw, fPitch, fRoll) {
                akra.Quat4.fromYawPitchRoll(fYaw, fPitch, fRoll, this._qRotation);
                ((this._iUpdateFlags) |= (1 << (1 /* k_NewOrientation */ )));
            };
            Node.prototype.setRotationByXYZAxis = function /** @no-inline */(fX, fY, fZ) {
                akra.Quat4.fromYawPitchRoll(fY, fX, fZ, this._qRotation);
                ((this._iUpdateFlags) |= (1 << (1 /* k_NewOrientation */ )));
            };
            Node.prototype.setRotation = function /** @no-inline */(q4fRotation) {
                this._qRotation.set(q4fRotation);
                ((this._iUpdateFlags) |= (1 << (1 /* k_NewOrientation */ )));
            };
            Node.prototype.addRelRotationByMatrix = function /** @no-inline */(matrix) {
                this.addRelRotation(arguments[0].toQuat4(Node._q4fTemp));
            };
            Node.prototype.addRelRotationByAxisAngle = function /** @no-inline */(v3fAxis, fAngle) {
                this.addRelRotation(akra.Quat4.fromAxisAngle(v3fAxis, fAngle, Node._q4fTemp));
            };
            Node.prototype.addRelRotationByForwardUp = function /** @no-inline */(v3fForward, v3fUp) {
                this.addRelRotation(akra.Quat4.fromForwardUp(v3fForward, v3fUp, Node._q4fTemp));
            };
            Node.prototype.addRelRotationByEulerAngles = function /** @no-inline */(fYaw, fPitch, fRoll) {
                this.addRelRotation(akra.Quat4.fromYawPitchRoll(fYaw, fPitch, fRoll, Node._q4fTemp));
            };
            Node.prototype.addRelRotationByXYZAxis = function /** @no-inline */(fX, fY, fZ) {
                this.addRelRotation(akra.Quat4.fromYawPitchRoll(fY, fX, fZ, Node._q4fTemp));
            };
            Node.prototype.addRelRotation = function /** @no-inline */(q4fRotation) {
                this._qRotation.multiply(q4fRotation);
                ((this._iUpdateFlags) |= (1 << (1 /* k_NewOrientation */ )));
            };
            Node.prototype.addRotationByMatrix = function /** @no-inline */(matrix) {
                this.addRotation(arguments[0].toQuat4(Node._q4fTemp));
            };
            Node.prototype.addRotationByAxisAngle = function /** @no-inline */(v3fAxis, fAngle) {
                this.addRotation(akra.Quat4.fromAxisAngle(v3fAxis, fAngle, Node._q4fTemp));
            };
            Node.prototype.addRotationByForwardUp = function /** @no-inline */(v3fForward, v3fUp) {
                this.addRotation(akra.Quat4.fromForwardUp(v3fForward, v3fUp, Node._q4fTemp));
            };
            Node.prototype.addRotationByEulerAngles = function /** @no-inline */(fYaw, fPitch, fRoll) {
                this.addRotation(akra.Quat4.fromYawPitchRoll(fYaw, fPitch, fRoll, Node._q4fTemp));
            };
            Node.prototype.addRotationByXYZAxis = function /** @no-inline */(fX, fY, fZ) {
                this.addRotation(akra.Quat4.fromYawPitchRoll(fY, fX, fZ, Node._q4fTemp));
            };
            Node.prototype.addRotation = function /** @no-inline */(q4fRotation) {
                q4fRotation.multiplyVec3(this._v3fTranslation);
                q4fRotation.multiply(this._qRotation, this._qRotation);
                ((this._iUpdateFlags) |= (1 << (1 /* k_NewOrientation */ )));
            };
            Node.prototype.scale = function /** @no-inline */(fX, fY, fZ) {
                var pScale = arguments.length === 1 ? arguments[0] : akra.vec3(fX);
                var v3fScale = this._v3fScale;
                v3fScale.scale(pScale);
                ((this._iUpdateFlags) |= (1 << (1 /* k_NewOrientation */ )));
            };
            Node.prototype.attachToParent = function /** @no-inline */(pParent) {
                if(_super.prototype.attachToParent.call(this, pParent)) {
                    // adjust my local matrix to be relative to this new parent
                    var m4fInvertedParentMatrix = akra.mat4();
                    (this._pParent)._m4fWorldMatrix.inverse(m4fInvertedParentMatrix);
                    return true;
                }
                return false;
            };
            Node.prototype.detachFromParent = function /** @no-inline */() {
                if(_super.prototype.detachFromParent.call(this)) {
                    this._m4fWorldMatrix.identity();
                    return true;
                }
                return false;
            };
            Node.prototype.toString = function /** @no-inline */(isRecursive, iDepth) {
                if (typeof isRecursive === "undefined") { isRecursive = false; }
                if (typeof iDepth === "undefined") { iDepth = 0; }
                if(!isRecursive) {
                    return '<node' + (this.name ? " " + this.name : "") + '>';
                }
                var pSibling = this.sibling;
                var pChild = this.child;
                var s = "";
                for(var i = 0; i < iDepth; ++i) {
                    s += ':  ';
                }
                s += '+----[depth: ' + this.depth + ']' + this.toString() + '\n';
                if(pChild) {
                    s += pChild.toString(true, iDepth + 1);
                }
                if(pSibling) {
                    s += pSibling.toString(true, iDepth);
                }
                return s;
            };
            Node._v3fTemp = akra.vec3();
            Node._v4fTemp = akra.vec4();
            Node._m3fTemp = akra.mat3();
            Node._m4fTemp = akra.mat4();
            Node._q4fTemp = akra.quat4();
            return Node;
        })(akra.util.Entity);
        scene.Node = Node;        
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        var SceneNode = (function (_super) {
            __extends(SceneNode, _super);
            function /** @no-inline */SceneNode(pScene) {
                        _super.call(this);
                /**@protected*/ this._pScene = null;
                pScene.connect(this, "attached", "nodeAttachment", 1 /* UNICAST */ );
                pScene.connect(this, "detached", "nodeDetachment", 1 /* UNICAST */ );
                this.scene = pScene;
                this._eType = 3 /* SCENE_NODE */ ;
            }
            Object.defineProperty(SceneNode.prototype, "scene", {
                get: function /** @inline */() {
                    return this._pScene;
                },
                set: function /** @inline */(pScene) {
                    this._pScene = pScene;
                },
                enumerable: true,
                configurable: true
            });
            SceneNode.prototype.create = function /** @no-inline */() {
                _super.prototype.create.call(this);
                this._m4fLocalMatrix = new akra.Mat4(1);
                this._m4fWorldMatrix = new akra.Mat4(1);
                this._m4fInverseWorldMatrix = new akra.Mat4(1);
                this._m3fNormalMatrix = new akra.Mat3(1);
                this._v3fWorldPosition = new akra.Vec3();
                this._v3fTranslation = new akra.Vec3(0);
                this._v3fScale = new akra.Vec3(1);
                this._qRotation = new akra.Quat4(0, 1);
                return true;
            };
            SceneNode.prototype.destroy = function /** @no-inline */() {
                _super.prototype.destroy.call(this);
            };
            SceneNode.prototype.render = /**
            * @deprecated
            */
            function /** @no-inline */() {
            };
            SceneNode.prototype.prepareForRender = /**
            * @deprecated
            */
            function /** @no-inline */() {
            };
            SceneNode.prototype.recursiveRender = /**
            * @deprecated
            */
            function /** @no-inline */() {
                // render myself
                this.prepareForRender();
                this.render();
                // render my sibling
                if(this.sibling) {
                    ((this.sibling)).recursiveRender();
                }
                // render my child
                if(this.child) {
                    ((this.child)).recursiveRender();
                }
            };
            SceneNode.prototype.attachToParent = function /** @no-inline */(pParent) {
                if((pParent).scene !== this._pScene) {
                    akra.logger.setSourceLocation("SceneNode.ts", 82);
                    akra.logger.warning("transfer of the scene node between trees scene - forbidden");
                    ;
                    return false;
                }
                return _super.prototype.attachToParent.call(this, pParent);
            };
            SceneNode.prototype.toString = function /** @no-inline */(isRecursive, iDepth) {
                if (typeof isRecursive === "undefined") { isRecursive = false; }
                if (typeof iDepth === "undefined") { iDepth = 0; }
                if(!isRecursive) {
                    return "<scene_node" + (this.name ? " " + this.name : "") + ">";
                }
                return _super.prototype.toString.call(this, isRecursive, iDepth);
            };
            return SceneNode;
        })(scene.Node);
        scene.SceneNode = SceneNode;        
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        var Joint = (function (_super) {
            __extends(Joint, _super);
            // private _iUpdated: int = 0;
            // private _pEngine: IEngine = null;
            function /** @no-inline */Joint(pScene) {
                        _super.call(this, pScene);
                this._sBone = null;
                this.type = 2 /* JOINT */ ;
            }
            Object.defineProperty(Joint.prototype, "boneName", {
                get: function /** @inline */() {
                    return this._sBone;
                },
                set: function /** @inline */(sBone) {
                    return this._sBone;
                },
                enumerable: true,
                configurable: true
            });
            Joint.prototype.create = // getEngine(): IEngine {
            // 	return this._pEngine;
            // }
            function /** @no-inline */() {
                this._m4fLocalMatrix = new akra.Mat4(1);
                this._m4fWorldMatrix = new akra.Mat4(1);
                this._v3fWorldPosition = new akra.Vec3();
                this._v3fTranslation = new akra.Vec3(0, 0, 0);
                this._v3fScale = new akra.Vec3(1);
                this._qRotation = new akra.Quat4(0, 1);
                //maybe custom
                this.setInheritance(2 /* ALL */ );
                return true;
            };
            Joint.prototype.toString = function /** @no-inline */(isRecursive, iDepth) {
                if (typeof isRecursive === "undefined") { isRecursive = false; }
                if (typeof iDepth === "undefined") { iDepth = 0; }
                isRecursive = isRecursive || false;
                if(!isRecursive) {
                    return "<joint" + (this._sName ? (' ' + this._sName) : "") + ">";
                }
                return scene.Node.prototype.toString.call(this, isRecursive, iDepth);
            };
            return Joint;
        })(scene.SceneNode);
        scene.Joint = Joint;        
        function /** @inline */isJoint(pEntity) {
            return pEntity.type == 2 /* JOINT */ ;
        }
        scene.isJoint = isJoint;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (model) {
        var Skeleton = (function () {
            function /** @no-inline */Skeleton(sName) {
                if (typeof sName === "undefined") { sName = null; }
                this._pRootJoints = [];
                this._pJointMap = null;
                this._pNodeList = null;
                this._pMeshNode = null;
                this._iFlags = false;
                this._sName = sName;
            }
            Object.defineProperty(Skeleton.prototype, "totalBones", {
                get: function /** @inline */() {
                    return Object.keys(this._pJointMap).length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Skeleton.prototype, "totalNodes", {
                get: function /** @inline */() {
                    return this._pNodeList.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Skeleton.prototype, "name", {
                get: function /** @inline */() {
                    return this._sName;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Skeleton.prototype, "root", {
                get: function /** @inline */() {
                    return this._pRootJoints[0] || null;
                },
                enumerable: true,
                configurable: true
            });
            Skeleton.prototype.getRootJoint = function /** @no-inline */() {
                return this.getRootJoints()[0];
            };
            Skeleton.prototype.getRootJoints = function /** @no-inline */() {
                return this._pRootJoints;
            };
            Skeleton.prototype.getJointMap = function /** @no-inline */() {
                return this._pJointMap;
            };
            Skeleton.prototype.getNodeList = function /** @no-inline */() {
                return this._pNodeList;
            };
            Skeleton.prototype.addRootJoint = function /** @no-inline */(pJoint) {
                akra.logger.setSourceLocation("model/Skeleton.ts", 56);
                akra.logger.assert(pJoint instanceof akra.scene.Joint, 'node must be joint');
                ;
                var pRootJoints = this._pRootJoints;
                for(var i = 0; i < pRootJoints.length; i++) {
                    if(pJoint.childOf(pRootJoints[i])) {
                        return false;
                    } else if(pRootJoints[i].childOf(pJoint)) {
                        pRootJoints.splice(i, 1);
                    }
                }
                ;
                this._pRootJoints.push(pJoint);
                return this.update();
            };
            Skeleton.prototype.update = function /** @no-inline */() {
                var pRootJoints = this._pRootJoints;
                var pJointList = this._pJointMap = {
                };
                var pNodeList = this._pNodeList = [];
                //var pNotificationJoints = this._pNotificationJoints = [];
                function /** @no-inline */findNodes(pNode) {
                    var sJoint;
                    if(pNode) {
                        sJoint = pNode.boneName;
                        if(sJoint) {
                            akra.logger.setSourceLocation("model/Skeleton.ts", 88);
                            akra.logger.assert(!pJointList[sJoint], 'joint with name<' + sJoint + '> already exists in skeleton <' + this._sName + '>');
                            ;
                            pJointList[sJoint] = pNode;
                        }
                        pNodeList.push(pNode);
                        findNodes(pNode.sibling());
                        findNodes(pNode.child());
                    }
                }
                for(var i = 0; i < pRootJoints.length; i++) {
                    findNodes(pRootJoints[i]);
                }
                ;
                // for (var sJoint in pJointList) {
                // 	var pJoint = pJointList[sJoint];
                //    	if (pJoint.sibling() == null && pJoint.child() == null) {
                //    		pNotificationJoints.push(pJoint);
                //    	}
                //    };
                return true;
            };
            Skeleton.prototype.findJoint = function /** @no-inline */(sName) {
                return this._pJointMap[sName];
            };
            Skeleton.prototype.findJointByName = function /** @no-inline */(sName) {
                for(var s in this._pJointMap) {
                    if(this._pJointMap[s].name === sName) {
                        return this._pJointMap[s];
                    }
                }
                return null;
            };
            Skeleton.prototype.attachMesh = function /** @no-inline */(pMesh) {
                if(akra.isNull(this.root)) {
                    return false;
                }
                if(this._pMeshNode == null) {
                    this._pMeshNode = this.root.scene.createModel();
                    this._pMeshNode.setInheritance(2 /* ALL */ );
                    this._pMeshNode.attachToParent(this.root);
                }
                this._pMeshNode.name = this.name + "[mesh-container]";
                this._pMeshNode.mesh = (pMesh);
                return true;
            };
            Skeleton.prototype.detachMesh = function /** @no-inline */() {
                //TODO: write detach method.
                            };
            return Skeleton;
        })();        
        function /** @no-inline */createSkeleton(sName) {
            if (typeof sName === "undefined") { sName = null; }
            return new Skeleton(sName);
        }
        model.createSkeleton = createSkeleton;
    })(akra.model || (akra.model = {}));
    var model = akra.model;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    (function (EAnimationInterpolations) {
        EAnimationInterpolations._map = [];
        EAnimationInterpolations._map[0] = "MATRIX_LINEAR";
        EAnimationInterpolations.MATRIX_LINEAR = 0;
        EAnimationInterpolations._map[1] = "LINEAR";
        EAnimationInterpolations.LINEAR = 1;
    })(akra.EAnimationInterpolations || (akra.EAnimationInterpolations = {}));
    var EAnimationInterpolations = akra.EAnimationInterpolations;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (animation) {
        var AnimationFrame = (function () {
            function /** @no-inline */AnimationFrame(fTime, pMatrix, fWeight) {
                this.time = 0.0;
                this.weight = 1.0;
                this.matrix = null;
                this.rotation = new akra.Quat4();
                this.scale = new akra.Vec3();
                this.translation = new akra.Vec3();
                switch(arguments.length) {
                    case 0:
                        this.matrix = new akra.Mat4();
                        return;
                    case 3:
                        this.weight = fWeight;
                    case 2:
                        this.matrix = pMatrix;
                    case 1:
                        this.time = fTime;
                }
                ;
                this.matrix.decompose(this.rotation, this.scale, this.translation);
            }
            AnimationFrame.prototype.toMatrix = function /** @no-inline */() {
                return this.rotation.toMat4(this.matrix).setTranslation(this.translation).scaleRight(this.scale);
            };
            AnimationFrame.prototype.toMatrixFromMatrix = function /** @no-inline */() {
                return this.matrix;
            };
            AnimationFrame.prototype.reset = function /** @no-inline */() {
                this.weight = 0.0;
                this.time = 0.0;
                var pData = this.matrix.data;
                pData[0] = pData[4] = pData[8] = pData[12] = pData[1] = pData[5] = pData[9] = pData[13] = pData[2] = pData[6] = pData[10] = pData[14] = pData[3] = pData[7] = pData[11] = pData[15] = 0;
                this.rotation.x = this.rotation.y = this.rotation.z = 0;
                this.rotation.w = 1.0;
                this.translation.x = this.translation.y = this.translation.z = 0;
                this.scale.x = this.scale.y = this.scale.z = 0;
                return this;
            };
            AnimationFrame.prototype.set = function /** @no-inline */(pFrame) {
                //FIXME: расписать побыстрее
                this.matrix.set(pFrame.matrix);
                this.rotation.set(pFrame.rotation);
                this.scale.set(pFrame.scale);
                this.translation.set(pFrame.translation);
                this.time = pFrame.time;
                this.weight = pFrame.weight;
            };
            AnimationFrame.prototype.add = /**
            * Добавить данные к фрейму с их весом.
            * После данного метода фрейму потребуется нормализация!!!!
            */
            function /** @no-inline */(pFrame, isFirst) {
                var fWeight = pFrame.weight;
                this.scale.x += pFrame.scale.x * fWeight;
                this.scale.y += pFrame.scale.y * fWeight;
                this.scale.z += pFrame.scale.z * fWeight;
                this.translation.x += pFrame.translation.x * fWeight;
                this.translation.y += pFrame.translation.y * fWeight;
                this.translation.z += pFrame.translation.z * fWeight;
                this.weight += fWeight;
                if(!isFirst) {
                    this.rotation.smix(pFrame.rotation, fWeight / this.weight);
                } else {
                    this.rotation.set(pFrame.rotation);
                }
                return this;
            };
            AnimationFrame.prototype.addMatrix = function /** @no-inline */(pFrame) {
                var pMatData = pFrame.matrix.data;
                var fWeight = pFrame.weight;
                var pResData = this.matrix.data;
                for(var i = 0; i < 16; ++i) {
                    pResData[i] += pMatData[i] * fWeight;
                }
                this.weight += fWeight;
                return this;
            };
            AnimationFrame.prototype.mult = function /** @no-inline */(fScalar) {
                this.weight *= fScalar;
                return this;
            };
            AnimationFrame.prototype.normilize = function /** @no-inline */() {
                var fScalar = 1.0 / this.weight;
                this.scale.x *= fScalar;
                this.scale.y *= fScalar;
                this.scale.z *= fScalar;
                this.translation.x *= fScalar;
                this.translation.y *= fScalar;
                this.translation.z *= fScalar;
                return this;
            };
            AnimationFrame.prototype.normilizeMatrix = function /** @no-inline */() {
                var fScalar = 1.0 / this.weight;
                var pData = this.matrix.data;
                pData[0] *= fScalar;
                pData[4] *= fScalar;
                pData[8] *= fScalar;
                pData[12] *= fScalar;
                pData[1] *= fScalar;
                pData[5] *= fScalar;
                pData[9] *= fScalar;
                pData[13] *= fScalar;
                pData[2] *= fScalar;
                pData[6] *= fScalar;
                pData[10] *= fScalar;
                pData[14] *= fScalar;
                pData[3] *= fScalar;
                pData[7] *= fScalar;
                pData[11] *= fScalar;
                pData[15] *= fScalar;
                return this;
            };
            AnimationFrame.prototype.interpolate = function /** @no-inline */(pStartFrame, pEndFrame, fBlend) {
                var pResultData = this.matrix.data;
                var pStartData = pStartFrame.matrix.data;
                var pEndData = pEndFrame.matrix.data;
                var fBlendInv = 1. - fBlend;
                for(var i = 0; i < 16; i++) {
                    pResultData[i] = pEndData[i] * fBlend + pStartData[i] * fBlendInv;
                }
                ;
            };
            AnimationFrame.prototype.interpolateMatrix = function /** @no-inline */(pStartFrame, pEndFrame, fBlend) {
                var pResultData = this.matrix.data;
                var pStartData = pStartFrame.matrix.data;
                var pEndData = pEndFrame.matrix.data;
                var fBlendInv = 1. - fBlend;
                for(var i = 0; i < 16; i++) {
                    pResultData[i] = pEndData[i] * fBlend + pStartData[i] * fBlendInv;
                }
                ;
            };
            Object.defineProperty(AnimationFrame, "stackCeil", {
                get: function /** @no-inline */() {
                    AnimationFrame.stackPosition = AnimationFrame.stackPosition === AnimationFrame.stackSize - 1 ? 0 : AnimationFrame.stackPosition;
                    return AnimationFrame.stack[AnimationFrame.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            AnimationFrame.stackSize = 4 * 4096;
            AnimationFrame.stackPosition = 0;
            AnimationFrame.stack = (function /** @no-inline */() {
                var pStack = new Array(AnimationFrame.stackSize);
                for(var i = 0; i < AnimationFrame.stackSize; i++) {
                    pStack[i] = new AnimationFrame();
                }
                return pStack;
            })();
            return AnimationFrame;
        })();
        animation.AnimationFrame = AnimationFrame;        
        function /** @no-inline */animationFrame() {
            return null;
        }
        animation.animationFrame = animationFrame;
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (animation) {
        var AnimationTrack = (function () {
            function /** @no-inline */AnimationTrack(sTarget) {
                if (typeof sTarget === "undefined") { sTarget = null; }
                this._sTarget = null;
                this._pTarget = null;
                this._pKeyFrames = [];
                this._eInterpolationType = 0 /* MATRIX_LINEAR */ ;
                this._sTarget = sTarget;
            }
            Object.defineProperty(AnimationTrack.prototype, "target", {
                get: function /** @inline */() {
                    return this._pTarget;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AnimationTrack.prototype, "targetName", {
                get: function /** @inline */() {
                    return this._sTarget;
                },
                set: function /** @inline */(sValue) {
                    this._sTarget = sValue;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AnimationTrack.prototype, "duration", {
                get: function /** @inline */() {
                    return this._pKeyFrames.last.fTime;
                },
                enumerable: true,
                configurable: true
            });
            AnimationTrack.prototype.keyFrame = function /** @no-inline */(fTime, pMatrix) {
                var pFrame;
                var iFrame;
                var pKeyFrames = this._pKeyFrames;
                var nTotalFrames = pKeyFrames.length;
                if(arguments.length > 1) {
                    pFrame = new akra.animation.AnimationFrame(fTime, pMatrix);
                } else {
                    pFrame = arguments[0];
                }
                if(nTotalFrames && (iFrame = this.findKeyFrame(pFrame.time)) >= 0) {
                    pKeyFrames.splice(iFrame, 0, pFrame);
                } else {
                    pKeyFrames.push(pFrame);
                }
                return true;
            };
            AnimationTrack.prototype.getKeyFrame = function /** @no-inline */(iFrame) {
                akra.logger.setSourceLocation("animation/AnimationTrack.ts", 65);
                akra.logger.assert(iFrame < this._pKeyFrames.length, 'iFrame must be less then number of total jey frames.');
                ;
                return this._pKeyFrames[iFrame];
            };
            AnimationTrack.prototype.findKeyFrame = function /** @no-inline */(fTime) {
                var pKeyFrames = this._pKeyFrames;
                var nTotalFrames = pKeyFrames.length;
                if(pKeyFrames[nTotalFrames - 1].time == fTime) {
                    return nTotalFrames - 1;
                } else {
                    for(var i = nTotalFrames - 1; i >= 0; i--) {
                        if(pKeyFrames[i].time > fTime && pKeyFrames[i - 1].time <= fTime) {
                            return i - 1;
                        }
                    }
                }
                return -1;
            };
            AnimationTrack.prototype.bind = function /** @no-inline */(pJoint, pSkeleton) {
                var pNode = null, pRootNode;
                var sJoint;
                switch(arguments.length) {
                    case 2:
                        //bind by pair <String joint, Skeleton skeleton>
                        sJoint = pJoint;
                        this._sTarget = sJoint;
                        pNode = (pSkeleton).findJoint(sJoint);
                        break;
                    default:
                        //bind by <Skeleton skeleton>
                        if(!akra.isDef(arguments[0].type)) {
                            if(this._sTarget == null) {
                                return false;
                            }
                            pSkeleton = arguments[0];
                            pNode = (pSkeleton).findJoint(this._sTarget);
                        } else//bind by <Node node>
                         {
                            pRootNode = arguments[0];
                            pNode = pRootNode.findEntity(this.targetName);
                        }
                }
                this._pTarget = pNode;
                return akra.isDefAndNotNull(pNode);
            };
            AnimationTrack.prototype.frame = function /** @no-inline */(fTime) {
                var iKey1 = 0, iKey2 = 0;
                var fScalar;
                var fTimeDiff;
                var pKeys = this._pKeyFrames;
                var nKeys = pKeys.length;
                var pFrame = akra.animation.animationFrame();
                akra.logger.setSourceLocation("animation/AnimationTrack.ts", 137);
                akra.logger.assert(nKeys > 0, 'no frames :(');
                ;
                if(nKeys === 1) {
                    pFrame.set(pKeys[0]);
                } else {
                    //TODO: реализовать существенно более эффективный поиск кадра.
                    for(var i = 0; i < nKeys; i++) {
                        if(fTime >= this._pKeyFrames[i].time) {
                            iKey1 = i;
                        }
                    }
                    iKey2 = (iKey1 >= (nKeys - 1)) ? iKey1 : iKey1 + 1;
                    fTimeDiff = pKeys[iKey2].time - pKeys[iKey1].time;
                    if(!fTimeDiff) {
                        fTimeDiff = 1;
                    }
                    fScalar = (fTime - pKeys[iKey1].time) / fTimeDiff;
                    pFrame.interpolate(this._pKeyFrames[iKey1], this._pKeyFrames[iKey2], fScalar);
                }
                pFrame.time = fTime;
                pFrame.weight = 1.0;
                return pFrame;
            };
            return AnimationTrack;
        })();        
        function /** @no-inline */createTrack(sName) {
            if (typeof sName === "undefined") { sName = null; }
            return new AnimationTrack(sName);
        }
        animation.createTrack = createTrack;
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (animation) {
        var AnimationBase = (function () {
            function /** @no-inline */AnimationBase() {
                /**@protected*/ this._pTargetMap = {
                };
                /**@protected*/ this._pTargetList = [];
                /**@protected*/ this._fDuration = 0.0;
                this._iGuid = eval("this._iGuid || akra.sid()");
                this._pUnicastSlotMap = null;
                this._pBroadcastSlotList = null;
                this._sName = ("animation-" + akra.now() + "-" + this.getGuid());
            }
            Object.defineProperty(AnimationBase.prototype, "duration", {
                get: function /** @inline */() {
                    return this._fDuration;
                },
                set: function /** @inline */(fValue) {
                    this._fDuration = fValue;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AnimationBase.prototype, "name", {
                get: function /** @inline */() {
                    return this._sName;
                },
                set: function /** @inline */(sName) {
                    this._sName = sName;
                },
                enumerable: true,
                configurable: true
            });
            AnimationBase.prototype.play = function /** @no-inline */(fRealTime) {
                this.onplay(fRealTime);
            };
            AnimationBase.prototype.stop = function /** @no-inline */(fRealTime) {
                this.onstop(fRealTime);
            };
            AnimationBase.prototype.attach = function /** @no-inline */(pTarget) {
                akra.logger.setSourceLocation("AnimationBase.ts", 54);
                akra.logger.error("method AnimationBase::bind() must be overwritten.");
                ;
            };
            AnimationBase.prototype.frame = function /** @no-inline */(sName, fRealTime) {
                return null;
            };
            AnimationBase.prototype.apply = function /** @no-inline */(fRealTime) {
                var pTargetList = this._pTargetList;
                var pTarget;
                var pFrame;
                var pTransform;
                for(var i = 0; i < pTargetList.length; ++i) {
                    pFrame = this.frame(pTargetList[i].name, fRealTime);
                    pTarget = pTargetList[i].target;
                    if(!pFrame || !pTarget) {
                        continue;
                    }
                    pTransform = pFrame.toMatrix();
                    pTarget.localMatrix.set(pTransform);
                }
                ;
            };
            AnimationBase.prototype.addTarget = function /** @no-inline */(sName, pTarget) {
                if (typeof pTarget === "undefined") { pTarget = null; }
                //pTarget = pTarget || null;
                var pPointer = this._pTargetMap[sName];
                if(pPointer) {
                    pPointer.target = pTarget || pPointer.target || null;
                    return pPointer;
                }
                pPointer = {
                    target: pTarget,
                    index: this._pTargetList.length,
                    name: sName
                };
                this._pTargetList.push(pPointer);
                this._pTargetMap[sName] = pPointer;
                return pPointer;
            };
            AnimationBase.prototype.setTarget = function /** @no-inline */(sName, pTarget) {
                var pPointer = this._pTargetMap[sName];
                pPointer.target = pTarget;
                return pPointer;
            };
            AnimationBase.prototype.getTarget = function /** @no-inline */(sTargetName) {
                return this._pTargetMap[sTargetName];
            };
            AnimationBase.prototype.getTargetList = function /** @inline */() {
                return this._pTargetList;
            };
            AnimationBase.prototype.getTargetByName = function /** @inline */(sName) {
                return this._pTargetMap[sName];
            };
            AnimationBase.prototype.targetNames = function /** @no-inline */() {
                var pTargets = this._pTargetList;
                var pTargetNames = [];
                for(var i = 0; i < pTargets.length; ++i) {
                    pTargetNames.push(pTargets[i].name);
                }
                return pTargetNames;
            };
            AnimationBase.prototype.targetList = function /** @no-inline */() {
                var pTargets = this._pTargetList;
                var pTargetList = [];
                for(var i = 0; i < pTargets.length; ++i) {
                    pTargetList.push(pTargets[i].target);
                }
                return pTargetList;
            };
            AnimationBase.prototype.jointList = function /** @no-inline */() {
                var pTargets = this._pTargetList;
                var pJointList = [];
                for(var i = 0; i < pTargets.length; ++i) {
                    if(akra.scene.isJoint(pTargets[i].target)) {
                        pJointList.push(pTargets[i].target);
                    }
                }
                return pJointList;
            };
            AnimationBase.prototype.grab = function /** @no-inline */(pAnimationBase, bRewrite) {
                if (typeof bRewrite === "undefined") { bRewrite = true; }
                var pAdoptTargets = pAnimationBase.getTargetList();
                for(var i = 0; i < pAdoptTargets.length; ++i) {
                    if(!pAdoptTargets[i].target) {
                        //warning('cannot grab target <' + pAdoptTargets[i].name + '>, becaus "target" is null');
                        continue;
                    }
                    if(bRewrite || !this.getTarget(pAdoptTargets[i].name)) {
                        this.addTarget(pAdoptTargets[i].name, pAdoptTargets[i].target);
                    }
                }
                ;
            };
            AnimationBase.prototype.createAnimationMask = function /** @no-inline */() {
                var pTargets = this.targetNames();
                var pMask = {
                };
                for(var i = 0; i < pTargets.length; ++i) {
                    pMask[pTargets[i]] = 1.0;
                }
                return pMask;
            };
            AnimationBase._pEventTable = new akra.events.EventTable();
            AnimationBase.prototype.getEventTable = function /** @inline */() {
                return AnimationBase._pEventTable;
            };
            AnimationBase.prototype.getGuid = function /** @no-inline */() {
                return this._iGuid < 0 ? (this._iGuid = akra.sid()) : this._iGuid;
            };
            AnimationBase.prototype.connect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            AnimationBase.prototype.disconnect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            AnimationBase.prototype.bind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType);
            };
            AnimationBase.prototype.unbind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType);
            };
            AnimationBase.prototype.onplay = function /** @no-inline */(fRealTime) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).onplay;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, fRealTime) : _broadcast[i].listener(_recivier, fRealTime);
                    }
                }
            };
            AnimationBase.prototype.onstop = function /** @no-inline */(fRealTime) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).onstop;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, fRealTime) : _broadcast[i].listener(_recivier, fRealTime);
                    }
                }
            };
            return AnimationBase;
        })();
        animation.AnimationBase = AnimationBase;        
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (animation) {
        var Animation = (function (_super) {
            __extends(Animation, _super);
            function /** @no-inline */Animation(sName) {
                if (typeof sName === "undefined") { sName = null; }
                        _super.call(this);
                this._pTracks = [];
                this.name = sName;
            }
            Object.defineProperty(Animation.prototype, "totalTracks", {
                get: function /** @inline */() {
                    return this._pTracks.length;
                },
                enumerable: true,
                configurable: true
            });
            Animation.prototype.push = function /** @no-inline */(pTrack) {
                this._pTracks.push(pTrack);
                this._fDuration = Math.max(this._fDuration, pTrack.duration);
                this.addTarget(pTrack.targetName);
            };
            Animation.prototype.attach = function /** @no-inline */(pTarget) {
                var pPointer;
                var pTracks = this._pTracks;
                for(var i = 0; i < pTracks.length; ++i) {
                    if(!pTracks[i].bind(pTarget)) {
                        akra.logger.setSourceLocation("animation/Animation.ts", 36);
                        akra.logger.log("cannot bind animation track [", i, "] to joint <", pTracks[i].target, ">");
                        ;
                    } else {
                        pPointer = this.setTarget(pTracks[i].targetName, pTracks[i].target);
                        pPointer.track = pTracks[i];
                    }
                }
                ;
            };
            Animation.prototype.getTracks = function /** @no-inline */() {
                return this._pTracks;
            };
            Animation.prototype.frame = function /** @no-inline */(sName, fTime) {
                var pPointer = this.getTargetByName(sName);
                if(!pPointer || !pPointer.track) {
                    return null;
                }
                return pPointer.track.frame(akra.math.clamp(fTime, 0, this._fDuration));
            };
            Animation.prototype.extend = function /** @no-inline */(pAnimation) {
                var pTracks = pAnimation.getTracks();
                for(var i = 0; i < pTracks.length; ++i) {
                    if(!this.getTarget(pTracks[i].targetName)) {
                        this.push(pTracks[i]);
                    }
                }
            };
            return Animation;
        })(animation.AnimationBase);        
        function /** @no-inline */createAnimation(sName) {
            if (typeof sName === "undefined") { sName = null; }
            return new Animation(sName);
        }
        animation.createAnimation = createAnimation;
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var Pathinfo = (function () {
            function /** @no-inline */Pathinfo(pPath) {
                this._sDirname = null;
                this._sExtension = null;
                this._sFilename = null;
                if(akra.isDef(pPath)) {
                    this.set(pPath);
                }
            }
            Object.defineProperty(Pathinfo.prototype, "path", {
                get: function /** @inline */() {
                    return this.toString();
                },
                set: function /** @inline */(sPath) {
                    this.set(sPath);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Pathinfo.prototype, "dirname", {
                get: function /** @inline */() {
                    return this._sDirname;
                },
                set: function /** @inline */(sDirname) {
                    this._sDirname = sDirname;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Pathinfo.prototype, "filename", {
                get: function /** @inline */() {
                    return this._sFilename;
                },
                set: function /** @inline */(sFilename) {
                    this._sFilename = sFilename;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Pathinfo.prototype, "ext", {
                get: function /** @inline */() {
                    return this._sExtension;
                },
                set: function /** @inline */(sExtension) {
                    this._sExtension = sExtension;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Pathinfo.prototype, "basename", {
                get: function /** @inline */() {
                    return (this._sFilename ? this._sFilename + (this._sExtension ? "." + this._sExtension : "") : "");
                },
                set: function /** @inline */(sBasename) {
                    var nPos = sBasename.lastIndexOf(".");
                    if(nPos < 0) {
                        this._sFilename = sBasename.substr(0);
                        this._sExtension = null;
                    } else {
                        this._sFilename = sBasename.substr(0, nPos);
                        this._sExtension = sBasename.substr(nPos + 1);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Pathinfo.prototype.set = function /** @no-inline */(sPath) {
                if(akra.isString(sPath)) {
                    var pParts = sPath.replace('\\', '/').split('/');
                    this.basename = pParts.pop();
                    this._sDirname = pParts.join('/');
                } else if(sPath instanceof Pathinfo) {
                    this._sDirname = sPath.dirname;
                    this._sFilename = sPath.filename;
                    this._sExtension = sPath.ext;
                } else {
                    //critical_error
                    util.logger.setSourceLocation("Pathinfo.ts", 68);
                    util.logger.error("Unexpected data type was used.");
                    ;
                }
            };
            Pathinfo.prototype.isAbsolute = function /** @no-inline */() {
                return this._sDirname[0] === "/";
            };
            Pathinfo.prototype.toString = function /** @no-inline */() {
                return (this._sDirname ? this._sDirname + "/" : "") + (this.basename);
            };
            return Pathinfo;
        })();
        util.Pathinfo = Pathinfo;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.Pathinfo = akra.util.Pathinfo;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var URI = (function () {
            function /** @no-inline */URI(pUri) {
                this.sScheme = null;
                this.sUserinfo = null;
                this.sHost = null;
                this.nPort = 0;
                this.sPath = null;
                this.sQuery = null;
                this.sFragment = null;
                if(pUri) {
                    this.set(pUri);
                }
            }
            Object.defineProperty(URI.prototype, "urn", {
                get: function /** @no-inline */() {
                    return (this.sPath ? this.sPath : "") + (this.sQuery ? '?' + this.sQuery : "") + (this.sFragment ? '#' + this.sFragment : "");
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "url", {
                get: function /** @no-inline */() {
                    return (this.sScheme ? this.sScheme : "") + this.authority;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "authority", {
                get: function /** @no-inline */() {
                    return (this.sHost ? '//' + (this.sUserinfo ? this.sUserinfo + '@' : "") + this.sHost + (this.nPort ? ':' + this.nPort : "") : "");
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "scheme", {
                get: function /** @inline */() {
                    return this.sScheme;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "protocol", {
                get: function /** @no-inline */() {
                    if(!this.sScheme) {
                        return this.sScheme;
                    }
                    return (this.sScheme.substr(0, this.sScheme.lastIndexOf(':')));
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "userinfo", {
                get: function /** @inline */() {
                    return this.sUserinfo;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "host", {
                get: function /** @inline */() {
                    return this.sHost;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "port", {
                get: function /** @inline */() {
                    return this.nPort;
                },
                set: function /** @inline */(iPort) {
                    this.nPort = iPort;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "path", {
                get: function /** @inline */() {
                    return this.sPath;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "query", {
                get: function /** @inline */() {
                    return this.sQuery;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(URI.prototype, "fragment", {
                get: function /** @inline */() {
                    return this.sFragment;
                },
                enumerable: true,
                configurable: true
            });
            URI.prototype.set = function /** @no-inline */(pData) {
                if(akra.isString(pData)) {
                    var pUri = URI.uriExp.exec(pData);
                    util.logger.setSourceLocation("URI.ts", 86);
                    util.logger.assert(pUri !== null, 'Invalid URI format used.\nused uri: ' + pData);
                    ;
                    if(!pUri) {
                        return null;
                    }
                    this.sScheme = pUri[1] || null;
                    this.sUserinfo = pUri[2] || null;
                    this.sHost = pUri[3] || null;
                    this.nPort = parseInt(pUri[4]) || null;
                    this.sPath = pUri[5] || pUri[6] || null;
                    this.sQuery = pUri[7] || null;
                    this.sFragment = pUri[8] || null;
                    return this;
                } else if(pData instanceof URI) {
                    return this.set(pData.toString());
                }
                util.logger.setSourceLocation("URI.ts", 107);
                util.logger.error('Unexpected data type was used.');
                ;
                return null;
            };
            URI.prototype.toString = function /** @no-inline */() {
                return this.url + this.urn;
            };
            URI.uriExp = new RegExp("^([a-z0-9+.-]+:)?(?:\\/\\/(?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(?::(\\d*))?(\\/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?|(\\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})*(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?)(?:\\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?(?:#((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?$", "i");
            return URI;
        })();
        util.URI = URI;        
        /*
        composed as follows:
        ^
        ([a-z0-9+.-]+):							#scheme
        (?:
        //							#it has an authority:
        (?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?	#userinfo
        ((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)		#host
        (?::(\d*))?						#port
        (/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?	#path
        |
        #it doesn't have an authority:
        (/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})+(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?	#path
        )
        (?:
        \?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)	#query string
        )?
        (?:
        #((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)	#fragment
        )?
        $
        */
            })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    // #include "ReferenceCounter.ts"
    // #include "Singleton.ts"
    // #include "BrowserInfo.ts"
    // #include "ApiInfo.ts"
    // #include "ScreenInfo.ts"
    // #include "DeviceInfo.ts"
    // #include "UtilTimer.ts"
    // #include "Entity.ts"
    // #include "ThreadManager.ts"
    (function (util) {
        util.uri = function /** @inline */(sUri) {
            return new akra.util.URI(sUri);
        };
        // export var pathinfo: (sPath: string) => IPathinfo;
        // export var pathinfo: (pPath: IPathinfo) => IPathinfo;
        util.pathinfo;
        util.pathinfo = function /** @no-inline */(pPath) {
            return new util.Pathinfo(pPath);
        };
        //string to array buffer
        util.stoab = function /** @no-inline */(s) {
            var len = s.length;
            var pCodeList = new Array(len);
            for(var i = 0; i < len; ++i) {
                /*& 0xFF;*/
                pCodeList[i] = s.charCodeAt(i);
            }
            return (new Uint8Array(pCodeList)).buffer;
        };
        util.abtos = function /** @no-inline */(pBuf) {
            var pData = new Uint8Array(pBuf);
            var s = "";
            for(var n = 0; n < pData.length; ++n) {
                s += String.fromCharCode(pData[n]);
            }
            return s;
        };
        function /** @no-inline */abtota(pBuffer, eType) {
            switch(eType) {
                case 5126 /* FLOAT */ :
                    return new Float32Array(pBuffer);
                case 5122 /* SHORT */ :
                    return new Int16Array(pBuffer);
                case 5123 /* UNSIGNED_SHORT */ :
                    return new Uint16Array(pBuffer);
                case 5124 /* INT */ :
                    return new Int32Array(pBuffer);
                case 5125 /* UNSIGNED_INT */ :
                    return new Uint32Array(pBuffer);
                case 5120 /* BYTE */ :
                    return new Int8Array(pBuffer);
                default:
                case 5121 /* UNSIGNED_BYTE */ :
                    return new Uint8Array(pBuffer);
            }
        }
        util.abtota = abtota;
        function /** @no-inline */parseJSON(sJSON) {
            return eval('(' + sJSON + ')');
        }
        util.parseJSON = parseJSON;
        ;
        /**
        * Преобразование html-сформированного текста
        * в dom.
        */
        function /** @no-inline */parseHTML(sHTML, useDocFragment) {
            if (typeof useDocFragment === "undefined") { useDocFragment = true; }
            var pDivEl = document.createElement('div');
            var pDocFrag;
            pDivEl.innerHTML = sHTML;
            if(!useDocFragment) {
                return pDivEl.childNodes;
            }
            pDocFrag = document.createDocumentFragment();
            for(var i = 0, len = pDivEl.childNodes.length; i < len; ++i) {
                if(!akra.isDef(pDivEl.childNodes[i])) {
                    continue;
                }
                pDocFrag.appendChild(pDivEl.childNodes[i]);
            }
            return pDocFrag;
        }
        util.parseHTML = parseHTML;
        ;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var Singleton = (function () {
            function /** @no-inline */Singleton() {
                var _constructor = (this).constructor;
                util.logger.setSourceLocation("Singleton.ts", 10);
                util.logger.assert(!akra.isDef(_constructor._pInstance), 'Singleton class may be created only one time.');
                ;
                _constructor._pInstance = this;
            }
            return Singleton;
        })();
        util.Singleton = Singleton;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var BrowserInfo = (function (_super) {
            __extends(BrowserInfo, _super);
            function BrowserInfo() {
                _super.apply(this, arguments);

                this.sBrowser = null;
                this.sVersion = null;
                this.sOS = null;
                this.sVersionSearch = null;
            }
            Object.defineProperty(BrowserInfo.prototype, "name", {
                get: function /** @no-inline */() {
                    return this.sBrowser;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BrowserInfo.prototype, "version", {
                get: function /** @no-inline */() {
                    return this.sVersion;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BrowserInfo.prototype, "os", {
                get: function /** @no-inline */() {
                    return this.sOS;
                },
                enumerable: true,
                configurable: true
            });
            BrowserInfo.prototype.init = function /** @no-inline */() {
                this.sBrowser = this.searchString(BrowserInfo.dataBrowser) || "An unknown browser";
                this.sVersion = this.searchVersion(navigator.userAgent) || this.searchVersion(navigator.appVersion) || "an unknown version";
                this.sOS = this.searchString(BrowserInfo.dataOS) || "an unknown OS";
            };
            BrowserInfo.prototype.searchString = function /** @no-inline */(pDataBrowser) {
                for(var i = 0; i < pDataBrowser.length; i++) {
                    var sData = pDataBrowser[i].string;
                    var dataProp = pDataBrowser[i].prop;
                    this.sVersionSearch = pDataBrowser[i].versionSearch || pDataBrowser[i].identity;
                    if(sData) {
                        if(sData.indexOf(pDataBrowser[i].subString) != -1) {
                            return pDataBrowser[i].identity;
                        }
                    } else if(dataProp) {
                        return pDataBrowser[i].identity;
                    }
                }
                return null;
            };
            BrowserInfo.prototype.searchVersion = function /** @no-inline */(sData) {
                var iStartIndex = sData.indexOf(this.sVersionSearch);
                if(iStartIndex == -1) {
                    return null;
                }
                iStartIndex = sData.indexOf('/', iStartIndex + 1);
                if(iStartIndex == -1) {
                    return null;
                }
                var iEndIndex = sData.indexOf(' ', iStartIndex + 1);
                if(iEndIndex == -1) {
                    iEndIndex = sData.indexOf(';', iStartIndex + 1);
                    if(iEndIndex == -1) {
                        return null;
                    }
                    return sData.slice(iStartIndex + 1);
                }
                return sData.slice((iStartIndex + 1), iEndIndex);
            };
            BrowserInfo.dataBrowser = [
                {
                    string: navigator.userAgent,
                    subString: "Chrome",
                    identity: "Chrome"
                }, 
                {
                    string: navigator.userAgent,
                    subString: "OmniWeb",
                    versionSearch: "OmniWeb/",
                    identity: "OmniWeb"
                }, 
                {
                    string: navigator.vendor,
                    subString: "Apple",
                    identity: "Safari",
                    versionSearch: "Version"
                }, 
                {
                    prop: window.opera,
                    identity: "Opera",
                    versionSearch: "Version"
                }, 
                {
                    string: navigator.vendor,
                    subString: "iCab",
                    identity: "iCab"
                }, 
                {
                    string: navigator.vendor,
                    subString: "KDE",
                    identity: "Konqueror"
                }, 
                {
                    string: navigator.userAgent,
                    subString: "Firefox",
                    identity: "Firefox"
                }, 
                {
                    string: navigator.vendor,
                    subString: "Camino",
                    identity: "Camino"
                }, 
                {
                    string: // for newer Netscapes (6+)
                    navigator.userAgent,
                    subString: "Netscape",
                    identity: "Netscape"
                }, 
                {
                    string: navigator.userAgent,
                    subString: "MSIE",
                    identity: "Explorer",
                    versionSearch: "MSIE"
                }, 
                {
                    string: navigator.userAgent,
                    subString: "Gecko",
                    identity: "Mozilla",
                    versionSearch: "rv"
                }, 
                {
                    string: // for older Netscapes (4-)
                    navigator.userAgent,
                    subString: "Mozilla",
                    identity: "Netscape",
                    versionSearch: "Mozilla"
                }
            ];
            BrowserInfo.dataOS = [
                {
                    string: navigator.platform,
                    subString: "Win",
                    identity: "Windows"
                }, 
                {
                    string: navigator.platform,
                    subString: "Mac",
                    identity: "Mac"
                }, 
                {
                    string: navigator.userAgent,
                    subString: "iPhone",
                    identity: "iPhone/iPod"
                }, 
                {
                    string: navigator.platform,
                    subString: "Linux",
                    identity: "Linux"
                }
            ];
            return BrowserInfo;
        })(util.Singleton);
        util.BrowserInfo = BrowserInfo;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var ScreenInfo = (function () {
            function ScreenInfo() { }
            Object.defineProperty(ScreenInfo.prototype, "width", {
                get: function /** @no-inline */() {
                    return screen.width;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ScreenInfo.prototype, "height", {
                get: function /** @no-inline */() {
                    return screen.height;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ScreenInfo.prototype, "aspect", {
                get: function /** @no-inline */() {
                    return screen.width / screen.height;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ScreenInfo.prototype, "pixelDepth", {
                get: function /** @no-inline */() {
                    return screen.pixelDepth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ScreenInfo.prototype, "colorDepth", {
                get: function /** @no-inline */() {
                    return screen.colorDepth;
                },
                enumerable: true,
                configurable: true
            });
            return ScreenInfo;
        })();
        util.ScreenInfo = ScreenInfo;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
var akra;
(function (akra) {
    (function (geometry) {
        var Box = (function () {
            function /** @no-inline */Box(l, t, ff, r, b, bb) {
                if (typeof l === "undefined") { l = 0; }
                if (typeof t === "undefined") { t = 0; }
                if (typeof ff === "undefined") { ff = 0; }
                if (typeof r === "undefined") { r = 1; }
                if (typeof b === "undefined") { b = 1; }
                if (typeof bb === "undefined") { bb = 1; }
                switch(arguments.length) {
                    case 1:
                        this.left = arguments[0].left;
                        this.top = arguments[0].top;
                        this.front = arguments[0].front;
                        this.right = arguments[0].right;
                        this.bottom = arguments[0].bottom;
                        this.back = arguments[0].back;
                        break;
                    case 3:
                    case 6:
                        this.left = l;
                        this.top = t;
                        this.front = ff;
                        this.right = r;
                        this.bottom = b;
                        this.back = bb;
                        break;
                    case 4:
                        this.left = l;
                        this.top = t;
                        this.right = ff;
                        this.bottom = r;
                        this.back = 1;
                        this.front = 0;
                        break;
                    case 5:
                        akra.logger.setSourceLocation("geometry/Box.ts", 62);
                        akra.logger.error("invalid number of arguments");
                        ;
                }
                akra.logger.setSourceLocation("geometry/Box.ts", 65);
                akra.logger.assert(this.right >= this.left && this.bottom >= this.top && this.back >= this.front);
                ;
            }
            Object.defineProperty(Box.prototype, "width", {
                get: function /** @inline */() {
                    return this.right - this.left;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Box.prototype, "height", {
                get: function /** @inline */() {
                    return this.bottom - this.top;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Box.prototype, "depth", {
                get: function /** @inline */() {
                    return this.back - this.front;
                },
                enumerable: true,
                configurable: true
            });
            Box.prototype.contains = function /** @no-inline */(pDest) {
                return (pDest.left >= this.left && pDest.top >= this.top && pDest.front >= this.front && pDest.right <= this.right && pDest.bottom <= this.bottom && pDest.back <= this.back);
            };
            return Box;
        })();
        geometry.Box = Box;        
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (pixelUtil) {
        var PixelBox = (function (_super) {
            __extends(PixelBox, _super);
            function /** @no-inline */PixelBox(iWidth, iHeight, iDepth, ePixelFormat, pPixelData) {
                if (typeof pPixelData === "undefined") { pPixelData = null; }
                if(arguments.length === 0) {
                    return;
                }
                if(arguments.length >= 4) {
                                _super.call(this, 0, 0, 0, iWidth, iHeight, iDepth);
                    this.data = akra.isDef(arguments[4]) ? (arguments[4]) : null;
                    this.format = arguments[3];
                } else {
                                _super.call(this, arguments[0]);
                    this.data = arguments[2];
                    this.format = arguments[1];
                }
                this.setConsecutive();
            }
            PixelBox.prototype.setConsecutive = function /** @no-inline */() {
                this.rowPitch = this.width;
                this.slicePitch = this.width * this.height;
            };
            PixelBox.prototype.getRowSkip = function /** @no-inline */() {
                return this.rowPitch - this.width;
            };
            PixelBox.prototype.getSliceSkip = function /** @no-inline */() {
                return this.slicePitch - (this.height * this.rowPitch);
            };
            PixelBox.prototype.isConsecutive = function /** @no-inline */() {
                return this.rowPitch == this.width && this.slicePitch == this.width * this.height;
            };
            PixelBox.prototype.getConsecutiveSize = function /** @no-inline */() {
                return pixelUtil.getMemorySize(this.width, this.height, this.depth, this.format);
            };
            PixelBox.prototype.getSubBox = function /** @no-inline */(pDest) {
                if(pixelUtil.isCompressed(this.format)) {
                    if(pDest.left == this.left && pDest.top == this.top && pDest.front == this.front && pDest.right == this.right && pDest.bottom == this.bottom && pDest.back == this.back) {
                        // Entire buffer is being queried
                        return this;
                    }
                    akra.logger.setSourceLocation("PixelBox.ts", 65);
                    akra.logger.error("Cannot return subvolume of compressed PixelBuffer", "PixelBox::getSubVolume");
                    ;
                }
                if(!this.contains(pDest)) {
                    akra.logger.setSourceLocation("PixelBox.ts", 69);
                }
                akra.logger.error("Bounds out of range", "PixelBox::getSubVolume");
                ;
                var elemSize = pixelUtil.getNumElemBytes(this.format);
                // Calculate new data origin
                // Notice how we do not propagate left/top/front from the incoming box, since
                // the returned pointer is already offset
                var rval = new PixelBox(pDest.width, pDest.height, pDest.depth, this.format, (this.data).subarray(((pDest.left - this.left) * elemSize) + ((pDest.top - this.top) * this.rowPitch * elemSize) + ((pDest.front - this.front) * this.slicePitch * elemSize)));
                rval.rowPitch = this.rowPitch;
                rval.slicePitch = this.slicePitch;
                rval.format = this.format;
                return rval;
            };
            PixelBox.prototype.getColorAt = function /** @no-inline */(x, y, z) {
                var cv = new akra.Color();
                var pixelSize = pixelUtil.getNumElemBytes(this.format);
                var pixelOffset = pixelSize * (z * this.slicePitch + y * this.rowPitch + x);
                pixelUtil.unpackColour(cv, this.format, this.data.subarray(pixelOffset));
                return cv;
            };
            PixelBox.prototype.setColorAt = function /** @no-inline */(pColor, x, y, z) {
                var pixelSize = pixelUtil.getNumElemBytes(this.format);
                var pixelOffset = pixelSize * (z * this.slicePitch + y * this.rowPitch + x);
                pixelUtil.packColour(pColor, this.format, this.data.subarray(pixelOffset));
            };
            PixelBox.prototype.scale = function /** @no-inline */(pDest, eFilter) {
                if (typeof eFilter === "undefined") { eFilter = 2 /* BILINEAR */ ; }
                return false;
            };
            return PixelBox;
        })(akra.geometry.Box);
        pixelUtil.PixelBox = PixelBox;        
    })(akra.pixelUtil || (akra.pixelUtil = {}));
    var pixelUtil = akra.pixelUtil;
})(akra || (akra = {}));
var akra;
(function (akra) {
    function /** @no-inline */fillPixelFormats(pData) {
        var pPixelFormats = [];
        for(var i = 0; i < pData.length; ++i) {
            var pEl = pData[i];
            pPixelFormats.push({
                name: pEl[0],
                elemBytes: pEl[1],
                flags: pEl[2],
                componentType: pEl[3],
                componentCount: pEl[4],
                rbits: pEl[5],
                gbits: pEl[6],
                bbits: pEl[7],
                abits: pEl[8],
                rmask: pEl[9],
                gmask: pEl[10],
                bmask: pEl[11],
                amask: pEl[12],
                rshift: pEl[13],
                gshift: pEl[14],
                bshift: pEl[15],
                ashift: pEl[16]
            });
        }
        return pPixelFormats;
    }
    var pPixelFormats = fillPixelFormats([
        [
            "PF_UNKNOWN", 
            /* Bytes per element */
            0, 
            /* Flags */
            0, 
            /* Component type and count */
            0 /* BYTE */ , 
            0, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_L8", 
            /* Bytes per element */
            1, 
            /* Flags */
            32 /* LUMINANCE */  | 16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            1, 
            /* rbits, gbits, bbits, abits */
            8, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0xFF, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_L16", 
            /* Bytes per element */
            2, 
            /* Flags */
            32 /* LUMINANCE */  | 16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            1 /* SHORT */ , 
            1, 
            /* rbits, gbits, bbits, abits */
            16, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0xFFFF, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_A8", 
            /* Bytes per element */
            1, 
            /* Flags */
            1 /* HASALPHA */  | 16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            1, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            8, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0xFF, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_A4L4", 
            /* Bytes per element */
            1, 
            /* Flags */
            1 /* HASALPHA */  | 32 /* LUMINANCE */  | 16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            2, 
            /* rbits, gbits, bbits, abits */
            4, 
            0, 
            0, 
            4, 
            /* Masks and shifts */
            0x0F, 
            0, 
            0, 
            0xF0, 
            0, 
            0, 
            0, 
            4
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_BYTE_LA", 
            /* Bytes per element */
            2, 
            /* Flags */
            1 /* HASALPHA */  | 32 /* LUMINANCE */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            2, 
            /* rbits, gbits, bbits, abits */
            8, 
            0, 
            0, 
            8, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_R5G6B5", 
            /* Bytes per element */
            2, 
            /* Flags */
            16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            3, 
            /* rbits, gbits, bbits, abits */
            5, 
            6, 
            5, 
            0, 
            /* Masks and shifts */
            0xF800, 
            0x07E0, 
            0x001F, 
            0, 
            11, 
            5, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_B5G6R5", 
            /* Bytes per element */
            2, 
            /* Flags */
            16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            3, 
            /* rbits, gbits, bbits, abits */
            5, 
            6, 
            5, 
            0, 
            /* Masks and shifts */
            0x001F, 
            0x07E0, 
            0xF800, 
            0, 
            0, 
            5, 
            11, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_A4R4G4B4", 
            /* Bytes per element */
            2, 
            /* Flags */
            1 /* HASALPHA */  | 16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            4, 
            /* rbits, gbits, bbits, abits */
            4, 
            4, 
            4, 
            4, 
            /* Masks and shifts */
            0x0F00, 
            0x00F0, 
            0x000F, 
            0xF000, 
            8, 
            4, 
            0, 
            12
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_A1R5G5B5", 
            /* Bytes per element */
            2, 
            /* Flags */
            1 /* HASALPHA */  | 16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            4, 
            /* rbits, gbits, bbits, abits */
            5, 
            5, 
            5, 
            1, 
            /* Masks and shifts */
            0x7C00, 
            0x03E0, 
            0x001F, 
            0x8000, 
            10, 
            5, 
            0, 
            15, 
            
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_R8G8B8", 
            /* Bytes per element */
            // 24 bit integer -- special        3,
            /* Flags */
            16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            3, 
            /* rbits, gbits, bbits, abits */
            8, 
            8, 
            8, 
            0, 
            /* Masks and shifts */
            0xFF0000, 
            0x00FF00, 
            0x0000FF, 
            0, 
            16, 
            8, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_B8G8R8", 
            /* Bytes per element */
            // 24 bit integer -- special        3,
            /* Flags */
            16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            3, 
            /* rbits, gbits, bbits, abits */
            8, 
            8, 
            8, 
            0, 
            /* Masks and shifts */
            0x0000FF, 
            0x00FF00, 
            0xFF0000, 
            0, 
            0, 
            8, 
            16, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_A8R8G8B8", 
            /* Bytes per element */
            4, 
            /* Flags */
            1 /* HASALPHA */  | 16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            4, 
            /* rbits, gbits, bbits, abits */
            8, 
            8, 
            8, 
            8, 
            /* Masks and shifts */
            0x00FF0000, 
            0x0000FF00, 
            0x000000FF, 
            0xFF000000, 
            16, 
            8, 
            0, 
            24
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_A8B8G8R8", 
            /* Bytes per element */
            4, 
            /* Flags */
            1 /* HASALPHA */  | 16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            4, 
            /* rbits, gbits, bbits, abits */
            8, 
            8, 
            8, 
            8, 
            /* Masks and shifts */
            0x000000FF, 
            0x0000FF00, 
            0x00FF0000, 
            0xFF000000, 
            0, 
            8, 
            16, 
            24, 
            
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_B8G8R8A8", 
            /* Bytes per element */
            4, 
            /* Flags */
            1 /* HASALPHA */  | 16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            4, 
            /* rbits, gbits, bbits, abits */
            8, 
            8, 
            8, 
            8, 
            /* Masks and shifts */
            0x0000FF00, 
            0x00FF0000, 
            0xFF000000, 
            0x000000FF, 
            8, 
            16, 
            24, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_A2R10G10B10", 
            /* Bytes per element */
            4, 
            /* Flags */
            1 /* HASALPHA */  | 16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            4, 
            /* rbits, gbits, bbits, abits */
            10, 
            10, 
            10, 
            2, 
            /* Masks and shifts */
            0x3FF00000, 
            0x000FFC00, 
            0x000003FF, 
            0xC0000000, 
            20, 
            10, 
            0, 
            30
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_A2B10G10R10", 
            /* Bytes per element */
            4, 
            /* Flags */
            1 /* HASALPHA */  | 16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            4, 
            /* rbits, gbits, bbits, abits */
            10, 
            10, 
            10, 
            2, 
            /* Masks and shifts */
            0x000003FF, 
            0x000FFC00, 
            0x3FF00000, 
            0xC0000000, 
            0, 
            10, 
            20, 
            30
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_DXT1", 
            /* Bytes per element */
            0, 
            /* Flags */
            2 /* COMPRESSED */  | 1 /* HASALPHA */ , 
            /* Component type and count */
            // No alpha        EPixelComponentTypes.BYTE, 3,
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_DXT2", 
            /* Bytes per element */
            0, 
            /* Flags */
            2 /* COMPRESSED */  | 1 /* HASALPHA */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            4, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_DXT3", 
            /* Bytes per element */
            0, 
            /* Flags */
            2 /* COMPRESSED */  | 1 /* HASALPHA */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            4, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_DXT4", 
            /* Bytes per element */
            0, 
            /* Flags */
            2 /* COMPRESSED */  | 1 /* HASALPHA */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            4, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_DXT5", 
            /* Bytes per element */
            0, 
            /* Flags */
            2 /* COMPRESSED */  | 1 /* HASALPHA */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            4, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_FLOAT16_RGB", 
            /* Bytes per element */
            6, 
            /* Flags */
            4 /* FLOAT */ , 
            /* Component type and count */
            2 /* FLOAT16 */ , 
            3, 
            /* rbits, gbits, bbits, abits */
            16, 
            16, 
            16, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_FLOAT16_RGBA", 
            /* Bytes per element */
            8, 
            /* Flags */
            4 /* FLOAT */  | 1 /* HASALPHA */ , 
            /* Component type and count */
            2 /* FLOAT16 */ , 
            4, 
            /* rbits, gbits, bbits, abits */
            16, 
            16, 
            16, 
            16, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_FLOAT32_RGB", 
            /* Bytes per element */
            12, 
            /* Flags */
            4 /* FLOAT */ , 
            /* Component type and count */
            3 /* FLOAT32 */ , 
            3, 
            /* rbits, gbits, bbits, abits */
            32, 
            32, 
            32, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_FLOAT32_RGBA", 
            /* Bytes per element */
            16, 
            /* Flags */
            4 /* FLOAT */  | 1 /* HASALPHA */ , 
            /* Component type and count */
            3 /* FLOAT32 */ , 
            4, 
            /* rbits, gbits, bbits, abits */
            32, 
            32, 
            32, 
            32, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_X8R8G8B8", 
            /* Bytes per element */
            4, 
            /* Flags */
            16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            3, 
            /* rbits, gbits, bbits, abits */
            8, 
            8, 
            8, 
            0, 
            /* Masks and shifts */
            0x00FF0000, 
            0x0000FF00, 
            0x000000FF, 
            0xFF000000, 
            16, 
            8, 
            0, 
            24
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_X8B8G8R8", 
            /* Bytes per element */
            4, 
            /* Flags */
            16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            3, 
            /* rbits, gbits, bbits, abits */
            8, 
            8, 
            8, 
            0, 
            /* Masks and shifts */
            0x000000FF, 
            0x0000FF00, 
            0x00FF0000, 
            0xFF000000, 
            0, 
            8, 
            16, 
            24
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_R8G8B8A8", 
            /* Bytes per element */
            4, 
            /* Flags */
            1 /* HASALPHA */  | 16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            4, 
            /* rbits, gbits, bbits, abits */
            8, 
            8, 
            8, 
            8, 
            /* Masks and shifts */
            0xFF000000, 
            0x00FF0000, 
            0x0000FF00, 
            0x000000FF, 
            24, 
            16, 
            8, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_DEPTH", 
            /* Bytes per element */
            4, 
            /* Flags */
            8 /* DEPTH */ , 
            /* Component type and count */
            // ?        EPixelComponentTypes.FLOAT32, 1,
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_SHORT_RGBA", 
            /* Bytes per element */
            8, 
            /* Flags */
            1 /* HASALPHA */ , 
            /* Component type and count */
            1 /* SHORT */ , 
            4, 
            /* rbits, gbits, bbits, abits */
            16, 
            16, 
            16, 
            16, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_R3G3B2", 
            /* Bytes per element */
            1, 
            /* Flags */
            16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            3, 
            /* rbits, gbits, bbits, abits */
            3, 
            3, 
            2, 
            0, 
            /* Masks and shifts */
            0xE0, 
            0x1C, 
            0x03, 
            0, 
            5, 
            2, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_FLOAT16_R", 
            /* Bytes per element */
            2, 
            /* Flags */
            4 /* FLOAT */ , 
            /* Component type and count */
            2 /* FLOAT16 */ , 
            1, 
            /* rbits, gbits, bbits, abits */
            16, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_FLOAT32_R", 
            /* Bytes per element */
            4, 
            /* Flags */
            4 /* FLOAT */ , 
            /* Component type and count */
            3 /* FLOAT32 */ , 
            1, 
            /* rbits, gbits, bbits, abits */
            32, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_SHORT_GR", 
            /* Bytes per element */
            4, 
            /* Flags */
            16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            1 /* SHORT */ , 
            2, 
            /* rbits, gbits, bbits, abits */
            16, 
            16, 
            0, 
            0, 
            /* Masks and shifts */
            0x0000FFFF, 
            0xFFFF0000, 
            0, 
            0, 
            0, 
            16, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_FLOAT16_GR", 
            /* Bytes per element */
            4, 
            /* Flags */
            4 /* FLOAT */ , 
            /* Component type and count */
            2 /* FLOAT16 */ , 
            2, 
            /* rbits, gbits, bbits, abits */
            16, 
            16, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_FLOAT32_GR", 
            /* Bytes per element */
            8, 
            /* Flags */
            4 /* FLOAT */ , 
            /* Component type and count */
            3 /* FLOAT32 */ , 
            2, 
            /* rbits, gbits, bbits, abits */
            32, 
            32, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_SHORT_RGB", 
            /* Bytes per element */
            6, 
            /* Flags */
            0, 
            /* Component type and count */
            1 /* SHORT */ , 
            3, 
            /* rbits, gbits, bbits, abits */
            16, 
            16, 
            16, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_PVRTC_RGB2", 
            /* Bytes per element */
            0, 
            /* Flags */
            2 /* COMPRESSED */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            3, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_PVRTC_RGBA2", 
            /* Bytes per element */
            0, 
            /* Flags */
            2 /* COMPRESSED */  | 1 /* HASALPHA */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            4, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_PVRTC_RGB4", 
            /* Bytes per element */
            0, 
            /* Flags */
            2 /* COMPRESSED */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            3, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_PVRTC_RGBA4", 
            /* Bytes per element */
            0, 
            /* Flags */
            2 /* COMPRESSED */  | 1 /* HASALPHA */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            4, 
            /* rbits, gbits, bbits, abits */
            0, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_R8", 
            /* Bytes per element */
            1, 
            /* Flags */
            16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            1, 
            /* rbits, gbits, bbits, abits */
            8, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0xFF0000, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_RG8", 
            /* Bytes per element */
            2, 
            /* Flags */
            16 /* NATIVEENDIAN */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            2, 
            /* rbits, gbits, bbits, abits */
            8, 
            8, 
            0, 
            0, 
            /* Masks and shifts */
            0xFF0000, 
            0x00FF00, 
            0, 
            0, 
            8, 
            0, 
            0, 
            0
        ], 
        //-----------------------------------------------------------------------
        [
            "PF_DEPTH_BYTE", 
            /* Bytes per element */
            1, 
            /* Flags */
            8 /* DEPTH */ , 
            /* Component type and count */
            0 /* BYTE */ , 
            1, 
            /* rbits, gbits, bbits, abits */
            8, 
            0, 
            0, 
            0, 
            /* Masks and shifts */
            0xFF, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0
        ], 
        
    ]);
    var _pColorValue = {
        r: 0.,
        g: 0.,
        b: 0.,
        a: 1.
    };
    (function (pixelUtil) {
        function /** @inline */getDescriptionFor(eFmt) {
            var ord = eFmt;
            akra.logger.setSourceLocation("pixelUtil/pixelUtil.ts", 696);
            akra.logger.assert(ord >= 0 && ord < 45 /* TOTAL */ );
            ;
            return pPixelFormats[ord];
        }
        pixelUtil.getDescriptionFor = getDescriptionFor;
        /** Returns the size in bytes of an element of the given pixel format.
        @return
        The size in bytes of an element. See Remarks.
        @remarks
        Passing PF_UNKNOWN will result in returning a size of 0 bytes.
        */
        function /** @inline */getNumElemBytes(eFormat) {
            return getDescriptionFor(eFormat).elemBytes;
        }
        pixelUtil.getNumElemBytes = getNumElemBytes;
        /** Returns the size in bits of an element of the given pixel format.
        @return
        The size in bits of an element. See Remarks.
        @remarks
        Passing PF_UNKNOWN will result in returning a size of 0 bits.
        */
        function /** @inline */getNumElemBits(eFormat) {
            return getDescriptionFor(eFormat).elemBytes * 8;
        }
        pixelUtil.getNumElemBits = getNumElemBits;
        /** Returns the size in memory of a region with the given extents and pixel
        format with consecutive memory layout.
        @param width
        The width of the area
        @param height
        The height of the area
        @param depth
        The depth of the area
        @param format
        The format of the area
        @return
        The size in bytes
        @remarks
        In case that the format is non-compressed, this simply returns
        width*height*depth*PixelUtil::getNumElemBytes(format). In the compressed
        case, this does serious magic.
        */
        function /** @no-inline */getMemorySize(iWidth, iHeight, iDepth, eFormat) {
            if(isCompressed(eFormat)) {
                switch(eFormat) {
                    case // DXT formats work by dividing the image into 4x4 blocks, then encoding each
                    // 4x4 block with a certain number of bytes.
                    17 /* DXT1 */ :
                        return ((iWidth + 3) / 4) * ((iHeight + 3) / 4) * 8 * iDepth;
                    case 18 /* DXT2 */ :
                    case 19 /* DXT3 */ :
                    case 20 /* DXT4 */ :
                    case 21 /* DXT5 */ :
                        return ((iWidth + 3) / 4) * ((iHeight + 3) / 4) * 16 * iDepth;
                        // Size calculations from the PVRTC OpenGL extension spec
                        // http://www.khronos.org/registry/gles/extensions/IMG/IMG_texture_compression_pvrtc.txt
                        // Basically, 32 bytes is the minimum texture size.  Smaller textures are padded up to 32 bytes
                                            case 38 /* PVRTC_RGB2 */ :
                    case 39 /* PVRTC_RGBA2 */ :
                        akra.logger.setSourceLocation("pixelUtil/pixelUtil.ts", 758);
                        akra.logger.assert(iDepth == 1);
                        ;
                        return (akra.math.max(iWidth, 16) * akra.math.max(iHeight, 8) * 2 + 7) / 8;
                    case 40 /* PVRTC_RGB4 */ :
                    case 41 /* PVRTC_RGBA4 */ :
                        akra.logger.setSourceLocation("pixelUtil/pixelUtil.ts", 762);
                        akra.logger.assert(iDepth == 1);
                        ;
                        return (akra.math.max(iWidth, 8) * akra.math.max(iHeight, 8) * 4 + 7) / 8;
                    default:
                        akra.logger.setSourceLocation("pixelUtil/pixelUtil.ts", 765);
                        akra.logger.error("Invalid compressed pixel format", "PixelUtil::getMemorySize");
                        ;
                }
            } else {
                return iWidth * iHeight * iDepth * getNumElemBytes(eFormat);
            }
        }
        pixelUtil.getMemorySize = getMemorySize;
        /** Returns the property flags for this pixel format
        @return
        A bitfield combination of PFF_HASALPHA, PFF_ISCOMPRESSED,
        PFF_FLOAT, PFF_DEPTH, PFF_NATIVEENDIAN, PFF_LUMINANCE
        @remarks
        This replaces the separate functions for formatHasAlpha, formatIsFloat, ...
        */
        function /** @inline */getFlags(eFormat) {
            return getDescriptionFor(eFormat).flags;
        }
        pixelUtil.getFlags = getFlags;
        /** Shortcut method to determine if the format has an alpha component */
        function /** @inline */hasAlpha(eFormat) {
            return (getFlags(eFormat) & 1 /* HASALPHA */ ) > 0;
        }
        pixelUtil.hasAlpha = hasAlpha;
        /** Shortcut method to determine if the format is floating point */
        function /** @inline */isFloatingPoint(eFormat) {
            return (getFlags(eFormat) & 4 /* FLOAT */ ) > 0;
        }
        pixelUtil.isFloatingPoint = isFloatingPoint;
        /** Shortcut method to determine if the format is compressed */
        function /** @inline */isCompressed(eFormat) {
            return (getFlags(eFormat) & 2 /* COMPRESSED */ ) > 0;
        }
        pixelUtil.isCompressed = isCompressed;
        /** Shortcut method to determine if the format is a depth format. */
        function /** @inline */isDepth(eFormat) {
            return (getFlags(eFormat) & 8 /* DEPTH */ ) > 0;
        }
        pixelUtil.isDepth = isDepth;
        /** Shortcut method to determine if the format is in native endian format. */
        function /** @inline */isNativeEndian(eFormat) {
            return (getFlags(eFormat) & 16 /* NATIVEENDIAN */ ) > 0;
        }
        pixelUtil.isNativeEndian = isNativeEndian;
        /** Shortcut method to determine if the format is a luminance format. */
        function /** @inline */isLuminance(eFormat) {
            return (getFlags(eFormat) & 32 /* LUMINANCE */ ) > 0;
        }
        pixelUtil.isLuminance = isLuminance;
        /** Return wether a certain image extent is valid for this image format.
        @param width
        The width of the area
        @param height
        The height of the area
        @param depth
        The depth of the area
        @param format
        The format of the area
        @remarks For non-compressed formats, this is always true. For DXT formats,
        only sizes with a width and height multiple of 4 and depth 1 are allowed.
        */
        function /** @no-inline */isValidExtent(iWidth, iHeight, iDepth, eFormat) {
            if(isCompressed(eFormat)) {
                switch(eFormat) {
                    case 17 /* DXT1 */ :
                    case 18 /* DXT2 */ :
                    case 19 /* DXT3 */ :
                    case 20 /* DXT4 */ :
                    case 21 /* DXT5 */ :
                        return ((iWidth & 3) == 0 && (iHeight & 3) == 0 && iDepth == 1);
                    default:
                        return true;
                }
            } else {
                return true;
            }
        }
        pixelUtil.isValidExtent = isValidExtent;
        /** Gives the number of bits (RGBA) for a format. See remarks.
        @remarks      For non-colour formats (dxt, depth) this returns [0,0,0,0].
        */
        function /** @no-inline */getBitDepths(eFormat) {
            /**@const*/ var des = getDescriptionFor(eFormat);
            var rgba = [];
            rgba[0] = des.rbits;
            rgba[1] = des.gbits;
            rgba[2] = des.bbits;
            rgba[3] = des.abits;
            return rgba;
        }
        pixelUtil.getBitDepths = getBitDepths;
        /** Gives the masks for the R, G, B and A component
        @note			Only valid for native endian formats
        */
        function /** @no-inline */getBitMasks(eFormat) {
            /**@const*/ var des = getDescriptionFor(eFormat);
            var rgba = [];
            rgba[0] = des.rmask;
            rgba[1] = des.gmask;
            rgba[2] = des.bmask;
            rgba[3] = des.amask;
            return rgba;
        }
        pixelUtil.getBitMasks = getBitMasks;
        /** Gives the bit shifts for R, G, B and A component
        @note			Only valid for native endian formats
        */
        function /** @no-inline */getBitShifts(eFormat) {
            /**@const*/ var des = getDescriptionFor(eFormat);
            var rgba = [];
            rgba[0] = des.rshift;
            rgba[1] = des.gshift;
            rgba[2] = des.bshift;
            rgba[3] = des.ashift;
            return rgba;
        }
        pixelUtil.getBitShifts = getBitShifts;
        /** Gets the name of an image format
        */
        function /** @inline */getFormatName(eSrcFormat) {
            return getDescriptionFor(eSrcFormat).name;
        }
        pixelUtil.getFormatName = getFormatName;
        /** Returns wether the format can be packed or unpacked with the packColour()
        and unpackColour() functions. This is generally not true for compressed and
        depth formats as they are special. It can only be true for formats with a
        fixed element size.
        @return
        true if yes, otherwise false
        */
        function /** @no-inline */isAccessible(eSrcFormat) {
            if(eSrcFormat == 0 /* UNKNOWN */ ) {
                return false;
            }
            var flags = getFlags(eSrcFormat);
            return !((flags & 2 /* COMPRESSED */ ) || (flags & 8 /* DEPTH */ ));
        }
        pixelUtil.isAccessible = isAccessible;
        /** Returns the component type for a certain pixel format. Returns PCT_BYTE
        in case there is no clear component type like with compressed formats.
        This is one of PCT_BYTE, PCT_SHORT, PCT_FLOAT16, PCT_FLOAT32.
        */
        function /** @inline */getComponentType(eFmt) {
            return getDescriptionFor(eFmt).componentType;
        }
        pixelUtil.getComponentType = getComponentType;
        /** Returns the component count for a certain pixel format. Returns 3(no alpha) or
        4 (has alpha) in case there is no clear component type like with compressed formats.
        */
        function /** @inline */getComponentCount(eFmt) {
            return getDescriptionFor(eFmt).componentCount;
        }
        pixelUtil.getComponentCount = getComponentCount;
        function /** @inline */getComponentTypeBits(eFormat) {
            var eType = getComponentType(eFormat);
            switch(eType) {
                case /*Byte per component (8 bit fixed 0.0..1.0)*/
                0 /* BYTE */ :
                    return 8;
                    /*Short per component (16 bit fixed 0.0..1.0))*/
                                    case 1 /* SHORT */ :
                    return 16;
                    /*16 bit float per component*/
                                    case 2 /* FLOAT16 */ :
                    return 16;
                    /*32 bit float per component*/
                                    case 3 /* FLOAT32 */ :
                    return 32;
            }
            return 0;
        }
        pixelUtil.getComponentTypeBits = getComponentTypeBits;
        /** Gets the format from given name.
        @param  name            The string of format name
        @param  accessibleOnly  If true, non-accessible format will treat as invalid format,
        otherwise, all supported format are valid.
        @param  caseSensitive   Should be set true if string match should use case sensitivity.
        @return                The format match the format name, or PF_UNKNOWN if is invalid name.
        */
        function /** @no-inline */getFormatFromName(sName, isAccessibleOnly, isCaseSensitive) {
            if (typeof isAccessibleOnly === "undefined") { isAccessibleOnly = false; }
            if (typeof isCaseSensitive === "undefined") { isCaseSensitive = false; }
            var tmp = sName;
            if(!isCaseSensitive) {
                // We are stored upper-case format names.
                tmp = tmp.toUpperCase();
            }
            for(var i = 0; i < 45 /* TOTAL */ ; ++i) {
                var ePf = i;
                if(!isAccessibleOnly || isAccessible(ePf)) {
                    if(tmp == getFormatName(ePf)) {
                        return ePf;
                    }
                }
            }
            return 0 /* UNKNOWN */ ;
        }
        pixelUtil.getFormatFromName = getFormatFromName;
        /** Gets the BNF expression of the pixel-formats.
        @note                   The string returned by this function is intended to be used as a BNF expression
        to work with Compiler2Pass.
        @param  accessibleOnly  If true, only accessible pixel format will take into account, otherwise all
        pixel formats list in EPixelFormats enumeration will being returned.
        @return                A string contains the BNF expression.
        */
        function /** @no-inline */getBNFExpressionOfPixelFormats(isAccessibleOnly) {
            if (typeof isAccessibleOnly === "undefined") { isAccessibleOnly = false; }
            // Collect format names sorted by length, it's required by BNF compiler
            // that similar tokens need longer ones comes first.
            var formatNames = new Array();
            for(var i = 0; i < 45 /* TOTAL */ ; ++i) {
                var ePf = (i);
                if(!isAccessibleOnly || isAccessible(ePf)) {
                    var formatName = getFormatName(ePf);
                    formatNames.push({
                        first: formatName.length,
                        second: formatName
                    });
                }
            }
            // Populate the BNF expression in reverse order
            var result = "";
            // Note: Stupid M$ VC7.1 can't dealing operator!= with FormatNameMap::const_reverse_iterator.
            for(var j in formatNames) {
                if(!akra.isEmpty(result)) {
                    result += " | ";
                }
                result += "'" + formatNames[j] + "'";
            }
            return result;
        }
        pixelUtil.getBNFExpressionOfPixelFormats = getBNFExpressionOfPixelFormats;
        /** Returns the similar format but acoording with given bit depths.
        @param fmt      The original foamt.
        @param integerBits Preferred bit depth (pixel bits) for integer pixel format.
        Available values: 0, 16 and 32, where 0 (the default) means as it is.
        @param floatBits Preferred bit depth (channel bits) for float pixel format.
        Available values: 0, 16 and 32, where 0 (the default) means as it is.
        @return        The format that similar original format with bit depth according
        with preferred bit depth, or original format if no conversion occurring.
        */
        function /** @no-inline */getFormatForBitDepths(eFmt, iIntegerBits, iFloatBits) {
            switch(iIntegerBits) {
                case 16:
                    switch(eFmt) {
                        case 10 /* R8G8B8 */ :
                        case 26 /* X8R8G8B8 */ :
                            return 6 /* R5G6B5 */ ;
                        case 11 /* B8G8R8 */ :
                        case 27 /* X8B8G8R8 */ :
                            return 7 /* B5G6R5 */ ;
                        case 12 /* A8R8G8B8 */ :
                        case 28 /* R8G8B8A8 */ :
                        case 13 /* A8B8G8R8 */ :
                        case 14 /* B8G8R8A8 */ :
                            return 8 /* A4R4G4B4 */ ;
                        case 15 /* A2R10G10B10 */ :
                        case 16 /* A2B10G10R10 */ :
                            return 9 /* A1R5G5B5 */ ;
                        default:
                            // use original image format
                            break;
                    }
                    break;
                case 32:
                    switch(eFmt) {
                        case 6 /* R5G6B5 */ :
                            return 26 /* X8R8G8B8 */ ;
                        case 7 /* B5G6R5 */ :
                            return 27 /* X8B8G8R8 */ ;
                        case 8 /* A4R4G4B4 */ :
                            return 12 /* A8R8G8B8 */ ;
                        case 9 /* A1R5G5B5 */ :
                            return 15 /* A2R10G10B10 */ ;
                        default:
                            // use original image format
                            break;
                    }
                    break;
                default:
                    // use original image format
                    break;
            }
            switch(iFloatBits) {
                case 16:
                    switch(eFmt) {
                        case 33 /* FLOAT32_R */ :
                            return 32 /* FLOAT16_R */ ;
                        case 24 /* FLOAT32_RGB */ :
                            return 22 /* FLOAT16_RGB */ ;
                        case 25 /* FLOAT32_RGBA */ :
                            return 23 /* FLOAT16_RGBA */ ;
                        default:
                            // use original image format
                            break;
                    }
                    break;
                case 32:
                    switch(eFmt) {
                        case 32 /* FLOAT16_R */ :
                            return 33 /* FLOAT32_R */ ;
                        case 22 /* FLOAT16_RGB */ :
                            return 24 /* FLOAT32_RGB */ ;
                        case 23 /* FLOAT16_RGBA */ :
                            return 25 /* FLOAT32_RGBA */ ;
                        default:
                            // use original image format
                            break;
                    }
                    break;
                default:
                    // use original image format
                    break;
            }
            return eFmt;
        }
        pixelUtil.getFormatForBitDepths = getFormatForBitDepths;
        /** Pack a colour value to memory
        @param colour	The colour
        @param pf		Pixelformat in which to write the colour
        @param dest		Destination memory location
        */
        function /** @inline */packColour(cColour, ePf, pDest) {
            packColourFloat(cColour.r, cColour.g, cColour.b, cColour.a, ePf, pDest);
        }
        pixelUtil.packColour = packColour;
        /** Pack a colour value to memory
        @param r,g,b,a	The four colour components, range 0x00 to 0xFF
        @param pf		Pixelformat in which to write the colour
        @param dest		Destination memory location
        */
        function /** @no-inline */packColourUint(r, g, b, a, ePf, pDest) {
            // if (arguments.length < 4) {
            // 	var cColour: IColor = arguments[0];
            // 	packColour(cColour.r, cColour.g, cColour.b, cColour.a, ePf, pDest);
            // 	return;
            // }
            /**@const*/ var des = getDescriptionFor(ePf);
            if(des.flags & 16 /* NATIVEENDIAN */ ) {
                // Shortcut for integer formats packing
                var value = ((akra.bf.fixedToFixed(r, 8, des.rbits) << des.rshift) & des.rmask) | ((akra.bf.fixedToFixed(g, 8, des.gbits) << des.gshift) & des.gmask) | ((akra.bf.fixedToFixed(b, 8, des.bbits) << des.bshift) & des.bmask) | ((akra.bf.fixedToFixed(a, 8, des.abits) << des.ashift) & des.amask);
                // And write to memory
                akra.bf.intWrite(pDest, des.elemBytes, value);
            } else {
                // Convert to float
                packColourFloat(r / 255.0, g / 255.0, b / 255.0, a / 255.0, ePf, pDest);
            }
        }
        pixelUtil.packColourUint = packColourUint;
        /** Pack a colour value to memory
        @param r,g,b,a	The four colour components, range 0.0f to 1.0f
        (an exception to this case exists for floating point pixel
        formats, which don't clamp to 0.0f..1.0f)
        @param pf		Pixelformat in which to write the colour
        @param dest		Destination memory location
        */
        function /** @no-inline */packColourFloat(r, g, b, a, ePf, pDest) {
            // Catch-it-all here
            /**@const*/ var des = getDescriptionFor(ePf);
            if(des.flags & 16 /* NATIVEENDIAN */ ) {
                // Do the packing
                //std::cerr << dest << " " << r << " " << g <<  " " << b << " " << a << std::endl;
                /**@const*/ var value = ((akra.bf.floatToFixed(r, des.rbits) << des.rshift) & des.rmask) | ((akra.bf.floatToFixed(g, des.gbits) << des.gshift) & des.gmask) | ((akra.bf.floatToFixed(b, des.bbits) << des.bshift) & des.bmask) | ((akra.bf.floatToFixed(a, des.abits) << des.ashift) & des.amask);
                // And write to memory
                akra.bf.intWrite(pDest, des.elemBytes, value);
            } else {
                switch(ePf) {
                    case 33 /* FLOAT32_R */ :
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 1))[0] = r;
                        break;
                    case 36 /* FLOAT32_GR */ :
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 1))[0] = g;
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 2))[1] = r;
                        break;
                    case 24 /* FLOAT32_RGB */ :
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 1))[0] = r;
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 2))[1] = g;
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 3))[2] = b;
                        break;
                    case 25 /* FLOAT32_RGBA */ :
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 1))[0] = r;
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 2))[1] = g;
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 3))[2] = b;
                        (new Float32Array(pDest.buffer, pDest.byteOffset, 4))[3] = a;
                        break;
                    case 32 /* FLOAT16_R */ :
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 1))[0] = akra.bf.floatToHalf(r);
                        break;
                    case 35 /* FLOAT16_GR */ :
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 1))[0] = akra.bf.floatToHalf(g);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 2))[1] = akra.bf.floatToHalf(r);
                        break;
                    case 22 /* FLOAT16_RGB */ :
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 1))[0] = akra.bf.floatToHalf(r);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 2))[1] = akra.bf.floatToHalf(g);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 3))[2] = akra.bf.floatToHalf(b);
                        break;
                    case 23 /* FLOAT16_RGBA */ :
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 1))[0] = akra.bf.floatToHalf(r);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 2))[1] = akra.bf.floatToHalf(g);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 3))[2] = akra.bf.floatToHalf(b);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 4))[3] = akra.bf.floatToHalf(a);
                        break;
                    case 37 /* SHORT_RGB */ :
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 1))[0] = akra.bf.floatToFixed(r, 16);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 2))[1] = akra.bf.floatToFixed(g, 16);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 3))[2] = akra.bf.floatToFixed(b, 16);
                        break;
                    case 30 /* SHORT_RGBA */ :
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 1))[0] = akra.bf.floatToFixed(r, 16);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 2))[1] = akra.bf.floatToFixed(g, 16);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 3))[2] = akra.bf.floatToFixed(b, 16);
                        (new Uint16Array(pDest.buffer, pDest.byteOffset, 4))[3] = akra.bf.floatToFixed(a, 16);
                        break;
                    case 5 /* BYTE_LA */ :
                        pDest[0] = akra.bf.floatToFixed(r, 8);
                        pDest[1] = akra.bf.floatToFixed(a, 8);
                        break;
                    default:
                        // Not yet supported
                        akra.logger.setSourceLocation("pixelUtil/pixelUtil.ts", 1208);
                        akra.logger.error("pack to " + getFormatName(ePf) + " not implemented", "PixelUtil::packColour");
                        ;
                        break;
                }
            }
        }
        pixelUtil.packColourFloat = packColourFloat;
        /** Unpack a colour value from memory
        @param colour	The colour is returned here
        @param pf		Pixelformat in which to read the colour
        @param src		Source memory location
        */
        function /** @no-inline */unpackColour(cColour, ePf, pSrc) {
            unpackColourFloat(cColour, ePf, pSrc);
        }
        pixelUtil.unpackColour = unpackColour;
        /** Unpack a colour value from memory
        @param r,g,b,a	The colour is returned here (as byte)
        @param pf		Pixelformat in which to read the colour
        @param src		Source memory location
        @remarks 	This function returns the colour components in 8 bit precision,
        this will lose precision when coming from PF_A2R10G10B10 or floating
        point formats.
        */
        function /** @no-inline */unpackColourUint(rgba, ePf, pSrc) {
            /**@const*/ var des = getDescriptionFor(ePf);
            var r = 0, g = 0, b = 0, a = 0;
            if(des.flags & 16 /* NATIVEENDIAN */ ) {
                // Shortcut for integer formats unpacking
                /**@const*/ var value = akra.bf.intRead(pSrc, des.elemBytes);
                if(des.flags & 32 /* LUMINANCE */ ) {
                    // Luminance format -- only rbits used
                    r = g = b = akra.bf.fixedToFixed((value & des.rmask) >> des.rshift, des.rbits, 8);
                } else {
                    r = akra.bf.fixedToFixed((value & des.rmask) >> des.rshift, des.rbits, 8);
                    g = akra.bf.fixedToFixed((value & des.gmask) >> des.gshift, des.gbits, 8);
                    b = akra.bf.fixedToFixed((value & des.bmask) >> des.bshift, des.bbits, 8);
                }
                if(des.flags & 1 /* HASALPHA */ ) {
                    a = akra.bf.fixedToFixed((value & des.amask) >> des.ashift, des.abits, 8);
                } else {
                    // No alpha, default a component to full	                a = 255;
                                    }
            } else {
                // Do the operation with the more generic floating point
                var pRGBA = _pColorValue;
                unpackColourFloat(pRGBA, ePf, pSrc);
                r = akra.bf.floatToFixed(pRGBA.r, 8);
                g = akra.bf.floatToFixed(pRGBA.g, 8);
                b = akra.bf.floatToFixed(pRGBA.b, 8);
                a = akra.bf.floatToFixed(pRGBA.a, 8);
            }
            rgba[0] = r;
            rgba[1] = g;
            rgba[2] = b;
            rgba[3] = a;
        }
        pixelUtil.unpackColourUint = unpackColourUint;
        /** Unpack a colour value from memory
        @param r,g,b,a	The colour is returned here (as float)
        @param pf		Pixelformat in which to read the colour
        @param src		Source memory location
        */
        function /** @no-inline */unpackColourFloat(rgba, ePf, pSrc) {
            /**@const*/ var des = getDescriptionFor(ePf);
            var r = 0., g = 0., b = 0., a = 0.;
            if(des.flags & 16 /* NATIVEENDIAN */ ) {
                // Shortcut for integer formats unpacking
                /**@const*/ var value = akra.bf.intRead(pSrc, des.elemBytes);
                if(des.flags & 32 /* LUMINANCE */ ) {
                    // Luminance format -- only rbits used
                    r = g = b = akra.bf.fixedToFloat((value & des.rmask) >> des.rshift, des.rbits);
                } else {
                    r = akra.bf.fixedToFloat((value & des.rmask) >> des.rshift, des.rbits);
                    g = akra.bf.fixedToFloat((value & des.gmask) >> des.gshift, des.gbits);
                    b = akra.bf.fixedToFloat((value & des.bmask) >> des.bshift, des.bbits);
                }
                if(des.flags & 1 /* HASALPHA */ ) {
                    a = akra.bf.fixedToFloat((value & des.amask) >> des.ashift, des.abits);
                } else {
                    // No alpha, default a component to full	                a = 1.0;
                                    }
            } else {
                switch(ePf) {
                    case 33 /* FLOAT32_R */ :
                        r = g = b = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1))[0];
                        a = 1.0;
                        break;
                    case 36 /* FLOAT32_GR */ :
                        g = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1))[0];
                        r = b = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 2))[1];
                        a = 1.0;
                        break;
                    case 24 /* FLOAT32_RGB */ :
                        r = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1))[0];
                        g = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 2))[1];
                        b = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 3))[2];
                        a = 1.0;
                        break;
                    case 25 /* FLOAT32_RGBA */ :
                        r = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1))[0];
                        g = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 2))[1];
                        b = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 3))[2];
                        a = (new Float32Array(pSrc.buffer, pSrc.byteOffset, 4))[3];
                        break;
                    case 32 /* FLOAT16_R */ :
                        r = g = b = akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1))[0]);
                        a = 1.0;
                        break;
                    case 35 /* FLOAT16_GR */ :
                        g = akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1))[0]);
                        r = b = akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2))[1]);
                        a = 1.0;
                        break;
                    case 22 /* FLOAT16_RGB */ :
                        r = akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1))[0]);
                        g = akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1))[1]);
                        b = akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2))[2]);
                        a = 1.0;
                        break;
                    case 23 /* FLOAT16_RGBA */ :
                        r = akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1))[0]);
                        g = akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2))[1]);
                        b = akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 3))[2]);
                        a = akra.bf.halfToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 4))[3]);
                        break;
                    case 37 /* SHORT_RGB */ :
                        r = akra.bf.fixedToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1))[0], 16);
                        g = akra.bf.fixedToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2))[1], 16);
                        b = akra.bf.fixedToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 3))[2], 16);
                        a = 1.0;
                        break;
                    case 30 /* SHORT_RGBA */ :
                        r = akra.bf.fixedToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1))[0], 16);
                        g = akra.bf.fixedToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2))[1], 16);
                        b = akra.bf.fixedToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 3))[2], 16);
                        a = akra.bf.fixedToFloat((new Uint16Array(pSrc.buffer, pSrc.byteOffset, 4))[3], 16);
                        break;
                    case 5 /* BYTE_LA */ :
                        r = g = b = akra.bf.fixedToFloat((pSrc)[0], 8);
                        a = akra.bf.fixedToFloat((pSrc)[1], 8);
                        break;
                    default:
                        // Not yet supported
                        akra.logger.setSourceLocation("pixelUtil/pixelUtil.ts", 1367);
                        akra.logger.error("unpack from " + getFormatName(ePf) + " not implemented", "PixelUtil::unpackColour");
                        ;
                        break;
                }
            }
            rgba.r = r;
            rgba.g = g;
            rgba.b = b;
            rgba.a = a;
        }
        pixelUtil.unpackColourFloat = unpackColourFloat;
                        function /** @no-inline */bulkPixelConversion(pSrc, eSrcFormat, pDest, eDstFormat, iCount) {
            var src = null, dst = null;
            if(arguments.length > 2) {
                src = new pixelUtil.PixelBox(iCount, 1, 1, eSrcFormat, pSrc);
                dst = new pixelUtil.PixelBox(iCount, 1, 1, eDstFormat, pDest);
            }
            akra.logger.setSourceLocation("pixelUtil/pixelUtil.ts", 1410);
            akra.logger.assert(src.width == dst.width && src.height == dst.height && src.depth == dst.depth);
            ;
            // Check for compressed formats, we don't support decompression, compression or recoding
            if(isCompressed(src.format) || isCompressed(dst.format)) {
                if(src.format == dst.format) {
                    //_memcpy(dst.data.buffer, src.data.buffer, src.getConsecutiveSize());
                    dst.data.set(src.data.subarray(0, src.getConsecutiveSize()));
                    return;
                } else {
                    akra.logger.setSourceLocation("pixelUtil/pixelUtil.ts", 1421);
                    akra.logger.error("This method can not be used to compress or decompress images", "PixelUtil::bulkPixelConversion");
                    ;
                }
            }
            // The easy case
            if(src.format == dst.format) {
                // Everything consecutive?
                if(src.isConsecutive() && dst.isConsecutive()) {
                    //_memcpy(dst.data.buffer, src.data.buffer, src.getConsecutiveSize());
                    dst.data.set(src.data.subarray(0, src.getConsecutiveSize()));
                    return;
                }
                var srcPixelSize = getNumElemBytes(src.format);
                var dstPixelSize = getNumElemBytes(dst.format);
                var srcptr = src.data.subarray((src.left + src.top * src.rowPitch + src.front * src.slicePitch) * srcPixelSize);
                var dstptr = dst.data.subarray(+(dst.left + dst.top * dst.rowPitch + dst.front * dst.slicePitch) * dstPixelSize);
                // Calculate pitches+skips in bytes
                var srcRowPitchBytes = src.rowPitch * srcPixelSize;
                //var size_t srcRowSkipBytes = src.getRowSkip()*srcPixelSize;
                var srcSliceSkipBytes = src.getSliceSkip() * srcPixelSize;
                var dstRowPitchBytes = dst.rowPitch * dstPixelSize;
                //var size_t dstRowSkipBytes = dst.getRowSkip()*dstPixelSize;
                var dstSliceSkipBytes = dst.getSliceSkip() * dstPixelSize;
                // Otherwise, copy per row
                /**@const*/ var rowSize = src.width * srcPixelSize;
                for(var z = src.front; z < src.back; z++) {
                    for(var y = src.top; y < src.bottom; y++) {
                        //_memcpy(dstptr.buffer, srcptr.buffer, rowSize);
                        dstptr.set(srcptr.subarray(0, rowSize));
                        srcptr = srcptr.subarray(srcRowPitchBytes);
                        dstptr = dstptr.subarray(dstRowPitchBytes);
                    }
                    srcptr = srcptr.subarray(srcSliceSkipBytes);
                    dstptr = dstptr.subarray(dstSliceSkipBytes);
                }
                return;
            }
            // Converting to PF_X8R8G8B8 is exactly the same as converting to
            // PF_A8R8G8B8. (same with PF_X8B8G8R8 and PF_A8B8G8R8)
            if(dst.format == 26 /* X8R8G8B8 */  || dst.format == 27 /* X8B8G8R8 */ ) {
                // Do the same conversion, with EPixelFormats.A8R8G8B8, which has a lot of
                // optimized conversions
                var tempdst = dst;
                tempdst.format = dst.format == 26 /* X8R8G8B8 */  ? 12 /* A8R8G8B8 */  : 13 /* A8B8G8R8 */ ;
                bulkPixelConversion(src, tempdst);
                return;
            }
            // Converting from EPixelFormats.X8R8G8B8 is exactly the same as converting from
            // EPixelFormats.A8R8G8B8, given that the destination format does not have alpha.
            if((src.format == 26 /* X8R8G8B8 */  || src.format == 27 /* X8B8G8R8 */ ) && !hasAlpha(dst.format)) {
                // Do the same conversion, with EPixelFormats.A8R8G8B8, which has a lot of
                // optimized conversions
                var tempsrc = src;
                tempsrc.format = src.format == 26 /* X8R8G8B8 */  ? 12 /* A8R8G8B8 */  : 13 /* A8B8G8R8 */ ;
                bulkPixelConversion(tempsrc, dst);
                return;
            }
            var srcPixelSize = getNumElemBytes(src.format);
            var dstPixelSize = getNumElemBytes(dst.format);
            var srcptr = src.data.subarray((src.left + src.top * src.rowPitch + src.front * src.slicePitch) * srcPixelSize);
            var dstptr = dst.data.subarray((dst.left + dst.top * dst.rowPitch + dst.front * dst.slicePitch) * dstPixelSize);
            // Old way, not taking into account box dimensions
            //uint8 *srcptr = static_cast<uint8*>(src.data), *dstptr = static_cast<uint8*>(dst.data);
            // Calculate pitches+skips in bytes
            var srcRowSkipBytes = src.getRowSkip() * srcPixelSize;
            var srcSliceSkipBytes = src.getSliceSkip() * srcPixelSize;
            var dstRowSkipBytes = dst.getRowSkip() * dstPixelSize;
            var dstSliceSkipBytes = dst.getSliceSkip() * dstPixelSize;
            // The brute force fallback
            // var r: float = 0, g: float = 0, b: float = 0, a: float = 1;
            var rgba = _pColorValue;
            for(var z = src.front; z < src.back; z++) {
                for(var y = src.top; y < src.bottom; y++) {
                    for(var x = src.left; x < src.right; x++) {
                        unpackColourFloat(rgba, src.format, srcptr);
                        packColourFloat(rgba.r, rgba.g, rgba.b, rgba.a, dst.format, dstptr);
                        srcptr = srcptr.subarray(srcPixelSize);
                        dstptr = dstptr.subarray(dstPixelSize);
                    }
                    srcptr = srcptr.subarray(srcRowSkipBytes);
                    dstptr = dstptr.subarray(dstRowSkipBytes);
                }
                srcptr = srcptr.subarray(srcSliceSkipBytes);
                dstptr = dstptr.subarray(dstSliceSkipBytes);
            }
        }
        pixelUtil.bulkPixelConversion = bulkPixelConversion;
        function /** @no-inline */calculateSizeForImage(nMipLevels, nFaces, iWidth, iHeight, iDepth, eFormat) {
            var iSize = 0;
            var mip = 0;
            for(mip = 0; mip <= nMipLevels; ++mip) {
                iSize += getMemorySize(iWidth, iHeight, iDepth, eFormat) * nFaces;
                if(iWidth !== 1) {
                    iWidth /= 2;
                }
                if(iHeight !== 1) {
                    iHeight /= 2;
                }
                if(iDepth !== 1) {
                    iDepth /= 2;
                }
            }
            return iSize;
        }
        pixelUtil.calculateSizeForImage = calculateSizeForImage;
    })(akra.pixelUtil || (akra.pixelUtil = {}));
    var pixelUtil = akra.pixelUtil;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        webgl.maxTextureSize = 0;
        webgl.maxCubeMapTextureSize = 0;
        webgl.maxViewPortSize = 0;
        webgl.maxTextureImageUnits = 0;
        webgl.maxVertexAttributes = 0;
        webgl.maxVertexTextureImageUnits = 0;
        webgl.maxCombinedTextureImageUnits = 0;
        webgl.maxColorAttachments = 1;
        webgl.stencilBits = 0;
        webgl.colorBits = [
            0, 
            0, 
            0
        ];
        webgl.alphaBits = 0;
        webgl.multisampleType = 0.;
        webgl.shaderVersion = 0;
        webgl.hasNonPowerOf2Textures = false;
        var pSupportedExtensionList = null;
        // var pLoadedExtensionList: Object = null;
        function /** @no-inline */setupContext(pWebGLContext) {
            var pWebGLExtentionList = {
            };
            var pWebGLExtension;
            //test context not created yet
            if(akra.isNull(pSupportedExtensionList)) {
                return pWebGLContext;
            }
            for(var i = 0; i < pSupportedExtensionList.length; ++i) {
                if(pWebGLExtension = pWebGLContext.getExtension(pSupportedExtensionList[i])) {
                    pWebGLExtentionList[pSupportedExtensionList[i]] = pWebGLExtension;
                    akra.logger.setSourceLocation("webgl/WebGL.ts", 60);
                    akra.logger.log("loaded WebGL extension: %1", pSupportedExtensionList[i]);
                    ;
                    for(var j in pWebGLExtension) {
                        if(akra.isFunction(pWebGLExtension[j])) {
                            pWebGLContext[j] = function /** @no-inline */() {
                                pWebGLContext[j] = new Function("var t = this.pWebGLExtentionList[" + pSupportedExtensionList[i] + "];" + "t." + j + ".apply(t, arguments);");
                            };
                        } else {
                            pWebGLContext[j] = pWebGLExtentionList[pSupportedExtensionList[i]][j];
                        }
                    }
                } else {
                    akra.logger.setSourceLocation("webgl/WebGL.ts", 78);
                    akra.logger.warning("cannot load extension: %1", pSupportedExtensionList[i]);
                    ;
                    pSupportedExtensionList.splice(i, 1);
                }
            }
            (pWebGLContext).pWebGLExtentionList = pWebGLExtentionList;
            // pLoadedExtensionList = pWebGLExtentionList;
            return pWebGLContext;
        }
        function /** @no-inline */createContext(pCanvas, pOptions) {
            if (typeof pCanvas === "undefined") { pCanvas = document.createElement("canvas"); }
            var pWebGLContext = null;
            try  {
                pWebGLContext = pCanvas.getContext("webgl", pOptions) || pCanvas.getContext("experimental-webgl", pOptions);
            } catch (e) {
            }
            if(akra.isDefAndNotNull(pWebGLContext)) {
                return setupContext(pWebGLContext);
            }
            akra.logger.setSourceLocation("webgl/WebGL.ts", 106);
            akra.logger.warning("cannot get 3d device");
            ;
            return null;
        }
        webgl.createContext = createContext;
        (function /** @no-inline */(pWebGLContext) {
            if(!pWebGLContext) {
                return;
            }
            webgl.maxTextureSize = pWebGLContext.getParameter(0x0D33);
            webgl.maxCubeMapTextureSize = pWebGLContext.getParameter(0x851C);
            webgl.maxViewPortSize = pWebGLContext.getParameter(0x0D3A);
            webgl.maxTextureImageUnits = pWebGLContext.getParameter(0x8872);
            webgl.maxVertexAttributes = pWebGLContext.getParameter(0x8869);
            webgl.maxVertexTextureImageUnits = pWebGLContext.getParameter(0x8B4C);
            webgl.maxCombinedTextureImageUnits = pWebGLContext.getParameter(0x8B4D);
            webgl.stencilBits = pWebGLContext.getParameter(0x0D57);
            webgl.colorBits = [
                pWebGLContext.getParameter(0x0D52), 
                pWebGLContext.getParameter(0x0D53), 
                pWebGLContext.getParameter(0x0D54)
            ];
            webgl.alphaBits = pWebGLContext.getParameter(0x0D55);
            webgl.multisampleType = pWebGLContext.getParameter(0x80AA);
            pSupportedExtensionList = pWebGLContext.getSupportedExtensions();
            pSupportedExtensionList.push("WEBGL_debug_shaders", "WEBGL_debug_renderer_info");
        })(createContext());
        function /** @no-inline */hasExtension(sExtName) {
            for(var i = 0; i < pSupportedExtensionList.length; ++i) {
                if(pSupportedExtensionList[i].search(sExtName) != -1) {
                    return true;
                }
            }
            return false;
        }
        webgl.hasExtension = hasExtension;
        function /** @no-inline */getWebGLUsage(iFlags) {
            if((((iFlags) & (2 /* DYNAMIC */ )) != 0)) {
                return 0x88E8;
            } else if((((iFlags) & (128 /* STREAM */ )) != 0)) {
                return 0x88E0;
            }
            return 0x88E4;
        }
        webgl.getWebGLUsage = getWebGLUsage;
        function /** @no-inline */getWebGLOriginFormat(eFormat) {
            switch(eFormat) {
                case 3 /* A8 */ :
                    return 0x1906;
                case 1 /* L8 */ :
                case 2 /* L16 */ :
                    return 0x1909;
                case 22 /* FLOAT16_RGB */ :
                    return webgl.hasExtension("OES_texture_half_float") ? 0x1907 : 0;
                case 23 /* FLOAT16_RGBA */ :
                    return webgl.hasExtension("OES_texture_half_float") ? 0x1908 : 0;
                case 32 /* FLOAT16_R */ :
                case 42 /* R8 */ :
                    return webgl.hasExtension("EXT_texture_rg") ? 0x1903 : 0;
                case 35 /* FLOAT16_GR */ :
                case 43 /* RG8 */ :
                    return webgl.hasExtension("EXT_texture_rg") ? 0x8227 : 0;
                case 5 /* BYTE_LA */ :
                case 34 /* SHORT_GR */ :
                    return 0x190A;
                    // PVRTC compressed formats
                                    case 38 /* PVRTC_RGB2 */ :
                    return webgl.hasExtension("WEBGL_compressed_texture_pvrtc") ? 0x8C01 : 0;
                case 40 /* PVRTC_RGB4 */ :
                    return webgl.hasExtension("WEBGL_compressed_texture_pvrtc") ? 0x8C00 : 0;
                case 39 /* PVRTC_RGBA2 */ :
                    return webgl.hasExtension("WEBGL_compressed_texture_pvrtc") ? 0x8C03 : 0;
                case 41 /* PVRTC_RGBA4 */ :
                    return webgl.hasExtension("WEBGL_compressed_texture_pvrtc") ? 0x8C02 : 0;
                case 6 /* R5G6B5 */ :
                case 7 /* B5G6R5 */ :
                case 10 /* R8G8B8 */ :
                case 11 /* B8G8R8 */ :
                    return 0x1907;
                case 9 /* A1R5G5B5 */ :
                    return 0x80E1;
                case 8 /* A4R4G4B4 */ :
                case 26 /* X8R8G8B8 */ :
                case 12 /* A8R8G8B8 */ :
                case 14 /* B8G8R8A8 */ :
                case 27 /* X8B8G8R8 */ :
                case 13 /* A8B8G8R8 */ :
                    return 0x1908;
                case 17 /* DXT1 */ :
                    return webgl.hasExtension("WEBGL_compressed_texture_s3tc") ? 0x83F1 : 0;
                case 19 /* DXT3 */ :
                    return webgl.hasExtension("WEBGL_compressed_texture_s3tc") ? 0x83F2 : 0;
                case 21 /* DXT5 */ :
                    return webgl.hasExtension("WEBGL_compressed_texture_s3tc") ? 0x83F3 : 0;
                case 36 /* FLOAT32_GR */ :
                case 33 /* FLOAT32_R */ :
                default:
                    return 0;
            }
        }
        webgl.getWebGLOriginFormat = getWebGLOriginFormat;
        function /** @no-inline */getWebGLOriginDataType(eFormat) {
            switch(eFormat) {
                case 3 /* A8 */ :
                case 1 /* L8 */ :
                case 2 /* L16 */ :
                case 10 /* R8G8B8 */ :
                case 11 /* B8G8R8 */ :
                case 5 /* BYTE_LA */ :
                    return 0x1401;
                case 6 /* R5G6B5 */ :
                case 7 /* B5G6R5 */ :
                    return 0x8363;
                case 8 /* A4R4G4B4 */ :
                    return 0x8033;
                case 9 /* A1R5G5B5 */ :
                    return 0x8034;
                case 27 /* X8B8G8R8 */ :
                case 13 /* A8B8G8R8 */ :
                    return 0x8367;
                case 26 /* X8R8G8B8 */ :
                case 13 /* A8B8G8R8 */ :
                case 12 /* A8R8G8B8 */ :
                    return 0x8367;
                case 14 /* B8G8R8A8 */ :
                    return 0x1401;
                case 28 /* R8G8B8A8 */ :
                    return 0x1401;
                case 32 /* FLOAT16_R */ :
                case 35 /* FLOAT16_GR */ :
                case 22 /* FLOAT16_RGB */ :
                case 23 /* FLOAT16_RGBA */ :
                    return webgl.hasExtension("OES_texture_half_float") ? 0x8D61 : 0;
                case 42 /* R8 */ :
                case 43 /* RG8 */ :
                    return webgl.hasExtension("EXT_texture_rg") ? 0x1401 : 0;
                case 33 /* FLOAT32_R */ :
                case 36 /* FLOAT32_GR */ :
                case 24 /* FLOAT32_RGB */ :
                case 25 /* FLOAT32_RGBA */ :
                    return 0x1406;
                case 29 /* DEPTH */ :
                    return 0x1405;
                case 44 /* DEPTH_BYTE */ :
                    return 0x1401;
                case 17 /* DXT1 */ :
                case 19 /* DXT3 */ :
                case 21 /* DXT5 */ :
                case 31 /* R3G3B2 */ :
                case 15 /* A2R10G10B10 */ :
                case 16 /* A2B10G10R10 */ :
                case 30 /* SHORT_RGBA */ :
                case 37 /* SHORT_RGB */ :
                case 34 /* SHORT_GR */ :
                    // TODO not supported
                                    default:
                    return 0;
            }
        }
        webgl.getWebGLOriginDataType = getWebGLOriginDataType;
        function /** @no-inline */getWebGLInternalFormat(eFormat, isHWGamma) {
            if (typeof isHWGamma === "undefined") { isHWGamma = false; }
            switch(eFormat) {
                case 1 /* L8 */ :
                case 2 /* L16 */ :
                    return 0x1909;
                case 3 /* A8 */ :
                    return 0x1906;
                case 5 /* BYTE_LA */ :
                    return 0x190A;
                case 38 /* PVRTC_RGB2 */ :
                    return webgl.hasExtension("WEBGL_compressed_texture_pvrtc") ? 0x8C01 : 0;
                case 40 /* PVRTC_RGB4 */ :
                    return webgl.hasExtension("WEBGL_compressed_texture_pvrtc") ? 0x8C00 : 0;
                case 39 /* PVRTC_RGBA2 */ :
                    return webgl.hasExtension("WEBGL_compressed_texture_pvrtc") ? 0x8C03 : 0;
                case 41 /* PVRTC_RGBA4 */ :
                    return webgl.hasExtension("WEBGL_compressed_texture_pvrtc") ? 0x8C02 : 0;
                case 27 /* X8B8G8R8 */ :
                case 26 /* X8R8G8B8 */ :
                case 13 /* A8B8G8R8 */ :
                case 12 /* A8R8G8B8 */ :
                case 14 /* B8G8R8A8 */ :
                case 9 /* A1R5G5B5 */ :
                case 8 /* A4R4G4B4 */ :
                    return 0x1908;
                case 6 /* R5G6B5 */ :
                case 7 /* B5G6R5 */ :
                case 10 /* R8G8B8 */ :
                case 11 /* B8G8R8 */ :
                    return 0x1907;
                case 32 /* FLOAT16_R */ :
                case 33 /* FLOAT32_R */ :
                case 42 /* R8 */ :
                    return webgl.hasExtension("EXT_texture_rg") ? 0x1903 : 0;
                case 35 /* FLOAT16_GR */ :
                case 36 /* FLOAT32_GR */ :
                case 43 /* RG8 */ :
                    return webgl.hasExtension("EXT_texture_rg") ? 0x1903 : 0;
                    //depth
                                    case 29 /* DEPTH */ :
                    return 0x1902;
                case 44 /* DEPTH_BYTE */ :
                    return 0x1902;
                case 4 /* A4L4 */ :
                case 31 /* R3G3B2 */ :
                case 15 /* A2R10G10B10 */ :
                case 16 /* A2B10G10R10 */ :
                case 23 /* FLOAT16_RGBA */ :
                case 24 /* FLOAT32_RGB */ :
                case 25 /* FLOAT32_RGBA */ :
                case 30 /* SHORT_RGBA */ :
                case 37 /* SHORT_RGB */ :
                case 34 /* SHORT_GR */ :
                case 17 /* DXT1 */ :
                    if(!isHWGamma) {
                        return webgl.hasExtension("WEBGL_compressed_texture_s3tc") ? 0x83F1 : 0;
                    }
                case 19 /* DXT3 */ :
                    if(!isHWGamma) {
                        return webgl.hasExtension("WEBGL_compressed_texture_s3tc") ? 0x83F2 : 0;
                    }
                case 21 /* DXT5 */ :
                    if(!isHWGamma) {
                        return webgl.hasExtension("WEBGL_compressed_texture_s3tc") ? 0x83F2 : 0;
                    }
                default:
                    return 0;
            }
        }
        webgl.getWebGLInternalFormat = getWebGLInternalFormat;
        function /** @no-inline */getWebGLPrimitiveType(eType) {
            switch(eType) {
                case 0 /* POINTLIST */ :
                    return 0x0000;
                case 1 /* LINELIST */ :
                    return 0x0001;
                case 2 /* LINELOOP */ :
                    return 0x0002;
                case 3 /* LINESTRIP */ :
                    return 0x0003;
                case 4 /* TRIANGLELIST */ :
                    return 0x0004;
                case 5 /* TRIANGLESTRIP */ :
                    return 0x0005;
                case 6 /* TRIANGLEFAN */ :
                    return 0x0006;
            }
            return 0x0000;
        }
        webgl.getWebGLPrimitiveType = getWebGLPrimitiveType;
        function /** @no-inline */getClosestWebGLInternalFormat(eFormat, isHWGamma) {
            if (typeof isHWGamma === "undefined") { isHWGamma = false; }
            var iGLFormat = webgl.getWebGLInternalFormat(eFormat, isHWGamma);
            if(iGLFormat === 0) {
                if(isHWGamma) {
                    // TODO not supported
                    return 0;
                } else {
                    return 0x1908;
                }
            } else {
                return iGLFormat;
            }
        }
        webgl.getClosestWebGLInternalFormat = getClosestWebGLInternalFormat;
        /**
        * Convert GL format to EPixelFormat.
        */
        function /** @no-inline */getClosestAkraFormat(iGLFormat, iGLDataType) {
            switch(iGLFormat) {
                case 0x8C01:
                    return webgl.hasExtension("WEBGL_compressed_texture_pvrtc") ? 38 /* PVRTC_RGB2 */  : 12 /* A8R8G8B8 */ ;
                case 0x8C03:
                    return webgl.hasExtension("WEBGL_compressed_texture_pvrtc") ? 39 /* PVRTC_RGBA2 */  : 12 /* A8R8G8B8 */ ;
                case 0x8C00:
                    return webgl.hasExtension("WEBGL_compressed_texture_pvrtc") ? 40 /* PVRTC_RGB4 */  : 12 /* A8R8G8B8 */ ;
                case 0x8C02:
                    return webgl.hasExtension("WEBGL_compressed_texture_pvrtc") ? 41 /* PVRTC_RGBA4 */  : 12 /* A8R8G8B8 */ ;
                case 0x1909:
                    return 1 /* L8 */ ;
                case 0x1906:
                    return 3 /* A8 */ ;
                case 0x190A:
                    return 5 /* BYTE_LA */ ;
                case 0x1907:
                    switch(iGLDataType) {
                        case 0x8363:
                            return 7 /* B5G6R5 */ ;
                        default:
                            return 10 /* R8G8B8 */ ;
                    }
                case 0x1908:
                    switch(iGLDataType) {
                        case 0x8034:
                            return 9 /* A1R5G5B5 */ ;
                        case 0x8033:
                            return 8 /* A4R4G4B4 */ ;
                        default:
                            return 13 /* A8B8G8R8 */ ;
                    }
                case 0x80E1:
                    return 13 /* A8B8G8R8 */ ;
                case 0x83F0:
                case 0x83F1:
                    return webgl.hasExtension("WEBGL_compressed_texture_s3tc") ? 17 /* DXT1 */  : 12 /* A8R8G8B8 */ ;
                case 0x83F2:
                    return webgl.hasExtension("WEBGL_compressed_texture_s3tc") ? 19 /* DXT3 */  : 12 /* A8R8G8B8 */ ;
                case 0x83F3:
                    return webgl.hasExtension("WEBGL_compressed_texture_s3tc") ? 21 /* DXT5 */  : 12 /* A8R8G8B8 */ ;
                case 0x8229:
                    return webgl.hasExtension("EXT_texture_rg") ? 42 /* R8 */  : 12 /* A8R8G8B8 */ ;
                case 0x822B:
                    return webgl.hasExtension("EXT_texture_rg") ? 43 /* RG8 */  : 12 /* A8R8G8B8 */ ;
                default:
                    //TODO: not supported
                    return 12 /* A8R8G8B8 */ ;
            }
        }
        webgl.getClosestAkraFormat = getClosestAkraFormat;
        function /** @no-inline */getMaxMipmaps(iWidth, iHeight, iDepth, eFormat) {
            var iCount = 0;
            if((iWidth > 0) && (iHeight > 0)) {
                do {
                    if(iWidth > 1) {
                        iWidth = iWidth / 2;
                    }
                    if(iHeight > 1) {
                        iHeight = iHeight / 2;
                    }
                    if(iDepth > 1) {
                        iDepth = iDepth / 2;
                    }
                    /*
                    NOT needed, compressed formats will have mipmaps up to 1x1
                    if(PixelUtil::isValidExtent(width, height, depth, format))
                    count ++;
                    else
                    break;
                    */
                    iCount++;
                }while(!(iWidth === 1 && iHeight === 1 && iDepth === 1));
            }
            return iCount;
        }
        webgl.getMaxMipmaps = getMaxMipmaps;
        function /** @no-inline */optionalPO2(iValue) {
            if(webgl.hasNonPowerOf2Textures) {
                return iValue;
            } else {
                return akra.math.ceilingPowerOfTwo(iValue);
            }
        }
        webgl.optionalPO2 = optionalPO2;
        function /** @no-inline */convertToWebGLformat(pSource, pDest) {
            // Always need to convert PF_A4R4G4B4, GL expects the colors to be in the
            // reverse order
            if(pDest.format == 8 /* A4R4G4B4 */ ) {
                // Convert PF_A4R4G4B4 -> PF_B4G4R4A4
                // Reverse pixel order
                var iSrcPtr = (pSource.left + pSource.top * pSource.rowPitch + pSource.front * pSource.slicePitch);
                var iDstPtr = (pDest.left + pDest.top * pDest.rowPitch + pDest.front * pDest.slicePitch);
                var iSrcSliceSkip = pSource.getSliceSkip();
                var iDstSliceSkip = pDest.getSliceSkip();
                var k = pSource.right - pSource.left;
                var x = 0, y = 0, z = 0;
                for(z = pSource.front; z < pSource.back; z++) {
                    for(y = pSource.top; y < pSource.bottom; y++) {
                        for(x = 0; x < k; x++) {
                            // B                        pDest[iDstPtr + x] = ((pSource[iSrcPtr + x]&0x000F)<<12) |
                            // G                                    		 ((pSource[iSrcPtr + x]&0x00F0)<<4)  |
                            // R                                    		 ((pSource[iSrcPtr + x]&0x0F00)>>4)  |
                            // A                                    	     ((pSource[iSrcPtr + x]&0xF000)>>12);
                                                    }
                        iSrcPtr += pSource.rowPitch;
                        iDstPtr += pDest.rowPitch;
                    }
                    iSrcPtr += iSrcSliceSkip;
                    iDstPtr += iDstSliceSkip;
                }
            }
        }
        webgl.convertToWebGLformat = convertToWebGLformat;
        function /** @no-inline */checkFBOAttachmentFormat(eFormat) {
            return false;
        }
        webgl.checkFBOAttachmentFormat = checkFBOAttachmentFormat;
        function /** @no-inline */getSupportedAlternative(eFormat) {
            if(checkFBOAttachmentFormat(eFormat)) {
                return eFormat;
            }
            /// Find first alternative
            var pct = akra.pixelUtil.getComponentType(eFormat);
            switch(pct) {
                case 0 /* BYTE */ :
                    eFormat = 12 /* A8R8G8B8 */ ;
                    break;
                case 1 /* SHORT */ :
                    eFormat = 30 /* SHORT_RGBA */ ;
                    break;
                case 2 /* FLOAT16 */ :
                    eFormat = 23 /* FLOAT16_RGBA */ ;
                    break;
                case 3 /* FLOAT32 */ :
                    eFormat = 25 /* FLOAT32_RGBA */ ;
                    break;
                case 4 /* COUNT */ :
                default:
                    break;
            }
            if(checkFBOAttachmentFormat(eFormat)) {
                return eFormat;
            }
            /// If none at all, return to default
            return 12 /* A8R8G8B8 */ ;
        }
        webgl.getSupportedAlternative = getSupportedAlternative;
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var ApiInfo = (function (_super) {
            __extends(ApiInfo, _super);
            function /** @no-inline */ApiInfo() {
                        _super.call(this);
                this.bWebGL = false;
                this.bWebAudio = false;
                this.bFile = false;
                this.bFileSystem = false;
                this.bWebWorker = false;
                this.bTransferableObjects = false;
                this.bLocalStorage = false;
                this.bWebSocket = false;
                var pApi = {
                };
                this.bWebAudio = ((window).AudioContext && (window).webkitAudioContext ? true : false);
                this.bFile = ((window).File && (window).FileReader && (window).FileList && (window).Blob ? true : false);
                this.bFileSystem = (this.bFile && (window).URL && (window).requestFileSystem ? true : false);
                this.bWebWorker = akra.isDef((window).Worker);
                this.bLocalStorage = akra.isDef((window).localStorage);
                this.bWebSocket = akra.isDef((window).WebSocket);
            }
            Object.defineProperty(ApiInfo.prototype, "webGL", {
                get: function /** @no-inline */() {
                    if(!this.bWebGL) {
                        this.bWebGL = ((window).WebGLRenderingContext || this.checkWebGL() ? true : false);
                    }
                    return this.bWebGL;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ApiInfo.prototype, "transferableObjects", {
                get: function /** @no-inline */() {
                    if(!this.bTransferableObjects) {
                        this.bTransferableObjects = (this.bWebWorker && this.chechTransferableObjects() ? true : false);
                    }
                    return this.bTransferableObjects;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ApiInfo.prototype, "file", {
                get: function /** @no-inline */() {
                    return this.bFile;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ApiInfo.prototype, "fileSystem", {
                get: function /** @no-inline */() {
                    return this.bFileSystem;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ApiInfo.prototype, "webAudio", {
                get: function /** @no-inline */() {
                    return this.bWebAudio;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ApiInfo.prototype, "webWorker", {
                get: function /** @no-inline */() {
                    return this.bWebWorker;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ApiInfo.prototype, "localStorage", {
                get: function /** @no-inline */() {
                    return this.bLocalStorage;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ApiInfo.prototype, "webSocket", {
                get: function /** @no-inline */() {
                    return this.bWebSocket;
                },
                enumerable: true,
                configurable: true
            });
            ApiInfo.prototype.checkWebGL = function /** @no-inline */() {
                var pCanvas;
                var pDevice;
                try  {
                    pCanvas = document.createElement('canvas');
                    pDevice = pCanvas.getContext('webgl', {
                    }) || pCanvas.getContext('experimental-webgl', {
                    });
                    if(pDevice) {
                        return true;
                    }
                } catch (e) {
                }
                return false;
            };
            ApiInfo.prototype.chechTransferableObjects = function /** @no-inline */() {
                var pBlob = new Blob([
                    "onmessage = function(e) { postMessage(true); }"
                ]);
                var sBlobURL = (window).URL.createObjectURL(pBlob);
                var pWorker = new Worker(sBlobURL);
                var pBuffer = new ArrayBuffer(1);
                try  {
                    pWorker.postMessage(pBuffer, [
                        pBuffer
                    ]);
                } catch (e) {
                    util.logger.setSourceLocation("util/ApiInfo.ts", 101);
                    util.logger.log('transferable objects not supported in your browser...');
                    ;
                }
                pWorker.terminate();
                if(pBuffer.byteLength) {
                    return false;
                }
                return true;
            };
            return ApiInfo;
        })(util.Singleton);
        util.ApiInfo = ApiInfo;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (info) {
                        function /** @no-inline */canvas(id) {
            var pCanvas = akra.isString(id) ? document.getElementById(id) : id;
            return {
                width: akra.isInt(pCanvas.width) ? pCanvas.width : parseInt(pCanvas.style.width),
                height: akra.isInt(pCanvas.height) ? pCanvas.height : parseInt(pCanvas.style.height),
                id: pCanvas.id
            };
        }
        info.canvas = canvas;
        info.browser = new akra.util.BrowserInfo();
        info.api = new akra.util.ApiInfo();
        info.screen = new akra.util.ScreenInfo();
        info.uri = akra.util.uri(document.location.href);
        var is;
        (function (is) {
            /**
            * show status - online or offline
            */
            is.online;
            /**
            * perform test on mobile device
            */
            is.mobile = (/mobile|iphone|ipad|ipod|android|blackberry|mini|windows\sce|palm/i).test(navigator.userAgent.toLowerCase());
            is.linux = info.browser.os === 'Linux';
            is.windows = info.browser.os === 'Windows';
            is.mac = info.browser.os === 'Mac';
            is.iPhone = info.browser.os === 'iPhone';
        })(is || (is = {}));
        //TODO: move it to [akra.info.is] module, when typescript access this.
        Object.defineProperty(is, 'online', {
            get: function /** @no-inline */() {
                return navigator.onLine;
            }
        });
    })(akra.info || (akra.info = {}));
    var info = akra.info;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        (function (EThreadStatuses) {
            EThreadStatuses._map = [];
            EThreadStatuses._map[0] = "k_WorkerBusy";
            EThreadStatuses.k_WorkerBusy = 0;
            EThreadStatuses._map[1] = "k_WorkerFree";
            EThreadStatuses.k_WorkerFree = 1;
        })(util.EThreadStatuses || (util.EThreadStatuses = {}));
        var EThreadStatuses = util.EThreadStatuses;
        var ThreadManager = (function () {
            function /** @no-inline */ThreadManager(sScript) {
                if (typeof sScript === "undefined") { sScript = null; }
                var _this = this;
                this._pWorkerList = [];
                this._pStatsList = [];
                this._sDefaultScript = sScript;
                setInterval(function /** @no-inline */() {
                    var pStats;
                    var iNow = akra.now();
                    for(var i = 0, n = _this._pStatsList.length; i < n; ++i) {
                        pStats = _this._pStatsList[i];
                        if(pStats.releaseTime > 0 && iNow - pStats.releaseTime > 30 * 1000) {
                            if(_this.terminateThread(i)) {
                                util.logger.setSourceLocation("util/ThreadManager.ts", 45);
                                util.logger.log("thread with id - " + i + " terminated. (" + i + "/" + n + ")");
                                ;
                                return;
                            }
                            util.logger.setSourceLocation("util/ThreadManager.ts", 49);
                            util.logger.warning("thread must be removed: " + i);
                            ;
                        }
                    }
                    ;
                }, 30000);
            }
            ThreadManager.prototype.createThread = function /** @no-inline */() {
                //console.log((new Error).stack)
                if(this._pWorkerList.length === 32) {
                    util.logger.setSourceLocation("util/ThreadManager.ts", 58);
                    util.logger.error("Reached limit the number of threads");
                    ;
                    return false;
                }
                if(!akra.info.api.webWorker) {
                    util.logger.setSourceLocation("util/ThreadManager.ts", 63);
                    util.logger.error("WebWorkers unsupprted..");
                    ;
                    return false;
                }
                var pWorker = (new Worker(this._sDefaultScript));
                pWorker.id = this._pWorkerList.length;
                pWorker.send = (pWorker).postMessage;
                this._pWorkerList.push(pWorker);
                this._pStatsList.push({
                    status: 1 /* k_WorkerFree */ ,
                    creationTime: akra.now(),
                    releaseTime: akra.now()
                });
                return true;
            };
            ThreadManager.prototype.occupyThread = function /** @no-inline */() {
                var pStats;
                for(var i = 0, n = this._pWorkerList.length; i < n; ++i) {
                    pStats = this._pStatsList[i];
                    if(pStats.status == 1 /* k_WorkerFree */ ) {
                        pStats.status = 0 /* k_WorkerBusy */ ;
                        pStats.releaseTime = 0;
                        return this._pWorkerList[i];
                    }
                }
                if(this.createThread()) {
                    return this.occupyThread();
                } else {
                    util.logger.setSourceLocation("util/ThreadManager.ts", 99);
                    util.logger.error("cannot occupy thread");
                    ;
                    return null;
                }
            };
            ThreadManager.prototype.terminateThread = function /** @no-inline */(iThread) {
                var pStats = this._pStatsList[iThread];
                var pWorker = this._pWorkerList[iThread];
                if(!akra.isDefAndNotNull(pWorker) && pStats.status != 1 /* k_WorkerFree */ ) {
                    return false;
                }
                (pWorker).terminate();
                this._pStatsList.splice(iThread);
                this._pWorkerList.splice(iThread);
                return true;
            };
            ThreadManager.prototype.releaseThread = function /** @no-inline */(pThread) {
                var iThread;
                var pStats;
                if(!akra.isInt(pThread)) {
                    iThread = pThread.id;
                } else {
                    iThread = pThread;
                }
                if(akra.isDef(this._pStatsList[iThread])) {
                    pStats = this._pStatsList[iThread];
                    pStats.status = 1 /* k_WorkerFree */ ;
                    pStats.releaseTime = akra.now();
                }
                return false;
            };
            ThreadManager.prototype.initialize = function /** @no-inline */() {
                return true;
            };
            ThreadManager.prototype.destroy = function /** @no-inline */() {
            };
            return ThreadManager;
        })();
        util.ThreadManager = ThreadManager;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    /// @dep io/FileInterface.t.js
    /// @dep io/LocalFile.t.js
    /// @dep io/RemoteFile.t.js
    (function (io) {
        (function (EFileActions) {
            EFileActions._map = [];
            EFileActions.k_Open = 1;
            EFileActions.k_Read = 2;
            EFileActions._map[3] = "k_Write";
            EFileActions.k_Write = 3;
            EFileActions._map[4] = "k_Clear";
            EFileActions.k_Clear = 4;
            EFileActions._map[5] = "k_Exists";
            EFileActions.k_Exists = 5;
            EFileActions._map[6] = "k_Remove";
            EFileActions.k_Remove = 6;
        })(io.EFileActions || (io.EFileActions = {}));
        var EFileActions = io.EFileActions;
        ;
        (function (EFileTransferModes) {
            EFileTransferModes._map = [];
            EFileTransferModes._map[0] = "k_Normal";
            EFileTransferModes.k_Normal = 0;
            EFileTransferModes._map[1] = "k_Slow";
            EFileTransferModes.k_Slow = 1;
            EFileTransferModes._map[2] = "k_Fast";
            EFileTransferModes.k_Fast = 2;
        })(io.EFileTransferModes || (io.EFileTransferModes = {}));
        var EFileTransferModes = io.EFileTransferModes;
        var pLocalFileThreadManager = new akra.util.ThreadManager("LocalFile.t.js");
        var pRemoteFileThreadManager = new akra.util.ThreadManager("RemoteFile.t.js");
        io.getLocalFileThreadManager = function /** @inline */() {
            return pLocalFileThreadManager;
        };
        io.getRemoteFileThreadManager = function /** @inline */() {
            return pRemoteFileThreadManager;
        };
        var TFile = (function () {
            function /** @no-inline */TFile(sFilename, sMode, fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = TFile.defaultCallback; }
                /**@protected*/ this._pUri = null;
                /**@protected*/ this._nCursorPosition = 0;
                /**@protected*/ this._bOpened = false;
                /**@protected*/ this._eTransferMode = 0 /* k_Normal */ ;
                /**@protected*/ this._pFileMeta = null;
                /**@protected*/ this._isLocal = false;
                if(akra.isDef(sMode)) {
                    this._iMode = akra.isString(sMode) ? io.filemode(sMode) : sMode;
                }
                this.setAndValidateUri(akra.util.uri(sFilename));
                if(akra.info.api.transferableObjects) {
                    this._eTransferMode = 2 /* k_Fast */ ;
                } else if(akra.info.browser.name == "Opera") {
                    this._eTransferMode = 1 /* k_Slow */ ;
                }
                if(arguments.length > 2) {
                    this.open(sFilename, sMode, fnCallback);
                }
            }
            Object.defineProperty(TFile.prototype, "path", {
                get: function /** @inline */() {
                    akra.logger.setSourceLocation("TFile.ts", 82);
                    akra.logger.assert(akra.isDefAndNotNull(this._pFileMeta), "There is no file handle open.");
                    ;
                    return this._pUri.toString();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TFile.prototype, "name", {
                get: function /** @inline */() {
                    return akra.util.pathinfo(this._pUri.path).basename;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TFile.prototype, "mode", {
                get: function /** @inline */() {
                    return this._iMode;
                },
                set: //set mode(sMode: string);
                //set mode(iMode: int);
                function /** @no-inline */(sMode) {
                    this._iMode = akra.isString(sMode) ? io.filemode(sMode) : sMode;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TFile.prototype, "onread", {
                set: function /** @inline */(fnCallback) {
                    this.read(fnCallback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TFile.prototype, "onopen", {
                set: function /** @inline */(fnCallback) {
                    this.open(fnCallback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TFile.prototype, "position", {
                get: function /** @inline */() {
                    akra.logger.setSourceLocation("TFile.ts", 109);
                    akra.logger.assert(akra.isDefAndNotNull(this._pFileMeta), 'There is no file handle open.');
                    ;
                    return this._nCursorPosition;
                },
                set: function /** @no-inline */(iOffset) {
                    akra.logger.setSourceLocation("TFile.ts", 114);
                    akra.logger.assert(akra.isDefAndNotNull(this._pFileMeta), 'There is no file handle open.');
                    ;
                    this._nCursorPosition = iOffset;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TFile.prototype, "byteLength", {
                get: function /** @inline */() {
                    return this._pFileMeta ? this._pFileMeta.size : 0;
                },
                enumerable: true,
                configurable: true
            });
            TFile.prototype.open = function /** @no-inline */(sFilename, iMode, fnCallback) {
                var pFile = this;
                var hasMode = !akra.isFunction(iMode);
                if(arguments.length < 3) {
                    if(akra.isString(arguments[0])) {
                        this.setAndValidateUri(akra.util.uri(sFilename));
                        fnCallback = arguments[1];
                    } else if(akra.isInt(arguments[0])) {
                        this._iMode = arguments[0];
                        fnCallback = arguments[1];
                    } else {
                        fnCallback = arguments[0];
                    }
                    akra.logger.setSourceLocation("TFile.ts", 165);
                    akra.logger.assert(akra.isDefAndNotNull(this._pUri), "No filename provided.");
                    ;
                    this.open(this._pUri.toString(), this._iMode, fnCallback);
                    return;
                }
                fnCallback = arguments[hasMode ? 2 : 1];
                fnCallback = fnCallback || TFile.defaultCallback;
                if(this.isOpened()) {
                    akra.logger.setSourceLocation("TFile.ts", 177);
                    akra.logger.warning("file already opened: " + this.name);
                    ;
                    (fnCallback)(null, this._pFileMeta);
                }
                this.setAndValidateUri(akra.util.uri(arguments[0]));
                if(hasMode) {
                    this._iMode = (akra.isString(arguments[1]) ? io.filemode(arguments[1]) : arguments[1]);
                }
                this.update(function /** @no-inline */(err) {
                    if(err) {
                        akra.logger.setSourceLocation("TFile.ts", 189);
                        akra.logger.warning("file update err", err);
                        ;
                        fnCallback.call(pFile, err);
                        return;
                    }
                    if(((this._iMode & (1 << (3))) != 0)) {
                        this.position = this.size;
                    }
                    fnCallback.call(pFile, null, pFile);
                });
            };
            TFile.prototype.close = function /** @no-inline */() {
                this._pUri = null;
                this._iMode = 1 /* IN */  | 2 /* OUT */ ;
                this._nCursorPosition = 0;
                this._pFileMeta = null;
            };
            TFile.prototype.clear = function /** @no-inline */(fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = TFile.defaultCallback; }
                if(!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function /** @no-inline */(err) {
                        if(err) {
                            fnCallback(err);
                        }
                        this.clear.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                var pCommand = {
                    act: 4 /* k_Clear */ ,
                    name: this.path,
                    mode: this._iMode
                };
                this.execCommand(pCommand, fnCallback);
            };
            TFile.prototype.read = function /** @no-inline */(fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = TFile.defaultCallback; }
                if(!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function /** @no-inline */(err) {
                        if(err) {
                            fnCallback(err);
                        }
                        this.read.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                var pFile = this;
                var eTransferMode = this._eTransferMode;
                akra.logger.setSourceLocation("TFile.ts", 228);
                akra.logger.assert(((this._iMode & (1 << (0))) != 0), "The file is not readable.");
                ;
                var pCommand = {
                    act: 2 /* k_Read */ ,
                    name: this.path,
                    mode: this._iMode,
                    pos: this._nCursorPosition,
                    transfer: this._eTransferMode
                };
                var fnCallbackSystem = function /** @no-inline */(err, pData) {
                    if(err) {
                        fnCallback.call(pFile, err);
                        return;
                    }
                    if(eTransferMode == 1 /* k_Slow */  && ((this._iMode & (1 << (5))) != 0)) {
                        pData = new Uint8Array(pData).buffer;
                    }
                    pFile.atEnd();
                    fnCallback.call(pFile, null, pData);
                };
                this.execCommand(pCommand, fnCallbackSystem);
            };
            TFile.prototype.write = function /** @no-inline */(pData, fnCallback, sContentType) {
                if (typeof fnCallback === "undefined") { fnCallback = TFile.defaultCallback; }
                if(!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function /** @no-inline */(err) {
                        if(err) {
                            fnCallback(err);
                        }
                        this.write.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                var pFile = this;
                var iMode = this._iMode;
                var pCommand;
                var fnCallbackSystem = function /** @no-inline */(err, pMeta) {
                    if(err) {
                        fnCallback.call(pFile, err);
                        return;
                    }
                    pFile.position += akra.isString(pData) ? pData.length : pData.byteLength;
                    (pFile)._pFileMeta = pMeta;
                    fnCallback.call(pFile, null, pMeta);
                };
                akra.logger.setSourceLocation("TFile.ts", 277);
                akra.logger.assert(((iMode & (1 << (1))) != 0), "The file is not writable.");
                ;
                sContentType = sContentType || (((iMode & (1 << (5))) != 0) ? "application/octet-stream" : "text/plain");
                pCommand = {
                    act: 3 /* k_Write */ ,
                    name: this.path,
                    mode: this._iMode,
                    data: pData,
                    contentType: sContentType,
                    pos: this._nCursorPosition
                };
                if(!akra.isString(pData)) {
                    this.execCommand(pCommand, fnCallbackSystem, [
                        pData
                    ]);
                } else {
                    this.execCommand(pCommand, fnCallbackSystem);
                }
            };
            TFile.prototype.move = function /** @no-inline */(sFilename, fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = TFile.defaultCallback; }
                var pFile = this;
                this.copy(sFilename, function /** @no-inline */(err) {
                    if(err) {
                        fnCallback(err);
                        return;
                    }
                    pFile.remove(fnCallback);
                });
            };
            TFile.prototype.copy = function /** @no-inline */(sFilename, fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = TFile.defaultCallback; }
                var iMode = 1 /* IN */  | 2 /* OUT */  | 16 /* TRUNC */ ;
                var pFile = this;
                var pFileCopy;
                if(((this._iMode & (1 << (5))) != 0)) {
                    iMode |= 32 /* BIN */ ;
                }
                pFileCopy = new TFile(sFilename, iMode, function /** @no-inline */(err) {
                    if(err) {
                        fnCallback(err);
                    }
                    pFile.read(function /** @no-inline */(pData) {
                        pFile.write(pData, fnCallback);
                    });
                });
            };
            TFile.prototype.rename = function /** @no-inline */(sFilename, fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = TFile.defaultCallback; }
                var pName = akra.util.pathinfo(sFilename);
                akra.logger.setSourceLocation("TFile.ts", 335);
                akra.logger.assert(!pName.dirname, 'only filename can be specified.');
                ;
                this.move(akra.util.pathinfo(this._pUri.path).dirname + "/" + pName.basename, fnCallback);
            };
            TFile.prototype.remove = function /** @no-inline */(fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = TFile.defaultCallback; }
                if(!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function /** @no-inline */(err) {
                        if(err) {
                            fnCallback(err);
                        }
                        this.remove.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                var pFile = this;
                var pCommand = {
                    act: 6 /* k_Remove */ ,
                    name: this.path,
                    mode: this._iMode
                };
                var fnCallbackSystem = function /** @no-inline */(err, pData) {
                    pFile.close();
                    if(akra.isDef(fnCallback)) {
                        fnCallback.call(pFile, err, pData);
                    }
                };
                this.execCommand(pCommand, fnCallbackSystem);
            };
            TFile.prototype.atEnd = //return current position
            function /** @no-inline */() {
                this.position = this.byteLength;
                return this._nCursorPosition;
            };
            TFile.prototype.seek = //return current position;
            function /** @no-inline */(iOffset) {
                akra.logger.setSourceLocation("TFile.ts", 367);
                akra.logger.assert(akra.isDefAndNotNull(this._pFileMeta), "There is no file handle open.");
                ;
                var nSeek = this._nCursorPosition + iOffset;
                if(nSeek < 0) {
                    nSeek = this.byteLength - (akra.math.abs(nSeek) % this.byteLength);
                }
                akra.logger.setSourceLocation("TFile.ts", 374);
                akra.logger.assert(nSeek >= 0 && nSeek <= this.byteLength, "Invalid offset parameter");
                ;
                this._nCursorPosition = nSeek;
                return this._nCursorPosition;
            };
            TFile.prototype.isOpened = function /** @no-inline */() {
                return this._pFileMeta !== null;
            };
            TFile.prototype.isExists = function /** @no-inline */(fnCallback) {
                var pCommand = {
                    act: 5 /* k_Exists */ ,
                    name: this.path,
                    mode: this._iMode
                };
                this.execCommand(pCommand, fnCallback);
            };
            TFile.prototype.isLocal = function /** @inline */() {
                return this._isLocal;
            };
            TFile.prototype.getMetaData = function /** @no-inline */(fnCallback) {
                akra.logger.setSourceLocation("TFile.ts", 399);
                akra.logger.assert(akra.isDefAndNotNull(this._pFileMeta), 'There is no file handle open.');
                ;
                fnCallback(null, {
                    lastModifiedDate: this._pFileMeta.lastModifiedDate
                });
            };
            TFile.prototype.setAndValidateUri = function /** @no-inline */(sFilename) {
                var pUri = akra.util.uri(sFilename);
                var pUriLocal;
                if(pUri.protocol === "filesystem") {
                    pUriLocal = akra.util.uri(pUri.path);
                    akra.logger.setSourceLocation("TFile.ts", 414);
                    akra.logger.assert(!(pUriLocal.protocol && pUriLocal.host != akra.info.uri.host), "Поддерживаются только локальные файлы в пределах текущего домена.");
                    ;
                    var pFolders = pUriLocal.path.split('/');
                    if(pFolders[0] == "" || pFolders[0] == ".") {
                        pFolders = pFolders.slice(1);
                    }
                    akra.logger.setSourceLocation("TFile.ts", 423);
                    akra.logger.assert(pUri.host === "temporary", "Поддерживаются только файловые системы типа \"temporary\".");
                    ;
                    this._pUri = akra.util.uri(pFolders.join("/"));
                    this._isLocal = true;
                } else {
                    this._pUri = pUri;
                }
            };
            TFile.prototype.update = function /** @no-inline */(fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = TFile.defaultCallback; }
                var pFile = this;
                var pCommand = {
                    act: 1 /* k_Open */ ,
                    name: this._pUri.toString(),
                    mode: this._iMode
                };
                var fnCallbackSystem = function /** @no-inline */(err, pMeta) {
                    (pFile)._pFileMeta = pMeta;
                    fnCallback.call(pFile, err, pFile);
                };
                this.execCommand(pCommand, fnCallbackSystem);
            };
            TFile.prototype.execCommand = function /** @no-inline */(pCommand, fnCallback, pTransferables) {
                TFile.execCommand(this.isLocal(), pCommand, fnCallback);
            };
            TFile.defaultCallback = function /** @no-inline */(err) {
                if(err) {
                    throw err;
                }
            };
            TFile.execCommand = function /** @no-inline */execCommand(isLocal, pCommand, fnCallback, pTransferables) {
                var pFile = this;
                var pManager = isLocal ? io.getLocalFileThreadManager() : io.getRemoteFileThreadManager();
                var pThread = pManager.occupyThread();
                pThread.onmessage = function /** @no-inline */(e) {
                    pManager.releaseThread(pThread);
                    pThread.onmessage = null;
                    fnCallback.call(pFile, null, e.data);
                };
                pThread.onerror = function /** @no-inline */(e) {
                    pManager.releaseThread(pThread);
                    pThread.onmessage = null;
                    fnCallback.call(pFile, e);
                };
                if(akra.isDef(pTransferables)) {
                    pThread.send(pCommand, pTransferables);
                } else {
                    pThread.send(pCommand);
                }
            };
            return TFile;
        })();
        io.TFile = TFile;        
    })(akra.io || (akra.io = {}));
    var io = akra.io;
})(akra || (akra = {}));
var akra;
(function (akra) {
    /*local file via local files system(async)*/
    /**
    * FIle implementation via <Local filesystem>.
    * ONLY FOR LOCAL FILES!!
    */
    (function (io) {
        var LocalFileSystem = (function () {
            function LocalFileSystem() {
                this._pFileSystem = null;
                this._pCallbackQueue = [];
            }
            LocalFileSystem.prototype.setFileSystem = function /** @no-inline */(pFS) {
                this._pFileSystem = pFS;
            };
            LocalFileSystem.prototype.get = /**
            * Инициализация файловой системы.
            * @tparam Function fnCallback Функция, вызываемая
            * при успешной(получет в 1ом параметре fs)
            * инициализации системы.
            */
            function /** @no-inline */(fnCallback) {
                if(this._pFileSystem) {
                    fnCallback(this._pFileSystem);
                    return;
                }
                var pFileSystem = this;
                var pQueue = this._pCallbackQueue;
                pQueue.push(fnCallback);
                if(pQueue.length > 1) {
                    return;
                }
                window.storageInfo.requestQuota(window.TEMPORARY, (32 * 1024 * 1024), function /** @no-inline */(nGrantedBytes) {
                    window.requestFileSystem(window.TEMPORARY, nGrantedBytes, function /** @no-inline */(pFs) {
                        pFileSystem.setFileSystem(pFs);
                        if(pQueue.length) {
                            for(var i = 0; i < pQueue.length; ++i) {
                                pQueue[i](pFs);
                            }
                        }
                    }, LocalFileSystem.errorHandler);
                });
            };
            LocalFileSystem.errorHandler = function /** @no-inline */errorHandler(e) {
                var sMesg = "init filesystem: ";
                switch(e.code) {
                    case FileError.QUOTA_EXCEEDED_ERR:
                        sMesg += 'QUOTA_EXCEEDED_ERR';
                        break;
                    case FileError.NOT_FOUND_ERR:
                        sMesg += 'NOT_FOUND_ERR';
                        break;
                    case FileError.SECURITY_ERR:
                        sMesg += 'SECURITY_ERR';
                        break;
                    case FileError.INVALID_MODIFICATION_ERR:
                        sMesg += 'INVALID_MODIFICATION_ERR';
                        break;
                    case FileError.INVALID_STATE_ERR:
                        sMesg += 'INVALID_STATE_ERR';
                        break;
                    default:
                        sMesg += 'Unknown Error';
                        break;
                }
                akra.logger.setSourceLocation("LocalFile.ts", 102);
                akra.logger.error(sMesg);
                ;
            };
            return LocalFileSystem;
        })();        
        var pLocalFileSystem = new LocalFileSystem();
        function /** @no-inline */getFileSystem(fnCallback) {
            pLocalFileSystem.get(fnCallback);
        }
        io.getFileSystem = getFileSystem;
        var LocalFile = (function () {
            function /** @no-inline */LocalFile(sFilename, sMode, fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = LocalFile.defaultCallback; }
                this._nCursorPosition = 0;
                if(akra.isDef(sMode)) {
                    this._iMode = akra.isString(sMode) ? io.filemode(sMode) : sMode;
                }
                this.setAndValidateUri(akra.util.uri(sFilename));
                if(arguments.length > 2) {
                    this.open(sFilename, sMode, fnCallback);
                }
            }
            Object.defineProperty(LocalFile.prototype, "path", {
                get: function /** @inline */() {
                    akra.logger.setSourceLocation("LocalFile.ts", 126);
                    akra.logger.assert(akra.isDefAndNotNull(this._pFile), "There is no file handle open.");
                    ;
                    return this._pUri.toString();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(LocalFile.prototype, "name", {
                get: function /** @inline */() {
                    return akra.util.pathinfo(this._pUri.path).basename;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(LocalFile.prototype, "mode", {
                get: function /** @inline */() {
                    return this._iMode;
                },
                set: //set mode(sMode: string);
                //set mode(iMode: int);
                function /** @no-inline */(sMode) {
                    this._iMode = akra.isString(sMode) ? io.filemode(sMode) : sMode;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(LocalFile.prototype, "onread", {
                set: function /** @inline */(fnCallback) {
                    this.read(fnCallback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(LocalFile.prototype, "onopen", {
                set: function /** @inline */(fnCallback) {
                    this.open(fnCallback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(LocalFile.prototype, "position", {
                get: function /** @inline */() {
                    akra.logger.setSourceLocation("LocalFile.ts", 153);
                    akra.logger.assert(akra.isDefAndNotNull(this._pFile), "There is no file handle open.");
                    ;
                    return this._nCursorPosition;
                },
                set: function /** @no-inline */(iOffset) {
                    akra.logger.setSourceLocation("LocalFile.ts", 158);
                    akra.logger.assert(akra.isDefAndNotNull(this._pFile), "There is no file handle open.");
                    ;
                    this._nCursorPosition = iOffset;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(LocalFile.prototype, "byteLength", {
                get: function /** @inline */() {
                    return this._pFile ? this._pFile.size : 0;
                },
                enumerable: true,
                configurable: true
            });
            LocalFile.prototype.open = function /** @no-inline */(sFilename, iMode, fnCallback) {
                var pFile = this;
                var hasMode = !akra.isFunction(iMode);
                if(arguments.length < 3) {
                    if(akra.isString(arguments[0])) {
                        this.setAndValidateUri(akra.util.uri(sFilename));
                        fnCallback = arguments[1];
                    } else if(akra.isInt(arguments[0])) {
                        this._iMode = arguments[0];
                        fnCallback = arguments[1];
                    } else {
                        fnCallback = arguments[0];
                    }
                    akra.logger.setSourceLocation("LocalFile.ts", 204);
                    akra.logger.assert(akra.isDefAndNotNull(this._pUri), "No filename provided.");
                    ;
                    this.open(this._pUri.toString(), this._iMode, fnCallback);
                    return;
                }
                fnCallback = arguments[hasMode ? 2 : 1];
                fnCallback = fnCallback || LocalFile.defaultCallback;
                if(this.isOpened()) {
                    akra.logger.setSourceLocation("LocalFile.ts", 216);
                    akra.logger.warning("file already opened: " + this.name);
                    ;
                    (fnCallback)(null, this._pFile);
                }
                this.setAndValidateUri(akra.util.uri(arguments[0]));
                if(hasMode) {
                    this._iMode = (akra.isString(arguments[1]) ? io.filemode(arguments[1]) : arguments[1]);
                }
                var fnFSInited;
                var pFile = this;
                var pFileSystem = null;
                var fnErrorHandler = function /** @no-inline */(e) {
                    if(e.code == FileError.NOT_FOUND_ERR && ((pFile.mode & (1 << (1))) != 0)) {
                        LocalFile.createDir(pFileSystem.root, akra.util.pathinfo(pFile.path).dirname.split('/'), function /** @no-inline */(e) {
                            if(!akra.isNull(e)) {
                                fnCallback.call(pFile, e);
                            } else {
                                fnFSInited.call(pFile, pFileSystem);
                            }
                        });
                    } else {
                        fnCallback.call(pFile, e);
                    }
                };
                fnFSInited = function /** @no-inline */(pFs) {
                    akra.logger.setSourceLocation("LocalFile.ts", 250);
                    akra.logger.assert(akra.isDefAndNotNull(pFs), "local file system not initialized");
                    ;
                    pFileSystem = pFs;
                    pFs.root.getFile(this.path, {
                        create: ((this._iMode & (1 << (1))) != 0),
                        exclusive: false
                    }, function /** @no-inline */(fileEntry) {
                        (pFile).setFileEntry(fileEntry);
                        (fileEntry).file(function /** @no-inline */(file) {
                            (pFile).setFile(file);
                            if(((pFile.mode & (1 << (4))) != 0) && pFile.byteLength) {
                                pFile.clear(function /** @no-inline */(err) {
                                    if(err) {
                                        fnCallback(err);
                                    } else {
                                        fnCallback.call(pFile, null, file);
                                    }
                                });
                                return;
                            }
                            if(((pFile.mode & (1 << (3))) != 0)) {
                                pFile.position = pFile.byteLength;
                            }
                            fnCallback.call(pFile, null, file);
                        }, fnErrorHandler);
                    }, fnErrorHandler);
                };
                getFileSystem(function /** @no-inline */(pFileSystem) {
                    fnFSInited.call(pFile, pFileSystem);
                });
            };
            LocalFile.prototype.close = function /** @no-inline */() {
                this._pUri = null;
                this._iMode = 1 /* IN */  | 2 /* OUT */ ;
                this._nCursorPosition = 0;
                this._pFile = null;
            };
            LocalFile.prototype.clear = function /** @no-inline */(fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = LocalFile.defaultCallback; }
                if(!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function /** @no-inline */(err) {
                        if(err) {
                            fnCallback(err);
                        }
                        this.clear.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                akra.logger.setSourceLocation("LocalFile.ts", 303);
                akra.logger.assert(akra.isDefAndNotNull(this._pFile), 'There is no file handle open');
                ;
                var pFile = this;
                var pFileEntry = this._pFileEntry;
                pFileEntry.createWriter(function /** @no-inline */(pWriter) {
                    pWriter.seek(0);
                    pWriter.onwriteend = function /** @no-inline */() {
                        fnCallback.call(pFile, null);
                    };
                    pWriter.truncate(0);
                }, function /** @no-inline */(e) {
                    fnCallback.call(pFile, e);
                });
            };
            LocalFile.prototype.read = function /** @no-inline */(fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = LocalFile.defaultCallback; }
                if(!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function /** @no-inline */(err) {
                        if(err) {
                            fnCallback(err);
                        }
                        this.read.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                var pFile = this;
                var eTransferMode = this._iMode;
                akra.logger.setSourceLocation("LocalFile.ts", 330);
                akra.logger.assert(((this._iMode & (1 << (0))) != 0), "The file is not readable.");
                ;
                var pReader = this._pFileReader;
                var pFileObject = this._pFile;
                pReader.onloadend = function /** @no-inline */(e) {
                    var pData = ((e.target)).result;
                    var nPos = pFile.position;
                    if(nPos) {
                        if(((pFile.mode & (1 << (5))) != 0)) {
                            pData = (new Uint8Array((new Uint8Array(pData)).subarray(nPos))).buffer;
                        } else {
                            pData = pData.substr(nPos);
                        }
                    }
                    pFile.atEnd();
                    fnCallback.call(pFile, null, pData);
                };
                if(((pFile.mode & (1 << (5))) != 0)) {
                    pReader.readAsArrayBuffer(pFileObject);
                } else {
                    pReader.readAsText(pFileObject);
                }
            };
            LocalFile.prototype.write = function /** @no-inline */(pData, fnCallback, sContentType) {
                if (typeof fnCallback === "undefined") { fnCallback = LocalFile.defaultCallback; }
                if(!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function /** @no-inline */(err) {
                        if(err) {
                            fnCallback(err);
                        }
                        this.write.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                var pFile = this;
                var iMode = this._iMode;
                akra.logger.setSourceLocation("LocalFile.ts", 369);
                akra.logger.assert(((iMode & (1 << (1))) != 0), "The file is not writable.");
                ;
                sContentType = sContentType || (((iMode & (1 << (5))) != 0) ? "application/octet-stream" : "text/plain");
                var pFile = this;
                var pFileEntry = this._pFileEntry;
                pFileEntry.createWriter(function /** @no-inline */(pWriter) {
                    pWriter.seek(pFile.position);
                    pWriter.onerror = function /** @no-inline */(e) {
                        fnCallback.call(pFileEntry, e);
                    };
                    pWriter.onwriteend = function /** @no-inline */() {
                        if(((iMode & (1 << (5))) != 0)) {
                            pFile.seek(pData.byteLength);
                        } else {
                            pFile.seek(pData.length);
                        }
                        fnCallback.call(pFile, null);
                    };
                    pWriter.write((new (Blob)(pData, {
                        type: sContentType
                    })));
                }, function /** @no-inline */(e) {
                    fnCallback.call(pFile, e);
                });
            };
            LocalFile.prototype.move = function /** @no-inline */(sFilename, fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = LocalFile.defaultCallback; }
                var pFile = this;
                this.copy(sFilename, function /** @no-inline */(err) {
                    if(err) {
                        fnCallback(err);
                        return;
                    }
                    pFile.remove(fnCallback);
                });
            };
            LocalFile.prototype.copy = function /** @no-inline */(sFilename, fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = LocalFile.defaultCallback; }
                var iMode = 1 /* IN */  | 2 /* OUT */  | 16 /* TRUNC */ ;
                var pFile = this;
                var pFileCopy;
                if(((this._iMode & (1 << (5))) != 0)) {
                    iMode |= 32 /* BIN */ ;
                }
                pFileCopy = new LocalFile(sFilename, iMode, function /** @no-inline */(err) {
                    if(err) {
                        fnCallback(err);
                    }
                    pFile.read(function /** @no-inline */(pData) {
                        pFile.write(pData, fnCallback);
                    });
                });
            };
            LocalFile.prototype.rename = function /** @no-inline */(sFilename, fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = LocalFile.defaultCallback; }
                var pName = akra.util.pathinfo(sFilename);
                akra.logger.setSourceLocation("LocalFile.ts", 441);
                akra.logger.assert(!pName.dirname, 'only filename can be specified.');
                ;
                this.move(akra.util.pathinfo(this._pUri.path).dirname + "/" + pName.basename, fnCallback);
            };
            LocalFile.prototype.remove = function /** @no-inline */(fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = LocalFile.defaultCallback; }
                if(!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function /** @no-inline */(err) {
                        if(err) {
                            fnCallback(err);
                        }
                        this.remove.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                var pFile = this;
                this._pFileEntry.remove(function /** @no-inline */() {
                    pFile.close();
                    fnCallback.call(pFile, null);
                }, fnCallback);
            };
            LocalFile.prototype.atEnd = //return current position
            function /** @no-inline */() {
                this.position = this.byteLength;
                return this._nCursorPosition;
            };
            LocalFile.prototype.seek = //return current position;
            function /** @no-inline */(iOffset) {
                akra.logger.setSourceLocation("LocalFile.ts", 464);
                akra.logger.assert(akra.isDefAndNotNull(this._pFile), "There is no file handle open.");
                ;
                var nSeek = this._nCursorPosition + iOffset;
                if(nSeek < 0) {
                    nSeek = this.byteLength - (akra.math.abs(nSeek) % this.byteLength);
                }
                akra.logger.setSourceLocation("LocalFile.ts", 471);
                akra.logger.assert(nSeek >= 0 && nSeek <= this.byteLength, "Invalid offset parameter");
                ;
                this._nCursorPosition = nSeek;
                return this._nCursorPosition;
            };
            LocalFile.prototype.isOpened = function /** @no-inline */() {
                return this._pFile !== null;
            };
            LocalFile.prototype.isExists = function /** @no-inline */(fnCallback) {
                this.open(function /** @no-inline */(e) {
                    fnCallback(akra.isNull(e) ? true : false);
                });
            };
            LocalFile.prototype.isLocal = function /** @no-inline */() {
                return true;
            };
            LocalFile.prototype.getMetaData = function /** @no-inline */(fnCallback) {
                akra.logger.setSourceLocation("LocalFile.ts", 493);
                akra.logger.assert(akra.isDefAndNotNull(this._pFile), 'There is no file handle open.');
                ;
                fnCallback(null, {
                    lastModifiedDate: this._pFile.lastModifiedDate
                });
            };
            LocalFile.prototype.setFileEntry = function /** @no-inline */(pFileEntry) {
                if(!akra.isNull(this._pFileEntry)) {
                    return false;
                }
                this._pFileEntry = pFileEntry;
                return true;
            };
            LocalFile.prototype.setFile = function /** @no-inline */(pFile) {
                if(!akra.isNull(this._pFile)) {
                    return false;
                }
                this._pFile = pFile;
                return true;
            };
            LocalFile.prototype.setAndValidateUri = function /** @no-inline */(sFilename) {
                var pUri = akra.util.uri(sFilename);
                var pUriLocal;
                if(pUri.protocol === "filesystem") {
                    pUriLocal = akra.util.uri(pUri.path);
                    akra.logger.setSourceLocation("LocalFile.ts", 528);
                    akra.logger.assert(!(pUriLocal.protocol && pUriLocal.host != akra.info.uri.host), "Поддерживаются только локальные файлы в пределах текущего домена.");
                    ;
                    var pFolders = pUriLocal.path.split('/');
                    if(pFolders[0] == "" || pFolders[0] == ".") {
                        pFolders = pFolders.slice(1);
                    }
                    akra.logger.setSourceLocation("LocalFile.ts", 537);
                    akra.logger.assert(pUri.host === "temporary", "Поддерживаются только файловые системы типа \"temporary\".");
                    ;
                    this._pUri = akra.util.uri(pFolders.join("/"));
                } else {
                    akra.logger.setSourceLocation("LocalFile.ts", 542);
                    akra.logger.error("used non local uri");
                    ;
                }
            };
            LocalFile.errorHandler = function /** @no-inline */errorHandler(e) {
                var sMesg = "";
                switch(e.code) {
                    case FileError.QUOTA_EXCEEDED_ERR:
                        sMesg += 'QUOTA_EXCEEDED_ERR';
                        break;
                    case FileError.NOT_FOUND_ERR:
                        sMesg += 'NOT_FOUND_ERR';
                        break;
                    case FileError.SECURITY_ERR:
                        sMesg += 'SECURITY_ERR';
                        break;
                    case FileError.INVALID_MODIFICATION_ERR:
                        sMesg += 'INVALID_MODIFICATION_ERR';
                        break;
                    case FileError.INVALID_STATE_ERR:
                        sMesg += 'INVALID_STATE_ERR';
                        break;
                    default:
                        sMesg += 'Unknown Error';
                        break;
                }
                akra.logger.setSourceLocation("LocalFile.ts", 570);
                akra.logger.error(sMesg);
                ;
            };
            LocalFile.createDir = function /** @no-inline */createDir(pRootDirEntry, pFolders, fnCallback) {
                if(pFolders[0] == "." || pFolders[0] == "") {
                    pFolders = pFolders.slice(1);
                }
                pRootDirEntry.getDirectory(pFolders[0], {
                    create: true
                }, function /** @no-inline */(dirEntry) {
                    if(pFolders.length) {
                        LocalFile.createDir(dirEntry, pFolders.slice(1), fnCallback);
                    } else {
                        fnCallback(null);
                    }
                }, fnCallback);
            };
            LocalFile.defaultCallback = function /** @no-inline */(err) {
                if(err) {
                    LocalFile.errorHandler(err);
                }
            };
            return LocalFile;
        })();
        io.LocalFile = LocalFile;        
    })(akra.io || (akra.io = {}));
    var io = akra.io;
})(akra || (akra = {}));
var akra;
(function (akra) {
    /*local file via local files system(async)*/
    /**
    * FIle implementation via <Local Storage>.
    * ONLY FOR LOCAL FILES!!
    */
    (function (io) {
        var StorageFile = (function (_super) {
            __extends(StorageFile, _super);
            function /** @no-inline */StorageFile(sFilename, sMode, fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = io.TFile.defaultCallback; }
                        _super.call(this, sFilename, sMode, fnCallback);
            }
            StorageFile.prototype.clear = function /** @no-inline */(fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = io.TFile.defaultCallback; }
                if(!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function /** @no-inline */(err) {
                        if(err) {
                            fnCallback(err);
                        }
                        this.clear.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                localStorage.setItem(this.path, "");
                this._pFileMeta.size = 0;
                fnCallback(null, this);
            };
            StorageFile.prototype.read = function /** @no-inline */(fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = io.TFile.defaultCallback; }
                if(!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function /** @no-inline */(err) {
                        if(err) {
                            fnCallback(err);
                        }
                        this.read.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                akra.logger.setSourceLocation("StorageFile.ts", 36);
                akra.logger.assert(((this._iMode & (1 << (1))) != 0), "The file is not readable.");
                ;
                var pData = this.readData();
                var nPos = this._nCursorPosition;
                if(nPos) {
                    if(((this._iMode & (1 << (5))) != 0)) {
                        pData = (new Uint8Array((new Uint8Array(pData)).subarray(nPos))).buffer;
                    } else {
                        pData = pData.substr(nPos);
                    }
                }
                this.atEnd();
                if(fnCallback) {
                    fnCallback.call(this, null, pData);
                }
            };
            StorageFile.prototype.write = function /** @no-inline */(pData, fnCallback, sContentType) {
                if (typeof fnCallback === "undefined") { fnCallback = io.TFile.defaultCallback; }
                if(!this.isOpened()) {
                    var _pArgv = arguments;
                    this.open(function /** @no-inline */(err) {
                        if(err) {
                            fnCallback(err);
                        }
                        this.write.apply(this, _pArgv);
                    });
                    return;
                }
                ;
                var iMode = this._iMode;
                var nSeek;
                var pCurrentData;
                akra.logger.setSourceLocation("StorageFile.ts", 66);
                akra.logger.assert(((iMode & (1 << (1))) != 0), "The file is not writable.");
                ;
                sContentType = sContentType || (((iMode & (1 << (5))) != 0) ? "application/octet-stream" : "text/plain");
                pCurrentData = this.readData();
                if(!akra.isString(pCurrentData)) {
                    pCurrentData = akra.util.abtos(pCurrentData);
                }
                nSeek = (akra.isString(pData) ? pData.length : pData.byteLength);
                if(!akra.isString(pData)) {
                    pData = akra.util.abtos(pData);
                }
                pData = (pCurrentData).substr(0, this._nCursorPosition) + (pData) + (pCurrentData).substr(this._nCursorPosition + (pData).length);
                try  {
                    localStorage.setItem(this.path, pData);
                } catch (e) {
                    fnCallback(e);
                }
                this._pFileMeta.size = pData.length;
                this._nCursorPosition += nSeek;
                fnCallback(null);
            };
            StorageFile.prototype.isExists = function /** @no-inline */(fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = io.TFile.defaultCallback; }
                fnCallback.call(this, null, localStorage.getItem(this.path) == null);
            };
            StorageFile.prototype.remove = function /** @no-inline */(fnCallback) {
                if (typeof fnCallback === "undefined") { fnCallback = io.TFile.defaultCallback; }
                localStorage.removeItem(this.path);
                fnCallback.call(this, null);
            };
            StorageFile.prototype.readData = function /** @no-inline */() {
                var pFileMeta = this._pFileMeta;
                var pData = localStorage.getItem(this.path);
                var pDataBin;
                if(pData == null) {
                    pData = "";
                    if(((this._iMode & (1 << (1))) != 0)) {
                        localStorage.setItem(this.path, pData);
                    }
                }
                if(((this._iMode & (1 << (5))) != 0)) {
                    pDataBin = akra.util.stoab(pData);
                    pFileMeta.size = pDataBin.byteLength;
                    return pDataBin;
                } else {
                    pFileMeta.size = pData.length;
                    return pData;
                }
                //return null;
                            };
            StorageFile.prototype.update = function /** @no-inline */(fnCallback) {
                this._pFileMeta = null;
                this.readData();
                fnCallback.call(this, null);
            };
            return StorageFile;
        })(io.TFile);
        io.StorageFile = StorageFile;        
    })(akra.io || (akra.io = {}));
    var io = akra.io;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (io) {
        (function (EIO) {
            EIO._map = [];
            EIO.IN = 0x01;
            EIO.OUT = 0x02;
            EIO.ATE = 0x04;
            EIO.APP = 0x08;
            EIO.TRUNC = 0x10;
            EIO.BINARY = 0x20;
            EIO.BIN = 0x20;
            EIO.TEXT = 0x40;
        })(io.EIO || (io.EIO = {}));
        var EIO = io.EIO;
        ;
        function /** @no-inline */filemode(sMode) {
            switch(sMode.toLowerCase()) {
                case "a+t":
                    return 1 /* IN */  | 2 /* OUT */  | 8 /* APP */  | 64 /* TEXT */ ;
                case "w+t":
                    return 1 /* IN */  | 2 /* OUT */  | 16 /* TRUNC */  | 64 /* TEXT */ ;
                case "r+t":
                    return 1 /* IN */  | 2 /* OUT */  | 64 /* TEXT */ ;
                case "at":
                    return 8 /* APP */  | 64 /* TEXT */ ;
                case "wt":
                    return 2 /* OUT */  | 64 /* TEXT */ ;
                case "rt":
                    return 1 /* IN */  | 64 /* TEXT */ ;
                case "a+b":
                    return 1 /* IN */  | 2 /* OUT */  | 8 /* APP */  | 32 /* BIN */ ;
                case "w+b":
                    return 1 /* IN */  | 2 /* OUT */  | 16 /* TRUNC */  | 32 /* BIN */ ;
                case "r+b":
                    return 1 /* IN */  | 2 /* OUT */  | 32 /* BIN */ ;
                case "ab":
                    return 8 /* APP */  | 32 /* BIN */ ;
                case "wb":
                    return 2 /* OUT */  | 32 /* BIN */ ;
                case "rb":
                    return 1 /* IN */  | 32 /* BIN */ ;
                case "a+":
                    return 1 /* IN */  | 2 /* OUT */  | 8 /* APP */ ;
                case "w+":
                    return 1 /* IN */  | 2 /* OUT */  | 16 /* TRUNC */ ;
                case "r+":
                    return 1 /* IN */  | 2 /* OUT */ ;
                case "a":
                    return 8 /* APP */  | 2 /* OUT */ ;
                case "w":
                    return 2 /* OUT */ ;
                case "r":
                default:
                    return 1 /* IN */ ;
            }
        }
        io.filemode = filemode;
        // function _fopen (sUri: string, iMode?: int): IFile;
        // function _fopen (sUri: string, sMode?: int): IFile;
        // function _fopen (pUri: IURI, iMode: int): IFile;
        // function _fopen (pUri: IURI, sMode: string): IFile;
        function /** @no-inline */_fopen(sUri, pMode) {
            if (typeof pMode === "undefined") { pMode = 1 /* IN */ ; }
            if(akra.info.api.webWorker) {
                return new io.TFile(sUri, pMode);
            } else if(akra.info.api.fileSystem) {
                return new io.LocalFile(sUri, pMode);
            } else {
                return new io.StorageFile(sUri, pMode);
            }
        }
        io.fopen = _fopen;
    })(akra.io || (akra.io = {}));
    var io = akra.io;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                                                                                                                                                                                                                                                                                // globals
                var pSupportedVertexFormat;
                var pSupportedTextureFormat;
                var pSupportedWeightFormat;
                var pSupportedJointFormat;
                var pSupportedInvBindMatrixFormat;
                var pSupportedInterpolationFormat;
                var pSupportedInputFormat;
                var pSupportedOutputFormat;
                var pSupportedTangentFormat;
                var pFormatStrideTable;
                var pConvFormats;
                var Collada = (function (_super) {
                    __extends(Collada, _super);
                    function /** @no-inline */Collada() {
                                        _super.call(this);
                        //=======================================================================================
                        this._pModel = null;
                        this._pOptions = null;
                        this._pLinks = {
                        };
                        this._pLib = {
                        };
                        this._pCache = {
                            meshMap: {
                            },
                            sharedBuffer: null
                        };
                        this._pAsset = null;
                        this._pVisualScene = null;
                        this._sFilename = null;
                        this._pXMLRoot = null;
                    }
                    Collada.DEFAULT_OPTIONS = {
                        drawJoints: false,
                        wireframe: false,
                        sharedBuffer: false,
                        animation: {
                            pose: true
                        },
                        scene: true,
                        extractPoses: true,
                        skeletons: null
                    };
                    Collada.SCENE_TEMPLATE = [
                        {
                            lib: 'library_images',
                            element: 'image',
                            loader: "COLLADAImage"
                        }, 
                        {
                            lib: 'library_effects',
                            element: 'effect',
                            loader: "COLLADAEffect"
                        }, 
                        {
                            lib: 'library_materials',
                            element: 'material',
                            loader: "COLLADAMaterial"
                        }, 
                        {
                            lib: 'library_geometries',
                            element: 'geometry',
                            loader: "COLLADAGeometrie"
                        }, 
                        {
                            lib: 'library_controllers',
                            element: 'controller',
                            loader: "COLLADAController"
                        }, 
                        {
                            lib: 'library_visual_scenes',
                            element: 'visual_scene',
                            loader: "COLLADAVisualScene"
                        }
                    ];
                    Collada.ANIMATION_TEMPLATE = [
                        {
                            lib: 'library_animations',
                            element: 'animation',
                            loader: "COLLADAAnimation"
                        }
                    ];
                    Collada.COLLADA_MATERIAL_NAMES = [
                        "emission", 
                        "ambient", 
                        "diffuse", 
                        "shininess", 
                        "reflective", 
                        "reflectivity", 
                        "transparent", 
                        "transparency", 
                        "specular"
                    ];
                    Collada.prototype.trifanToTriangles = // polygon index convertion
                    function /** @no-inline */(pXML, iStride) {
                        var pFans2Tri = [
                            0, 
                            0, 
                            0
                        ];
                        var pData = [];
                        var tmp = new Array(iStride), n;
                        var pIndexes = [];
                        this.eachByTag(pXML, "p", function /** @no-inline */(pXMLData) {
                            n = string2IntArray(stringData(pXMLData), pData);
                            for(var i = 0; i < 3; i++) {
                                retrieve(pData, tmp, iStride, i, 1);
                                for(var j = 0; j < iStride; ++j) {
                                    pIndexes.push(tmp[j]);
                                }
                            }
                            for(var i = 3, m = n / iStride; i < m; i++) {
                                pFans2Tri[1] = i - 1;
                                pFans2Tri[2] = i;
                                for(var j = 0; j < pFans2Tri.length; ++j) {
                                    for(var k = 0; k < iStride; ++k) {
                                        pIndexes.push(pData[pFans2Tri[j] * iStride + k]);
                                    }
                                }
                            }
                        });
                        return pIndexes;
                    };
                    Collada.prototype.polygonToTriangles = function /** @inline */(pXML, iStride) {
                        //TODO для невыпуклых многоугольников с самоперечечениями работать будет не верно
                        return this.trifanToTriangles(pXML, iStride);
                    };
                    Collada.prototype.tristripToTriangles = function /** @no-inline */(pXML, iStride) {
                        var pStrip2Tri = [
                            0, 
                            0, 
                            0
                        ];
                        var pData = [];
                        var tmp = new Array(iStride), n;
                        var pIndexes = [];
                        this.eachByTag(pXML, "p", function /** @no-inline */(pXMLData) {
                            n = string2IntArray(stringData(pXMLData), pData);
                            for(var i = 0; i < 3; i++) {
                                retrieve(pData, tmp, iStride, i, 1);
                                for(var j = 0; j < iStride; ++j) {
                                    pIndexes.push(tmp[j]);
                                }
                            }
                            for(var i = 3, m = n / iStride; i < m; i++) {
                                pStrip2Tri[0] = i - 1;
                                pStrip2Tri[1] = i - 2;
                                pStrip2Tri[2] = i;
                                for(var j = 0; j < pStrip2Tri.length; ++j) {
                                    for(var k = 0; k < iStride; ++k) {
                                        pIndexes.push(pData[pStrip2Tri[j] * iStride + k]);
                                    }
                                }
                            }
                        });
                        return pIndexes;
                    };
                    Collada.prototype.polylistToTriangles = function /** @no-inline */(pXML, iStride) {
                        var pXMLvcount = firstChild(pXML, "vcount");
                        var pXMLp = firstChild(pXML, "p");
                        var pVcount = new Array(parseInt(attr(pXML, "count")));
                        var pData, pIndexes;
                        var n, h = 0;
                        var tmp = new Array(128);
                        var buf = new Array(256);
                        var pPoly2Tri = [
                            0, 
                            0, 
                            0
                        ];
                        string2IntArray(stringData(pXMLvcount), pVcount);
                        var nElements = 0, nTotalElement = 0;
                        for(var i = 0; i < pVcount.length; i++) {
                            nElements += pVcount[i];
                            nTotalElement += (pVcount[i] - 2) * 3;
                        }
                        pIndexes = new Array(iStride * nTotalElement);
                        pData = new Array(iStride * nElements);
                        string2IntArray(stringData(pXMLp), pData);
                        for(var i = 0, m = 0; i < pVcount.length; i++) {
                            n = retrieve(pData, tmp, iStride, m, pVcount[i]);
                            for(var j = 0; j < 3; j++) {
                                retrieve(tmp, buf, iStride, j, 1);
                                for(var k = 0; k < iStride; ++k) {
                                    pIndexes[h++] = buf[k];
                                }
                            }
                            for(var x = 3, t = n / iStride; x < t; x++) {
                                pPoly2Tri[1] = x - 1;
                                pPoly2Tri[2] = x;
                                for(var j = 0; j < pPoly2Tri.length; ++j) {
                                    for(var k = 0; k < iStride; ++k) {
                                        pIndexes[h++] = pData[(m + pPoly2Tri[j]) * iStride + k];
                                    }
                                }
                            }
                            m += pVcount[i];
                        }
                        return pIndexes;
                    };
                    Collada.prototype.eachNode = //xml
                    function /** @no-inline */(pXMLList, fnCallback, nMax) {
                        var n = pXMLList.length, i;
                        nMax = (akra.isNumber(nMax) ? (nMax < n ? nMax : n) : n);
                        n = 0;
                        i = 0;
                        while(n < pXMLList.length) {
                            //skip text nodes
                            if(pXMLList[n++].nodeType === Node.TEXT_NODE) {
                                continue;
                            }
                            var pXMLData = pXMLList[n - 1];
                            fnCallback.call(this, pXMLData, pXMLData.nodeName);
                            i++;
                            if(nMax === i) {
                                break;
                            }
                        }
                        //        for (var i = 0; i < nMax; i++) {
                        //            var pXMLData = pXMLList.item(i);
                        //            var sName = pXMLData.getNodeName();
                        //            fnCallback(pXMLData, sName);
                        //        }
                                            };
                    Collada.prototype.eachChild = function /** @no-inline */(pXML, fnCallback) {
                        this.eachNode(pXML.childNodes, fnCallback);
                    };
                    Collada.prototype.eachByTag = function /** @inline */(pXML, sTag, fnCallback, nMax) {
                        this.eachNode(pXML.getElementsByTagName(sTag), fnCallback, nMax);
                    };
                    Collada.prototype.findNode = // akra additional functions
                    function /** @no-inline */(pNodes, sNode, fnNodeCallback) {
                        if (typeof sNode === "undefined") { sNode = null; }
                        if (typeof fnNodeCallback === "undefined") { fnNodeCallback = null; }
                        var pNode = null;
                        var pRootJoint = null;
                        for(var i = pNodes.length - 1; i >= 0; i--) {
                            pNode = pNodes[i];
                            if(pNode === null) {
                                continue;
                            }
                            if(sNode && "#" + pNode.id === sNode) {
                                return pNode;
                            }
                            if(!akra.isNull(fnNodeCallback)) {
                                fnNodeCallback.call(this, pNode);
                            }
                            if(pNode.childNodes) {
                                pRootJoint = this.findNode(pNode.childNodes, sNode, fnNodeCallback);
                                if(!akra.isNull(pRootJoint)) {
                                    return pRootJoint;
                                }
                            }
                        }
                        return null;
                    };
                    Collada.prototype.COLLADATranslateMatrix = // helper functions
                    function /** @no-inline */(pXML) {
                        var pData = new Array(3);
                        string2FloatArray(stringData(pXML), pData);
                        return (akra.vec3(pData)).toTranslationMatrix();
                    };
                    Collada.prototype.COLLADARotateMatrix = function /** @no-inline */(pXML) {
                        var pData = new Array(4);
                        string2FloatArray(stringData(pXML), pData);
                        return (new akra.Mat4(1)).rotateLeft(pData[3] * Math.PI / 180.0, akra.vec3(pData[0], pData[1], pData[2]));
                    };
                    Collada.prototype.COLLADAScaleMatrix = function /** @no-inline */(pXML) {
                        var pData = new Array(3);
                        string2FloatArray(stringData(pXML), pData);
                        return new akra.Mat4(pData[0], pData[1], pData[2], 1.0);
                    };
                    Collada.prototype.COLLADAData = function /** @no-inline */(pXML) {
                        var sName = pXML.nodeName;
                        var sData = stringData(pXML);
                        switch(sName) {
                            case "bool":
                                return string2Any(sData, 1, "bool");
                            case "int":
                                return string2Any(sData, 1, "int");
                            case "float":
                                return string2Any(sData, 1, "float");
                            case "float2":
                                return string2Any(sData, 2, "float");
                            case "float3":
                                return string2Any(sData, 3, "float");
                            case "float4":
                            case "color":
                                return string2Any(sData, 4, "float");
                            case "rotate":
                                return this.COLLADARotateMatrix(pXML);
                            case "translate":
                                return this.COLLADATranslateMatrix(pXML);
                            case "scale":
                                return this.COLLADAScaleMatrix(pXML);
                            case "bind_shape_matrix":
                            case "matrix":
                                return (new akra.Mat4(string2Any(sData, 16, "float"), true)).transpose();
                            case "float_array":
                                return string2Any(sData, parseInt(attr(pXML, "count")), "float", true);
                            case "int_array":
                                return string2Any(sData, parseInt(attr(pXML, "count")), "int", true);
                            case "bool_array":
                                return string2Any(sData, parseInt(attr(pXML, "count")), "bool", true);
                            case "Name_array":
                            case "name_array":
                            case "IDREF_array":
                                return string2Any(sData, parseInt(attr(pXML, "count")), "string", true);
                            case "sampler2D":
                                return this.COLLADASampler2D(pXML);
                            case "surface":
                                return this.COLLADASurface(pXML);
                            default:
                                akra.logger.setSourceLocation("resources/Collada.ts", 580);
                                akra.logger.error("unsupported COLLADA data type <" + sName + " />");
                                ;
                        }
                        //return null;
                                            };
                    Collada.prototype.COLLADAGetSourceData = function /** @no-inline */(pSource, pFormat) {
                        akra.logger.setSourceLocation("resources/Collada.ts", 588);
                        akra.logger.assert(akra.isDefAndNotNull(pSource), "<source /> with expected format ", pFormat, " not founded");
                        ;
                        var nStride = calcFormatStride(pFormat);
                        var pTech = pSource.techniqueCommon;
                        akra.logger.setSourceLocation("resources/Collada.ts", 593);
                        akra.logger.assert(akra.isDefAndNotNull(pTech), "<source /> with id <" + pSource.id + "> has no <technique_common />");
                        ;
                        var pAccess = pTech.accessor;
                        var isFormatSupported;
                        if(!(pAccess.stride <= nStride)) {
                            akra.logger.setSourceLocation("resources/Collada.ts", 600);
                            akra.logger.log(pAccess.stride, "/", nStride);
                            ;
                        }
                        akra.logger.setSourceLocation("resources/Collada.ts", 605);
                        akra.logger.assert(pAccess.stride <= nStride, "<source /> width id" + pSource.id + " has unsupported stride: " + pAccess.stride);
                        ;
                        var fnUnsupportedFormatError = function /** @no-inline */() {
                            akra.logger.setSourceLocation("resources/Collada.ts", 608);
                            akra.logger.log("expected format: ", pFormat);
                            ;
                            akra.logger.setSourceLocation("resources/Collada.ts", 609);
                            akra.logger.log("given format: ", pAccess.params);
                            ;
                            akra.logger.setSourceLocation("resources/Collada.ts", 610);
                            akra.logger.error("accessor of <" + pSource.id + "> has unsupported format");
                            ;
                        };
                        for(var i = 0; i < pAccess.params.length; ++i) {
                            isFormatSupported = false;
                            //finding name in format names..
                            for(var f = 0; f < pFormat[i].name.length; ++f) {
                                if((pAccess.params[i].name || "").toLowerCase() == (pFormat[i].name[f] || "").toLowerCase()) {
                                    isFormatSupported = true;
                                }
                            }
                            if(!isFormatSupported) {
                                fnUnsupportedFormatError();
                            }
                            isFormatSupported = false;
                            for(var f = 0; f < pFormat[i].type.length; ++f) {
                                if(pAccess.params[i].type.toLowerCase() == pFormat[i].type[f].toLowerCase()) {
                                    isFormatSupported = true;
                                }
                            }
                            if(!isFormatSupported) {
                                fnUnsupportedFormatError();
                            }
                        }
                        return pAccess.data;
                    };
                    Collada.prototype.COLLADATransform = // common
                    // -----------------------------------------------------------
                    function /** @no-inline */(pXML, id) {
                        var pTransform = {
                            sid: attr(pXML, "sid"),
                            transform: String(pXML.nodeName),
                            value: null
                        };
                        if(akra.isString(id) && akra.isDefAndNotNull(pTransform.sid)) {
                            this.link(id + "/" + pTransform.sid, pTransform);
                        } else {
                            this.link(id + "/" + pTransform.transform, pTransform);
                        }
                        var v4f, m4f;
                        var pData;
                        switch(pTransform.transform) {
                            case "rotate":
                                pData = new Array(4);
                                string2FloatArray(stringData(pXML), pData);
                                v4f = new akra.Vec4(pData);
                                /* to radians. */
                                v4f.w *= Math.PI / 180.0;
                                pTransform.value = v4f;
                                break;
                            case "translate":
                            case "scale":
                                pData = new Array(3);
                                string2FloatArray(stringData(pXML), pData);
                                pTransform.value = new akra.Vec3(pData);
                                break;
                            case "matrix":
                                m4f = new akra.Mat4();
                                string2FloatArray(stringData(pXML), m4f.data);
                                m4f.transpose();
                                pTransform.value = m4f;
                                break;
                            default:
                                akra.logger.setSourceLocation("resources/Collada.ts", 697);
                                akra.logger.error("unsupported transform detected: " + pTransform.transform);
                                ;
                        }
                        return pTransform;
                    };
                    Collada.prototype.COLLADANewParam = function /** @no-inline */(pXML) {
                        var _this = this;
                        var pParam = {
                            sid: attr(pXML, "sid"),
                            annotate: null,
                            semantics: null,
                            modifier: null,
                            value: null,
                            type: null
                        };
                        this.eachChild(pXML, function /** @no-inline */(pXMLData, sName) {
                            switch(sName) {
                                case "semantic":
                                    pParam.semantics = stringData(pXMLData);
                                    break;
                                case "modifier":
                                    pParam.modifier = stringData(pXMLData);
                                case "annotate":
                                    pParam.annotate = {
                                        name: attr(pXMLData, "name"),
                                        value: stringData(pXMLData)
                                    };
                                case "float":
                                case "float2":
                                case "float3":
                                case "float4":
                                case "surface":
                                case "sampler2D":
                                    pParam.type = sName;
                                    pParam.value = _this.COLLADAData(pXMLData);
                                    break;
                                default:
                                    pParam.value = _this.COLLADAData(pXMLData);
                            }
                        });
                        this.link(pParam.sid, pParam);
                        return pParam;
                    };
                    Collada.prototype.COLLADAAsset = function /** @no-inline */(pXML) {
                        var pAsset = {
                            unit: {
                                meter: 1.0,
                                name: "meter"
                            },
                            upAxis: "Y_UP",
                            title: null,
                            created: null,
                            modified: null,
                            contributor: {
                                author: null,
                                authoringTool: null,
                                comments: null,
                                copyright: null,
                                sourceData: null
                            }
                        };
                        this.eachChild(pXML, function /** @no-inline */(pXMLNode, sName) {
                            var sValue = stringData(pXMLNode);
                            switch(sName) {
                                case "up_axis":
                                    pAsset.upAxis = sValue;
                                    break;
                                case "created":
                                    pAsset.created = sValue;
                                    break;
                                case "modified":
                                    pAsset.modified = sValue;
                                    break;
                                case "title":
                                    pAsset.title = sValue;
                                    break;
                                case "contributor":
                                    //TODO contributor
                                    break;
                                case "unit":
                                    pAsset.unit.meter = parseFloat(attr(pXMLNode, "meter"));
                                    pAsset.unit.name = attr(pXMLNode, "name");
                                    break;
                            }
                        });
                        return this._pAsset = pAsset;
                    };
                    Collada.prototype.COLLADALibrary = function /** @no-inline */(pXML, pTemplate) {
                        var _this = this;
                        if(!akra.isDefAndNotNull(pXML)) {
                            return null;
                        }
                        var pLib = {
                        };
                        var pData;
                        var sTag = pTemplate.element;
                        pLib[sTag] = {
                        };
                        this.eachChild(pXML, function /** @no-inline */(pXMLData, sName) {
                            if(sTag !== sName) {
                                return;
                            }
                            pData = (((_this)[pTemplate.loader]))(pXMLData);
                            if(akra.isNull(pData)) {
                                return;
                            }
                            pLib[sTag][attr(pXMLData, 'id')] = pData;
                        });
                        return pLib;
                    };
                    Collada.prototype.COLLADAAccessor = // geometry
                    function /** @no-inline */(pXML) {
                        var pAccessor = {
                            data: this.source(attr(pXML, "source")),
                            count: parseInt(attr(pXML, "count")),
                            stride: parseInt(attr(pXML, "stride") || 1),
                            params: []
                        };
                        this.eachChild(pXML, function /** @no-inline */(pXMLData, sName) {
                            pAccessor.params.push({
                                name: attr(pXMLData, "name"),
                                type: attr(pXMLData, "type")
                            });
                        });
                        return pAccessor;
                    };
                    Collada.prototype.COLLADAInput = //dangerous: the default offset is 0, but collada required this attribute
                    function /** @no-inline */(pXML, iOffset) {
                        if (typeof iOffset === "undefined") { iOffset = 0; }
                        var pInput = {
                            semantics: attr(pXML, "semantic"),
                            source: this.source(attr(pXML, "source")),
                            offset: -1,
                            set: attr(pXML, "set")
                        };
                        //pInput.set = (pInput.set ? parseInt(pInput.set) : 0);
                        if(!akra.isNull(attr(pXML, "offset"))) {
                            pInput.offset = parseInt(attr(pXML, "offset"));
                        }
                        if(akra.isInt(iOffset) && pInput.offset === -1) {
                            pInput.offset = iOffset;
                        }
                        akra.logger.setSourceLocation("resources/Collada.ts", 873);
                        akra.logger.assert(akra.isInt(pInput.offset) && pInput.offset >= 0, "invalid offset detected");
                        ;
                        return pInput;
                    };
                    Collada.prototype.COLLADATechniqueCommon = function /** @no-inline */(pXML) {
                        var _this = this;
                        var pTechniqueCommon = {
                            accessor: null
                        };
                        this.eachChild(pXML, function /** @no-inline */(pXMLData, sName) {
                            switch(sName) {
                                case "accessor":
                                    pTechniqueCommon.accessor = _this.COLLADAAccessor(pXMLData);
                                    break;
                            }
                        });
                        return pTechniqueCommon;
                    };
                    Collada.prototype.COLLADASource = function /** @no-inline */(pXML) {
                        var _this = this;
                        var pSource = {
                            id: attr(pXML, "id"),
                            name: attr(pXML, "name"),
                            array: {
                            },
                            techniqueCommon: null
                        };
                        this.link(pSource);
                        this.eachChild(pXML, function /** @no-inline */(pXMLData, sName) {
                            var pColladaArray;
                            var id;
                            switch(sName.toLowerCase()) {
                                case "int_array":
                                case "bool_array":
                                case "float_array":
                                case "idref_array":
                                case "name_array":
                                    pColladaArray = _this.COLLADAData(pXMLData);
                                    id = attr(pXMLData, "id");
                                    pSource.array[id] = pColladaArray;
                                    _this.link(id, pColladaArray);
                                    break;
                                case "technique_common":
                                    pSource.techniqueCommon = _this.COLLADATechniqueCommon(pXMLData);
                                    break;
                            }
                        });
                        return pSource;
                    };
                    Collada.prototype.COLLADAVertices = function /** @no-inline */(pXML) {
                        var pVertices = {
                            id: attr(pXML, "id"),
                            inputs: {
                            }
                        };
                        this.eachByTag(pXML, "input", function /** @no-inline */(pXMLData) {
                            var sSemantic = attr(pXMLData, "semantic");
                            pVertices.inputs[sSemantic] = this.COLLADAInput(pXMLData);
                        });
                        akra.logger.setSourceLocation("resources/Collada.ts", 945);
                        akra.logger.assert(akra.isDefAndNotNull(pVertices.inputs["POSITION"]), "semantics POSITION must be in the <vertices /> tag");
                        ;
                        this.link(pVertices);
                        return pVertices;
                    };
                    Collada.prototype.COLLADAJoints = function /** @no-inline */(pXML) {
                        var _this = this;
                        var pJoints = {
                            inputs: {
                            }
                        };
                        var pMatrixArray;
                        var iCount;
                        var pInvMatrixArray;
                        this.eachByTag(pXML, "input", function /** @no-inline */(pXMLData) {
                            switch(attr(pXMLData, "semantic")) {
                                case "JOINT":
                                    pJoints.inputs["JOINT"] = _this.COLLADAInput(pXMLData);
                                    break;
                                case "INV_BIND_MATRIX":
                                    pJoints.inputs["INV_BIND_MATRIX"] = _this.COLLADAInput(pXMLData);
                                    break;
                                default:
                                    akra.logger.setSourceLocation("resources/Collada.ts", 972);
                                    akra.logger.error("semantics are different from JOINT/INV_BIND_MATRIX is not supported in the <joints /> tag");
                                    ;
                            }
                        });
                        for(var sInput in pJoints.inputs) {
                            this.prepareInput(pJoints.inputs[sInput]);
                            if(sInput === "INV_BIND_MATRIX") {
                                pInvMatrixArray = new Float32Array(pJoints.inputs[sInput].array);
                                iCount = pInvMatrixArray.length / 16;
                                pMatrixArray = new Array(iCount);
                                for(var j = 0, n = 0; j < pInvMatrixArray.length; j += 16) {
                                    pMatrixArray[n++] = (new akra.Mat4(new Float32Array(pInvMatrixArray.buffer, j * Float32Array.BYTES_PER_ELEMENT, 16), true)).transpose();
                                }
                                pJoints.inputs[sInput].array = pMatrixArray;
                            }
                        }
                        return pJoints;
                    };
                    Collada.prototype.COLLADAPolygons = function /** @no-inline */(pXML, sType) {
                        var _this = this;
                        var pPolygons = {
                            inputs: /*потоки данных*/
                            [],
                            p: /*индексы*/
                            null,
                            material: /*идентификатор материала*/
                            attr(pXML, "material"),
                            name: /*имя (встречается редко, не используется)*/
                            null
                        };
                        var iOffset = 0, n = 0;
                        var iCount = parseInt(attr(pXML, "count"));
                        var iStride;
                        this.eachByTag(pXML, "input", function /** @no-inline */(pXMLData) {
                            pPolygons.inputs.push(_this.COLLADAInput(pXMLData, iOffset));
                            iOffset++;
                        });
                        sortArrayByProperty(pPolygons.inputs, "iOffset");
                        iStride = (pPolygons.inputs.last).offset + 1;
                        switch(sType) {
                            case "polylist":
                                pPolygons.p = this.polylistToTriangles(pXML, iStride);
                                break;
                            case "polygons":
                                pPolygons.p = this.polygonToTriangles(pXML, iStride);
                                this.eachByTag(pXML, "ph", function /** @no-inline */(pXMLData) {
                                    akra.logger.setSourceLocation("resources/Collada.ts", 1030);
                                    akra.logger.error("unsupported polygon[polygon] subtype founded: <ph>");
                                    ;
                                });
                                break;
                            case "triangles":
                                pPolygons.p = new Array(3 * iCount * iStride);
                                this.eachByTag(pXML, "p", function /** @no-inline */(pXMLData) {
                                    n += string2IntArray(stringData(pXMLData), pPolygons.p, n);
                                });
                                break;
                            case "trifans":
                                pPolygons.p = this.trifanToTriangles(pXML, iStride);
                                break;
                            case "tristrips":
                                pPolygons.p = this.tristripToTriangles(pXML, iStride);
                                break;
                            default:
                                akra.logger.setSourceLocation("resources/Collada.ts", 1052);
                                akra.logger.error("unsupported polygon[" + sType + "] type founded");
                                ;
                        }
                        if(!akra.isDef(pPolygons.type)) {
                            pPolygons.type = 4 /* TRIANGLELIST */ ;
                        }
                        return pPolygons;
                    };
                    Collada.prototype.COLLADAVertexWeights = function /** @no-inline */(pXML) {
                        var _this = this;
                        var pVertexWeights = {
                            count: parseInt(attr(pXML, "count")),
                            inputs: [],
                            weightInput: null,
                            vcount: null,
                            v: null
                        };
                        var iOffset = 0;
                        var pInput;
                        this.eachByTag(pXML, "input", function /** @no-inline */(pXMLData) {
                            pInput = _this.COLLADAInput(pXMLData, iOffset);
                            if(pInput.semantics === "WEIGHT") {
                                pVertexWeights.weightInput = pInput;
                            }
                            pVertexWeights.inputs.push(pInput);
                            iOffset++;
                        });
                        var pVcountData, pVData;
                        pVcountData = new Array(pVertexWeights.count);
                        string2IntArray(stringData(firstChild(pXML, "vcount")), pVcountData);
                        pVertexWeights.vcount = pVcountData;
                        var n = 0;
                        for(var i = 0; i < pVcountData.length; ++i) {
                            n += pVcountData[i];
                        }
                        n *= pVertexWeights.inputs.length;
                        akra.logger.setSourceLocation("resources/Collada.ts", 1102);
                        akra.logger.error(pVertexWeights.inputs.length === 2, "more than 2 inputs in <vertex_weights/> not supported currently");
                        ;
                        pVData = new Array(n);
                        string2IntArray(stringData(firstChild(pXML, "v")), pVData);
                        pVertexWeights.v = pVData;
                        return pVertexWeights;
                    };
                    Collada.prototype.COLLADAMesh = function /** @no-inline */(pXML) {
                        var _this = this;
                        var pMesh = {
                            sources: [],
                            polygons: []
                        };
                        var id;
                        var pPolygons, pVertices, pPos;
                        this.eachChild(pXML, function /** @no-inline */(pXMLData, sName) {
                            switch(sName) {
                                case "source":
                                    pMesh.sources.push(_this.COLLADASource(pXMLData));
                                    break;
                                case "vertices":
                                    pVertices = _this.COLLADAVertices(pXMLData);
                                    break;
                                case "lines":
                                case "linestrips":
                                case "tristrips":
                                case "trifans":
                                case "triangles":
                                case "polygons":
                                case "polylist":
                                    pPolygons = _this.COLLADAPolygons(pXMLData, sName);
                                    for(var i = 0; i < pPolygons.inputs.length; ++i) {
                                        pPos = null;
                                        if(pPolygons.inputs[i].semantics == "VERTEX") {
                                            if(pPolygons.inputs[i].source.id == pVertices.id) {
                                                pPos = pVertices.inputs["POSITION"];
                                                pPolygons.inputs[i].source = pPos.source;
                                                pPolygons.inputs[i].semantics = pPos.semantics;
                                            } else {
                                                akra.logger.setSourceLocation("resources/Collada.ts", 1152);
                                                akra.logger.error("<input /> with semantic VERTEX must refer to <vertices /> tag in same mesh.");
                                                ;
                                            }
                                        }
                                        _this.prepareInput(pPolygons.inputs[i]);
                                    }
                                    pMesh.polygons.push(pPolygons);
                                    break;
                            }
                        });
                        return pMesh;
                    };
                    Collada.prototype.COLLADAGeometrie = function /** @no-inline */(pXML) {
                        var pGeometrie = {
                            id: attr(pXML, "id"),
                            name: attr(pXML, "name"),
                            mesh: null,
                            convexMesh: null,
                            spline: null
                        };
                        var pXMLData = firstChild(pXML);
                        var sName = pXMLData.nodeName;
                        if(sName == "mesh") {
                            pGeometrie.mesh = this.COLLADAMesh(pXMLData);
                        }
                        this.link(pGeometrie);
                        return pGeometrie;
                    };
                    Collada.prototype.COLLADASkin = function /** @no-inline */(pXML) {
                        var _this = this;
                        var pSkin = {
                            shapeMatrix: this.COLLADAData(firstChild(pXML, "bind_shape_matrix")),
                            sources: [],
                            geometry: this.source(attr(pXML, "source")),
                            joints: null,
                            vertexWeights: null
                        };
                        //TODO:  add other parameters to skin section
                                                var pVertexWeights, pInput;
                        this.eachChild(pXML, function /** @no-inline */(pXMLData, sName) {
                            switch(sName) {
                                case "source":
                                    pSkin.sources.push(_this.COLLADASource(pXMLData));
                                    break;
                                case "joints":
                                    pSkin.joints = _this.COLLADAJoints(pXMLData);
                                    break;
                                case "vertex_weights":
                                    pVertexWeights = _this.COLLADAVertexWeights(pXMLData);
                                    for(var i = 0; i < pVertexWeights.inputs.length; ++i) {
                                        pInput = _this.prepareInput(pVertexWeights.inputs[i]);
                                    }
                                    pSkin.vertexWeights = pVertexWeights;
                                    break;
                            }
                        });
                        return pSkin;
                    };
                    Collada.prototype.COLLADAController = function /** @no-inline */(pXML) {
                        var pController = {
                            name: attr(pXML, "name"),
                            id: attr(pXML, "id"),
                            skin: null,
                            morph: null
                        };
                        var pXMLData = firstChild(pXML, "skin");
                        if(akra.isNull(pXMLData)) {
                            pController.skin = this.COLLADASkin(pXMLData);
                        } else {
                            return null;
                        }
                        this.link(pController);
                        return pController;
                    };
                    Collada.prototype.COLLADAImage = // images
                    function /** @no-inline */(pXML) {
                        var pImage = {
                            id: attr(pXML, "id"),
                            name: attr(pXML, "name"),
                            format: attr(pXML, "format"),
                            height: /*-1 == auto detection*/
                            parseInt(attr(pXML, "height") || -1),
                            width: parseInt(attr(pXML, "width") || -1),
                            depth: /*only 2D images supported*/
                            1,
                            data: null,
                            path: null
                        };
                        var sFilename = this.getFilename();
                        var sPath = null;
                        var pXMLInitData = firstChild(pXML, "init_from"), pXMLData;
                        if(akra.isDefAndNotNull(pXMLInitData)) {
                            sPath = stringData(pXMLInitData);
                            //modify path to the textures relative to a given file
                            if(!akra.isNull(sFilename)) {
                                if(!akra.util.pathinfo(sPath).isAbsolute()) {
                                    sPath = akra.util.pathinfo(sFilename).dirname + "/" + sPath;
                                }
                            }
                            pImage.path = sPath;
                        } else if(akra.isDefAndNotNull(pXMLData = firstChild(pXML, "data"))) {
                            akra.logger.setSourceLocation("resources/Collada.ts", 1283);
                            akra.logger.error("image loading from <data /> tag unsupported yet.");
                            ;
                        } else {
                            akra.logger.setSourceLocation("resources/Collada.ts", 1286);
                            akra.logger.error("image with id: " + pImage.id + " has no data.");
                            ;
                        }
                        this.link(pImage);
                        return pImage;
                    };
                    Collada.prototype.COLLADASurface = // effects
                    function /** @no-inline */(pXML) {
                        var pSurface = {
                            initFrom: stringData(firstChild(pXML, "init_from"))
                        };
                        //, format: stringData(firstChild(pXML, "format"))
                        return pSurface;
                    };
                    Collada.prototype.COLLADATexture = function /** @no-inline */(pXML) {
                        var pTexture = {
                            texcoord: attr(pXML, "texcoord"),
                            sampler: this.source(attr(pXML, "texture")),
                            surface: null,
                            image: null
                        };
                        if(!akra.isNull(pTexture.sampler) && akra.isDefAndNotNull(pTexture.sampler.value)) {
                            pTexture.surface = this.source((pTexture.sampler.value).source);
                        }
                        if(!akra.isNull(pTexture.surface)) {
                            pTexture.image = this.source((pTexture.surface.value).initFrom);
                        }
                        return pTexture;
                    };
                    Collada.prototype.COLLADASampler2D = function /** @no-inline */(pXML) {
                        var pSampler = {
                            source: stringData(firstChild(pXML, "source")),
                            wrapS: stringData(firstChild(pXML, "wrap_s")),
                            wrapT: stringData(firstChild(pXML, "wrap_t")),
                            minFilter: stringData(firstChild(pXML, "minfilter")),
                            mipFilter: stringData(firstChild(pXML, "mipfilter")),
                            magFilter: stringData(firstChild(pXML, "magfilter"))
                        };
                        return pSampler;
                    };
                    Collada.prototype.COLLADAPhong = function /** @no-inline */(pXML) {
                        var _this = this;
                        var pMat = {
                            diffuse: new akra.Color(0.),
                            specular: new akra.Color(0.),
                            ambient: new akra.Color(0.),
                            emissive: new akra.Color(0.),
                            shininess: 0.0,
                            reflective: new akra.Color(0.),
                            reflectivity: 0.0,
                            transparent: new akra.Color(0.),
                            transparency: 0.0,
                            indexOfRefraction: 0.0,
                            textures: {
                                diffuse: null,
                                specular: null,
                                ambient: null,
                                emissive: null
                            }
                        };
                        var pXMLData;
                        var pList = Collada.COLLADA_MATERIAL_NAMES;
                        for(var i = 0; i < pList.length; i++) {
                            var csComponent = pList[i];
                            pXMLData = firstChild(pXML, csComponent);
                            //emission --> emissive
                            //emission does not exists in akra engine materials
                            if(csComponent === "emission") {
                                csComponent = "emissive";
                            }
                            if(pXMLData) {
                                this.eachChild(pXMLData, function /** @no-inline */(pXMLData, sName) {
                                    switch(sName) {
                                        case "float":
                                            pMat[csComponent] = _this.COLLADAData(pXMLData);
                                            break;
                                        case "color":
                                            pMat[csComponent].set(_this.COLLADAData(pXMLData));
                                            break;
                                        case "texture":
                                            pMat.textures[csComponent] = _this.COLLADATexture(pXMLData);
                                    }
                                });
                            }
                        }
                        // correct shininess
                        pMat.shininess *= 10.0;
                        return pMat;
                    };
                    Collada.prototype.COLLADAEffectTechnique = function /** @no-inline */(pXML) {
                        var pTech = {
                            sid: attr(pXML, "sid"),
                            type: null,
                            value: null
                        };
                        var pValue = firstChild(pXML);
                        pTech.type = pValue.nodeName;
                        switch(pTech.type) {
                            case //FIXME: at now, all materials draws similar..
                            "blinn":
                            case "lambert":
                                akra.logger.setSourceLocation("resources/Collada.ts", 1416);
                                akra.logger.warning("<blinn /> or <lambert /> material interprated as phong");
                                ;
                            case "phong":
                                pTech.value = this.COLLADAPhong(pValue);
                                break;
                            default:
                                akra.logger.setSourceLocation("resources/Collada.ts", 1422);
                                akra.logger.error("unsupported technique <" + pTech.type + " /> founded");
                                ;
                        }
                        this.link(pTech.sid, pTech);
                        return pTech;
                    };
                    Collada.prototype.COLLADAProfileCommon = function /** @no-inline */(pXML) {
                        var _this = this;
                        var pProfile = {
                            technique: null,
                            newParam: {
                            }
                        };
                        this.eachByTag(pXML, "newparam", function /** @no-inline */(pXMLData) {
                            pProfile.newParam[attr(pXMLData, "sid")] = _this.COLLADANewParam(pXMLData);
                        });
                        pProfile.technique = this.COLLADAEffectTechnique(firstChild(pXML, "technique"));
                        return pProfile;
                    };
                    Collada.prototype.COLLADAEffect = function /** @no-inline */(pXML) {
                        var _this = this;
                        var pEffect = {
                            id: attr(pXML, "id"),
                            profileCommon: null
                        };
                        this.eachChild(pXML, function /** @no-inline */(pXMLData, sName) {
                            switch(sName) {
                                case "profile_COMMON":
                                    pEffect.profileCommon = _this.COLLADAProfileCommon(pXMLData);
                                    pEffect.profileCommon.technique.value.name = pEffect.id;
                                    break;
                                case "extra":
                                    break;
                                default:
                                    akra.logger.setSourceLocation("resources/Collada.ts", 1462);
                                    akra.logger.error("<" + sName + " /> unsupported in effect section");
                                    ;
                            }
                        });
                        this.link(pEffect);
                        return pEffect;
                    };
                    Collada.prototype.COLLADAMaterial = //materials
                    function /** @no-inline */(pXML) {
                        var pMaterial = {
                            id: attr(pXML, "id"),
                            name: attr(pXML, "name"),
                            instanceEffect: this.COLLADAInstanceEffect(firstChild(pXML, "instance_effect"))
                        };
                        this.link(pMaterial);
                        return pMaterial;
                    };
                    Collada.prototype.COLLADANode = // scene
                    function /** @no-inline */(pXML, iDepth) {
                        if (typeof iDepth === "undefined") { iDepth = 0; }
                        var _this = this;
                        var pNode = {
                            id: attr(pXML, "id"),
                            sid: attr(pXML, "sid"),
                            name: attr(pXML, "name") || "unknown",
                            type: attr(pXML, "type"),
                            layer: attr(pXML, "layer"),
                            transform: new akra.Mat4(1),
                            geometry: [],
                            controller: [],
                            childNodes: [],
                            depth: iDepth,
                            transforms: [],
                            constructedNode: /*<! узел, в котором будет хранится ссылка на реальный игровой нод, построенный по нему*/
                            null
                        };
                        var m4fMatrix;
                        var sType;
                        var id, sid;
                        this.link(pNode);
                        this.eachChild(pXML, function /** @no-inline */(pXMLData, sName) {
                            switch(sName) {
                                case "rotate":
                                case "matrix":
                                case "translate":
                                case "scale":
                                    pNode.transforms.push(_this.COLLADATransform(pXMLData, pNode.id));
                                    pNode.transform.multiply(_this.COLLADAData(pXMLData));
                                    break;
                                case "instance_geometry":
                                    pNode.geometry.push(_this.COLLADAInstanceGeometry(pXMLData));
                                    break;
                                case "instance_controller":
                                    pNode.controller.push(_this.COLLADAInstanceController(pXMLData));
                                    break;
                                case "node":
                                    pNode.childNodes.push(_this.COLLADANode(pXMLData, iDepth + 1));
                                    break;
                            }
                        });
                        //TODO: do not load empty nodes..
                        // if (!pNode.pGeometry.length &&
                        //     !pNode.pController.length &&
                        //     !pNode.pChildNodes.length) {
                        //     return null;
                        // }
                        return pNode;
                    };
                    Collada.prototype.COLLADAVisualScene = function /** @no-inline */(pXML) {
                        var _this = this;
                        var pNode;
                        var pScene = {
                            id: attr(pXML, "id"),
                            name: attr(pXML, "name"),
                            nodes: []
                        };
                        this.link(pScene);
                        this.eachChild(pXML, function /** @no-inline */(pXMLData, sName) {
                            switch(sName) {
                                case "node":
                                    pNode = _this.COLLADANode(pXMLData);
                                    if(akra.isDefAndNotNull(pNode)) {
                                        pScene.nodes.push(pNode);
                                    }
                                    break;
                            }
                        });
                        return pScene;
                    };
                    Collada.prototype.COLLADABindMaterial = function /** @no-inline */(pXML) {
                        var _this = this;
                        if(akra.isNull(pXML)) {
                            return null;
                        }
                        var pMaterials = {
                        };
                        var pMat = null;
                        var pSourceMat = null;
                        var pTech = firstChild(pXML, "technique_common");
                        this.eachByTag(pTech, "instance_material", function /** @no-inline */(pInstMat) {
                            pSourceMat = _this.source(attr(pInstMat, "target"));
                            pMat = {
                                target: // url         : pSourceMat.instanceEffect.url,
                                attr(pInstMat, "target"),
                                symbol: attr(pInstMat, "symbol"),
                                material: pSourceMat,
                                vertexInput: {
                                }
                            };
                            _this.eachByTag(pInstMat, "bind_vertex_input", function /** @no-inline */(pXMLVertexInput) {
                                var sInputSemantic = attr(pXMLVertexInput, "input_semantic");
                                if(sInputSemantic !== "TEXCOORD") {
                                    akra.logger.setSourceLocation("resources/Collada.ts", 1596);
                                    akra.logger.error("unsupported vertex input semantics founded: " + sInputSemantic);
                                    ;
                                }
                                var sSemantic = attr(pXMLVertexInput, "semantic");
                                var iInputSet = parseInt(attr(pXMLVertexInput, "input_set"));
                                pMat.vertexInput[sSemantic] = {
                                    semantics: sSemantic,
                                    inputSet: iInputSet,
                                    inputSemantic: sInputSemantic
                                };
                            });
                            pMaterials[pMat.symbol] = pMat;
                        });
                        return pMaterials;
                    };
                    Collada.prototype.COLLADAInstanceEffect = function /** @no-inline */(pXML) {
                        var _this = this;
                        var pInstance = {
                            parameters: {
                            },
                            techniqueHint: {
                            },
                            effect: null
                        };
                        /*
                        Exmaple for <instance_effect /> :
                        
                        <instance_effect url="CarPaint">
                        <technique_hint profile="CG" platform="PS3" ref="precalc_texture"/>
                        <setparam ref="diffuse_color">
                        <float3> 0.3 0.25 0.85 </float3>
                        </setparam>
                        </instance_effect>
                        */
                        pInstance.effect = this.source(attr(pXML, "url"));
                        this.eachByTag(pXML, "technique_hint", function /** @no-inline */(pXMLData) {
                            pInstance.techniqueHint[attr(pXMLData, "platform")] = attr(pXMLData, "ref");
                            akra.logger.setSourceLocation("resources/Collada.ts", 1638);
                            akra.logger.warning("<technique_hint /> used, but will be ignored!");
                            ;
                        });
                        this.eachByTag(pXML, "setparam", function /** @no-inline */(pXMLData) {
                            //can be any type
                            pInstance.parameters[attr(pXMLData, "ref")] = _this.COLLADAData(pXMLData);
                            akra.logger.setSourceLocation("resources/Collada.ts", 1644);
                            akra.logger.warning("<setparam /> used, but will be ignored!");
                            ;
                        });
                        return pInstance;
                    };
                    Collada.prototype.COLLADAInstanceController = function /** @no-inline */(pXML) {
                        var pInst = {
                            controller: this.source(attr(pXML, "url")),
                            material: this.COLLADABindMaterial(firstChild(pXML, "bind_material")),
                            skeletons: []
                        };
                        this.eachByTag(pXML, "skeleton", function /** @no-inline */(pXMLData) {
                            //cut # symbol from skeleton name
                            pInst.skeletons.push(stringData(pXMLData).substr(1));
                        });
                        return pInst;
                    };
                    Collada.prototype.COLLADAInstanceGeometry = function /** @no-inline */(pXML) {
                        var pInst = {
                            geometry: this.source(attr(pXML, "url")),
                            material: this.COLLADABindMaterial(firstChild(pXML, "bind_material"))
                        };
                        return pInst;
                    };
                    Collada.prototype.COLLADAScene = // directly load <visual_scene> from <instance_visual_scene> from <scene>.
                    function /** @no-inline */(pXML) {
                        var pXMLData = firstChild(pXML, "instance_visual_scene");
                        var pScene = this.source(attr(pXMLData, "url"));
                        if(akra.isNull(pXMLData) || akra.isNull(pScene)) {
                            akra.logger.setSourceLocation("resources/Collada.ts", 1680);
                            akra.logger.warning("collada model: <" + this.getBasename() + "> has no visual scenes.");
                            ;
                        }
                        return this._pVisualScene = pScene;
                    };
                    Collada.prototype.COLLADAAnimationSampler = // animation
                    function /** @no-inline */(pXML) {
                        var _this = this;
                        var pSampler = {
                            inputs: {
                            },
                            id: attr(pXML, "id")
                        };
                        var pInput;
                        var sSemantic;
                        this.link(pSampler);
                        this.eachByTag(pXML, "input", function /** @no-inline */(pXMLData) {
                            sSemantic = attr(pXMLData, "semantic");
                            switch(sSemantic) {
                                case "INPUT":
                                case "OUTPUT":
                                case "INTERPOLATION":
                                case "IN_TANGENT":
                                case "OUT_TANGENT":
                                    pInput = _this.prepareInput(_this.COLLADAInput(pXMLData));
                                    pSampler.inputs[sSemantic] = pInput;
                                    break;
                                default:
                                    akra.logger.setSourceLocation("resources/Collada.ts", 1714);
                                    akra.logger.error("semantics are different from OUTPUT/INTERPOLATION/IN_TANGENT/OUT_TANGENT is not supported in the <sampler /> tag");
                                    ;
                            }
                        });
                        return pSampler;
                    };
                    Collada.prototype.COLLADAAnimationChannel = function /** @no-inline */(pXML) {
                        var pChannel = {
                            sampler: this.source(attr(pXML, "source")),
                            target: this.target(attr(pXML, "target"))
                        };
                        if(akra.isNull(pChannel.target) || akra.isNull(pChannel.target.object)) {
                            akra.logger.setSourceLocation("resources/Collada.ts", 1729);
                            akra.logger.warning("cound not setup animation channel for <" + attr(pXML, "target") + ">");
                            ;
                            return null;
                        }
                        return pChannel;
                    };
                    Collada.prototype.COLLADAAnimation = function /** @no-inline */(pXML) {
                        var _this = this;
                        var pAnimation = {
                            id: attr(pXML, "id"),
                            name: attr(pXML, "name"),
                            sources: [],
                            samplers: [],
                            channels: [],
                            animations: []
                        };
                        var pChannel;
                        var pSubAnimation;
                        this.link(pAnimation);
                        this.eachChild(pXML, function /** @no-inline */(pXMLData, sName) {
                            switch(sName) {
                                case "source":
                                    pAnimation.sources.push(_this.COLLADASource(pXMLData));
                                    break;
                                case "sampler":
                                    pAnimation.samplers.push(_this.COLLADAAnimationSampler(pXMLData));
                                    break;
                                case "channel":
                                    pChannel = _this.COLLADAAnimationChannel(pXMLData);
                                    if(akra.isDefAndNotNull(pChannel)) {
                                        //this guard for skipping channels with unknown targets
                                        pAnimation.channels.push(pChannel);
                                    }
                                    break;
                                case "animation":
                                    pSubAnimation = _this.COLLADAAnimation(pXMLData);
                                    if(akra.isDefAndNotNull(pSubAnimation)) {
                                        pAnimation.animations.push(pSubAnimation);
                                    }
                            }
                        });
                        if(pAnimation.channels.length == 0 && pAnimation.animations.length == 0) {
                            akra.logger.setSourceLocation("resources/Collada.ts", 1781);
                            akra.logger.warning("animation with id \"" + pAnimation.id + "\" skipped, because channels/sub animation are empty");
                            ;
                            return null;
                        }
                        return pAnimation;
                    };
                    Collada.prototype.source = // collada mapping
                    function /** @no-inline */(sUrl) {
                        if(sUrl.charAt(0) !== "#") {
                            sUrl = "#" + sUrl;
                        }
                        var pElement = this._pLinks[sUrl];
                        if(!akra.isDefAndNotNull(pElement)) {
                            akra.logger.setSourceLocation("resources/Collada.ts", 1798);
                            akra.logger.warning("cannot find element with id: " + sUrl);
                            ;
                        }
                        return pElement || null;
                    };
                    Collada.prototype.link = function /** @no-inline */(el, pTarget) {
                        var sId;
                        if(!akra.isString(arguments[0])) {
                            pTarget = arguments[0];
                            sId = pTarget.id;
                        } else {
                            sId = arguments[0];
                        }
                        this._pLinks["#" + sId] = pTarget;
                    };
                    Collada.prototype.target = //astroBoy_newSkeleton_root/rotateY.ANGLE
                    //pObject.source: IColladaEntry = astroBoy_newSkeleton_root
                    //pSource: IColladaTransform = source(astroBoy_newSkeleton_root/rotateY)
                    //pSource: IColladaTransform = {
                    //    sid: string;  //rotateY
                    //    value: IVec4; //<0 1 0 -4.56752>
                    //    name: string; //rotate
                    //  }
                    //
                    //sValue: string = "ANGLE"
                    //pObject.object: IColladaTransform = pSource;
                    //
                    function /** @no-inline */(sPath) {
                        var pObject = {
                            value: null
                        };
                        var pSource;
                        var pMatches;
                        var sValue;
                        var iPos;
                        var jPos = 0;
                        iPos = sPath.lastIndexOf("/");
                        if(iPos >= 0) {
                            pObject.source = this.source(sPath.substr(0, iPos));
                        }
                        iPos = sPath.lastIndexOf(".");
                        if(iPos < 0) {
                            iPos = sPath.indexOf("(");
                            jPos = -1;
                        }
                        if(iPos < 0) {
                            pObject.object = this.source(sPath);
                            return pObject;
                        }
                        pSource = this.source(sPath.substr(0, iPos));
                        sValue = sPath.substr(iPos + jPos + 1);
                        pObject.object = pSource;
                        if(!pSource) {
                            return null;
                        }
                        switch(sValue) {
                            case "X":
                                pObject.value = (pSource.value).x;
                                break;
                            case "Y":
                                pObject.value = (pSource.value).y;
                                break;
                            case "Z":
                                pObject.value = (pSource.value).z;
                                break;
                            case "W":
                                pObject.value = (pSource.value).w;
                                break;
                            case "ANGLE":
                                //<rotate sid="rotateY">0 1 0 -4.56752</rotate>                    pObject.value = (<IVec4>pSource.value).w;
                                break;
                        }
                        if(akra.isDefAndNotNull(pObject.value)) {
                            return pObject;
                        }
                        pMatches = sValue.match(/^\((\d+)\)$/);
                        if(pMatches) {
                            pObject.value = Number(pMatches[1]);
                        }
                        pMatches = sValue.match(/^\((\d+)\)\((\d+)\)$/);
                        if(pMatches) {
                            //trace(pMatches, '--->',  Number(pMatches[2]) * 4 + Number(pMatches[1]));
                            //pObject.value = Number(pMatches[2]) * 4 + Number(pMatches[1]);
                            pObject.value = Number(pMatches[1]) * 4 + Number(pMatches[2]);
                        }
                        akra.logger.setSourceLocation("resources/Collada.ts", 1903);
                        akra.logger.assert(akra.isDefAndNotNull(pObject.value), "unsupported target value founded: " + sValue);
                        ;
                        return pObject;
                    };
                    Collada.prototype.buildAnimationTrack = // //animation
                    function /** @no-inline */(pChannel) {
                        var sNodeId = pChannel.target.source.id;
                        var sJoint = this.source(sNodeId).sid || null;
                        var pTrack = null;
                        var pSampler = pChannel.sampler;
                        akra.logger.setSourceLocation("resources/Collada.ts", 1916);
                        akra.logger.assert(akra.isDefAndNotNull(pSampler), "could not find sampler for animation channel");
                        ;
                        var pInput = pSampler.inputs["INPUT"];
                        var pOutput = pSampler.inputs["OUTPUT"];
                        var pInterpolation = pSampler.inputs["INTERPOLATION"];
                        var pTimeMarks = pInput.array;
                        var pOutputValues = pOutput.array;
                        var pFloatArray;
                        var pTransform = pChannel.target.object;
                        var sTransform = pTransform.name;
                        var v4f;
                        var pValue;
                        var nMatrices;
                        // if (sJoint == null) {
                        //     warning('node\'s <' + pChannel.pTarget.pSource.id + '> "sid" attribute is null');
                        // }
                        switch(sTransform) {
                            case "translate":
                                // pTrack = new a.AnimationTranslation(sJoint);
                                // for (var i = 0, v3f = new Array(3), n; i < pTimeMarks.length; ++ i) {
                                //     n = i * 3;
                                //     v3f.X = pOutputValues[i * 3];
                                //     v3f.Y = pOutputValues[i * 3 + 1];
                                //     v3f.Z = pOutputValues[i * 3 + 2];
                                //     pTrack.keyFrame(pTimeMarks[i], [v3f.X, v3f.Y, v3f.Z]);
                                // };
                                akra.logger.setSourceLocation("resources/Collada.ts", 1947);
                                akra.logger.criticalError("TODO: implement animation translation");
                                ;
                                //TODO: implement animation translation
                                break;
                            case "rotate":
                                // v4f = pTransform.pValue;
                                // pTrack = new a.AnimationRotation(sJoint, [v4f[1], v4f[2], v4f[3]]);
                                // debug_assert(pOutput.pAccessor.iStride === 1,
                                //     "matrix modification supported only for one parameter modification");
                                // for (var i = 0; i < pTimeMarks.length; ++ i) {
                                //     pTrack.keyFrame(pTimeMarks[i], pOutputValues[i] / 180.0 * Math.PI);
                                // };
                                akra.logger.setSourceLocation("resources/Collada.ts", 1960);
                                akra.logger.criticalError("TODO: implement animation rotation");
                                ;
                                //TODO: implement animation rotation
                                break;
                            case "matrix":
                                pValue = pChannel.target.value;
                                if(akra.isNull(pValue)) {
                                    pTrack = akra.animation.createTrack(sJoint);
                                    nMatrices = pOutputValues.length / 16;
                                    pFloatArray = new Float32Array(pOutputValues);
                                    akra.logger.setSourceLocation("resources/Collada.ts", 1971);
                                    akra.logger.assert(nMatrices % 1 === 0.0, "incorrect output length of transformation data (" + pFloatArray.length + ")");
                                    ;
                                    for(var i = 0; i < nMatrices; i++) {
                                        pTrack.keyFrame(pTimeMarks[i], (new akra.Mat4(pFloatArray.subarray(i * 16, i * 16 + 16), true)).transpose());
                                    }
                                    // i=0;
                                    // var m = (new Mat4(pFloatArray.subarray(i * 16, i * 16 + 16), true));
                                    // trace(sFilename,sNodeId,m.toString());
                                                                    } else {
                                    // pTrack = new a.AnimationMatrixModification(sJoint, pValue);
                                    // for (var i = 0; i < pTimeMarks.length; ++i) {
                                    //     pTrack.keyFrame(pTimeMarks[i], pOutputValues[i]);
                                    // }
                                    akra.logger.setSourceLocation("resources/Collada.ts", 1989);
                                    akra.logger.criticalError("TODO: implement animation matrix modification");
                                    ;
                                }
                                break;
                            default:
                                akra.logger.setSourceLocation("resources/Collada.ts", 1993);
                                akra.logger.error("unsupported animation typed founeed: " + sTransform);
                                ;
                        }
                        if(!akra.isNull(pTrack)) {
                            pTrack.targetName = sNodeId;
                        }
                        return pTrack;
                    };
                    Collada.prototype.buildAnimationTrackList = function /** @no-inline */(pAnimationData) {
                        var pSubAnimations = pAnimationData.animations;
                        var pSubTracks;
                        var pTrackList = [];
                        var pTrack;
                        var pChannels = pAnimationData.channels;
                        for(var i = 0; i < pChannels.length; ++i) {
                            pTrack = this.buildAnimationTrack(pChannels[i]);
                            pTrackList.push(pTrack);
                        }
                        if(akra.isDefAndNotNull(pSubAnimations)) {
                            for(var i = 0; i < pSubAnimations.length; ++i) {
                                pSubTracks = this.buildAnimationTrackList(pSubAnimations[i]);
                                pTrackList = pTrackList.concat(pSubTracks);
                            }
                        }
                        return pTrackList;
                    };
                    Collada.prototype.buildAnimation = function /** @no-inline */(pAnimationData) {
                        var pTracks = this.buildAnimationTrackList(pAnimationData);
                        /*pAnimationData.length ? pAnimationData[0].name :*/
                        var sAnimation = null;
                        var pAnimation = akra.animation.createAnimation(sAnimation || this.getBasename());
                        for(var i = 0; i < pTracks.length; i++) {
                            pAnimation.push(pTracks[i]);
                        }
                        return pAnimation;
                    };
                    Collada.prototype.buildAnimations = function /** @no-inline */(pAnimations, pAnimationsList) {
                        if (typeof pAnimationsList === "undefined") { pAnimationsList = []; }
                        if(akra.isNull(pAnimations)) {
                            return null;
                        }
                        for(var i = 0; i < pAnimations.length; ++i) {
                            var pAnimation = this.buildAnimation(pAnimations[i]);
                            pAnimationsList.push(pAnimation);
                        }
                        return pAnimationsList;
                    };
                    Collada.prototype.buildAssetTransform = // common
                    function /** @no-inline */(pNode, pAsset) {
                        if (typeof pAsset === "undefined") { pAsset = null; }
                        pAsset = pAsset || this.getAsset();
                        if(akra.isDefAndNotNull(pAsset)) {
                            var fUnit = pAsset.unit.meter;
                            var sUPaxis = pAsset.upAxis;
                            pNode.localScale = akra.vec3(fUnit);
                            if(sUPaxis.toUpperCase() == "Z_UP") {
                                //pNode.addRelRotation([1, 0, 0], -.5 * Math.PI);
                                pNode.addRelRotationByEulerAngles(0, -.5 * akra.math.PI, 0);
                            }
                        }
                        return pNode;
                    };
                    Collada.prototype.buildMaterials = // materials & meshes
                    function /** @no-inline */(pMesh, pGeometryInstance) {
                        var pMaterials = pGeometryInstance.material;
                        var pEffects = this.getLibrary("library_effects");
                        if(akra.isNull(pEffects)) {
                            return pMesh;
                        }
                        for(var sMaterial in pMaterials) {
                            var pMaterialInst = pMaterials[sMaterial];
                            var pInputMap = pMaterialInst.vertexInput;
                            // URL --> ID (#somebody ==> somebody)
                            var sEffectId = pMaterialInst.url.substr(1);
                            var pEffect = pEffects.effects[sEffectId];
                            var pPhongMaterial = pEffect.profileCommon.technique.value;
                            var pMaterial = akra.material.create(sEffectId);
                            pMaterial.set(pPhongMaterial);
                            for(var j = 0; j < pMesh.length; ++j) {
                                var pSubMesh = pMesh[j];
                                //if (pSubMesh.surfaceMaterial.findResourceName() === sMaterial) {
                                if(pSubMesh.material.name === sMaterial) {
                                    //setup materials
                                    pSubMesh.material.set(pMaterial);
                                    //FIXME: remove flex material setup(needs only demo with flexmats..)
                                    // pSubMesh.applyFlexMaterial(sMaterial, pMaterial);
                                    if(!pSubMesh.renderMethod.effect.isResourceLoaded()) {
                                        pSubMesh.renderMethod.effect.create();
                                    }
                                    pSubMesh.renderMethod.effect.addComponent("akra.system.mesh_texture");
                                    pSubMesh.renderMethod.effect.addComponent("akra.system.prepareForDeferredShading");
                                    //setup textures
                                    for(var sTextureType in pPhongMaterial.textures) {
                                        var pColladaTexture = pPhongMaterial.textures[sTextureType];
                                        var pInput = pInputMap[pColladaTexture.texcoord];
                                        if(!akra.isDefAndNotNull(pInput)) {
                                            continue;
                                        }
                                        var sInputSemantics = pInputMap[pColladaTexture.texcoord].inputSemantic;
                                        var pColladaImage = pColladaTexture.image;
                                        var pSurfaceMaterial = pSubMesh.surfaceMaterial;
                                        var pTexture = this.getManager().texturePool.loadResource(pColladaImage.path);
                                        var pMatches = sInputSemantics.match(/^(.*?\w)(\d+)$/i);
                                        var iTexCoord = (pMatches ? parseInt(pMatches[2]) : 0);
                                        var iTexture = akra.ESurfaceMaterialTextures[sTextureType.toUpperCase()];
                                        if(!akra.isDef(iTexture)) {
                                            continue;
                                        }
                                        pSurfaceMaterial.setTexture(iTexture, pTexture, iTexCoord);
                                    }
                                }
                            }
                            //trace('try to apply mat:', pMaterial);
                                                    }
                        return pMesh;
                    };
                    Collada.prototype.buildSkeleton = function /** @no-inline */(pSkeletonsList) {
                        var pSkeleton = null;
                        pSkeleton = akra.model.createSkeleton(pSkeletonsList[0]);
                        for(var i = 0; i < pSkeletonsList.length; ++i) {
                            var pJoint = (this.source(pSkeletonsList[i])).constructedNode;
                            akra.logger.setSourceLocation("resources/Collada.ts", 2155);
                            akra.logger.error(akra.scene.isJoint(pJoint), "skeleton node must be joint");
                            ;
                            pSkeleton.addRootJoint(pJoint);
                        }
                        return pSkeleton;
                    };
                    Collada.prototype.buildMesh = function /** @no-inline */(pGeometryInstance) {
                        var pMesh = null;
                        var pGeometry = pGeometryInstance.geometry;
                        var pNodeData = pGeometry.mesh;
                        var sMeshName = pGeometry.id;
                        if(akra.isNull(pNodeData)) {
                            return null;
                        }
                        if((pMesh = this.findMesh(sMeshName))) {
                            //mesh with same geometry data
                            return this.buildMaterials(pMesh.clone(0 /* GEOMETRY_ONLY */  | 1 /* SHARED_GEOMETRY */ ), pGeometryInstance);
                        }
                        var iBegin = akra.now();
                        pMesh = this.getEngine().createMesh(sMeshName, /*|EMeshOptions.RD_ADVANCED_INDEX,  //0,//*/
                        (akra.EMeshOptions.HB_READABLE), /*shared buffer, if supported*/
                        this.sharedBuffer());
                        var pPolyGroup = pNodeData.polygons;
                        var pMeshData = pMesh.data;
                        //creating subsets
                        for(var i = 0; i < pPolyGroup.length; ++i) {
                            pMesh.createSubset("submesh-" + i, /*EPrimitiveTypes.POINTLIST);*/
                            this.isWireframeEnabled() ? 1 /* LINELIST */  : pPolyGroup[i].type);
                        }
                        //filling data
                        for(var i = 0, pUsedSemantics = {
                        }; i < pPolyGroup.length; ++i) {
                            var pPolygons = pPolyGroup[i];
                            for(var j = 0; j < pPolygons.inputs.length; ++j) {
                                var pInput = pPolygons.inputs[j];
                                var sSemantic = pInput.semantics;
                                var pData = pInput.array;
                                var pDecl;
                                var pDataExt;
                                //if (pMesh.buffer.getDataLocation(sSemantic) < 0) {
                                if(!pUsedSemantics[sSemantic]) {
                                    pUsedSemantics[sSemantic] = true;
                                    switch(sSemantic) {
                                        case akra.DeclUsages.POSITION:
                                        case akra.DeclUsages.NORMAL:
                                            /*
                                            Extend POSITION and NORMAL from {x,y,z} --> {x,y,z,w};
                                            */
                                            pDataExt = new Float32Array((pData).length / 3 * 4);
                                            for(var y = 0, n = 0, m = 0, l = (pData).length / 3; y < l; y++ , n++) {
                                                pDataExt[n++] = pData[m++];
                                                pDataExt[n++] = pData[m++];
                                                pDataExt[n++] = pData[m++];
                                            }
                                            pData = pDataExt;
                                            pDecl = [
                                                akra.VE_FLOAT3(sSemantic), 
                                                akra.VE_END(16)
                                            ];
                                            break;
                                        case akra.DeclUsages.TEXCOORD:
                                        case akra.DeclUsages.TEXCOORD1:
                                        case akra.DeclUsages.TEXCOORD2:
                                        case akra.DeclUsages.TEXCOORD3:
                                        case akra.DeclUsages.TEXCOORD4:
                                        case akra.DeclUsages.TEXCOORD5:
                                            //avoiding semantics collisions
                                            if(sSemantic === "TEXCOORD") {
                                                sSemantic = "TEXCOORD0";
                                            }
                                            pDecl = [
                                                akra.VE_CUSTOM(sSemantic, 5126 /* FLOAT */ , pInput.accessor.stride)
                                            ];
                                            break;
                                        default:
                                            akra.logger.setSourceLocation("resources/Collada.ts", 2245);
                                            akra.logger.error("unsupported semantics used: " + sSemantic);
                                            ;
                                    }
                                    pMeshData.allocateData(pDecl, pData);
                                }
                            }
                        }
                        //add indices to data
                        for(var i = 0; i < pPolyGroup.length; ++i) {
                            var pPolygons = pPolyGroup[i];
                            var pSubMesh = pMesh.getSubset(i);
                            var pSubMeshData = pSubMesh.data;
                            var pDecl = new Array(pPolygons.inputs.length);
                            var iIndex = 0;
                            var pSurfaceMaterial = null;
                            var pSurfacePool = null;
                            for(var j = 0; j < pPolygons.inputs.length; ++j) {
                                pDecl[j] = akra.VE_FLOAT(akra.DeclUsages.INDEX + (iIndex++));
                            }
                            pSubMeshData.allocateIndex(pDecl, new Float32Array(pPolygons.p));
                            for(var j = 0; j < pDecl.length; ++j) {
                                var sSemantic = pPolygons.inputs[j].semantics;
                                pSubMeshData.index(sSemantic, pDecl[j].usage);
                            }
                            // if (!pSubMesh.material) {
                            //     pSurfacePool = pEngine.getResourceManager().surfaceMaterialPool;
                            //     pSurfaceMaterial = pSurfacePool.findResource(pPolygons.material);
                            //     if (!pSurfaceMaterial) {
                            //         pSurfaceMaterial = pSurfacePool.createResource(pPolygons.material);
                            //     }
                            //     pSubMesh.surfaceMaterial = pSurfaceMaterial;
                            // }
                            pSubMesh.material.name = pPolygons.material;
                        }
                        pMesh.addFlexMaterial("default");
                        pMesh.setFlexMaterial("default");
                        //adding all data to cahce data
                        this.addMesh(pMesh);
                        return this.buildMaterials(pMesh, pGeometryInstance);
                    };
                    Collada.prototype.buildSkinMesh = function /** @no-inline */(pControllerInstance) {
                        var pController = pControllerInstance.controller;
                        var pMaterials = pControllerInstance.material;
                        var pSkinData = pController.skin;
                        //skin data
                        var pBoneList = pSkinData.joints.inputs["JOINT"].array;
                        var pBoneOffsetMatrices = pSkinData.joints.inputs["INV_BIND_MATRIX"].array;
                        var m4fBindMatrix = pSkinData.shapeMatrix;
                        var pVertexWeights = pSkinData.vertexWeights;
                        var pGeometry = pSkinData.geometry;
                        var pMesh;
                        var pSkeleton;
                        var pSkin;
                        pSkeleton = this.buildSkeleton(pControllerInstance.skeletons);
                        pMesh = this.buildMesh({
                            geometry: pGeometry,
                            material: pMaterials
                        });
                        pSkin = pMesh.createSkin();
                        pSkin.setBindMatrix(m4fBindMatrix);
                        pSkin.setBoneNames(pBoneList);
                        pSkin.setBoneOffsetMatrices(pBoneOffsetMatrices);
                        pSkin.setSkeleton(pSkeleton);
                        if(!pSkin.setVertexWeights(pVertexWeights.vcount, new Float32Array(pVertexWeights.v), new Float32Array(pVertexWeights.weightInput.array))) {
                            akra.logger.setSourceLocation("resources/Collada.ts", 2330);
                            akra.logger.error("cannot set vertex weight info to skin");
                            ;
                        }
                        pMesh.setSkeleton(pSkeleton);
                        pSkeleton.attachMesh(pMesh);
                        return pMesh;
                    };
                    Collada.prototype.buildSkinMeshInstance = function /** @no-inline */(pControllers, pSceneNode) {
                        if (typeof pSceneNode === "undefined") { pSceneNode = null; }
                        var pMesh = null;
                        var pMeshList = [];
                        for(var m = 0; m < pControllers.length; ++m) {
                            pMesh = this.buildSkinMesh(pControllers[m]);
                            pMeshList.push(pMesh);
                            akra.logger.setSourceLocation("resources/Collada.ts", 2348);
                            akra.logger.assert(akra.isDefAndNotNull(pMesh), "cannot find instance <" + pControllers[m].url + ">\"s data");
                            ;
                            if(!akra.isNull(pSceneNode)) {
                                pSceneNode.mesh = pMesh;
                            }
                        }
                        return pMeshList;
                    };
                    Collada.prototype.buildMeshInstance = function /** @no-inline */(pGeometries, pSceneNode) {
                        if (typeof pSceneNode === "undefined") { pSceneNode = null; }
                        var pMesh = null;
                        var pMeshList = [];
                        for(var m = 0; m < pGeometries.length; ++m) {
                            pMesh = this.buildMesh(pGeometries[m]);
                            pMeshList.push(pMesh);
                            akra.logger.setSourceLocation("resources/Collada.ts", 2366);
                            akra.logger.assert(akra.isDefAndNotNull(pMesh), "cannot find instance <" + pGeometries[m].url + ">\"s data");
                            ;
                            if(!akra.isNull(pSceneNode)) {
                                pSceneNode.mesh = pMesh;
                            }
                        }
                        return pMeshList;
                    };
                    Collada.prototype.buildMeshes = function /** @no-inline */() {
                        var pScene = this.getVisualScene();
                        var pMeshes = [];
                        this.findNode(pScene.nodes, null, function /** @no-inline */(pNode) {
                            var pModelNode = pNode.constructedNode;
                            if(akra.isNull(pModelNode)) {
                                akra.logger.setSourceLocation("resources/Collada.ts", 2384);
                                akra.logger.error("you must call buildScene() before call buildMeshes() or file corrupt");
                                ;
                                return;
                            }
                            if(pNode.controller.length == 0 && pNode.geometry.length == 0) {
                                return;
                            }
                            if(akra.scene.isModel(pModelNode)) {
                                pModelNode = pModelNode.scene.createModel(".joint-to-model-link-" + akra.sid());
                                pModelNode.attachToParent(pNode.constructedNode);
                            }
                            pMeshes.insert(this.buildSkinMeshInstance(pNode.controller));
                            pMeshes.insert(this.buildMeshInstance(pNode.geometry, pModelNode));
                        });
                        return pMeshes;
                    };
                    Collada.prototype.buildSceneNode = // scene
                    function /** @no-inline */(pNode, pParentNode) {
                        var pSceneNode = pNode.constructedNode;
                        var pScene = pParentNode.scene;
                        if(akra.isDefAndNotNull(pSceneNode)) {
                            return pSceneNode;
                        }
                        //FIXME: предпологаем, что мы никогда не аттачим контроллеры к узлам,
                        // где они найдены, а аттачим  их к руту скелета, на который они ссылаются
                        /*pNode.pController.length ||*/
                        if(pNode.geometry.length > 0) {
                            pSceneNode = pScene.createModel();
                        } else {
                            pSceneNode = pScene.createNode();
                        }
                        pSceneNode.attachToParent(pParentNode);
                        return pSceneNode;
                    };
                    Collada.prototype.buildJointNode = function /** @no-inline */(pNode, pParentNode) {
                        var pJointNode = pNode.constructedNode;
                        var sJointSid = pNode.sid;
                        var sJointName = pNode.id;
                        var pSkeleton;
                        akra.logger.setSourceLocation("resources/Collada.ts", 2435);
                        akra.logger.assert(akra.isDefAndNotNull(pParentNode), "parent node is null");
                        ;
                        if(akra.isDefAndNotNull(pJointNode)) {
                            return pJointNode;
                        }
                        if(akra.isNull(pParentNode)) {
                            return null;
                        }
                        pJointNode = pParentNode.scene.createJoint();
                        pJointNode.boneName = sJointSid;
                        pJointNode.attachToParent(pParentNode);
                        if(this.isJointsVisualizationNeeded()) {
                            //draw joints
                            // var pSceneNode: ISceneModel = pEngine.appendMesh(
                            //     pEngine.pCubeMesh.clone(a.Mesh.GEOMETRY_ONLY | a.Mesh.SHARED_GEOMETRY),
                            //     pJointNode);
                            // pSceneNode.name = sJointName + '[joint]';
                            // pSceneNode.setScale(0.02);
                            akra.logger.setSourceLocation("resources/Collada.ts", 2457);
                            akra.logger.criticalError("TODO: visualize joints...");
                            ;
                        }
                        return pJointNode;
                    };
                    Collada.prototype.buildNodes = function /** @no-inline */(pNodes, pParentNode) {
                        if (typeof pParentNode === "undefined") { pParentNode = null; }
                        if(akra.isNull(pNodes)) {
                            return null;
                        }
                        var pNode = null;
                        var pHierarchyNode = null;
                        var m4fLocalMatrix = null;
                        for(var i = pNodes.length - 1; i >= 0; i--) {
                            pNode = pNodes[i];
                            if(!akra.isDefAndNotNull(pNode)) {
                                continue;
                            }
                            if(pNode.type === "JOINT") {
                                pHierarchyNode = this.buildJointNode(pNode, pParentNode);
                            } else {
                                pHierarchyNode = this.buildSceneNode(pNode, pParentNode);
                            }
                            pHierarchyNode.name = (pNode.id || pNode.name);
                            pHierarchyNode.setInheritance(2 /* ALL */ );
                            //cache already constructed nodes
                            pNode.constructedNode = pHierarchyNode;
                            pHierarchyNode.localMatrix = pNode.transform;
                            this.buildNodes(pNode.childNodes, pHierarchyNode);
                        }
                        return pHierarchyNode;
                    };
                    Collada.prototype.buildScene = function /** @no-inline */(pRootNode) {
                        var pScene = this.getVisualScene();
                        var pAsset = this.getAsset();
                        var pNodes = [];
                        var pNode = null;
                        for(var i = 0; i < pScene.nodes.length; i++) {
                            pNode = pScene.nodes[i];
                            pNodes.push(this.buildNodes([
                                pNode
                            ], pRootNode));
                        }
                        for(var i = 0; i < pNodes.length; i++) {
                            pNodes[i] = this.buildAssetTransform(pNodes[i]);
                        }
                        return pNodes;
                    };
                    Collada.prototype.buildInititalPose = function /** @no-inline */(pNodes, pSkeleton) {
                        var sPose = "Pose-" + this.getBasename() + "-" + pSkeleton.name;
                        var pPose = akra.animation.createAnimation(sPose);
                        var pNodeList = pSkeleton.getNodeList();
                        var pNodeMap = {
                        };
                        var pTrack;
                        for(var i = 0; i < pNodeList.length; ++i) {
                            pNodeMap[pNodeList[i].name] = pNodeList[i];
                        }
                        this.findNode(pNodes, null, function /** @no-inline */(pNode) {
                            var sJoint = pNode.sid;
                            var sNodeId = pNode.id;
                            if(!akra.isDefAndNotNull(pNodeMap[sNodeId])) {
                                return;
                            }
                            pTrack = akra.animation.createTrack(sJoint);
                            pTrack.targetName = sNodeId;
                            pTrack.keyFrame(0.0, pNode.transform);
                            pPose.push(pTrack);
                        });
                        return pPose;
                    };
                    Collada.prototype.buildInitialPoses = function /** @no-inline */(pPoseSkeletons) {
                        if (typeof pPoseSkeletons === "undefined") { pPoseSkeletons = null; }
                        pPoseSkeletons = pPoseSkeletons || this.getSkeletonsOutput();
                        if(akra.isNull(pPoseSkeletons)) {
                            return null;
                        }
                        var pScene = this.getVisualScene();
                        var pSkeleton;
                        var pPoses = [];
                        for(var i = 0; i < pPoseSkeletons.length; ++i) {
                            pSkeleton = pPoseSkeletons[i];
                            // if (pSkeleton.name === "node-Bip001_Pelvis" || pSkeleton.name === "node-Bip001") {
                            //     trace('skipping <node-Bip001_Pelvis> skeleto, ...', '[' + sBasename + ']');
                            //     trace(pSkeleton.getNodeList()[0].localMatrix().toQuat4().toYawPitchRoll(Vec3()).toString());
                            //     continue;
                            // }
                            pPoses.push(this.buildInititalPose(pScene.nodes, pSkeleton));
                        }
                        return pPoses;
                    };
                    Collada.prototype.buildComplete = // additional
                    function /** @no-inline */() {
                        var pScene = this.getVisualScene();
                        if(akra.isNull(pScene)) {
                            akra.logger.setSourceLocation("resources/Collada.ts", 2581);
                            akra.logger.warning("build complete, but visual scene not parsed correctly!");
                            ;
                            return;
                        }
                        //release all links to constructed nodes
                        this.findNode(pScene.nodes, null, function /** @no-inline */(pNode) {
                            pNode.constructedNode = null;
                        });
                    };
                    Collada.prototype.setOptions = function /** @no-inline */(pOptions) {
                        if(akra.isNull(pOptions)) {
                            pOptions = Collada.DEFAULT_OPTIONS;
                        }
                        for(var i in Collada.DEFAULT_OPTIONS) {
                            if(akra.isDef(pOptions[i])) {
                                continue;
                            }
                            pOptions[i] = Collada.DEFAULT_OPTIONS[i];
                        }
                        this._pOptions = pOptions;
                    };
                    Collada.prototype.setXMLRoot = function /** @no-inline */(pXML) {
                        this._pXMLRoot = pXML;
                    };
                    Collada.prototype.getXMLRoot = function /** @no-inline */() {
                        return this._pXMLRoot;
                    };
                    Collada.prototype.findMesh = function /** @no-inline */(sName) {
                        return this._pCache.meshMap[sName] || null;
                    };
                    Collada.prototype.addMesh = function /** @no-inline */(pMesh) {
                        this._pCache.meshMap[pMesh.name] = pMesh;
                        this.sharedBuffer(pMesh.data);
                    };
                    Collada.prototype.sharedBuffer = function /** @no-inline */(pBuffer) {
                        if(akra.isDefAndNotNull(pBuffer)) {
                            this._pCache.sharedBuffer = pBuffer;
                        }
                        return null;
                        // return this._pOptions.sharedBuffer ? pCache.sharedBuffer : null;
                                            };
                    Collada.prototype.prepareInput = function /** @no-inline */(pInput) {
                        var pSupportedFormat = getSupportedFormat(pInput.semantics);
                        akra.logger.setSourceLocation("resources/Collada.ts", 2636);
                        akra.logger.assert(akra.isDefAndNotNull(pSupportedFormat), "unsupported semantic used <" + pInput.semantics + ">");
                        ;
                        pInput.array = this.COLLADAGetSourceData(pInput.source, pSupportedFormat);
                        pInput.accessor = pInput.source.techniqueCommon.accessor;
                        return pInput;
                    };
                    Collada.prototype.isJointsVisualizationNeeded = function /** @inline */() {
                        return this._pOptions.drawJoints === true;
                    };
                    Collada.prototype.isVisualSceneLoaded = function /** @inline */() {
                        return akra.isDefAndNotNull(this._pVisualScene);
                    };
                    Collada.prototype.isSceneNeeded = function /** @inline */() {
                        return this._pOptions.scene === true;
                    };
                    Collada.prototype.isAnimationNeeded = function /** @inline */() {
                        return akra.isDefAndNotNull(this._pOptions.animation);
                    };
                    Collada.prototype.isPoseExtractionNeeded = function /** @inline */() {
                        return this._pOptions.extractPoses === true;
                    };
                    Collada.prototype.isWireframeEnabled = function /** @inline */() {
                        return this._pOptions.wireframe === true;
                    };
                    Collada.prototype.getSkeletonsOutput = function /** @inline */() {
                        return this._pOptions.skeletons || null;
                    };
                    Collada.prototype.getVisualScene = function /** @inline */() {
                        return this._pVisualScene;
                    };
                    Collada.prototype.getAsset = function /** @inline */() {
                        return this._pAsset;
                    };
                    Collada.prototype.isLibraryLoaded = function /** @inline */(sLib) {
                        return akra.isDefAndNotNull(this._pLib[sLib]);
                    };
                    Collada.prototype.isLibraryExists = function /** @inline */(sLib) {
                        return false;
                    };
                    Collada.prototype.getLibrary = function /** @inline */(sLib) {
                        return this._pLib[sLib] || null;
                    };
                    Collada.prototype.getBasename = function /** @inline */() {
                        return akra.util.pathinfo(this._sFilename).basename || "unknown";
                    };
                    Collada.prototype.getFilename = function /** @inline */() {
                        return this._sFilename;
                    };
                    Collada.prototype.setFilename = function /** @inline */(sName) {
                        this._sFilename = sName;
                    };
                    Collada.prototype.readLibraries = function /** @no-inline */(pXML, pTemplates) {
                        var pLibraries = this._pLib;
                        for(var i = 0; i < pTemplates.length; i++) {
                            var sLib = pTemplates[i].lib;
                            pLibraries[sLib] = this.COLLADALibrary(firstChild(pXML, sLib), pTemplates[i]);
                        }
                    };
                    Collada.prototype.checkLibraries = function /** @no-inline */(pXML, pTemplates) {
                        var pLibraries = this._pLib;
                        for(var i = 0; i < pTemplates.length; i++) {
                            var sLib = pTemplates[i].lib;
                            if(akra.isDefAndNotNull(firstChild(pXML, sLib))) {
                                pLibraries[sLib] = null;
                            }
                        }
                    };
                    Collada.prototype.parse = function /** @no-inline */(sXMLData, pOptions) {
                        if (typeof pOptions === "undefined") { pOptions = null; }
                        if(akra.isNull(sXMLData)) {
                            akra.logger.setSourceLocation("resources/Collada.ts", 2728);
                            akra.logger.error("must be specified collada content.");
                            ;
                            return false;
                        }
                        var pParser = new DOMParser();
                        var pXMLDocument = pParser.parseFromString(sXMLData, "application/xml");
                        var pXMLRoot = pXMLDocument.getElementsByTagName("COLLADA")[0];
                        this.setOptions(pOptions);
                        this.setXMLRoot(pXMLRoot);
                        this.checkLibraries(pXMLRoot, Collada.SCENE_TEMPLATE);
                        this.checkLibraries(pXMLRoot, Collada.ANIMATION_TEMPLATE);
                        this.readLibraries(pXMLRoot, Collada.SCENE_TEMPLATE);
                        this.COLLADAAsset(firstChild(pXMLRoot, "asset"));
                        this.COLLADAScene(firstChild(pXMLRoot, "scene"));
                        if(this.isAnimationNeeded()) {
                            this.readLibraries(pXMLRoot, Collada.ANIMATION_TEMPLATE);
                        }
                        return true;
                    };
                    Collada.prototype.loadResource = function /** @no-inline */(sFilename, pOptions) {
                        if (typeof sFilename === "undefined") { sFilename = null; }
                        if (typeof pOptions === "undefined") { pOptions = null; }
                        if(akra.isNull(sFilename)) {
                            sFilename = this.findResourceName();
                        }
                        if(this.isResourceLoaded()) {
                            akra.logger.setSourceLocation("resources/Collada.ts", 2760);
                            akra.logger.warning("collada model already loaded");
                            ;
                            return false;
                        }
                        var pModel = this;
                        this.setFilename(sFilename);
                        this.notifyDisabled();
                        this.notifyUnloaded();
                        akra.io.fopen(sFilename).read(function /** @no-inline */(pErr, sXML) {
                            if(!akra.isNull(pErr)) {
                                akra.logger.setSourceLocation("resources/Collada.ts", 2773);
                                akra.logger.error(pErr);
                                ;
                            }
                            pModel.notifyRestored();
                            if(pModel.parse(sXML, pOptions)) {
                                pModel.notifyLoaded();
                            }
                        });
                    };
                    Collada.prototype.attachToScene = function /** @no-inline */(pNode) {
                        var pSkeletons, pSkeleton;
                        var pPoses;
                        var pRoot;
                        var pSceneOutput = null;
                        var pAnimationOutput = null;
                        var pMeshOutput = null;
                        var pInitialPosesOutput = null;
                        var pController = null;
                        if(akra.isNull(pNode)) {
                            return false;
                        }
                        if(this.isVisualSceneLoaded() && this.isSceneNeeded()) {
                            pSceneOutput = this.buildScene(pNode);
                            pMeshOutput = this.buildMeshes();
                        }
                        if(this.isPoseExtractionNeeded()) {
                            pInitialPosesOutput = this.buildInitialPoses();
                        }
                        if(this.isAnimationNeeded() && this.isLibraryExists("library_animations")) {
                            pAnimationOutput = this.buildAnimations((this.getLibrary("library_animations")).animations);
                            //дополним анимации начальными позициями костей
                            if(this.isPoseExtractionNeeded()) {
                                pSkeletons = this.getSkeletonsOutput() || [];
                                /*
                                
                                // добавим к начальным позам, те, в которых находятся меши
                                // в момент выгрузки
                                if (!isNull(pMeshOutput)) {
                                for (var i = 0; i < pMeshOutput.length; ++ i) {
                                pSkeletons.push(pMeshOutput[i].skeleton);
                                }
                                }
                                else {
                                //необхоимо для посчета ссылочной информации
                                if (isNull(pSceneOutput)) {
                                this.buildScene();
                                }
                                
                                this.eachByTag(pXMLRoot, "skeleton", function (pXML: Node) {
                                pSkeletons.push(this.buildSkeleton([stringData(pXML)]));
                                });
                                }
                                
                                */
                                pPoses = this.buildInitialPoses(pSkeletons);
                                for(var i = 0; i < pAnimationOutput.length; ++i) {
                                    for(var j = 0; j < pPoses.length; ++j) {
                                        pAnimationOutput[i].extend(pPoses[j]);
                                    }
                                }
                            }
                        }
                        this.buildComplete();
                        pRoot = pNode.scene.createNode();
                        pRoot.setInheritance(2 /* ALL */ );
                        if(!pRoot.attachToParent(pNode)) {
                            return false;
                        }
                        if(!akra.isNull(pController)) {
                            //TODO: bind controller
                                                    }
                        return true;
                    };
                    return Collada;
                })(pool.ResourcePoolItem);
                resources.Collada = Collada;                
                pSupportedVertexFormat = [
                    {
                        name: [
                            "X"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "Y"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "Z"
                        ],
                        type: [
                            "float"
                        ]
                    }
                ];
                pSupportedTextureFormat = [
                    {
                        name: [
                            "S"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "T"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "P"
                        ],
                        type: [
                            "float"
                        ]
                    }
                ];
                pSupportedWeightFormat = [
                    {
                        name: [
                            "WEIGHT"
                        ],
                        type: [
                            "float"
                        ]
                    }
                ];
                pSupportedJointFormat = [
                    {
                        name: [
                            "JOINT"
                        ],
                        type: [
                            "Name", 
                            "IDREF"
                        ]
                    }
                ];
                pSupportedInvBindMatrixFormat = [
                    {
                        name: [
                            "TRANSFORM"
                        ],
                        type: [
                            "float4x4"
                        ]
                    }
                ];
                pSupportedInterpolationFormat = [
                    {
                        name: [
                            "INTERPOLATION"
                        ],
                        type: [
                            "Name"
                        ]
                    }
                ];
                pSupportedInputFormat = [
                    {
                        name: [
                            "TIME"
                        ],
                        type: [
                            "float"
                        ]
                    }
                ];
                pSupportedOutputFormat = [
                    {
                        name: [
                            "TRANSFORM", 
                            "X", 
                            "ANGLE", 
                            null
                        ],
                        type: [
                            "float4x4", 
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "Y"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "Z"
                        ],
                        type: [
                            "float"
                        ]
                    }
                ];
                pSupportedTangentFormat = [
                    {
                        name: [
                            "X"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "Y"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "X"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "Y"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "X"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "Y"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "X"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "Y"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "X"
                        ],
                        type: [
                            "float"
                        ]
                    }, 
                    {
                        name: [
                            "Y"
                        ],
                        type: [
                            "float"
                        ]
                    }
                ];
                pFormatStrideTable = {
                    "float": 1,
                    "float2": 2,
                    "float3": 3,
                    "float4": 4,
                    "float3x3": 9,
                    "float4x4": 16,
                    "int": 1,
                    "name": 1,
                    "Name": 1,
                    "IDREF": 1
                };
                pConvFormats = {
                    "int": {
                        type: Int32Array,
                        converter: string2IntArray
                    },
                    "float": {
                        type: Float32Array,
                        converter: string2FloatArray
                    },
                    "bool": {
                        type: Array,
                        converter: string2BoolArray
                    },
                    "string": {
                        type: Array,
                        converter: string2StringArray
                    }
                };
                /* COMMON FUNCTIONS
                ------------------------------------------------------
                */
                function /** @no-inline */getSupportedFormat(sSemantics) {
                    switch(sSemantics) {
                        case "TEXTANGENT":
                        case "TEXBINORMAL":
                        case "VERTEX":
                        case "NORMAL":
                        case "TANGENT":
                        case "BINORMAL":
                        case "POSITION":
                            return pSupportedVertexFormat;
                        case "TEXCOORD":
                            return pSupportedTextureFormat;
                        case "WEIGHT":
                            return pSupportedWeightFormat;
                        case "JOINT":
                            return pSupportedJointFormat;
                        case "INV_BIND_MATRIX":
                            return pSupportedInvBindMatrixFormat;
                        case "INTERPOLATION":
                            return pSupportedInterpolationFormat;
                        case "IN_TANGENT":
                            return pSupportedTangentFormat;
                        case "INPUT":
                            return pSupportedInputFormat;
                        case "OUT_TANGENT":
                            return pSupportedTangentFormat;
                        case "OUTPUT":
                            return pSupportedOutputFormat;
                        case "UV":
                        case "MORPH_WEIGHT":
                        case "MORPH_TARGET":
                        case "LINEAR_STEPS":
                        case "IMAGE":
                        case "CONTINUITY":
                        case "COLOR":
                            return null;
                    }
                    akra.logger.setSourceLocation("resources/Collada.ts", 2991);
                    akra.logger.error("unknown semantics founded: " + sSemantics);
                    ;
                    return null;
                }
                function /** @no-inline */calcFormatStride(pFormat) {
                    var iStride = 0;
                    var s = null;
                    for(var i = 0; i < pFormat.length; ++i) {
                        s = pFormat[i].type[0];
                        iStride += pFormatStrideTable[s];
                    }
                    return iStride;
                }
                // data convertion
                function /** @inline */parseBool(sValue) {
                    return (sValue === "true");
                }
                function /** @inline */parseString(sValue) {
                    return String(sValue);
                }
                /**
                * Получить часть данных массива
                * @param pSrc
                * @param pDst
                * @param iStride шаг (количество элементов в шаге)
                * @param iFrom номер элемента с которого начинать
                * @param iCount сколько элементов надо получить
                * @param iOffset смещение внутри шага (в элементах)
                * @param iLen количество элементов в шаге.
                */
                function /** @no-inline */retrieve(pSrc, pDst, iStride, iFrom, iCount, iOffset, iLen) {
                    if (typeof iStride === "undefined") { iStride = 1; }
                    if (typeof iFrom === "undefined") { iFrom = 0; }
                    if (typeof iOffset === "undefined") { iOffset = 0; }
                    if (typeof iLen === "undefined") { iLen = iStride - iOffset; }
                    if(!akra.isDef(iCount)) {
                        iCount = (pSrc.length / iStride - iFrom);
                    }
                    if(iOffset + iLen > iStride) {
                        iLen = iStride - iOffset;
                    }
                    var iBegin = iFrom * iStride;
                    var n = 0;
                    for(var i = 0; i < iCount; ++i) {
                        for(var j = 0; j < iLen; ++j) {
                            pDst[n++] = (pSrc[iBegin + i * iStride + iOffset + j]);
                        }
                    }
                    return n;
                }
                function /** @no-inline */string2Array(sData, ppData, fnConv, iFrom) {
                    if (typeof fnConv === "undefined") { fnConv = parseFloat; }
                    if (typeof iFrom === "undefined") { iFrom = 0; }
                    var pData = sData.split(/[\s]+/g);
                    for(var i = 0, n = pData.length, j = 0; i < n; ++i) {
                        if(pData[i] != "") {
                            ppData[iFrom + j] = fnConv(pData[i]);
                            j++;
                        }
                    }
                    return n;
                }
                function /** @inline */string2IntArray(sData, ppData, iFrom) {
                    return string2Array(sData, ppData, parseInt, iFrom);
                }
                function /** @inline */string2FloatArray(sData, ppData, iFrom) {
                    return string2Array(sData, ppData, parseFloat, iFrom);
                }
                function /** @inline */string2BoolArray(sData, ppData, iFrom) {
                    return string2Array(sData, ppData, parseBool, iFrom);
                }
                function /** @inline */string2StringArray(sData, ppData, iFrom) {
                    return string2Array(sData, ppData, parseString, iFrom);
                }
                function /** @no-inline */string2Any(sData, n, sType, isArray) {
                    if (typeof isArray === "undefined") { isArray = false; }
                    var ppData = new (pConvFormats[sType].type)(n);
                    pConvFormats[sType].converter(sData, ppData);
                    if(n == 1 && !isArray) {
                        return ppData[0];
                    }
                    return ppData;
                }
                ;
                // additional
                function /** @no-inline */printArray(pArr, nRow, nCol) {
                    var s = "\n";
                    for(var i = 0; i < pArr.length; ++i) {
                        if(i % nCol == 0) {
                            s += "  ";
                        }
                        s += pArr[i] + ", ";
                        if((i + 1) % nRow == 0) {
                            s += '\n';
                        }
                    }
                    return s;
                }
                function /** @no-inline */sortArrayByProperty(pData, sProperty) {
                    var tmp;
                    for(var i = pData.length - 1; i > 0; i--) {
                        for(var j = 0; j < i; j++) {
                            if(pData[j][sProperty] > pData[j + 1][sProperty]) {
                                tmp = pData[j];
                                pData[j] = pData[j + 1];
                                pData[j + 1] = tmp;
                            }
                        }
                    }
                    return pData;
                }
                function /** @inline */stringData(pXML) {
                    return (akra.isDefAndNotNull(pXML) ? pXML.textContent : null);
                }
                function /** @inline */attr(pXML, sName) {
                    return pXML.getAttribute(sName);
                }
                function /** @no-inline */firstChild(pXML, sTag) {
                    if(akra.isString(sTag)) {
                        return pXML.getElementsByTagName(sTag)[0];
                    }
                    for(var i = 0; i < pXML.childNodes.length; i++) {
                        if(pXML.childNodes[i].nodeType === Node.ELEMENT_NODE) {
                            return pXML.childNodes[i];
                        }
                    }
                    return null;
                }
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        akra.logger.registerCode(2001, "Grammar not LALR(1)! Cannot to generate syntax table. Add operation error.\n" + "Conflict in state with index: {stateIndex}. With grammar symbol: \"{grammarSymbol}\"\n" + "Old operation: {oldOperation}\n" + "New operation: {newOperation}\n" + "For more info init parser in debug-mode and see syntax table and list of states.");
        akra.logger.registerCode(2002, "Grammar not LALR(1)! Cannot to generate syntax table. Add state link error.\n" + "Conflict in state with index: {stateIndex}. With grammar symbol: \"{grammarSymbol}\"\n" + "Old next state: {oldNextStateIndex}\n" + "New next state: {newNextStateIndex}\n" + "For more info init parser in debug-mode and see syntax table and list of states.");
        akra.logger.registerCode(2003, "Grammar error. Can`t generate rules from grammar\n" + "Unexpected symbol: {unexpectedSymbol}\n" + "Expected: {expectedSymbol}");
        akra.logger.registerCode(2004, "Grammar error. Empty additional function name.");
        akra.logger.registerCode(2005, "Grammar error. Bad keyword: {badKeyword}\n" + "All keyword must be define in lexer rule block.");
        akra.logger.registerCode(2051, "Syntax error during parsing. Token: {tokenValue}\n" + "Line: {line}. Column: {column}.");
        akra.logger.registerCode(2101, "Unknown token: {tokenValue}");
        akra.logger.registerCode(2102, "Bad token: {tokenValue}");
        function /** @no-inline */sourceLocationToString(pLocation) {
            var sLocation = "[" + pLocation.file + ":" + pLocation.line.toString() + "]: ";
            return sLocation;
        }
        function /** @no-inline */syntaxErrorLogRoutine(pLogEntity) {
            var sPosition = sourceLocationToString(pLogEntity.location);
            var sError = "Code: " + pLogEntity.code.toString() + ". ";
            var pParseMessage = pLogEntity.message.split(/\{(\w+)\}/);
            var pInfo = pLogEntity.info;
            for(var i = 0; i < pParseMessage.length; i++) {
                if(akra.isDef(pInfo[pParseMessage[i]])) {
                    pParseMessage[i] = pInfo[pParseMessage[i]];
                }
            }
            var sMessage = sPosition + sError + pParseMessage.join("");
            console["error"].call(console, sMessage);
        }
        akra.logger.setCodeFamilyRoutine("ParserSyntaxErrors", syntaxErrorLogRoutine, 8 /* ERROR */ );
        var Item = (function () {
            function /** @no-inline */Item(pRule, iPos, pExpected) {
                this._pRule = pRule;
                this._iPos = iPos;
                this._iIndex = 0;
                this._pState = null;
                this._isNewExpected = true;
                this._iLength = 0;
                this._pExpected = {
                };
                if(arguments.length === 3) {
                    var i = null;
                    for(i in arguments[2]) {
                        this.addExpected(i);
                    }
                }
            }
            Object.defineProperty(Item.prototype, "rule", {
                get: function /** @inline */() {
                    return this._pRule;
                },
                set: function /** @inline */(pRule) {
                    this._pRule = pRule;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Item.prototype, "position", {
                get: function /** @inline */() {
                    return this._iPos;
                },
                set: function /** @inline */(iPos) {
                    this._iPos = iPos;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Item.prototype, "state", {
                get: function /** @inline */() {
                    return this._pState;
                },
                set: function /** @inline */(pState) {
                    this._pState = pState;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Item.prototype, "index", {
                get: function /** @inline */() {
                    return this._iIndex;
                },
                set: function /** @inline */(iIndex) {
                    this._iIndex = iIndex;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Item.prototype, "expectedSymbols", {
                get: function /** @inline */() {
                    return this._pExpected;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Item.prototype, "length", {
                get: function /** @inline */() {
                    return this._iLength;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Item.prototype, "isNewExpected", {
                get: function /** @inline */() {
                    return this._isNewExpected;
                },
                set: function /** @inline */(_isNewExpected) {
                    this._isNewExpected = _isNewExpected;
                },
                enumerable: true,
                configurable: true
            });
            Item.prototype.isEqual = function /** @no-inline */(pItem, eType) {
                if (typeof eType === "undefined") { eType = 0 /* k_LR0 */ ; }
                if(eType === 0 /* k_LR0 */ ) {
                    return (this._pRule === pItem.rule && this._iPos === pItem.position);
                } else if(eType === 1 /* k_LR1 */ ) {
                    if(!(this._pRule === pItem.rule && this._iPos === pItem.position && this._iLength === (pItem).length)) {
                        return false;
                    }
                    var i = null;
                    for(i in this._pExpected) {
                        if(!(pItem).isExpected(i)) {
                            return false;
                        }
                    }
                    return true;
                }
            };
            Item.prototype.isParentItem = function /** @no-inline */(pItem) {
                return (this._pRule === pItem.rule && this._iPos === pItem.position + 1);
            };
            Item.prototype.isChildItem = function /** @no-inline */(pItem) {
                return (this._pRule === pItem.rule && this._iPos === pItem.position - 1);
            };
            Item.prototype.mark = function /** @no-inline */() {
                var pRight = this._pRule.right;
                if(this._iPos === pRight.length) {
                    return "END";
                }
                return pRight[this._iPos];
            };
            Item.prototype.end = function /** @inline */() {
                return this._pRule.right[this._pRule.right.length - 1] || "EMPTY";
            };
            Item.prototype.nextMarked = function /** @inline */() {
                return this._pRule.right[this._iPos + 1] || "END";
            };
            Item.prototype.isExpected = function /** @inline */(sSymbol) {
                return !!(this._pExpected[sSymbol]);
            };
            Item.prototype.addExpected = function /** @no-inline */(sSymbol) {
                if(this._pExpected[sSymbol]) {
                    return false;
                }
                this._pExpected[sSymbol] = true;
                this._isNewExpected = true;
                this._iLength++;
                return true;
            };
            Item.prototype.toString = function /** @no-inline */() {
                var sMsg = this._pRule.left + " -> ";
                var sExpected = "";
                var pRight = this._pRule.right;
                for(var k = 0; k < pRight.length; k++) {
                    if(k === this._iPos) {
                        sMsg += ". ";
                    }
                    sMsg += pRight[k] + " ";
                }
                if(this._iPos === pRight.length) {
                    sMsg += ". ";
                }
                if(akra.isDef(this._pExpected)) {
                    sExpected = ", ";
                    for(var l in this._pExpected) {
                        sExpected += l + "/";
                    }
                    if(sExpected !== ", ") {
                        sMsg += sExpected;
                    }
                }
                sMsg = sMsg.slice(0, sMsg.length - 1);
                return sMsg;
            };
            return Item;
        })();        
        var State = (function () {
            function /** @no-inline */State() {
                this._pItemList = [];
                this._pNextStates = {
                };
                this._iIndex = 0;
                this._nBaseItems = 0;
            }
            Object.defineProperty(State.prototype, "items", {
                get: function /** @inline */() {
                    return this._pItemList;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(State.prototype, "numBaseItems", {
                get: function /** @inline */() {
                    return this._nBaseItems;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(State.prototype, "index", {
                get: function /** @inline */() {
                    return this._iIndex;
                },
                set: function /** @inline */(iIndex) {
                    this._iIndex = iIndex;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(State.prototype, "nextStates", {
                get: function /** @inline */() {
                    return this._pNextStates;
                },
                enumerable: true,
                configurable: true
            });
            State.prototype.hasItem = function /** @no-inline */(pItem, eType) {
                var i;
                var pItems = this._pItemList;
                for(i = 0; i < pItems.length; i++) {
                    if(pItems[i].isEqual(pItem, eType)) {
                        return pItems[i];
                    }
                }
                return null;
            };
            State.prototype.hasParentItem = function /** @no-inline */(pItem) {
                var i;
                var pItems = this._pItemList;
                for(i = 0; i < pItems.length; i++) {
                    if(pItems[i].isParentItem(pItem)) {
                        return pItems[i];
                    }
                }
                return null;
            };
            State.prototype.hasChildItem = function /** @no-inline */(pItem) {
                var i;
                var pItems = this._pItemList;
                for(i = 0; i < pItems.length; i++) {
                    if(pItems[i].isChildItem(pItem)) {
                        return pItems[i];
                    }
                }
                return null;
            };
            State.prototype.hasRule = function /** @no-inline */(pRule, iPos) {
                var i = 0;
                var pItemList = this._pItemList;
                var pItem;
                for(i = 0; i < this._nBaseItems; i++) {
                    pItem = pItemList[i];
                    if(pItem.rule === pRule && pItem.position === iPos) {
                        return true;
                    }
                }
                return false;
            };
            State.prototype.isEmpty = function /** @inline */() {
                return !(this._pItemList.length);
            };
            State.prototype.isEqual = function /** @no-inline */(pState, eType) {
                var pItemsA = this._pItemList;
                var pItemsB = pState.items;
                if(this._nBaseItems !== pState.numBaseItems) {
                    return false;
                }
                var nItems = this._nBaseItems;
                var i, j;
                var isEqual;
                for(i = 0; i < nItems; i++) {
                    isEqual = false;
                    for(j = 0; j < nItems; j++) {
                        if(pItemsA[i].isEqual(pItemsB[j], eType)) {
                            isEqual = true;
                            break;
                        }
                    }
                    if(!isEqual) {
                        return false;
                    }
                }
                return true;
            };
            State.prototype.push = function /** @no-inline */(pItem) {
                if(this._pItemList.length === 0 || pItem.position > 0) {
                    this._nBaseItems += 1;
                }
                pItem.state = this;
                this._pItemList.push(pItem);
            };
            State.prototype.tryPush_LR0 = function /** @no-inline */(pRule, iPos) {
                var i;
                var pItems = this._pItemList;
                for(i = 0; i < pItems.length; i++) {
                    if(pItems[i].rule === pRule && pItems[i].position === iPos) {
                        return false;
                    }
                }
                var pItem = new Item(pRule, iPos);
                this.push(pItem);
                return true;
            };
            State.prototype.tryPush_LR = function /** @no-inline */(pRule, iPos, sExpectedSymbol) {
                var i;
                var pItems = (this._pItemList);
                for(i = 0; i < pItems.length; i++) {
                    if(pItems[i].rule === pRule && pItems[i].position === iPos) {
                        return pItems[i].addExpected(sExpectedSymbol);
                    }
                }
                var pExpected = {
                };
                pExpected[sExpectedSymbol] = true;
                var pItem = new Item(pRule, iPos, pExpected);
                this.push(pItem);
                return true;
            };
            State.prototype.getNextStateBySymbol = function /** @no-inline */(sSymbol) {
                if(akra.isDef(this._pNextStates[sSymbol])) {
                    return this._pNextStates[sSymbol];
                } else {
                    return null;
                }
            };
            State.prototype.addNextState = function /** @no-inline */(sSymbol, pState) {
                if(akra.isDef(this._pNextStates[sSymbol])) {
                    return false;
                } else {
                    this._pNextStates[sSymbol] = pState;
                    return true;
                }
            };
            State.prototype.deleteNotBase = function /** @inline */() {
                this._pItemList.length = this._nBaseItems;
            };
            State.prototype.toString = function /** @no-inline */(isBase) {
                var len = 0;
                var sMsg;
                var pItemList = this._pItemList;
                sMsg = "State " + this._iIndex + ":\n";
                len = isBase ? this._nBaseItems : pItemList.length;
                for(var j = 0; j < len; j++) {
                    sMsg += "\t\t";
                    sMsg += pItemList[j].toString();
                    sMsg += "\n";
                }
                return sMsg;
            };
            return State;
        })();        
        var ParseTree = (function () {
            function /** @no-inline */ParseTree() {
                this._pRoot = null;
                this._pNodes = [];
                this._pNodesCountStack = [];
                this._isOptimizeMode = false;
            }
            Object.defineProperty(ParseTree.prototype, "root", {
                get: function /** @inline */() {
                    return this._pRoot;
                },
                set: function /** @inline */(pRoot) {
                    this._pRoot = pRoot;
                },
                enumerable: true,
                configurable: true
            });
            ParseTree.prototype.setRoot = function /** @no-inline */() {
                this._pRoot = this._pNodes.pop();
            };
            ParseTree.prototype.setOptimizeMode = function /** @no-inline */(isOptimize) {
                this._isOptimizeMode = isOptimize;
            };
            ParseTree.prototype.addNode = function /** @no-inline */(pNode) {
                this._pNodes.push(pNode);
                this._pNodesCountStack.push(1);
            };
            ParseTree.prototype.reduceByRule = function /** @no-inline */(pRule, eCreate) {
                if (typeof eCreate === "undefined") { eCreate = 0 /* k_Default */ ; }
                var iReduceCount = 0;
                var pNodesCountStack = this._pNodesCountStack;
                var pNode;
                var iRuleLength = pRule.right.length;
                var pNodes = this._pNodes;
                var nOptimize = this._isOptimizeMode ? 1 : 0;
                while(iRuleLength) {
                    iReduceCount += pNodesCountStack.pop();
                    iRuleLength--;
                }
                if((eCreate === 0 /* k_Default */  && iReduceCount > nOptimize) || (eCreate === 1 /* k_Necessary */ )) {
                    pNode = {
                        name: pRule.left,
                        children: null,
                        parent: null,
                        value: "",
                        isAnalyzed: false,
                        position: this._pNodes.length
                    };
                    while(iReduceCount) {
                        this.addLink(pNode, pNodes.pop());
                        iReduceCount -= 1;
                    }
                    pNodes.push(pNode);
                    pNodesCountStack.push(1);
                } else {
                    pNodesCountStack.push(iReduceCount);
                }
            };
            ParseTree.prototype.toString = function /** @no-inline */() {
                if(this._pRoot) {
                    return this.toStringNode(this._pRoot);
                } else {
                    return "";
                }
            };
            ParseTree.prototype.clone = function /** @no-inline */() {
                var pTree = new ParseTree();
                pTree.root = this.cloneNode(this._pRoot);
                return pTree;
            };
            ParseTree.prototype.getNodes = function /** @inline */() {
                return this._pNodes;
            };
            ParseTree.prototype.getLastNode = function /** @inline */() {
                return this._pNodes[this._pNodes.length - 1];
            };
            ParseTree.prototype.addLink = function /** @no-inline */(pParent, pNode) {
                if(!pParent.children) {
                    pParent.children = [];
                }
                pParent.children.push(pNode);
                pNode.parent = pParent;
            };
            ParseTree.prototype.cloneNode = function /** @no-inline */(pNode) {
                var pNewNode;
                pNewNode = {
                    name: pNode.name,
                    value: pNode.value,
                    children: null,
                    parent: null,
                    isAnalyzed: pNode.isAnalyzed,
                    position: pNode.position
                };
                var pChildren = pNode.children;
                for(var i = 0; pChildren && i < pChildren.length; i++) {
                    this.addLink(pNewNode, this.cloneNode(pChildren[i]));
                }
                return pNewNode;
            };
            ParseTree.prototype.toStringNode = function /** @no-inline */(pNode, sPadding) {
                if (typeof sPadding === "undefined") { sPadding = ""; }
                var sRes = sPadding + "{\n";
                var sOldPadding = sPadding;
                var sDefaultPadding = "  ";
                sPadding += sDefaultPadding;
                if(pNode.value) {
                    sRes += sPadding + "name : \"" + pNode.name + "\"" + ",\n";
                    sRes += sPadding + "value : \"" + pNode.value + "\"" + "\n";
                } else {
                    sRes += sPadding + "name : \"" + pNode.name + "\"" + "\n";
                    sRes += sPadding + "children : [";
                    var pChildren = pNode.children;
                    if(pChildren) {
                        sRes += "\n";
                        sPadding += sDefaultPadding;
                        for(var i = pChildren.length - 1; i >= 0; i--) {
                            sRes += this.toStringNode(pChildren[i], sPadding);
                            sRes += ",\n";
                        }
                        sRes = sRes.slice(0, sRes.length - 2);
                        sRes += "\n";
                        sRes += sOldPadding + sDefaultPadding + "]\n";
                    } else {
                        sRes += " ]\n";
                    }
                }
                sRes += sOldPadding + "}";
                return sRes;
            };
            return ParseTree;
        })();
        util.ParseTree = ParseTree;        
        var Lexer = (function () {
            function /** @no-inline */Lexer(pParser) {
                this._iLineNumber = 0;
                this._iColumnNumber = 0;
                this._sSource = "";
                this._iIndex = 0;
                this._pParser = pParser;
                this._pPunctuatorsMap = {
                };
                this._pKeywordsMap = {
                };
                this._pPunctuatorsFirstSymbols = {
                };
            }
            Lexer.prototype.addPunctuator = function /** @no-inline */(sValue, sName) {
                if(sName === undefined && sValue.length === 1) {
                    sName = "T_PUNCTUATOR_" + sValue.charCodeAt(0);
                }
                this._pPunctuatorsMap[sValue] = sName;
                this._pPunctuatorsFirstSymbols[sValue[0]] = true;
                return sName;
            };
            Lexer.prototype.addKeyword = function /** @no-inline */(sValue, sName) {
                this._pKeywordsMap[sValue] = sName;
                return sName;
            };
            Lexer.prototype.getTerminalValueByName = function /** @no-inline */(sName) {
                var sValue = null;
                for(sValue in this._pPunctuatorsMap) {
                    if(this._pPunctuatorsMap[sValue] === sName) {
                        return sValue;
                    }
                }
                for(sValue in this._pKeywordsMap) {
                    if(this._pKeywordsMap[sValue] === sName) {
                        return sValue;
                    }
                }
                return sName;
            };
            Lexer.prototype.init = function /** @no-inline */(sSource) {
                this._sSource = sSource;
                this._iLineNumber = 0;
                this._iColumnNumber = 0;
                this._iIndex = 0;
            };
            Lexer.prototype.getNextToken = function /** @no-inline */() {
                var ch = this.currentChar();
                if(!ch) {
                    return {
                        name: "$",
                        value: "$",
                        start: this._iColumnNumber,
                        end: this._iColumnNumber,
                        line: this._iLineNumber
                    };
                }
                var eType = this.identityTokenType();
                var pToken;
                switch(eType) {
                    case 1 /* k_NumericLiteral */ :
                        pToken = this.scanNumber();
                        break;
                    case 2 /* k_CommentLiteral */ :
                        this.scanComment();
                        pToken = this.getNextToken();
                        break;
                    case 3 /* k_StringLiteral */ :
                        pToken = this.scanString();
                        break;
                    case 4 /* k_PunctuatorLiteral */ :
                        pToken = this.scanPunctuator();
                        break;
                    case 6 /* k_IdentifierLiteral */ :
                        pToken = this.scanIdentifier();
                        break;
                    case 5 /* k_WhitespaceLiteral */ :
                        this.scanWhiteSpace();
                        pToken = this.getNextToken();
                        break;
                    default:
                        this._error(2101, {
                            name: "UNNOWN",
                            value: ch + this._sSource[this._iIndex + 1],
                            start: this._iColumnNumber,
                            end: this._iColumnNumber + 1,
                            line: this._iLineNumber
                        });
                }
                return pToken;
            };
            Lexer.prototype._getIndex = function /** @inline */() {
                return this._iIndex;
            };
            Lexer.prototype._setSource = function /** @inline */(sSource) {
                this._sSource = sSource;
            };
            Lexer.prototype._setIndex = function /** @inline */(iIndex) {
                this._iIndex = iIndex;
            };
            Lexer.prototype._error = function /** @no-inline */(eCode, pToken) {
                var pLocation = {
                    file: this._pParser.getParseFileName(),
                    line: this._iLineNumber
                };
                var pInfo = {
                    tokenValue: pToken.value,
                    tokenType: pToken.type
                };
                var pLogEntity = {
                    code: eCode,
                    info: pInfo,
                    location: pLocation
                };
                akra.logger["error"](pLogEntity);
                throw new Error(eCode.toString());
            };
            Lexer.prototype.identityTokenType = function /** @no-inline */() {
                if(this.isIdentifierStart()) {
                    return 6 /* k_IdentifierLiteral */ ;
                }
                if(this.isWhiteSpaceStart()) {
                    return 5 /* k_WhitespaceLiteral */ ;
                }
                if(this.isStringStart()) {
                    return 3 /* k_StringLiteral */ ;
                }
                if(this.isCommentStart()) {
                    return 2 /* k_CommentLiteral */ ;
                }
                if(this.isNumberStart()) {
                    return 1 /* k_NumericLiteral */ ;
                }
                if(this.isPunctuatorStart()) {
                    return 4 /* k_PunctuatorLiteral */ ;
                }
                return 8 /* k_Unknown */ ;
            };
            Lexer.prototype.isNumberStart = function /** @no-inline */() {
                var ch = this.currentChar();
                if((ch >= '0') && (ch <= '9')) {
                    return true;
                }
                var ch1 = this.nextChar();
                if(ch === "." && (ch1 >= '0') && (ch1 <= '9')) {
                    return true;
                }
                return false;
            };
            Lexer.prototype.isCommentStart = function /** @no-inline */() {
                var ch = this.currentChar();
                var ch1 = this.nextChar();
                if(ch === "/" && (ch1 === "/" || ch1 === "*")) {
                    return true;
                }
                return false;
            };
            Lexer.prototype.isStringStart = function /** @no-inline */() {
                var ch = this.currentChar();
                if(ch === "\"" || ch === "'") {
                    return true;
                }
                return false;
            };
            Lexer.prototype.isPunctuatorStart = function /** @no-inline */() {
                var ch = this.currentChar();
                if(this._pPunctuatorsFirstSymbols[ch]) {
                    return true;
                }
                return false;
            };
            Lexer.prototype.isWhiteSpaceStart = function /** @no-inline */() {
                var ch = this.currentChar();
                if(ch === ' ' || ch === '\n' || ch === '\r' || ch === '\t') {
                    return true;
                }
                return false;
            };
            Lexer.prototype.isIdentifierStart = function /** @no-inline */() {
                var ch = this.currentChar();
                if((ch === '_') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
                    return true;
                }
                return false;
            };
            Lexer.prototype.isLineTerminator = function /** @no-inline */(sSymbol) {
                return (sSymbol === '\n' || sSymbol === '\r' || sSymbol === '\u2028' || sSymbol === '\u2029');
            };
            Lexer.prototype.isWhiteSpace = function /** @no-inline */(sSymbol) {
                return (sSymbol === ' ') || (sSymbol === '\t');
            };
            Lexer.prototype.isKeyword = function /** @inline */(sValue) {
                return !!(this._pKeywordsMap[sValue]);
            };
            Lexer.prototype.isPunctuator = function /** @inline */(sValue) {
                return !!(this._pPunctuatorsMap[sValue]);
            };
            Lexer.prototype.nextChar = function /** @inline */() {
                return this._sSource[this._iIndex + 1];
            };
            Lexer.prototype.currentChar = function /** @inline */() {
                return this._sSource[this._iIndex];
            };
            Lexer.prototype.readNextChar = function /** @inline */() {
                this._iIndex++;
                this._iColumnNumber++;
                return this._sSource[this._iIndex];
            };
            Lexer.prototype.scanString = function /** @no-inline */() {
                var chFirst = this.currentChar();
                var sValue = chFirst;
                var ch = null;
                var chPrevious = chFirst;
                var isGoodFinish = false;
                var iStart = this._iColumnNumber;
                while(true) {
                    ch = this.readNextChar();
                    if(!ch) {
                        break;
                    }
                    sValue += ch;
                    if(ch === chFirst && chPrevious !== '\\') {
                        isGoodFinish = true;
                        this.readNextChar();
                        break;
                    }
                    chPrevious = ch;
                }
                if(isGoodFinish) {
                    return {
                        name: "T_STRING",
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber - 1,
                        line: this._iLineNumber
                    };
                } else {
                    if(!ch) {
                        ch = "EOF";
                    }
                    sValue += ch;
                    this._error(2102, {
                        type: 3 /* k_StringLiteral */ ,
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber,
                        line: this._iLineNumber
                    });
                    return null;
                }
            };
            Lexer.prototype.scanPunctuator = function /** @no-inline */() {
                var sValue = this.currentChar();
                var ch;
                var iStart = this._iColumnNumber;
                while(true) {
                    ch = this.readNextChar();
                    if(ch) {
                        sValue += ch;
                        this._iColumnNumber++;
                        if(!this.isPunctuator(sValue)) {
                            sValue = sValue.slice(0, sValue.length - 1);
                            break;
                        }
                    } else {
                        break;
                    }
                }
                return {
                    name: this._pPunctuatorsMap[sValue],
                    value: sValue,
                    start: iStart,
                    end: this._iColumnNumber - 1,
                    line: this._iLineNumber
                };
            };
            Lexer.prototype.scanNumber = function /** @no-inline */() {
                var ch = this.currentChar();
                var sValue = "";
                var isFloat = false;
                var chPrevious = ch;
                var isGoodFinish = false;
                var iStart = this._iColumnNumber;
                var isE = false;
                if(ch === '.') {
                    sValue += 0;
                    isFloat = true;
                }
                sValue += ch;
                while(true) {
                    ch = this.readNextChar();
                    if(ch === '.') {
                        if(isFloat) {
                            break;
                        } else {
                            isFloat = true;
                        }
                    } else if(ch === 'e') {
                        if(isE) {
                            break;
                        } else {
                            isE = true;
                        }
                    } else if(((ch === '+' || ch === '-') && chPrevious === 'e')) {
                        sValue += ch;
                        chPrevious = ch;
                        continue;
                    } else if(ch === 'f' && isFloat) {
                        ch = this.readNextChar();
                        if((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
                            break;
                        }
                        isGoodFinish = true;
                        break;
                    } else if((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
                        break;
                    } else if(!((ch >= '0') && (ch <= '9')) || !ch) {
                        if((isE && chPrevious !== '+' && chPrevious !== '-' && chPrevious !== 'e') || !isE) {
                            isGoodFinish = true;
                        }
                        break;
                    }
                    sValue += ch;
                    chPrevious = ch;
                }
                if(isGoodFinish) {
                    var sName = isFloat ? "T_FLOAT" : "T_UINT";
                    return {
                        name: sName,
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber - 1,
                        line: this._iLineNumber
                    };
                } else {
                    if(!ch) {
                        ch = "EOF";
                    }
                    sValue += ch;
                    this._error(2102, {
                        type: 1 /* k_NumericLiteral */ ,
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber,
                        line: this._iLineNumber
                    });
                    return null;
                }
            };
            Lexer.prototype.scanIdentifier = function /** @no-inline */() {
                var ch = this.currentChar();
                var sValue = ch;
                var iStart = this._iColumnNumber;
                var isGoodFinish = false;
                while(true) {
                    ch = this.readNextChar();
                    if(!ch) {
                        isGoodFinish = true;
                        break;
                    }
                    if(!((ch === '_') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9'))) {
                        isGoodFinish = true;
                        break;
                    }
                    sValue += ch;
                }
                if(isGoodFinish) {
                    if(this.isKeyword(sValue)) {
                        return {
                            name: this._pKeywordsMap[sValue],
                            value: sValue,
                            start: iStart,
                            end: this._iColumnNumber - 1,
                            line: this._iLineNumber
                        };
                    } else {
                        var sName = this._pParser.isTypeId(sValue) ? "T_TYPE_ID" : "T_NON_TYPE_ID";
                        return {
                            name: sName,
                            value: sValue,
                            start: iStart,
                            end: this._iColumnNumber - 1,
                            line: this._iLineNumber
                        };
                    }
                } else {
                    if(!ch) {
                        ch = "EOF";
                    }
                    sValue += ch;
                    this._error(2102, {
                        type: 6 /* k_IdentifierLiteral */ ,
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber,
                        line: this._iLineNumber
                    });
                    return null;
                }
            };
            Lexer.prototype.scanWhiteSpace = function /** @no-inline */() {
                var ch = this.currentChar();
                while(true) {
                    if(!ch) {
                        break;
                    }
                    if(this.isLineTerminator(ch)) {
                        if(ch === "\r" && this.nextChar() === "\n") {
                            this._iLineNumber--;
                        }
                        this._iLineNumber++;
                        ch = this.readNextChar();
                        this._iColumnNumber = 0;
                        continue;
                    } else if(ch === '\t') {
                        this._iColumnNumber += 3;
                    } else if(ch !== ' ') {
                        break;
                    }
                    ch = this.readNextChar();
                }
                return true;
            };
            Lexer.prototype.scanComment = function /** @no-inline */() {
                var sValue = this.currentChar();
                var ch = this.readNextChar();
                sValue += ch;
                if(ch === '/') {
                    //Line Comment
                    while(true) {
                        ch = this.readNextChar();
                        if(!ch) {
                            break;
                        }
                        if(this.isLineTerminator(ch)) {
                            if(ch === "\r" && this.nextChar() === "\n") {
                                this._iLineNumber--;
                            }
                            this._iLineNumber++;
                            this.readNextChar();
                            this._iColumnNumber = 0;
                            break;
                        }
                        sValue += ch;
                    }
                    return true;
                } else {
                    //Multiline Comment
                    var chPrevious = ch;
                    var isGoodFinish = false;
                    var iStart = this._iColumnNumber;
                    while(true) {
                        ch = this.readNextChar();
                        if(!ch) {
                            break;
                        }
                        sValue += ch;
                        if(ch === '/' && chPrevious === '*') {
                            isGoodFinish = true;
                            this.readNextChar();
                            break;
                        }
                        if(this.isLineTerminator(ch)) {
                            if(ch === "\r" && this.nextChar() === "\n") {
                                this._iLineNumber--;
                            }
                            this._iLineNumber++;
                            this._iColumnNumber = -1;
                        }
                        chPrevious = ch;
                    }
                    if(isGoodFinish) {
                        return true;
                    } else {
                        if(!ch) {
                            ch = "EOF";
                        }
                        sValue += ch;
                        this._error(2102, {
                            type: 2 /* k_CommentLiteral */ ,
                            value: sValue,
                            start: iStart,
                            end: this._iColumnNumber,
                            line: this._iLineNumber
                        });
                    }
                }
            };
            return Lexer;
        })();        
        var Parser = (function () {
            function /** @no-inline */Parser() {
                this._sSource = "";
                this._iIndex = 0;
                this._pSyntaxTree = null;
                this._pTypeIdMap = null;
                this._pLexer = null;
                this._pStack = [];
                this._pToken = null;
                this._fnFinishCallback = null;
                this._pCaller = null;
                this._pSymbolMap = {
                    "$": true
                };
                this._pSyntaxTable = null;
                this._pReduceOperationsMap = null;
                this._pShiftOperationsMap = null;
                this._pSuccessOperation = null;
                this._pFirstTerminalsDMap = null;
                this._pFollowTerminalsDMap = null;
                this._pRulesDMap = null;
                this._pStateList = null;
                this._nRules = 0;
                this._pAdditionalFuncInfoList = null;
                this._pAdditionalFunctionsMap = null;
                this._pAdidtionalFunctByStateDMap = null;
                this._eType = 0 /* k_LR0 */ ;
                this._pRuleCreationModeMap = null;
                this._eParseMode = 1 /* k_AllNode */ ;
                // this._isSync = false;
                this._pStatesTempMap = null;
                this._pBaseItemList = null;
                this._pExpectedExtensionDMap = null;
                this._sFileName = "stdin";
                ;
            }
            Parser.prototype.isTypeId = function /** @no-inline */(sValue) {
                return !!(this._pTypeIdMap[sValue]);
            };
            Parser.prototype.returnCode = function /** @no-inline */(pNode) {
                if(pNode) {
                    if(pNode.value) {
                        return pNode.value + " ";
                    } else if(pNode.children) {
                        var sCode = "";
                        var i = 0;
                        for(i = pNode.children.length - 1; i >= 0; i--) {
                            sCode += this.returnCode(pNode.children[i]);
                        }
                        return sCode;
                    }
                }
                return "";
            };
            Parser.prototype.init = function /** @no-inline */(sGrammar, eMode, eType) {
                if (typeof eMode === "undefined") { eMode = 1 /* k_AllNode */ ; }
                if (typeof eType === "undefined") { eType = 2 /* k_LALR */ ; }
                try  {
                    this._eType = eType;
                    this._pLexer = new Lexer(this);
                    this._eParseMode = eMode;
                    this.generateRules(sGrammar);
                    this.buildSyntaxTable();
                    this.generateFunctionByStateMap();
                    if(!akra.bf.testAll(eMode, 16 /* k_DebugMode */ )) {
                        this.clearMem();
                    }
                    return true;
                } catch (e) {
                    util.logger.setSourceLocation("util/Parser.ts", 1397);
                    util.logger.log(e.stack);
                    ;
                    // error("Could`not initialize parser. Error with code has occurred: " + e.message + ". See log for more info.");
                    return false;
                }
            };
            Parser.prototype.parse = function /** @no-inline */(sSource, fnFinishCallback, pCaller) {
                if (typeof fnFinishCallback === "undefined") { fnFinishCallback = null; }
                if (typeof pCaller === "undefined") { pCaller = null; }
                try  {
                    this.defaultInit();
                    this._sSource = sSource;
                    this._pLexer.init(sSource);
                    //this._isSync = isSync;
                    this._fnFinishCallback = fnFinishCallback;
                    this._pCaller = pCaller;
                    var pTree = this._pSyntaxTree;
                    var pStack = this._pStack;
                    var pSyntaxTable = this._pSyntaxTable;
                    var isStop = false;
                    var isError = false;
                    var isPause = false;
                    var pToken = this.readToken();
                    var pOperation;
                    var iRuleLength;
                    var eAdditionalOperationCode;
                    var iStateIndex = 0;
                    while(!isStop) {
                        pOperation = pSyntaxTable[pStack[pStack.length - 1]][pToken.name];
                        if(akra.isDef(pOperation)) {
                            switch(pOperation.type) {
                                case 103 /* k_Success */ :
                                    isStop = true;
                                    break;
                                case 101 /* k_Shift */ :
                                    iStateIndex = pOperation.index;
                                    pStack.push(iStateIndex);
                                    pTree.addNode(pToken);
                                    eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pToken.name);
                                    if(eAdditionalOperationCode === 100 /* k_Error */ ) {
                                        isError = true;
                                        isStop = true;
                                    } else if(eAdditionalOperationCode === 104 /* k_Pause */ ) {
                                        this._pToken = null;
                                        isStop = true;
                                        isPause = true;
                                    } else if(eAdditionalOperationCode === 105 /* k_Ok */ ) {
                                        pToken = this.readToken();
                                    }
                                    break;
                                case 102 /* k_Reduce */ :
                                    iRuleLength = pOperation.rule.right.length;
                                    pStack.length -= iRuleLength;
                                    iStateIndex = pSyntaxTable[pStack[pStack.length - 1]][pOperation.rule.left].index;
                                    pStack.push(iStateIndex);
                                    pTree.reduceByRule(pOperation.rule, this._pRuleCreationModeMap[pOperation.rule.left]);
                                    eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pOperation.rule.left);
                                    if(eAdditionalOperationCode === 100 /* k_Error */ ) {
                                        isError = true;
                                        isStop = true;
                                    } else if(eAdditionalOperationCode === 104 /* k_Pause */ ) {
                                        this._pToken = pToken;
                                        isStop = true;
                                        isPause = true;
                                    }
                                    break;
                            }
                        } else {
                            isError = true;
                            isStop = true;
                        }
                    }
                    if(isPause) {
                        return 0 /* k_Pause */ ;
                    }
                    if(!isError) {
                        pTree.setRoot();
                        this._sFileName = "stdin";
                        if(!akra.isNull(this._fnFinishCallback)) {
                            this._fnFinishCallback.call(this._pCaller, 1 /* k_Ok */ , this.getParseFileName());
                        }
                        return 1 /* k_Ok */ ;
                    } else {
                        this._error(2051, pToken);
                        this._sFileName = "stdin";
                        if(!akra.isNull(this._fnFinishCallback)) {
                            this._fnFinishCallback.call(this._pCaller, 2 /* k_Error */ , this.getParseFileName());
                        }
                        return 2 /* k_Error */ ;
                    }
                } catch (e) {
                    // debug_print(e.stack);
                    this._sFileName = "stdin";
                    return 2 /* k_Error */ ;
                }
            };
            Parser.prototype.setParseFileName = function /** @no-inline */(sFileName) {
                this._sFileName = sFileName;
            };
            Parser.prototype.getParseFileName = function /** @no-inline */() {
                return this._sFileName;
            };
            Parser.prototype.pause = function /** @no-inline */() {
                return 0 /* k_Pause */ ;
            };
            Parser.prototype.resume = function /** @no-inline */() {
                return this.resumeParse();
            };
            Parser.prototype.printStates = function /** @no-inline */(isBaseOnly) {
                if (typeof isBaseOnly === "undefined") { isBaseOnly = true; }
                if(!akra.isDef(this._pStateList)) {
                    util.logger.setSourceLocation("util/Parser.ts", 1535);
                    util.logger.log("It`s impossible to print states. You must init parser in debug-mode");
                    ;
                    return;
                }
                var sMsg = "\n" + this.statesToString(isBaseOnly);
                util.logger.setSourceLocation("util/Parser.ts", 1539);
                util.logger.log(sMsg);
                ;
            };
            Parser.prototype.printState = function /** @no-inline */(iStateIndex, isBaseOnly) {
                if (typeof isBaseOnly === "undefined") { isBaseOnly = true; }
                if(!akra.isDef(this._pStateList)) {
                    util.logger.setSourceLocation("util/Parser.ts", 1544);
                    util.logger.log("It`s impossible to print states. You must init parser in debug-mode");
                    ;
                    return;
                }
                var pState = this._pStateList[iStateIndex];
                if(!akra.isDef(pState)) {
                    util.logger.setSourceLocation("util/Parser.ts", 1550);
                    util.logger.log("Can not print stete with index: " + iStateIndex.toString());
                    ;
                    return;
                }
                var sMsg = "\n" + pState.toString(isBaseOnly);
                util.logger.setSourceLocation("util/Parser.ts", 1555);
                util.logger.log(sMsg);
                ;
            };
            Parser.prototype.getGrammarSymbols = function /** @no-inline */() {
                return this._pGrammarSymbols;
            };
            Parser.prototype.getSyntaxTree = function /** @inline */() {
                return this._pSyntaxTree;
            };
            Parser.prototype._saveState = function /** @no-inline */() {
                return {
                    source: this._sSource,
                    index: this._pLexer._getIndex(),
                    fileName: this._sFileName,
                    tree: this._pSyntaxTree,
                    types: this._pTypeIdMap,
                    stack: this._pStack,
                    token: this._pToken,
                    fnCallback: this._fnFinishCallback,
                    caller: this._pCaller
                };
            };
            Parser.prototype._loadState = function /** @no-inline */(pState) {
                this._sSource = pState.source;
                this._iIndex = pState.index;
                this._sFileName = pState.fileName;
                this._pSyntaxTree = pState.tree;
                this._pTypeIdMap = pState.types;
                this._pStack = pState.stack;
                this._pToken = pState.token;
                this._fnFinishCallback = pState.fnCallback;
                this._pCaller = pState.caller;
                this._pLexer._setSource(pState.source);
                this._pLexer._setIndex(pState.index);
            };
            Parser.prototype.addAdditionalFunction = /**@protected*/ function /** @no-inline */(sFuncName, fnRuleFunction) {
                if(akra.isNull(this._pAdditionalFunctionsMap)) {
                    this._pAdditionalFunctionsMap = {
                    };
                }
                this._pAdditionalFunctionsMap[sFuncName] = fnRuleFunction;
            };
            Parser.prototype.addTypeId = /**@protected*/ function /** @no-inline */(sIdentifier) {
                if(akra.isNull(this._pTypeIdMap)) {
                    this._pTypeIdMap = {
                    };
                }
                this._pTypeIdMap[sIdentifier] = true;
            };
            Parser.prototype.defaultInit = /**@protected*/ function /** @no-inline */() {
                this._iIndex = 0;
                this._pStack = [
                    0
                ];
                this._pSyntaxTree = new ParseTree();
                this._pTypeIdMap = {
                };
                this._pSyntaxTree.setOptimizeMode(akra.bf.testAll(this._eParseMode, 8 /* k_Optimize */ ));
            };
            Parser.prototype._error = function /** @no-inline */(eCode, pErrorInfo) {
                var pLocation = {
                };
                var pInfo = {
                    tokenValue: null,
                    line: null,
                    column: null,
                    stateIndex: null,
                    oldNextStateIndex: null,
                    newNextStateIndex: null,
                    grammarSymbol: null,
                    newOperation: null,
                    oldOperation: null,
                    expectedSymbol: null,
                    unexpectedSymbol: null,
                    badKeyword: null
                };
                var pLogEntity = {
                    code: eCode,
                    info: pInfo,
                    location: pLocation
                };
                if(eCode === 2051) {
                    var pToken = pErrorInfo;
                    var iLine = pToken.line;
                    var iColumn = pToken.start;
                    pInfo.tokenValue = pToken.value;
                    pInfo.line = iLine;
                    pInfo.column = iColumn;
                    pLocation.file = this.getParseFileName();
                    pLocation.line = iLine;
                } else if(eCode === 2001) {
                    var iStateIndex = pErrorInfo.stateIndex;
                    var sSymbol = pErrorInfo.grammarSymbol;
                    var pOldOperation = pErrorInfo.oldOperation;
                    var pNewOperation = pErrorInfo.newOperation;
                    pInfo.stateIndex = iStateIndex;
                    pInfo.grammarSymbol = sSymbol;
                    pInfo.oldOperation = this.operationToString(pOldOperation);
                    pInfo.newOperation = this.operationToString(pNewOperation);
                    pLocation.file = "GRAMMAR";
                    pLocation.line = 0;
                } else if(eCode === 2002) {
                    var iStateIndex = pErrorInfo.stateIndex;
                    var sSymbol = pErrorInfo.grammarSymbol;
                    var iOldNextStateIndex = pErrorInfo.oldNextStateIndex;
                    var iNewNextStateIndex = pErrorInfo.newNextStateIndex;
                    pInfo.stateIndex = iStateIndex;
                    pInfo.grammarSymbol = sSymbol;
                    pInfo.oldNextStateIndex = iOldNextStateIndex;
                    pInfo.newNextStateIndex = iNewNextStateIndex;
                    pLocation.file = "GRAMMAR";
                    pLocation.line = 0;
                } else if(eCode === 2003) {
                    var iLine = pErrorInfo.grammarLine;
                    var sExpectedSymbol = pErrorInfo.expectedSymbol;
                    var sUnexpectedSymbol = pErrorInfo.unexpectedSymbol;
                    pInfo.expectedSymbol = sExpectedSymbol;
                    pInfo.unexpectedSymbol = sExpectedSymbol;
                    pLocation.file = "GRAMMAR";
                    pLocation.line = iLine || 0;
                } else if(eCode === 2004) {
                    var iLine = pErrorInfo.grammarLine;
                    pLocation.file = "GRAMMAR";
                    pLocation.line = iLine || 0;
                } else if(eCode === 2005) {
                    var iLine = pErrorInfo.grammarLine;
                    var sBadKeyword = pErrorInfo.badKeyword;
                    pInfo.badKeyword = sBadKeyword;
                    pLocation.file = "GRAMMAR";
                    pLocation.line = iLine || 0;
                }
                akra.logger["error"](pLogEntity);
                throw new Error(eCode.toString());
            };
            Parser.prototype.clearMem = function /** @no-inline */() {
                delete this._pFirstTerminalsDMap;
                delete this._pFollowTerminalsDMap;
                delete this._pRulesDMap;
                delete this._pStateList;
                delete this._pReduceOperationsMap;
                delete this._pShiftOperationsMap;
                delete this._pSuccessOperation;
                delete this._pStatesTempMap;
                delete this._pBaseItemList;
                delete this._pExpectedExtensionDMap;
            };
            Parser.prototype.hasState = function /** @no-inline */(pState, eType) {
                var pStateList = this._pStateList;
                var i = 0;
                for(i = 0; i < pStateList.length; i++) {
                    if(pStateList[i].isEqual(pState, eType)) {
                        return pStateList[i];
                    }
                }
                return null;
            };
            Parser.prototype.isTerminal = function /** @no-inline */(sSymbol) {
                return !(this._pRulesDMap[sSymbol]);
            };
            Parser.prototype.pushState = function /** @no-inline */(pState) {
                pState.index = this._pStateList.length;
                this._pStateList.push(pState);
            };
            Parser.prototype.pushBaseItem = function /** @no-inline */(pItem) {
                pItem.index = this._pBaseItemList.length;
                this._pBaseItemList.push(pItem);
            };
            Parser.prototype.tryAddState = function /** @no-inline */(pState, eType) {
                var pRes = this.hasState(pState, eType);
                if(akra.isNull(pRes)) {
                    if(eType === 0 /* k_LR0 */ ) {
                        var pItems = pState.items;
                        for(var i = 0; i < pItems.length; i++) {
                            this.pushBaseItem(pItems[i]);
                        }
                    }
                    this.pushState(pState);
                    this.closure(pState, eType);
                    return pState;
                }
                return pRes;
            };
            Parser.prototype.hasEmptyRule = function /** @no-inline */(sSymbol) {
                if(this.isTerminal(sSymbol)) {
                    return false;
                }
                var pRulesDMap = this._pRulesDMap;
                for(var i in pRulesDMap[sSymbol]) {
                    if(pRulesDMap[sSymbol][i].right.length === 0) {
                        return true;
                    }
                }
                return false;
            };
            Parser.prototype.pushInSyntaxTable = function /** @no-inline */(iIndex, sSymbol, pOperation) {
                var pSyntaxTable = this._pSyntaxTable;
                if(!pSyntaxTable[iIndex]) {
                    pSyntaxTable[iIndex] = {
                    };
                }
                if(akra.isDef(pSyntaxTable[iIndex][sSymbol])) {
                    this._error(2001, {
                        stateIndex: iIndex,
                        grammarSymbol: this.convertGrammarSymbol(sSymbol),
                        oldOperation: this._pSyntaxTable[iIndex][sSymbol],
                        newOperation: pOperation
                    });
                }
                pSyntaxTable[iIndex][sSymbol] = pOperation;
            };
            Parser.prototype.addStateLink = function /** @no-inline */(pState, pNextState, sSymbol) {
                var isAddState = pState.addNextState(sSymbol, pNextState);
                if(!isAddState) {
                    this._error(2002, {
                        stateIndex: pState.index,
                        oldNextStateIndex: pState.getNextStateBySymbol(sSymbol),
                        newNextStateIndex: pNextState.index,
                        grammarSymbol: this.convertGrammarSymbol(sSymbol)
                    });
                }
            };
            Parser.prototype.firstTerminal = function /** @no-inline */(sSymbol) {
                if(this.isTerminal(sSymbol)) {
                    return null;
                }
                if(akra.isDef(this._pFirstTerminalsDMap[sSymbol])) {
                    return this._pFirstTerminalsDMap[sSymbol];
                }
                var i = null, j = 0, k = null;
                var pRulesMap = this._pRulesDMap[sSymbol];
                var pTempRes = {
                };
                var pRes;
                var pRight;
                var isFinish;
                pRes = this._pFirstTerminalsDMap[sSymbol] = {
                };
                if(this.hasEmptyRule(sSymbol)) {
                    pRes["EMPTY"] = true;
                }
                for(i in pRulesMap) {
                    isFinish = false;
                    pRight = pRulesMap[i].right;
                    for(j = 0; j < pRight.length; j++) {
                        if(pRight[j] === sSymbol) {
                            if(pRes["EMPTY"]) {
                                continue;
                            }
                            isFinish = true;
                            break;
                        }
                        pTempRes = this.firstTerminal(pRight[j]);
                        if(akra.isNull(pTempRes)) {
                            pRes[pRight[j]] = true;
                        } else {
                            for(k in pTempRes) {
                                pRes[k] = true;
                            }
                        }
                        if(!this.hasEmptyRule(pRight[j])) {
                            isFinish = true;
                            break;
                        }
                    }
                    if(!isFinish) {
                        pRes["EMPTY"] = true;
                    }
                }
                return pRes;
            };
            Parser.prototype.followTerminal = function /** @no-inline */(sSymbol) {
                if(akra.isDef(this._pFollowTerminalsDMap[sSymbol])) {
                    return this._pFollowTerminalsDMap[sSymbol];
                }
                var i = null, j = null, k = 0, l = 0, m = null;
                var pRulesDMap = this._pRulesDMap;
                var pTempRes;
                var pRes;
                var pRight;
                var isFinish;
                pRes = this._pFollowTerminalsDMap[sSymbol] = {
                };
                for(i in pRulesDMap) {
                    for(j in pRulesDMap[i]) {
                        pRight = pRulesDMap[i][j].right;
                        for(k = 0; k < pRight.length; k++) {
                            if(pRight[k] === sSymbol) {
                                if(k === pRight.length - 1) {
                                    pTempRes = this.followTerminal(pRulesDMap[i][j].left);
                                    for(m in pTempRes) {
                                        pRes[m] = true;
                                    }
                                } else {
                                    isFinish = false;
                                    for(l = k + 1; l < pRight.length; l++) {
                                        pTempRes = this.firstTerminal(pRight[l]);
                                        if(akra.isNull(pTempRes)) {
                                            pRes[pRight[l]] = true;
                                            isFinish = true;
                                            break;
                                        } else {
                                            for(m in pTempRes) {
                                                pRes[m] = true;
                                            }
                                        }
                                        if(!pTempRes["EMPTY"]) {
                                            isFinish = true;
                                            break;
                                        }
                                    }
                                    if(!isFinish) {
                                        pTempRes = this.followTerminal(pRulesDMap[i][j].left);
                                        for(m in pTempRes) {
                                            pRes[m] = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return pRes;
            };
            Parser.prototype.firstTerminalForSet = function /** @no-inline */(pSet, pExpected) {
                var i = 0, j = null;
                var pTempRes;
                var pRes = {
                };
                var isEmpty;
                for(i = 0; i < pSet.length; i++) {
                    pTempRes = this.firstTerminal(pSet[i]);
                    if(akra.isNull(pTempRes)) {
                        pRes[pSet[i]] = true;
                    }
                    isEmpty = false;
                    for(j in pTempRes) {
                        if(j === "EMPTY") {
                            isEmpty = true;
                            continue;
                        }
                        pRes[j] = true;
                    }
                    if(!isEmpty) {
                        return pRes;
                    }
                }
                for(j in pExpected) {
                    pRes[j] = true;
                }
                return pRes;
            };
            Parser.prototype.generateRules = function /** @no-inline */(sGrammarSource) {
                var pAllRuleList = sGrammarSource.split(/\r?\n/);
                var pTempRule;
                var pRule;
                var isLexerBlock = false;
                this._pRulesDMap = {
                };
                this._pAdditionalFuncInfoList = [];
                this._pRuleCreationModeMap = {
                };
                this._pGrammarSymbols = {
                };
                var i = 0, j = 0;
                var isAllNodeMode = akra.bf.testAll(this._eParseMode, 1 /* k_AllNode */ );
                var isNegateMode = akra.bf.testAll(this._eParseMode, 2 /* k_Negate */ );
                var isAddMode = akra.bf.testAll(this._eParseMode, 4 /* k_Add */ );
                var pSymbolsWithNodeMap = this._pRuleCreationModeMap;
                for(i = 0; i < pAllRuleList.length; i++) {
                    if(pAllRuleList[i] === "" || pAllRuleList[i] === "\r") {
                        continue;
                    }
                    pTempRule = pAllRuleList[i].split(/\s* \s*/);
                    if(isLexerBlock) {
                        if((pTempRule.length === 3 || (pTempRule.length === 4 && pTempRule[3] === "")) && ((pTempRule[2][0] === "\"" || pTempRule[2][0] === "'") && pTempRule[2].length > 3)) {
                            //TERMINALS
                            if(pTempRule[2][0] !== pTempRule[2][pTempRule[2].length - 1]) {
                                this._error(2003, {
                                    unexpectedSymbol: pTempRule[2][pTempRule[2].length - 1],
                                    expectedSymbol: pTempRule[2][0],
                                    grammarLine: i
                                });
                            }
                            pTempRule[2] = pTempRule[2].slice(1, pTempRule[2].length - 1);
                            var ch = pTempRule[2][0];
                            var sName;
                            if((ch === "_") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
                                sName = this._pLexer.addKeyword(pTempRule[2], pTempRule[0]);
                            } else {
                                sName = this._pLexer.addPunctuator(pTempRule[2], pTempRule[0]);
                            }
                            this._pGrammarSymbols[sName] = pTempRule[2];
                        }
                        continue;
                    }
                    if(pTempRule[0] === "--LEXER--") {
                        isLexerBlock = true;
                        continue;
                    }
                    //NON TERMNINAL RULES
                    if(akra.isDef(this._pRulesDMap[pTempRule[0]]) === false) {
                        this._pRulesDMap[pTempRule[0]] = {
                        };
                    }
                    pRule = {
                        left: pTempRule[0],
                        right: [],
                        index: 0
                    };
                    this._pSymbolMap[pTempRule[0]] = true;
                    this._pGrammarSymbols[pTempRule[0]] = pTempRule[0];
                    if(isAllNodeMode) {
                        pSymbolsWithNodeMap[pTempRule[0]] = 0 /* k_Default */ ;
                    } else if(isNegateMode && !akra.isDef(pSymbolsWithNodeMap[pTempRule[0]])) {
                        pSymbolsWithNodeMap[pTempRule[0]] = 0 /* k_Default */ ;
                    } else if(isAddMode && !akra.isDef(pSymbolsWithNodeMap[pTempRule[0]])) {
                        pSymbolsWithNodeMap[pTempRule[0]] = 2 /* k_Not */ ;
                    }
                    for(j = 2; j < pTempRule.length; j++) {
                        if(pTempRule[j] === "") {
                            continue;
                        }
                        if(pTempRule[j] === "--AN") {
                            if(isAddMode) {
                                pSymbolsWithNodeMap[pTempRule[0]] = 1 /* k_Necessary */ ;
                            }
                            continue;
                        }
                        if(pTempRule[j] === "--NN") {
                            if(isNegateMode && !isAllNodeMode) {
                                pSymbolsWithNodeMap[pTempRule[0]] = 2 /* k_Not */ ;
                            }
                            continue;
                        }
                        if(pTempRule[j] === "--F") {
                            if((!pTempRule[j + 1] || pTempRule[j + 1].length === 0)) {
                                this._error(2004, {
                                    grammarLine: i
                                });
                            }
                            var pFuncInfo = {
                                name: pTempRule[j + 1],
                                position: pRule.right.length,
                                rule: pRule
                            };
                            this._pAdditionalFuncInfoList.push(pFuncInfo);
                            j++;
                            continue;
                        }
                        if(pTempRule[j][0] === "'" || pTempRule[j][0] === "\"") {
                            if(pTempRule[j].length !== 3) {
                                this._error(2005, {
                                    badKeyword: pTempRule[j],
                                    grammarLine: i
                                });
                            }
                            if(pTempRule[j][0] !== pTempRule[j][2]) {
                                this._error(2003, {
                                    unexpectedSymbol: pTempRule[j][2],
                                    expectedSymbol: pTempRule[j][0],
                                    grammarLine: i
                                });
                                //this._error("Can`t generate rules from grammar! Unexpected symbol! Must be");
                                                            }
                            var sName = this._pLexer.addPunctuator(pTempRule[j][1]);
                            pRule.right.push(sName);
                            this._pSymbolMap[sName] = true;
                        } else {
                            pRule.right.push(pTempRule[j]);
                            this._pSymbolMap[pTempRule[j]] = true;
                        }
                    }
                    pRule.index = this._nRules;
                    this._pRulesDMap[pTempRule[0]][pRule.index] = pRule;
                    this._nRules += 1;
                }
            };
            Parser.prototype.generateFunctionByStateMap = function /** @no-inline */() {
                if(akra.isNull(this._pAdditionalFunctionsMap)) {
                    return;
                }
                var pStateList = this._pStateList;
                var pFuncInfoList = this._pAdditionalFuncInfoList;
                var pFuncInfo;
                var pRule;
                var iPos = 0;
                var pFunc;
                var sGrammarSymbol;
                var i = 0, j = 0;
                var pFuncByStateDMap = {
                };
                pFuncByStateDMap = this._pAdidtionalFunctByStateDMap = {
                };
                for(i = 0; i < pFuncInfoList.length; i++) {
                    pFuncInfo = pFuncInfoList[i];
                    pFunc = this._pAdditionalFunctionsMap[pFuncInfo.name];
                    if(!akra.isDef(pFunc)) {
                        continue;
                    }
                    pRule = pFuncInfo.rule;
                    iPos = pFuncInfo.position;
                    sGrammarSymbol = pRule.right[iPos - 1];
                    for(j = 0; j < pStateList.length; j++) {
                        if(pStateList[j].hasRule(pRule, iPos)) {
                            if(!akra.isDef(pFuncByStateDMap[pStateList[j].index])) {
                                pFuncByStateDMap[pStateList[j].index] = {
                                };
                            }
                            pFuncByStateDMap[pStateList[j].index][sGrammarSymbol] = pFunc;
                        }
                    }
                }
            };
            Parser.prototype.generateFirstState = function /** @no-inline */(eType) {
                if(eType === 0 /* k_LR0 */ ) {
                    this.generateFirstState_LR0();
                } else {
                    this.generateFirstState_LR();
                }
            };
            Parser.prototype.generateFirstState_LR0 = function /** @no-inline */() {
                var pState = new State();
                var pItem = new Item(this._pRulesDMap["S"][0], 0);
                this.pushBaseItem(pItem);
                pState.push(pItem);
                this.closure_LR0(pState);
                this.pushState(pState);
            };
            Parser.prototype.generateFirstState_LR = function /** @no-inline */() {
                var pState = new State();
                var pExpected = {
                };
                pExpected["$"] = true;
                pState.push(new Item(this._pRulesDMap["S"][0], 0, pExpected));
                this.closure_LR(pState);
                this.pushState(pState);
            };
            Parser.prototype.closure = function /** @no-inline */(pState, eType) {
                if(eType === 0 /* k_LR0 */ ) {
                    return this.closure_LR0(pState);
                } else {
                    this.closure_LR(pState);
                }
            };
            Parser.prototype.closure_LR0 = function /** @no-inline */(pState) {
                var pItemList = pState.items;
                var i = 0, j = null;
                var sSymbol;
                for(i = 0; i < pItemList.length; i++) {
                    sSymbol = pItemList[i].mark();
                    if(sSymbol !== "END" && (!this.isTerminal(sSymbol))) {
                        for(j in this._pRulesDMap[sSymbol]) {
                            pState.tryPush_LR0(this._pRulesDMap[sSymbol][j], 0);
                        }
                    }
                }
                return pState;
            };
            Parser.prototype.closure_LR = function /** @no-inline */(pState) {
                var pItemList = (pState.items);
                var i = 0, j = null, k = null;
                var sSymbol;
                var pSymbols;
                var pTempSet;
                var isNewExpected = false;
                while(true) {
                    if(i === pItemList.length) {
                        if(!isNewExpected) {
                            break;
                        }
                        i = 0;
                        isNewExpected = false;
                    }
                    sSymbol = pItemList[i].mark();
                    if(sSymbol !== "END" && (!this.isTerminal(sSymbol))) {
                        pTempSet = pItemList[i].rule.right.slice(pItemList[i].position + 1);
                        pSymbols = this.firstTerminalForSet(pTempSet, pItemList[i].expectedSymbols);
                        for(j in this._pRulesDMap[sSymbol]) {
                            for(k in pSymbols) {
                                if(pState.tryPush_LR(this._pRulesDMap[sSymbol][j], 0, k)) {
                                    isNewExpected = true;
                                }
                            }
                        }
                    }
                    i++;
                }
                return pState;
            };
            Parser.prototype.nexeState = function /** @no-inline */(pState, sSymbol, eType) {
                if(eType === 0 /* k_LR0 */ ) {
                    return this.nextState_LR0(pState, sSymbol);
                } else {
                    return this.nextState_LR(pState, sSymbol);
                }
            };
            Parser.prototype.nextState_LR0 = function /** @no-inline */(pState, sSymbol) {
                var pItemList = pState.items;
                var i = 0;
                var pNewState = new State();
                for(i = 0; i < pItemList.length; i++) {
                    if(sSymbol === pItemList[i].mark()) {
                        pNewState.push(new Item(pItemList[i].rule, pItemList[i].position + 1));
                    }
                }
                return pNewState;
            };
            Parser.prototype.nextState_LR = function /** @no-inline */(pState, sSymbol) {
                var pItemList = pState.items;
                var i = 0;
                var pNewState = new State();
                for(i = 0; i < pItemList.length; i++) {
                    if(sSymbol === pItemList[i].mark()) {
                        pNewState.push(new Item(pItemList[i].rule, pItemList[i].position + 1, pItemList[i].expectedSymbols));
                    }
                }
                return pNewState;
            };
            Parser.prototype.deleteNotBaseItems = function /** @no-inline */() {
                var i = 0;
                for(i = 0; i < this._pStateList.length; i++) {
                    this._pStateList[i].deleteNotBase();
                }
            };
            Parser.prototype.closureForItem = function /** @no-inline */(pRule, iPos) {
                var sIndex = "";
                sIndex += pRule.index + "_" + iPos;
                var pState = this._pStatesTempMap[sIndex];
                if(akra.isDef(pState)) {
                    return pState;
                } else {
                    var pExpected = {
                    };
                    pExpected["##"] = true;
                    pState = new State();
                    pState.push(new Item(pRule, iPos, pExpected));
                    this.closure_LR(pState);
                    this._pStatesTempMap[sIndex] = pState;
                    return pState;
                }
            };
            Parser.prototype.addLinkExpected = function /** @no-inline */(pItem, pItemX) {
                var pTable = this._pExpectedExtensionDMap;
                var iIndex = pItem.index;
                if(!akra.isDef(pTable[iIndex])) {
                    pTable[iIndex] = {
                    };
                }
                pTable[iIndex][pItemX.index] = true;
            };
            Parser.prototype.determineExpected = function /** @no-inline */(pTestState, sSymbol) {
                var pStateX = pTestState.getNextStateBySymbol(sSymbol);
                if(akra.isNull(pStateX)) {
                    return;
                }
                var pItemListX = pStateX.items;
                var pItemList = pTestState.items;
                var pState;
                var pItem;
                var i = 0, j = 0, k = null;
                var nBaseItemTest = pTestState.numBaseItems;
                var nBaseItemX = pStateX.numBaseItems;
                for(i = 0; i < nBaseItemTest; i++) {
                    pState = this.closureForItem(pItemList[i].rule, pItemList[i].position);
                    for(j = 0; j < nBaseItemX; j++) {
                        pItem = pState.hasChildItem(pItemListX[j]);
                        if(pItem) {
                            var pExpected = pItem.expectedSymbols;
                            for(k in pExpected) {
                                if(k === "##") {
                                    this.addLinkExpected(pItemList[i], pItemListX[j]);
                                } else {
                                    pItemListX[j].addExpected(k);
                                }
                            }
                        }
                    }
                }
            };
            Parser.prototype.generateLinksExpected = function /** @no-inline */() {
                var i = 0, j = null;
                var pStates = this._pStateList;
                for(i = 0; i < pStates.length; i++) {
                    for(j in this._pSymbolMap) {
                        this.determineExpected(pStates[i], j);
                    }
                }
            };
            Parser.prototype.expandExpected = function /** @no-inline */() {
                var pItemList = this._pBaseItemList;
                var pTable = this._pExpectedExtensionDMap;
                var i = 0, j = null;
                var sSymbol = null;
                var isNewExpected = false;
                pItemList[0].addExpected("$");
                pItemList[0].isNewExpected = true;
                while(true) {
                    if(i === pItemList.length) {
                        if(!isNewExpected) {
                            break;
                        }
                        isNewExpected = false;
                        i = 0;
                    }
                    if(pItemList[i].isNewExpected) {
                        var pExpected = pItemList[i].expectedSymbols;
                        for(sSymbol in pExpected) {
                            for(j in pTable[i]) {
                                if(pItemList[j].addExpected(sSymbol)) {
                                    isNewExpected = true;
                                }
                            }
                        }
                    }
                    pItemList[i].isNewExpected = false;
                    i++;
                }
            };
            Parser.prototype.generateStates = function /** @no-inline */(eType) {
                if(eType === 0 /* k_LR0 */ ) {
                    this.generateStates_LR0();
                } else if(eType === 1 /* k_LR1 */ ) {
                    this.generateStates_LR();
                } else if(eType === 2 /* k_LALR */ ) {
                    this.generateStates_LALR();
                }
            };
            Parser.prototype.generateStates_LR0 = function /** @no-inline */() {
                this.generateFirstState_LR0();
                var i = 0;
                var pStateList = this._pStateList;
                var sSymbol = null;
                var pState;
                for(i = 0; i < pStateList.length; i++) {
                    for(sSymbol in this._pSymbolMap) {
                        pState = this.nextState_LR0(pStateList[i], sSymbol);
                        if(!pState.isEmpty()) {
                            pState = this.tryAddState(pState, 0 /* k_LR0 */ );
                            this.addStateLink(pStateList[i], pState, sSymbol);
                        }
                    }
                }
            };
            Parser.prototype.generateStates_LR = function /** @no-inline */() {
                this._pFirstTerminalsDMap = {
                };
                this.generateFirstState_LR();
                var i = 0;
                var pStateList = this._pStateList;
                var sSymbol = null;
                var pState;
                for(i = 0; i < pStateList.length; i++) {
                    for(sSymbol in this._pSymbolMap) {
                        pState = this.nextState_LR(pStateList[i], sSymbol);
                        if(!pState.isEmpty()) {
                            pState = this.tryAddState(pState, 1 /* k_LR1 */ );
                            this.addStateLink(pStateList[i], pState, sSymbol);
                        }
                    }
                }
            };
            Parser.prototype.generateStates_LALR = function /** @no-inline */() {
                this._pStatesTempMap = {
                };
                this._pBaseItemList = [];
                this._pExpectedExtensionDMap = {
                };
                this._pFirstTerminalsDMap = {
                };
                this.generateStates_LR0();
                this.deleteNotBaseItems();
                this.generateLinksExpected();
                this.expandExpected();
                var i = 0;
                var pStateList = this._pStateList;
                for(i = 0; i < pStateList.length; i++) {
                    this.closure_LR(pStateList[i]);
                }
            };
            Parser.prototype.calcBaseItem = function /** @no-inline */() {
                var num = 0;
                var i = 0;
                for(i = 0; i < this._pStateList.length; i++) {
                    num += this._pStateList[i].numBaseItems;
                }
                return num;
            };
            Parser.prototype.printExpectedTable = function /** @no-inline */() {
                var i = null, j = null;
                var sMsg = "";
                for(i in this._pExpectedExtensionDMap) {
                    sMsg += "State " + this._pBaseItemList[i].state.index + ":   ";
                    sMsg += this._pBaseItemList[i].toString() + "  |----->\n";
                    for(j in this._pExpectedExtensionDMap[i]) {
                        sMsg += "\t\t\t\t\t" + "State " + this._pBaseItemList[j].state.index + ":   ";
                        sMsg += this._pBaseItemList[j].toString() + "\n";
                    }
                    sMsg += "\n";
                }
                return sMsg;
            };
            Parser.prototype.addReducing = function /** @no-inline */(pState) {
                var i = 0, j = null;
                var pItemList = pState.items;
                for(i = 0; i < pItemList.length; i++) {
                    if(pItemList[i].mark() === "END") {
                        if(pItemList[i].rule.left === "S") {
                            this.pushInSyntaxTable(pState.index, "$", this._pSuccessOperation);
                        } else {
                            var pExpected = pItemList[i].expectedSymbols;
                            for(j in pExpected) {
                                this.pushInSyntaxTable(pState.index, j, this._pReduceOperationsMap[pItemList[i].rule.index]);
                            }
                        }
                    }
                }
            };
            Parser.prototype.addShift = function /** @no-inline */(pState) {
                var i = null;
                var pStateMap = pState.nextStates;
                for(i in pStateMap) {
                    this.pushInSyntaxTable(pState.index, i, this._pShiftOperationsMap[pStateMap[i].index]);
                }
            };
            Parser.prototype.buildSyntaxTable = function /** @no-inline */() {
                this._pStateList = [];
                var pStateList = this._pStateList;
                var pState;
                //Generate states
                this.generateStates(this._eType);
                //Init necessary properties
                this._pSyntaxTable = {
                };
                this._pReduceOperationsMap = {
                };
                this._pShiftOperationsMap = {
                };
                this._pSuccessOperation = {
                    type: 103 /* k_Success */ 
                };
                var i = 0, j = null, k = null;
                for(i = 0; i < pStateList.length; i++) {
                    this._pShiftOperationsMap[pStateList[i].index] = {
                        type: 101 /* k_Shift */ ,
                        index: pStateList[i].index
                    };
                }
                for(j in this._pRulesDMap) {
                    for(k in this._pRulesDMap[j]) {
                        this._pReduceOperationsMap[k] = {
                            type: 102 /* k_Reduce */ ,
                            rule: this._pRulesDMap[j][k]
                        };
                    }
                }
                //Build syntax table
                for(var i = 0; i < pStateList.length; i++) {
                    pState = pStateList[i];
                    this.addReducing(pState);
                    this.addShift(pState);
                }
            };
            Parser.prototype.readToken = function /** @no-inline */() {
                return this._pLexer.getNextToken();
            };
            Parser.prototype.operationAdditionalAction = function /** @no-inline */(iStateIndex, sGrammarSymbol) {
                var pFuncDMap = this._pAdidtionalFunctByStateDMap;
                if(!akra.isNull(this._pAdidtionalFunctByStateDMap) && akra.isDef(pFuncDMap[iStateIndex]) && akra.isDef(pFuncDMap[iStateIndex][sGrammarSymbol])) {
                    return pFuncDMap[iStateIndex][sGrammarSymbol].call(this);
                }
                return 105 /* k_Ok */ ;
            };
            Parser.prototype.resumeParse = function /** @no-inline */() {
                try  {
                    var pTree = this._pSyntaxTree;
                    var pStack = this._pStack;
                    var pSyntaxTable = this._pSyntaxTable;
                    var isStop = false;
                    var isError = false;
                    var isPause = false;
                    var pToken = akra.isNull(this._pToken) ? this.readToken() : this._pToken;
                    var pOperation;
                    var iRuleLength;
                    var eAdditionalOperationCode;
                    var iStateIndex = 0;
                    while(!isStop) {
                        pOperation = pSyntaxTable[pStack[pStack.length - 1]][pToken.name];
                        if(akra.isDef(pOperation)) {
                            switch(pOperation.type) {
                                case 103 /* k_Success */ :
                                    isStop = true;
                                    break;
                                case 101 /* k_Shift */ :
                                    iStateIndex = pOperation.index;
                                    pStack.push(iStateIndex);
                                    pTree.addNode(pToken);
                                    eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pToken.name);
                                    if(eAdditionalOperationCode === 100 /* k_Error */ ) {
                                        isError = true;
                                        isStop = true;
                                    } else if(eAdditionalOperationCode === 104 /* k_Pause */ ) {
                                        this._pToken = null;
                                        isStop = true;
                                        isPause = true;
                                    } else if(eAdditionalOperationCode === 105 /* k_Ok */ ) {
                                        pToken = this.readToken();
                                    }
                                    break;
                                case 102 /* k_Reduce */ :
                                    iRuleLength = pOperation.rule.right.length;
                                    pStack.length -= iRuleLength;
                                    iStateIndex = pSyntaxTable[pStack[pStack.length - 1]][pOperation.rule.left].index;
                                    pStack.push(iStateIndex);
                                    pTree.reduceByRule(pOperation.rule, this._pRuleCreationModeMap[pOperation.rule.left]);
                                    eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pOperation.rule.left);
                                    if(eAdditionalOperationCode === 100 /* k_Error */ ) {
                                        isError = true;
                                        isStop = true;
                                    } else if(eAdditionalOperationCode === 104 /* k_Pause */ ) {
                                        this._pToken = pToken;
                                        isStop = true;
                                        isPause = true;
                                    }
                                    break;
                            }
                        } else {
                            isError = true;
                            isStop = true;
                        }
                    }
                    if(isPause) {
                        return 0 /* k_Pause */ ;
                    }
                    if(!isError) {
                        pTree.setRoot();
                        this._sFileName = "stdin";
                        if(akra.isDef(this._fnFinishCallback)) {
                            this._fnFinishCallback.call(this._pCaller, 1 /* k_Ok */ , this.getParseFileName());
                        }
                        return 1 /* k_Ok */ ;
                    } else {
                        this._error(2051, pToken);
                        this._sFileName = "stdin";
                        if(akra.isDef(this._fnFinishCallback)) {
                            this._fnFinishCallback.call(this._pCaller, 2 /* k_Error */ , this.getParseFileName());
                        }
                        return 2 /* k_Error */ ;
                    }
                } catch (e) {
                    this._sFileName = "stdin";
                    return 2 /* k_Error */ ;
                }
            };
            Parser.prototype.statesToString = function /** @no-inline */(isBaseOnly) {
                if (typeof isBaseOnly === "undefined") { isBaseOnly = true; }
                if(!akra.isDef(this._pStateList)) {
                    return null;
                }
                var sMsg = "";
                var i = 0;
                for(i = 0; i < this._pStateList.length; i++) {
                    sMsg += this._pStateList[i].toString(isBaseOnly);
                    sMsg += " ";
                }
                return sMsg;
            };
            Parser.prototype.operationToString = function /** @no-inline */(pOperation) {
                var sOperation = null;
                switch(pOperation.type) {
                    case 101 /* k_Shift */ :
                        sOperation = "SHIFT to state " + pOperation.index.toString();
                        break;
                    case 102 /* k_Reduce */ :
                        sOperation = "REDUCE by rule { " + this.ruleToString(pOperation.rule) + " }";
                        break;
                    case 103 /* k_Success */ :
                        sOperation = "SUCCESS";
                        break;
                }
                return sOperation;
            };
            Parser.prototype.ruleToString = function /** @no-inline */(pRule) {
                var sRule;
                sRule = pRule.left + " : " + pRule.right.join(" ");
                return sRule;
            };
            Parser.prototype.convertGrammarSymbol = function /** @no-inline */(sSymbol) {
                if(!this.isTerminal(sSymbol)) {
                    return sSymbol;
                } else {
                    return this._pLexer.getTerminalValueByName(sSymbol);
                }
            };
            return Parser;
        })();
        util.Parser = Parser;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var EffectParser = (function (_super) {
            __extends(EffectParser, _super);
            function /** @no-inline */EffectParser() {
                        _super.call(this);
                this._pIncludedFilesMap = null;
                this.addAdditionalFunction("addType", this._addType);
                this.addAdditionalFunction("includeCode", this._includeCode);
            }
            EffectParser.prototype.defaultInit = /**@protected*/ function /** @no-inline */() {
                _super.prototype.defaultInit.call(this);
                this.addTypeId("float2");
                this.addTypeId("float3");
                this.addTypeId("float4");
                this.addTypeId("float2x2");
                this.addTypeId("float3x3");
                this.addTypeId("float4x4");
                this.addTypeId("int2");
                this.addTypeId("int3");
                this.addTypeId("int4");
                this.addTypeId("bool2");
                this.addTypeId("bool3");
                this.addTypeId("bool4");
                this._pIncludedFilesMap = {
                };
                this._pIncludedFilesMap[this.getParseFileName()] = true;
            };
            EffectParser.prototype._addIncludedFile = function /** @no-inline */(sFileName) {
                this._pIncludedFilesMap[sFileName] = true;
            };
            EffectParser.prototype._addType = function /** @no-inline */() {
                var pTree = this.getSyntaxTree();
                var pNode = pTree.getLastNode();
                var sTypeId;
                sTypeId = pNode.children[pNode.children.length - 2].value;
                this.addTypeId(sTypeId);
                return 105 /* k_Ok */ ;
            };
            EffectParser.prototype._includeCode = function /** @no-inline */() {
                var pTree = this.getSyntaxTree();
                var pNode = pTree.getLastNode();
                var sFile = pNode.value;
                sFile = sFile.substr(1, sFile.length - 2);
                if(this._pIncludedFilesMap[sFile]) {
                    return 105 /* k_Ok */ ;
                } else {
                    var pParserState = this._saveState();
                    var me = this;
                    var pFile = akra.io.fopen(sFile, "r+t");
                    pFile.read(function /** @no-inline */(err, sData) {
                        if(err) {
                            util.logger.setSourceLocation("util/EffectParser.ts", 75);
                            util.logger.error("Can not read file");
                            ;
                        } else {
                            pParserState.source = pParserState.source.substr(0, pParserState.index) + sData + pParserState.source.substr(pParserState.index);
                            me._loadState(pParserState);
                            me._addIncludedFile(sFile);
                            me.resume();
                        }
                    });
                    return 104 /* k_Pause */ ;
                }
            };
            return EffectParser;
        })(util.Parser);
        util.EffectParser = EffectParser;        
        util.parser = new EffectParser();
        function /** @no-inline */initAFXParser(sGrammar) {
            util.parser.init(sGrammar, 4 /* k_Add */  | 2 /* k_Negate */  | 8 /* k_Optimize */  | 16 /* k_DebugMode */ );
        }
        util.initAFXParser = initAFXParser;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var EffectData = (function (_super) {
                    __extends(EffectData, _super);
                    function EffectData() {
                        _super.apply(this, arguments);

                        this._pSyntaxTree = null;
                    }
                    EffectData.prototype.loadResource = function /** @no-inline */(sFileName) {
                        var reExt = /^(.+)(\.afx|\.abf|\.fx)$/;
                        var pRes = reExt.exec(sFileName);
                        if(akra.isNull(pRes)) {
                            akra.logger.setSourceLocation("resources/EffectData.ts", 23);
                            akra.logger.error("Bad effect file extension. Only .afx, .fx, .abf are available");
                            ;
                            return;
                        }
                        var isBinary = pRes[pRes.length - 1] === ".abf";
                        var pComposer = this.getManager().getEngine().getComposer();
                        if(isBinary) {
                            var pFile = akra.io.fopen(sFileName, "r+b");
                            pFile.read(function /** @no-inline */(err, pData) {
                                if(err) {
                                    akra.logger.setSourceLocation("resources/EffectData.ts", 38);
                                    akra.logger.error("Can not read file");
                                    ;
                                } else {
                                    me._initFromBinaryData(pData, sFileName);
                                }
                            });
                        }
                        var me = this;
                        akra.io.fopen(sFileName, "r+t").read(function /** @no-inline */(pErr, sData) {
                            if(!akra.isNull(pErr)) {
                                akra.logger.setSourceLocation("resources/EffectData.ts", 48);
                                akra.logger.error("Can not load .afx file: '" + sFileName + "'");
                                ;
                            } else {
                                akra.util.parser.setParseFileName(sFileName);
                                if(sFileName === "../../../data/effects/prepareDeferredShading.afx") {
                                    akra.logger.setSourceLocation("resources/EffectData.ts", 54);
                                    akra.logger.log(sFileName);
                                    ;
                                }
                                akra.util.parser.parse(sData, me._initFromParsedEffect, me);
                            }
                        });
                        return true;
                    };
                    EffectData.prototype._initFromParsedEffect = function /** @no-inline */(eCode, sFileName) {
                        if(eCode === 2 /* k_Error */ ) {
                            return;
                        }
                        this._pSyntaxTree = akra.util.parser.getSyntaxTree();
                        this.notifyLoaded();
                        var pComposer = this.getManager().getEngine().getComposer();
                        pComposer._loadEffectFromSyntaxTree(this._pSyntaxTree, sFileName);
                    };
                    EffectData.prototype._initFromBinaryData = function /** @no-inline */(pData, sFileName) {
                        // var pComposer: IAFXComposer = this.getManager().getEngine().getComposer();
                        // pComposer._loadEffectFromBinary(this._pSyntaxTree, sFileName);
                                            };
                    return EffectData;
                })(pool.ResourcePoolItem);
                resources.EffectData = EffectData;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            /*
            -----------------------------------------------------------------------------
            This source file is part of OGRE
            (Object-oriented Graphics Rendering Engine)
            For the latest info, see http://www.ogre3d.org/
            
            Copyright (c) 2000-2012 Torus Knot Software Ltd
            -----------------------------------------------------------------------------
            */
            (function (resources) {
                var HardwareBuffer = (function (_super) {
                    __extends(HardwareBuffer, _super);
                    function /** @no-inline */HardwareBuffer() {
                                        _super.call(this);
                        /**@protected*/ this._iFlags = 0;
                        /**@protected*/ this._isLocked = false;
                        /**@protected*/ this._pBackupCopy = null;
                        /**@protected*/ this._pBackupUpdated = false;
                        /**@protected*/ this._bIgnoreHardwareUpdate = false;
                        this.byteLength = 0;
                        this.length = 0;
                    }
                    HardwareBuffer.prototype.isValid = function /** @inline */() {
                        return false;
                    };
                    HardwareBuffer.prototype.isDynamic = function /** @inline */() {
                        return (((this._iFlags) & (2 /* DYNAMIC */ )) != 0);
                    };
                    HardwareBuffer.prototype.isStatic = function /** @inline */() {
                        return (((this._iFlags) & (1 /* STATIC */ )) != 0);
                    };
                    HardwareBuffer.prototype.isStream = function /** @inline */() {
                        return (((this._iFlags) & (128 /* STREAM */ )) != 0);
                    };
                    HardwareBuffer.prototype.isReadable = function /** @inline */() {
                        return (((this._iFlags) & (4 /* READABLE */ )) != 0);
                    };
                    HardwareBuffer.prototype.isBackupPresent = function /** @inline */() {
                        return this._pBackupCopy != null;
                    };
                    HardwareBuffer.prototype.isSoftware = function /** @inline */() {
                        return (((this._iFlags) & (16 /* SOFTWARE */ )) != 0);
                    };
                    HardwareBuffer.prototype.isAligned = function /** @inline */() {
                        return (((this._iFlags) & (32 /* ALIGNMENT */ )) != 0);
                    };
                    HardwareBuffer.prototype.isLocked = function /** @inline */() {
                        return this._isLocked;
                    };
                    HardwareBuffer.prototype.clone = function /** @no-inline */(pSrc) {
                        return false;
                    };
                    HardwareBuffer.prototype.getFlags = function /** @inline */() {
                        return this._iFlags;
                    };
                    HardwareBuffer.prototype.readData = function /** @no-inline */(iOffset, iSize, ppDest) {
                        return false;
                    };
                    HardwareBuffer.prototype.writeData = function /** @no-inline */(pData, iOffset, iSize, bDiscardWholeBuffer) {
                        if (typeof bDiscardWholeBuffer === "undefined") { bDiscardWholeBuffer = false; }
                        return false;
                    };
                    HardwareBuffer.prototype.copyData = function /** @no-inline */(pSrcBuffer, iSrcOffset, iDstOffset, iSize, bDiscardWholeBuffer) {
                        if (typeof bDiscardWholeBuffer === "undefined") { bDiscardWholeBuffer = false; }
                        var pData = pSrcBuffer.lock(iSrcOffset, iSize);
                        this.writeData(pData, iDstOffset, iSize, bDiscardWholeBuffer);
                        pSrcBuffer.unlock();
                        return true;
                    };
                    HardwareBuffer.prototype.create = function /** @no-inline */(iFlags) {
                        iFlags |= 1 /* STATIC */ ;
                        if((((iFlags) & (2 /* DYNAMIC */ )) != 0)) {
                            ((iFlags) &= ~(1 /* STATIC */ ));
                            if((((iFlags) & (8 /* BACKUP_COPY */ )) != 0)) {
                                ((iFlags) &= ~(4 /* READABLE */ ));
                            }
                        }
                        this._iFlags = iFlags;
                        this.notifyCreated();
                        this.notifyRestored();
                        return true;
                    };
                    HardwareBuffer.prototype.destroy = function /** @no-inline */() {
                        this._iFlags = 0;
                        this.notifyDestroyed();
                        this.notifyUnloaded();
                    };
                    HardwareBuffer.prototype.resize = function /** @no-inline */(iSize) {
                        return false;
                    };
                    HardwareBuffer.prototype.lock = function /** @no-inline */(iOffset, iSize, iLockFlags) {
                        if (typeof iLockFlags === "undefined") { iLockFlags = 4 /* READABLE */ ; }
                        akra.logger.setSourceLocation("core/pool/resources/HardwareBuffer.ts", 128);
                        akra.logger.assert(!this.isLocked(), "Cannot lock this buffer, it is already locked!");
                        ;
                        if(arguments.length == 1) {
                            iLockFlags = arguments[0];
                            iOffset = 0;
                            iSize = this.byteLength;
                        }
                        var pResult = null;
                        if((iOffset + iSize) > this.byteLength) {
                            akra.logger.setSourceLocation("core/pool/resources/HardwareBuffer.ts", 139);
                            akra.logger.error("Lock request out of bounds.", "HardwareBuffer::lock");
                            ;
                        } else if(this.isBackupPresent()) {
                            if(!(((iLockFlags) & (2 /* WRITE */ )) != 0)) {
                                // we have to assume a read / write lock so we use the shadow buffer
                                // and tag for sync on unlock()
                                this._pBackupUpdated = true;
                            }
                            pResult = this._pBackupCopy.lock(iOffset, iSize, iLockFlags);
                        } else {
                            // Lock the real buffer if there is no shadow buffer
                            pResult = this.lockImpl(iOffset, iSize, iLockFlags);
                            this._isLocked = true;
                        }
                        this._iLockStart = iOffset;
                        this._iLockSize = iSize;
                        return pResult;
                    };
                    HardwareBuffer.prototype.unlock = function /** @no-inline */() {
                        akra.logger.setSourceLocation("core/pool/resources/HardwareBuffer.ts", 163);
                        akra.logger.assert(this.isLocked(), "Cannot unlock this buffer, it is not locked!");
                        ;
                        // If we used the shadow buffer this time...
                        if(this._pBackupCopy && this._pBackupCopy.isLocked()) {
                            this._pBackupCopy.unlock();
                            // Potentially update the 'real' buffer from the shadow buffer
                            this.restoreFromBackup();
                        } else {
                            // Otherwise, unlock the real one
                            this.unlockImpl();
                            this._isLocked = false;
                        }
                    };
                    HardwareBuffer.prototype.restoreFromBackup = function /** @no-inline */() {
                        if(this._pBackupCopy && this._pBackupUpdated && !this._bIgnoreHardwareUpdate) {
                            // Do this manually to avoid locking problems
                            var pBackupData = this._pBackupCopy.lockImpl(this._iLockStart, this._iLockSize, 1 /* READ */ );
                            // Lock with discard if the whole buffer was locked, otherwise normal
                            var iLockFlags;
                            if(this._iLockStart == 0 && this._iLockSize == this.byteLength) {
                                iLockFlags = 4 /* DISCARD */ ;
                            } else {
                                iLockFlags = akra.ELockFlags.NORMAL;
                            }
                            var pRealData = this.lockImpl(this._iLockStart, this._iLockSize, iLockFlags);
                            // Copy backup to real
                            this.copyBackupToRealImpl(pRealData, pBackupData, iLockFlags);
                            this.unlockImpl();
                            this._pBackupCopy.unlockImpl();
                            this._pBackupUpdated = false;
                            return true;
                        }
                        return false;
                    };
                    HardwareBuffer.prototype.createResource = function /** @no-inline */() {
                        // innitialize the resource (called once)
                        akra.logger.setSourceLocation("core/pool/resources/HardwareBuffer.ts", 211);
                        akra.logger.assert(!this.isResourceCreated(), "The resource has already been created.");
                        ;
                        // signal that the resource is now created,
                        // but has not been enabled
                        //this.notifyCreated();
                        this.notifyDisabled();
                        return true;
                    };
                    HardwareBuffer.prototype.destroyResource = function /** @no-inline */() {
                        // destroy the resource
                        //
                        // we permit redundant calls to destroy, so there are no asserts here
                        //
                        if(this.isResourceCreated()) {
                            // disable the resource
                            this.disableResource();
                            this.destroy();
                            return true;
                        }
                        return false;
                    };
                    HardwareBuffer.prototype.restoreResource = function /** @no-inline */() {
                        akra.logger.setSourceLocation("core/pool/resources/HardwareBuffer.ts", 237);
                        akra.logger.assert(this.isResourceCreated(), "The resource has not been created.");
                        ;
                        this.notifyRestored();
                        return true;
                    };
                    HardwareBuffer.prototype.disableResource = function /** @no-inline */() {
                        akra.logger.setSourceLocation("core/pool/resources/HardwareBuffer.ts", 244);
                        akra.logger.assert(this.isResourceCreated(), "The resource has not been created.");
                        ;
                        this.notifyDisabled();
                        return true;
                    };
                    HardwareBuffer.prototype.lockImpl = /**@protected*/ function /** @no-inline */(iOffset, iSize, iLockFlags) {
                        return null;
                    };
                    HardwareBuffer.prototype.unlockImpl = /**@protected*/ function /** @no-inline */() {
                    };
                    HardwareBuffer.prototype.copyBackupToRealImpl = /**@protected*/ function /** @no-inline */(pRealData, pBackupData, iLockFlags) {
                    };
                    return HardwareBuffer;
                })(pool.ResourcePoolItem);
                resources.HardwareBuffer = HardwareBuffer;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLPixelBuffer = (function (_super) {
            __extends(WebGLPixelBuffer, _super);
            function /** @no-inline */WebGLPixelBuffer() {
                        _super.call(this);
                /**@protected*/ this._iWidth = 0;
                /**@protected*/ this._iHeight = 0;
                /**@protected*/ this._iDepth = 0;
                // Pitches (offsets between rows and slices)
                /**@protected*/ this._iRowPitch = 0;
                /**@protected*/ this._iSlicePitch = 0;
                /**@protected*/ this._eFormat = 0 /* UNKNOWN */ ;
                //webgl specific
                /**@protected*/ this._pCurrentLock = null;
                /**@protected*/ this._pLockedBox = null;
                /**@protected*/ this._iCurrentLockFlags = 0;
                /**@protected*/ this._pBuffer = null;
                /**@protected*/ this._iWebGLInternalFormat = 0;
            }
            Object.defineProperty(WebGLPixelBuffer.prototype, "width", {
                get: function /** @inline */() {
                    return this._iWidth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLPixelBuffer.prototype, "height", {
                get: function /** @inline */() {
                    return this._iHeight;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLPixelBuffer.prototype, "depth", {
                get: function /** @inline */() {
                    return this._iDepth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLPixelBuffer.prototype, "format", {
                get: function /** @inline */() {
                    return this._eFormat;
                },
                enumerable: true,
                configurable: true
            });
            WebGLPixelBuffer.prototype.upload = //upload(download) data to(from) videocard.
            /**@protected*/ function /** @no-inline */(pData, pDestBox) {
                akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 46);
                akra.logger.criticalError("Upload not possible for this pixelbuffer type");
                ;
            };
            WebGLPixelBuffer.prototype.download = /**@protected*/ function /** @no-inline */(pData) {
                akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 50);
                akra.logger.criticalError("Download not possible for this pixelbuffer type");
                ;
            };
            WebGLPixelBuffer.prototype._bindToFramebuffer = function /** @no-inline */(pAttachment, iZOffset) {
                akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 54);
                akra.logger.criticalError("Framebuffer bind not possible for this pixelbuffer type");
                ;
            };
            WebGLPixelBuffer.prototype._getWebGLFormat = function /** @no-inline */() {
                return this._iWebGLInternalFormat;
            };
            WebGLPixelBuffer.prototype._clearRTT = function /** @no-inline */(iZOffset) {
            };
            WebGLPixelBuffer.prototype.create = function /** @no-inline */() {
                if(arguments.length === 1) {
                    akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 68);
                    akra.logger.criticalError("Invalid number of arguments. For PixelBuffer it must be six");
                    ;
                }
                var iWidth = arguments[0];
                var iHeight = arguments[1];
                var iDepth = arguments[2];
                var eFormat = arguments[3];
                var iFlags = arguments[4];
                _super.prototype.create.call(this, iFlags);
                this._iWidth = iWidth;
                this._iHeight = iHeight;
                this._iDepth = iDepth;
                this._eFormat = eFormat;
                this._iRowPitch = iWidth;
                this._iSlicePitch = iHeight * iWidth;
                this.byteLength = iHeight * iWidth * akra.pixelUtil.getNumElemBytes(eFormat);
                this._pBuffer = new akra.pixelUtil.PixelBox(iWidth, iHeight, iDepth, eFormat);
                this._iWebGLInternalFormat = 0;
                return true;
            };
            WebGLPixelBuffer.prototype.destroy = function /** @no-inline */() {
                this._pBuffer = null;
                _super.prototype.destroy.call(this);
            };
            WebGLPixelBuffer.prototype.destroyResource = function /** @no-inline */() {
                this.destroy();
                this.notifyDestroyed();
                return true;
            };
            WebGLPixelBuffer.prototype.readData = function /** @no-inline */() {
                akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 108);
                akra.logger.criticalError("Reading a byte range is not implemented. Use blitToMemory.");
                ;
                return false;
            };
            WebGLPixelBuffer.prototype.writeData = function /** @no-inline */() {
                akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 115);
                akra.logger.criticalError("Writing a byte range is not implemented. Use blitFromMemory.");
                ;
                return false;
            };
            WebGLPixelBuffer.prototype.blit = function /** @no-inline */(pSource, pSrcBox, pDestBox) {
                if(arguments.length == 1) {
                    return this.blit(pSource, new akra.geometry.Box(0, 0, 0, pSource.width, pSource.height, pSource.depth), new akra.geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth));
                } else {
                    if(pSource === this) {
                        akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 133);
                        akra.logger.criticalError("Source must not be the same object");
                        ;
                    }
                    /**@const*/ var pSrclock = pSource.lock(pSrcBox, 1 /* READ */ );
                    var eLockMethod = akra.ELockFlags.NORMAL;
                    if(pDestBox.left === 0 && pDestBox.top === 0 && pDestBox.front === 0 && pDestBox.right === this._iWidth && pDestBox.bottom === this._iHeight && pDestBox.back === this._iDepth) {
                        // Entire buffer -- we can discard the previous contents
                        eLockMethod = 4 /* DISCARD */ ;
                    }
                    /**@const*/ var pDstlock = this.lock(pDestBox, eLockMethod);
                    if(pDstlock.width != pSrclock.width || pDstlock.height != pSrclock.height || pDstlock.depth != pSrclock.depth) {
                        // Scaling desired
                        pSrclock.scale(pDstlock);
                    } else {
                        // No scaling needed
                        akra.pixelUtil.bulkPixelConversion(pSrclock, pDstlock);
                    }
                    this.unlock();
                    pSource.unlock();
                    return true;
                }
            };
            WebGLPixelBuffer.prototype.blitFromMemory = function /** @no-inline */() {
                var pSource;
                var pDestBox;
                pSource = arguments[0];
                if(arguments.length === 1) {
                    pDestBox = new akra.geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
                    return this.blitFromMemory(pSource, pDestBox);
                } else {
                    pDestBox = arguments[1];
                }
                if(!this._pBuffer.contains(pDestBox)) {
                    akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 183);
                    akra.logger.criticalError("Destination box out of range");
                    ;
                }
                var pScaledBox;
                if(pSource.width != pDestBox.width || pSource.height != pDestBox.height || pSource.depth != pDestBox.depth) {
                    // Scale to destination size.
                    // This also does pixel format conversion if needed
                    this.allocateBuffer();
                    pScaledBox = this._pBuffer.getSubBox(pDestBox);
                    pSource.scale(pScaledBox, 2 /* BILINEAR */ );
                } else if((pSource.format != this._eFormat) || ((webgl.getWebGLOriginFormat(pSource.format) == 0) && (pSource.format != 10 /* R8G8B8 */ ))) {
                    // Extents match, but format is not accepted as valid source format for GL
                    // do conversion in temporary buffer
                    this.allocateBuffer();
                    pScaledBox = this._pBuffer.getSubBox(pDestBox);
                    akra.pixelUtil.bulkPixelConversion(pSource, pScaledBox);
                    if(this._eFormat === 8 /* A4R4G4B4 */ ) {
                        // ARGB->BGRA
                        webgl.convertToWebGLformat(pScaledBox, pScaledBox);
                    }
                } else {
                    this.allocateBuffer();
                    pScaledBox = pSource;
                    if(pSource.format == 10 /* R8G8B8 */ ) {
                        pScaledBox.format = 11 /* B8G8R8 */ ;
                        akra.pixelUtil.bulkPixelConversion(pSource, pScaledBox);
                    }
                }
                this.upload(pScaledBox, pDestBox);
                this.freeBuffer();
                return true;
            };
            WebGLPixelBuffer.prototype.blitToMemory = function /** @no-inline */() {
                var pSrcBox;
                var pDest;
                if(arguments.length === 1) {
                    pDest = arguments[0];
                    pSrcBox = new akra.geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
                    return this.blitToMemory(pSrcBox, pDest);
                } else {
                    pSrcBox = arguments[0];
                    pDest = arguments[1];
                }
                if(!this._pBuffer.contains(pSrcBox)) {
                    akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 244);
                    akra.logger.criticalError("source box out of range");
                    ;
                }
                if(pSrcBox.left == 0 && pSrcBox.right == this._iWidth && pSrcBox.top == 0 && pSrcBox.bottom == this._iHeight && pSrcBox.front == 0 && pSrcBox.back == this._iDepth && pDest.width == this._iWidth && pDest.height == this._iHeight && pDest.depth == this._iDepth && webgl.getWebGLOriginFormat(pDest.format) != 0) {
                    // The direct case: the user wants the entire texture in a format supported by GL
                    // so we don't need an intermediate buffer
                    this.download(pDest);
                } else {
                    // Use buffer for intermediate copy
                    this.allocateBuffer();
                    // Download entire buffer
                    this.download(this._pBuffer);
                    if(pSrcBox.width != pDest.width || pSrcBox.height != pDest.height || pSrcBox.depth != pDest.depth) {
                        // We need scaling
                        this._pBuffer.getSubBox(pSrcBox).scale(pDest, 2 /* BILINEAR */ );
                    } else {
                        // Just copy the bit that we need
                        akra.pixelUtil.bulkPixelConversion(this._pBuffer.getSubBox(pSrcBox), pDest);
                    }
                    this.freeBuffer();
                }
                return true;
            };
            WebGLPixelBuffer.prototype.getRenderTarget = function /** @no-inline */() {
                return null;
            };
            WebGLPixelBuffer.prototype.lock = function /** @no-inline */() {
                var pLockBox = null;
                var iLockFlags = 0;
                if(akra.isInt(arguments[0])) {
                    var iOffset;
                    var iSize;
                    if(arguments.length === 1) {
                        iLockFlags === arguments[0];
                        iOffset = 0;
                        iSize = this.byteLength;
                    } else {
                        iOffset = arguments[0];
                        iSize = arguments[1];
                        iLockFlags = (arguments.length === 3) ? arguments[2] : 4 /* READABLE */ ;
                    }
                    akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 307);
                    akra.logger.assert(!this.isLocked(), "Cannot lock this buffer, it is already locked!");
                    ;
                    akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 309);
                    akra.logger.assert(iOffset === 0 && iSize === this.byteLength, "Cannot lock memory region, most lock box or entire buffer");
                    ;
                    pLockBox = new akra.geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
                }
                if(this.isBackupPresent()) {
                    if(!(((iLockFlags) & (2 /* WRITE */ )) != 0)) {
                        // we have to assume a read / write lock so we use the shadow buffer
                        // and tag for sync on unlock()
                        this._pBackupUpdated = true;
                    }
                    this._pCurrentLock = ((this._pBackupCopy)).lock(pLockBox, iLockFlags);
                } else {
                    this._pCurrentLock = this.lockImpl(pLockBox, iLockFlags);
                    this._isLocked = true;
                }
                return this._pCurrentLock;
            };
            WebGLPixelBuffer.prototype.allocateBuffer = /**@protected*/ function /** @no-inline */() {
                if(!akra.isNull(this._pBuffer.data)) {
                    return;
                }
                this._pBuffer.data = new Uint8Array(this.byteLength);
            };
            WebGLPixelBuffer.prototype.freeBuffer = /**@protected*/ function /** @no-inline */() {
                if((((this._iFlags) & (1 /* STATIC */ )) != 0)) {
                    this._pBuffer.data = null;
                }
            };
            WebGLPixelBuffer.prototype.lockImpl = /**@protected*/ function /** @no-inline */() {
                if(arguments.length === 3) {
                    akra.logger.setSourceLocation("webgl/WebGLPixelBuffer.ts", 349);
                    akra.logger.criticalError("lockImpl(offset,length) is not valid for PixelBuffers and should never be called");
                    ;
                }
                var pLockBox = arguments[0];
                var iLockFlags = arguments[1];
                this.allocateBuffer();
                if(!(((iLockFlags) & (4 /* DISCARD */ )) != 0) && (((this._iFlags) & (4 /* READABLE */ )) != 0)) {
                    this.download(this._pBuffer);
                }
                this._iCurrentLockFlags = iLockFlags;
                this._pLockedBox = pLockBox;
                return this._pBuffer.getSubBox(pLockBox);
            };
            WebGLPixelBuffer.prototype.unlockImpl = /**@protected*/ function /** @no-inline */() {
                if((((this._iCurrentLockFlags) & (2 /* WRITE */ )) != 0)) {
                    // From buffer to card, only upload if was locked for writing
                    this.upload(this._pCurrentLock, this._pLockedBox);
                }
                this.freeBuffer();
            };
            return WebGLPixelBuffer;
        })(akra.core.pool.resources.HardwareBuffer);
        webgl.WebGLPixelBuffer = WebGLPixelBuffer;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    (function (ETextureFlags) {
        ETextureFlags._map = [];
        ETextureFlags.STATIC = 1 /* STATIC */ ;
        ETextureFlags.DYNAMIC = 2 /* DYNAMIC */ ;
        ETextureFlags.READEBLE = 4 /* READABLE */ ;
        ETextureFlags.DYNAMIC_DISCARDABLE = akra.EHardwareBufferFlags.DYNAMIC_DISCARDABLE;
        /// mipmaps will be automatically generated for this texture
        ETextureFlags.AUTOMIPMAP = 0x100;
        /// this texture will be a render target, i.e. used as a target for render to texture
        /// setting this flag will ignore all other texture usages except AUTOMIPMAP
        ETextureFlags.RENDERTARGET = 0x200;
        /// default to automatic mipmap generation static textures
        ETextureFlags.DEFAULT = ETextureFlags.AUTOMIPMAP | ETextureFlags.STATIC;
    })(akra.ETextureFlags || (akra.ETextureFlags = {}));
    var ETextureFlags = akra.ETextureFlags;
    (function (ETextureFilters) {
        ETextureFilters._map = [];
        ETextureFilters.NEAREST = 0x2600;
        ETextureFilters.LINEAR = 0x2601;
        ETextureFilters.NEAREST_MIPMAP_NEAREST = 0x2700;
        ETextureFilters.LINEAR_MIPMAP_NEAREST = 0x2701;
        ETextureFilters.NEAREST_MIPMAP_LINEAR = 0x2702;
        ETextureFilters.LINEAR_MIPMAP_LINEAR = 0x2703;
    })(akra.ETextureFilters || (akra.ETextureFilters = {}));
    var ETextureFilters = akra.ETextureFilters;
    ;
    (function (ETextureWrapModes) {
        ETextureWrapModes._map = [];
        ETextureWrapModes.REPEAT = 0x2901;
        ETextureWrapModes.CLAMP_TO_EDGE = 0x812F;
        ETextureWrapModes.MIRRORED_REPEAT = 0x8370;
    })(akra.ETextureWrapModes || (akra.ETextureWrapModes = {}));
    var ETextureWrapModes = akra.ETextureWrapModes;
    ;
    (function (ETextureParameters) {
        ETextureParameters._map = [];
        ETextureParameters.MAG_FILTER = 0x2800;
        ETextureParameters._map[10241] = "MIN_FILTER";
        ETextureParameters.MIN_FILTER = 10241;
        ETextureParameters._map[10242] = "WRAP_S";
        ETextureParameters.WRAP_S = 10242;
        ETextureParameters._map[10243] = "WRAP_T";
        ETextureParameters.WRAP_T = 10243;
    })(akra.ETextureParameters || (akra.ETextureParameters = {}));
    var ETextureParameters = akra.ETextureParameters;
    ;
    (function (ETextureTypes) {
        ETextureTypes._map = [];
        ETextureTypes.TEXTURE_2D = 0x0DE1;
        ETextureTypes.TEXTURE = 0x1702;
        ETextureTypes.TEXTURE_CUBE_MAP = 0x8513;
        ETextureTypes.TEXTURE_BINDING_CUBE_MAP = 0x8514;
        ETextureTypes.TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
        ETextureTypes.TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
        ETextureTypes.TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
        ETextureTypes.TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
        ETextureTypes.TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
        ETextureTypes.TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;
        ETextureTypes.MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;
    })(akra.ETextureTypes || (akra.ETextureTypes = {}));
    var ETextureTypes = akra.ETextureTypes;
    ;
    (function (ETextureUnits) {
        ETextureUnits._map = [];
        ETextureUnits.TEXTURE = 0x84C0;
    })(akra.ETextureUnits || (akra.ETextureUnits = {}));
    var ETextureUnits = akra.ETextureUnits;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                (function (ETextureForcedFormatFlags) {
                    ETextureForcedFormatFlags._map = [];
                    ETextureForcedFormatFlags.FORCEMIPLEVELS = 0;
                    ETextureForcedFormatFlags._map[1] = "FORCEFORMAT";
                    ETextureForcedFormatFlags.FORCEFORMAT = 1;
                    ETextureForcedFormatFlags._map[2] = "FORCESIZE";
                    ETextureForcedFormatFlags.FORCESIZE = 2;
                })(resources.ETextureForcedFormatFlags || (resources.ETextureForcedFormatFlags = {}));
                var ETextureForcedFormatFlags = resources.ETextureForcedFormatFlags;
                var Texture = (function (_super) {
                    __extends(Texture, _super);
                    function /** @no-inline */Texture() {
                                        _super.call(this);
                        /**@protected*/ this._iFlags = akra.ETextureFlags.DEFAULT;
                        /**@protected*/ this._iWidth = 512;
                        /**@protected*/ this._iSrcWidth = 0;
                        /**@protected*/ this._iHeight = 512;
                        /**@protected*/ this._iSrcHeight = 0;
                        /**@protected*/ this._iDepth = 1;
                        /**@protected*/ this._iSrcDepth = 0;
                        /**@protected*/ this._eFormat = 0 /* UNKNOWN */ ;
                        /**@protected*/ this._nMipLevels = 0;
                        /**@protected*/ this._nRequestedMipLevels = 0;
                        /**@protected*/ this._eTextureType = 3553 /* TEXTURE_2D */ ;
                        /**@protected*/ this._iDesiredIntegerBitDepth = 0;
                        /**@protected*/ this._iDesiredFloatBitDepth = 0;
                        /**@protected*/ this._eDesiredFormat = 0 /* UNKNOWN */ ;
                        /**@protected*/ this._eSrcFormat = 0 /* UNKNOWN */ ;
                        /**@protected*/ this._pParams = {
                        };
                        /**@protected*/ this._isInternalResourceCreated = false;
                        /**@protected*/ this._isMipmapsHardwareGenerated = false;
                        /**@protected*/ this._iResourceSize = 0;
                        this._pParams[10241 /* MIN_FILTER */ ] = 9728 /* NEAREST */ ;
                        this._pParams[10240 /* MAG_FILTER */ ] = 9728 /* NEAREST */ ;
                        this._pParams[10242 /* WRAP_S */ ] = 33071 /* CLAMP_TO_EDGE */ ;
                        this._pParams[10243 /* WRAP_T */ ] = 33071 /* CLAMP_TO_EDGE */ ;
                    }
                    Object.defineProperty(Texture.prototype, "width", {
                        get: function /** @inline */() {
                            return this._iWidth;
                        },
                        set: function /** @inline */(iWidth) {
                            this._iWidth = this._iSrcWidth = iWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Texture.prototype, "height", {
                        get: function /** @inline */() {
                            return this._iHeight;
                        },
                        set: function /** @inline */(iHeight) {
                            this._iHeight = this._iSrcHeight = iHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Texture.prototype, "depth", {
                        get: function /** @inline */() {
                            return this._iDepth;
                        },
                        set: function /** @inline */(iDepth) {
                            this._iDepth = this._iSrcDepth = iDepth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Texture.prototype, "format", {
                        get: function /** @inline */() {
                            return this._eFormat;
                        },
                        set: function /** @inline */(eFormat) {
                            this._eFormat = eFormat;
                            this._eDesiredFormat = eFormat;
                            this._eSrcFormat = eFormat;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Texture.prototype, "textureType", {
                        get: function /** @inline */() {
                            return this._eTextureType;
                        },
                        set: function /** @inline */(eTextureType) {
                            this._eTextureType = eTextureType;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Texture.prototype, "mipLevels", {
                        get: function /** @inline */() {
                            return this._nMipLevels;
                        },
                        set: function /** @inline */(nMipLevels) {
                            this._nMipLevels = nMipLevels;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Texture.prototype, "desiredIntegerBitDepth", {
                        get: function /** @inline */() {
                            return this._iDesiredIntegerBitDepth;
                        },
                        set: function /** @inline */(iDesiredIntegerBitDepth) {
                            this._iDesiredIntegerBitDepth = iDesiredIntegerBitDepth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Texture.prototype, "desiredFloatBitDepth", {
                        get: function /** @inline */() {
                            return this._iDesiredFloatBitDepth;
                        },
                        set: function /** @inline */(iDesiredFloatBitDepth) {
                            this._iDesiredFloatBitDepth = iDesiredFloatBitDepth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Texture.prototype, "srcWidth", {
                        get: function /** @inline */() {
                            return this._iSrcWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Texture.prototype, "srcHeight", {
                        get: function /** @inline */() {
                            return this._iSrcHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Texture.prototype, "srcDepth", {
                        get: function /** @inline */() {
                            return this._iSrcWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Texture.prototype, "desiredFormat", {
                        get: function /** @inline */() {
                            return this._eDesiredFormat;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Texture.prototype, "srcFormat", {
                        get: function /** @inline */() {
                            return this._eSrcFormat;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Texture.prototype.getFlags = function /** @inline */() {
                        return this._iFlags;
                    };
                    Texture.prototype.setFlags = function /** @inline */(iFlags) {
                        this._iFlags = iFlags;
                    };
                    Texture.prototype.isTexture2D = function /** @inline */() {
                        return this._eTextureType === 3553 /* TEXTURE_2D */ ;
                    };
                    Texture.prototype.isTextureCube = function /** @inline */() {
                        return this._eTextureType === 34067 /* TEXTURE_CUBE_MAP */ ;
                    };
                    Texture.prototype.isCompressed = function /** @inline */() {
                        return (this._eFormat >= 17 /* DXT1 */  && this._eFormat <= 21 /* DXT5 */ ) || (this._eFormat >= 38 /* PVRTC_RGB2 */  && this._eFormat <= 41 /* PVRTC_RGBA4 */ );
                    };
                    Texture.prototype.isValid = function /** @inline */() {
                        return akra.isDefAndNotNull(this._isInternalResourceCreated);
                    };
                    Texture.prototype.calculateSize = function /** @inline */() {
                        return this.getNumFaces() * akra.pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
                    };
                    Texture.prototype.getNumFaces = function /** @inline */() {
                        return this._eTextureType === 34067 /* TEXTURE_CUBE_MAP */  ? 6 : 1;
                    };
                    Texture.prototype.getSize = function /** @inline */() {
                        return this._iResourceSize;
                    };
                    Texture.prototype.getBuffer = function /** @no-inline */(iFace, iMipmap) {
                        return null;
                    };
                    Texture.prototype.create = function /** @no-inline */(iWidth, iHeight, iDepth, pPixels, iFlags, nMipLevels, eTextureType, eFormat) {
                        if (typeof pPixels === "undefined") { pPixels = null; }
                        if (typeof iFlags === "undefined") { iFlags = 0; }
                        if (typeof nMipLevels === "undefined") { nMipLevels = 0; }
                        if (typeof eTextureType === "undefined") { eTextureType = 3553 /* TEXTURE_2D */ ; }
                        if (typeof eFormat === "undefined") { eFormat = 10 /* R8G8B8 */ ; }
                        this._iWidth = iWidth;
                        this._iHeight = iHeight;
                        this._iDepth = iDepth;
                        this._iFlags = iFlags;
                        this._nMipLevels = nMipLevels;
                        this._eTextureType = eTextureType;
                        this._eFormat = eFormat;
                        if(akra.isDef(pPixels.length)) {
                            if(pPixels instanceof Array) {
                                pPixels = new Uint8Array(pPixels);
                            }
                            return this.loadRawData(pPixels, iWidth, iHeight, eFormat);
                        } else {
                            return this.createInternalTexture(pPixels);
                        }
                    };
                    Texture.prototype.destroyResource = function /** @no-inline */() {
                        this.freeInternalTexture();
                        this.notifyDestroyed();
                        return true;
                    };
                    Texture.prototype.setParameter = function /** @no-inline */(eParam, eValue) {
                        if(!this.isValid()) {
                            return false;
                        }
                        this._pParams[eParam] = eValue;
                        return true;
                    };
                    Texture.prototype.loadRawData = function /** @no-inline */(pStream, iWidth, iHeight, eFormat) {
                        var pTempImg = this.getManager().imagePool.findResource(".temp_image");
                        if(akra.isNull(pTempImg)) {
                            pTempImg = this.getManager().imagePool.createResource(".temp_image");
                            //pTempImg.create();
                                                    }
                        pTempImg.loadRawData(pStream, iWidth, iHeight, eFormat);
                        var isLoaded = this.loadImage(pTempImg);
                        this.getManager().imagePool.destroyResource(pTempImg);
                        return isLoaded;
                    };
                    Texture.prototype.loadImage = function /** @no-inline */(pImage) {
                        var isLoaded = this._loadImages(pImage, true);
                        if(isLoaded) {
                            this.notifyLoaded();
                            return true;
                        } else {
                            return false;
                        }
                    };
                    Texture.prototype.loadImages = function /** @no-inline */(pImages) {
                        var isLoaded = this._loadImages(pImages);
                        if(isLoaded) {
                            this.notifyLoaded();
                            return true;
                        } else {
                            return false;
                        }
                    };
                    Texture.prototype._loadImages = function /** @no-inline */() {
                        if(this.isResourceLoaded()) {
                            akra.logger.setSourceLocation("core/pool/resources/Texture.ts", 272);
                            akra.logger.warning("Yoy try to load texture when it already have been loaded. All texture data was destoyed.");
                            ;
                            this.freeInternalTexture();
                        }
                        var pMainImage = null;
                        var pImageList = null;
                        if(arguments.length === 2) {
                            pMainImage = arguments[0];
                        } else {
                            pImageList = arguments[0];
                            if(pImageList.length === 0) {
                                akra.logger.setSourceLocation("core/pool/resources/Texture.ts", 285);
                                akra.logger.criticalError("Cannot load empty list of images");
                                ;
                                return false;
                            }
                            pMainImage = pImageList[0];
                        }
                        this._iSrcWidth = this._iWidth = pMainImage.width;
                        this._iSrcHeight = this._iHeight = pMainImage.height;
                        this._iSrcDepth = this._iDepth = pMainImage.depth;
                        // Get source image format and adjust if required
                        this._eSrcFormat = pMainImage.format;
                        if(this._eDesiredFormat !== 0 /* UNKNOWN */ ) {
                            // If have desired format, use it
                            this._eFormat = this._eDesiredFormat;
                        } else {
                            // Get the format according with desired bit depth
                            this._eFormat = akra.pixelUtil.getFormatForBitDepths(this._eSrcFormat, this._iDesiredIntegerBitDepth, this._iDesiredFloatBitDepth);
                        }
                        // The custom mipmaps in the image have priority over everything
                        var iImageMips = pMainImage.numMipMaps;
                        if(iImageMips > 0) {
                            this._nMipLevels = this._nRequestedMipLevels = iImageMips;
                            // Disable flag for auto mip generation
                            ((this._iFlags) &= ~(256 /* AUTOMIPMAP */ ));
                        }
                        // Create the texture
                        this.createInternalTexture(null);
                        // Check if we're loading one image with multiple faces
                        // or a vector of images representing the faces
                        var iFaces = 0;
                        var isMultiImage = false;
                        if(!akra.isNull(pImageList) && pImageList.length > 1) {
                            iFaces = pImageList.length;
                            isMultiImage = true;
                        } else {
                            iFaces = pMainImage.numFaces;
                            isMultiImage = false;
                        }
                        // Check wether number of faces in images exceeds number of faces
                        // in this texture. If so, clamp it.
                        if(iFaces > this.getNumFaces()) {
                            iFaces = this.getNumFaces();
                        }
                        // Main loading loop
                        // imageMips == 0 if the image has no custom mipmaps, otherwise contains the number of custom mips
                        var mip = 0;
                        var i = 0;
                        for(mip = 0; mip <= iImageMips; ++mip) {
                            for(i = 0; i < iFaces; ++i) {
                                var pSrc;
                                if(isMultiImage) {
                                    // Load from multiple images
                                    pSrc = pImageList[i].getPixels(0, mip);
                                } else {
                                    // Load from faces of images[0] or main Image
                                    pSrc = pMainImage.getPixels(i, mip);
                                }
                                // Sets to treated format in case is difference
                                pSrc.format = this._eSrcFormat;
                                // Destination: entire texture. blitFromMemory does the scaling to
                                // a power of two for us when needed
                                this.getBuffer(i, mip).blitFromMemory(pSrc);
                            }
                        }
                        // Update size (the final size, not including temp space)
                        this._iResourceSize = this.getNumFaces() * akra.pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
                        return true;
                    };
                    Texture.prototype.convertToImage = function /** @no-inline */(pDestImage, bIncludeMipMaps) {
                        var iNumMips = bIncludeMipMaps ? this._nMipLevels + 1 : 1;
                        var iDataSize = akra.pixelUtil.calculateSizeForImage(iNumMips, this._nMipLevels, this._iWidth, this._iHeight, this._iDepth, this._eFormat);
                        var pPixData = new Uint8Array(iDataSize);
                        // if there are multiple faces and mipmaps we must pack them into the data
                        // faces, then mips
                        var pCurrentPixData = pPixData;
                        var iFace = 0;
                        var mip = 0;
                        for(iFace = 0; iFace < this.getNumFaces(); ++iFace) {
                            for(mip = 0; mip < iNumMips; ++mip) {
                                var iMipDataSize = akra.pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
                                var pPixBox = new akra.pixelUtil.PixelBox(this._iWidth, this._iHeight, this._iDepth, this._eFormat, pCurrentPixData);
                                this.getBuffer(iFace, mip).blitToMemory(pPixBox);
                                pCurrentPixData = pCurrentPixData.subarray(iMipDataSize);
                            }
                        }
                        // load, and tell Image to delete the memory when it's done.
                        pDestImage.loadDynamicImage(pPixData, this._iWidth, this._iHeight, this._iDepth, this._eFormat, true, this.getNumFaces(), iNumMips - 1);
                    };
                    Texture.prototype.copyToTexture = function /** @no-inline */(pTarget) {
                        if(pTarget.getNumFaces() !== this.getNumFaces()) {
                            akra.logger.setSourceLocation("core/pool/resources/Texture.ts", 400);
                            akra.logger.criticalError("Texture types must match");
                            ;
                        }
                        var nMipLevels = Math.min(this._nMipLevels, pTarget.mipLevels);
                        if((((this._iFlags) & (256 /* AUTOMIPMAP */ )) != 0) || (((this.getFlags()) & (256 /* AUTOMIPMAP */ )) != 0)) {
                            nMipLevels = 0;
                        }
                        var iFace = 0, mip = 0;
                        for(iFace = 0; iFace < this.getNumFaces(); iFace++) {
                            for(mip = 0; mip <= nMipLevels; mip++) {
                                pTarget.getBuffer(iFace, mip).blit(this.getBuffer(iFace, mip));
                            }
                        }
                    };
                    Texture.prototype.createInternalTexture = function /** @no-inline */(cFillColor) {
                        if (typeof cFillColor === "undefined") { cFillColor = null; }
                        if(!this._isInternalResourceCreated) {
                            this.createInternalTextureImpl(cFillColor);
                            this._isInternalResourceCreated = true;
                            this.notifyCreated();
                            return true;
                        }
                        return false;
                    };
                    Texture.prototype.freeInternalTexture = function /** @no-inline */() {
                        if(this._isInternalResourceCreated) {
                            this.freeInternalTextureImpl();
                            this._isInternalResourceCreated = false;
                            this.notifyDestroyed();
                            return true;
                        }
                        return false;
                    };
                    Texture.prototype.getNativeFormat = function /** @no-inline */(eTextureType, eFormat, iFlags) {
                        if (typeof eTextureType === "undefined") { eTextureType = this._eTextureType; }
                        if (typeof eFormat === "undefined") { eFormat = this._eFormat; }
                        if (typeof iFlags === "undefined") { iFlags = this._iFlags; }
                        return null;
                    };
                    Texture.prototype.createInternalTextureImpl = /**@protected*/ function /** @no-inline */(cFillColor) {
                        if (typeof cFillColor === "undefined") { cFillColor = null; }
                        return false;
                    };
                    Texture.prototype.freeInternalTextureImpl = /**@protected*/ function /** @no-inline */() {
                        return false;
                    };
                    Texture.prototype.setPixelRGBA = function /** @no-inline */(i1, i2, iTextureWidth, iTextureHeight, pBuffer) {
                        return;
                    };
                    return Texture;
                })(pool.ResourcePoolItem);
                resources.Texture = Texture;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    (function (ECameraParameters) {
        ECameraParameters._map = [];
        ECameraParameters.CONST_ASPECT = 1;
    })(akra.ECameraParameters || (akra.ECameraParameters = {}));
    var ECameraParameters = akra.ECameraParameters;
    (function (ECameraTypes) {
        ECameraTypes._map = [];
        ECameraTypes._map[0] = "PERSPECTIVE";
        ECameraTypes.PERSPECTIVE = 0;
        ECameraTypes._map[1] = "ORTHO";
        ECameraTypes.ORTHO = 1;
        ECameraTypes._map[2] = "OFFSET_ORTHO";
        ECameraTypes.OFFSET_ORTHO = 2;
    })(akra.ECameraTypes || (akra.ECameraTypes = {}));
    var ECameraTypes = akra.ECameraTypes;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EFramebuffer) {
        EFramebuffer._map = [];
        EFramebuffer._map[0] = "FRONT";
        EFramebuffer.FRONT = 0;
        EFramebuffer._map[1] = "BACK";
        EFramebuffer.BACK = 1;
        EFramebuffer._map[2] = "AUTO";
        EFramebuffer.AUTO = 2;
    })(akra.EFramebuffer || (akra.EFramebuffer = {}));
    var EFramebuffer = akra.EFramebuffer;
    ;
    (function (EStatFlags) {
        EStatFlags._map = [];
        EStatFlags.NONE = 0;
        EStatFlags.FPS = 1;
        EStatFlags.AVG_FPS = 2;
        EStatFlags.BEST_FPS = 4;
        EStatFlags.WORST_FPS = 8;
        EStatFlags.TRIANGLE_COUNT = 16;
        EStatFlags.ALL = 0xFFFF;
    })(akra.EStatFlags || (akra.EStatFlags = {}));
    var EStatFlags = akra.EStatFlags;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EAFXInstructionTypes) {
        EAFXInstructionTypes._map = [];
        EAFXInstructionTypes.k_Instruction = 0;
        EAFXInstructionTypes._map[1] = "k_SimpleInstruction";
        EAFXInstructionTypes.k_SimpleInstruction = 1;
        EAFXInstructionTypes._map[2] = "k_VariableTypeInstruction";
        EAFXInstructionTypes.k_VariableTypeInstruction = 2;
        EAFXInstructionTypes._map[3] = "k_SystemTypeInstruction";
        EAFXInstructionTypes.k_SystemTypeInstruction = 3;
        EAFXInstructionTypes._map[4] = "k_ComplexTypeInstruction";
        EAFXInstructionTypes.k_ComplexTypeInstruction = 4;
        EAFXInstructionTypes._map[5] = "k_TypedInstruction";
        EAFXInstructionTypes.k_TypedInstruction = 5;
        EAFXInstructionTypes._map[6] = "k_DeclInstruction";
        EAFXInstructionTypes.k_DeclInstruction = 6;
        EAFXInstructionTypes._map[7] = "k_IntInstruction";
        EAFXInstructionTypes.k_IntInstruction = 7;
        EAFXInstructionTypes._map[8] = "k_FloatInstruction";
        EAFXInstructionTypes.k_FloatInstruction = 8;
        EAFXInstructionTypes._map[9] = "k_BoolInstruction";
        EAFXInstructionTypes.k_BoolInstruction = 9;
        EAFXInstructionTypes._map[10] = "k_StringInstruction";
        EAFXInstructionTypes.k_StringInstruction = 10;
        EAFXInstructionTypes._map[11] = "k_IdInstruction";
        EAFXInstructionTypes.k_IdInstruction = 11;
        EAFXInstructionTypes._map[12] = "k_KeywordInstruction";
        EAFXInstructionTypes.k_KeywordInstruction = 12;
        EAFXInstructionTypes._map[13] = "k_TypeDeclInstruction";
        EAFXInstructionTypes.k_TypeDeclInstruction = 13;
        EAFXInstructionTypes._map[14] = "k_VariableDeclInstruction";
        EAFXInstructionTypes.k_VariableDeclInstruction = 14;
        EAFXInstructionTypes._map[15] = "k_AnnotationInstruction";
        EAFXInstructionTypes.k_AnnotationInstruction = 15;
        EAFXInstructionTypes._map[16] = "k_UsageTypeInstruction";
        EAFXInstructionTypes.k_UsageTypeInstruction = 16;
        EAFXInstructionTypes._map[17] = "k_BaseTypeInstruction";
        EAFXInstructionTypes.k_BaseTypeInstruction = 17;
        EAFXInstructionTypes._map[18] = "k_StructDeclInstruction";
        EAFXInstructionTypes.k_StructDeclInstruction = 18;
        EAFXInstructionTypes._map[19] = "k_StructFieldsInstruction";
        EAFXInstructionTypes.k_StructFieldsInstruction = 19;
        EAFXInstructionTypes._map[20] = "k_ExprInstruction";
        EAFXInstructionTypes.k_ExprInstruction = 20;
        EAFXInstructionTypes._map[21] = "k_IdExprInstruction";
        EAFXInstructionTypes.k_IdExprInstruction = 21;
        EAFXInstructionTypes._map[22] = "k_ArithmeticExprInstruction";
        EAFXInstructionTypes.k_ArithmeticExprInstruction = 22;
        EAFXInstructionTypes._map[23] = "k_AssignmentExprInstruction";
        EAFXInstructionTypes.k_AssignmentExprInstruction = 23;
        EAFXInstructionTypes._map[24] = "k_RelationalExprInstruction";
        EAFXInstructionTypes.k_RelationalExprInstruction = 24;
        EAFXInstructionTypes._map[25] = "k_LogicalExprInstruction";
        EAFXInstructionTypes.k_LogicalExprInstruction = 25;
        EAFXInstructionTypes._map[26] = "k_ConditionalExprInstruction";
        EAFXInstructionTypes.k_ConditionalExprInstruction = 26;
        EAFXInstructionTypes._map[27] = "k_CastExprInstruction";
        EAFXInstructionTypes.k_CastExprInstruction = 27;
        EAFXInstructionTypes._map[28] = "k_UnaryExprInstruction";
        EAFXInstructionTypes.k_UnaryExprInstruction = 28;
        EAFXInstructionTypes._map[29] = "k_PostfixIndexInstruction";
        EAFXInstructionTypes.k_PostfixIndexInstruction = 29;
        EAFXInstructionTypes._map[30] = "k_PostfixPointInstruction";
        EAFXInstructionTypes.k_PostfixPointInstruction = 30;
        EAFXInstructionTypes._map[31] = "k_PostfixArithmeticInstruction";
        EAFXInstructionTypes.k_PostfixArithmeticInstruction = 31;
        EAFXInstructionTypes._map[32] = "k_PrimaryExprInstruction";
        EAFXInstructionTypes.k_PrimaryExprInstruction = 32;
        EAFXInstructionTypes._map[33] = "k_ComplexExprInstruction";
        EAFXInstructionTypes.k_ComplexExprInstruction = 33;
        EAFXInstructionTypes._map[34] = "k_FunctionCallInstruction";
        EAFXInstructionTypes.k_FunctionCallInstruction = 34;
        EAFXInstructionTypes._map[35] = "k_SystemCallInstruction";
        EAFXInstructionTypes.k_SystemCallInstruction = 35;
        EAFXInstructionTypes._map[36] = "k_ConstructorCallInstruction";
        EAFXInstructionTypes.k_ConstructorCallInstruction = 36;
        EAFXInstructionTypes._map[37] = "k_CompileExprInstruction";
        EAFXInstructionTypes.k_CompileExprInstruction = 37;
        EAFXInstructionTypes._map[38] = "k_SamplerStateBlockInstruction";
        EAFXInstructionTypes.k_SamplerStateBlockInstruction = 38;
        EAFXInstructionTypes._map[39] = "k_SamplerStateInstruction";
        EAFXInstructionTypes.k_SamplerStateInstruction = 39;
        EAFXInstructionTypes._map[40] = "k_MemExprInstruction";
        EAFXInstructionTypes.k_MemExprInstruction = 40;
        EAFXInstructionTypes._map[41] = "k_FunctionDeclInstruction";
        EAFXInstructionTypes.k_FunctionDeclInstruction = 41;
        EAFXInstructionTypes._map[42] = "k_ShaderFunctionInstruction";
        EAFXInstructionTypes.k_ShaderFunctionInstruction = 42;
        EAFXInstructionTypes._map[43] = "k_SystemFunctionInstruction";
        EAFXInstructionTypes.k_SystemFunctionInstruction = 43;
        EAFXInstructionTypes._map[44] = "k_FunctionDefInstruction";
        EAFXInstructionTypes.k_FunctionDefInstruction = 44;
        EAFXInstructionTypes._map[45] = "k_StmtInstruction";
        EAFXInstructionTypes.k_StmtInstruction = 45;
        EAFXInstructionTypes._map[46] = "k_StmtBlockInstruction";
        EAFXInstructionTypes.k_StmtBlockInstruction = 46;
        EAFXInstructionTypes._map[47] = "k_ExprStmtInstruction";
        EAFXInstructionTypes.k_ExprStmtInstruction = 47;
        EAFXInstructionTypes._map[48] = "k_BreakStmtInstruction";
        EAFXInstructionTypes.k_BreakStmtInstruction = 48;
        EAFXInstructionTypes._map[49] = "k_WhileStmtInstruction";
        EAFXInstructionTypes.k_WhileStmtInstruction = 49;
        EAFXInstructionTypes._map[50] = "k_ForStmtInstruction";
        EAFXInstructionTypes.k_ForStmtInstruction = 50;
        EAFXInstructionTypes._map[51] = "k_IfStmtInstruction";
        EAFXInstructionTypes.k_IfStmtInstruction = 51;
        EAFXInstructionTypes._map[52] = "k_DeclStmtInstruction";
        EAFXInstructionTypes.k_DeclStmtInstruction = 52;
        EAFXInstructionTypes._map[53] = "k_ReturnStmtInstruction";
        EAFXInstructionTypes.k_ReturnStmtInstruction = 53;
        EAFXInstructionTypes._map[54] = "k_SemicolonStmtInstruction";
        EAFXInstructionTypes.k_SemicolonStmtInstruction = 54;
        EAFXInstructionTypes._map[55] = "k_TechniqueInstruction";
        EAFXInstructionTypes.k_TechniqueInstruction = 55;
    })(akra.EAFXInstructionTypes || (akra.EAFXInstructionTypes = {}));
    var EAFXInstructionTypes = akra.EAFXInstructionTypes;
    (function (EFunctionType) {
        EFunctionType._map = [];
        EFunctionType._map[0] = "k_Vertex";
        EFunctionType.k_Vertex = 0;
        EFunctionType._map[1] = "k_Pixel";
        EFunctionType.k_Pixel = 1;
        EFunctionType.k_Fragment = EFunctionType.k_Pixel;
        EFunctionType._map[NaN] = "k_Function";
        EFunctionType.k_Function = NaN;
    })(akra.EFunctionType || (akra.EFunctionType = {}));
    var EFunctionType = akra.EFunctionType;
    (function (ECheckStage) {
        ECheckStage._map = [];
        ECheckStage._map[0] = "CODE_TARGET_SUPPORT";
        /* Отсутсвуют конструкции не поддерживаемые языком назначения (GLSL) */
        ECheckStage.CODE_TARGET_SUPPORT = 0;
        ECheckStage._map[1] = "SELF_CONTAINED";
        /* Код замкнут, нет не определенных функций, пассов, техник. Нет мертвых функций. */
        ECheckStage.SELF_CONTAINED = 1;// VALIDATION  /* Код не содерит синтаксиески неправильных выражений, то что не исчерпывается */
        
    })(akra.ECheckStage || (akra.ECheckStage = {}));
    var ECheckStage = akra.ECheckStage;
    (function (EVarUsedMode) {
        EVarUsedMode._map = [];
        EVarUsedMode._map[0] = "k_Read";
        EVarUsedMode.k_Read = 0;
        EVarUsedMode._map[1] = "k_Write";
        EVarUsedMode.k_Write = 1;
        EVarUsedMode._map[2] = "k_ReadWrite";
        EVarUsedMode.k_ReadWrite = 2;
        EVarUsedMode._map[3] = "k_Undefined";
        EVarUsedMode.k_Undefined = 3;
        EVarUsedMode.k_Default = EVarUsedMode.k_ReadWrite;
    })(akra.EVarUsedMode || (akra.EVarUsedMode = {}));
    var EVarUsedMode = akra.EVarUsedMode;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    (function (EDataFlowTypes) {
        EDataFlowTypes._map = [];
        /*!< The data stream can be marked up its index.*/
        EDataFlowTypes.MAPPABLE = 1;
        /*!< The data stream cannot be marked up its index.*/
        EDataFlowTypes.UNMAPPABLE = 0;
    })(akra.EDataFlowTypes || (akra.EDataFlowTypes = {}));
    var EDataFlowTypes = akra.EDataFlowTypes;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    (function (EVertexBufferTypes) {
        EVertexBufferTypes._map = [];
        EVertexBufferTypes._map[0] = "UNKNOWN";
        EVertexBufferTypes.UNKNOWN = 0;
        EVertexBufferTypes._map[1] = "VBO";
        EVertexBufferTypes.VBO = 1;
        EVertexBufferTypes._map[2] = "TBO";
        EVertexBufferTypes.TBO = 2;
    })(akra.EVertexBufferTypes || (akra.EVertexBufferTypes = {}));
    var EVertexBufferTypes = akra.EVertexBufferTypes;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EFrameBufferTypes) {
        EFrameBufferTypes._map = [];
        EFrameBufferTypes.COLOR = 0x1;
        EFrameBufferTypes.DEPTH = 0x2;
        EFrameBufferTypes.STENCIL = 0x4;
    })(akra.EFrameBufferTypes || (akra.EFrameBufferTypes = {}));
    var EFrameBufferTypes = akra.EFrameBufferTypes;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    (function (EViewportTypes) {
        EViewportTypes._map = [];
        EViewportTypes.DEFAULT = -1;
        EViewportTypes.DSVIEWPORT = 1;
    })(akra.EViewportTypes || (akra.EViewportTypes = {}));
    var EViewportTypes = akra.EViewportTypes;
})(akra || (akra = {}));
;
;
var akra;
(function (akra) {
    (function (geometry) {
        var Circle = (function () {
            function /** @no-inline */Circle(fCenterX, fCenterY, fRadius) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        var pCircle = arguments[0];
                        this.center = new akra.Vec2(pCircle.center);
                        this.radius = pCircle.radius;
                        break;
                    case 2:
                        var v2fCenter = arguments[0];
                        var fRadius = arguments[1];
                        this.center = new akra.Vec2(v2fCenter);
                        this.radius = fRadius;
                        break;
                    case 3:
                        this.center = new akra.Vec2(arguments[0], arguments[1]);
                        this.radius = arguments[2];
                        break;
                    default:
                        this.center = new akra.Vec2();
                        this.radius = 0.;
                        break;
                }
            }
            Circle.prototype.set = function /** @no-inline */(fCenterX, fCenterY, fRadius) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        var pCircle = arguments[0];
                        this.center.set(pCircle.center);
                        this.radius = pCircle.radius;
                        break;
                    case 2:
                        var v2fCenter = arguments[0];
                        var fRadius = arguments[1];
                        this.center.set(v2fCenter);
                        this.radius = fRadius;
                        break;
                    case 3:
                        this.center.set(arguments[0], arguments[1]);
                        this.radius = arguments[2];
                        break;
                    default:
                        this.center.set(0.);
                        this.radius = 0.;
                }
                return this;
            };
            Circle.prototype.clear = function /** @inline */() {
                this.center.clear();
                this.radius = 0.;
                return this;
            };
            Circle.prototype.isEqual = function /** @inline */(pCircle) {
                return this.center.isEqual(pCircle.center) && (this.radius == pCircle.radius);
            };
            Circle.prototype.isClear = function /** @inline */() {
                return this.center.isClear() && (this.radius === 0.);
            };
            Circle.prototype.isValid = function /** @inline */() {
                return (this.radius >= 0.);
            };
            Circle.prototype.offset = function /** @inline */(v2fOffset) {
                this.center.add(v2fOffset);
                return this;
            };
            Circle.prototype.expand = function /** @inline */(fInc) {
                this.radius += fInc;
                return this;
            };
            Circle.prototype.normalize = function /** @inline */() {
                this.radius = akra.math.abs(this.radius);
                return this;
            };
            return Circle;
        })();
        geometry.Circle = Circle;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
;
var akra;
(function (akra) {
    (function (geometry) {
        var Rect2d = (function () {
            function /** @no-inline */Rect2d(fX0, fX1, fY0, fY1) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 2:
                        this.set(arguments[0], arguments[1]);
                        break;
                    case 4:
                        this.set(arguments[0], arguments[1], arguments[2], arguments[3]);
                        break;
                    default:
                        this.x0 = this.x1 = this.y0 = this.y1 = 0.;
                        break;
                }
            }
            Object.defineProperty(Rect2d.prototype, "left", {
                get: function /** @inline */() {
                    return this.x0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rect2d.prototype, "top", {
                get: function /** @inline */() {
                    return this.y0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rect2d.prototype, "width", {
                get: function /** @inline */() {
                    return this.x1 - this.x0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rect2d.prototype, "height", {
                get: function /** @inline */() {
                    return this.y1 - this.y0;
                },
                enumerable: true,
                configurable: true
            });
            Rect2d.prototype.set = function /** @no-inline */(fX0, fX1, fY0, fY1) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        if(arguments[0] instanceof Rect2d) {
                            var pRect = arguments[0];
                            this.x0 = pRect.x0;
                            this.x1 = pRect.x1;
                            this.y0 = pRect.y0;
                            this.y1 = pRect.y1;
                        } else {
                            var v2fSizes = arguments[0];
                            this.x1 = v2fSizes.x * 0.5;
                            this.x0 = -this.x1;
                            this.y1 = v2fSizes.y * 0.5;
                            this.y0 = -this.y1;
                        }
                        break;
                    case 2:
                        var fSizeX = arguments[0];
                        var fSizeY = arguments[1];
                        this.x1 = fSizeX * 0.5;
                        this.x0 = -this.x1;
                        this.y1 = fSizeY * 0.5;
                        this.y0 = -this.y1;
                        break;
                    case 4:
                        this.x0 = arguments[0];
                        this.x1 = arguments[1];
                        this.y0 = arguments[2];
                        this.y1 = arguments[3];
                        break;
                    default:
                        this.x0 = this.x1 = this.y0 = this.y1 = 0.;
                        break;
                }
                return this;
            };
            Rect2d.prototype.setFloor = function /** @no-inline */(pRect) {
                this.x0 = akra.math.floor(pRect.x0);
                this.x1 = akra.math.floor(pRect.x1);
                this.y0 = akra.math.floor(pRect.y0);
                this.y1 = akra.math.floor(pRect.y1);
                return this;
            };
            Rect2d.prototype.setCeil = function /** @no-inline */(pRect) {
                this.x0 = akra.math.ceil(pRect.x0);
                this.x1 = akra.math.ceil(pRect.x1);
                this.y0 = akra.math.ceil(pRect.y0);
                this.y1 = akra.math.ceil(pRect.y1);
                return this;
            };
            Rect2d.prototype.clear = function /** @inline */() {
                this.x0 = this.x1 = this.y0 = this.y1 = 0.;
                return this;
            };
            Rect2d.prototype.addSelf = function /** @no-inline */(v2fVec) {
                if(akra.isFloat(arguments[0])) {
                    var fValue = arguments[0];
                    this.x0 += fValue;
                    this.x1 += fValue;
                    this.y0 += fValue;
                    this.y1 += fValue;
                } else {
                    var v2fVec = arguments[0];
                    this.x0 += v2fVec.x;
                    this.x1 += v2fVec.x;
                    this.y0 += v2fVec.y;
                    this.y1 += v2fVec.y;
                }
                return this;
            };
            Rect2d.prototype.subSelf = function /** @no-inline */(v2fVec) {
                if(akra.isFloat(arguments[0])) {
                    var fValue = arguments[0];
                    this.x0 -= fValue;
                    this.x1 -= fValue;
                    this.y0 -= fValue;
                    this.y1 -= fValue;
                } else {
                    var v2fVec = arguments[0];
                    this.x0 -= v2fVec.x;
                    this.x1 -= v2fVec.x;
                    this.y0 -= v2fVec.y;
                    this.y1 -= v2fVec.y;
                }
                return this;
            };
            Rect2d.prototype.multSelf = function /** @no-inline */(v2fVec) {
                if(akra.isFloat(arguments[0])) {
                    var fValue = arguments[0];
                    this.x0 *= fValue;
                    this.x1 *= fValue;
                    this.y0 *= fValue;
                    this.y1 *= fValue;
                } else {
                    var v2fVec = arguments[0];
                    this.x0 *= v2fVec.x;
                    this.x1 *= v2fVec.x;
                    this.y0 *= v2fVec.y;
                    this.y1 *= v2fVec.y;
                }
                return this;
            };
            Rect2d.prototype.divSelf = function /** @no-inline */(v2fVec) {
                if(akra.isFloat(arguments[0])) {
                    var fValue = arguments[0];
                    akra.logger.setSourceLocation("geometry/Rect2d.ts", 196);
                    akra.logger.assert(fValue != 0., "divide by zero error");
                    ;
                    var fInvValue = 1. / fValue;
                    this.x0 *= fInvValue;
                    this.x1 *= fInvValue;
                    this.y0 *= fInvValue;
                    this.y1 *= fInvValue;
                } else {
                    var v2fVec = arguments[0];
                    akra.logger.setSourceLocation("geometry/Rect2d.ts", 208);
                    akra.logger.assert(v2fVec.x != 0., "divide by zero error");
                    ;
                    akra.logger.setSourceLocation("geometry/Rect2d.ts", 209);
                    akra.logger.assert(v2fVec.y != 0., "divide by zero error");
                    ;
                    var fInvX = 1. / v2fVec.x;
                    var fInvY = 1. / v2fVec.y;
                    this.x0 *= fInvX;
                    this.x1 *= fInvX;
                    this.y0 *= fInvY;
                    this.y1 *= fInvY;
                }
                return this;
            };
            Rect2d.prototype.offset = function /** @no-inline */(fOffsetX, fOffsetY) {
                if(arguments.length === 1) {
                    var v2fOffset = arguments[0];
                    this.x0 += v2fOffset.x;
                    this.x1 += v2fOffset.x;
                    this.y0 += v2fOffset.y;
                    this.y1 += v2fOffset.y;
                } else {
                    this.x0 += arguments[0];
                    this.x1 += arguments[0];
                    this.y0 += arguments[1];
                    this.y1 += arguments[1];
                }
                return this;
            };
            Rect2d.prototype.expand = function /** @no-inline */(fValueX, fValueY) {
                if(arguments.length == 1) {
                    if(akra.isFloat(arguments[0])) {
                        var fValue = arguments[0];
                        this.x0 -= fValue;
                        this.x1 += fValue;
                        this.y0 -= fValue;
                        this.y1 += fValue;
                    } else {
                        var v2fValue = arguments[0];
                        this.x0 -= v2fValue.x;
                        this.x1 += v2fValue.x;
                        this.y0 -= v2fValue.y;
                        this.y1 += v2fValue.y;
                    }
                } else {
                    //arguments.length == 2
                    this.x0 -= arguments[0];
                    this.x1 += arguments[0];
                    this.y0 -= arguments[1];
                    this.y1 += arguments[1];
                }
                return this;
            };
            Rect2d.prototype.expandX = function /** @no-inline */(fValue) {
                this.x0 -= fValue;
                this.x1 += fValue;
                return this;
            };
            Rect2d.prototype.expandY = function /** @no-inline */(fValue) {
                this.y0 -= fValue;
                this.y1 += fValue;
                return this;
            };
            Rect2d.prototype.resize = function /** @no-inline */(fSizeX, fSizeY) {
                var fSizeX, fSizeY;
                if(arguments.length == 1) {
                    var v2fSize = arguments[0];
                    fSizeX = v2fSize.x;
                    fSizeY = v2fSize.y;
                } else {
                    fSizeX = arguments[0];
                    fSizeY = arguments[1];
                }
                this.x1 = (this.x0 + this.x1 + fSizeX) * 0.5;
                this.x0 = this.x1 - fSizeX;
                this.y1 = (this.y0 + this.y1 + fSizeY) * 0.5;
                this.y0 = this.y1 - fSizeY;
                return this;
            };
            Rect2d.prototype.resizeX = function /** @inline */(fSize) {
                this.x1 = (this.x0 + this.x1 + fSize) * 0.5;
                this.x0 = this.x1 - fSize;
                return this;
            };
            Rect2d.prototype.resizeY = function /** @inline */(fSize) {
                this.y1 = (this.y0 + this.y1 + fSize) * 0.5;
                this.y0 = this.y1 - fSize;
                return this;
            };
            Rect2d.prototype.resizeMax = function /** @no-inline */(fSpanX, fSpanY) {
                if(arguments.length == 1) {
                    var v2fSpan = arguments[0];
                    this.x1 = this.x0 + v2fSpan.x;
                    this.y1 = this.y0 + v2fSpan.y;
                } else {
                    this.x1 = this.x0 + arguments[0];
                    this.y1 = this.y0 + arguments[1];
                }
                return this;
            };
            Rect2d.prototype.resizeMaxX = function /** @inline */(fSpan) {
                this.x1 = this.x0 + fSpan;
                return this;
            };
            Rect2d.prototype.resizeMaxY = function /** @inline */(fSpan) {
                this.y1 = this.y0 + fSpan;
                return this;
            };
            Rect2d.prototype.resizeMin = function /** @no-inline */(fSpanX, fSpanY) {
                if(arguments.length == 1) {
                    var v2fSpan = arguments[0];
                    this.x0 = this.x1 - v2fSpan.x;
                    this.y0 = this.y1 - v2fSpan.y;
                } else {
                    this.x0 = this.x1 - arguments[0];
                    this.y0 = this.y1 - arguments[1];
                }
                return this;
            };
            Rect2d.prototype.resizeMinX = function /** @inline */(fSpan) {
                this.x0 = this.x1 - fSpan;
                return this;
            };
            Rect2d.prototype.resizeMinY = function /** @inline */(fSpan) {
                this.y0 = this.y1 - fSpan;
                return this;
            };
            Rect2d.prototype.unionPoint = function /** @no-inline */(fX, fY) {
                if(arguments.length == 1) {
                    var v2fPoint = arguments[0];
                    this.x0 = akra.math.min(this.x0, v2fPoint.x);
                    this.x1 = akra.math.max(this.x1, v2fPoint.x);
                    this.y0 = akra.math.min(this.y0, v2fPoint.y);
                    this.y1 = akra.math.max(this.y1, v2fPoint.y);
                } else {
                    var fX = arguments[0];
                    var fY = arguments[1];
                    this.x0 = akra.math.min(this.x0, fX);
                    this.x1 = akra.math.max(this.x1, fX);
                    this.y0 = akra.math.min(this.y0, fY);
                    this.y1 = akra.math.max(this.y1, fY);
                }
                return this;
            };
            Rect2d.prototype.unionRect = function /** @no-inline */(pRect) {
                this.normalize();
                pRect.normalize();
                this.x0 = akra.math.min(this.x0, pRect.x0);
                this.x1 = akra.math.max(this.x1, pRect.x1);
                this.y0 = akra.math.min(this.y0, pRect.y0);
                this.y1 = akra.math.max(this.y1, pRect.y1);
                return this;
            };
            Rect2d.prototype.negate = function /** @no-inline */(pDestination) {
                if(!akra.isDef(pDestination)) {
                    pDestination = this;
                }
                return pDestination.set(-this.x1, -this.x0, -this.y1, -this.y0);
            };
            Rect2d.prototype.normalize = function /** @no-inline */() {
                var fTmp;
                if(this.x0 > this.x1) {
                    fTmp = this.x0;
                    this.x0 = this.x1;
                    this.x1 = fTmp;
                }
                if(this.y0 > this.y1) {
                    fTmp = this.y0;
                    this.y0 = this.y1;
                    this.y1 = fTmp;
                }
                return this;
            };
            Rect2d.prototype.isEqual = function /** @inline */(pRect) {
                return this.x0 == pRect.x0 && this.x1 == pRect.x1 && this.y0 == pRect.y0 && this.y1 == pRect.y1;
            };
            Rect2d.prototype.isClear = function /** @inline */() {
                return this.x0 == 0. && this.x1 == 0. && this.y0 == 0. && this.y1 == 0.;
            };
            Rect2d.prototype.isValid = function /** @inline */() {
                return this.x0 <= this.x1 && this.y0 <= this.y1;
            };
            Rect2d.prototype.isPointInRect = function /** @inline */(v2fPoint) {
                var x = v2fPoint.x;
                var y = v2fPoint.y;
                return (this.x0 <= x && x <= this.x1) && (this.y0 <= y && y <= this.y1);
            };
            Rect2d.prototype.midPoint = function /** @no-inline */(v2fDestination) {
                if(!akra.isDef(v2fDestination)) {
                    v2fDestination = new akra.Vec2();
                }
                v2fDestination.x = (this.x0 + this.x1) * 0.5;
                v2fDestination.y = (this.y0 + this.y1) * 0.5;
                return v2fDestination;
            };
            Rect2d.prototype.midX = function /** @inline */() {
                return (this.x0 + this.x1) * 0.5;
            };
            Rect2d.prototype.midY = function /** @inline */() {
                return (this.y0 + this.y1) * 0.5;
            };
            Rect2d.prototype.size = function /** @no-inline */(v2fDestination) {
                if(!akra.isDef(v2fDestination)) {
                    v2fDestination = new akra.Vec2();
                }
                v2fDestination.x = this.x1 - this.x0;
                v2fDestination.y = this.y1 - this.y0;
                return v2fDestination;
            };
            Rect2d.prototype.sizeX = function /** @inline */() {
                return this.x1 - this.x0;
            };
            Rect2d.prototype.sizeY = function /** @inline */() {
                return this.y1 - this.y0;
            };
            Rect2d.prototype.minPoint = function /** @no-inline */(v2fDestination) {
                if(!akra.isDef(v2fDestination)) {
                    v2fDestination = new akra.Vec2();
                }
                v2fDestination.x = this.x0;
                v2fDestination.y = this.y0;
                return v2fDestination;
            };
            Rect2d.prototype.maxPoint = function /** @no-inline */(v2fDestination) {
                if(!akra.isDef(v2fDestination)) {
                    v2fDestination = new akra.Vec2();
                }
                v2fDestination.x = this.x1;
                v2fDestination.y = this.y1;
                return v2fDestination;
            };
            Rect2d.prototype.area = function /** @inline */() {
                return (this.x1 - this.x0) * (this.y1 - this.y0);
            };
            Rect2d.prototype.corner = /**
            * counter-clockwise
            * x0,y0 -> x1,y0 -> x1,y1 -> x0,y1;
            */
            function /** @no-inline */(iIndex, v2fDestination) {
                if(!akra.isDef(v2fDestination)) {
                    v2fDestination = new akra.Vec2();
                }
                akra.logger.setSourceLocation("geometry/Rect2d.ts", 547);
                akra.logger.assert(0 <= iIndex && iIndex < 4, "invalid index");
                ;
                switch(iIndex) {
                    case 0:
                        v2fDestination.set(this.x0, this.y0);
                        break;
                    case 1:
                        v2fDestination.set(this.x1, this.y0);
                        break;
                    case 2:
                        v2fDestination.set(this.x1, this.y1);
                        break;
                    case 3:
                        v2fDestination.set(this.x0, this.y1);
                        break;
                }
                ;
                return v2fDestination;
            };
            Rect2d.prototype.createBoundingCircle = function /** @no-inline */(pCircle) {
                if(!akra.isDef(pCircle)) {
                    pCircle = new geometry.Circle();
                }
                var fX0 = this.x0, fX1 = this.x1;
                var fY0 = this.y0, fY1 = this.y1;
                var fHalfSizeX = (fX1 - fX0) * 0.5;
                var fHalfSizeY = (fY1 - fY0) * 0.5;
                pCircle.set((fX0 + fX1) * 0.5, (fY0 + fY1) * 0.5, akra.math.sqrt(fHalfSizeX * fHalfSizeX + fHalfSizeY * fHalfSizeY));
                return pCircle;
            };
            Rect2d.prototype.toString = function /** @no-inline */() {
                return "(" + this.x0 + ", " + this.y0 + ") --> (" + this.x1 + ", " + this.y1 + ")";
            };
            return Rect2d;
        })();
        geometry.Rect2d = Rect2d;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var ObjectArray = (function () {
            // set length(n: uint) {
            // 	if (this._bLock) {
            // 		return;
            // 	}
            // 	this.extend(n);
            // 	this._iLength = n;
            // }
            function /** @no-inline */ObjectArray(pElements) {
                /**@protected*/ this._pData = [];
                /**@protected*/ this._bLock = false;
                /**@protected*/ this._iLength = 0;
                if(arguments.length) {
                    this.fromArray(pElements);
                }
            }
            Object.defineProperty(ObjectArray.prototype, "length", {
                get: function /** @inline */() {
                    return this._iLength;
                },
                enumerable: true,
                configurable: true
            });
            ObjectArray.prototype.lock = function /** @inline */() {
                this._bLock = true;
            };
            ObjectArray.prototype.unlock = function /** @inline */() {
                this._bLock = false;
            };
            ObjectArray.prototype.isLocked = function /** @inline */() {
                return this._bLock;
            };
            ObjectArray.prototype.clear = function /** @no-inline */(bRemoveLinks) {
                if (typeof bRemoveLinks === "undefined") { bRemoveLinks = false; }
                util.logger.setSourceLocation("util/ObjectArray.ts", 47);
                util.logger.assert(!this._bLock, "cannot clear. array is locked.");
                ;
                this._iLength = 0;
                if(bRemoveLinks) {
                    for(var i = 0; i < this._pData.length; ++i) {
                        this._pData[i] = null;
                    }
                }
                return this;
            };
            ObjectArray.prototype.release = function /** @no-inline */() {
                this.clear(true);
                this._pData.clear();
                return this;
            };
            ObjectArray.prototype.value = function /** @inline */(n) {
                return this._pData[n];
            };
            ObjectArray.prototype.extend = function /** @no-inline */(n) {
                if(this._pData.length < n) {
                    // LOG("extending object array to > " + n);
                    for(var i = this._pData.length; i < n; ++i) {
                        this._pData[i] = null;
                    }
                }
            };
            ObjectArray.prototype.set = function /** @no-inline */(n, pData) {
                util.logger.setSourceLocation("util/ObjectArray.ts", 80);
                util.logger.assert(!this._bLock, "cannot clear. array is locked.");
                ;
                var N = n + 1;
                this.extend(N);
                if(this._iLength < N) {
                    this._iLength = N;
                }
                this._pData[n] = pData;
                return this;
            };
            ObjectArray.prototype.fromArray = function /** @no-inline */(pElements, iOffset, iSize) {
                if (typeof iOffset === "undefined") { iOffset = 0; }
                if (typeof iSize === "undefined") { iSize = 0; }
                util.logger.setSourceLocation("util/ObjectArray.ts", 96);
                util.logger.assert(!this._bLock, "cannot clear. array is locked.");
                ;
                iSize = iSize > 0 ? iSize < pElements.length ? iSize : pElements.length : pElements.length;
                this.extend(iSize);
                for(var i = iOffset, j = 0; i < iSize; ++i , ++j) {
                    this._pData[i] = pElements[j];
                }
                this._iLength = i;
                return this;
            };
            ObjectArray.prototype.push = function /** @inline */(pElement) {
                util.logger.setSourceLocation("util/ObjectArray.ts", 113);
                util.logger.assert(!this._bLock, "cannot clear. array is locked.");
                ;
                return this.set(this._iLength, pElement);
            };
            ObjectArray.prototype.pop = function /** @inline */() {
                util.logger.setSourceLocation("util/ObjectArray.ts", 119);
                util.logger.assert(!this._bLock, "cannot clear. array is locked.");
                ;
                return this._iLength > 0 ? this._pData[--this._iLength] : null;
            };
            ObjectArray.prototype.swap = function /** @inline */(i, j) {
                util.logger.setSourceLocation("util/ObjectArray.ts", 124);
                util.logger.assert(!this._bLock, "cannot clear. array is locked.");
                ;
                util.logger.setSourceLocation("util/ObjectArray.ts", 125);
                util.logger.assert(i < this._iLength && j < this._iLength, "invalid swap index.");
                ;
                this._pData.swap(i, j);
                return this;
            };
            return ObjectArray;
        })();
        util.ObjectArray = ObjectArray;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.ObjectArray = akra.util.ObjectArray;
})(akra || (akra = {}));
var akra;
(function (akra) {
    //#define DL_DEFAULT DEFAULT_NAME;
    (function (render) {
        var Viewport = (function () {
            function /** @no-inline */Viewport(pCamera, pTarget, csRenderMethod, fLeft, fTop, fWidth, fHeight, iZIndex) {
                if (typeof csRenderMethod === "undefined") { csRenderMethod = null; }
                if (typeof fLeft === "undefined") { fLeft = 0.; }
                if (typeof fTop === "undefined") { fTop = 0.; }
                if (typeof fWidth === "undefined") { fWidth = 1.; }
                if (typeof fHeight === "undefined") { fHeight = 1.; }
                if (typeof iZIndex === "undefined") { iZIndex = 0; }
                /**@protected*/ this._cBackColor = new akra.Color(akra.Color.BLACK);
                /**@protected*/ this._fDepthClearValue = 1.;
                /**@protected*/ this._bClearEveryFrame = true;
                /**@protected*/ this._iClearBuffers = 1 /* COLOR */  | 2 /* DEPTH */ ;
                /**@protected*/ this._bUpdated = false;
                // protected _bShowOverlays: bool = true;
                // protected _bShowSkies: bool = true;
                // protected _bShowShadows: bool = true;
                /**@protected*/ this._iVisibilityMask = 0xFFFFFFFF;
                // protected _sRQSequenceName: string;
                // protected mRQSequence: RenderQueueInvocationSequence;
                /**@protected*/ this.sMaterialSchemeName = akra.DEFAULT_MATERIAL_NAME;
                // static _eDefaultOrientationMode: EOrientationModes;
                /**@protected*/ this._isAutoUpdated = true;
                /**@protected*/ this._csDefaultRenderMethod = null;
                this._iGuid = eval("this._iGuid || akra.sid()");
                this._pUnicastSlotMap = null;
                this._pBroadcastSlotList = null;
                this._pTarget = pTarget;
                this._fRelLeft = fLeft;
                this._fRelTop = fTop;
                this._fRelWidth = fWidth;
                this._fRelHeight = fHeight;
                this._iZIndex = iZIndex;
                this._csDefaultRenderMethod = csRenderMethod;
                this._updateDimensions();
                this._setCamera(pCamera);
            }
            Object.defineProperty(Viewport.prototype, "zIndex", {
                get: function /** @inline */() {
                    return this._iZIndex;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "left", {
                get: function /** @inline */() {
                    return this._fRelLeft;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "top", {
                get: function /** @inline */() {
                    return this._fRelTop;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "width", {
                get: function /** @inline */() {
                    return this._fRelWidth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "height", {
                get: function /** @inline */() {
                    return this._fRelHeight;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "actualLeft", {
                get: function /** @inline */() {
                    return this._iActLeft;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "actualTop", {
                get: function /** @inline */() {
                    return this._iActTop;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "actualWidth", {
                get: function /** @inline */() {
                    return this._iActWidth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "actualHeight", {
                get: function /** @inline */() {
                    return this._iActHeight;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "backgroundColor", {
                get: function /** @inline */() {
                    return this._cBackColor;
                },
                set: function /** @inline */(cColor) {
                    this._cBackColor = cColor;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Viewport.prototype, "depthClear", {
                get: function /** @inline */() {
                    return this._fDepthClearValue;
                },
                set: function /** @inline */(fDepthClearValue) {
                    this._fDepthClearValue = fDepthClearValue;
                },
                enumerable: true,
                configurable: true
            });
            Viewport.prototype.destroy = function /** @no-inline */() {
                var pRenderer = this._pTarget.getRenderer();
                if(pRenderer && pRenderer._getViewport() === this) {
                    pRenderer._setViewport(null);
                }
            };
            Viewport.prototype.clear = function /** @no-inline */(iBuffers, cColor, iDepth) {
                if (typeof iBuffers === "undefined") { iBuffers = 1; }
                if (typeof cColor === "undefined") { cColor = akra.Color.BLACK; }
                if (typeof iDepth === "undefined") { iDepth = 1.; }
                var pRenderer = this._pTarget.getRenderer();
                if(pRenderer) {
                    var pCurrentViewport = pRenderer._getViewport();
                    if(pCurrentViewport && pCurrentViewport == this) {
                        pRenderer.clearFrameBuffer(iBuffers, cColor, iDepth);
                    } else if(pCurrentViewport) {
                        pRenderer._setViewport(this);
                        pRenderer.clearFrameBuffer(iBuffers, cColor, iDepth);
                        pRenderer._setViewport(pCurrentViewport);
                    }
                }
            };
            Viewport.prototype.getTarget = function /** @inline */() {
                return this._pTarget;
            };
            Viewport.prototype.getCamera = function /** @inline */() {
                return this._pCamera;
            };
            Viewport.prototype.setCamera = function /** @no-inline */(pCamera) {
                if(this._pCamera) {
                    if(this._pCamera._getLastViewport() == this) {
                        this._pCamera._keepLastViewport(null);
                    }
                }
                if(this._pCamera) {
                    // update aspect ratio of new camera if needed.
                    if(!pCamera.isConstantAspect()) {
                        pCamera.aspect = (this._iActWidth / this._iActHeight);
                    }
                }
                this._setCamera(pCamera);
                this.viewportCameraChanged();
                return true;
            };
            Viewport.prototype._setCamera = /**@protected*/ function /** @no-inline */(pCamera) {
                this._pCamera = pCamera;
                if(pCamera) {
                    pCamera._keepLastViewport(this);
                }
            };
            Viewport.prototype.setDimensions = function /** @no-inline */(fLeft, fTop, fWidth, fHeight) {
                var pRect;
                if(akra.isNumber(arguments[0])) {
                    this._fRelLeft = fLeft;
                    this._fRelTop = fTop;
                    this._fRelWidth = fWidth;
                    this._fRelHeight = fHeight;
                } else {
                    pRect = arguments[0];
                    this._fRelLeft = pRect.left;
                    this._fRelTop = pRect.top;
                    this._fRelWidth = pRect.width;
                    this._fRelHeight = pRect.height;
                }
                this._updateDimensions();
                return true;
            };
            Viewport.prototype.getActualDimensions = function /** @no-inline */() {
                return new akra.geometry.Rect2d(this._iActLeft, this._iActTop, this._iActWidth, this._iActHeight);
            };
            Viewport.prototype.setClearEveryFrame = //iBuffers=FBT_COLOUR|FBT_DEPTH
            function /** @no-inline */(isClear, iBuffers) {
                this._bClearEveryFrame = isClear;
                this._iClearBuffers = iBuffers;
            };
            Viewport.prototype.getClearEveryFrame = function /** @inline */() {
                return this._bClearEveryFrame;
            };
            Viewport.prototype.getClearBuffers = function /** @inline */() {
                return this._iClearBuffers;
            };
            Viewport.prototype.setAutoUpdated = function /** @inline */(bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                this._isAutoUpdated = bValue;
            };
            Viewport.prototype.isAutoUpdated = function /** @inline */() {
                return this._isAutoUpdated;
            };
            Viewport.prototype._updateDimensions = function /** @no-inline */() {
                var fHeight = this._pTarget.height;
                var fWidth = this._pTarget.width;
                this._iActLeft = (this._fRelLeft * fWidth);
                this._iActTop = (this._fRelTop * fHeight);
                this._iActWidth = (this._fRelWidth * fWidth);
                this._iActHeight = (this._fRelHeight * fHeight);
                // This will check if the cameras getAutoAspectRatio() property is set.
                // If it's true its aspect ratio is fit to the current viewport
                // If it's false the camera remains unchanged.
                // This allows cameras to be used to render to many viewports,
                // which can have their own dimensions and aspect ratios.
                if(this._pCamera) {
                    if(!this._pCamera.isConstantAspect()) {
                        this._pCamera.aspect = (this._iActWidth / this._iActHeight);
                    }
                }
                this._bUpdated = true;
                this.viewportDimensionsChanged();
            };
            Viewport.prototype.update = function /** @no-inline */() {
                if(this._pCamera) {
                    this.renderAsNormal(this._csDefaultRenderMethod, this._pCamera);
                }
            };
            Viewport.prototype.renderAsNormal = /**@protected*/ function /** @no-inline */(csMethod, pCamera) {
                var pVisibleObjects = pCamera.display();
                var pRenderable;
                for(var i = 0; i < pVisibleObjects.length; ++i) {
                    pRenderable = pVisibleObjects.value(i).getRenderable();
                    if(!akra.isNull(pRenderable)) {
                        pRenderable.render(csMethod);
                    }
                }
            };
            Viewport.prototype.isUpdated = function /** @inline */() {
                return this._bUpdated;
            };
            Viewport.prototype._clearUpdatedFlag = function /** @inline */() {
                this._bUpdated = false;
            };
            Viewport.prototype._getNumRenderedPolygons = function /** @no-inline */() {
                return this._pCamera ? this._pCamera._getNumRenderedFaces() : 0;
            };
            Viewport._pEventTable = new akra.events.EventTable();
            Viewport.prototype.getEventTable = function /** @inline */() {
                return Viewport._pEventTable;
            };
            Viewport.prototype.getGuid = function /** @no-inline */() {
                return this._iGuid < 0 ? (this._iGuid = akra.sid()) : this._iGuid;
            };
            Viewport.prototype.connect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            Viewport.prototype.disconnect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            Viewport.prototype.bind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType);
            };
            Viewport.prototype.unbind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType);
            };
            Viewport.prototype.viewportDimensionsChanged = function /** @no-inline */() {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).viewportDimensionsChanged;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            Viewport.prototype.viewportCameraChanged = function /** @no-inline */() {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).viewportCameraChanged;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            return Viewport;
        })();
        render.Viewport = Viewport;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        var LightData = (function () {
            function LightData() {
                this.DIFFUSE = new akra.Vec4();
                this.AMBIENT = new akra.Vec4();
                this.SPECULAR = new akra.Vec4();
                this.POSITION = new akra.Vec3();
                this.ATTENUATION = new akra.Vec3();
            }
            LightData.prototype.set = function /** @no-inline */(pLightParam, v3fPosition) {
                this.DIFFUSE.set(pLightParam.diffuse);
                this.AMBIENT.set(pLightParam.ambient);
                this.SPECULAR.set(pLightParam.specular);
                this.ATTENUATION.set(pLightParam.attenuation);
                this.POSITION.set(v3fPosition);
                return this;
            };
            return LightData;
        })();
        render.LightData = LightData;        
        ;
        var UniformOmni = (function () {
            function UniformOmni() {
                this.LIGHT_DATA = new LightData();
            }
            UniformOmni.prototype.setLightData = function /** @no-inline */(pLightParam, v3fPosition) {
                this.LIGHT_DATA.set(pLightParam, v3fPosition);
                return this;
            };
            Object.defineProperty(UniformOmni, "stackCeil", {
                get: function /** @no-inline */() {
                    UniformOmni.stackPosition = UniformOmni.stackPosition === UniformOmni.stackSize - 1 ? 0 : UniformOmni.stackPosition;
                    return UniformOmni.stack[UniformOmni.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            UniformOmni.stackSize = 200;
            UniformOmni.stackPosition = 0;
            UniformOmni.stack = (function /** @no-inline */() {
                var pStack = new Array(UniformOmni.stackSize);
                for(var i = 0; i < UniformOmni.stackSize; i++) {
                    pStack[i] = new UniformOmni();
                }
                return pStack;
            })();
            return UniformOmni;
        })();
        render.UniformOmni = UniformOmni;        
        ;
        var UniformProject = (function () {
            function UniformProject() {
                this.LIGHT_DATA = new LightData();
                this.SHADOW_MATRIX = new akra.Mat4();
            }
            UniformProject.prototype.setLightData = function /** @no-inline */(pLightParam, v3fPosition) {
                this.LIGHT_DATA.set(pLightParam, v3fPosition);
                return this;
            };
            UniformProject.prototype.setMatrix = function /** @no-inline */(m4fMatrix) {
                this.SHADOW_MATRIX.set(m4fMatrix);
                return this;
            };
            Object.defineProperty(UniformProject, "stackCeil", {
                get: function /** @no-inline */() {
                    UniformProject.stackPosition = UniformProject.stackPosition === UniformProject.stackSize - 1 ? 0 : UniformProject.stackPosition;
                    return UniformProject.stack[UniformProject.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            UniformProject.stackSize = 200;
            UniformProject.stackPosition = 0;
            UniformProject.stack = (function /** @no-inline */() {
                var pStack = new Array(UniformProject.stackSize);
                for(var i = 0; i < UniformProject.stackSize; i++) {
                    pStack[i] = new UniformProject();
                }
                return pStack;
            })();
            return UniformProject;
        })();
        render.UniformProject = UniformProject;        
        ;
        var UniformProjectShadow = (function () {
            function UniformProjectShadow() {
                this.LIGHT_DATA = new LightData();
                this.TO_LIGHT_SPACE = new akra.Mat4();
                this.REAL_PROJECTION_MATRIX = new akra.Mat4();
                this.OPTIMIZED_PROJECTION_MATRIX = new akra.Mat4();
                this.SHADOW_SAMPLER = {
                    TEXTURE: null
                };
            }
            UniformProjectShadow.prototype.setLightData = function /** @no-inline */(pLightParam, v3fPosition) {
                this.LIGHT_DATA.set(pLightParam, v3fPosition);
                return this;
            };
            UniformProjectShadow.prototype.setMatrix = function /** @no-inline */(m4fToLightSpace, m4fRealProj, m4fOptimizedProj) {
                this.TO_LIGHT_SPACE.set(m4fToLightSpace);
                this.REAL_PROJECTION_MATRIX.set(m4fRealProj);
                this.OPTIMIZED_PROJECTION_MATRIX.set(m4fOptimizedProj);
                return this;
            };
            UniformProjectShadow.prototype.setSampler = function /** @no-inline */(sTexture) {
                this.SHADOW_SAMPLER.TEXTURE = sTexture;
                return this;
            };
            Object.defineProperty(UniformProjectShadow, "stackCeil", {
                get: function /** @no-inline */() {
                    UniformProjectShadow.stackPosition = UniformProjectShadow.stackPosition === UniformProjectShadow.stackSize - 1 ? 0 : UniformProjectShadow.stackPosition;
                    return UniformProjectShadow.stack[UniformProjectShadow.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            UniformProjectShadow.stackSize = 20;
            UniformProjectShadow.stackPosition = 0;
            UniformProjectShadow.stack = (function /** @no-inline */() {
                var pStack = new Array(UniformProjectShadow.stackSize);
                for(var i = 0; i < UniformProjectShadow.stackSize; i++) {
                    pStack[i] = new UniformProjectShadow();
                }
                return pStack;
            })();
            return UniformProjectShadow;
        })();
        render.UniformProjectShadow = UniformProjectShadow;        
        var UniformOmniShadow = (function () {
            function UniformOmniShadow() {
                this.LIGHT_DATA = new LightData();
                this.TO_LIGHT_SPACE = [
                    new akra.Mat4(), 
                    new akra.Mat4(), 
                    new akra.Mat4(), 
                    new akra.Mat4(), 
                    new akra.Mat4(), 
                    new akra.Mat4()
                ];
                this.OPTIMIZED_PROJECTION_MATRIX = [
                    new akra.Mat4(), 
                    new akra.Mat4(), 
                    new akra.Mat4(), 
                    new akra.Mat4(), 
                    new akra.Mat4(), 
                    new akra.Mat4()
                ];
                this.SHADOW_SAMPLER = [
                    {
                        "TEXTURE": null
                    }, 
                    {
                        "TEXTURE": null
                    }, 
                    {
                        "TEXTURE": null
                    }, 
                    {
                        "TEXTURE": null
                    }, 
                    {
                        "TEXTURE": null
                    }, 
                    {
                        "TEXTURE": null
                    }
                ];
            }
            UniformOmniShadow.prototype.setLightData = function /** @no-inline */(pLightParam, v3fPosition) {
                this.LIGHT_DATA.set(pLightParam, v3fPosition);
                return this;
            };
            UniformOmniShadow.prototype.setMatrix = function /** @no-inline */(m4fToLightSpace, m4fOptimizedProj, index) {
                this.TO_LIGHT_SPACE[index].set(m4fToLightSpace);
                this.OPTIMIZED_PROJECTION_MATRIX[index].set(m4fOptimizedProj);
                return this;
            };
            UniformOmniShadow.prototype.setSampler = function /** @no-inline */(sTexture, index) {
                this.SHADOW_SAMPLER[index].TEXTURE = sTexture;
                return this;
            };
            Object.defineProperty(UniformOmniShadow, "stackCeil", {
                get: function /** @no-inline */() {
                    UniformOmniShadow.stackPosition = UniformOmniShadow.stackPosition === UniformOmniShadow.stackSize - 1 ? 0 : UniformOmniShadow.stackPosition;
                    return UniformOmniShadow.stack[UniformOmniShadow.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            UniformOmniShadow.stackSize = 3;
            UniformOmniShadow.stackPosition = 0;
            UniformOmniShadow.stack = (function /** @no-inline */() {
                var pStack = new Array(UniformOmniShadow.stackSize);
                for(var i = 0; i < UniformOmniShadow.stackSize; i++) {
                    pStack[i] = new UniformOmniShadow();
                }
                return pStack;
            })();
            return UniformOmniShadow;
        })();
        render.UniformOmniShadow = UniformOmniShadow;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        var RenderTechnique = (function () {
            function /** @no-inline */RenderTechnique(pMethod) {
                if (typeof pMethod === "undefined") { pMethod = null; }
                this._iGuid = eval("this._iGuid || akra.sid()");
                this._pUnicastSlotMap = null;
                this._pBroadcastSlotList = null;
                this._pMethod = pMethod;
            }
            Object.defineProperty(RenderTechnique.prototype, "modified", {
                get: function /** @no-inline */() {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderTechnique.prototype, "totalPasses", {
                get: function /** @no-inline */() {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });
            RenderTechnique.prototype.destroy = function /** @no-inline */() {
            };
            RenderTechnique.prototype.getPass = function /** @no-inline */(n) {
                return null;
            };
            RenderTechnique.prototype.getMethod = function /** @no-inline */() {
                return null;
            };
            RenderTechnique.prototype.setMethod = function /** @no-inline */(pMethod) {
            };
            RenderTechnique.prototype.setState = function /** @no-inline */(sName, pValue) {
            };
            RenderTechnique.prototype.setForeign = function /** @no-inline */(sName, pValue) {
            };
            RenderTechnique.prototype.setStruct = function /** @no-inline */(sName, pValue) {
            };
            RenderTechnique.prototype.setTextureBySemantics = function /** @no-inline */(sName, pValue) {
            };
            RenderTechnique.prototype.setShadowSamplerArray = function /** @no-inline */(sName, pValue) {
            };
            RenderTechnique.prototype.setVec2BySemantic = function /** @no-inline */(sName, pValue) {
            };
            RenderTechnique.prototype.isReady = function /** @no-inline */() {
                return false;
            };
            RenderTechnique._pEventTable = new akra.events.EventTable();
            RenderTechnique.prototype.getEventTable = function /** @inline */() {
                return RenderTechnique._pEventTable;
            };
            RenderTechnique.prototype.getGuid = function /** @no-inline */() {
                return this._iGuid < 0 ? (this._iGuid = akra.sid()) : this._iGuid;
            };
            RenderTechnique.prototype.connect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            RenderTechnique.prototype.disconnect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            RenderTechnique.prototype.bind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType);
            };
            RenderTechnique.prototype.unbind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType);
            };
            RenderTechnique.prototype.render = function /** @no-inline */() {
                var _recivier = this;
                this._pUnicastSlotMap = this._pUnicastSlotMap || this.getEventTable().findUnicastList(this._iGuid);
                var _unicast = (this._pUnicastSlotMap).render;
                if(akra.isDef(_unicast)) {
                    _unicast.target ? _unicast.target[_unicast.callback](_recivier) : _unicast.listener(_recivier);
                }
            };
            return RenderTechnique;
        })();
        render.RenderTechnique = RenderTechnique;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        var RenderableObject = (function () {
            function /** @no-inline */RenderableObject() {
                /**@protected*/ this._pTechnique = null;
                /**@protected*/ this._pTechniqueMap = {
                };
                /**@protected*/ this._bShadow = false;
                this._iGuid = eval("this._iGuid || akra.sid()");
                this._pUnicastSlotMap = null;
                this._pBroadcastSlotList = null;
            }
            Object.defineProperty(RenderableObject.prototype, "renderMethod", {
                get: function /** @inline */() {
                    return this._pTechnique.getMethod();
                },
                set: function /** @inline */(pMethod) {
                    this.switchRenderMethod(pMethod);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderableObject.prototype, "effect", {
                get: function /** @inline */() {
                    return this._pTechnique.getMethod().effect;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderableObject.prototype, "surfaceMaterial", {
                get: function /** @inline */() {
                    return this._pTechnique.getMethod().surfaceMaterial;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderableObject.prototype, "material", {
                get: function /** @inline */() {
                    return this.surfaceMaterial.material;
                },
                enumerable: true,
                configurable: true
            });
            RenderableObject.prototype._setup = function /** @no-inline */(pRenderer, csDefaultMethod) {
                if (typeof csDefaultMethod === "undefined") { csDefaultMethod = null; }
                this._pRenderer = pRenderer;
                if(this.addRenderMethod(csDefaultMethod) || this.switchRenderMethod(null) === false) {
                    akra.logger.setSourceLocation("RenderableObject.ts", 44);
                    akra.logger.criticalError("cannot add & switch render method to default");
                    ;
                }
            };
            RenderableObject.prototype.getRenderer = function /** @inline */() {
                return this._pRenderer;
            };
            RenderableObject.prototype.destroy = function /** @no-inline */() {
                this._pRenderer = null;
                this._pTechnique = null;
                for(var i in this._pTechniqueMap) {
                    this._pTechniqueMap[i].destroy();
                }
                this._pTechniqueMap = null;
            };
            RenderableObject.prototype.addRenderMethod = function /** @no-inline */(csMethod, csName) {
                if (typeof csName === "undefined") { csName = "default"; }
                var pTechnique = new render.RenderTechnique();
                var pRmgr = this.getRenderer().getEngine().getResourceManager();
                var pMethod = null;
                if(akra.isNull(csMethod)) {
                    return false;
                }
                if(akra.isString(arguments[0])) {
                    pMethod = pRmgr.createRenderMethod((csMethod) + this.getGuid());
                    if(!akra.isDefAndNotNull(pMethod)) {
                        return false;
                    }
                    //adding empty, but NOT NULL effect & material
                    pMethod.surfaceMaterial = pRmgr.createSurfaceMaterial(csMethod + ".material." + this.getGuid());
                    pMethod.effect = pRmgr.createEffect(csMethod + ".effect." + this.getGuid());
                } else {
                    pMethod = arguments[0];
                }
                akra.logger.setSourceLocation("RenderableObject.ts", 91);
                akra.logger.assert(pMethod.getManager().getEngine().getRenderer() === this._pRenderer, "Render method should belong to the same engine instance that the renderable object.");
                ;
                pTechnique.setMethod(pMethod);
                //pTechnique.name = csName || DEFAULT_RT;
                this._pTechniqueMap[csName || "default"] = pTechnique;
                return true;
            };
            RenderableObject.prototype.switchRenderMethod = function /** @no-inline */(csName) {
                var pTechnique;
                var sName = null;
                if(akra.isString(arguments[0])) {
                    sName = csName;
                } else if(akra.isDefAndNotNull(arguments[0])) {
                    sName = (arguments[0]).findResourceName();
                    if(!akra.isDefAndNotNull(this._pTechniqueMap[sName])) {
                        if(!this.addRenderMethod(arguments[0], sName)) {
                            return false;
                        }
                    }
                }
                pTechnique = this._pTechniqueMap[sName];
                if(akra.isDefAndNotNull(pTechnique)) {
                    this._pTechnique = pTechnique;
                    return true;
                }
                return false;
            };
            RenderableObject.prototype.removeRenderMethod = function /** @no-inline */(csName) {
                var pTechnique = this._pTechniqueMap[csName];
                if(akra.isDefAndNotNull(pTechnique)) {
                    delete this._pTechniqueMap[csName || "default"];
                    return true;
                }
                return false;
            };
            RenderableObject.prototype.getRenderMethod = function /** @inline */(csName) {
                if (typeof csName === "undefined") { csName = null; }
                var pTechnique = this._pTechniqueMap[csName || "default"];
                return pTechnique ? pTechnique.getMethod() : null;
            };
            RenderableObject.prototype.hasShadow = function /** @inline */() {
                return this._bShadow;
            };
            RenderableObject.prototype.setShadow = function /** @no-inline */(bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                if(this._bShadow != bValue) {
                    this._bShadow = bValue;
                    this.shadow(bValue);
                }
            };
            RenderableObject.prototype.isReadyForRender = function /** @inline */() {
                return this._pTechnique.isReady();
            };
            RenderableObject.prototype.isAllMethodsLoaded = function /** @no-inline */() {
                for(var i in this._pTechniqueMap) {
                    var pMethod = this._pTechniqueMap[i].getMethod();
                    if(!akra.isDefAndNotNull(pMethod) || !pMethod.isResourceLoaded()) {
                        return false;
                    }
                }
                return true;
            };
            RenderableObject.prototype.render = function /** @no-inline */(csMethod) {
                if (typeof csMethod === "undefined") { csMethod = null; }
                //TODO("DRAW!!!!");
                akra.logger.setSourceLocation("RenderableObject.ts", 178);
                akra.logger.error("TODO(DRAW!!)");
                ;
            };
            RenderableObject.prototype.getTechnique = function /** @no-inline */(sName) {
                if (typeof sName === "undefined") { sName = null; }
                return this._pTechniqueMap[sName] || null;
            };
            RenderableObject.prototype._draw = function /** @no-inline */() {
                akra.logger.setSourceLocation("RenderableObject.ts", 186);
                akra.logger.error("RenderableObject::_draw() pure virtual method() isn't callable!!");
                ;
            };
            RenderableObject._pEventTable = new akra.events.EventTable();
            RenderableObject.prototype.getEventTable = function /** @inline */() {
                return RenderableObject._pEventTable;
            };
            RenderableObject.prototype.getGuid = function /** @no-inline */() {
                return this._iGuid < 0 ? (this._iGuid = akra.sid()) : this._iGuid;
            };
            RenderableObject.prototype.connect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            RenderableObject.prototype.disconnect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            RenderableObject.prototype.bind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType);
            };
            RenderableObject.prototype.unbind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType);
            };
            RenderableObject.prototype.shadow = function /** @no-inline */(bValue) {
                var _recivier = this;
                this._pUnicastSlotMap = this._pUnicastSlotMap || this.getEventTable().findUnicastList(this._iGuid);
                var _unicast = (this._pUnicastSlotMap).shadow;
                if(akra.isDef(_unicast)) {
                    _unicast.target ? _unicast.target[_unicast.callback](_recivier, bValue) : _unicast.listener(_recivier, bValue);
                }
            };
            return RenderableObject;
        })();
        render.RenderableObject = RenderableObject;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        var DSViewport = (function (_super) {
            __extends(DSViewport, _super);
            function /** @no-inline */DSViewport(pCamera, pTarget, csRenderMethod, fLeft, fTop, fWidth, fHeight, iZIndex) {
                if (typeof csRenderMethod === "undefined") { csRenderMethod = null; }
                if (typeof fLeft === "undefined") { fLeft = 0.; }
                if (typeof fTop === "undefined") { fTop = 0.; }
                if (typeof fWidth === "undefined") { fWidth = 1.; }
                if (typeof fHeight === "undefined") { fHeight = 1.; }
                if (typeof iZIndex === "undefined") { iZIndex = 0; }
                        _super.call(this, pCamera, pTarget, null, fLeft, fTop, fWidth, fHeight, iZIndex);
                this._pDeferredView = null;
                this._pDeferredSkyTexture = null;
                this._pLightingUnifoms = {
                    omni: [],
                    project: [],
                    omniShadows: [],
                    projectShadows: [],
                    textures: [],
                    samplersOmni: [],
                    samplersProject: []
                };
                this._pLightPoints = null;
                var pEngine = this.getTarget().getRenderer().getEngine();
                var pResMgr = pEngine.getResourceManager();
                var pDeferredData = new Array(2);
                var pDeferredTextures = new Array(2);
                var pDepthTexture;
                var pDefferedView = this._pDeferredView = new akra.render.RenderableObject();
                var iGuid = akra.sid();
                var iWidth = akra.math.ceilingPowerOfTwo(this.actualWidth);
                var iHeight = akra.math.ceilingPowerOfTwo(this.actualHeight);
                if(akra.info.browser.name === "Firefox") {
                    iWidth = akra.math.min(iWidth, 1024);
                    iHeight = akra.math.min(iHeight, 1024);
                }
                pDepthTexture = this._pDeferredDepthTexture = pResMgr.createTexture("deferred-depth-texture-" + iGuid);
                pDepthTexture.create(iWidth, iHeight, 1, null, 0, 0, 3553 /* TEXTURE_2D */ , 29 /* DEPTH */ );
                for(var i = 0; i < 2; ++i) {
                    pDeferredTextures[i] = this._pDefferedColorTextures[i] = pResMgr.createTexture("deferred-color-texture-" + i + "-" + iGuid);
                    pDeferredTextures[i].create(iWidth, iHeight, 1, null, 0, 0, 3553 /* TEXTURE_2D */ , 25 /* FLOAT32_RGBA */ );
                    pDeferredData[i] = pDeferredTextures[i].getBuffer().getRenderTarget();
                    pDeferredData[i].addViewport(this.getCamera(), "deferred_shading_pass_" + i);
                    pDeferredData[i].attachDepthTexture(pDepthTexture);
                }
                //TODO >>>
                // pResMgr.loadAFXEffect("prepare_deferred_shading.afx");
                // pResMgr.loadAFXEffect("base_deferred_shading.afx");
                // pResMgr.loadAFXEffect("lights_and_shadows_deferred_shading.afx");
                // pResMgr.loadAFXEffect("skybox_deferred_shading.afx");
                // pResMgr.loadAFXEffect("fxaa_deferred_shading.afx");
                var pDSMethod = pResMgr.createRenderMethod(".deferred_shading");
                var pDSEffect = pResMgr.createEffect(".deferred_shading");
                // pDSEffect.addComponent("akra.system.prepareForDeferredShading");
                pDSEffect.addComponent("akra.system.deferredShading");
                pDSEffect.addComponent("akra.system.omniLighting");
                pDSEffect.addComponent("akra.system.projectLighting");
                pDSEffect.addComponent("akra.system.omniShadowsLighting");
                pDSEffect.addComponent("akra.system.projectShadowsLighting");
                pDSEffect.addComponent("akra.system.skybox", 1);
                pDSMethod.effect = pDSEffect;
                pDefferedView.renderMethod = pDSMethod;
                this.connect(pDefferedView.getTechnique(), "render", "_onRender");
            }
            DSViewport.prototype.update = function /** @no-inline */() {
                this.prepareForDeferredShading();
                var pLights = this.getCamera().display(1);
                for(var i = 0; i < pLights.length; i++) {
                    pLights[i]._calculateShadows();
                }
                this._pLightPoints = pLights;
                //prepare deferred textures
                this._pDefferedColorTextures[0].getBuffer().getRenderTarget().update();
                this._pDefferedColorTextures[1].getBuffer().getRenderTarget().update();
                //render defferred
                this._pDeferredView.render();
                return true;
            };
            DSViewport.prototype.prepareForDeferredShading = function /** @no-inline */() {
                var pNodeList = this.getCamera().display();
                for(var i = 0; i < pNodeList.length; ++i) {
                    var pRenderable = pNodeList.value(i).getRenderable();
                    if(pRenderable) {
                        for(var j = 0; j < 2; ++j) {
                            var sMethod = "deferred_shading_pass_" + j;
                            var pMethod = pRenderable.getRenderMethod(sMethod);
                            var pTechCurr = pRenderable.getTechnique();
                            var pTechnique = pRenderable.getTechnique(sMethod);
                            if(akra.isNull(pTechnique) || pTechCurr.modified >= pTechnique.modified) {
                                if(!pRenderable.addRenderMethod(pRenderable.getRenderMethod(), sMethod)) {
                                    akra.logger.setSourceLocation("DSViewport2.ts", 138);
                                    akra.logger.criticalError("cannot clone active render method");
                                    ;
                                }
                                pTechnique = pRenderable.getTechnique(sMethod);
                                for(var k = 0; k < pTechnique.totalPasses; ++k) {
                                    var pPass = pTechnique.getPass(k);
                                    if(akra.isNull(pPass.getRenderTarget())) {
                                        pPass.data.blend("akra.system.prepareForDeferredShading.pass" + j);
                                    }
                                }
                            }
                        }
                    }
                }
                ;
            };
            DSViewport.prototype.setSkybox = function /** @no-inline */(pSkyTexture) {
                if(pSkyTexture.textureType !== 34067 /* TEXTURE_CUBE_MAP */ ) {
                    return null;
                }
                this._pDeferredSkyTexture = pSkyTexture;
                return true;
            };
            DSViewport.prototype.setFXAA = function /** @no-inline */(bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                var pEffect = this._pDeferredView.renderMethod.effect;
                if(bValue) {
                    pEffect.addComponent("akra.system.fxaa", 2);
                } else {
                    pEffect.delComponent("akra.system.fxaa", 2);
                }
            };
            DSViewport.prototype.destroy = function /** @no-inline */() {
                _super.prototype.destroy.call(this);
                this._pDeferredDepthTexture.destroyResource();
                this._pDefferedColorTextures[0].destroyResource();
                this._pDefferedColorTextures[1].destroyResource();
                this._pDeferredView.destroy();
                this._pDeferredView = null;
                this._pDeferredSkyTexture = null;
            };
            DSViewport.prototype._onRender = function /** @no-inline */(pTechnique, iPass) {
                switch(iPass) {
                    case 2:
                        var pLightUniforms = this._pLightingUnifoms;
                        var pLightPoints = this._pLightPoints;
                        var pCamera = this.getCamera();
                        var pDepthTexture = this._pDeferredDepthTexture;
                        var pDeferredTextures = this._pDefferedColorTextures;
                        this.createLightingUniforms(pCamera, pLightPoints, pLightUniforms);
                        pTechnique.setState("lights.omni", pLightUniforms.omni.length);
                        pTechnique.setState("lights.project", pLightUniforms.project.length);
                        pTechnique.setState("lights.omniShadows", pLightUniforms.omniShadows.length);
                        pTechnique.setState("lights.projectShadows", pLightUniforms.projectShadows.length);
                        pTechnique.setForeign("nOmni", pLightUniforms.omni.length);
                        pTechnique.setForeign("nProject", pLightUniforms.project.length);
                        pTechnique.setForeign("nOmniShadows", pLightUniforms.omniShadows.length);
                        pTechnique.setForeign("nProjectShadows", pLightUniforms.projectShadows.length);
                        pTechnique.setStruct("points_omni", pLightUniforms.omni);
                        pTechnique.setStruct("points_project", pLightUniforms.project);
                        pTechnique.setStruct("points_omni_shadows", pLightUniforms.omniShadows);
                        pTechnique.setStruct("points_project_shadows", pLightUniforms.projectShadows);
                        for(var i = 0; i < pLightUniforms.textures.length; i++) {
                            pTechnique.setTextureBySemantics("TEXTURE" + i, pLightUniforms.textures[i]);
                        }
                        pTechnique.setShadowSamplerArray("project_shadow_sampler", pLightUniforms.samplersProject);
                        pTechnique.setShadowSamplerArray("omni_shadow_sampler", pLightUniforms.samplersOmni);
                        pTechnique.setVec2BySemantic("SCREEN_TEXTURE_RATIO", akra.vec2(this.actualWidth / pDepthTexture.width, this.actualHeight / pDepthTexture.height));
                        pTechnique.setTextureBySemantics("DEFERRED_TEXTURE0", pDeferredTextures[0]);
                        pTechnique.setTextureBySemantics("DEFERRED_TEXTURE1", pDeferredTextures[1]);
                        pTechnique.setTextureBySemantics("SCENE_DEPTH_TEXTURE", pDepthTexture);
                        break;
                        //case 1;
                                        }
            };
            DSViewport.prototype.resetUniforms = function /** @inline */() {
                var pUniforms = this._pLightingUnifoms;
                pUniforms.omni.clear();
                pUniforms.project.clear();
                pUniforms.omniShadows.clear();
                pUniforms.projectShadows.clear();
                pUniforms.textures.clear();
                pUniforms.samplersProject.clear();
                pUniforms.samplersOmni.clear();
            };
            DSViewport.prototype.createLightingUniforms = function /** @no-inline */(pCamera, pLightPoints, pUniforms) {
                var pLight;
                var pOmniLight;
                var pProjectLight;
                var i, j;
                var pUniformData;
                var pCameraView = pCamera.viewMatrix;
                var v4fLightPosition = akra.vec4();
                var v3fLightTransformPosition = akra.vec3();
                var v4fTemp = akra.vec4();
                var pShadowCaster;
                var m4fShadow, m4fToLightSpace;
                var iLastTextureIndex = 0;
                var sTexture = "TEXTURE";
                this.resetUniforms();
                for(i = 0; i < pLightPoints.length; i++) {
                    pLight = pLightPoints[i];
                    if(!pLight.enabled) {
                        continue;
                    }
                    v4fLightPosition.set(pLight.worldPosition, 1.);
                    pCameraView.multiplyVec4(v4fLightPosition, v4fTemp);
                    v3fLightTransformPosition.set(v4fTemp.x, v4fTemp.y, v4fTemp.z);
                    if(pLight.type === 38 /* LIGHT_OMNI_DIRECTIONAL */ ) {
                        pOmniLight = pLight;
                        if(pLight.isShadowCaster) {
                            pUniformData = render.UniformOmniShadow.stackCeil;
                            (pUniformData).setLightData(pLight.params, v3fLightTransformPosition);
                            var pDepthCube = pOmniLight.getDepthTextureCube();
                            var pShadowCasterCube = pOmniLight.getShadowCaster();
                            //var pOptimizedProjCube: IMat4[] 			= pOmniLight.optimizedProjectionCube;
                            for(j = 0; j < 6; ++j) {
                                pShadowCaster = pShadowCasterCube[j];
                                m4fToLightSpace = pShadowCaster.viewMatrix.multiply(pCamera.worldMatrix, akra.mat4());
                                pUniforms.textures.push(pDepthCube[j]);
                                sTexture = "TEXTURE" + (pUniforms.textures.length - 1);
                                (pUniformData).setSampler(sTexture, j);
                                pUniforms.samplersOmni.push((pUniformData).SHADOW_SAMPLER[j]);
                                (pUniformData).setMatrix(m4fToLightSpace, pShadowCasterCube[j].optimizedProjection, j);
                            }
                            pUniforms.omniShadows.push(pUniformData);
                        } else {
                            pUniformData = render.UniformOmni.stackCeil;
                            (pUniformData).setLightData(pLight.params, v3fLightTransformPosition);
                            pUniforms.omni.push(pUniformData);
                        }
                    } else if(pLight.type === 37 /* LIGHT_PROJECT */ ) {
                        pProjectLight = pLight;
                        if(pLight.isShadowCaster) {
                            pUniformData = render.UniformProjectShadow.stackCeil;
                            (pUniformData).setLightData(pLight.params, v3fLightTransformPosition);
                            pShadowCaster = pProjectLight.getShadowCaster();
                            m4fToLightSpace = pShadowCaster.viewMatrix.multiply(pCamera.worldMatrix, akra.mat4());
                            pUniforms.textures.push(pProjectLight.getDepthTexture());
                            sTexture = "TEXTURE" + (pUniforms.textures.length - 1);
                            (pUniformData).setSampler(sTexture);
                            pUniforms.samplersProject.push((pUniformData).SHADOW_SAMPLER);
                            (pUniformData).setMatrix(m4fToLightSpace, pShadowCaster.projectionMatrix, pShadowCaster.optimizedProjection);
                            pUniforms.projectShadows.push(pUniformData);
                        } else {
                            pUniformData = render.UniformProject.stackCeil;
                            (pUniformData).setLightData(pLight.params, v3fLightTransformPosition);
                            pShadowCaster = pProjectLight.getShadowCaster();
                            m4fShadow = pShadowCaster.projViewMatrix.multiply(pCamera.worldMatrix, akra.mat4());
                            (pUniformData).setMatrix(m4fShadow);
                            pUniforms.project.push(pUniformData);
                        }
                    } else {
                        akra.logger.setSourceLocation("DSViewport2.ts", 342);
                        akra.logger.criticalError("Invalid light point type detected.");
                        ;
                    }
                }
            };
            return DSViewport;
        })(render.Viewport);
        render.DSViewport = DSViewport;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    /* Define the number of priority groups for the render system's render targets. */
    (function (render) {
        var RenderTarget = (function () {
            function /** @no-inline */RenderTarget(pRenderer) {
                /**@protected*/ this._iPriority = 4;
                /**@protected*/ this._pDepthBuffer = null;
                /**@protected*/ this._pDepthPixelBuffer = null;
                /**@protected*/ this._isActive = true;
                /**@protected*/ this._isAutoUpdate = true;
                /**@protected*/ this._bHwGamma = false;
                this._iGuid = eval("this._iGuid || akra.sid()");
                this._pUnicastSlotMap = null;
                this._pBroadcastSlotList = null;
                this._pRenderer = pRenderer;
                this._pTimer = pRenderer.getEngine().getTimer();
                this.resetStatistics();
            }
            Object.defineProperty(RenderTarget.prototype, "name", {
                get: function /** @inline */() {
                    return this._sName;
                },
                set: function /** @inline */(sName) {
                    this._sName = sName;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderTarget.prototype, "width", {
                get: function /** @inline */() {
                    return this._iWidth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderTarget.prototype, "height", {
                get: function /** @inline */() {
                    return this._iHeight;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderTarget.prototype, "colorDepth", {
                get: function /** @inline */() {
                    return this._iColorDepth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderTarget.prototype, "totalViewports", {
                get: function /** @inline */() {
                    return this._pViewportList.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderTarget.prototype, "totalFrames", {
                get: function /** @inline */() {
                    return this._iFrameCount;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderTarget.prototype, "priority", {
                get: function /** @inline */() {
                    return this._iPriority;
                },
                enumerable: true,
                configurable: true
            });
            RenderTarget.prototype.getRenderer = function /** @inline */() {
                return this._pRenderer;
            };
            RenderTarget.prototype.destroy = function /** @no-inline */() {
                var pViewport;
                for(var i in this._pViewportList) {
                    pViewport = this._pViewportList[i];
                    this.viewportRemoved(pViewport);
                    pViewport.destroy();
                }
                this.detachDepthBuffer();
                akra.logger.setSourceLocation("render/RenderTarget.ts", 88);
                akra.logger.log("RenderTarget '%s'\n Average FPS: %s\n Best FPS: %s\n Worst FPS: %s", this._sName, this._pFrameStats.fps.avg, this._pFrameStats.fps.best, this._pFrameStats.fps.worst);
                ;
            };
            RenderTarget.prototype.getDepthBuffer = function /** @no-inline */() {
                return this._pDepthBuffer;
            };
            RenderTarget.prototype.attachDepthBuffer = function /** @no-inline */(pBuffer) {
                var isOk = false;
                if((isOk = pBuffer.isCompatible(this))) {
                    this.detachDepthBuffer();
                    this._pDepthBuffer = pBuffer;
                    this._pDepthBuffer._notifyRenderTargetAttached(this);
                }
                return isOk;
            };
            RenderTarget.prototype.attachDepthPixelBuffer = function /** @no-inline */(pBuffer) {
                if(this._iWidth !== pBuffer.width || this._iHeight !== pBuffer.height) {
                    return false;
                }
                var eFormat = pBuffer.format;
                if(eFormat !== 29 /* DEPTH */  || eFormat !== 44 /* DEPTH_BYTE */ ) {
                    return false;
                }
                this.detachDepthPixelBuffer();
                this._pDepthPixelBuffer = pBuffer;
                return true;
            };
            RenderTarget.prototype.detachDepthPixelBuffer = function /** @no-inline */() {
                if(this._pDepthPixelBuffer) {
                    this._pDepthPixelBuffer = null;
                }
            };
            RenderTarget.prototype.detachDepthBuffer = function /** @no-inline */() {
                if(this._pDepthBuffer) {
                    this._pDepthBuffer._notifyRenderTargetDetached(this);
                    this._pDepthBuffer = null;
                }
            };
            RenderTarget.prototype.attachDepthTexture = function /** @no-inline */(pTexture) {
                return false;
            };
            RenderTarget.prototype.detachDepthTexture = function /** @no-inline */() {
            };
            RenderTarget.prototype._detachDepthBuffer = function /** @no-inline */() {
                this._pDepthBuffer = null;
            };
            RenderTarget.prototype._beginUpdate = function /** @no-inline */() {
                this.preUpdate();
                this._pFrameStats.polygonsCount = 0;
            };
            RenderTarget.prototype._updateAutoUpdatedViewports = function /** @no-inline */(bUpdateStatistics) {
                if (typeof bUpdateStatistics === "undefined") { bUpdateStatistics = true; }
                var pViewport;
                for(var i in this._pViewportList) {
                    pViewport = this._pViewportList[i];
                    if(pViewport.isAutoUpdated()) {
                        this._updateViewport(pViewport, bUpdateStatistics);
                    }
                }
            };
            RenderTarget.prototype._endUpdate = function /** @no-inline */() {
                this.postUpdate();
                this.updateStats();
            };
            RenderTarget.prototype._updateViewport = function /** @no-inline */(pViewportPtr, bUpdateStatistics) {
                if (typeof bUpdateStatistics === "undefined") { bUpdateStatistics = true; }
                var pViewport;
                var iZIndex;
                if(akra.isNumber(arguments[0])) {
                    iZIndex = arguments[0];
                    pViewport = this._pViewportList[iZIndex];
                    akra.logger.setSourceLocation("render/RenderTarget.ts", 186);
                    akra.logger.assert(akra.isDefAndNotNull(pViewport), "No viewport with given z-index : %s", iZIndex, "RenderTarget::_updateViewport");
                    ;
                } else {
                    pViewport = arguments[0];
                }
                akra.logger.setSourceLocation("render/RenderTarget.ts", 193);
                akra.logger.assert(pViewport.getTarget() == this, "RenderTarget::_updateViewport the requested viewport is not bound to the rendertarget!");
                ;
                this.viewportPreUpdate(pViewport);
                pViewport.update();
                if(bUpdateStatistics) {
                    this._pFrameStats.polygonsCount += pViewport._getNumRenderedPolygons();
                }
                this.viewportPostUpdate(pViewport);
            };
            RenderTarget.prototype.addViewport = function /** @no-inline */(pCamera, csRenderMethod, iZIndex, fLeft, fTop, fWidth, fHeight) {
                if (typeof csRenderMethod === "undefined") { csRenderMethod = null; }
                if (typeof iZIndex === "undefined") { iZIndex = 0; }
                if (typeof fLeft === "undefined") { fLeft = 0.; }
                if (typeof fTop === "undefined") { fTop = 0.; }
                if (typeof fWidth === "undefined") { fWidth = 1.; }
                if (typeof fHeight === "undefined") { fHeight = 1.; }
                var pViewport = this._pViewportList[iZIndex];
                if(akra.isDefAndNotNull(pViewport)) {
                    akra.logger.setSourceLocation("render/RenderTarget.ts", 213);
                    akra.logger.criticalError("Can't create another viewport for %s with Z-index %s 					because a viewport exists with this Z-Order already.", this._sName, iZIndex, "RenderTarget::addViewport");
                    ;
                }
                if(akra.isNumber(arguments[1]) && arguments[1] >= 0) {
                    pViewport = new render.DSViewport(pCamera, this, null, fLeft, fTop, fWidth, fHeight, iZIndex);
                } else {
                    pViewport = new render.Viewport(pCamera, this, akra.isNumber(arguments[1]) ? null : csRenderMethod, fLeft, fTop, fWidth, fHeight, iZIndex);
                }
                this._pViewportList[iZIndex] = pViewport;
                this.viewportAdded(pViewport);
                return pViewport;
            };
            RenderTarget.prototype.removeViewport = function /** @no-inline */(iZIndex) {
                var pViewport = this._pViewportList[iZIndex];
                if(akra.isDefAndNotNull(pViewport)) {
                    this.viewportRemoved(pViewport);
                    this._pViewportList.splice(iZIndex, 1);
                    pViewport = null;
                    return true;
                }
                return false;
            };
            RenderTarget.prototype.removeAllViewports = function /** @no-inline */() {
                var pViewport;
                var iTotal;
                for(var i in this._pViewportList) {
                    pViewport = this._pViewportList[i];
                    this.viewportRemoved(pViewport);
                }
                iTotal = this._pViewportList.length;
                (this._pViewportList).clear();
                return iTotal;
            };
            RenderTarget.prototype.getStatistics = function /** @inline */() {
                return this._pFrameStats;
            };
            RenderTarget.prototype.getLastFPS = function /** @inline */() {
                return this._pFrameStats.fps.last;
            };
            RenderTarget.prototype.getAverageFPS = function /** @inline */() {
                return this._pFrameStats.fps.avg;
            };
            RenderTarget.prototype.getBestFPS = function /** @inline */() {
                return this._pFrameStats.fps.best;
            };
            RenderTarget.prototype.getWorstFPS = function /** @inline */() {
                return this._pFrameStats.fps.worst;
            };
            RenderTarget.prototype.getPolygonCount = function /** @inline */() {
                return this._pFrameStats.polygonsCount;
            };
            RenderTarget.prototype.getBestFrameTime = function /** @inline */() {
                return this._pFrameStats.time.best;
            };
            RenderTarget.prototype.getWorstFrameTime = function /** @inline */() {
                return this._pFrameStats.time.worst;
            };
            RenderTarget.prototype.resetStatistics = function /** @no-inline */() {
                var pStats = this._pFrameStats;
                pStats.fps.avg = 0.;
                pStats.fps.best = 0.;
                pStats.fps.last = 0.;
                pStats.fps.worst = 999.;
                pStats.polygonsCount = 0;
                pStats.time.best = 9999999;
                pStats.time.worst = 0;
                //FIXME: get right time!!!
                this._fLastTime = this._pTimer.appTime;
                this._fLastSecond = this._fLastTime;
                this._iFrameCount = 0;
            };
            RenderTarget.prototype.updateStats = function /** @no-inline */() {
                this._iFrameCount++;
                var fThisTime = this._pTimer.appTime;
                var fFrameTime = fThisTime - this._fLastTime;
                this._fLastTime = fThisTime;
                this._pFrameStats.time.best = akra.math.min(this._pFrameStats.time.best, fFrameTime);
                this._pFrameStats.time.worst = akra.math.min(this._pFrameStats.time.worst, fFrameTime);
                if(fThisTime - this._fLastTime > 1) {
                    this._pFrameStats.fps.last = this._iFrameCount / (fThisTime - this._fLastSecond);
                    if(this._pFrameStats.fps.avg == 0.) {
                        this._pFrameStats.fps.avg = this._pFrameStats.fps.last;
                    } else {
                        this._pFrameStats.fps.avg = (this._pFrameStats.fps.avg + this._pFrameStats.fps.last) / 2.;
                        this._pFrameStats.fps.best = akra.math.max(this._pFrameStats.fps.best, this._pFrameStats.fps.last);
                        this._pFrameStats.fps.worst = akra.math.max(this._pFrameStats.fps.worst, this._pFrameStats.fps.last);
                        this._fLastSecond = fThisTime;
                        this._iFrameCount = 0;
                    }
                }
            };
            RenderTarget.prototype.getCustomAttribute = function /** @no-inline */(sName) {
                return null;
            };
            RenderTarget.prototype.getViewport = function /** @no-inline */(iIndex) {
                akra.logger.setSourceLocation("render/RenderTarget.ts", 348);
                akra.logger.assert(iIndex < this._pViewportList.length, "Index out of bounds");
                ;
                for(var i in this._pViewportList) {
                    if(iIndex--) {
                        continue;
                    }
                    return this._pViewportList[i];
                }
                return null;
            };
            RenderTarget.prototype.getViewportByZIndex = function /** @no-inline */(iZIndex) {
                var pViewport = this._pViewportList[iZIndex];
                akra.logger.setSourceLocation("render/RenderTarget.ts", 365);
                akra.logger.assert(akra.isDefAndNotNull(pViewport), "No viewport with given z-index : " + String(iZIndex), "RenderTarget::getViewportByZIndex");
                ;
                return pViewport;
            };
            RenderTarget.prototype.hasViewportByZIndex = function /** @inline */(iZIndex) {
                return akra.isDefAndNotNull(this._pViewportList[iZIndex]);
            };
            RenderTarget.prototype.isActive = function /** @inline */() {
                return this._isActive;
            };
            RenderTarget.prototype.setActive = function /** @no-inline */(bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                this._isActive = bValue;
            };
            RenderTarget.prototype.setAutoUpdated = function /** @inline */(isAutoUpdate) {
                if (typeof isAutoUpdate === "undefined") { isAutoUpdate = true; }
                this._isAutoUpdate = isAutoUpdate;
            };
            RenderTarget.prototype._notifyCameraRemoved = function /** @no-inline */(pCamera) {
                var isRemoved = false;
                for(var i in this._pViewportList) {
                    var pViewport = this._pViewportList[i];
                    if(pViewport.getCamera() === pCamera) {
                        pViewport.setCamera(null);
                        isRemoved = true;
                    }
                }
                if(isRemoved) {
                    this.cameraRemoved(pCamera);
                }
            };
            RenderTarget.prototype.setAutoUpdare = function /** @inline */(bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                this._isAutoUpdate = bValue;
            };
            RenderTarget.prototype.isAutoUpdated = function /** @inline */() {
                return this._isAutoUpdate;
            };
            RenderTarget.prototype.isPrimary = function /** @inline */() {
                // RenderWindow will override and return true for the primary window
                return false;
            };
            RenderTarget.prototype.update = function /** @no-inline */() {
                this.updateImpl();
            };
            RenderTarget.prototype.readPixels = function /** @no-inline */(ppDest, eFramebuffer) {
                return null;
            };
            RenderTarget.prototype.updateImpl = /**@protected*/ function /** @no-inline */() {
                this._beginUpdate();
                this._updateAutoUpdatedViewports(true);
                this._endUpdate();
            };
            RenderTarget._pEventTable = new akra.events.EventTable();
            RenderTarget.prototype.getEventTable = function /** @inline */() {
                return RenderTarget._pEventTable;
            };
            RenderTarget.prototype.getGuid = function /** @no-inline */() {
                return this._iGuid < 0 ? (this._iGuid = akra.sid()) : this._iGuid;
            };
            RenderTarget.prototype.connect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            RenderTarget.prototype.disconnect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            RenderTarget.prototype.bind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType);
            };
            RenderTarget.prototype.unbind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType);
            };
            RenderTarget.prototype.preUpdate = function /** @no-inline */() {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).preUpdate;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            RenderTarget.prototype.viewportPreUpdate = function /** @no-inline */(pViewport) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).viewportPreUpdate;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pViewport) : _broadcast[i].listener(_recivier, pViewport);
                    }
                }
            };
            RenderTarget.prototype.viewportPostUpdate = function /** @no-inline */(pViewport) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).viewportPostUpdate;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pViewport) : _broadcast[i].listener(_recivier, pViewport);
                    }
                }
            };
            RenderTarget.prototype.viewportAdded = function /** @no-inline */(pViewport) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).viewportAdded;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pViewport) : _broadcast[i].listener(_recivier, pViewport);
                    }
                }
            };
            RenderTarget.prototype.viewportRemoved = function /** @no-inline */(pViewport) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).viewportRemoved;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pViewport) : _broadcast[i].listener(_recivier, pViewport);
                    }
                }
            };
            RenderTarget.prototype.postUpdate = function /** @no-inline */() {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).postUpdate;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            RenderTarget.prototype.cameraRemoved = function /** @no-inline */(pCamera) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).cameraRemoved;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pCamera) : _broadcast[i].listener(_recivier, pCamera);
                    }
                }
            };
            return RenderTarget;
        })();
        render.RenderTarget = RenderTarget;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        render.SShaderPrefixes = {
            k_Sampler: "A_s_",
            k_Header: "A_h_",
            k_Attribute: "A_a_",
            k_Offset: "A_o_",
            k_Texture: "TEXTURE",
            k_Texcoord: "TEXCOORD",
            k_Texmatrix: "TEXMATRIX",
            k_Temp: "TEMP_",
            k_BlendType: "AUTO_BLEND_TYPE_"
        };
        render.ZEROSAMPLER = 19;
        render.SSystemSemantics = {
            MODEL_MATRIX: "MODEL_MATRIX",
            VIEW_MATRIX: "VIEW_MATRIX",
            PROJ_MATRIX: "PROJ_MATRIX",
            NORMAL_MATRIX: "NORMAL_MATRIX",
            BIND_MATRIX: "BIND_SHAPE_MATRIX",
            RENDER_OBJECT_ID: "RENDER_OBJECT_ID"
        };
        var Renderer = (function () {
            function /** @no-inline */Renderer(pEngine) {
                /**@protected*/ this._isActive = false;
                this._iGuid = eval("this._iGuid || akra.sid()");
                this._pUnicastSlotMap = null;
                this._pBroadcastSlotList = null;
                this._pEngine = pEngine;
                this.connect(pEngine, "active", "active");
                this.connect(pEngine, "inactive", "inactive");
            }
            Renderer.prototype.getEngine = function /** @inline */() {
                return this._pEngine;
            };
            Renderer.prototype.hasCapability = function /** @no-inline */(eCapability) {
                return false;
            };
            Renderer.prototype.debug = function /** @no-inline */(bValue, useApiTrace) {
                return false;
            };
            Renderer.prototype.isDebug = function /** @no-inline */() {
                return false;
            };
            Renderer.prototype.isValid = function /** @no-inline */() {
                return false;
            };
            Renderer.prototype.getError = function /** @inline */() {
                return null;
            };
            Renderer.prototype.clearFrameBuffer = function /** @no-inline */(iBuffer, cColor, iDepth) {
            };
            Renderer.prototype.attachRenderTarget = function /** @no-inline */(pTarget) {
                for(var i = 0; i < this._pRenderTargets.length; i++) {
                    if(this._pRenderTargets[i] === pTarget) {
                        return false;
                    }
                }
                this._pRenderTargets.push(pTarget);
                return true;
            };
            Renderer.prototype.detachRenderTarget = function /** @no-inline */(pTarget) {
                for(var i = 0; i < this._pRenderTargets.length; i++) {
                    if(this._pRenderTargets[i] === pTarget) {
                        this._pRenderTargets.splice(i, 1);
                        return true;
                    }
                }
                return false;
            };
            Renderer.prototype.destroyRenderTarget = function /** @no-inline */(pTarget) {
                var hasTarget = this.detachRenderTarget(pTarget);
                if(hasTarget) {
                    pTarget.destroy();
                    pTarget = null;
                }
            };
            Renderer.prototype.getActiveProgram = function /** @no-inline */() {
                akra.logger.setSourceLocation("render/Renderer.ts", 133);
                akra.logger.criticalError("Renderer::getActiveProgram() is uncompleted method!");
                ;
                return null;
            };
            Renderer.prototype._disableAllTextureUnits = function /** @inline */() {
                this._disableTextureUnitsFrom(0);
            };
            Renderer.prototype._disableTextureUnitsFrom = function /** @inline */(iUnit) {
            };
            Renderer.prototype._initRenderTargets = function /** @no-inline */() {
                // Init stats
                for(var i = 0; i < this._pRenderTargets.length; ++i) {
                    this._pRenderTargets[i].resetStatistics();
                }
            };
            Renderer.prototype._updateAllRenderTargets = function /** @no-inline */() {
                var pTarget;
                for(var i in this._pPrioritisedRenderTargets) {
                    pTarget = this._pPrioritisedRenderTargets[i];
                    if(pTarget.isActive() && pTarget.isAutoUpdated()) {
                        pTarget.update();
                    }
                }
            };
            Renderer.prototype._setViewport = function /** @no-inline */(pViewport) {
            };
            Renderer.prototype._getViewport = function /** @no-inline */() {
                return null;
            };
            Renderer._pEventTable = new akra.events.EventTable();
            Renderer.prototype.getEventTable = function /** @inline */() {
                return Renderer._pEventTable;
            };
            Renderer.prototype.getGuid = function /** @no-inline */() {
                return this._iGuid < 0 ? (this._iGuid = akra.sid()) : this._iGuid;
            };
            Renderer.prototype.connect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            Renderer.prototype.disconnect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            Renderer.prototype.bind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType);
            };
            Renderer.prototype.unbind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType);
            };
            Renderer.prototype.active = function /** @no-inline */(pEngine) {
                this._isActive = true;
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).active;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pEngine) : _broadcast[i].listener(_recivier, pEngine);
                    }
                }
                ;
            };
            Renderer.prototype.inactive = function /** @no-inline */(pEngine) {
                this._isActive = false;
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).inactive;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pEngine) : _broadcast[i].listener(_recivier, pEngine);
                    }
                }
                ;
            };
            return Renderer;
        })();
        render.Renderer = Renderer;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
;
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLRenderer = (function (_super) {
            __extends(WebGLRenderer, _super);
            function /** @no-inline */WebGLRenderer(pEngine, pCanvas) {
                        _super.call(this, pEngine);
                //real context, if debug context used
                this._pWebGLInternalContext = null;
                if(akra.isDef(pCanvas)) {
                    //get HTMLCanvasElement by id
                    if(akra.isString(pCanvas)) {
                        this._pCanvas = document.getElementById(pCanvas);
                    } else {
                        this._pCanvas = pCanvas;
                    }
                } else {
                    this._pCanvas = document.createElement('canvas');
                }
                this._pWebGLContext = webgl.createContext(this._pCanvas);
                this._pWebGLFramebufferList = new Array(32);
                for(var i = 0; i < this._pWebGLFramebufferList.length; ++i) {
                    this._pWebGLFramebufferList[i] = this._pWebGLContext.createFramebuffer();
                }
            }
            WebGLRenderer.prototype.debug = function /** @no-inline */(bValue, useApiTrace) {
                if (typeof bValue === "undefined") { bValue = true; }
                if (typeof useApiTrace === "undefined") { useApiTrace = false; }
                var pWebGLInternalContext = this._pWebGLContext;
                if(bValue) {
                    if(akra.isDef(WebGLDebugUtils) && !akra.isNull(pWebGLInternalContext)) {
                        this._pWebGLContext = WebGLDebugUtils.makeDebugContext(pWebGLInternalContext, function /** @no-inline */(err, funcName, args) {
                            throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName;
                        }, useApiTrace ? function /** @no-inline */(funcName, args) {
                            akra.logger.setSourceLocation("webgl/WebGLRenderer.ts", 61);
                            akra.logger.log("gl." + funcName + "(" + WebGLDebugUtils.glFunctionArgsToString(funcName, args) + ")");
                            ;
                        } : null);
                        this._pWebGLInternalContext = pWebGLInternalContext;
                        return true;
                    }
                } else if(this.isDebug()) {
                    this._pWebGLContext = this._pWebGLInternalContext;
                    this._pWebGLInternalContext = null;
                    return true;
                }
                return false;
            };
            WebGLRenderer.prototype.isDebug = function /** @no-inline */() {
                return !akra.isNull(this._pWebGLInternalContext);
            };
            WebGLRenderer.prototype.getHTMLCanvas = function /** @inline */() {
                return this._pCanvas;
            };
            WebGLRenderer.prototype.getWebGLContext = function /** @inline */() {
                return this._pWebGLContext;
            };
            WebGLRenderer.prototype.bindWebGLBuffer = /** Buffer Objects. */
            function /** @inline */(eTarget, pBuffer) {
                this._pWebGLContext.bindBuffer(eTarget, pBuffer);
            };
            WebGLRenderer.prototype.createWebGLBuffer = function /** @inline */() {
                return this._pWebGLContext.createBuffer();
            };
            WebGLRenderer.prototype.deleteWebGLBuffer = function /** @inline */(pBuffer) {
                this._pWebGLContext.deleteBuffer(pBuffer);
            };
            WebGLRenderer.prototype.bindWebGLTexture = /** Texture Objects. */
            function /** @inline */(eTarget, pTexture) {
                this._pWebGLContext.bindTexture(eTarget, pTexture);
            };
            WebGLRenderer.prototype.activateWebGLTexture = function /** @inline */(iSlot) {
                this._pWebGLContext.activeTexture(iSlot);
            };
            WebGLRenderer.prototype.createWebGLTexture = function /** @inline */() {
                return this._pWebGLContext.createTexture();
            };
            WebGLRenderer.prototype.deleteWebGLTexture = function /** @inline */(pTexture) {
                this._pWebGLContext.deleteTexture(pTexture);
            };
            WebGLRenderer.prototype.createWebGLFramebuffer = /** Framebuffer Objects */
            function /** @inline */() {
                if(this._pWebGLFramebufferList.length === 0) {
                    akra.logger.setSourceLocation("webgl/WebGLRenderer.ts", 128);
                    akra.logger.criticalError("WebGL framebuffer limit exidit");
                    ;
                }
                return this._pWebGLFramebufferList.pop();
            };
            WebGLRenderer.prototype.bindWebGLFramebuffer = function /** @inline */(eTarget, pBuffer) {
                this._pWebGLContext.bindFramebuffer(eTarget, pBuffer);
            };
            WebGLRenderer.prototype.deleteWebGLFramebuffer = function /** @inline */(pBuffer) {
                this._pWebGLFramebufferList.push(pBuffer);
            };
            WebGLRenderer.prototype.createWebGLRenderbuffer = /** Renderbuffer Objects */
            function /** @inline */() {
                return this._pWebGLContext.createRenderbuffer();
            };
            WebGLRenderer.prototype.bindWebGLRenderbuffer = function /** @inline */(eTarget, pBuffer) {
                this._pWebGLContext.bindRenderbuffer(eTarget, pBuffer);
            };
            WebGLRenderer.prototype.deleteWebGLRenderbuffer = function /** @inline */(pBuffer) {
                this._pWebGLContext.deleteRenderbuffer(pBuffer);
            };
            WebGLRenderer.prototype.createWebGLProgram = function /** @inline */() {
                return this._pWebGLContext.createProgram();
            };
            WebGLRenderer.prototype.deleteWebGLProgram = function /** @inline */(pProgram) {
                this._pWebGLContext.deleteProgram(pProgram);
            };
            WebGLRenderer.prototype.useWebGLProgram = function /** @inline */(pProgram) {
                this._pWebGLContext.useProgram(pProgram);
            };
            WebGLRenderer.prototype.disableAllWebGLVertexAttribs = function /** @inline */() {
                //TODO: check attrib array from last shader program
                var i = 0;
                for(i = 0; i < 16; i++) {
                    this._pWebGLContext.disableVertexAttribArray(i);
                }
            };
            return WebGLRenderer;
        })(akra.render.Renderer);
        webgl.WebGLRenderer = WebGLRenderer;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        function /** @no-inline */computeLog(iValue) {
            var i = 0;
            /* Error! */
            if(iValue === 0) {
                return -1;
            }
            for(; ; ) {
                if(iValue & 1) {
                    /* Error! */
                    if(iValue !== 1) {
                        return -1;
                    }
                    return i;
                }
                iValue = iValue >> 1;
                i++;
            }
        }
        webgl.computeLog = computeLog;
        var WebGLTextureBuffer = (function (_super) {
            __extends(WebGLTextureBuffer, _super);
            function /** @no-inline */WebGLTextureBuffer() {
                        _super.call(this);
                /**@protected*/ this._eTarget = null;
                /**@protected*/ this._eFaceTarget = null;
                /**@protected*/ this._pWebGLTexture = null;
                /**@protected*/ this._iFace = 0;
                /**@protected*/ this._iLevel = 0;
                /**@protected*/ this._bSoftwareMipmap = false;
                /**@protected*/ this._pRTTList = null;
            }
            WebGLTextureBuffer.prototype._clearRTT = function /** @no-inline */(iZOffset) {
                this._pRTTList[iZOffset] = null;
            };
            WebGLTextureBuffer.prototype.create = function /** @no-inline */() {
                if(arguments.length < 6) {
                    akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 53);
                    akra.logger.criticalError("Invalid number of params. For WebGLTextureBuffer");
                    ;
                }
                var eTarget = arguments[0];
                var pTexture = arguments[1];
                var iWidth = arguments[2];
                var iHeight = arguments[3];
                var iInternalFormat = arguments[4];
                var iFormat = arguments[5];
                var iFace = arguments[6];
                var iLevel = arguments[7];
                var iFlags = arguments[8];
                var bSoftwareMipmap = arguments[9];
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                pWebGLRenderer.bindWebGLTexture(eTarget, pTexture);
                this._eTarget = eTarget;
                this._pWebGLTexture = pTexture;
                this._iFace = iFace;
                this._iLevel = iLevel;
                this._bSoftwareMipmap = bSoftwareMipmap;
                this._eFaceTarget = eTarget;
                if(eTarget === 0x8513) {
                    this._eFaceTarget = 0x8515 + iFace;
                }
                this._iWidth = iLevel === 0 ? iWidth : iWidth / Math.pow(2.0, iLevel);
                this._iHeight = iLevel === 0 ? iHeight : iHeight / Math.pow(2.0, iLevel);
                this._iDepth = 1;
                this._iWebGLInternalFormat = iInternalFormat;
                this._eFormat = akra.webgl.getClosestAkraFormat(iInternalFormat, iFormat);
                this._iRowPitch = this._iWidth;
                this._iSlicePitch = this._iHeight * this._iWidth;
                this.byteLength = akra.pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
                this._pBuffer = new akra.pixelUtil.PixelBox(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
                if(this._iWidth === 0 || this._iHeight === 0 || this._iDepth === 0) {
                    // We are invalid, do not allocate a buffer
                    return false;
                }
                // Is this a render target?
                if((((this._iFlags) & (512 /* RENDERTARGET */ )) != 0)) {
                    // Create render target for each slice
                    this._pRTTList = new Array();
                    for(var iZOffset = 0; iZOffset < this._iDepth; ++iZOffset) {
                        var pRenderTexture = new webgl.WebGLRenderTexture(pWebGLRenderer, this);
                        this._pRTTList.push(pRenderTexture);
                        pWebGLRenderer.attachRenderTarget(pRenderTexture);
                    }
                }
                var pProgram = this.getManager().shaderProgramPool.findResource("WEBGL_blit_texture_buffer");
                if(akra.isNull(pProgram)) {
                    pProgram = this.getManager().shaderProgramPool.createResource("WEBGL_blit_texture_buffer");
                    pProgram.create("																									\n	        	attribute vec2 POSITION;																			\n				attribute vec3 TEXCOORD;																			\n				                      																				\n				varying vec3 texcoord;																				\n				                   																					\n				void main(void){																					\n				    texcoord = TEXCOORD;																			\n				    gl_Position = vec4(POSITION, 0., 1.);															\n				}																									\n				", "													\n				#ifdef GL_ES                        				\n				    precision highp float;          				\n				#endif												\n				varying vec3 texcoord;              				\n				uniform sampler2D uSampler;        					\n																	\n				void main(void) {  									\n					vec4 color;										\n					color = texture2D(uSampler, texcoord.xy);      	\n				    gl_FragColor = color;           				\n				}                                   				\n				");
                }
                return true;
            };
            WebGLTextureBuffer.prototype.destroy = function /** @no-inline */() {
                if((((this._iFlags) & (512 /* RENDERTARGET */ )) != 0)) {
                    // Delete all render targets that are not yet deleted via _clearSliceRTT because the rendertarget
                    // was deleted by the user.
                    var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                    for(var i = 0; i < this._pRTTList.length; i++) {
                        pWebGLRenderer.destroyRenderTarget(this._pRTTList[i]);
                    }
                }
            };
            WebGLTextureBuffer.prototype.upload = //upload(download) data to(from) videocard.
            /**@protected*/ function /** @no-inline */(pData, pDestBox) {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);
                if(akra.pixelUtil.isCompressed(pData.format)) {
                    if(pData.format !== this._eFormat || !pData.isConsecutive()) {
                        akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 166);
                        akra.logger.criticalError("Compressed images must be consecutive, in the source format");
                        ;
                    }
                    var iWebGLFormat = akra.webgl.getClosestWebGLInternalFormat(this._eFormat);
                    // Data must be consecutive and at beginning of buffer as PixelStorei not allowed
                    // for compressed formats
                    if(pDestBox.left === 0 && pDestBox.top === 0) {
                        pWebGLContext.compressedTexImage2D(this._eFaceTarget, this._iLevel, iWebGLFormat, pDestBox.width, pDestBox.height, 0, pData.data);
                    } else {
                        pWebGLContext.compressedTexSubImage2D(this._eFaceTarget, this._iLevel, pDestBox.left, pDestBox.top, pDestBox.width, pDestBox.height, iWebGLFormat, pData.data);
                    }
                } else if(this._bSoftwareMipmap) {
                    if(pData.width !== pData.rowPitch) {
                        // TODO
                        akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 191);
                        akra.logger.criticalError("Unsupported texture format");
                        ;
                    }
                    if(pData.height * pData.width !== pData.slicePitch) {
                        // TODO
                        akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 196);
                        akra.logger.criticalError("Unsupported texture format");
                        ;
                    }
                    pWebGLContext.pixelStorei(0x0CF5, 1);
                    this.buildMipmaps(pData);
                } else {
                    if(pData.width !== pData.rowPitch) {
                        // TODO
                        akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 205);
                        akra.logger.criticalError("Unsupported texture format");
                        ;
                    }
                    if(pData.height * pData.width !== pData.slicePitch) {
                        // TODO
                        akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 210);
                        akra.logger.criticalError("Unsupported texture format");
                        ;
                    }
                    if((pData.width * akra.pixelUtil.getNumElemBytes(pData.format)) & 3) {
                        // Standard alignment of 4 is not right
                        pWebGLContext.pixelStorei(0x0CF5, 1);
                    }
                    pWebGLContext.texSubImage2D(this._eFaceTarget, this._iLevel, pDestBox.left, pDestBox.top, pDestBox.width, pDestBox.height, akra.webgl.getWebGLOriginFormat(pData.format), akra.webgl.getWebGLOriginDataType(pData.format), pData.data);
                }
                if((((this._iFlags) & (256 /* AUTOMIPMAP */ )) != 0) && !this._bSoftwareMipmap && (this._iLevel === 0)) {
                    pWebGLContext.generateMipmap(this._eFaceTarget);
                }
                pWebGLContext.pixelStorei(0x0CF5, 4);
                this.notifyAltered();
            };
            WebGLTextureBuffer.prototype.download = /**@protected*/ function /** @no-inline */(pData) {
                // if(data.getWidth() != getWidth() ||
                //     data.getHeight() != getHeight() ||
                //     data.getDepth() != getDepth())
                //     OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, "only download of entire buffer is supported by GL",
                //         "GLTextureBuffer::download");
                // glBindTexture( mTarget, mTextureID );
                // if(PixelUtil::isCompressed(data.format))
                // {
                //     if(data.format != mFormat || !data.isConsecutive())
                //         OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS,
                //         "Compressed images must be consecutive, in the source format",
                //         "GLTextureBuffer::download");
                //     // Data must be consecutive and at beginning of buffer as PixelStorei not allowed
                //     // for compressed formate
                //     glGetCompressedTexImageNV(mFaceTarget, mLevel, data.data);
                // }
                // else
                // {
                //     if((data.getWidth()*PixelUtil::getNumElemBytes(data.format)) & 3) {
                //         // Standard alignment of 4 is not right
                //         glPixelStorei(GL_PACK_ALIGNMENT, 1);
                //     }
                //     // We can only get the entire texture
                //     glGetTexImageNV(mFaceTarget, mLevel,
                //         GLES2PixelUtil::getGLOriginFormat(data.format), GLES2PixelUtil::getGLOriginDataType(data.format),
                //         data.data);
                //     // Restore defaults
                //     glPixelStorei(GL_PACK_ALIGNMENT, 4);
                // }
                akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 266);
                akra.logger.criticalError("Downloading texture buffers is not supported by OpenGL ES");
                ;
            };
            WebGLTextureBuffer.prototype.buildMipmaps = /**@protected*/ function /** @no-inline */(pData) {
                var iWidth = 0;
                var iHeight = 0;
                var iLogW = 0;
                var iLogH = 0;
                var iLevel = 0;
                var pScaled = new akra.pixelUtil.PixelBox();
                pScaled.data = pData.data;
                pScaled.left = pData.left;
                pScaled.right = pData.right;
                pScaled.top = pData.top;
                pScaled.bottom = pData.bottom;
                pScaled.front = pData.front;
                pScaled.back = pData.back;
                iWidth = pData.width;
                iHeight = pData.height;
                iLogW = computeLog(iWidth);
                iLogH = computeLog(iHeight);
                iLevel = (iLogW > iLogH ? iLogW : iLogH);
                var mip = 0;
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                for(mip = 0; mip <= iLevel; mip++) {
                    var iWebGLFormat = akra.webgl.getWebGLOriginFormat(pScaled.format);
                    var iWebGLDataType = akra.webgl.getWebGLOriginDataType(pScaled.format);
                    pWebGLContext.texImage2D(this._eFaceTarget, mip, iWebGLFormat, iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, pScaled.data);
                    if(mip !== 0) {
                        pScaled.data = null;
                    }
                    if(iWidth > 1) {
                        iWidth = iWidth / 2;
                    }
                    if(iHeight > 1) {
                        iHeight = iHeight / 2;
                    }
                    var iSizeInBytes = akra.pixelUtil.getMemorySize(iWidth, iHeight, 1, pData.format);
                    pScaled = new akra.pixelUtil.PixelBox(iWidth, iHeight, 1, pData.format);
                    pScaled.data = new Uint8Array(iSizeInBytes);
                    pData.scale(pScaled, 1 /* LINEAR */ );
                }
                // Delete the scaled data for the last level
                if(iLevel > 0) {
                    pScaled.data = null;
                }
            };
            WebGLTextureBuffer.prototype._bindToFramebuffer = function /** @no-inline */(iAttachment, iZOffset) {
                akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 335);
                akra.logger.assert(iZOffset < this._iDepth);
                ;
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                pWebGLContext.framebufferTexture2D(0x8D40, iAttachment, this._eFaceTarget, this._pWebGLTexture, this._iLevel);
            };
            WebGLTextureBuffer.prototype._copyFromFramebuffer = function /** @no-inline */(iZOffset) {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);
                pWebGLContext.copyTexSubImage2D(this._eFaceTarget, this._iLevel, 0, 0, 0, 0, this._iWidth, this._iHeight);
            };
            WebGLTextureBuffer.prototype._getTarget = function /** @inline */() {
                return this._eTarget;
            };
            WebGLTextureBuffer.prototype._getWebGLTexture = function /** @inline */() {
                return this._pWebGLTexture;
            };
            WebGLTextureBuffer.prototype.blit = function /** @no-inline */(pSource, pSrcBox, pDestBox) {
                if(arguments.length == 1) {
                    return this.blit(pSource, new akra.geometry.Box(0, 0, 0, pSource.width, pSource.height, pSource.depth), new akra.geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth));
                } else {
                    var pSourceTexture = pSource;
                    // TODO: Check for FBO support first
                    // Destination texture must be 2D or Cube
                    // Source texture must be 2D
                    if(!(((pSourceTexture.getFlags()) & (512 /* RENDERTARGET */ )) != 0) && pSourceTexture._getTarget() === 0x0DE1) {
                        return this.blitFromTexture(pSourceTexture, pSrcBox, pDestBox);
                    } else {
                        return _super.prototype.blit.call(this, pSource, pSrcBox, pDestBox);
                    }
                }
            };
            WebGLTextureBuffer.prototype.blitFromTexture = //-----------------------------------------------------------------------------
            // Very fast texture-to-texture blitter and hardware bi/trilinear scaling implementation using FBO
            // Destination texture must be 1D, 2D, 3D, or Cube
            // Source texture must be 1D, 2D or 3D
            // Supports compressed formats as both source and destination format, it will use the hardware DXT compressor
            // if available.
            function /** @no-inline */(pSource, pSrcBox, pDestBox) {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                pWebGLRenderer._disableTextureUnitsFrom(0);
                pWebGLRenderer.activateWebGLTexture(0x84C0);
                // Disable alpha, depth and scissor testing, disable blending,
                // and disable culling
                pWebGLContext.disable(0x0B71);
                pWebGLContext.disable(0x0C11);
                pWebGLContext.disable(0x0BE2);
                pWebGLContext.disable(0x0B44);
                // Set up source texture
                pWebGLRenderer.bindWebGLTexture(pSource._getTarget(), pSource._getWebGLTexture());
                // Set filtering modes depending on the dimensions and source
                if(pSrcBox.width === pDestBox.width && pSrcBox.height === pDestBox.height && pSrcBox.depth === pDestBox.depth) {
                    // Dimensions match -- use nearest filtering (fastest and pixel correct)
                    pWebGLContext.texParameteri(pSource._getTarget(), 0x2801, 0x2600);
                    pWebGLContext.texParameteri(pSource._getTarget(), 0x2800, 0x2600);
                } else {
                    // Dimensions don't match -- use bi or trilinear filtering depending on the
                    // source texture.
                    if((((pSource.getFlags()) & (256 /* AUTOMIPMAP */ )) != 0)) {
                        // Automatic mipmaps, we can safely use trilinear filter which
                        // brings greatly improved quality for minimisation.
                        pWebGLContext.texParameteri(pSource._getTarget(), 0x2801, 0x2703);
                        pWebGLContext.texParameteri(pSource._getTarget(), 0x2800, 0x2601);
                    } else {
                        // Manual mipmaps, stay safe with bilinear filtering so that no
                        // intermipmap leakage occurs.
                        pWebGLContext.texParameteri(pSource._getTarget(), 0x2801, 0x2601);
                        pWebGLContext.texParameteri(pSource._getTarget(), 0x2800, 0x2601);
                    }
                }
                // Clamp to edge (fastest)
                pWebGLContext.texParameteri(pSource._getTarget(), 0x2802, 0x812F);
                pWebGLContext.texParameteri(pSource._getTarget(), 0x2803, 0x812F);
                //Store old binding so it can be restored later
                var pOldFramebuffer = pWebGLContext.getParameter(0x8CA6);
                var pFramebuffer = pWebGLRenderer.createWebGLFramebuffer();
                pWebGLRenderer.bindWebGLFramebuffer(0x8D40, pFramebuffer);
                var pTempWebGLTexture = null;
                if(!akra.webgl.checkFBOAttachmentFormat(this._eFormat) || pSource === this) {
                    // If target format not directly supported, create intermediate texture
                    var iGLTempFormat = akra.webgl.getClosestWebGLInternalFormat(akra.webgl.getSupportedAlternative(this._eFormat));
                    pTempWebGLTexture = pWebGLRenderer.createWebGLTexture();
                    pWebGLRenderer.bindWebGLTexture(0x0DE1, pTempWebGLTexture);
                    // Allocate temporary texture of the size of the destination area
                    pWebGLContext.texImage2D(0x0DE1, 0, iGLTempFormat, akra.math.ceilingPowerOfTwo(pDestBox.width), akra.math.ceilingPowerOfTwo(pDestBox.height), 0, 0x1908, 0x1401, null);
                    pWebGLContext.framebufferTexture2D(0x8D40, 0x8CE0, 0x0DE1, pTempWebGLTexture, 0);
                    // Set viewport to size of destination slice
                    pWebGLContext.viewport(0, 0, pDestBox.width, pDestBox.height);
                } else {
                    // We are going to bind directly, so set viewport to size and position of destination slice
                    pWebGLContext.viewport(pDestBox.left, pDestBox.top, pDestBox.width, pDestBox.height);
                }
                //Get WebGL program
                var pWebGLShaderProgram = this.getManager().shaderProgramPool.findResource("WEBGL_blit_texture_buffer");
                pWebGLRenderer.disableAllWebGLVertexAttribs();
                pWebGLRenderer.useWebGLProgram(pWebGLShaderProgram);
                var iPosAttrIndex = 0;
                var iTexAttrIndex = 0;
                iPosAttrIndex = pWebGLShaderProgram.getWebGLAttributeLocation("POSITION");
                iTexAttrIndex = pWebGLShaderProgram.getWebGLAttributeLocation("TEXCOORD");
                pWebGLContext.enableVertexAttribArray(iPosAttrIndex);
                pWebGLContext.enableVertexAttribArray(iTexAttrIndex);
                var pSquareVertices = new Float32Array([
                    -1.0, 
                    -1.0, 
                    1.0, 
                    -1.0, 
                    -1.0, 
                    1.0, 
                    1.0, 
                    1.0
                ]);
                var pTexCoords = new Float32Array(12);
                var pPositionBuffer = pWebGLRenderer.createWebGLBuffer();
                var pTexCoordsBuffer = pWebGLRenderer.createWebGLBuffer();
                pWebGLRenderer.bindWebGLBuffer(0x8892, pPositionBuffer);
                pWebGLContext.bufferData(0x8892, pSquareVertices, 0x88E0);
                pWebGLContext.vertexAttribPointer(iPosAttrIndex, 2, 0x1406, false, 0, 0);
                pWebGLShaderProgram.setInt("uSampler", 0);
                // Process each destination slice
                var iSlice = 0;
                for(iSlice = pDestBox.front; iSlice < pDestBox.back; ++iSlice) {
                    if(akra.isNull(pTempWebGLTexture)) {
                        // Bind directly
                        this._bindToFramebuffer(0x8CE0, iSlice);
                    }
                    /// Calculate source texture coordinates
                    var u1 = pSrcBox.left / pSource.width;
                    var v1 = pSrcBox.top / pSource.height;
                    var u2 = pSrcBox.right / pSource.width;
                    var v2 = pSrcBox.bottom / pSource.height;
                    /// Calculate source slice for this destination slice
                    var w = (iSlice - pDestBox.front) / pDestBox.depth;
                    /// Get slice # in source
                    w = w * pSrcBox.depth + pSrcBox.front;
                    /// Normalise to texture coordinate in 0.0 .. 1.0
                    w = (w + 0.5) / pSource.depth;
                    pTexCoords[0] = u1;
                    pTexCoords[1] = v1;
                    pTexCoords[2] = w;
                    pTexCoords[3] = u2;
                    pTexCoords[4] = v1;
                    pTexCoords[5] = w;
                    pTexCoords[6] = u2;
                    pTexCoords[7] = v2;
                    pTexCoords[8] = w;
                    pTexCoords[9] = u1;
                    pTexCoords[10] = v2;
                    pTexCoords[11] = w;
                    /// Finally we're ready to rumble
                    pWebGLRenderer.bindWebGLTexture(pSource._getTarget(), pSource._getWebGLTexture());
                    pWebGLContext.enable(pSource._getTarget());
                    pWebGLRenderer.bindWebGLBuffer(0x8892, pTexCoordsBuffer);
                    pWebGLContext.bufferData(0x8892, pTexCoords, 0x88E0);
                    pWebGLContext.vertexAttribPointer(iTexAttrIndex, 3, 0x1406, false, 0, 0);
                    pWebGLContext.drawArrays(0x0005, 0, 4);
                    pWebGLContext.disable(pSource._getTarget());
                    if(!akra.isNull(pTempWebGLTexture)) {
                        if(pSource === this) {
                            //set width, height and _pWebGLTexture
                            pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);
                            this._pWebGLTexture = pTempWebGLTexture;
                            this._iWidth = akra.math.ceilingPowerOfTwo(pDestBox.width);
                            this._iHeight = akra.math.ceilingPowerOfTwo(pDestBox.height);
                        } else {
                            // Copy temporary texture
                            pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);
                            switch(this._eTarget) {
                                case 0x0DE1:
                                case 0x8513:
                                    pWebGLContext.copyTexSubImage2D(this._eFaceTarget, this._iLevel, pDestBox.left, pDestBox.top, 0, 0, pDestBox.width, pDestBox.height);
                                    break;
                            }
                        }
                    }
                }
                pWebGLContext.disableVertexAttribArray(iPosAttrIndex);
                pWebGLContext.disableVertexAttribArray(iTexAttrIndex);
                pWebGLRenderer.deleteWebGLBuffer(pPositionBuffer);
                pWebGLRenderer.deleteWebGLBuffer(pTexCoordsBuffer);
                // Finish up
                if(!akra.isNull(pTempWebGLTexture)) {
                    // Generate mipmaps
                    if((((this._iFlags) & (256 /* AUTOMIPMAP */ )) != 0)) {
                        pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);
                        pWebGLContext.generateMipmap(this._eTarget);
                    }
                }
                // Reset source texture to sane state
                pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);
                // Detach texture from temporary framebuffer
                pWebGLContext.framebufferRenderbuffer(0x8D40, 0x8CE0, 0x8D41, null);
                // Restore old framebuffer
                pWebGLRenderer.bindWebGLFramebuffer(0x8D40, pOldFramebuffer);
                if(pSource !== this) {
                    pWebGLRenderer.deleteWebGLTexture(pTempWebGLTexture);
                }
                pWebGLRenderer.deleteWebGLFramebuffer(pFramebuffer);
                pTempWebGLTexture = null;
                this.notifyAltered();
                return true;
            };
            WebGLTextureBuffer.prototype.blitFromMemory = function /** @no-inline */() {
                if(arguments.length === 1) {
                    return _super.prototype.blitFromMemory.call(this, arguments[0]);
                }
                // Fall back to normal GLHardwarePixelBuffer::blitFromMemory in case
                // - FBO is not supported
                // - Either source or target is luminance due doesn't looks like supported by hardware
                // - the source dimensions match the destination ones, in which case no scaling is needed
                // TODO: Check that extension is NOT available
                var pSourceOrigin = arguments[0];
                var pDestBox = arguments[1];
                if(akra.pixelUtil.isLuminance(pSourceOrigin.format) || akra.pixelUtil.isLuminance(this._eFormat) || (pSourceOrigin.width === pDestBox.width && pSourceOrigin.height === pDestBox.height && pSourceOrigin.depth === pDestBox.depth)) {
                    return _super.prototype.blitFromMemory.call(this, pSourceOrigin, pDestBox);
                }
                if(!this._pBuffer.contains(pDestBox)) {
                    akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 626);
                    akra.logger.criticalError("Destination box out of range");
                    ;
                }
                var pSource;
                // First, convert the srcbox to a OpenGL compatible pixel format
                if(webgl.getWebGLOriginFormat(pSourceOrigin.format) === 0) {
                    // Convert to buffer internal format
                    var iSizeInBytes = akra.pixelUtil.getMemorySize(pSourceOrigin.width, pSourceOrigin.height, pSourceOrigin.depth, this._eFormat);
                    pSource = new akra.pixelUtil.PixelBox(pSourceOrigin.width, pSourceOrigin.height, pSourceOrigin.depth, this._eFormat, new Uint8Array(iSizeInBytes));
                    akra.pixelUtil.bulkPixelConversion(pSourceOrigin, pSource);
                } else {
                    // No conversion needed
                    pSource = pSourceOrigin;
                }
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                // Create temporary texture to store source data
                var pTempWebGLTexture = null;
                var eTarget = 0x0DE1;
                var iWidth = akra.math.ceilingPowerOfTwo(pSource.width);
                var iHeight = akra.math.ceilingPowerOfTwo(pSource.height);
                var iWebGLFormat = webgl.getClosestWebGLInternalFormat(pSource.format);
                var iWebGLDataType = webgl.getWebGLOriginDataType(pSource.format);
                pTempWebGLTexture = pWebGLRenderer.createWebGLTexture();
                if(akra.isNull(pTempWebGLTexture)) {
                    akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 659);
                    akra.logger.error("Can not create WebGL texture");
                    ;
                    return false;
                }
                pWebGLRenderer.bindWebGLTexture(eTarget, pTempWebGLTexture);
                pWebGLContext.texImage2D(eTarget, 0, iWebGLFormat, iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, null);
                var pTextureBufferPool = this.getManager().textureBufferPool;
                var pTempTexBuffer = pTextureBufferPool.createResource(".temp");
                pTempTexBuffer.create(eTarget, pTempWebGLTexture, iWidth, iHeight, iWebGLFormat, pSource.format, 0, 0, 256 /* AUTOMIPMAP */  | 1 /* STATIC */ , false);
                // Upload data to 0,0,0 in temporary texture
                var pTempBoxTarget = new akra.geometry.Box(0, 0, 0, pSource.width, pSource.height, pSource.depth);
                pTempTexBuffer.upload(pSource, pTempBoxTarget);
                //Blit
                this.blitFromTexture(pTempTexBuffer, pTempBoxTarget, pDestBox);
                //Delete temp data
                pTextureBufferPool.destroyResource(pTempTexBuffer);
                pWebGLRenderer.deleteWebGLTexture(pTempWebGLTexture);
                pTempWebGLTexture = null;
                pTempBoxTarget = null;
                return true;
            };
            WebGLTextureBuffer.prototype.getRenderTarget = function /** @no-inline */(iZOffest) {
                if (typeof iZOffest === "undefined") { iZOffest = 0; }
                akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 694);
                akra.logger.assert((((this._iFlags) & (512 /* RENDERTARGET */ )) != 0));
                ;
                akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 695);
                akra.logger.assert(iZOffest < this._iDepth);
                ;
                return this._pRTTList[iZOffest];
            };
            WebGLTextureBuffer.prototype.resize = function /** @no-inline */(iWidth, iHeight) {
                if(arguments.length === 1) {
                    akra.logger.setSourceLocation("webgl/WebGLTextureBuffer.ts", 702);
                    akra.logger.criticalError("resize with one parametr not available for WebGLTextureBuffer");
                    ;
                    return false;
                }
                var pSrcBox = new akra.geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
                var pDestBox = new akra.geometry.Box(0, 0, 0, iWidth, iHeight, this._iDepth);
                return this.blitFromTexture(this, pSrcBox, pDestBox);
            };
            return WebGLTextureBuffer;
        })(webgl.WebGLPixelBuffer);
        webgl.WebGLTextureBuffer = WebGLTextureBuffer;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLInternalTexture = (function (_super) {
            __extends(WebGLInternalTexture, _super);
            function /** @no-inline */WebGLInternalTexture() {
                        _super.call(this);
                this._pSurfaceList = null;
                this._pWebGLTexture = null;
            }
            WebGLInternalTexture.prototype.getWebGLTextureTarget = function /** @no-inline */() {
                switch(this._eTextureType) {
                    case 5890 /* TEXTURE */ :
                    case 3553 /* TEXTURE_2D */ :
                        return 0x0DE1;
                    case 34067 /* TEXTURE_CUBE_MAP */ :
                        return 0x8513;
                    default:
                        return 0;
                }
            };
            WebGLInternalTexture.prototype.createInternalTextureImpl = /**@protected*/ function /** @no-inline */(cFillColor) {
                if (typeof cFillColor === "undefined") { cFillColor = null; }
                if(!akra.isNull(cFillColor)) {
                    akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 36);
                    akra.logger.warning("Texture can create with filled only by default(black) color");
                    ;
                    //TODO: must implement filling by color
                                    }
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                // Convert to nearest power-of-two size if required
                this._iWidth = akra.math.ceilingPowerOfTwo(this._iWidth);
                this._iHeight = akra.math.ceilingPowerOfTwo(this._iHeight);
                this._iDepth = akra.math.ceilingPowerOfTwo(this._iDepth);
                // Adjust format if required
                this._eFormat = this.getNativeFormat(this._eTextureType, this._eFormat, this._iFlags);
                // Check requested number of mipmaps
                var nMaxMips = akra.webgl.getMaxMipmaps(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
                if(akra.pixelUtil.isCompressed(this._eFormat) && (this._nMipLevels === 0)) {
                    this._nRequestedMipLevels = 0;
                }
                this._nMipLevels = this._nRequestedMipLevels;
                if(this._nMipLevels > nMaxMips) {
                    this._nMipLevels = nMaxMips;
                }
                var iWebGLTarget = this.getWebGLTextureTarget();
                this._pWebGLTexture = pWebGLRenderer.createWebGLTexture();
                pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);
                this._isMipmapsHardwareGenerated = pWebGLRenderer.hasCapability(akra.ERenderCapabilities.AUTOMIPMAP);
                // Set some misc default parameters, these can of course be changed later
                pWebGLContext.texParameteri(iWebGLTarget, 0x2801, 0x2600);
                pWebGLContext.texParameteri(iWebGLTarget, 0x2800, 0x2600);
                pWebGLContext.texParameteri(iWebGLTarget, 0x2802, 0x812F);
                pWebGLContext.texParameteri(iWebGLTarget, 0x2803, 0x812F);
                var iWebGLFormat = akra.webgl.getClosestWebGLInternalFormat(this._eFormat);
                var iWebGLDataType = akra.webgl.getWebGLOriginDataType(this._eFormat);
                var iWidth = this._iWidth;
                var iHeight = this._iHeight;
                var iDepth = this._iDepth;
                if(akra.pixelUtil.isCompressed(this._eFormat)) {
                    // Compressed formats
                    var iSize = akra.pixelUtil.getMemorySize(iWidth, iHeight, iDepth, this._eFormat);
                    // Provide temporary buffer filled with zeroes as glCompressedTexImageXD does not
                    // accept a 0 pointer like normal glTexImageXD
                    // Run through this process for every mipmap to pregenerate mipmap pyramid
                    //TODO: можем мы можем подать просто null, надо проверить
                    var pTmpData = new Uint8Array(iSize);
                    var pEmptyData;
                    var mip = 0;
                    for(mip = 0; mip <= this._nMipLevels; mip++) {
                        iSize = akra.pixelUtil.getMemorySize(iWidth, iHeight, iDepth, this._eFormat);
                        pEmptyData = pTmpData.subarray(0, iSize);
                        switch(this._eTextureType) {
                            case 5890 /* TEXTURE */ :
                            case 3553 /* TEXTURE_2D */ :
                                pWebGLContext.compressedTexImage2D(0x0DE1, mip, iWebGLFormat, iWidth, iHeight, 0, pTmpData);
                                break;
                            case 34067 /* TEXTURE_CUBE_MAP */ :
                                var iFace = 0;
                                for(iFace = 0; iFace < 6; iFace++) {
                                    pWebGLContext.compressedTexImage2D(0x8515 + iFace, mip, iWebGLFormat, iWidth, iHeight, 0, pTmpData);
                                }
                                break;
                            default:
                                break;
                        }
                        ;
                        if(iWidth > 1) {
                            iWidth = iWidth / 2;
                        }
                        if(iHeight > 1) {
                            iHeight = iHeight / 2;
                        }
                        if(iDepth > 1) {
                            iDepth = iDepth / 2;
                        }
                    }
                    pTmpData = null;
                    pEmptyData = null;
                } else {
                    var mip = 0;
                    // Run through this process to pregenerate mipmap pyramid
                    for(mip = 0; mip <= this._nMipLevels; mip++) {
                        // Normal formats
                        switch(this._eTextureType) {
                            case 5890 /* TEXTURE */ :
                            case 3553 /* TEXTURE_2D */ :
                                pWebGLContext.texImage2D(0x0DE1, mip, iWebGLFormat, iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, null);
                                break;
                            case 34067 /* TEXTURE_CUBE_MAP */ :
                                var iFace = 0;
                                for(iFace = 0; iFace < 6; iFace++) {
                                    pWebGLContext.texImage2D(0x8515 + iFace, mip, iWebGLFormat, iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, null);
                                }
                                break;
                            default:
                                break;
                        }
                        if(iWidth > 1) {
                            iWidth = iWidth / 2;
                        }
                        if(iHeight > 1) {
                            iHeight = iHeight / 2;
                        }
                        if(iDepth > 1) {
                            iDepth = iDepth / 2;
                        }
                    }
                }
                this._createSurfaceList();
                // Get final internal format
                this._eFormat = this.getBuffer(0, 0).format;
                return false;
            };
            WebGLInternalTexture.prototype.freeInternalTextureImpl = /**@protected*/ function /** @no-inline */() {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);
                this._pWebGLTexture = null;
                for(var i = 0; i < this._pSurfaceList.length; i++) {
                    this._pSurfaceList[i].release();
                }
                this._pSurfaceList = null;
                return true;
            };
            WebGLInternalTexture.prototype._createSurfaceList = function /** @no-inline */() {
                this._pSurfaceList = new Array();
                // For all faces and mipmaps, store surfaces as IPixelBuffer
                var bWantGeneratedMips = (((this._iFlags) & (256 /* AUTOMIPMAP */ )) != 0);
                // Do mipmapping in software? (uses GLU) For some cards, this is still needed. Of course,
                // only when mipmap generation is desired.
                var bDoSoftware = bWantGeneratedMips && !this._isMipmapsHardwareGenerated && this._nMipLevels !== 0;
                var iFace = 0;
                var mip = 0;
                var pTextureBufferPool = this.getManager().textureBufferPool;
                var sResourceName = this.findResourceName();
                for(iFace = 0; iFace < this.getNumFaces(); iFace++) {
                    var iWidth = this._iWidth;
                    var iHeight = this._iHeight;
                    for(mip = 0; mip <= this._nMipLevels; mip++) {
                        var pBuf = pTextureBufferPool.createResource(sResourceName + "_" + iFace + "_" + mip);
                        pBuf.create(this.getWebGLTextureTarget(), this._pWebGLTexture, iWidth, iHeight, akra.webgl.getClosestWebGLInternalFormat(this._eFormat), akra.webgl.getWebGLOriginDataType(this._eFormat), iFace, mip, this._iFlags, bDoSoftware && mip === 0);
                        this._pSurfaceList.push(pBuf);
                        //check error
                        if(pBuf.width === 0 || pBuf.height === 0 || pBuf.depth === 0) {
                            akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 223);
                            akra.logger.criticalError("Zero sized texture surface on texture " + sResourceName + " face " + iFace + " mipmap " + mip + ". The GL driver probably refused to create the texture.");
                            ;
                        }
                    }
                }
            };
            WebGLInternalTexture.prototype.getBuffer = function /** @no-inline */(iFace, iMipmap) {
                if (typeof iFace === "undefined") { iFace = 1; }
                if (typeof iMipmap === "undefined") { iMipmap = 0; }
                if(iFace >= this.getNumFaces()) {
                    akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 232);
                    akra.logger.criticalError("Face index out of range");
                    ;
                }
                if(iMipmap > this._nMipLevels) {
                    akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 236);
                    akra.logger.criticalError("Mipmap index out of range");
                    ;
                }
                var idx = iFace * (this._nMipLevels + 1) + iMipmap;
                akra.logger.setSourceLocation("webgl/WebGLInternalTexture.ts", 240);
                akra.logger.assert(idx < this._pSurfaceList.length, "smth");
                ;
                return this._pSurfaceList[idx];
            };
            WebGLInternalTexture.prototype.getNativeFormat = function /** @no-inline */(eTextureType, eFormat, iFlags) {
                if (typeof eTextureType === "undefined") { eTextureType = this._eTextureType; }
                if (typeof eFormat === "undefined") { eFormat = this._eFormat; }
                if (typeof iFlags === "undefined") { iFlags = this._iFlags; }
                var pRenderer = this.getManager().getEngine().getRenderer();
                if(akra.pixelUtil.isCompressed(eFormat) && !pRenderer.hasCapability(akra.ERenderCapabilities.TEXTURE_COMPRESSION_DXT) && !pRenderer.hasCapability(akra.ERenderCapabilities.TEXTURE_COMPRESSION_PVRTC)) {
                    return 12 /* A8R8G8B8 */ ;
                }
                // if floating point textures not supported, revert to PF_A8R8G8B8
                if(akra.pixelUtil.isFloatingPoint(eFormat) && pRenderer.hasCapability(akra.ERenderCapabilities.TEXTURE_FLOAT)) {
                    return 12 /* A8R8G8B8 */ ;
                }
                // Check if this is a valid rendertarget format
                if((((iFlags) & (512 /* RENDERTARGET */ )) != 0)) {
                    /// Get closest supported alternative
                    /// If mFormat is supported it's returned
                    return akra.webgl.getSupportedAlternative(eFormat);
                }
                // Supported
                return eFormat;
            };
            WebGLInternalTexture.prototype.createRenderTexture = function /** @no-inline */() {
                // Create the GL texture
                // This already does everything necessary
                return this.createInternalTexture();
            };
            return WebGLInternalTexture;
        })(akra.core.pool.resources.Texture);
        webgl.WebGLInternalTexture = WebGLInternalTexture;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (data) {
        var EVertexDataLimits;
        (function (EVertexDataLimits) {
            EVertexDataLimits._map = [];
            EVertexDataLimits.k_MaxElementsSize = 256;
        })(EVertexDataLimits || (EVertexDataLimits = {}));
        ;
        var VertexData = (function () {
            function /** @no-inline */VertexData(pVertexBuffer, id, iOffset, iCount, pDecl) {
                this._iGuid = eval("this._iGuid || akra.sid()");
                this._pUnicastSlotMap = null;
                this._pBroadcastSlotList = null;
                this._pVertexBuffer = pVertexBuffer;
                this._iOffset = iOffset;
                this._iLength = iCount;
                this._iId = id;
                this._pVertexDeclaration = null;
                this._iStride = 0;
                if(akra.isInt(pDecl)) {
                    this._iStride = pDecl;
                } else {
                    this.setVertexDeclaration(pDecl);
                }
                akra.logger.setSourceLocation("data/VertexData.ts", 58);
                akra.logger.assert(pVertexBuffer.byteLength >= this.byteLength + this.byteOffset, "vertex data out of array linits");
                ;
            }
            Object.defineProperty(VertexData.prototype, "id", {
                get: function /** @inline */() {
                    return this._iId;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VertexData.prototype, "length", {
                get: function /** @inline */() {
                    return this._iLength;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VertexData.prototype, "byteOffset", {
                get: function /** @inline */() {
                    return this._iOffset;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VertexData.prototype, "byteLength", {
                get: function /** @inline */() {
                    return this._iLength * this._iStride;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VertexData.prototype, "buffer", {
                get: function /** @inline */() {
                    return this._pVertexBuffer;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VertexData.prototype, "stride", {
                get: function /** @inline */() {
                    return this._iStride;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VertexData.prototype, "startIndex", {
                get: function /** @inline */() {
                    var iIndex = this.byteOffset / this.stride;
                    akra.logger.setSourceLocation("data/VertexData.ts", 34);
                    akra.logger.assert(iIndex % 1 == 0, "cannot calc first element index");
                    ;
                    return iIndex;
                },
                enumerable: true,
                configurable: true
            });
            VertexData.prototype.getVertexDeclaration = function /** @no-inline */() {
                return this._pVertexDeclaration;
            };
            VertexData.prototype.setVertexDeclaration = function /** @no-inline */(pDecl) {
                if(this._pVertexDeclaration) {
                    akra.logger.setSourceLocation("data/VertexData.ts", 68);
                    akra.logger.error("vertex declaration already exists");
                    ;
                    return false;
                }
                var iStride = pDecl.stride;
                this._pVertexDeclaration = pDecl.clone();
                akra.logger.setSourceLocation("data/VertexData.ts", 79);
                akra.logger.assert(iStride < 256 /* k_MaxElementsSize */ , "stride max is 255 bytes");
                ;
                akra.logger.setSourceLocation("data/VertexData.ts", 81);
                akra.logger.assert(iStride <= this.stride, "stride in VertexDeclaration grather than stride in construtor");
                ;
                return true;
            };
            VertexData.prototype.getVertexElementCount = function /** @inline */() {
                return this._pVertexDeclaration.length;
            };
            VertexData.prototype.hasSemantics = function /** @no-inline */(sUsage) {
                if(this._pVertexDeclaration != null) {
                    return this._pVertexDeclaration.hasSemantics(sUsage);
                }
                return false;
            };
            VertexData.prototype.destroy = function /** @no-inline */() {
                this._pVertexDeclaration = null;
                this._iLength = 0;
            };
            VertexData.prototype.extend = function /** @no-inline */(pDecl, pData) {
                if (typeof pData === "undefined") { pData = null; }
                pDecl = akra.createVertexDeclaration(pDecl);
                if(akra.isNull(pData)) {
                    pData = new Uint8Array(this.length * pDecl.stride);
                } else {
                    pData = new Uint8Array(pData.buffer);
                }
                akra.logger.setSourceLocation("data/VertexData.ts", 113);
                akra.logger.assert(this.length === pData.byteLength / pDecl.stride, 'invalid data size for extending');
                ;
                var nCount = this._iLength;
                //strides modifications
                var nStrideNew = pDecl.stride;
                var nStridePrev = this.stride;
                var nStrideNext = nStridePrev + nStrideNew;
                //total bytes after extending
                var nTotalSize = nStrideNext * this.length;
                var pDeclNew = this.getVertexDeclaration().clone();
                //data migration
                var pDataPrev = new Uint8Array(this.getData());
                var pDataNext = new Uint8Array(nTotalSize);
                for(var i = 0, iOffset; i < nCount; ++i) {
                    iOffset = i * nStrideNext;
                    pDataNext.set(pDataPrev.subarray(i * nStridePrev, (i + 1) * nStridePrev), iOffset);
                    pDataNext.set((pData).subarray(i * nStrideNew, (i + 1) * nStrideNew), iOffset + nStridePrev);
                }
                if(!pDeclNew.extend(pDecl)) {
                    return false;
                }
                if(!this.resize(nCount, pDeclNew)) {
                    return false;
                }
                return this.setData(pDataNext, 0, nStrideNext);
            };
            VertexData.prototype.resize = function /** @no-inline */(nCount, pDecl) {
                var iStride = 0;
                var iOldOffset = this.byteOffset;
                var pOldVertexBuffer;
                var pOldVertexDeclaration;
                var iOldStride;
                if(arguments.length == 2) {
                    if(akra.isInt(pDecl)) {
                        iStride = pDecl;
                    } else {
                        iStride = (pDecl).stride;
                    }
                    if(nCount * iStride <= this.byteLength) {
                        this._iLength = nCount;
                        this._iStride = iStride;
                        this._pVertexDeclaration = null;
                        if(!akra.isInt(pDecl)) {
                            this.setVertexDeclaration(pDecl);
                        }
                        return true;
                    } else {
                        pOldVertexBuffer = this.buffer;
                        pOldVertexBuffer.freeVertexData(this);
                        if(pOldVertexBuffer.getEmptyVertexData(nCount, pDecl, this) !== this) {
                            return false;
                        }
                        if(this.byteOffset != iOldOffset) {
                            akra.logger.setSourceLocation("data/VertexData.ts", 184);
                            akra.logger.warning("vertex data moved from " + iOldOffset + " ---> " + this.byteOffset);
                            ;
                            this.relocation(this, iOldOffset, this.byteOffset);
                        }
                        return true;
                    }
                } else if(arguments.length == 1) {
                    if(nCount <= this.length) {
                        this._iLength = nCount;
                        return true;
                    } else {
                        pOldVertexBuffer = this.buffer;
                        pOldVertexDeclaration = this.getVertexDeclaration();
                        iOldStride = this.stride;
                        pOldVertexBuffer.freeVertexData(this);
                        if(pOldVertexBuffer.getEmptyVertexData(nCount, iOldStride, this) == null) {
                            return false;
                        }
                        this.setVertexDeclaration(pOldVertexDeclaration);
                        if(this.byteOffset != iOldOffset) {
                            akra.logger.setSourceLocation("data/VertexData.ts", 210);
                            akra.logger.warning("vertex data moved from " + iOldOffset + " ---> " + this.byteOffset);
                            ;
                            this.relocation(this, iOldOffset, this.byteOffset);
                        }
                        return true;
                    }
                }
                return false;
            };
            VertexData.prototype.applyModifier = function /** @no-inline */(sUsage, fnModifier) {
                var pData = this.getTypedData(sUsage);
                fnModifier(pData);
                return this.setData(pData, sUsage);
            };
            VertexData.prototype.setData = function /** @no-inline */(pData, iOffset, iSize, nCountStart, nCount) {
                var iStride;
                var pVertexBuffer = this._pVertexBuffer;
                var pBackupBuf;
                var pDataU8;
                var k;
                var iOffsetBuffer;
                var pDeclaration = this._pVertexDeclaration;
                var pElement;
                switch(arguments.length) {
                    case 5:
                        iStride = this.stride;
                        pDataU8 = new Uint8Array(pData.buffer);
                        if(iStride != iSize) {
                            //FIXME: очень тормознутое место, крайне медленно работает...
                            if(pVertexBuffer.isBackupPresent() && nCount > 1) {
                                pBackupBuf = new Uint8Array(this._pVertexBuffer.byteLength);
                                this._pVertexBuffer.readData(pBackupBuf);
                                iOffsetBuffer = this.byteOffset;
                                for(var i = nCountStart; i < nCount + nCountStart; i++) {
                                    for(k = 0; k < iSize; k++) {
                                        pBackupBuf[iStride * i + iOffset + iOffsetBuffer + k] = pDataU8[iSize * (i - nCountStart) + k];
                                    }
                                }
                                pVertexBuffer.writeData(pBackupBuf, 0, pVertexBuffer.byteLength);
                            } else {
                                for(var i = nCountStart; i < nCount + nCountStart; i++) {
                                    pVertexBuffer.writeData(/*pData.buffer.slice*/
                                    pDataU8.subarray(iSize * (i - nCountStart), iSize * (i - nCountStart) + iSize), iStride * i + iOffset + this.byteOffset, iSize);
                                }
                            }
                        } else {
                            pVertexBuffer.writeData(/*pData.buffer.slice*/
                            pDataU8.subarray(0, iStride * nCount), iOffset + this.byteOffset, iStride * nCount);
                        }
                        return true;
                    case 4:
                        pElement = null;
                        if(akra.isString(arguments[1])) {
                            pElement = pDeclaration.findElement(arguments[1]);
                            if(pElement) {
                                return this.setData(pData, pElement.offset, pElement.size, arguments[2], arguments[3]);
                            }
                            return false;
                        }
                        nCountStart = nCountStart || 0;
                        if(!nCount) {
                            nCount = pData.byteLength / iSize;
                        }
                        return this.setData(pData, iOffset, iSize, nCountStart, nCount);
                    case 2:
                    case 3:
                        var pDeclaration = this._pVertexDeclaration, pElement = null;
                        if(akra.isString(arguments[1])) {
                            pElement = pDeclaration.findElement(arguments[1]);
                            if(pElement) {
                                arguments[2] = arguments[2] || 0;
                                if(!arguments[3]) {
                                    arguments[3] = pData.buffer.byteLength / pElement.size;
                                }
                                return this.setData(pData, pElement.offset, pElement.size, arguments[2], arguments[3]);
                            }
                            return false;
                        } else if(arguments.length === 3) {
                            nCountStart = nCountStart || 0;
                            if(!nCount) {
                                nCount = pData.byteLength / iSize;
                            }
                            return this.setData(pData, iOffset, iSize, nCountStart, nCount);
                        }
                        return false;
                    case 1:
                        return this.setData(pData, this._pVertexDeclaration[0].eUsage);
                    default:
                        return false;
                }
            };
            VertexData.prototype.getData = function /** @no-inline */(iOffset, iSize, iFrom, iCount) {
                switch(arguments.length) {
                    case 4:
                    case 2:
                        if(akra.isString(arguments[0])) {
                            return null;
                        }
                        iFrom = iFrom || 0;
                        iCount = iCount || this._iLength;
                        iCount = akra.math.min(iCount, this._iLength);
                        var iStride = this.stride;
                        var pBufferData = new Uint8Array(iSize * this.length);
                        for(var i = iFrom; i < iCount; i++) {
                            this._pVertexBuffer.readData(iStride * i + iOffset + this.byteOffset, iSize, pBufferData.subarray(i * iSize, i * iSize + iSize));
                            //pBufferData.set(new Uint8Array(), i * iSize);
                                                    }
                        return pBufferData.buffer;
                    case 3:
                    case 1:
                        var pDeclaration = this._pVertexDeclaration, pElement = null;
                        if(akra.isString("string")) {
                            pElement = pDeclaration.findElement(arguments[0]);
                            if(pElement) {
                                return this.getData(pElement.offset, pElement.size, arguments[1], arguments[2]);
                            }
                            return null;
                        }
                        return null;
                    case 0:
                        return this.getData(0, this._pVertexDeclaration.stride);
                    default:
                        return null;
                }
            };
            VertexData.prototype.getTypedData = function /** @no-inline */(sUsage, iFrom, iCount) {
                sUsage = sUsage || this._pVertexDeclaration[0].sUsage;
                var pVertexElement = this._pVertexDeclaration.findElement(sUsage);
                if(pVertexElement) {
                    return akra.util.abtota(this.getData(sUsage, iFrom, iCount), pVertexElement.type);
                }
                return null;
            };
            VertexData.prototype.getBufferHandle = function /** @inline */() {
                return this._pVertexBuffer.resourceHandle;
            };
            VertexData.prototype.toString = function /** @no-inline */() {
                if(akra.DEBUG) {
                    var s = "";
                    s += "          VERTEX DATA  #" + this.id + "\n";
                    s += "---------------+-----------------------\n";
                    s += "        BUFFER : " + this.getBufferHandle() + "\n";
                    s += "          SIZE : " + this.byteLength + " b.\n";
                    s += "        OFFSET : " + this.byteOffset + " b.\n";
                    s += "---------------+-----------------------\n";
                    s += " MEMBERS COUNT : " + this.length + " \n";
                    s += "        STRIDE : " + this.stride + " \n";
                    s += "---------------+-----------------------\n";
                    s += this.getVertexDeclaration().toString();
                    return s;
                }
                return null;
            };
            VertexData._pEventTable = new akra.events.EventTable();
            VertexData.prototype.getEventTable = function /** @inline */() {
                return VertexData._pEventTable;
            };
            VertexData.prototype.getGuid = function /** @no-inline */() {
                return this._iGuid < 0 ? (this._iGuid = akra.sid()) : this._iGuid;
            };
            VertexData.prototype.connect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            VertexData.prototype.disconnect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            VertexData.prototype.bind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType);
            };
            VertexData.prototype.unbind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType);
            };
            VertexData.prototype.relocation = function /** @no-inline */(pTarget, iFrom, iTo) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).relocation;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pTarget, iFrom, iTo) : _broadcast[i].listener(_recivier, pTarget, iFrom, iTo);
                    }
                }
            };
            return VertexData;
        })();
        data.VertexData = VertexData;        
        // BEGIN_EVENT_TABLE(VertexData);
        // relocation(pTarget: IVertexData, iFrom: uint, iTo: uint): void {
        // 	EMIT_BROADCAST(relocation, CALL(pTarget, iFrom, iTo));
        // }
        // END_EVENT_TABLE();
            })(akra.data || (akra.data = {}));
    var data = akra.data;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var MemoryBuffer = (function (_super) {
                    __extends(MemoryBuffer, _super);
                    function MemoryBuffer() {
                        _super.apply(this, arguments);

                    }
                    Object.defineProperty(MemoryBuffer.prototype, "byteLength", {
                        get: function /** @inline */() {
                            return this._pData.byteLength;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    MemoryBuffer.prototype.create = function /** @no-inline */(iByteSize, iFlags) {
                        if (typeof iFlags === "undefined") { iFlags = 2 /* DYNAMIC */ ; }
                        ((iFlags) &= ~(8 /* BACKUP_COPY */  | 64 /* DISCARDABLE */  | 32 /* ALIGNMENT */ ));
                        var isCreated = _super.prototype.create.call(this, iFlags | 16 /* SOFTWARE */ );
                        this._pData = new Uint8Array(iByteSize);
                        return isCreated;
                    };
                    MemoryBuffer.prototype.destroy = function /** @no-inline */() {
                        _super.prototype.destroy.call(this);
                        this._pData = null;
                    };
                    MemoryBuffer.prototype.resize = function /** @no-inline */(iSize) {
                        var pData = new Uint8Array(iSize);
                        pData.set(this._pData);
                        this._pData = pData;
                        this.notifyAltered();
                        return true;
                    };
                    MemoryBuffer.prototype.lockImpl = function /** @no-inline */(iOffset, iLength, iLockFlags) {
                        return this._pData.subarray(iOffset, iOffset + iLength);
                    };
                    MemoryBuffer.prototype.readData = function /** @no-inline */(iOffset, iSize, ppDest) {
                        if(arguments.length < 3) {
                            ppDest = arguments[0];
                            iOffset = 0;
                            iSize = ppDest.byteLength;
                        }
                        akra.logger.setSourceLocation("MemoryBuffer.ts", 55);
                        akra.logger.assert((iOffset + iSize) <= this.byteLength);
                        ;
                        akra.memcpy((ppDest).buffer, 0, this._pData.buffer, iOffset, iSize);
                        return true;
                    };
                    MemoryBuffer.prototype.writeData = function /** @no-inline */(pData, iOffset, iSize, bDiscardWholeBuffer) {
                        if (typeof bDiscardWholeBuffer === "undefined") { bDiscardWholeBuffer = false; }
                        akra.logger.setSourceLocation("MemoryBuffer.ts", 64);
                        akra.logger.assert((iOffset + iSize) <= this.byteLength);
                        ;
                        if(arguments.length < 3) {
                            iOffset = 0;
                            iSize = pData.byteLength;
                        }
                        akra.memcpy(this._pData.buffer, 0, (pData).buffer, iOffset, iSize);
                        this.notifyAltered();
                        return true;
                    };
                    return MemoryBuffer;
                })(resources.HardwareBuffer);
                resources.MemoryBuffer = MemoryBuffer;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var VertexBuffer = (function (_super) {
                    __extends(VertexBuffer, _super);
                    /*pManager: IResourcePoolManager*/
                    function /** @no-inline */VertexBuffer() {
                        /*pManager*/
                                        _super.call(this);
                        /**@protected*/ this._pVertexDataArray = [];
                        /**@protected*/ this._iDataCounter = 0;
                    }
                    Object.defineProperty(VertexBuffer.prototype, "type", {
                        get: function /** @inline */() {
                            return 0 /* UNKNOWN */ ;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(VertexBuffer.prototype, "length", {
                        get: function /** @inline */() {
                            return this._pVertexDataArray.length;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    VertexBuffer.prototype.create = function /** @no-inline */(iByteSize, iFlags, pData) {
                        _super.prototype.create.call(this, iFlags || 0);
                        if((((iFlags) & (8 /* BACKUP_COPY */ )) != 0)) {
                            this._pBackupCopy = new resources.MemoryBuffer();
                            this._pBackupCopy.create(iByteSize);
                            this._pBackupCopy.writeData(pData, 0, iByteSize);
                        }
                        return true;
                    };
                    VertexBuffer.prototype.destroy = function /** @no-inline */() {
                        _super.prototype.destroy.call(this);
                        this._pBackupCopy.destroy();
                        this.freeVertexData();
                        this._iDataCounter = 0;
                    };
                    VertexBuffer.prototype.getVertexData = function /** @no-inline */(iOffset, iCount, pData) {
                        if(arguments.length < 2) {
                            return this._pVertexDataArray[arguments[0]];
                        }
                        var pDecl = akra.createVertexDeclaration(pData);
                        var pVertexData = new akra.data.VertexData(this, this._iDataCounter++, iOffset, iCount, pDecl);
                        this._pVertexDataArray.push(pVertexData);
                        this.notifyAltered();
                        return pVertexData;
                    };
                    VertexBuffer.prototype.getEmptyVertexData = function /** @no-inline */(iCount, pDeclData, ppVertexDataIn) {
                        var pDecl;
                        var pHole = [];
                        var i;
                        var pVertexData;
                        var iTemp;
                        var iStride = 0;
                        var iAligStart;
                        while(true) {
                            pHole[0] = {
                                start: 0,
                                end: this.byteLength
                            };
                            for(var k = 0; k < this._pVertexDataArray.length; ++k) {
                                pVertexData = this._pVertexDataArray[k];
                                for(i = 0; i < pHole.length; i++) {
                                    //Полностью попадает внутрь
                                    if(pVertexData.byteOffset > pHole[i].start && pVertexData.byteOffset + pVertexData.byteLength < pHole[i].end) {
                                        iTemp = pHole[i].end;
                                        pHole[i].end = pVertexData.byteOffset;
                                        pHole.splice(i + 1, 0, {
                                            start: pVertexData.byteOffset + pVertexData.byteLength,
                                            end: iTemp
                                        });
                                        i--;
                                    } else if(pVertexData.byteOffset == pHole[i].start && pVertexData.byteOffset + pVertexData.byteLength < pHole[i].end) {
                                        pHole[i].start = pVertexData.byteOffset + pVertexData.byteLength;
                                    } else if(pVertexData.byteOffset > pHole[i].start && pVertexData.byteOffset + pVertexData.byteLength == pHole[i].end) {
                                    } else if(pVertexData.byteOffset == pHole[i].start && pVertexData.byteLength == (pHole[i].end - pHole[i].start)) {
                                        pHole.splice(i, 1);
                                        i--;
                                    } else //Перекрывает снизу
                                    if(pVertexData.byteOffset < pHole[i].start && pVertexData.byteOffset + pVertexData.byteLength > pHole[i].start && pVertexData.byteOffset + pVertexData.byteLength < pHole[i].end) {
                                        pHole[i].start = pVertexData.byteOffset + pVertexData.byteLength;
                                    } else if(pVertexData.byteOffset < pHole[i].start && pVertexData.byteOffset + pVertexData.byteLength > pHole[i].start && pVertexData.byteOffset + pVertexData.byteLength == pHole[i].end) {
                                        pHole.splice(i, 1);
                                        i--;
                                    } else //Перекрывается сверху
                                    if(pVertexData.byteOffset + pVertexData.byteLength > pHole[i].end && pVertexData.byteOffset > pHole[i].start && pVertexData.byteOffset < pHole[i].end) {
                                        pHole[i].end = pVertexData.byteOffset;
                                    } else if(pVertexData.byteOffset + pVertexData.byteLength > pHole[i].end && pVertexData.byteOffset == pHole[i].start && pVertexData.byteOffset < pHole[i].end) {
                                        pHole.splice(i, 1);
                                        i--;
                                    } else //полнстью перекрывает
                                    if(pVertexData.byteOffset < pHole[i].start && pVertexData.byteOffset + pVertexData.byteLength > pHole[i].end) {
                                        i--;
                                    }
                                }
                            }
                            pHole.sort(function /** @inline */(a, b) {
                                return ((a.end - a.start) - (b.end - b.start));
                            });
                            if(akra.isInt(pDeclData)) {
                                pDecl = akra.createVertexDeclaration(pDeclData);
                                iStride = pDecl.stride;
                            } else {
                                iStride = pDeclData;
                            }
                            for(i = 0; i < pHole.length; i++) {
                                iAligStart = this.isAligned() ? akra.math.alignUp(pHole[i].start, akra.math.nok(iStride, 4)) : akra.math.alignUp(pHole[i].start, iStride);
                                if((pHole[i].end - iAligStart) >= iCount * iStride) {
                                    if(arguments.length == 2) {
                                        pVertexData = new akra.data.VertexData(this, this._iDataCounter++, iAligStart, iCount, pDeclData);
                                        this._pVertexDataArray.push(pVertexData);
                                        this.notifyAltered();
                                        return pVertexData;
                                    } else if(arguments.length == 3) {
                                        ((ppVertexDataIn).constructor).call(ppVertexDataIn, this, iAligStart, iCount, pDeclData);
                                        this._pVertexDataArray.push(ppVertexDataIn);
                                        this.notifyAltered();
                                        return ppVertexDataIn;
                                    }
                                    return null;
                                }
                            }
                            if(this.resize(akra.math.max(this.byteLength * 2, this.byteLength + iCount * iStride)) == false) {
                                break;
                            }
                        }
                        return null;
                    };
                    VertexBuffer.prototype.freeVertexData = function /** @no-inline */(pVertexData) {
                        if(arguments.length == 0) {
                            for(var i = 0; i < this._pVertexDataArray.length; i++) {
                                this._pVertexDataArray[Number(i)].destroy();
                            }
                            this._pVertexDataArray = null;
                        } else {
                            for(var i = 0; i < this._pVertexDataArray.length; i++) {
                                if(this._pVertexDataArray[i] == pVertexData) {
                                    pVertexData.destroy();
                                    this._pVertexDataArray.splice(i, 1);
                                    this.notifyAltered();
                                    return true;
                                }
                            }
                            return false;
                        }
                        this.notifyAltered();
                        return true;
                    };
                    VertexBuffer.prototype.allocateData = function /** @no-inline */(pDeclData, pData) {
                        var pDecl = akra.createVertexDeclaration(pDeclData);
                        var pVertexData;
                        var iCount = pData.byteLength / pDecl.stride;
                        akra.logger.setSourceLocation("core/pool/resources/VertexBuffer.ts", 221);
                        akra.logger.assert(iCount === akra.math.floor(iCount), 'Data size should be a multiple of the vertex declaration.');
                        ;
                        pVertexData = this.getEmptyVertexData(iCount, pDecl);
                        pVertexData.setData(pData, 0, pDecl.stride);
                        return pVertexData;
                    };
                    return VertexBuffer;
                })(resources.HardwareBuffer);
                resources.VertexBuffer = VertexBuffer;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLVertexBuffer = (function (_super) {
            __extends(WebGLVertexBuffer, _super);
            /*pManager: IResourcePoolManager*/
            function /** @no-inline */WebGLVertexBuffer() {
                /*pManager*/
                        _super.call(this);
                this._pLockData = null;
            }
            Object.defineProperty(WebGLVertexBuffer.prototype, "type", {
                get: function /** @inline */() {
                    return 1 /* VBO */ ;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLVertexBuffer.prototype, "byteLength", {
                get: function /** @inline */() {
                    return this._iByteSize;
                },
                enumerable: true,
                configurable: true
            });
            WebGLVertexBuffer.prototype.create = function /** @no-inline */(iByteSize, iFlags, pData) {
                if (typeof iFlags === "undefined") { iFlags = 1 /* STATIC */ ; }
                if (typeof pData === "undefined") { pData = null; }
                iByteSize = akra.math.max(iByteSize, 1024);
                if((((iFlags) & (4 /* READABLE */ )) != 0)) {
                    ((iFlags) |= (8 /* BACKUP_COPY */ ));
                }
                _super.prototype.create.call(this, iByteSize, iFlags, pData);
                var pWebGLRenderer = this.getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                var i;
                akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 45);
                akra.logger.assert(this._pWebGLBuffer == null, "webgl buffer already allocated");
                ;
                this._iByteSize = iByteSize;
                this._iFlags = iFlags;
                pWebGLContext = pWebGLRenderer.getWebGLContext();
                akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 51);
                akra.logger.assert(pWebGLContext !== null, "cannot grab webgl context");
                ;
                //Софтварного рендеринга буфера у нас нет
                akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 54);
                akra.logger.assert(!this.isSoftware(), "no sftware rendering");
                ;
                //Если есть локальная копия то буфер можно читать
                if(this.isBackupPresent()) {
                    ((this._iFlags) |= (4 /* READABLE */ ));
                }
                akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 62);
                akra.logger.assert(!pData || pData.byteLength <= iByteSize, "Размер переданного массива больше переданного размера буфера");
                ;
                this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();
                if(!this._pWebGLBuffer) {
                    akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 68);
                    akra.logger.criticalError("Не удалось создать буфер");
                    ;
                    this.destroy();
                    return false;
                }
                pWebGLRenderer.bindWebGLBuffer(0x8892, this._pWebGLBuffer);
                pWebGLContext.bufferData(0x8892, this._iByteSize, webgl.getWebGLUsage(this._iFlags));
                if(pData) {
                    pWebGLContext.bufferSubData(0x8892, 0, akra.isArrayBuffer(pData) ? pData : pData.buffer);
                }
                return true;
            };
            WebGLVertexBuffer.prototype.destroy = function /** @no-inline */() {
                _super.prototype.destroy.call(this);
                var pWebGLRenderer = this.getEngine().getRenderer();
                pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);
                this._pWebGLBuffer = null;
                this._iByteSize = 0;
            };
            WebGLVertexBuffer.prototype.readData = function /** @no-inline */(iOffset, iSize, ppDest) {
                akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 99);
                akra.logger.assert(!akra.isNull(this._pWebGLBuffer), "Буффер еще не создан");
                ;
                if(!this.isBackupPresent()) {
                    return false;
                }
                if(arguments.length === 1) {
                    this._pBackupCopy.readData(arguments[0]);
                } else {
                    this._pBackupCopy.readData(iOffset, iSize, ppDest);
                }
                return true;
            };
            WebGLVertexBuffer.prototype.writeData = function /** @no-inline */(pData, iOffset, iSize, bDiscardWholeBuffer) {
                if (typeof bDiscardWholeBuffer === "undefined") { bDiscardWholeBuffer = false; }
                akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 119);
                akra.logger.assert(!akra.isNull(this._pWebGLBuffer), "WebGL buffer not exists");
                ;
                var pWebGLRenderer = this.getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                pWebGLRenderer.bindWebGLBuffer(0x8892, this._pWebGLBuffer);
                akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 126);
                akra.logger.assert(pData.byteLength <= iSize, "Размер переданного массива больше переданного размера");
                ;
                akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 127);
                akra.logger.assert(this.byteLength >= iOffset + iSize, "Данные выйдут за предел буфера");
                ;
                var pU8Data = null;
                if(akra.isArrayBuffer(pData)) {
                    pU8Data = new Uint8Array(pData);
                } else {
                    pU8Data = new Uint8Array(pData.buffer, pData.byteOffset, pData.byteLength);
                }
                pU8Data = pU8Data.subarray(0, iSize);
                pWebGLContext.bufferSubData(0x8892, iOffset, pU8Data);
                if(this.isBackupPresent()) {
                    this._pBackupCopy.writeData(pU8Data, iOffset);
                }
                this.notifyAltered();
                return true;
            };
            WebGLVertexBuffer.prototype.resize = function /** @no-inline */(iSize) {
                var eUsage;
                var pData;
                var iMax = 0;
                var pVertexData;
                var pWebGLRenderer = this.getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                if(this.isBackupPresent()) {
                    return false;
                }
                if(iSize < this.byteLength) {
                    for(var k = 0; k < this._pVertexDataArray.length; ++k) {
                        pVertexData = this._pVertexDataArray[k];
                        if(pVertexData.byteOffset + pVertexData.byteLength > iMax) {
                            iMax = pVertexData.byteOffset + pVertexData.byteLength;
                        }
                    }
                    akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 174);
                    akra.logger.assert(iMax <= iSize, "Уменьшение невозможно. Страая разметка не укладывается в новый размер");
                    ;
                }
                if(pWebGLContext.isBuffer(this._pWebGLBuffer)) {
                    pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);
                }
                eUsage = webgl.getWebGLUsage(this._iFlags);
                this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();
                if(!this._pWebGLBuffer) {
                    akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 186);
                    akra.logger.criticalError("Не удалось создать буфер");
                    ;
                    this.destroy();
                    return false;
                }
                pWebGLRenderer.bindWebGLBuffer(0x8892, this._pWebGLBuffer);
                pWebGLContext.bufferData(0x8892, iSize, eUsage);
                pData = new Uint8Array(this._iByteSize);
                if(this.readData(pData)) {
                    akra.logger.setSourceLocation("webgl/WebGLVertexBuffer.ts", 199);
                    akra.logger.warning("cannot read data from buffer");
                    ;
                    return false;
                }
                this.writeData(pData, 0, this._iByteSize);
                this._pBackupCopy.resize(iSize);
                this._iByteSize = iSize;
                this.notifyAltered();
                return true;
            };
            WebGLVertexBuffer.prototype.getWebGLBuffer = function /** @inline */() {
                return this._pWebGLBuffer;
            };
            WebGLVertexBuffer.prototype.lockImpl = /**@protected*/ function /** @no-inline */(iOffset, iSize, iLockFlags) {
                var pRetData = new Uint8Array(iSize);
                this.readData(iOffset, iSize, pRetData);
                this._pLockData = pRetData;
                return pRetData;
            };
            WebGLVertexBuffer.prototype.unlockImpl = /**@protected*/ function /** @no-inline */() {
                this.writeData(this._pLockData, this._iLockStart, this._iLockSize);
            };
            WebGLVertexBuffer.prototype.copyBackupToRealImpl = /**@protected*/ function /** @no-inline */(pRealData, pBackupData, iLockFlags) {
                pRealData.set(pBackupData);
            };
            return WebGLVertexBuffer;
        })(akra.core.pool.resources.VertexBuffer);
        webgl.WebGLVertexBuffer = WebGLVertexBuffer;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLShaderProgram = (function (_super) {
            __extends(WebGLShaderProgram, _super);
            function WebGLShaderProgram() {
                _super.apply(this, arguments);

            }
            WebGLShaderProgram.prototype.create = function /** @no-inline */(csVertex, csPixel) {
                if(arguments.length > 0) {
                    return this.compile(csVertex || "void main(void){gl_Position = vec4(0., 0., 0., 1.);}", csPixel || "void main(void){}");
                }
                return false;
            };
            WebGLShaderProgram.prototype.destroy = function /** @no-inline */() {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                pWebGLRenderer.deleteWebGLProgram(this._pWebGLProgram);
                this._pWebGLUniformLocations = null;
                this._pWebGLAttributeLocations = null;
                this._pWebGLAttributesInfo = null;
                this.notifyDestroyed();
                this.notifyDisabled();
            };
            WebGLShaderProgram.prototype.compile = function /** @no-inline */(csVertex, csPixel) {
                if (typeof csVertex === "undefined") { csVertex = "void main(void){gl_Position = vec4(0., 0., 0., 1.);}"; }
                if (typeof csPixel === "undefined") { csPixel = "void main(void){}"; }
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                var pWebGLProgram = this._pWebGLProgram = pWebGLRenderer.createWebGLProgram();
                var pWebGLVs = this.createWebGLShader(0x8B31, csVertex);
                var pWebGLFs = this.createWebGLShader(0x8B30, csPixel);
                /** because, if not all units correctly activated, can obtained wronf link status */
                pWebGLRenderer._disableAllTextureUnits();
                pWebGLContext.attachShader(pWebGLProgram, pWebGLVs);
                pWebGLContext.attachShader(pWebGLProgram, pWebGLFs);
                pWebGLContext.linkProgram(pWebGLProgram);
                if(!this.isLinked()) {
                    akra.logger.setSourceLocation("WebGLShaderProgram.ts", 67);
                    akra.logger.error("cannot link GLSL program(guid: %d)", this.getGuid());
                    ;
                    if(webgl.hasExtension("WEBGL_debug_shaders")) {
                        akra.logger.setSourceLocation("WebGLShaderProgram.ts", 73);
                        akra.logger.log("translated(from GLSL) VS shader: \n %s\ntranslated(from GLSL) PS shader: \n%s", pWebGLContext.getTranslatedShaderSource(pWebGLVs), pWebGLContext.getTranslatedShaderSource(pWebGLFs));
                        ;
                    }
                    var sInfo = pWebGLContext.getProgramInfoLog(pWebGLProgram);
                    akra.logger.setSourceLocation("WebGLShaderProgram.ts", 78);
                    akra.logger.log("shader program errors: \n %s\n\nvertex code:\n %s\n\n pixel code: %s", sInfo, csVertex, csPixel);
                    ;
                    return false;
                }
                pWebGLContext.validateProgram(pWebGLProgram);
                if(!this.isValid()) {
                    akra.logger.setSourceLocation("WebGLShaderProgram.ts", 87);
                    akra.logger.warning("GLSL program not valid(guid: %d)", this.getGuid());
                    ;
                    akra.logger.setSourceLocation("WebGLShaderProgram.ts", 89);
                    akra.logger.log(pWebGLContext.getProgramInfoLog(pWebGLProgram));
                    ;
                }
                this.obtainWebGLUniforms();
                this.obtainWebGLAttributes();
                this.notifyCreated();
                this.notifyRestored();
                return true;
            };
            WebGLShaderProgram.prototype.isLinked = function /** @no-inline */() {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                ;
                return akra.isDefAndNotNull(this._pWebGLProgram) && pWebGLContext.getProgramParameter(this._pWebGLProgram, 0x8B82);
            };
            WebGLShaderProgram.prototype.isValid = function /** @no-inline */() {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                ;
                return akra.isDefAndNotNull(this._pWebGLProgram) && pWebGLContext.getProgramParameter(this._pWebGLProgram, 0x8B83);
            };
            WebGLShaderProgram.prototype.isActive = function /** @no-inline */() {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                ;
                return (akra.isDefAndNotNull(this._pWebGLProgram) && pWebGLContext.getParameter(0x8B8D) === this._pWebGLProgram);
            };
            WebGLShaderProgram.prototype.setFloat = function /** @no-inline */(sName, fValue) {
                var iLoc = this._pWebGLUniformLocations[sName];
                if(!akra.isDef(iLoc)) {
                    return false;
                }
                ;
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                ;
                pWebGLContext.uniform1f(iLoc, fValue);
                return true;
            };
            WebGLShaderProgram.prototype.setInt = function /** @no-inline */(sName, iValue) {
                var iLoc = this._pWebGLUniformLocations[sName];
                if(!akra.isDef(iLoc)) {
                    return false;
                }
                ;
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                ;
                pWebGLContext.uniform1i(iLoc, iValue);
                return true;
            };
            WebGLShaderProgram.prototype.setVec2 = function /** @inline */(sName, x, y) {
                var iLoc = this._pWebGLUniformLocations[sName];
                if(!akra.isDef(iLoc)) {
                    return false;
                }
                ;
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                ;
                if(arguments.length == 2) {
                    pWebGLContext.uniform2f(iLoc, arguments[1].x, arguments[1].y);
                } else {
                    pWebGLContext.uniform2f(iLoc, arguments[1], arguments[2]);
                }
                return true;
            };
            WebGLShaderProgram.prototype.setVec2i = function /** @inline */(sName, x, y) {
                var iLoc = this._pWebGLUniformLocations[sName];
                if(!akra.isDef(iLoc)) {
                    return false;
                }
                ;
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                ;
                if(arguments.length == 2) {
                    pWebGLContext.uniform2i(iLoc, arguments[1].x, arguments[1].y);
                } else {
                    pWebGLContext.uniform2i(iLoc, arguments[1], arguments[2]);
                }
                return true;
            };
            WebGLShaderProgram.prototype.setVec3 = function /** @inline */(sName, x, y, z) {
                var iLoc = this._pWebGLUniformLocations[sName];
                if(!akra.isDef(iLoc)) {
                    return false;
                }
                ;
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                ;
                if(arguments.length == 2) {
                    pWebGLContext.uniform3f(iLoc, arguments[1].x, arguments[1].y, arguments[1].z);
                } else {
                    pWebGLContext.uniform3f(iLoc, arguments[1], arguments[2], arguments[3]);
                }
                return true;
            };
            WebGLShaderProgram.prototype.setVec3i = function /** @inline */(sName, x, y, z) {
                var iLoc = this._pWebGLUniformLocations[sName];
                if(!akra.isDef(iLoc)) {
                    return false;
                }
                ;
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                ;
                if(arguments.length == 2) {
                    pWebGLContext.uniform3i(iLoc, arguments[1].x, arguments[1].y, arguments[1].z);
                } else {
                    pWebGLContext.uniform3i(iLoc, arguments[1], arguments[2], arguments[3]);
                }
                return true;
            };
            WebGLShaderProgram.prototype.setVec4 = function /** @inline */(sName, x, y, z, w) {
                var iLoc = this._pWebGLUniformLocations[sName];
                if(!akra.isDef(iLoc)) {
                    return false;
                }
                ;
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                ;
                if(arguments.length == 2) {
                    pWebGLContext.uniform4f(iLoc, arguments[1].x, arguments[1].y, arguments[1].z, arguments[1].w);
                } else {
                    pWebGLContext.uniform4f(iLoc, arguments[1], arguments[2], arguments[3], arguments[3]);
                }
                return true;
            };
            WebGLShaderProgram.prototype.setVec4i = function /** @inline */(sName, x, y, z, w) {
                var iLoc = this._pWebGLUniformLocations[sName];
                if(!akra.isDef(iLoc)) {
                    return false;
                }
                ;
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                ;
                if(arguments.length == 2) {
                    pWebGLContext.uniform4i(iLoc, arguments[1].x, arguments[1].y, arguments[1].z, arguments[1].w);
                } else {
                    pWebGLContext.uniform4i(iLoc, arguments[1], arguments[2], arguments[3], arguments[3]);
                }
                return true;
            };
            WebGLShaderProgram.prototype.setMat3 = function /** @inline */(sName, m3fValue) {
                var iLoc = this._pWebGLUniformLocations[sName];
                if(!akra.isDef(iLoc)) {
                    return false;
                }
                ;
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                ;
                pWebGLContext.uniformMatrix3fv(iLoc, false, m3fValue.data);
                return true;
            };
            WebGLShaderProgram.prototype.setMat4 = function /** @no-inline */(sName, m4fValue) {
                var iLoc = this._pWebGLUniformLocations[sName];
                if(!akra.isDef(iLoc)) {
                    return false;
                }
                ;
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                ;
                pWebGLContext.uniformMatrix4fv(iLoc, false, m4fValue.data);
                return true;
            };
            WebGLShaderProgram.prototype.setFloat32Array = function /** @inline */(sName, pValue) {
                var iLoc = this._pWebGLUniformLocations[sName];
                if(!akra.isDef(iLoc)) {
                    return false;
                }
                ;
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                ;
                pWebGLContext.uniform1fv(iLoc, pValue);
                return true;
            };
            WebGLShaderProgram.prototype.setInt32Array = function /** @inline */(sName, pValue) {
                var iLoc = this._pWebGLUniformLocations[sName];
                if(!akra.isDef(iLoc)) {
                    return false;
                }
                ;
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                ;
                pWebGLContext.uniform1iv(iLoc, pValue);
                return true;
            };
            WebGLShaderProgram.prototype.setVec2Array = function /** @inline */(sName, pValue) {
                return false;
            };
            WebGLShaderProgram.prototype.setVec2iArray = function /** @inline */(sName, pValue) {
                return false;
            };
            WebGLShaderProgram.prototype.setVec3Array = function /** @inline */(sName, pValue) {
                return false;
            };
            WebGLShaderProgram.prototype.setVec3iArray = function /** @inline */(sName, pValue) {
                return false;
            };
            WebGLShaderProgram.prototype.setVec4Array = function /** @inline */(sName, pValue) {
                return false;
            };
            WebGLShaderProgram.prototype.setVec4iArray = function /** @inline */(sName, pValue) {
                return false;
            };
            WebGLShaderProgram.prototype.setMat3Array = function /** @inline */(sName, pValue) {
                return false;
            };
            WebGLShaderProgram.prototype.setMat4Array = function /** @inline */(sName, pValue) {
                return false;
            };
            WebGLShaderProgram.prototype.setStruct = function /** @inline */(sName, pData) {
                return false;
            };
            WebGLShaderProgram.prototype.setSampler2D = function /** @inline */(sName, pData) {
                return false;
            };
            WebGLShaderProgram.prototype.setSampler2DToStruct = function /** @inline */(sName, pData) {
                return false;
            };
            WebGLShaderProgram.prototype.setTexture = function /** @inline */(sName, pData) {
                return false;
            };
            WebGLShaderProgram.prototype.applyVertexData = //applyVertexBuffer(sName: string, pBuffer: IVertexBuffer);
            function /** @no-inline */(sName, pData) {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                ;
                var pVertexBuffer = pData.buffer;
                var iStride = pData.stride;
                if(pVertexBuffer.type !== 1 /* VBO */ ) {
                    return false;
                }
                var pVertexDecl = pData.getVertexDeclaration();
                var pVertexElement;
                var iLoc;
                for(var i = 0; i < pVertexDecl.length; ++i) {
                    pVertexElement = pVertexDecl[i];
                    iLoc = this.getWebGLAttributeLocation(pVertexElement.usage);
                    if(iLoc < 0) {
                        akra.logger.setSourceLocation("WebGLShaderProgram.ts", 353);
                        akra.logger.warning("founded invalid GLSL attribute location(guid: %s): %s", this.getGuid(), pVertexElement.usage);
                        ;
                        continue;
                    }
                    pWebGLRenderer.bindWebGLBuffer(0x8892, (pVertexBuffer).getWebGLBuffer());
                    pWebGLContext.vertexAttribPointer(iLoc, pVertexElement.count, pVertexElement.type, false, iStride, pVertexElement.offset);
                }
                return true;
            };
            WebGLShaderProgram.prototype.applyBufferMap = function /** @inline */(pMap) {
                akra.logger.setSourceLocation("WebGLShaderProgram.ts", 371);
                akra.logger.criticalError("WebGLShaderProgram::applyBufferMap() is uncompleted method!");
                ;
            };
            WebGLShaderProgram.prototype.getWebGLAttributeLocation = function /** @inline */(sName) {
                return this._pWebGLAttributeLocations[sName] || -1;
            };
            WebGLShaderProgram.prototype.getWebGLUniformLocation = function /** @inline */(sName) {
                var iLoc = this._pWebGLUniformLocations[sName];
                if(!akra.isDef(iLoc)) {
                    akra.logger.setSourceLocation("WebGLShaderProgram.ts", 384);
                    akra.logger.warning("could not find location for GLSL attribute(guid: %s): %s", this.getGuid(), sName);
                    ;
                }
                return null;
            };
            WebGLShaderProgram.prototype.getWebGLProgram = function /** @inline */() {
                return this._pWebGLProgram;
            };
            WebGLShaderProgram.prototype.createWebGLShader = /**@protected*/ function /** @no-inline */(eType, csCode) {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                var pWebGLShader = pWebGLContext.createShader(eType);
                pWebGLContext.shaderSource(pWebGLShader, csCode);
                pWebGLContext.compileShader(pWebGLShader);
                if(!pWebGLContext.getShaderParameter(pWebGLShader, 0x8B81)) {
                    akra.logger.setSourceLocation("WebGLShaderProgram.ts", 406);
                    akra.logger.error("cannot compile GLSL shader(guid: %d)", this.getGuid());
                    ;
                    var sInfo = pWebGLContext.getShaderInfoLog(pWebGLShader);
                    var sCode = pWebGLContext.getShaderSource(pWebGLShader) || csCode;
                    akra.logger.setSourceLocation("WebGLShaderProgram.ts", 411);
                    akra.logger.log("shader errors: \n %s \n----------\n %s", sInfo, sCode);
                    ;
                    return null;
                }
                return pWebGLShader;
            };
            WebGLShaderProgram.prototype.obtainWebGLUniforms = /**@protected*/ function /** @no-inline */() {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                ;
                var nUniforms = pWebGLContext.getProgramParameter(this._pWebGLProgram, 0x8B86);
                var pUniformLocations = {
                };
                var iLoc;
                var pUniformInfo;
                for(var i = 0; i < nUniforms; ++i) {
                    pUniformInfo = pWebGLContext.getActiveUniform(this._pWebGLProgram, i);
                    iLoc = pWebGLContext.getUniformLocation(this._pWebGLProgram, pUniformInfo.name);
                    pUniformLocations[pUniformInfo.name] = iLoc;
                }
                this._pWebGLUniformLocations = pUniformLocations;
            };
            WebGLShaderProgram.prototype.obtainWebGLAttributes = /**@protected*/ function /** @no-inline */() {
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                ;
                var nAttributes = pWebGLContext.getProgramParameter(this._pWebGLProgram, 0x8B89);
                var pAttributeLocations = {
                };
                var pAttributesInfo = [];
                var iLoc;
                var pAttributeInfo;
                for(var i = 0; i < nAttributes; ++i) {
                    pAttributeInfo = pWebGLContext.getActiveAttrib(this._pWebGLProgram, i);
                    iLoc = pWebGLContext.getAttribLocation(this._pWebGLProgram, pAttributeInfo.name);
                    if(iLoc < 0 || !akra.isDef(iLoc)) {
                        akra.logger.setSourceLocation("WebGLShaderProgram.ts", 450);
                        akra.logger.warning("could not get GLSL attribute location(guid: %s): %s", this.getGuid(), pAttributeInfo.name);
                        ;
                    }
                    pAttributeLocations[pAttributeInfo.name] = iLoc;
                    pAttributesInfo[iLoc] = pAttributeInfo;
                }
                this._pWebGLAttributeLocations = pAttributeLocations;
                this._pWebGLAttributesInfo = pAttributesInfo;
            };
            return WebGLShaderProgram;
        })(akra.core.pool.ResourcePoolItem);
        webgl.WebGLShaderProgram = WebGLShaderProgram;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLVertexTexture = (function (_super) {
            __extends(WebGLVertexTexture, _super);
            /*pManager: IResourcePoolManager*/
            function /** @no-inline */WebGLVertexTexture() {
                /*pManager*/
                        _super.call(this);
                /**@protected*/ this._iWidth = 0;
                /**@protected*/ this._iHeight = 0;
                /**@protected*/ this._ePixelFormat = 25 /* FLOAT32_RGBA */ ;
                //переменная нужна, чтобы проигнорировать обновление копии, обычно, это не требуется
                /**@protected*/ this._bForceUpdateBackupCopy = true;
                this._pLockData = null;
            }
            Object.defineProperty(WebGLVertexTexture.prototype, "type", {
                get: function /** @inline */() {
                    return 2 /* TBO */ ;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLVertexTexture.prototype, "byteLength", {
                get: function /** @inline */() {
                    return akra.pixelUtil.getMemorySize(this._iWidth, this._iHeight, 1, this._ePixelFormat);
                },
                enumerable: true,
                configurable: true
            });
            WebGLVertexTexture.prototype.create = function /** @no-inline */(iByteSize, iFlags, pData) {
                if (typeof iFlags === "undefined") { iFlags = 1 /* STATIC */ ; }
                if (typeof pData === "undefined") { pData = null; }
                var iMinWidth = 32;
                var iWidth, iHeight;
                var pTextureData = null;
                var pDataU8 = pData;
                iByteSize = akra.math.max(iByteSize, akra.pixelUtil.getMemorySize(iMinWidth, iMinWidth, 1, this._ePixelFormat));
                if((((iFlags) & (4 /* READABLE */ )) != 0)) {
                    ((iFlags) |= (8 /* BACKUP_COPY */ ));
                }
                _super.prototype.create.call(this, iByteSize, iFlags, pData);
                var pPOTSize = akra.math.calcPOTtextureSize(akra.math.ceil(iByteSize / akra.pixelUtil.getNumElemBytes(this._ePixelFormat)));
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                var i;
                iWidth = pPOTSize[0];
                iHeight = pPOTSize[1];
                akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 61);
                akra.logger.assert(this._pWebGLTexture == null, "webgl texture already allocated");
                ;
                this._iWidth = iWidth;
                this._iHeight = iHeight;
                this._iFlags = iFlags;
                akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 67);
                akra.logger.assert(pWebGLContext !== null, "cannot grab webgl context");
                ;
                //Софтварного рендеринга буфера у нас нет
                akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 70);
                akra.logger.assert(!this.isSoftware(), "no sftware rendering");
                ;
                //Если есть локальная копия то буфер можно читать
                if(this.isBackupPresent()) {
                    ((this._iFlags) |= (4 /* READABLE */ ));
                }
                akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 78);
                akra.logger.assert(!pData || pData.byteLength <= iByteSize, "Размер переданного массива больше переданного размера буфера");
                ;
                this._pWebGLTexture = pWebGLRenderer.createWebGLTexture();
                this._eWebGLFormat = webgl.getWebGLOriginFormat(this._ePixelFormat);
                this._eWebGLType = webgl.getWebGLOriginDataType(this._ePixelFormat);
                if(!this._pWebGLTexture) {
                    akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 85);
                    akra.logger.criticalError("Не удалось создать буфер");
                    ;
                    this.destroy();
                    return false;
                }
                if(pData) {
                    if(pData.BYTES_PER_ELEMENT > 1) {
                        pDataU8 = new Uint8Array(pData, pData.byteOffset, pData.byteLength);
                    }
                    pTextureData = new Uint8Array(this.byteLength);
                    pTextureData.set(pDataU8);
                }
                pWebGLRenderer.bindWebGLTexture(0x0DE1, this._pWebGLTexture);
                pWebGLContext.texImage2D(0x0DE1, 0, this._eWebGLFormat, this._iWidth, this._iHeight, 0, this._eWebGLFormat, this._eWebGLType, pTextureData);
                var pProgram = this.getManager().shaderProgramPool.findResource("WEBGL_update_vertex_texture");
                if(akra.isNull(pProgram)) {
                    pProgram = this.getManager().shaderProgramPool.createResource("WEBGL_update_vertex_texture");
                    pProgram.create("																									\n	        	uniform sampler2D sourceTexture;																	\n				attribute vec4  VALUE;																				\n				attribute float INDEX;																				\n				attribute float SHIFT;																				\n				                      																				\n				uniform vec2 size;																					\n				varying vec4 color;																					\n				                   																					\n				void main(void){																					\n				    vec4 value = VALUE;																				\n				    float  serial = INDEX;																			\n				                          																			\n				    int shift = int(SHIFT);																			\n				    if (shift != 0) {																				\n				        color = texture2D(sourceTexture,                                        					\n				            vec2((mod(serial, size.x) +.5 ) / size.x, (floor(serial / size.x) + .5) / size.y)		\n				            );																						\n																													\n																													\n				        if (shift == 1) {																			\n				            color = vec4(color.r, value.gba);														\n				        }																							\n				        else if (shift == 2) {																		\n				            color = vec4(color.rg, value.ba);														\n				        }																							\n				        else if (shift == 3) {																		\n				            color = vec4(color.rgb, value.a);														\n				        }																							\n				        else if (shift == -1) {																		\n				            color = vec4(value.r, color.gba);														\n				        }																							\n				        else if (shift == -2) {																		\n				            color = vec4(value.rg, color.ba);														\n				        }																							\n				        else {																						\n				            color = vec4(value.rgb, color.a);														\n				        }																							\n				    }																								\n				    else {																							\n				        color = value;																				\n				    }																								\n				    gl_Position = vec4(2. * (mod(serial, size.x) + .5) / size.x - 1.,								\n				                    2. * (floor(serial / size.x)  + .5) / size.y - 1., 0., 1.);						\n				}																									\n				", "									\n				#ifdef GL_ES                        \n				    precision highp float;          \n				#endif								\n				varying vec4 color;                 \n				                                    \n				void main(void) {                   \n				    gl_FragColor = color;           \n				}                                   \n				");
                }
                return true;
            };
            WebGLVertexTexture.prototype.destroy = function /** @no-inline */() {
                _super.prototype.destroy.call(this);
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);
                this._pWebGLTexture = null;
            };
            WebGLVertexTexture.prototype.readData = function /** @no-inline */(iOffset, iSize, ppDest) {
                akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 184);
                akra.logger.assert(!akra.isNull(this._pWebGLTexture), "Буффер еще не создан");
                ;
                if(!this.isBackupPresent()) {
                    return false;
                }
                if(arguments.length === 1) {
                    this._pBackupCopy.readData(arguments[0]);
                } else {
                    this._pBackupCopy.readData(iOffset, iSize, ppDest);
                }
                return true;
            };
            WebGLVertexTexture.prototype.writeData = function /** @no-inline */(pData, iOffset, iSize, bDiscardWholeBuffer) {
                if (typeof bDiscardWholeBuffer === "undefined") { bDiscardWholeBuffer = false; }
                /*предпологается, что float*/
                                var iTypeSize = akra.pixelUtil.getComponentTypeBits(this._ePixelFormat) / 8, nElementsPerPix = /*число float'ов в пикселе*/
                akra.pixelUtil.getComponentCount(this._ePixelFormat), iFrom, iCount;
                /*номер float'a с которого начинается обновление*/
                /*исло float'ов для обновления*/
                /*данные для обновления*/
                var pBufferData;
                /*смещение внутри первого пикселя*/
                                var iLeftShift, iRightShift, iBeginPix, iEndPix, nPixels, nElements;
                /*смещение внутри последнего пикселя*/
                /*пиксель с которого начинается обновление*/
                /*пиксель на котором заканчивается обновление*/
                /*число пикселей*/
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                var pDataU8 = pData;
                akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 222);
                akra.logger.assert(bDiscardWholeBuffer === false, "Discard option temporary unsupported.");
                ;
                if(pData.BYTES_PER_ELEMENT > 1) {
                    pDataU8 = new Uint8Array(pData.buffer, pData.byteOffset, pData.byteLength);
                }
                iOffset = iOffset || 0;
                iSize = iSize || pData.byteLength;
                pDataU8 = pDataU8.subarray(0, iSize);
                if(this.byteLength < iOffset + iSize) {
                    this.resize(iOffset + iSize);
                }
                if(this.isBackupPresent() && this._bForceUpdateBackupCopy) {
                    this._pBackupCopy.writeData(pDataU8, iOffset);
                }
                this._bForceUpdateBackupCopy = true;
                akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 243);
                akra.logger.assert(iOffset % iTypeSize === 0 && iSize % iTypeSize === 0, "Incorrect data size or offset");
                ;
                iFrom = iOffset / iTypeSize;
                iCount = iSize / iTypeSize;
                iLeftShift = iFrom % nElementsPerPix;
                iRightShift = ((iFrom + iCount) % nElementsPerPix);
                iBeginPix = Math.floor(iFrom / nElementsPerPix);
                iEndPix = Math.floor((iFrom + iCount) / nElementsPerPix);
                nPixels = Math.ceil((iFrom + iCount) / nElementsPerPix) - Math.floor(iFrom / nElementsPerPix);
                nElements = nPixels * nElementsPerPix;
                pBufferData = new Float32Array(pDataU8.buffer, pDataU8.byteOffset);
                if(iLeftShift === 0 && iRightShift === 0) {
                    var iWidth = this._iWidth;
                    var iYmin = Math.floor(iBeginPix / iWidth);
                    var iYmax = Math.ceil(iEndPix / iWidth);
                    var iXbegin = iBeginPix % iWidth;
                    var iXend = iEndPix % iWidth;
                    var iHeight = iYmax - iYmin;
                    var iBeginElement = 0, iEndElement = 0;
                    //hack: if iEndPixel is first pixel from next row
                    iXend = (iXend === 0 ? iWidth : iXend);
                    //FIX THIS, move this function from here...
                    function /** @no-inline */updatePixelRect(iX, iY, iW, iH) {
                        iBeginElement = iEndElement;
                        iEndElement = iW * iH * nElementsPerPix + iEndElement;
                        pWebGLRenderer.bindWebGLTexture(0x0DE1, this._pWebGLTexture);
                        pWebGLContext.texSubImage2D(0x0DE1, 0, iX, iY, iW, iH, this._eWebGLFormat, this._eWebGLType, pBufferData.subarray(iBeginElement, iEndElement));
                    }
                    ;
                    if(iHeight === 1) {
                        updatePixelRect(iXbegin, iYmin, iXend - iXbegin, 1);
                    } else {
                        updatePixelRect(iXbegin, iYmin, iWidth - iXbegin, 1);
                        if(iHeight > 2) {
                            updatePixelRect(0, iYmin + 1, iWidth, iHeight - 2);
                        }
                        updatePixelRect(0, iYmax - 1, iXend, 1);
                    }
                } else if(this.isBackupPresent()) {
                    var iRealOffset = iBeginPix * nElementsPerPix * iTypeSize;
                    var iRealSize = nElements * iTypeSize;
                    var pTempData = this._pBackupCopy.lock(iRealOffset, iRealSize);
                    //var iTotalSize: uint 	= iRealOffset + iRealSize;
                    this._bForceUpdateBackupCopy = false;
                    return this.writeData(pTempData, iRealOffset, iRealSize);
                } else {
                    var pMarkupDataIndex = new Float32Array(nPixels);
                    var pMarkupDataShift = new Float32Array(nPixels);
                    var pRealData = new Float32Array(nElements);
                    pMarkupDataIndex[0] = iBeginPix;
                    pMarkupDataShift[0] = iLeftShift;
                    pMarkupDataIndex[nPixels - 1] = iBeginPix + nPixels - 1;
                    pMarkupDataShift[nPixels - 1] = -iRightShift;
                    for(var i = 1; i < nPixels - 1; ++i) {
                        pMarkupDataIndex[i] = iBeginPix + i;
                    }
                    for(var i = 0; i < iCount; i++) {
                        pRealData[iLeftShift + i] = pBufferData[i];
                    }
                    var pShaderSource;
                    var pWebGLFramebuffer = pWebGLRenderer.createWebGLFramebuffer();
                    var pWebGLProgram = this.getManager().shaderProgramPool.findResource("WEBGL_update_vertex_texture");
                    var pValueBuffer = pWebGLRenderer.createWebGLBuffer();
                    var pMarkupIndexBuffer = pWebGLRenderer.createWebGLBuffer();
                    var pMarkupShiftBuffer = pWebGLRenderer.createWebGLBuffer();
                    akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 335);
                    akra.logger.assert(akra.isDef(pWebGLProgram), "cound not find WEBGL_update_vertex_texture program");
                    ;
                    pWebGLRenderer.disableAllWebGLVertexAttribs();
                    pWebGLRenderer.bindWebGLFramebuffer(0x8D40, pWebGLFramebuffer);
                    pWebGLRenderer.useWebGLProgram(pWebGLProgram.getWebGLProgram());
                    //FIXME: set weblg states (GL_DEPTH_FUNC, GL_***)
                    pWebGLContext.framebufferTexture2D(0x8D40, 0x8CE0, 0x0DE1, this._pWebGLTexture, 0);
                    pWebGLRenderer.bindWebGLBuffer(0x8892, pValueBuffer);
                    pWebGLContext.bufferData(0x8892, pRealData, 0x88E0);
                    pWebGLContext.vertexAttribPointer(pWebGLProgram.getWebGLAttributeLocation("VALUE"), 4, 0x1406, false, 0, 0);
                    pWebGLRenderer.bindWebGLBuffer(0x8892, pMarkupIndexBuffer);
                    pWebGLContext.bufferData(0x8892, pMarkupDataIndex, 0x88E0);
                    pWebGLContext.vertexAttribPointer(pWebGLProgram.getWebGLAttributeLocation("INDEX"), 1, 0x1406, false, 0, 0);
                    pWebGLRenderer.bindWebGLBuffer(0x8892, pMarkupShiftBuffer);
                    pWebGLContext.bufferData(0x8892, pMarkupDataShift, 0x88E0);
                    pWebGLContext.vertexAttribPointer(pWebGLProgram.getWebGLAttributeLocation("SHIFT"), 1, 0x1406, false, 0, 0);
                    pWebGLRenderer.bindWebGLTexture(0x0DE1, this._pWebGLTexture);
                    pWebGLRenderer.activateWebGLTexture(0x84C0);
                    pWebGLContext.uniform2i("size", this._iWidth, this._iHeight);
                    pWebGLContext.uniform1i("sourceTexture", 0);
                    pWebGLContext.viewport(0, 0, this._iWidth, this._iHeight);
                    pWebGLContext.drawArrays(0, 0, nPixels);
                    pWebGLContext.flush();
                    pWebGLContext.framebufferTexture2D(0x8D40, 0x8CE0, 0x0DE1, null, 0);
                    pWebGLRenderer.bindWebGLBuffer(0x8892, null);
                    pWebGLRenderer.deleteWebGLBuffer(pValueBuffer);
                    pWebGLRenderer.deleteWebGLBuffer(pMarkupShiftBuffer);
                    pWebGLRenderer.deleteWebGLBuffer(pMarkupIndexBuffer);
                    pWebGLRenderer.bindWebGLFramebuffer(0x8D40, null);
                    pWebGLRenderer.deleteWebGLFramebuffer(pWebGLFramebuffer);
                }
                return true;
            };
            WebGLVertexTexture.prototype.resize = function /** @no-inline */(iSize) {
                var eUsage;
                var pData;
                var iMax = 0;
                var pVertexData;
                var pWebGLRenderer = this.getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                if(this.isBackupPresent()) {
                    return false;
                }
                if(iSize < this.byteLength) {
                    for(var k = 0; k < this._pVertexDataArray.length; ++k) {
                        pVertexData = this._pVertexDataArray[k];
                        if(pVertexData.byteOffset + pVertexData.byteLength > iMax) {
                            iMax = pVertexData.byteOffset + pVertexData.byteLength;
                        }
                    }
                    akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 410);
                    akra.logger.assert(iMax <= iSize, "Уменьшение невозможно. Страая разметка не укладывается в новый размер");
                    ;
                }
                if(pWebGLContext.isTexture(this._pWebGLTexture)) {
                    pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);
                }
                this._pWebGLTexture = pWebGLRenderer.createWebGLTexture();
                if(!this._pWebGLTexture) {
                    akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 421);
                    akra.logger.criticalError("Не удалось создать текстуру");
                    ;
                    this.destroy();
                    return false;
                }
                pWebGLRenderer.bindWebGLTexture(0x0DE1, this._pWebGLTexture);
                pData = new Uint8Array(this.byteLength);
                if(this.readData(pData)) {
                    akra.logger.setSourceLocation("webgl/WebGLVertexTexture.ts", 433);
                    akra.logger.warning("cannot read data from buffer");
                    ;
                    return false;
                }
                this.writeData(pData, 0, this.byteLength);
                this._pBackupCopy.resize(iSize);
                this.notifyAltered();
                return true;
            };
            WebGLVertexTexture.prototype.lockImpl = /**@protected*/ function /** @no-inline */(iOffset, iSize, iLockFlags) {
                var pRetData = new Uint8Array(iSize);
                this.readData(iOffset, iSize, pRetData);
                this._pLockData = pRetData;
                return pRetData;
            };
            WebGLVertexTexture.prototype.unlockImpl = /**@protected*/ function /** @no-inline */() {
                this.writeData(this._pLockData, this._iLockStart, this._iLockSize);
            };
            WebGLVertexTexture.prototype.copyBackupToRealImpl = /**@protected*/ function /** @no-inline */(pRealData, pBackupData, iLockFlags) {
                pRealData.set(pBackupData);
            };
            return WebGLVertexTexture;
        })(akra.core.pool.resources.VertexBuffer);
        webgl.WebGLVertexTexture = WebGLVertexTexture;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (data) {
        var IndexData = (function () {
            function /** @no-inline */IndexData(pIndexBuffer, id, iOffset, iCount, ePrimitiveType, eElementsType) {
                if (typeof ePrimitiveType === "undefined") { ePrimitiveType = 4 /* TRIANGLELIST */ ; }
                if (typeof eElementsType === "undefined") { eElementsType = 5123 /* UNSIGNED_SHORT */ ; }
                akra.logger.setSourceLocation("data/IndexData.ts", 36);
                akra.logger.assert(eElementsType == 5123 /* UNSIGNED_SHORT */  || eElementsType == 5121 /* UNSIGNED_BYTE */  || eElementsType == 5125 /* UNSIGNED_INT */ , "supported only short, byte, uint data types.");
                ;
                this._pIndexBuffer = pIndexBuffer;
                this._iOffset = iOffset;
                this._iLength = iCount;
                this._iId = id;
                akra.logger.setSourceLocation("data/IndexData.ts", 43);
                akra.logger.assert(pIndexBuffer.byteLength >= this.byteLength + this.byteOffset, "out of buffer limits.");
                ;
            }
            Object.defineProperty(IndexData.prototype, "id", {
                get: function /** @inline */() {
                    return this._iId;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(IndexData.prototype, "type", {
                get: function /** @inline */() {
                    return this._eElementsType;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(IndexData.prototype, "length", {
                get: function /** @inline */() {
                    return this._iLength;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(IndexData.prototype, "bytesPerIndex", {
                get: function /** @inline */() {
                    return akra.getTypeSize(this._eElementsType);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(IndexData.prototype, "byteOffset", {
                get: function /** @inline */() {
                    return this._iOffset;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(IndexData.prototype, "byteLength", {
                get: function /** @inline */() {
                    return this._iLength * this.bytesPerIndex;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(IndexData.prototype, "buffer", {
                get: function /** @inline */() {
                    return this._pIndexBuffer;
                },
                enumerable: true,
                configurable: true
            });
            IndexData.prototype.getData = function /** @no-inline */(iOffset, iSize) {
                akra.logger.setSourceLocation("data/IndexData.ts", 48);
                akra.logger.assert(iOffset + iSize <= this.byteLength, "out of buffer limits");
                ;
                var pBuffer = new Uint8Array(iSize);
                if(this._pIndexBuffer.readData(this.byteOffset + iOffset, iSize, pBuffer)) {
                    return pBuffer.buffer;
                }
                akra.logger.setSourceLocation("data/IndexData.ts", 55);
                akra.logger.error("cannot read data from index buffer");
                ;
                return null;
            };
            IndexData.prototype.setData = function /** @no-inline */(pData, iOffset, iCount) {
                if (typeof iOffset === "undefined") { iOffset = 0; }
                if (typeof iCount === "undefined") { iCount = pData.byteLength / this.bytesPerIndex; }
                akra.logger.setSourceLocation("data/IndexData.ts", 61);
                akra.logger.assert((iOffset + iCount) * this.bytesPerIndex <= this.byteLength, "out of buffer limits.");
                ;
                return this._pIndexBuffer.writeData(pData, this.byteOffset + iOffset * this.bytesPerIndex, iCount * this.bytesPerIndex);
            };
            IndexData.prototype.destroy = function /** @no-inline */() {
                this._pIndexBuffer = null;
                this._iOffset = undefined;
                this._iLength = undefined;
                this._eElementsType = undefined;
                this._eElementsType = undefined;
            };
            IndexData.prototype.getPrimitiveType = function /** @inline */() {
                return this._ePrimitiveType;
            };
            IndexData.prototype.getPrimitiveCount = function /** @inline */(iIndexCount) {
                if (typeof iIndexCount === "undefined") { iIndexCount = this.length; }
                return IndexData.getPrimitiveCount(this._ePrimitiveType, iIndexCount);
            };
            IndexData.prototype.getBufferHandle = function /** @inline */() {
                return this._pIndexBuffer.resourceHandle;
            };
            IndexData.getPrimitiveCount = function /** @no-inline */getPrimitiveCount(eType, nVertices) {
                switch(eType) {
                    case 0 /* POINTLIST */ :
                        return nVertices;
                    case 1 /* LINELIST */ :
                        return nVertices / 2;
                    case 3 /* LINESTRIP */ :
                        return nVertices - 1;
                    case 2 /* LINELOOP */ :
                        return nVertices;
                    case 4 /* TRIANGLELIST */ :
                        return nVertices / 3;
                    case 6 /* TRIANGLEFAN */ :
                    case 5 /* TRIANGLESTRIP */ :
                        return nVertices - 2;
                }
                akra.logger.setSourceLocation("data/IndexData.ts", 106);
                akra.logger.error("unhandled case detected..");
                ;
                return 0;
            };
            return IndexData;
        })();
        data.IndexData = IndexData;        
    })(akra.data || (akra.data = {}));
    var data = akra.data;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var IndexBuffer = (function (_super) {
                    __extends(IndexBuffer, _super);
                    /*pManager: IResourcePoolManager*/
                    function /** @no-inline */IndexBuffer() {
                        /*pManager*/
                                        _super.call(this);
                        /**@protected*/ this._pIndexDataArray = [];
                        /**@protected*/ this._iDataCounter = 0;
                    }
                    Object.defineProperty(IndexBuffer.prototype, "length", {
                        get: function /** @inline */() {
                            return this._pIndexDataArray.length;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    IndexBuffer.prototype.create = function /** @no-inline */(iByteSize, iFlags, pData) {
                        _super.prototype.create.call(this, iFlags || 0);
                        if((((iFlags) & (8 /* BACKUP_COPY */ )) != 0)) {
                            this._pBackupCopy = new resources.MemoryBuffer();
                            this._pBackupCopy.create(iByteSize);
                            this._pBackupCopy.writeData(pData, 0, iByteSize);
                        }
                        return true;
                    };
                    IndexBuffer.prototype.destroy = function /** @no-inline */() {
                        _super.prototype.destroy.call(this);
                        this._pBackupCopy.destroy();
                        this.freeIndexData();
                        this._iDataCounter = 0;
                    };
                    IndexBuffer.prototype.getIndexData = function /** @no-inline */(iOffset, iCount, ePrimitiveType, eElementsType) {
                        var pIndexData = new akra.data.IndexData(this, this._iDataCounter++, iOffset, iCount, ePrimitiveType, eElementsType);
                        this._pIndexDataArray.push(pIndexData);
                        return pIndexData;
                    };
                    IndexBuffer.prototype.getEmptyIndexData = function /** @no-inline */(iCount, ePrimitiveType, eElementsType) {
                        var pHole = new Array();
                        var i;
                        var pIndexData;
                        pHole[0] = {
                            start: 0,
                            end: this.byteLength
                        };
                        //console.log(pHole[0].end);
                        for(var k = 0; k < this._pIndexDataArray.length; ++k) {
                            pIndexData = this._pIndexDataArray[k];
                            for(i = 0; i < pHole.length; i++) {
                                //console.log("pHole:",pHole[i].start,pHole[i].end);
                                //Полностью попадает внутрь
                                if(pIndexData.byteOffset > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength < pHole[i].end) {
                                    var iTemp = pHole[i].end;
                                    pHole[i].end = pIndexData.byteOffset;
                                    pHole.splice(i + 1, 0, {
                                        start: pIndexData.byteOffset + pIndexData.byteLength,
                                        end: iTemp
                                    });
                                    i--;
                                } else if(pIndexData.byteOffset == pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength < pHole[i].end) {
                                    pHole[i].start = pIndexData.byteOffset + pIndexData.byteLength;
                                } else if(pIndexData.byteOffset > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength == pHole[i].end) {
                                } else if(pIndexData.byteOffset == pHole[i].start && pIndexData.byteLength == (pHole[i].end - pHole[i].start)) {
                                    pHole.splice(i, 1);
                                    i--;
                                } else //Перекрывает снизу
                                if(pIndexData.byteOffset < pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength < pHole[i].end) {
                                    pHole[i].start = pIndexData.byteOffset + pIndexData.byteLength;
                                } else if(pIndexData.byteOffset < pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength == pHole[i].end) {
                                    pHole.splice(i, 1);
                                    i--;
                                } else //Перекрывается сверху
                                if(pIndexData.byteOffset + pIndexData.byteLength > pHole[i].end && pIndexData.byteOffset > pHole[i].start && pIndexData.byteOffset < pHole[i].end) {
                                    pHole[i].end = pIndexData.byteOffset;
                                } else if(pIndexData.byteOffset + pIndexData.byteLength > pHole[i].end && pIndexData.byteOffset == pHole[i].start && pIndexData.byteOffset < pHole[i].end) {
                                    pHole.splice(i, 1);
                                    i--;
                                } else //полнстью перекрывает
                                if(pIndexData.byteOffset < pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength > pHole[i].end) {
                                    i--;
                                }
                            }
                        }
                        pHole.sort(function /** @inline */(a, b) {
                            return ((a.end - a.start) - (b.end - b.start));
                        });
                        for(i = 0; i < pHole.length; i++) {
                            if((pHole[i].end - pHole[i].start) >= iCount * akra.getTypeSize(eElementsType)) {
                                pIndexData = new akra.data.IndexData(this, this._iDataCounter++, pHole[i].start, iCount, ePrimitiveType, eElementsType);
                                this._pIndexDataArray.push(pIndexData);
                                return pIndexData;
                            }
                        }
                        return null;
                    };
                    IndexBuffer.prototype.freeIndexData = function /** @no-inline */(pIndexData) {
                        if(arguments.length == 0) {
                            for(var i = 0; i < this._pIndexDataArray.length; i++) {
                                this._pIndexDataArray[Number(i)].destroy();
                            }
                            this._pIndexDataArray = null;
                        } else {
                            for(var i = 0; i < this._pIndexDataArray.length; i++) {
                                if(this._pIndexDataArray[i] == pIndexData) {
                                    pIndexData.destroy();
                                    this._pIndexDataArray.splice(i, 1);
                                    this.notifyAltered();
                                    return true;
                                }
                            }
                            return false;
                        }
                        this.notifyAltered();
                        return true;
                    };
                    IndexBuffer.prototype.allocateData = function /** @no-inline */(ePrimitiveType, eElementsType, pData) {
                        var pIndexData;
                        var iCount = pData.byteLength / akra.getTypeSize(eElementsType);
                        akra.logger.setSourceLocation("core/pool/resources/IndexBuffer.ts", 164);
                        akra.logger.assert(iCount === akra.math.floor(iCount), "data size should be a multiple of the vertex declaration");
                        ;
                        pIndexData = this.getEmptyIndexData(iCount, ePrimitiveType, eElementsType);
                        pIndexData.setData(pData);
                        return pIndexData;
                    };
                    return IndexBuffer;
                })(resources.HardwareBuffer);
                resources.IndexBuffer = IndexBuffer;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLIndexBuffer = (function (_super) {
            __extends(WebGLIndexBuffer, _super);
            /*pManager: IResourcePoolManager*/
            function /** @no-inline */WebGLIndexBuffer() {
                /*pManager*/
                        _super.call(this);
                this._pLockData = null;
            }
            Object.defineProperty(WebGLIndexBuffer.prototype, "byteLength", {
                get: function /** @inline */() {
                    return this._iByteSize;
                },
                enumerable: true,
                configurable: true
            });
            WebGLIndexBuffer.prototype.create = function /** @no-inline */(iByteSize, iFlags, pData) {
                if (typeof iFlags === "undefined") { iFlags = 1 /* STATIC */ ; }
                if (typeof pData === "undefined") { pData = null; }
                iByteSize = akra.math.max(iByteSize, 1024);
                if((((iFlags) & (4 /* READABLE */ )) != 0)) {
                    ((iFlags) |= (8 /* BACKUP_COPY */ ));
                }
                _super.prototype.create.call(this, iByteSize, iFlags, pData);
                var pWebGLRenderer = this.getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                var i;
                akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 45);
                akra.logger.assert(this._pWebGLBuffer == null, "webgl buffer already allocated");
                ;
                this._iByteSize = iByteSize;
                this._iFlags = iFlags;
                pWebGLContext = pWebGLRenderer.getWebGLContext();
                akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 51);
                akra.logger.assert(pWebGLContext !== null, "cannot grab webgl context");
                ;
                //Софтварного рендеринга буфера у нас нет
                akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 54);
                akra.logger.assert(!this.isSoftware(), "no sftware rendering");
                ;
                //Если есть локальная копия то буфер можно читать
                if(this.isBackupPresent()) {
                    ((this._iFlags) |= (4 /* READABLE */ ));
                }
                akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 62);
                akra.logger.assert(!pData || pData.byteLength <= iByteSize, "Размер переданного массива больше переданного размера буфера");
                ;
                this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();
                if(!this._pWebGLBuffer) {
                    akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 68);
                    akra.logger.criticalError("cannot create WebGL index buffer");
                    ;
                    this.destroy();
                    return false;
                }
                pWebGLRenderer.bindWebGLBuffer(0x8893, this._pWebGLBuffer);
                pWebGLContext.bufferData(0x8893, this._iByteSize, webgl.getWebGLUsage(this._iFlags));
                if(pData) {
                    pWebGLContext.bufferSubData(0x8893, 0, akra.isArrayBuffer(pData) ? pData : pData.buffer);
                }
                return true;
            };
            WebGLIndexBuffer.prototype.destroy = function /** @no-inline */() {
                _super.prototype.destroy.call(this);
                var pWebGLRenderer = this.getEngine().getRenderer();
                pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);
                this._pWebGLBuffer = null;
                this._iByteSize = 0;
            };
            WebGLIndexBuffer.prototype.readData = function /** @no-inline */(iOffset, iSize, ppDest) {
                akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 99);
                akra.logger.assert(!akra.isNull(this._pWebGLBuffer), "WebGL buffer not exists");
                ;
                if(!this.isBackupPresent()) {
                    return false;
                }
                if(arguments.length === 1) {
                    this._pBackupCopy.readData(arguments[0]);
                } else {
                    this._pBackupCopy.readData(iOffset, iSize, ppDest);
                }
                return true;
            };
            WebGLIndexBuffer.prototype.writeData = function /** @no-inline */(pData, iOffset, iSize, bDiscardWholeBuffer) {
                if (typeof bDiscardWholeBuffer === "undefined") { bDiscardWholeBuffer = false; }
                akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 119);
                akra.logger.assert(!akra.isNull(this._pWebGLBuffer), "WebGL buffer not exists");
                ;
                var pWebGLRenderer = this.getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                pWebGLRenderer.bindWebGLBuffer(0x8893, this._pWebGLBuffer);
                akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 126);
                akra.logger.assert(pData.byteLength <= iSize, "Размер переданного массива больше переданного размера");
                ;
                akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 127);
                akra.logger.assert(this.byteLength >= iOffset + iSize, "Данные выйдут за предел буфера");
                ;
                var pU8Data = null;
                if(akra.isArrayBuffer(pData)) {
                    pU8Data = new Uint8Array(pData);
                } else {
                    pU8Data = new Uint8Array(pData.buffer, pData.byteOffset, pData.byteLength);
                }
                pU8Data = pU8Data.subarray(0, iSize);
                pWebGLContext.bufferSubData(0x8893, iOffset, pU8Data);
                if(this.isBackupPresent()) {
                    this._pBackupCopy.writeData(pU8Data, iOffset);
                }
                this.notifyAltered();
                return true;
            };
            WebGLIndexBuffer.prototype.resize = function /** @no-inline */(iSize) {
                var eUsage;
                var pData;
                var iMax = 0;
                var pIndexData;
                var pWebGLRenderer = this.getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                if(this.isBackupPresent()) {
                    return false;
                }
                if(iSize < this.byteLength) {
                    for(var k = 0; k < this._pIndexDataArray.length; ++k) {
                        pIndexData = this._pIndexDataArray[k];
                        if(pIndexData.byteOffset + pIndexData.byteLength > iMax) {
                            iMax = pIndexData.byteOffset + pIndexData.byteLength;
                        }
                    }
                    akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 174);
                    akra.logger.assert(iMax <= iSize, "Уменьшение невозможно. Страая разметка не укладывается в новый размер");
                    ;
                }
                if(pWebGLContext.isBuffer(this._pWebGLBuffer)) {
                    pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);
                }
                eUsage = webgl.getWebGLUsage(this._iFlags);
                this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();
                if(!this._pWebGLBuffer) {
                    akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 186);
                    akra.logger.criticalError("cannot create WebGL index buffer");
                    ;
                    this.destroy();
                    return false;
                }
                pWebGLRenderer.bindWebGLBuffer(0x8893, this._pWebGLBuffer);
                pWebGLContext.bufferData(0x8893, iSize, eUsage);
                pData = new Uint8Array(this._iByteSize);
                if(this.readData(pData)) {
                    akra.logger.setSourceLocation("webgl/WebGLIndexBuffer.ts", 199);
                    akra.logger.warning("cannot read data from buffer");
                    ;
                    return false;
                }
                this.writeData(pData, 0, this._iByteSize);
                this._pBackupCopy.resize(iSize);
                this._iByteSize = iSize;
                this.notifyAltered();
                return true;
            };
            WebGLIndexBuffer.prototype.getWebGLBuffer = function /** @inline */() {
                return this._pWebGLBuffer;
            };
            WebGLIndexBuffer.prototype.lockImpl = /**@protected*/ function /** @no-inline */(iOffset, iSize, iLockFlags) {
                var pRetData = new Uint8Array(iSize);
                this.readData(iOffset, iSize, pRetData);
                this._pLockData = pRetData;
                return pRetData;
            };
            WebGLIndexBuffer.prototype.unlockImpl = /**@protected*/ function /** @no-inline */() {
                this.writeData(this._pLockData, this._iLockStart, this._iLockSize);
            };
            WebGLIndexBuffer.prototype.copyBackupToRealImpl = /**@protected*/ function /** @no-inline */(pRealData, pBackupData, iLockFlags) {
                pRealData.set(pBackupData);
            };
            return WebGLIndexBuffer;
        })(akra.core.pool.resources.IndexBuffer);
        webgl.WebGLIndexBuffer = WebGLIndexBuffer;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLInternalRenderBuffer = (function (_super) {
            __extends(WebGLInternalRenderBuffer, _super);
            function /** @no-inline */WebGLInternalRenderBuffer() {
                        _super.call(this);
                /**@protected*/ this._pWebGLRenderbuffer = null;
            }
            WebGLInternalRenderBuffer.prototype.create = function /** @no-inline */() {
                if(arguments.length !== 4) {
                    akra.logger.setSourceLocation("webgl/WebGLInternalRenderbuffer.ts", 20);
                    akra.logger.criticalError("Invalid number of arguments. For PixelBuffer it must be four");
                    ;
                }
                var iWebGLFormat = arguments[0];
                var iWidth = arguments[1];
                var iHeight = arguments[2];
                var bCreateStorage = arguments[3];
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                _super.prototype.create.call(this, iWidth, iHeight, 1, akra.webgl.getClosestAkraFormat(iWebGLFormat, 12 /* A8R8G8B8 */ ), 0);
                this._iWebGLInternalFormat = iWebGLFormat;
                this._pWebGLRenderbuffer = pWebGLRenderer.createWebGLRenderbuffer();
                pWebGLRenderer.bindWebGLRenderbuffer(0x8D41, this._pWebGLRenderbuffer);
                if(bCreateStorage) {
                    pWebGLContext.renderbufferStorage(0x8D41, iWebGLFormat, iWidth, iHeight);
                }
                this.notifyCreated();
                return true;
            };
            WebGLInternalRenderBuffer.prototype.destroy = function /** @no-inline */() {
                _super.prototype.destroy.call(this);
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                pWebGLRenderer.deleteWebGLRenderbuffer(this._pWebGLRenderbuffer);
                this._pWebGLRenderbuffer = null;
            };
            WebGLInternalRenderBuffer.prototype._bindToFramebuffer = function /** @no-inline */(iAttachment, iZOffset) {
                akra.logger.setSourceLocation("webgl/WebGLInternalRenderbuffer.ts", 55);
                akra.logger.assert(iZOffset < this._iDepth);
                ;
                var pWebGLRenderer = this.getManager().getEngine().getRenderer();
                var pWebGLContext = pWebGLRenderer.getWebGLContext();
                pWebGLContext.framebufferRenderbuffer(0x8D40, iAttachment, 0x8D41, this._pWebGLRenderbuffer);
            };
            return WebGLInternalRenderBuffer;
        })(webgl.WebGLPixelBuffer);
        webgl.WebGLInternalRenderBuffer = WebGLInternalRenderBuffer;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            (function (resources) {
                var DepthBuffer = (function (_super) {
                    __extends(DepthBuffer, _super);
                    function /** @no-inline */DepthBuffer() {
                                        _super.call(this);
                        /**@protected*/ this._iBitDepth = 0;
                        /**@protected*/ this._iWidth = 0;
                        /**@protected*/ this._iHeight = 0;
                        /**@protected*/ this._isManual = false;
                        /**@protected*/ this._pAttachedRenderTargetsList = null;
                    }
                    Object.defineProperty(DepthBuffer.prototype, "bitDepth", {
                        get: function /** @inline */() {
                            return this._iBitDepth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DepthBuffer.prototype, "width", {
                        get: function /** @inline */() {
                            return this._iWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DepthBuffer.prototype, "height", {
                        get: function /** @inline */() {
                            return this._iHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DepthBuffer.prototype.create = function /** @no-inline */(iBitDepth, iWidth, iHeight, isManual) {
                        this._iBitDepth = iBitDepth;
                        this._iWidth = iWidth;
                        this._iHeight = iHeight;
                        this._isManual = isManual;
                        this._pAttachedRenderTargetsList = [];
                        this.notifyCreated();
                        return true;
                    };
                    DepthBuffer.prototype.destroy = function /** @no-inline */() {
                        this.detachFromAllRenderTargets();
                        this._pAttachedRenderTargetsList = null;
                    };
                    DepthBuffer.prototype.destroyResource = function /** @no-inline */() {
                        this.destroy();
                        this.notifyDestroyed();
                        return true;
                    };
                    DepthBuffer.prototype.isManual = function /** @no-inline */() {
                        return this._isManual;
                    };
                    DepthBuffer.prototype.isCompatible = function /** @no-inline */(pTarget) {
                        if(this._iWidth >= pTarget.width && this._iHeight >= pTarget.height) {
                            return true;
                        }
                        return false;
                    };
                    DepthBuffer.prototype._notifyRenderTargetAttached = function /** @no-inline */(pTarget) {
                        akra.logger.setSourceLocation("core/pool/resources/DepthBuffer.ts", 70);
                        akra.logger.assert(this._pAttachedRenderTargetsList.indexOf(pTarget) === -1, "RenderTarget alrady has been attached to this DepthBuffer");
                        ;
                        this._pAttachedRenderTargetsList.push(pTarget);
                    };
                    DepthBuffer.prototype._notifyRenderTargetDetached = function /** @no-inline */(pTarget) {
                        var index = this._pAttachedRenderTargetsList.indexOf(pTarget);
                        akra.logger.setSourceLocation("core/pool/resources/DepthBuffer.ts", 78);
                        akra.logger.assert(index !== -1, "Can not detach RenderTarget from DepthBuffer beacuse it hasn`t been attached to it");
                        ;
                        this._pAttachedRenderTargetsList.splice(index, 1);
                    };
                    DepthBuffer.prototype.detachFromAllRenderTargets = /**@protected*/ function /** @no-inline */() {
                        var i = 0;
                        for(i = 0; i < this._pAttachedRenderTargetsList.length; i++) {
                            //If we call, detachDepthBuffer, we'll invalidate the iterators
                            this._pAttachedRenderTargetsList[i].detachDepthBuffer();
                        }
                        this._pAttachedRenderTargetsList.clear();
                    };
                    return DepthBuffer;
                })(pool.ResourcePoolItem);
                resources.DepthBuffer = DepthBuffer;                
            })(pool.resources || (pool.resources = {}));
            var resources = pool.resources;
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        var RenderTexture = (function (_super) {
            __extends(RenderTexture, _super);
            function /** @no-inline */RenderTexture(pRenderer, pBuffer, iZOffset) {
                        _super.call(this, pRenderer);
                /**@protected*/ this._pBuffer = null;
                /**@protected*/ this._iZOffset = 0;
                this._pBuffer = pBuffer;
                this._iZOffset = iZOffset;
                this._iWidth = pBuffer.width;
                this._iHeight = pBuffer.height;
                this._iColorDepth = akra.pixelUtil.getNumElemBits(pBuffer.format);
            }
            RenderTexture.prototype.destroy = function /** @no-inline */() {
                this._pBuffer._clearRTT(this._iZOffset);
                this._pBuffer = null;
            };
            RenderTexture.prototype.suggestPixelFormat = function /** @inline */() {
                return this._pBuffer.format;
            };
            RenderTexture.prototype.copyContentsToMemory = function /** @no-inline */(pDest, eBuffer) {
                if(eBuffer === 2 /* AUTO */ ) {
                    eBuffer = 0 /* FRONT */ ;
                }
                if(eBuffer !== 0 /* FRONT */ ) {
                    akra.logger.setSourceLocation("render/RenderTexture.ts", 41);
                    akra.logger.criticalError("Invalid buffer.");
                    ;
                }
                this._pBuffer.blitToMemory(pDest);
            };
            return RenderTexture;
        })(render.RenderTarget);
        render.RenderTexture = RenderTexture;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLRenderTexture = (function (_super) {
            __extends(WebGLRenderTexture, _super);
            function /** @no-inline */WebGLRenderTexture(pRenderer, pTarget) {
                        _super.call(this, pRenderer, pTarget, 0);
                /**@protected*/ this._pFrameBuffer = null;
                this._pFrameBuffer = new webgl.WebGLInternalFrameBuffer(pRenderer);
                this._pFrameBuffer.bindSurface(0x8CE0, pTarget);
                this._iWidth = this._pFrameBuffer.width;
                this._iHeight = this._pFrameBuffer.height;
            }
            WebGLRenderTexture.prototype.destroy = function /** @no-inline */() {
                _super.prototype.destroy.call(this);
            };
            WebGLRenderTexture.prototype.requiresTextureFlipping = function /** @no-inline */() {
                return true;
            };
            WebGLRenderTexture.prototype.getCustomAttribute = function /** @no-inline */(sName) {
                if(sName === "FBO") {
                    return this._pFrameBuffer;
                }
            };
            WebGLRenderTexture.prototype.swapBuffers = function /** @no-inline */() {
                this._pFrameBuffer.swapBuffers();
            };
            WebGLRenderTexture.prototype.attachDepthBuffer = function /** @no-inline */(pDepthBuffer) {
                var bResult = false;
                bResult = _super.prototype.attachDepthBuffer.call(this, pDepthBuffer);
                if(bResult) {
                    this._pFrameBuffer.attachDepthBuffer(pDepthBuffer);
                }
                return bResult;
            };
            WebGLRenderTexture.prototype.attachDepthPixelBuffer = function /** @no-inline */(pBuffer) {
                var bResult = false;
                bResult = _super.prototype.attachDepthPixelBuffer.call(this, pBuffer);
                if(bResult) {
                    if(pBuffer.format !== 44 /* DEPTH_BYTE */ ) {
                        this.detachDepthPixelBuffer();
                        return false;
                    }
                    this._pFrameBuffer.bindSurface(0x8D00, pBuffer);
                    (pBuffer).addRef();
                }
                return bResult;
            };
            WebGLRenderTexture.prototype.detachDepthPixelBuffer = function /** @no-inline */() {
                this._pFrameBuffer.unbindSurface(0x8D00);
                (this._pDepthPixelBuffer).release();
                _super.prototype.detachDepthPixelBuffer.call(this);
            };
            WebGLRenderTexture.prototype.detachDepthBuffer = function /** @no-inline */() {
                this._pFrameBuffer.detachDepthBuffer();
                _super.prototype.detachDepthBuffer.call(this);
            };
            return WebGLRenderTexture;
        })(akra.render.RenderTexture);
        webgl.WebGLRenderTexture = WebGLRenderTexture;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLInternalFrameBuffer = (function () {
            function /** @no-inline */WebGLInternalFrameBuffer(pWebGLRenderer) {
                this._pWebGLRenderer = null;
                this._pWebGLFramebuffer = null;
                this._pAttachments = null;
                this._pWebGLRenderer = pWebGLRenderer;
                this._pWebGLFramebuffer = this._pWebGLRenderer.createWebGLFramebuffer();
                this._pAttachments = {
                };
                for(var i = 0; i < akra.webgl.maxColorAttachments; i++) {
                    this._pAttachments[0x8CE0 + i] = null;
                }
                this._pAttachments[0x8D00] = null;
                this._pAttachments[0x8D20] = null;
                this._pAttachments[0x821A] = null;
            }
            WebGLInternalFrameBuffer.prototype.destroy = function /** @no-inline */() {
                this._pWebGLRenderer.deleteWebGLFramebuffer(this._pWebGLFramebuffer);
                this._pWebGLFramebuffer = null;
            };
            Object.defineProperty(WebGLInternalFrameBuffer.prototype, "width", {
                get: function /** @inline */() {
                    return this._pAttachments[0x8CE0].width;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLInternalFrameBuffer.prototype, "height", {
                get: function /** @inline */() {
                    return this._pAttachments[0x8CE0].height;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLInternalFrameBuffer.prototype, "format", {
                get: function /** @inline */() {
                    return this._pAttachments[0x8CE0].format;
                },
                enumerable: true,
                configurable: true
            });
            WebGLInternalFrameBuffer.prototype.getColorAttachment = function /** @inline */(iAttachment) {
                return this._pAttachments[0x8CE0 + iAttachment];
            };
            WebGLInternalFrameBuffer.prototype.getAttachment = function /** @inline */(iWebGLAttachment) {
                return this._pAttachments[iWebGLAttachment];
            };
            WebGLInternalFrameBuffer.prototype.bindSurface = function /** @no-inline */(iWebGLAttachment, pSurface) {
                if(!akra.isDef(this._pAttachments[iWebGLAttachment])) {
                    return;
                }
                this.releaseAttachment(iWebGLAttachment);
                this._pAttachments[iWebGLAttachment] = pSurface;
                if(this.checkAttachment(iWebGLAttachment)) {
                    this.bind();
                    (pSurface)._bindToFramebuffer(iWebGLAttachment, 0);
                    (pSurface).addRef();
                }
            };
            WebGLInternalFrameBuffer.prototype.unbindSurface = function /** @no-inline */(iWebGLAttachment) {
                if(!akra.isDef(this._pAttachments[iWebGLAttachment])) {
                    return;
                }
                var pWebGLContext = this._pWebGLRenderer.getWebGLContext();
                this.releaseAttachment(iWebGLAttachment);
                this._pAttachments[iWebGLAttachment] = null;
                pWebGLContext.framebufferRenderbuffer(0x8D40, iWebGLAttachment, 0x8D41, null);
            };
            WebGLInternalFrameBuffer.prototype.bindColorSurface = function /** @inline */(iAttachment, pSurface) {
                this.bindSurface(0x8CE0 + iAttachment, pSurface);
            };
            WebGLInternalFrameBuffer.prototype.bind = function /** @inline */() {
                this._pWebGLRenderer.bindWebGLFramebuffer(0x8D40, this._pWebGLFramebuffer);
            };
            WebGLInternalFrameBuffer.prototype.attachDepthBuffer = function /** @no-inline */(pDepthBuffer) {
                if(!akra.isNull(pDepthBuffer)) {
                    var pDepthRenderBuffer = (pDepthBuffer).depthBuffer;
                    var pStencilRenderBuffer = (pDepthBuffer).stencilBuffer;
                    if(!akra.isNull(pDepthRenderBuffer)) {
                        pDepthRenderBuffer._bindToFramebuffer(0x8D00, 0);
                        this.releaseAttachment(0x8D00);
                        this._pAttachments[0x8D00] = pDepthRenderBuffer;
                        pDepthRenderBuffer.addRef();
                    }
                    if(!akra.isNull(pStencilRenderBuffer)) {
                        pStencilRenderBuffer._bindToFramebuffer(0x8D20, 0);
                        this.releaseAttachment(0x8D20);
                        this._pAttachments[0x8D20] = pStencilRenderBuffer;
                        pDepthRenderBuffer.addRef();
                    }
                    if(!this.checkAttachment(0x8D00) || !this.checkAttachment(0x8D20)) {
                        akra.logger.setSourceLocation("webgl/WebGLInternalFrameBuffer.ts", 117);
                        akra.logger.error("Invalid frame buffer depthbuffer attachment. Wrong size.");
                        ;
                        return;
                    }
                } else {
                    var pWebGLContext = this._pWebGLRenderer.getWebGLContext();
                    pWebGLContext.framebufferRenderbuffer(0x8D40, 0x8D00, 0x8D41, null);
                    pWebGLContext.framebufferRenderbuffer(0x8D40, 0x8D20, 0x8D41, null);
                    this.releaseAttachment(0x8D00);
                    this.releaseAttachment(0x8D20);
                    this._pAttachments[0x8D00] = null;
                    this._pAttachments[0x8D20] = null;
                }
            };
            WebGLInternalFrameBuffer.prototype.detachDepthBuffer = function /** @no-inline */() {
                var pWebGLContext = this._pWebGLRenderer.getWebGLContext();
                this._pWebGLRenderer.bindWebGLFramebuffer(0x8D40, this._pWebGLFramebuffer);
                pWebGLContext.framebufferRenderbuffer(0x8D40, 0x8D00, 0x8D41, null);
                pWebGLContext.framebufferRenderbuffer(0x8D40, 0x8D20, 0x8D41, null);
                this.releaseAttachment(0x8D00);
                this.releaseAttachment(0x8D20);
                this._pAttachments[0x8D00] = null;
                this._pAttachments[0x8D20] = null;
            };
            WebGLInternalFrameBuffer.prototype.swapBuffers = function /** @no-inline */() {
            };
            WebGLInternalFrameBuffer.prototype.checkAttachment = function /** @no-inline */(iWebGLAttachment) {
                if(iWebGLAttachment === 0x8CE0) {
                    var isOk = true;
                    for(var i = 1; i < akra.webgl.maxColorAttachments; i++) {
                        isOk = this.checkAttachment(0x8CE0 + i);
                        if(!isOk) {
                            return false;
                        }
                    }
                    isOk = this.checkAttachment(0x8D00);
                    if(!isOk) {
                        return false;
                    }
                    isOk = this.checkAttachment(0x8D20);
                    if(!isOk) {
                        return false;
                    }
                    isOk = this.checkAttachment(0x821A);
                    if(!isOk) {
                        return false;
                    }
                    return true;
                } else {
                    var pBuffer = this._pAttachments[iWebGLAttachment];
                    if(akra.isNull(pBuffer)) {
                        return true;
                    }
                    if(this.width === 0 && this.height === 0) {
                        return true;
                    }
                    if(this.width !== pBuffer.width && this.height !== pBuffer.height) {
                        return false;
                    }
                    if(iWebGLAttachment > 0x8CE0 && iWebGLAttachment < 0x8CE0 + akra.webgl.maxColorAttachments) {
                        if(!akra.isNull(this._pAttachments[0x8CE0]) && this.format !== pBuffer.format) {
                            return false;
                        }
                    }
                    return true;
                }
            };
            WebGLInternalFrameBuffer.prototype.releaseAttachment = function /** @inline */(iWebGLAttachment) {
                if(!akra.isNull(this._pAttachments[iWebGLAttachment])) {
                    this._pAttachments[iWebGLAttachment].release();
                }
            };
            return WebGLInternalFrameBuffer;
        })();
        webgl.WebGLInternalFrameBuffer = WebGLInternalFrameBuffer;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (webgl) {
        var WebGLDepthBuffer = (function (_super) {
            __extends(WebGLDepthBuffer, _super);
            function /** @no-inline */WebGLDepthBuffer() {
                        _super.call(this);
                /**@protected*/ this._pDepthBuffer = null;
                /**@protected*/ this._pStencilBuffer = null;
            }
            Object.defineProperty(WebGLDepthBuffer.prototype, "depthBuffer", {
                get: function /** @inline */() {
                    return this._pDepthBuffer;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLDepthBuffer.prototype, "stencilBuffer", {
                get: function /** @inline */() {
                    return this._pStencilBuffer;
                },
                enumerable: true,
                configurable: true
            });
            WebGLDepthBuffer.prototype.create = function /** @no-inline */() {
                if(arguments.length !== 5) {
                    akra.logger.setSourceLocation("webgl/WebGLDepthBuffer.ts", 30);
                    akra.logger.criticalError("Invalid number of arguments. For WebGLDepthBuffer it must be five");
                    ;
                }
                _super.prototype.create.call(this, 0, arguments[2], arguments[3], arguments[4]);
                var pDepth = arguments[0];
                var pStencil = arguments[1];
                this._pDepthBuffer = pDepth;
                this._pStencilBuffer = pStencil;
                if(!akra.isNull(pDepth)) {
                    switch(pDepth._getWebGLFormat()) {
                        case 0x81A5:
                            this._iBitDepth = 16;
                            break;
                        case 0x81A6:
                        case 0x81A7:
                        case 0x88F0:
                            if(akra.webgl.hasExtension("OES_depth24") || akra.webgl.hasExtension("OES_depth32") || akra.webgl.hasExtension("OES_packed_depth_stencil")) {
                                this._iBitDepth = 32;
                            }
                            break;
                    }
                }
                return true;
            };
            WebGLDepthBuffer.prototype.destroy = function /** @no-inline */() {
                _super.prototype.destroy.call(this);
                if(!akra.isNull(this._pStencilBuffer) && this._pStencilBuffer !== this._pDepthBuffer) {
                    this._pStencilBuffer.release();
                }
                if(!akra.isNull(this._pDepthBuffer)) {
                    this._pDepthBuffer.release();
                }
                this._pStencilBuffer = null;
                this._pDepthBuffer = null;
            };
            WebGLDepthBuffer.prototype.isCompatible = function /** @no-inline */(pTarget) {
                if(this._iWidth >= pTarget.width && this._iHeight >= pTarget.height) {
                    return true;
                }
                return false;
            };
            return WebGLDepthBuffer;
        })(akra.core.pool.resources.DepthBuffer);
        webgl.WebGLDepthBuffer = WebGLDepthBuffer;        
    })(akra.webgl || (akra.webgl = {}));
    var webgl = akra.webgl;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        (function (pool) {
            //is this class really singleton??
            var ResourcePoolManager = (function () {
                function /** @no-inline */ResourcePoolManager(pEngine) {
                    /** Списки пулов по семействам ресурсов */
                    this.pResourceFamilyList = null;
                    /** Карта пулов по коду ресурса */
                    this.pResourceTypeMap = null;
                    /** Ресурс для ожидания остальных */
                    this.pWaiterResource = null;
                    //super();
                    this.pEngine = pEngine;
                    this.pResourceFamilyList = new Array(3 /* TOTAL_RESOURCE_FAMILIES */ );
                    for(var i = 0; i < 3 /* TOTAL_RESOURCE_FAMILIES */ ; i++) {
                        this.pResourceFamilyList[i] = new Array();
                    }
                    this.pResourceTypeMap = new Array();
                    /*this*/
                    this.pWaiterResource = new core.pool.ResourcePoolItem();
                    this.createDeviceResource();
                }
                Object.defineProperty(ResourcePoolManager.prototype, "surfaceMaterialPool", {
                    get: function /** @no-inline */() {
                        return this.pSurfaceMaterialPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "effectPool", {
                    get: function /** @no-inline */() {
                        return this.pEffectPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "renderMethodPool", {
                    get: function /** @no-inline */() {
                        return this.pRenderMethodPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "vertexBufferPool", {
                    get: function /** @no-inline */() {
                        return this.pVertexBufferPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "indexBufferPool", {
                    get: function /** @no-inline */() {
                        return this.pIndexBufferPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "colladaPool", {
                    get: function /** @no-inline */() {
                        return this.pColladaPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "imagePool", {
                    get: function /** @no-inline */() {
                        return this.pImagePool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "texturePool", {
                    get: function /** @no-inline */() {
                        return this.pTexturePool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "videoBufferPool", {
                    get: function /** @no-inline */() {
                        return this.pVideoBufferPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "shaderProgramPool", {
                    get: function /** @no-inline */() {
                        return this.pShaderProgramPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "componentPool", {
                    get: function /** @no-inline */() {
                        return this.pComponentPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "textureBufferPool", {
                    get: function /** @no-inline */() {
                        return this.pTextureBufferPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "renderBufferPool", {
                    get: function /** @no-inline */() {
                        return this.pRenderBufferPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "depthBufferPool", {
                    get: function /** @no-inline */() {
                        return this.pDepthBufferPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ResourcePoolManager.prototype, "effectDataPool", {
                    get: function /** @no-inline */() {
                        return this.pEffectDataPool;
                    },
                    enumerable: true,
                    configurable: true
                });
                ResourcePoolManager.prototype.initialize = function /** @no-inline */() {
                    this.registerDeviceResources();
                    return true;
                };
                ResourcePoolManager.prototype.destroy = function /** @no-inline */() {
                    this.unregisterDeviceResources();
                };
                ResourcePoolManager.prototype.registerResourcePool = function /** @no-inline */(pCode, pPool) {
                    akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 115);
                    akra.logger.assert(pCode.family >= 0 && pCode.family < 3 /* TOTAL_RESOURCE_FAMILIES */ , "invalid code familyi index");
                    ;
                    akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 117);
                    akra.logger.assert(!akra.isDef(this.pResourceTypeMap[pCode.toNumber()]), "Resource type code already registered");
                    ;
                    this.pResourceTypeMap[pCode.toNumber()] = pPool;
                    this.pResourceFamilyList[pCode.family].push(pPool);
                };
                ResourcePoolManager.prototype.unregisterResourcePool = function /** @no-inline */(pCode) {
                    akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 124);
                    akra.logger.assert(pCode.family >= 0, "invalid family index");
                    ;
                    akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 125);
                    akra.logger.assert(pCode.family < 3 /* TOTAL_RESOURCE_FAMILIES */ , "invalid family index");
                    ;
                    var iCode = pCode.toNumber();
                    var pPool = null;
                    if(this.pResourceTypeMap[iCode] != undefined) {
                        pPool = this.pResourceTypeMap[iCode];
                        delete this.pResourceTypeMap[iCode];
                    }
                    if(pPool != null) {
                        for(var i in this.pResourceFamilyList[pCode.family]) {
                            if(this.pResourceFamilyList[pCode.family][i] == pPool) {
                                delete this.pResourceFamilyList[pCode.family][i];
                                return pPool;
                            }
                        }
                    }
                    return pPool;
                };
                ResourcePoolManager.prototype.destroyResourceFamily = function /** @no-inline */(eFamily) {
                    akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 148);
                    akra.logger.assert(eFamily < 3 /* TOTAL_RESOURCE_FAMILIES */ , "invalid family index");
                    ;
                    for(var i in this.pResourceFamilyList[eFamily]) {
                        this.pResourceFamilyList[eFamily][i].destroyAll();
                    }
                };
                ResourcePoolManager.prototype.restoreResourceFamily = function /** @no-inline */(eFamily) {
                    akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 157);
                    akra.logger.assert(eFamily >= 0, "invalid family index");
                    ;
                    akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 158);
                    akra.logger.assert(eFamily < 3 /* TOTAL_RESOURCE_FAMILIES */ , "invalid family index");
                    ;
                    for(var i in this.pResourceFamilyList[eFamily]) {
                        this.pResourceFamilyList[eFamily][i].restoreAll();
                    }
                };
                ResourcePoolManager.prototype.disableResourceFamily = function /** @no-inline */(eFamily) {
                    akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 166);
                    akra.logger.assert(eFamily >= 0, "invalid family index");
                    ;
                    akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 167);
                    akra.logger.assert(eFamily < 3 /* TOTAL_RESOURCE_FAMILIES */ , "invalid family index");
                    ;
                    for(var i in this.pResourceFamilyList[eFamily]) {
                        this.pResourceFamilyList[eFamily][i].disableAll();
                    }
                };
                ResourcePoolManager.prototype.cleanResourceFamily = function /** @no-inline */(eFamily) {
                    akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 175);
                    akra.logger.assert(eFamily >= 0, "invalid family index");
                    ;
                    akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 176);
                    akra.logger.assert(eFamily < 3 /* TOTAL_RESOURCE_FAMILIES */ , "invalid family index");
                    ;
                    for(var i in this.pResourceFamilyList[eFamily]) {
                        this.pResourceFamilyList[eFamily][i].clean();
                    }
                };
                ResourcePoolManager.prototype.destroyResourceType = function /** @no-inline */(pCode) {
                    if(akra.isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                        this.pResourceTypeMap[pCode.toNumber()].destroyAll();
                    }
                };
                ResourcePoolManager.prototype.restoreResourceType = function /** @no-inline */(pCode) {
                    if(akra.isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                        this.pResourceTypeMap[pCode.toNumber()].restoreAll();
                    }
                };
                ResourcePoolManager.prototype.disableResourceType = function /** @no-inline */(pCode) {
                    if(akra.isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                        this.pResourceTypeMap[pCode.toNumber()].disableAll();
                    }
                };
                ResourcePoolManager.prototype.cleanResourceType = function /** @no-inline */(pCode) {
                    if(akra.isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                        this.pResourceTypeMap[pCode.toNumber()].clean();
                    }
                };
                ResourcePoolManager.prototype.findResourcePool = function /** @no-inline */(pCode) {
                    if(akra.isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                        return this.pResourceTypeMap[pCode.toNumber()];
                    }
                    return null;
                };
                ResourcePoolManager.prototype.findResourceHandle = function /** @no-inline */(pCode, sName) {
                    var pPool = this.findResourcePool(pCode);
                    var iHandle = akra.INVALID_INDEX;
                    if(!akra.isNull(pPool)) {
                        iHandle = pPool.findResourceHandle(sName);
                    }
                    return iHandle;
                };
                ResourcePoolManager.prototype.findResource = function /** @no-inline */(pCode, sName) {
                    var pPool = this.findResourcePool(pCode);
                    var pResult = null;
                    var iHandle = 0;
                    if(akra.isString(arguments[1])) {
                        iHandle = pPool.findResourceHandle(sName);
                    } else if(akra.isInt(arguments[1])) {
                        iHandle = arguments[1];
                    }
                    if(pPool != null && iHandle != akra.INVALID_INDEX) {
                        pResult = pPool.getResource(iHandle);
                    }
                    return pResult;
                };
                ResourcePoolManager.prototype.monitorInitResources = function /** @no-inline */(fnMonitor) {
                    var me = this;
                    this.pWaiterResource.setStateWatcher(1 /* LOADED */ , function /** @no-inline */() {
                        fnMonitor.apply(me, arguments);
                    });
                };
                ResourcePoolManager.prototype.setLoadedAllRoutine = function /** @no-inline */(fnCallback) {
                    var pPool;
                    var pResource;
                    var iHandleResource;
                    var pWaiterResouse = this.pWaiterResource;
                    var fnResCallback = function /** @no-inline */(iFlagBit, iResourceFlags, isSetting) {
                        if(iFlagBit == 1 /* LOADED */  && isSetting) {
                            fnCallback();
                        }
                    };
                    pWaiterResouse.notifyLoaded();
                    for(var n = 0; n < 3 /* TOTAL_RESOURCE_FAMILIES */ ; n++) {
                        for(var i = 0; i < ResourcePoolManager.pTypedResourseTotal[n]; i++) {
                            pPool = this.findResourcePool(new pool.ResourceCode(n, i));
                            if(pPool) {
                                var pResources = pPool.getResources();
                                var pResource;
                                for(var i = 0; i < pResources.length; ++i) {
                                    pResource = pResources[i];
                                    pWaiterResouse.sync(pResource, 1 /* LOADED */ );
                                }
                            }
                        }
                    }
                    if(pWaiterResouse.isResourceLoaded()) {
                        fnCallback();
                    } else {
                        pWaiterResouse.setChangesNotifyRoutine(fnResCallback);
                    }
                };
                ResourcePoolManager.prototype.destroyAll = function /** @no-inline */() {
                    for(var i = 0; i < 3 /* TOTAL_RESOURCE_FAMILIES */ ; i++) {
                        this.destroyResourceFamily(i);
                    }
                };
                ResourcePoolManager.prototype.restoreAll = function /** @no-inline */() {
                    for(var i = 0; i < 3 /* TOTAL_RESOURCE_FAMILIES */ ; i++) {
                        this.restoreResourceFamily(i);
                    }
                };
                ResourcePoolManager.prototype.disableAll = function /** @no-inline */() {
                    for(var i = 0; i < 3 /* TOTAL_RESOURCE_FAMILIES */ ; i++) {
                        this.disableResourceFamily(i);
                    }
                };
                ResourcePoolManager.prototype.clean = function /** @no-inline */() {
                    for(var i = 0; i < 3 /* TOTAL_RESOURCE_FAMILIES */ ; i++) {
                        this.cleanResourceFamily(i);
                    }
                };
                ResourcePoolManager.prototype.createDeviceResources = function /** @no-inline */() {
                    return true;
                };
                ResourcePoolManager.prototype.destroyDeviceResources = function /** @no-inline */() {
                    this.disableDeviceResources();
                    // then destroy...
                    akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 327);
                    akra.logger.log("Destroying Video Device Resources\n");
                    ;
                    this.destroyResourceFamily(0 /* VIDEO_RESOURCE */ );
                    return true;
                };
                ResourcePoolManager.prototype.restoreDeviceResources = function /** @no-inline */() {
                    akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 335);
                    akra.logger.log("Restoring Video Device Resources\n");
                    ;
                    this.restoreResourceFamily(0 /* VIDEO_RESOURCE */ );
                    return true;
                };
                ResourcePoolManager.prototype.disableDeviceResources = function /** @no-inline */() {
                    akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 341);
                    akra.logger.log("Disabling Video Device Resources\n");
                    ;
                    this.disableResourceFamily(0 /* VIDEO_RESOURCE */ );
                    return true;
                };
                ResourcePoolManager.prototype.getEngine = function /** @inline */() {
                    return this.pEngine;
                };
                ResourcePoolManager.prototype.createRenderMethod = function /** @inline */(sResourceName) {
                    return this.renderMethodPool.createResource(sResourceName);
                };
                ResourcePoolManager.prototype.createTexture = function /** @inline */(sResourceName) {
                    return this.texturePool.createResource(sResourceName);
                };
                ResourcePoolManager.prototype.createEffect = function /** @inline */(sResourceName) {
                    return this.effectPool.createResource(sResourceName);
                };
                ResourcePoolManager.prototype.createSurfaceMaterial = function /** @inline */(sResourceName) {
                    return this.surfaceMaterialPool.createResource(sResourceName);
                };
                ResourcePoolManager.prototype.createVertexBuffer = function /** @inline */(sResourceName) {
                    return this.vertexBufferPool.createResource(sResourceName);
                };
                ResourcePoolManager.prototype.createVideoBuffer = function /** @inline */(sResourceName) {
                    return this.videoBufferPool.createResource(sResourceName);
                };
                ResourcePoolManager.prototype.createModel = function /** @inline */(sResourceName) {
                    return this.colladaPool.createResource(sResourceName);
                };
                ResourcePoolManager.prototype.loadModel = function /** @inline */(sFilename, pOptions) {
                    if (typeof pOptions === "undefined") { pOptions = null; }
                    if(akra.util.pathinfo(sFilename).ext.toLowerCase() === "dae") {
                        var pCollada = this.colladaPool.findResource(sFilename);
                        if(akra.isNull(pCollada)) {
                            pCollada = this.colladaPool.createResource(sFilename);
                        }
                        if(!pCollada.isResourceLoaded()) {
                            pCollada.loadResource(sFilename, pOptions);
                        }
                        return pCollada;
                    }
                    return null;
                };
                ResourcePoolManager.prototype.createDeviceResource = function /** @no-inline */() {
                    this.pSurfaceMaterialPool = new pool.ResourcePool(this, pool.resources.SurfaceMaterial);
                    this.pSurfaceMaterialPool.initialize(16);
                    this.pEffectPool = new pool.ResourcePool(this, pool.resources.Effect);
                    this.pEffectPool.initialize(16);
                    this.pRenderMethodPool = new pool.ResourcePool(this, pool.resources.RenderMethod);
                    this.pRenderMethodPool.initialize(16);
                    this.pColladaPool = new pool.ResourcePool(this, pool.resources.Collada);
                    this.pColladaPool.initialize(0);
                    this.pImagePool = new pool.ResourcePool(this, pool.resources.Img);
                    this.pImagePool.initialize(16);
                    this.pTexturePool = new pool.ResourcePool(this, akra.webgl.WebGLInternalTexture);
                    this.pTexturePool.initialize(16);
                    this.pIndexBufferPool = new pool.ResourcePool(this, akra.webgl.WebGLIndexBuffer);
                    this.pIndexBufferPool.initialize(16);
                    this.pVertexBufferPool = new pool.ResourcePool(this, akra.webgl.WebGLVertexBuffer);
                    this.pVertexBufferPool.initialize(16);
                    this.pVideoBufferPool = new pool.ResourcePool(this, akra.webgl.WebGLVertexTexture);
                    this.pVideoBufferPool.initialize(16);
                    this.pTextureBufferPool = new pool.ResourcePool(this, akra.webgl.WebGLTextureBuffer);
                    this.pTextureBufferPool.initialize(16);
                    this.pShaderProgramPool = new pool.ResourcePool(this, akra.webgl.WebGLShaderProgram);
                    this.pShaderProgramPool.initialize(16);
                    this.pRenderBufferPool = new pool.ResourcePool(this, akra.webgl.WebGLInternalRenderBuffer);
                    this.pRenderBufferPool.initialize(16);
                    this.pDepthBufferPool = new pool.ResourcePool(this, akra.webgl.WebGLDepthBuffer);
                    this.pDepthBufferPool.initialize(16);
                    this.pEffectDataPool = new pool.ResourcePool(this, pool.resources.EffectData);
                    this.pEffectDataPool.initialize(8);
                    this.pComponentPool = new pool.ResourcePool(this, pool.resources.Component);
                    this.pComponentPool.initialize(16);
                };
                ResourcePoolManager.prototype.registerDeviceResources = function /** @no-inline */() {
                    akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 450);
                    akra.logger.log("Registering Video Device Resources\n");
                    ;
                    this.pTexturePool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */ , 0 /* TEXTURE_RESOURCE */ ));
                    this.pVertexBufferPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */ , 2 /* VERTEXBUFFER_RESOURCE */ ));
                    this.pIndexBufferPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */ , 3 /* INDEXBUFFER_RESOURCE */ ));
                    this.pEffectPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */ , 4 /* EFFECT_RESOURCE */ ));
                    this.pRenderMethodPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */ , 5 /* RENDERMETHOD_RESOURCE */ ));
                    this.pColladaPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */ , 6 /* MODEL_RESOURCE */ ));
                    this.pImagePool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */ , 8 /* IMAGE_RESOURCE */ ));
                    this.pSurfaceMaterialPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */ , 9 /* SURFACEMATERIAL_RESOURCE */ ));
                    this.pVideoBufferPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */ , 1 /* VIDEOBUFFER_RESOURCE */ ));
                    this.pShaderProgramPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */ , 10 /* SHADERPROGRAM_RESOURCE */ ));
                    this.pComponentPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */ , 11 /* COMPONENT_RESOURCE */ ));
                    this.pEffectDataPool.registerResourcePool(new pool.ResourceCode(0 /* VIDEO_RESOURCE */ , 12 /* EFFECTDATA_RESOURCE */ ));
                };
                ResourcePoolManager.prototype.unregisterDeviceResources = function /** @no-inline */() {
                    akra.logger.setSourceLocation("pool/ResourcePoolManager.ts", 502);
                    akra.logger.log("Unregistering Video Device Resources");
                    ;
                    this.pTexturePool.unregisterResourcePool();
                    this.pVertexBufferPool.unregisterResourcePool();
                    this.pIndexBufferPool.unregisterResourcePool();
                    this.pEffectPool.unregisterResourcePool();
                    this.pRenderMethodPool.unregisterResourcePool();
                    this.pColladaPool.unregisterResourcePool();
                    this.pImagePool.unregisterResourcePool();
                    this.pSurfaceMaterialPool.unregisterResourcePool();
                    this.pVideoBufferPool.unregisterResourcePool();
                    this.pShaderProgramPool.unregisterResourcePool();
                    this.pComponentPool.unregisterResourcePool();
                };
                ResourcePoolManager.pTypedResourseTotal = [
                    13 /* TOTAL_VIDEO_RESOURCES */ , 
                    0 /* TOTAL_AUDIO_RESOURCES */ , 
                    0 /* TOTAL_GAME_RESOURCES */ 
                ];
                return ResourcePoolManager;
            })();
            pool.ResourcePoolManager = ResourcePoolManager;            
        })(core.pool || (core.pool = {}));
        var pool = core.pool;
    })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
;
var akra;
(function (akra) {
    (function (geometry) {
        var Sphere = (function () {
            function /** @no-inline */Sphere(fCenterX, fCenterY, fCenterZ, fRadius) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        var pSphere = arguments[0];
                        this.center = new akra.Vec3(pSphere.v3fCenter);
                        this.radius = pSphere.fRadius;
                        break;
                    case 2:
                        var v3fCenter = arguments[0];
                        var fRadius = arguments[1];
                        this.center = new akra.Vec3(v3fCenter);
                        this.radius = fRadius;
                        break;
                    case 4:
                        this.center = new akra.Vec3(arguments[0], arguments[1], arguments[2]);
                        this.radius = arguments[3];
                        break;
                    default:
                        this.center = new akra.Vec3();
                        this.radius = 0.;
                        break;
                }
            }
            Object.defineProperty(Sphere.prototype, "circle", {
                get: function /** @no-inline */() {
                    var v3fCenter = this.center;
                    return new geometry.Circle(v3fCenter.x, v3fCenter.y, this.radius);
                },
                set: function /** @no-inline */(pCircle) {
                    var v3fCenter = this.center;
                    var v2fCircleCenter = pCircle.center;
                    v3fCenter.x = v2fCircleCenter.x;
                    v3fCenter.y = v2fCircleCenter.y;
                    this.radius = pCircle.radius;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Sphere.prototype, "z", {
                get: function /** @no-inline */() {
                    return this.center.z;
                },
                set: function /** @no-inline */(fZ) {
                    this.center.z = fZ;
                },
                enumerable: true,
                configurable: true
            });
            Sphere.prototype.set = function /** @no-inline */(fCenterX, fCenterY, fCenterZ, fRadius) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        var pSphere = arguments[0];
                        this.center.set(pSphere.center);
                        this.radius = pSphere.radius;
                        break;
                    case 2:
                        var v3fCenter = arguments[0];
                        var fRadius = arguments[1];
                        this.center.set(v3fCenter);
                        this.radius = fRadius;
                        break;
                    case 4:
                        this.center.set(arguments[0], arguments[1], arguments[2]);
                        this.radius = arguments[3];
                        break;
                    default:
                        this.center.set(0.);
                        this.radius = 0.;
                        break;
                }
                return this;
            };
            Sphere.prototype.clear = function /** @inline */() {
                this.center.clear();
                this.radius = 0.;
                return this;
            };
            Sphere.prototype.isEqual = function /** @inline */(pSphere) {
                return this.center.isEqual(pSphere.center) && (this.radius == pSphere.radius);
            };
            Sphere.prototype.isClear = function /** @inline */() {
                return this.center.isClear() && (this.radius === 0.);
            };
            Sphere.prototype.isValid = function /** @inline */() {
                return (this.radius >= 0.);
            };
            Sphere.prototype.offset = function /** @inline */(v3fOffset) {
                this.center.add(v3fOffset);
                return this;
            };
            Sphere.prototype.expand = function /** @inline */(fInc) {
                this.radius += fInc;
                return this;
            };
            Sphere.prototype.normalize = function /** @inline */() {
                this.radius = akra.math.abs(this.radius);
                return this;
            };
            Sphere.prototype.transform = function /** @no-inline */(m4fMatrix) {
                akra.logger.setSourceLocation("Sphere.ts", 133);
                akra.logger.criticalError("TODO: transform() for Sphere similar to Rect3d::transform();");
                ;
                return this;
            };
            return Sphere;
        })();
        geometry.Sphere = Sphere;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (geometry) {
        var Rect3d = (function () {
            function /** @no-inline */Rect3d(fX0, fX1, fY0, fY1, fZ0, fZ1) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 2:
                        this.set(arguments[0], arguments[1]);
                        break;
                    case 3:
                        this.set(arguments[0], arguments[1], arguments[2]);
                        break;
                    case 6:
                        this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                        break;
                    default:
                        this.x0 = this.x1 = this.y0 = this.y1 = this.z0 = this.z1 = 0.;
                        break;
                }
            }
            Object.defineProperty(Rect3d.prototype, "rect2d", {
                get: function /** @no-inline */() {
                    return new geometry.Rect2d(this.x0, this.x1, this.y0, this.y1);
                },
                set: function /** @no-inline */(pRect) {
                    this.x0 = pRect.x0;
                    this.x1 = pRect.x1;
                    this.y0 = pRect.y0;
                    this.y1 = pRect.y1;
                },
                enumerable: true,
                configurable: true
            });
            Rect3d.prototype.set = function /** @no-inline */(fX0, fX1, fY0, fY1, fZ0, fZ1) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        if(arguments[0] instanceof Rect3d) {
                            var pRect = arguments[0];
                            this.x0 = pRect.x0;
                            this.x1 = pRect.x1;
                            this.y0 = pRect.y0;
                            this.y1 = pRect.y1;
                            this.z0 = pRect.z0;
                            this.z1 = pRect.z1;
                        } else {
                            var v3fSize = arguments[0];
                            this.x1 = v3fSize.x * 0.5;
                            this.x0 = -this.x1;
                            this.y1 = v3fSize.y * 0.5;
                            this.y0 = -this.y1;
                            this.z1 = v3fSize.z * 0.5;
                            this.z0 = -this.z1;
                        }
                        break;
                    case 2:
                        var v3fMinPoint = arguments[0];
                        var v3fMaxPoint = arguments[1];
                        this.x0 = v3fMinPoint.x;
                        this.y0 = v3fMinPoint.y;
                        this.z0 = v3fMinPoint.z;
                        this.x1 = v3fMaxPoint.x;
                        this.y1 = v3fMaxPoint.y;
                        this.z1 = v3fMaxPoint.z;
                        break;
                    case 3:
                        var fSizeX = arguments[0];
                        var fSizeY = arguments[1];
                        var fSizeZ = arguments[2];
                        this.x1 = fSizeX * 0.5;
                        this.x0 = -this.x1;
                        this.y1 = fSizeY * 0.5;
                        this.y0 = -this.y1;
                        this.z1 = fSizeZ * 0.5;
                        this.z0 = -this.z1;
                        break;
                    case 6:
                        this.x0 = arguments[0];
                        this.x1 = arguments[1];
                        this.y0 = arguments[2];
                        this.y1 = arguments[3];
                        this.z0 = arguments[4];
                        this.z1 = arguments[5];
                        break;
                    default:
                        this.x0 = this.x1 = this.y0 = this.y1 = this.z0 = this.z1 = 0.;
                        break;
                }
                return this;
            };
            Rect3d.prototype.setFloor = function /** @no-inline */(pRect) {
                this.x0 = akra.math.floor(pRect.x0);
                this.x1 = akra.math.floor(pRect.x1);
                this.y0 = akra.math.floor(pRect.y0);
                this.y1 = akra.math.floor(pRect.y1);
                this.z0 = akra.math.floor(pRect.z0);
                this.z1 = akra.math.floor(pRect.z1);
                return this;
            };
            Rect3d.prototype.setCeil = function /** @no-inline */(pRect) {
                this.x0 = akra.math.ceil(pRect.x0);
                this.x1 = akra.math.ceil(pRect.x1);
                this.y0 = akra.math.ceil(pRect.y0);
                this.y1 = akra.math.ceil(pRect.y1);
                this.z0 = akra.math.ceil(pRect.z0);
                this.z1 = akra.math.ceil(pRect.z1);
                return this;
            };
            Rect3d.prototype.clear = function /** @inline */() {
                this.x0 = this.x1 = this.y0 = this.y1 = this.z0 = this.z1 = 0.;
                return this;
            };
            Rect3d.prototype.addSelf = function /** @no-inline */(v3fVec) {
                if(akra.isFloat(arguments[0])) {
                    var fValue = arguments[0];
                    this.x0 += fValue;
                    this.x1 += fValue;
                    this.y0 += fValue;
                    this.y1 += fValue;
                    this.z0 += fValue;
                    this.z1 += fValue;
                } else {
                    var v3fVec = arguments[0];
                    this.x0 += v3fVec.x;
                    this.x1 += v3fVec.x;
                    this.y0 += v3fVec.y;
                    this.y1 += v3fVec.y;
                    this.z0 += v3fVec.z;
                    this.z1 += v3fVec.z;
                }
                return this;
            };
            Rect3d.prototype.subSelf = function /** @no-inline */(v3fVec) {
                if(akra.isFloat(arguments[0])) {
                    var fValue = arguments[0];
                    this.x0 -= fValue;
                    this.x1 -= fValue;
                    this.y0 -= fValue;
                    this.y1 -= fValue;
                    this.z0 -= fValue;
                    this.z1 -= fValue;
                } else {
                    var v3fVec = arguments[0];
                    this.x0 -= v3fVec.x;
                    this.x1 -= v3fVec.x;
                    this.y0 -= v3fVec.y;
                    this.y1 -= v3fVec.y;
                    this.z0 -= v3fVec.z;
                    this.z1 -= v3fVec.z;
                }
                return this;
            };
            Rect3d.prototype.multSelf = function /** @no-inline */(v3fVec) {
                if(akra.isFloat(arguments[0])) {
                    var fValue = arguments[0];
                    this.x0 *= fValue;
                    this.x1 *= fValue;
                    this.y0 *= fValue;
                    this.y1 *= fValue;
                    this.z0 *= fValue;
                    this.z1 *= fValue;
                } else {
                    var v3fVec = arguments[0];
                    this.x0 *= v3fVec.x;
                    this.x1 *= v3fVec.x;
                    this.y0 *= v3fVec.y;
                    this.y1 *= v3fVec.y;
                    this.z0 *= v3fVec.z;
                    this.z1 *= v3fVec.z;
                }
                return this;
            };
            Rect3d.prototype.divSelf = function /** @no-inline */(v3fVec) {
                if(akra.isFloat(arguments[0])) {
                    var fValue = arguments[0];
                    akra.logger.setSourceLocation("geometry/Rect3d.ts", 261);
                    akra.logger.assert(fValue != 0.0, "divide by zero error");
                    ;
                    var fInvValue = 1. / fValue;
                    this.x0 *= fInvValue;
                    this.x1 *= fInvValue;
                    this.y0 *= fInvValue;
                    this.y1 *= fInvValue;
                    this.z0 *= fInvValue;
                    this.z1 *= fInvValue;
                } else {
                    var v3fVec = arguments[0];
                    akra.logger.setSourceLocation("geometry/Rect3d.ts", 275);
                    akra.logger.assert(v3fVec.x != 0.0, "divide by zero error");
                    ;
                    akra.logger.setSourceLocation("geometry/Rect3d.ts", 276);
                    akra.logger.assert(v3fVec.y != 0.0, "divide by zero error");
                    ;
                    akra.logger.setSourceLocation("geometry/Rect3d.ts", 277);
                    akra.logger.assert(v3fVec.z != 0.0, "divide by zero error");
                    ;
                    var fInvX = 1. / v3fVec.x;
                    var fInvY = 1. / v3fVec.y;
                    var fInvZ = 1. / v3fVec.z;
                    this.x0 *= fInvX;
                    this.x1 *= fInvX;
                    this.y0 *= fInvY;
                    this.y1 *= fInvY;
                    this.z0 *= fInvZ;
                    this.z1 *= fInvZ;
                }
                return this;
            };
            Rect3d.prototype.offset = function /** @no-inline */(fOffsetX, fOffsetY, fOffsetZ) {
                if(arguments.length === 1) {
                    var v3fOffset = arguments[0];
                    this.x0 += v3fOffset.x;
                    this.x1 += v3fOffset.x;
                    this.y0 += v3fOffset.y;
                    this.y1 += v3fOffset.y;
                    this.z0 += v3fOffset.z;
                    this.z1 += v3fOffset.z;
                } else {
                    this.x0 += arguments[0];
                    this.x1 += arguments[0];
                    this.y0 += arguments[1];
                    this.y1 += arguments[1];
                    this.z0 += arguments[2];
                    this.z1 += arguments[2];
                }
                return this;
            };
            Rect3d.prototype.expand = function /** @no-inline */(fValueX, fValueY, fValueZ) {
                if(arguments.length === 1) {
                    if(akra.isFloat(arguments[0])) {
                        var fValue = arguments[0];
                        this.x0 -= fValue;
                        this.x1 += fValue;
                        this.y0 -= fValue;
                        this.y1 += fValue;
                        this.z0 -= fValue;
                        this.z1 += fValue;
                    } else {
                        var v3fVec = arguments[0];
                        this.x0 -= v3fVec.x;
                        this.x1 += v3fVec.x;
                        this.y0 -= v3fVec.y;
                        this.y1 += v3fVec.y;
                        this.z0 -= v3fVec.z;
                        this.z1 += v3fVec.z;
                    }
                } else {
                    //arguments.length === 3
                    this.x0 -= arguments[0];
                    this.x1 += arguments[0];
                    this.y0 -= arguments[1];
                    this.y1 += arguments[1];
                    this.z0 -= arguments[2];
                    this.z1 += arguments[2];
                }
                return this;
            };
            Rect3d.prototype.expandX = function /** @inline */(fValue) {
                this.x0 -= fValue;
                this.x1 += fValue;
                return this;
            };
            Rect3d.prototype.expandY = function /** @inline */(fValue) {
                this.y0 -= fValue;
                this.y1 += fValue;
                return this;
            };
            Rect3d.prototype.expandZ = function /** @inline */(fValue) {
                this.z0 -= fValue;
                this.z1 += fValue;
                return this;
            };
            Rect3d.prototype.resize = function /** @no-inline */(fSizeX, fSizeY, fSizeZ) {
                var fSizeX, fSizeY, fSizeZ;
                if(arguments.length === 1) {
                    var v3fSize = arguments[0];
                    fSizeX = v3fSize.x;
                    fSizeY = v3fSize.y;
                    fSizeZ = v3fSize.z;
                } else {
                    fSizeX = arguments[0];
                    fSizeY = arguments[1];
                    fSizeZ = arguments[2];
                }
                this.x1 = (this.x0 + this.x1 + fSizeX) * 0.5;
                this.x0 = this.x1 - fSizeX;
                this.y1 = (this.y0 + this.y1 + fSizeY) * 0.5;
                this.y0 = this.y1 - fSizeY;
                this.z1 = (this.z0 + this.z1 + fSizeZ) * 0.5;
                this.z0 = this.z1 - fSizeZ;
                return this;
            };
            Rect3d.prototype.resizeX = function /** @inline */(fSize) {
                this.x1 = (this.x0 + this.x1 + fSize) * 0.5;
                this.x0 = this.x1 - fSize;
                return this;
            };
            Rect3d.prototype.resizeY = function /** @inline */(fSize) {
                this.y1 = (this.y0 + this.y1 + fSize) * 0.5;
                this.y0 = this.y1 - fSize;
                return this;
            };
            Rect3d.prototype.resizeZ = function /** @inline */(fSize) {
                this.z1 = (this.z0 + this.z1 + fSize) * 0.5;
                this.z0 = this.z1 - fSize;
                return this;
            };
            Rect3d.prototype.resizeMax = function /** @no-inline */(fSpanX, fSpanY, fSpanZ) {
                if(arguments.length === 1) {
                    var v3fSpan = arguments[0];
                    this.x1 = this.x0 + v3fSpan.x;
                    this.y1 = this.y0 + v3fSpan.y;
                    this.z1 = this.z0 + v3fSpan.z;
                } else {
                    //arguments.length === 3
                    this.x1 = this.x0 + arguments[0];
                    this.y1 = this.y0 + arguments[1];
                    this.z1 = this.z0 + arguments[2];
                }
                return this;
            };
            Rect3d.prototype.resizeMaxX = function /** @inline */(fSpan) {
                this.x1 = this.x0 + fSpan;
                return this;
            };
            Rect3d.prototype.resizeMaxY = function /** @inline */(fSpan) {
                this.y1 = this.y0 + fSpan;
                return this;
            };
            Rect3d.prototype.resizeMaxZ = function /** @inline */(fSpan) {
                this.z1 = this.z0 + fSpan;
                return this;
            };
            Rect3d.prototype.resizeMin = function /** @no-inline */(fSpanX, fSpanY, fSpanZ) {
                if(arguments.length === 1) {
                    var v3fSpan = arguments[0];
                    this.x0 = this.x1 - v3fSpan.x;
                    this.y0 = this.y1 - v3fSpan.y;
                    this.z0 = this.z1 - v3fSpan.z;
                } else {
                    //arguments.length === 3
                    this.x0 = this.x1 - arguments[0];
                    this.y0 = this.y1 - arguments[1];
                    this.z0 = this.z1 - arguments[2];
                }
                return this;
            };
            Rect3d.prototype.resizeMinX = function /** @inline */(fSpan) {
                this.x0 = this.x1 - fSpan;
                return this;
            };
            Rect3d.prototype.resizeMinY = function /** @inline */(fSpan) {
                this.y0 = this.y1 - fSpan;
                return this;
            };
            Rect3d.prototype.resizeMinZ = function /** @inline */(fSpan) {
                this.z0 = this.z1 - fSpan;
                return this;
            };
            Rect3d.prototype.unionPoint = function /** @no-inline */(fX, fY, fZ) {
                if(arguments.length === 1) {
                    var v3fPoint = arguments[0];
                    this.x0 = akra.math.min(this.x0, v3fPoint.x);
                    this.x1 = akra.math.max(this.x1, v3fPoint.x);
                    this.y0 = akra.math.min(this.y0, v3fPoint.y);
                    this.y1 = akra.math.max(this.y1, v3fPoint.y);
                    this.z0 = akra.math.min(this.z0, v3fPoint.z);
                    this.z1 = akra.math.max(this.z1, v3fPoint.z);
                } else {
                    //arguments.length === 3
                    this.x0 = akra.math.min(this.x0, arguments[0]);
                    this.x1 = akra.math.max(this.x1, arguments[0]);
                    this.y0 = akra.math.min(this.y0, arguments[1]);
                    this.y1 = akra.math.max(this.y1, arguments[1]);
                    this.z0 = akra.math.min(this.z0, arguments[2]);
                    this.z1 = akra.math.max(this.z1, arguments[2]);
                }
                return this;
            };
            Rect3d.prototype.unionRect = function /** @no-inline */(pRect) {
                console.log(this, pRect);
                this.normalize();
                pRect.normalize();
                this.x0 = akra.math.min(this.x0, pRect.x0);
                this.x1 = akra.math.max(this.x1, pRect.x1);
                this.y0 = akra.math.min(this.y0, pRect.y0);
                this.y1 = akra.math.max(this.y1, pRect.y1);
                this.z0 = akra.math.min(this.z0, pRect.z0);
                this.z1 = akra.math.max(this.z1, pRect.z1);
                return this;
            };
            Rect3d.prototype.negate = function /** @no-inline */(pDestination) {
                if(!akra.isDef(pDestination)) {
                    pDestination = this;
                }
                return pDestination.set(-this.x1, -this.x0, -this.y1, -this.y0, -this.z1, -this.z0);
            };
            Rect3d.prototype.normalize = function /** @no-inline */() {
                var fTmp;
                if(this.x0 > this.x1) {
                    fTmp = this.x0;
                    this.x0 = this.x1;
                    this.x1 = fTmp;
                }
                if(this.y0 > this.y1) {
                    fTmp = this.y0;
                    this.y0 = this.y1;
                    this.y1 = fTmp;
                }
                if(this.z0 > this.z1) {
                    fTmp = this.z0;
                    this.z0 = this.z1;
                    this.z1 = fTmp;
                }
                return this;
            };
            Rect3d.prototype.transform = function /** @no-inline */(m4fMatrix) {
                var pData = m4fMatrix.data;
                var a11 = pData[0], a12 = pData[4], a13 = pData[8], a14 = pData[12];
                var a21 = pData[1], a22 = pData[5], a23 = pData[9], a24 = pData[13];
                var a31 = pData[2], a32 = pData[6], a33 = pData[10], a34 = pData[14];
                var fX0 = this.x0, fX1 = this.x1;
                var fY0 = this.y0, fY1 = this.y1;
                var fZ0 = this.z0, fZ1 = this.z1;
                //base point
                var fBaseX = a11 * fX0 + a12 * fY0 + a13 * fZ0 + a14;
                var fBaseY = a21 * fX0 + a22 * fY0 + a23 * fZ0 + a24;
                var fBaseZ = a31 * fX0 + a32 * fY0 + a33 * fZ0 + a34;
                //new x vector
                var fXNewX = a11 * (fX1 - fX0);
                var fXNewY = a21 * (fX1 - fX0);
                var fXNewZ = a31 * (fX1 - fX0);
                //new y vector
                var fYNewX = a12 * (fY1 - fY0);
                var fYNewY = a22 * (fY1 - fY0);
                var fYNewZ = a32 * (fY1 - fY0);
                //new z vector
                var fZNewX = a13 * (fZ1 - fZ0);
                var fZNewY = a23 * (fZ1 - fZ0);
                var fZNewZ = a33 * (fZ1 - fZ0);
                var fXMultX = (fXNewX > 0.) ? 1. : 0.;
                var fYMultX = (fYNewX > 0.) ? 1. : 0.;
                var fZMultX = (fZNewX > 0.) ? 1. : 0.;
                var fXMultY = (fXNewY > 0.) ? 1. : 0.;
                var fYMultY = (fYNewY > 0.) ? 1. : 0.;
                var fZMultY = (fZNewY > 0.) ? 1. : 0.;
                var fXMultZ = (fXNewZ > 0.) ? 1. : 0.;
                var fYMultZ = (fYNewZ > 0.) ? 1. : 0.;
                var fZMultZ = (fZNewZ > 0.) ? 1. : 0.;
                this.x1 = fBaseX + fXMultX * fXNewX + fYMultX * fYNewX + fZMultX * fZNewX;
                this.y1 = fBaseY + fXMultY * fXNewY + fYMultY * fYNewY + fZMultY * fZNewY;
                this.z1 = fBaseZ + fXMultZ * fXNewZ + fYMultZ * fYNewZ + fZMultZ * fZNewZ;
                this.x0 = fBaseX + (1. - fXMultX) * fXNewX + (1. - fYMultX) * fYNewX + (1. - fZMultX) * fZNewX;
                this.y0 = fBaseY + (1. - fXMultY) * fXNewY + (1. - fYMultY) * fYNewY + (1. - fZMultY) * fZNewY;
                this.z0 = fBaseZ + (1. - fXMultZ) * fXNewZ + (1. - fYMultZ) * fYNewZ + (1. - fZMultZ) * fZNewZ;
                return this;
            };
            Rect3d.prototype.isEqual = function /** @inline */(pRect) {
                return this.x0 == pRect.x0 && this.x1 == pRect.x1 && this.y0 == pRect.y0 && this.y1 == pRect.y1 && this.z0 == pRect.z0 && this.z1 == pRect.z1;
            };
            Rect3d.prototype.isClear = function /** @inline */() {
                return this.x0 == 0. && this.x1 == 0. && this.y0 == 0. && this.y1 == 0. && this.z0 == 0. && this.z1 == 0.;
            };
            Rect3d.prototype.isValid = function /** @inline */() {
                return this.x0 <= this.x1 && this.y0 <= this.y1 && this.z0 <= this.z1;
            };
            Rect3d.prototype.isPointInRect = function /** @inline */(v3fPoint) {
                var x = v3fPoint.x;
                var y = v3fPoint.y;
                var z = v3fPoint.z;
                return (this.x0 <= x && x <= this.x1) && (this.y0 <= y && y <= this.y1) && (this.z0 <= z && z <= this.z1);
            };
            Rect3d.prototype.midPoint = function /** @no-inline */(v3fDestination) {
                if(!akra.isDef(v3fDestination)) {
                    v3fDestination = new akra.Vec3();
                }
                return v3fDestination.set((this.x0 + this.x1) * 0.5, (this.y0 + this.y1) * 0.5, (this.z0 + this.z1) * 0.5);
            };
            Rect3d.prototype.midX = function /** @inline */() {
                return (this.x0 + this.x1) * 0.5;
            };
            Rect3d.prototype.midY = function /** @inline */() {
                return (this.y0 + this.y1) * 0.5;
            };
            Rect3d.prototype.midZ = function /** @inline */() {
                return (this.z0 + this.z1) * 0.5;
            };
            Rect3d.prototype.size = function /** @no-inline */(v3fDestination) {
                if(!akra.isDef(v3fDestination)) {
                    v3fDestination = new akra.Vec3();
                }
                return v3fDestination.set(this.x1 - this.x0, this.y1 - this.y0, this.z1 - this.z0);
            };
            Rect3d.prototype.sizeX = function /** @inline */() {
                return this.x1 - this.x0;
            };
            Rect3d.prototype.sizeY = function /** @inline */() {
                return this.y1 - this.y0;
            };
            Rect3d.prototype.sizeZ = function /** @inline */() {
                return this.z1 - this.z0;
            };
            Rect3d.prototype.minPoint = function /** @no-inline */(v3fDestination) {
                if(!akra.isDef(v3fDestination)) {
                    v3fDestination = new akra.Vec3();
                }
                return v3fDestination.set(this.x0, this.y0, this.z0);
            };
            Rect3d.prototype.maxPoint = function /** @no-inline */(v3fDestination) {
                if(!akra.isDef(v3fDestination)) {
                    v3fDestination = new akra.Vec3();
                }
                return v3fDestination.set(this.x1, this.y1, this.z1);
            };
            Rect3d.prototype.volume = function /** @inline */() {
                return (this.x1 - this.x0) * (this.y1 - this.y0) * (this.z1 - this.z0);
            };
            Rect3d.prototype.corner = /**
            * counter-clockwise and from bottom
            * x0,y0,z0 -> x1,y0,z0 -> x1,y1,z0 -> x0,y1,z0 ->
            * x0,y0,z1 -> x1,y0,z1 -> x1,y1,z1 -> x0,y1,z1
            */
            function /** @no-inline */(iIndex, v3fDestination) {
                if(!akra.isDef(v3fDestination)) {
                    v3fDestination = new akra.Vec3();
                }
                akra.logger.setSourceLocation("geometry/Rect3d.ts", 753);
                akra.logger.assert(0 <= iIndex && iIndex < 8, "invalid index");
                ;
                switch(iIndex) {
                    case 0:
                        v3fDestination.set(this.x0, this.y0, this.z0);
                        break;
                    case 1:
                        v3fDestination.set(this.x1, this.y0, this.z0);
                        break;
                    case 2:
                        v3fDestination.set(this.x1, this.y1, this.z0);
                        break;
                    case 3:
                        v3fDestination.set(this.x0, this.y1, this.z0);
                        break;
                    case 4:
                        v3fDestination.set(this.x0, this.y0, this.z1);
                        break;
                    case 5:
                        v3fDestination.set(this.x1, this.y0, this.z1);
                        break;
                    case 6:
                        v3fDestination.set(this.x1, this.y1, this.z1);
                        break;
                    case 7:
                        v3fDestination.set(this.x0, this.y1, this.z1);
                        break;
                }
                return v3fDestination;
            };
            Rect3d.prototype.createBoundingSphere = function /** @no-inline */(pSphere) {
                if(!akra.isDef(pSphere)) {
                    pSphere = new geometry.Sphere();
                }
                var fX0 = this.x0, fX1 = this.x1;
                var fY0 = this.y0, fY1 = this.y1;
                var fZ0 = this.z0, fZ1 = this.z1;
                var fHalfSizeX = (fX1 - fX0) * 0.5;
                var fHalfSizeY = (fY1 - fY0) * 0.5;
                var fHalfSizeZ = (fZ1 - fZ0) * 0.5;
                pSphere.set((fX0 + fX1) * 0.5, (fY0 + fY1) * 0.5, (fZ0 + fZ1) * 0.5, akra.math.sqrt(fHalfSizeX * fHalfSizeX + fHalfSizeY * fHalfSizeY + fHalfSizeZ * fHalfSizeZ));
                return pSphere;
            };
            Rect3d.prototype.toString = function /** @no-inline */() {
                return "(" + this.x0 + ", " + this.y0 + ", " + this.z0 + ") --> (" + this.x1 + ", " + this.y1 + ", " + this.z1 + ")";
            };
            Object.defineProperty(Rect3d, "stackCeil", {
                get: function /** @no-inline */() {
                    Rect3d.stackPosition = Rect3d.stackPosition === Rect3d.stackSize - 1 ? 0 : Rect3d.stackPosition;
                    return Rect3d.stack[Rect3d.stackPosition++];
                },
                enumerable: true,
                configurable: true
            });
            Rect3d.stackSize = 128;
            Rect3d.stackPosition = 0;
            Rect3d.stack = (function /** @no-inline */() {
                var pStack = new Array(Rect3d.stackSize);
                for(var i = 0; i < Rect3d.stackSize; i++) {
                    pStack[i] = new Rect3d();
                }
                return pStack;
            })();
            return Rect3d;
        })();
        geometry.Rect3d = Rect3d;        
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        (function (ESceneObjectFlags) {
            ESceneObjectFlags._map = [];
            ESceneObjectFlags.k_NewLocalBounds = 0;
            ESceneObjectFlags._map[1] = "k_NewWorldBounds";
            ESceneObjectFlags.k_NewWorldBounds = 1;
        })(scene.ESceneObjectFlags || (scene.ESceneObjectFlags = {}));
        var ESceneObjectFlags = scene.ESceneObjectFlags;
        ;
        var SceneObject = (function (_super) {
            __extends(SceneObject, _super);
            function /** @no-inline */SceneObject(pScene) {
                        _super.call(this, pScene);
                /**@protected*/ this._iObjectFlags = 0;
                /**@protected*/ this._pLocalBounds = new akra.geometry.Rect3d();
                /**@protected*/ this._pWorldBounds = new akra.geometry.Rect3d();
                /**@protected*/ this._hasShadows = false;
                this._iGuid = eval("this._iGuid || akra.sid()");
                this._pUnicastSlotMap = null;
                this._pBroadcastSlotList = null;
                this._eType = 64 /* SCENE_OBJECT */ ;
            }
            Object.defineProperty(SceneObject.prototype, "totalRenderable", {
                get: function /** @inline */() {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SceneObject.prototype, "worldBounds", {
                get: function /** @inline */() {
                    return this._pWorldBounds;
                },
                set: function /** @inline */(pBox) {
                    this._pWorldBounds = pBox;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SceneObject.prototype, "localBounds", {
                get: function /** @inline */() {
                    return this._pLocalBounds;
                },
                enumerable: true,
                configurable: true
            });
            SceneObject.prototype.getRenderable = function /** @inline */(i) {
                return null;
            };
            SceneObject.prototype.accessLocalBounds = function /** @no-inline */() {
                ((this._iObjectFlags) |= (1 << (0 /* k_NewLocalBounds */ )));
                return this._pLocalBounds;
            };
            SceneObject.prototype.isWorldBoundsNew = function /** @inline */() {
                return ((this._iObjectFlags & (1 << (0 /* k_NewLocalBounds */ ))) != 0);
            };
            SceneObject.prototype.destroy = function /** @no-inline */() {
                _super.prototype.destroy.call(this);
            };
            SceneObject.prototype.prepareForUpdate = function /** @no-inline */() {
                _super.prototype.prepareForUpdate.call(this);
                ((this._iObjectFlags) &= ~((1 << (0 /* k_NewLocalBounds */ )) | (1 << (1 /* k_NewWorldBounds */ ))));
            };
            SceneObject.prototype.update = function /** @no-inline */() {
                //если, обновится мировая матрица узла, то и AABB обновится
                _super.prototype.update.call(this);
                // do we need to update our local matrix?
                // derived classes update the local matrix
                // then call this base function to complete
                // the update
                return this.recalcWorldBounds();
            };
            SceneObject.prototype.recalcWorldBounds = function /** @no-inline */() {
                // nodes only get their bounds updated
                // as nessesary
                if(((this._iObjectFlags & (1 << (0 /* k_NewLocalBounds */ ))) != 0) || this.isWorldMatrixNew()) {
                    // transform our local rectangle
                    // by the current world matrix
                    this._pWorldBounds.set(this._pLocalBounds);
                    // make sure we have some degree of thickness
                    if(true) {
                        this._pWorldBounds.x1 = Math.max(this._pWorldBounds.x1, this._pWorldBounds.x0 + 0.01);
                        this._pWorldBounds.y1 = Math.max(this._pWorldBounds.y1, this._pWorldBounds.y0 + 0.01);
                        this._pWorldBounds.z1 = Math.max(this._pWorldBounds.z1, this._pWorldBounds.z0 + 0.01);
                    }
                    this._pWorldBounds.transform(this.worldMatrix);
                    // set the flag that our bounding box has changed
                    ((this._iObjectFlags) |= (1 << (1 /* k_NewWorldBounds */ )));
                    this.worldBoundsUpdated();
                    return true;
                }
                return false;
            };
            Object.defineProperty(SceneObject.prototype, "hasShadows", {
                get: function /** @inline */() {
                    return this._hasShadows;
                },
                set: function /** @inline */(bValue) {
                    this._hasShadows = bValue;
                },
                enumerable: true,
                configurable: true
            });
            SceneObject.prototype.getObjectFlags = function /** @no-inline */() {
                return this._iObjectFlags;
            };
            SceneObject.prototype.toString = function /** @no-inline */(isRecursive, iDepth) {
                if (typeof isRecursive === "undefined") { isRecursive = false; }
                if (typeof iDepth === "undefined") { iDepth = 0; }
                if(!isRecursive) {
                    return "<scene_object" + (this._sName ? " " + this._sName : "") + ">";
                }
                return _super.prototype.toString.call(this, isRecursive, iDepth);
            };
            SceneObject._pEventTable = new akra.events.EventTable();
            SceneObject.prototype.getEventTable = function /** @inline */() {
                return SceneObject._pEventTable;
            };
            SceneObject.prototype.getGuid = function /** @no-inline */() {
                return this._iGuid < 0 ? (this._iGuid = akra.sid()) : this._iGuid;
            };
            SceneObject.prototype.connect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            SceneObject.prototype.disconnect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            SceneObject.prototype.bind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType);
            };
            SceneObject.prototype.unbind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType);
            };
            SceneObject.prototype.worldBoundsUpdated = function /** @no-inline */() {
                var _recivier = this;
                this._pUnicastSlotMap = this._pUnicastSlotMap || this.getEventTable().findUnicastList(this._iGuid);
                var _unicast = (this._pUnicastSlotMap).worldBoundsUpdated;
                if(akra.isDef(_unicast)) {
                    _unicast.target ? _unicast.target[_unicast.callback](_recivier) : _unicast.listener(_recivier);
                }
            };
            return SceneObject;
        })(scene.SceneNode);
        scene.SceneObject = SceneObject;        
        function /** @inline */isSceneObject(pEntity) {
            return pEntity.type >= 64 /* SCENE_OBJECT */  && pEntity.type < 128 /* OBJECTS_LIMIT */ ;
        }
        scene.isSceneObject = isSceneObject;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (geometry) {
        var Plane3d = (function () {
            function /** @no-inline */Plane3d(v3fPoint1, v3fPoint2, v3fPoint3) {
                this.normal = new akra.Vec3();
                this.distance = 0.;
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 2:
                        this.set(arguments[0], arguments[1]);
                        break;
                    case 3:
                        this.set(arguments[0], arguments[1], arguments[2]);
                        break;
                    default:
                        break;
                }
            }
            Plane3d.prototype.set = function /** @no-inline */(v3fPoint1, v3fPoint2, v3fPoint3) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        var pPlane = arguments[0];
                        this.normal.set(pPlane.normal);
                        this.distance = pPlane.distance;
                        break;
                    case 2:
                        this.normal.set(arguments[0]);
                        this.distance = arguments[1];
                        break;
                    case 3:
                        var v3fPoint1 = arguments[0];
                        var v3fPoint2 = arguments[1];
                        var v3fPoint3 = arguments[2];
                        var x1 = v3fPoint2.x - v3fPoint1.x;
                        var y1 = v3fPoint2.y - v3fPoint1.y;
                        var z1 = v3fPoint2.z - v3fPoint1.z;
                        var x2 = v3fPoint3.x - v3fPoint1.x;
                        var y2 = v3fPoint3.y - v3fPoint1.y;
                        var z2 = v3fPoint3.z - v3fPoint1.z;
                        var x = y1 * z2 - y2 * z1;
                        var y = z1 * x2 - z2 * x1;
                        var z = x1 * y2 - x2 * y1;
                        this.distance = -(x * v3fPoint1.x + y * v3fPoint1.y + z * v3fPoint1.z);
                        this.normal.set(x, y, z);
                        break;
                    default:
                        this.normal.clear();
                        this.distance = 0.;
                        break;
                }
                return this.normalize();
            };
            Plane3d.prototype.clear = function /** @inline */() {
                this.normal.clear();
                this.distance = 0.;
                return this;
            };
            Plane3d.prototype.normalize = function /** @no-inline */() {
                var v3fNormal = this.normal;
                var x = v3fNormal.x, y = v3fNormal.y, z = v3fNormal.z;
                var fLength = akra.math.sqrt(x * x + y * y + z * z);
                if(fLength !== 0.) {
                    var fInvLength = 1. / fLength;
                    v3fNormal.x = x * fInvLength;
                    v3fNormal.y = y * fInvLength;
                    v3fNormal.z = z * fInvLength;
                    this.distance *= fInvLength;
                }
                return this;
            };
            Plane3d.prototype.isEqual = function /** @no-inline */(pPlane) {
                return this.normal.isEqual(pPlane.normal) && (this.distance == pPlane.distance);
            };
            Plane3d.prototype.projectPointToPlane = /*предполагается работа только с нормализованной плоскостью*/
            function /** @no-inline */(v3fPoint, v3fDestination) {
                if(!akra.isDef(v3fDestination)) {
                    v3fDestination = new akra.Vec3();
                }
                var v3fNormal = this.normal;
                var fDistance = this.distance + v3fNormal.dot(v3fPoint);
                v3fDestination.x = v3fPoint.x - fDistance * v3fNormal.x;
                v3fDestination.y = v3fPoint.y - fDistance * v3fNormal.y;
                v3fDestination.z = v3fPoint.z - fDistance * v3fNormal.z;
                return v3fDestination;
            };
            Plane3d.prototype.solveForX = function /** @no-inline */(fY, fZ) {
                /*Ax+By+Cz+D=0;
                x = -(D+By+Cz)/A;*/
                var v3fNormal = this.normal;
                if(v3fNormal.x !== 0.) {
                    return -(this.distance + v3fNormal.y * fY + v3fNormal.z * fZ) / v3fNormal.x;
                }
                return 0.;
            };
            Plane3d.prototype.solveForY = function /** @no-inline */(fX, fZ) {
                /*Ax+By+Cz+D=0;
                y = -(D+Ax+Cz)/B;*/
                var v3fNormal = this.normal;
                if(v3fNormal.y !== 0.) {
                    return -(this.distance + v3fNormal.x * fX + v3fNormal.z * fZ) / v3fNormal.y;
                }
                return 0.;
            };
            Plane3d.prototype.solveForZ = function /** @no-inline */(fX, fY) {
                /*Ax+By+Cz+D=0;
                z = -(D+Ax+By)/C;*/
                var v3fNormal = this.normal;
                if(v3fNormal.z !== 0.) {
                    return -(this.distance + v3fNormal.x * fX + v3fNormal.y * fY) / v3fNormal.z;
                }
                return 0.;
            };
            Plane3d.prototype.signedDistance = function /** @no-inline */(v3fPoint) {
                return this.distance + this.normal.dot(v3fPoint);
            };
            return Plane3d;
        })();
        geometry.Plane3d = Plane3d;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
;
var akra;
(function (akra) {
    (function (geometry) {
        var Plane2d = (function () {
            function /** @no-inline */Plane2d(v2fPoint1, v2fPoint2) {
                this.normal = new akra.Vec2();
                this.distance = 0.;
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 2:
                        this.set(arguments[0], arguments[1]);
                        break;
                    default:
                        break;
                }
            }
            Plane2d.prototype.set = function /** @no-inline */(v2fPoint1, v2fPoint2) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        var pPlane = arguments[0];
                        this.normal.set(pPlane.normal);
                        this.distance = pPlane.distance;
                        break;
                    case 2:
                        if(akra.isFloat(arguments[1])) {
                            this.normal.set(arguments[0]);
                            this.distance = arguments[1];
                        } else {
                            var v2fLine = akra.vec2(arguments[1]).subtract(arguments[0]);
                            var v2fNormal = this.normal;
                            v2fNormal.set(-v2fLine.y, v2fLine.x);
                            this.distance = -v2fNormal.dot(arguments[0]);
                        }
                        break;
                    default:
                        this.normal.clear();
                        this.distance = 0.;
                        break;
                }
                return this.normalize();
            };
            Plane2d.prototype.clear = function /** @inline */() {
                this.normal.clear();
                this.distance = 0.;
                return this;
            };
            Plane2d.prototype.normalize = function /** @no-inline */() {
                var v2fNormal = this.normal;
                var x = v2fNormal.x;
                var y = v2fNormal.y;
                var fLength = akra.math.sqrt(x * x + y * y);
                if(fLength !== 0.) {
                    var fInvLength = 1. / fLength;
                    v2fNormal.x = x * fInvLength;
                    v2fNormal.y = y * fInvLength;
                    this.distance = this.distance * fInvLength;
                }
                return this;
            };
            Plane2d.prototype.isEqual = function /** @inline */(pPlane) {
                return this.normal.isEqual(pPlane.normal) && (this.distance == pPlane.distance);
            };
            Plane2d.prototype.projectPointToPlane = /*предполагается работа только с нормализованной плоскостью*/
            function /** @no-inline */(v2fPoint, v2fDestination) {
                if(!akra.isDef(v2fDestination)) {
                    v2fDestination = new akra.Vec2();
                }
                var v2fNormal = this.normal;
                var fDistance = this.distance + v2fNormal.dot(v2fPoint);
                v2fDestination.x = v2fPoint.x - fDistance * v2fNormal.x;
                v2fDestination.y = v2fPoint.y - fDistance * v2fNormal.y;
                return v2fDestination;
            };
            Plane2d.prototype.solveForX = function /** @no-inline */(fY) {
                /*Ax+By+d=0;
                x=-(d+By)/A;*/
                var v2fNormal = this.normal;
                if(v2fNormal.x !== 0.) {
                    return -(this.distance + v2fNormal.y * fY) / v2fNormal.x;
                }
                return 0.;
            };
            Plane2d.prototype.solveForY = function /** @no-inline */(fX) {
                /*Ax+By+d=0;
                y=-(d+Ax)/B;*/
                var v2fNormal = this.normal;
                if(v2fNormal.y !== 0.) {
                    return -(this.distance + v2fNormal.x * fX) / v2fNormal.y;
                }
                return 0.;
            };
            Plane2d.prototype.signedDistance = /*предполагается работа только с нормализованной плоскостью*/
            function /** @inline */(v2fPoint) {
                return this.distance + this.normal.dot(v2fPoint);
            };
            return Plane2d;
        })();
        geometry.Plane2d = Plane2d;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EVolumeClassifications) {
        EVolumeClassifications._map = [];
        EVolumeClassifications.NO_RELATION = 0;
        EVolumeClassifications._map[1] = "EQUAL";
        EVolumeClassifications.EQUAL = 1;
        EVolumeClassifications._map[2] = "A_CONTAINS_B";
        EVolumeClassifications.A_CONTAINS_B = 2;
        EVolumeClassifications._map[3] = "B_CONTAINS_A";
        EVolumeClassifications.B_CONTAINS_A = 3;
        EVolumeClassifications._map[4] = "INTERSECTING";
        EVolumeClassifications.INTERSECTING = 4;
    })(akra.EVolumeClassifications || (akra.EVolumeClassifications = {}));
    var EVolumeClassifications = akra.EVolumeClassifications;
    ;
    (function (EPlaneClassifications) {
        EPlaneClassifications._map = [];
        /**
        * ax+by+cz+d=0
        * PLANE_FRONT - объект находится перед плоскостью, то есть по направлению нормали
        * PLANE_BACK - объект находится за плостостью, то есть против направления нормали
        */
        EPlaneClassifications.PLANE_FRONT = 0;
        EPlaneClassifications._map[1] = "PLANE_BACK";
        EPlaneClassifications.PLANE_BACK = 1;
        EPlaneClassifications._map[2] = "PLANE_INTERSECT";
        EPlaneClassifications.PLANE_INTERSECT = 2;
    })(akra.EPlaneClassifications || (akra.EPlaneClassifications = {}));
    var EPlaneClassifications = akra.EPlaneClassifications;
    ;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (geometry) {
        function /** @no-inline */planeClassifyCircle(pPlane, pCircle) {
            var fDistance = pPlane.signedDistance(pCircle.center);
            var fRadius = pCircle.radius;
            if(fDistance > fRadius) {
                return 0 /* PLANE_FRONT */ ;
            } else if(fDistance < -fRadius) {
                return 1 /* PLANE_BACK */ ;
            } else {
                return 2 /* PLANE_INTERSECT */ ;
            }
        }
        geometry.planeClassifyCircle = planeClassifyCircle;
        ;
        function /** @no-inline */planeClassifySphere(pPlane, pSphere) {
            var fDistance = pPlane.signedDistance(pSphere.center);
            var fRadius = pSphere.radius;
            if(fDistance > fRadius) {
                return 0 /* PLANE_FRONT */ ;
            } else if(fDistance < -fRadius) {
                return 1 /* PLANE_BACK */ ;
            } else {
                return 2 /* PLANE_INTERSECT */ ;
            }
        }
        geometry.planeClassifySphere = planeClassifySphere;
        ;
        function /** @no-inline */planeClassifyRect2d(pPlane, pRect) {
            var v2fMinPoint = akra.vec2();
            var v2fMaxPoint = akra.vec2();
            var v2fNormal = pPlane.normal;
            if(v2fNormal.x > 0.) {
                v2fMinPoint.x = pRect.x0;
                v2fMaxPoint.x = pRect.x1;
            } else {
                v2fMinPoint.x = pRect.x1;
                v2fMaxPoint.x = pRect.x0;
            }
            if(v2fNormal.y > 0.) {
                v2fMinPoint.y = pRect.y0;
                v2fMaxPoint.y = pRect.y1;
            } else {
                v2fMinPoint.y = pRect.y1;
                v2fMaxPoint.y = pRect.y0;
            }
            var fMinDistance = pPlane.signedDistance(v2fMinPoint);
            var fMaxDistance = pPlane.signedDistance(v2fMaxPoint);
            if(fMinDistance * fMaxDistance <= 0.) {
                return 2 /* PLANE_INTERSECT */ ;
            } else if(fMaxDistance < 0.) {
                return 1 /* PLANE_BACK */ ;
            } else {
                return 0 /* PLANE_FRONT */ ;
            }
        }
        geometry.planeClassifyRect2d = planeClassifyRect2d;
        ;
        function /** @no-inline */planeClassifyRect3d(pPlane, pRect) {
            var v3fMinPoint = akra.vec3();
            var v3fMaxPoint = akra.vec3();
            var v3fNormal = pPlane.normal;
            if(v3fNormal.x > 0.) {
                v3fMinPoint.x = pRect.x0;
                v3fMaxPoint.x = pRect.x1;
            } else {
                v3fMinPoint.x = pRect.x1;
                v3fMaxPoint.x = pRect.x0;
            }
            if(v3fNormal.y > 0.) {
                v3fMinPoint.y = pRect.y0;
                v3fMaxPoint.y = pRect.y1;
            } else {
                v3fMinPoint.y = pRect.y1;
                v3fMaxPoint.y = pRect.y0;
            }
            if(v3fNormal.z > 0.) {
                v3fMinPoint.z = pRect.z0;
                v3fMaxPoint.z = pRect.z1;
            } else {
                v3fMinPoint.z = pRect.z1;
                v3fMaxPoint.z = pRect.z0;
            }
            var fMinDistance = pPlane.signedDistance(v3fMinPoint);
            var fMaxDistance = pPlane.signedDistance(v3fMaxPoint);
            if(fMinDistance * fMaxDistance <= 0.) {
                return 2 /* PLANE_INTERSECT */ ;
            } else if(fMaxDistance < 0.) {
                return 1 /* PLANE_BACK */ ;
            } else {
                return 0 /* PLANE_FRONT */ ;
            }
        }
        geometry.planeClassifyRect3d = planeClassifyRect3d;
        ;
                                        function /** @no-inline */planeClassify(pPlane, pRect) {
            var pArg0 = arguments[0];
            var pArg1 = arguments[1];
            if(pArg0 instanceof geometry.Plane2d) {
                if(pArg1 instanceof geometry.Circle) {
                    return planeClassifyCircle(pArg0, pArg1);
                } else {
                    return planeClassifyRect2d(pArg0, pArg1);
                }
            } else {
                if(pArg1 instanceof geometry.Sphere) {
                    return planeClassifySphere(pArg0, pArg1);
                } else {
                    return planeClassifyRect3d(pArg0, pArg1);
                }
            }
        }
        geometry.planeClassify = planeClassify;
        ;
        function /** @no-inline */classifyRect2d(pRectA, pRectB) {
            var fRectAX0 = pRectA.x0, fRectAX1 = pRectA.x1;
            var fRectAY0 = pRectA.y0, fRectAY1 = pRectA.y1;
            var fRectBX0 = pRectB.x0, fRectBX1 = pRectB.x1;
            var fRectBY0 = pRectB.y0, fRectBY1 = pRectB.y1;
            if((fRectAX1 < fRectBX0 || fRectBX1 < fRectAX0) || (fRectAY1 < fRectBY0 || fRectAY1 < fRectBY0)) {
                return 0 /* NO_RELATION */ ;
            }
            if((fRectAX0 == fRectBX0 && fRectAX1 == fRectBX1) && (fRectAY0 == fRectBY0 && fRectAY1 == fRectBY1)) {
                return 1 /* EQUAL */ ;
            }
            if((fRectAX0 <= fRectBX0 && fRectBX1 <= fRectAX1) && (fRectAY0 <= fRectBY0 && fRectBY1 <= fRectAY1)) {
                return 2 /* A_CONTAINS_B */ ;
            }
            if((fRectBX0 <= fRectAX0 && fRectAX1 <= fRectBX1) && (fRectBY0 <= fRectAY0 && fRectAY1 <= fRectBY1)) {
                return 3 /* B_CONTAINS_A */ ;
            }
            return 4 /* INTERSECTING */ ;
        }
        geometry.classifyRect2d = classifyRect2d;
        ;
        function /** @no-inline */classifyRect3d(pRectA, pRectB) {
            var fRectAX0 = pRectA.x0, fRectAX1 = pRectA.x1;
            var fRectAY0 = pRectA.y0, fRectAY1 = pRectA.y1;
            var fRectAZ0 = pRectA.z0, fRectAZ1 = pRectA.z1;
            var fRectBX0 = pRectB.x0, fRectBX1 = pRectB.x1;
            var fRectBY0 = pRectB.y0, fRectBY1 = pRectB.y1;
            var fRectBZ0 = pRectB.z0, fRectBZ1 = pRectB.z1;
            if((fRectAX1 < fRectBX0 || fRectBX1 < fRectAX0) || (fRectAY1 < fRectBY0 || fRectAY1 < fRectBY0) || (fRectAZ1 < fRectBZ0 || fRectAZ1 < fRectBZ0)) {
                return 0 /* NO_RELATION */ ;
            }
            if((fRectAX0 == fRectBX0 && fRectAX1 == fRectBX1) && (fRectAY0 == fRectBY0 && fRectAY1 == fRectBY1) && (fRectAZ0 == fRectBZ0 && fRectAZ1 == fRectBZ1)) {
                return 1 /* EQUAL */ ;
            }
            if((fRectAX0 <= fRectBX0 && fRectBX1 <= fRectAX1) && (fRectAY0 <= fRectBY0 && fRectBY1 <= fRectAY1) && (fRectAZ0 <= fRectBZ0 && fRectBZ1 <= fRectAZ1)) {
                return 2 /* A_CONTAINS_B */ ;
            }
            if((fRectBX0 <= fRectAX0 && fRectAX1 <= fRectBX1) && (fRectBY0 <= fRectAY0 && fRectAY1 <= fRectBY1) && (fRectBZ0 <= fRectAZ0 && fRectAZ1 <= fRectBZ1)) {
                return 3 /* B_CONTAINS_A */ ;
            }
            return 4 /* INTERSECTING */ ;
        }
        geometry.classifyRect3d = classifyRect3d;
        ;
        function /** @no-inline */classifyFrustumRect3d(pFrustum, pRect) {
            var kClassification;
            var isIntersect = false;
            kClassification = planeClassifyRect3d(pFrustum.leftPlane, pRect);
            if(kClassification == 0 /* PLANE_FRONT */ ) {
                return 0 /* NO_RELATION */ ;
            } else if(kClassification == 2 /* PLANE_INTERSECT */ ) {
                isIntersect = true;
            }
            kClassification = planeClassifyRect3d(pFrustum.rightPlane, pRect);
            if(kClassification == 0 /* PLANE_FRONT */ ) {
                return 0 /* NO_RELATION */ ;
            } else if(kClassification == 2 /* PLANE_INTERSECT */ ) {
                isIntersect = true;
            }
            kClassification = planeClassifyRect3d(pFrustum.topPlane, pRect);
            if(kClassification == 0 /* PLANE_FRONT */ ) {
                return 0 /* NO_RELATION */ ;
            } else if(kClassification == 2 /* PLANE_INTERSECT */ ) {
                isIntersect = true;
            }
            kClassification = planeClassifyRect3d(pFrustum.bottomPlane, pRect);
            if(kClassification == 0 /* PLANE_FRONT */ ) {
                return 0 /* NO_RELATION */ ;
            } else if(kClassification == 2 /* PLANE_INTERSECT */ ) {
                isIntersect = true;
            }
            kClassification = planeClassifyRect3d(pFrustum.nearPlane, pRect);
            if(kClassification == 0 /* PLANE_FRONT */ ) {
                return 0 /* NO_RELATION */ ;
            } else if(kClassification == 2 /* PLANE_INTERSECT */ ) {
                isIntersect = true;
            }
            kClassification = planeClassifyRect3d(pFrustum.farPlane, pRect);
            if(kClassification == 0 /* PLANE_FRONT */ ) {
                return 0 /* NO_RELATION */ ;
            } else if(kClassification == 2 /* PLANE_INTERSECT */ ) {
                isIntersect = true;
            }
            if(isIntersect) {
                return 4 /* INTERSECTING */ ;
            } else {
                return 2 /* A_CONTAINS_B */ ;
            }
        }
        geometry.classifyFrustumRect3d = classifyFrustumRect3d;
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
;
var akra;
(function (akra) {
    (function (geometry) {
        var Frustum = (function () {
            function /** @no-inline */Frustum(pLeftPlane, pRightPlane, pTopPlane, pBottomPlane, pNearPlane, pFarPlane) {
                this._pFrustumVertices = null;
                this.leftPlane = new geometry.Plane3d();
                this.rightPlane = new geometry.Plane3d();
                this.topPlane = new geometry.Plane3d();
                this.bottomPlane = new geometry.Plane3d();
                this.nearPlane = new geometry.Plane3d();
                this.farPlane = new geometry.Plane3d();
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        this.set(arguments[0]);
                        break;
                    case 6:
                        this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                        break;
                    default:
                        break;
                }
            }
            Object.defineProperty(Frustum.prototype, "frustumVertices", {
                get: function /** @no-inline */() {
                    return this._pFrustumVertices;
                },
                enumerable: true,
                configurable: true
            });
            Frustum.prototype.set = function /** @no-inline */(pLeftPlane, pRightPlane, pTopPlane, pBottomPlane, pNearPlane, pFarPlane) {
                var nArgumentsLength = arguments.length;
                switch(nArgumentsLength) {
                    case 1:
                        var pFrustum = arguments[0];
                        this.leftPlane.set(pFrustum.leftPlane);
                        this.rightPlane.set(pFrustum.rightPlane);
                        this.topPlane.set(pFrustum.topPlane);
                        this.bottomPlane.set(pFrustum.bottomPlane);
                        this.nearPlane.set(pFrustum.nearPlane);
                        this.farPlane.set(pFrustum.farPlane);
                        break;
                    case 6:
                        this.leftPlane.set(arguments[0]);
                        this.rightPlane.set(arguments[1]);
                        this.topPlane.set(arguments[2]);
                        this.bottomPlane.set(arguments[3]);
                        this.nearPlane.set(arguments[4]);
                        this.farPlane.set(arguments[5]);
                        break;
                    default:
                        this.leftPlane.clear();
                        this.rightPlane.clear();
                        this.topPlane.clear();
                        this.bottomPlane.clear();
                        this.nearPlane.clear();
                        this.farPlane.clear();
                        break;
                }
                return this;
            };
            Frustum.prototype.calculateFrustumVertices = function /** @no-inline */() {
                if(this._pFrustumVertices == null) {
                    this._pFrustumVertices = new Array(8);
                    for(var i = 0; i < 8; i++) {
                        this._pFrustumVertices[i] = new akra.Vec3();
                    }
                }
                var v3fLeftNormal = this.leftPlane.normal;
                var v3fRightNormal = this.rightPlane.normal;
                var v3fTopNormal = this.topPlane.normal;
                var v3fBottomNormal = this.bottomPlane.normal;
                var v3fNearNormal = this.nearPlane.normal;
                var v3fFarNormal = this.farPlane.normal;
                var fLeft = -this.leftPlane.distance;
                var fRight = -this.rightPlane.distance;
                var fTop = -this.topPlane.distance;
                var fBottom = -this.bottomPlane.distance;
                var fNear = -this.nearPlane.distance;
                var fFar = -this.farPlane.distance;
                var m3fTemp = akra.mat3();
                var pFrustumVertices = this._pFrustumVertices;
                //first left-bottom-near
                pFrustumVertices[0].set(fLeft, fBottom, fNear);
                /*first colomn, not row*/
                m3fTemp.set(v3fLeftNormal.x, v3fBottomNormal.x, v3fNearNormal.x, v3fLeftNormal.y, v3fBottomNormal.y, v3fNearNormal.y, v3fLeftNormal.z, v3fBottomNormal.z, v3fNearNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[0]);
                //second right-bottom-near
                pFrustumVertices[1].set(fRight, fBottom, fNear);
                /*first colomn, not row*/
                m3fTemp.set(v3fRightNormal.x, v3fBottomNormal.x, v3fNearNormal.x, v3fRightNormal.y, v3fBottomNormal.y, v3fNearNormal.y, v3fRightNormal.z, v3fBottomNormal.z, v3fNearNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[1]);
                //third left-top-near
                pFrustumVertices[2].set(fLeft, fTop, fNear);
                /*first colomn, not row*/
                m3fTemp.set(v3fLeftNormal.x, v3fTopNormal.x, v3fNearNormal.x, v3fLeftNormal.y, v3fTopNormal.y, v3fNearNormal.y, v3fLeftNormal.z, v3fTopNormal.z, v3fNearNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[2]);
                //forth right-top-near
                pFrustumVertices[3].set(fRight, fTop, fNear);
                /*first colomn, not row*/
                m3fTemp.set(v3fRightNormal.x, v3fTopNormal.x, v3fNearNormal.x, v3fRightNormal.y, v3fTopNormal.y, v3fNearNormal.y, v3fRightNormal.z, v3fTopNormal.z, v3fNearNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[3]);
                //fifth left-bottom-far
                pFrustumVertices[4].set(fLeft, fBottom, fFar);
                /*first colomn, not row*/
                m3fTemp.set(v3fLeftNormal.x, v3fBottomNormal.x, v3fFarNormal.x, v3fLeftNormal.y, v3fBottomNormal.y, v3fFarNormal.y, v3fLeftNormal.z, v3fBottomNormal.z, v3fFarNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[4]);
                //sixth right-bottom-far
                pFrustumVertices[5].set(fRight, fBottom, fFar);
                /*first colomn, not row*/
                m3fTemp.set(v3fRightNormal.x, v3fBottomNormal.x, v3fFarNormal.x, v3fRightNormal.y, v3fBottomNormal.y, v3fFarNormal.y, v3fRightNormal.z, v3fBottomNormal.z, v3fFarNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[5]);
                //seventh left-top-far
                pFrustumVertices[6].set(fLeft, fTop, fFar);
                /*first colomn, not row*/
                m3fTemp.set(v3fLeftNormal.x, v3fTopNormal.x, v3fFarNormal.x, v3fLeftNormal.y, v3fTopNormal.y, v3fFarNormal.y, v3fLeftNormal.z, v3fTopNormal.z, v3fFarNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[6]);
                //eighth right-top-far
                pFrustumVertices[7].set(fRight, fTop, fFar);
                /*first colomn, not row*/
                m3fTemp.set(v3fRightNormal.x, v3fTopNormal.x, v3fFarNormal.x, v3fRightNormal.y, v3fTopNormal.y, v3fFarNormal.y, v3fRightNormal.z, v3fTopNormal.z, v3fFarNormal.z);
                m3fTemp.inverse().multiplyVec3(pFrustumVertices[7]);
                return pFrustumVertices;
            };
            Frustum.prototype.extractFromMatrix = function /** @no-inline */(m4fProjection, m4fWorld, pSearchRect) {
                if(this._pFrustumVertices == null) {
                    this._pFrustumVertices = new Array(8);
                    for(var i = 0; i < 8; i++) {
                        this._pFrustumVertices[i] = new akra.Vec3();
                    }
                }
                var pFrustumVertices = this._pFrustumVertices;
                var v4fLeftBottomNear = akra.vec4();
                var v4fRightBottomNear = akra.vec4();
                var v4fLeftTopNear = akra.vec4();
                var v4fRightTopNear = akra.vec4();
                var v4fLeftBottomFar = akra.vec4();
                var v4fRightBottomFar = akra.vec4();
                var v4fLeftTopFar = akra.vec4();
                var v4fRightTopFar = akra.vec4();
                m4fProjection.unproj(akra.vec3(-1, -1, -1), v4fLeftBottomNear);
                m4fProjection.unproj(akra.vec3(1, -1, -1), v4fRightBottomNear);
                m4fProjection.unproj(akra.vec3(-1, 1, -1), v4fLeftTopNear);
                m4fProjection.unproj(akra.vec3(1, 1, -1), v4fRightTopNear);
                m4fProjection.unproj(akra.vec3(-1, -1, 1), v4fLeftBottomFar);
                m4fProjection.unproj(akra.vec3(1, -1, 1), v4fRightBottomFar);
                m4fProjection.unproj(akra.vec3(-1, 1, 1), v4fLeftTopFar);
                m4fProjection.unproj(akra.vec3(1, 1, 1), v4fRightTopFar);
                if(akra.isDef(m4fWorld)) {
                    m4fWorld.multiplyVec4(v4fLeftBottomNear);
                    m4fWorld.multiplyVec4(v4fRightBottomNear);
                    m4fWorld.multiplyVec4(v4fLeftTopNear);
                    m4fWorld.multiplyVec4(v4fRightTopNear);
                    m4fWorld.multiplyVec4(v4fLeftBottomFar);
                    m4fWorld.multiplyVec4(v4fRightBottomFar);
                    m4fWorld.multiplyVec4(v4fLeftTopFar);
                    m4fWorld.multiplyVec4(v4fRightTopFar);
                }
                var v3fLeftBottomNear = pFrustumVertices[0].set(v4fLeftBottomNear.xyz);
                var v3fRightBottomNear = pFrustumVertices[1].set(v4fRightBottomNear.xyz);
                var v3fLeftTopNear = pFrustumVertices[2].set(v4fLeftTopNear.xyz);
                var v3fRightTopNear = pFrustumVertices[3].set(v4fRightTopNear.xyz);
                var v3fLeftBottomFar = pFrustumVertices[4].set(v4fLeftBottomFar.xyz);
                var v3fRightBottomFar = pFrustumVertices[5].set(v4fRightBottomFar.xyz);
                var v3fLeftTopFar = pFrustumVertices[6].set(v4fLeftTopFar.xyz);
                var v3fRightTopFar = pFrustumVertices[7].set(v4fRightTopFar.xyz);
                //filling search rectangle
                if(akra.isDef(pSearchRect)) {
                    pSearchRect.set(v3fLeftBottomNear, v3fLeftBottomNear);
                    pSearchRect.unionPoint(v3fRightBottomNear);
                    pSearchRect.unionPoint(v3fLeftTopNear);
                    pSearchRect.unionPoint(v3fRightTopNear);
                    pSearchRect.unionPoint(v3fLeftBottomFar);
                    pSearchRect.unionPoint(v3fRightBottomFar);
                    pSearchRect.unionPoint(v3fLeftTopFar);
                    pSearchRect.unionPoint(v3fRightTopFar);
                }
                //calculating planes
                this.leftPlane.set(v3fLeftTopNear, v3fLeftTopFar, v3fLeftBottomNear);
                this.rightPlane.set(v3fRightBottomFar, v3fRightTopFar, v3fRightBottomNear);
                this.topPlane.set(v3fLeftTopNear, v3fRightTopNear, v3fLeftTopFar);
                this.bottomPlane.set(v3fRightBottomFar, v3fRightBottomNear, v3fLeftBottomFar);
                this.nearPlane.set(v3fLeftTopNear, v3fLeftBottomNear, v3fRightTopNear);
                this.farPlane.set(v3fRightBottomFar, v3fLeftBottomFar, v3fRightTopFar);
                return this;
            };
            Frustum.prototype.isEqual = function /** @inline */(pFrustum) {
                return (this.leftPlane.isEqual(pFrustum.leftPlane) && this.rightPlane.isEqual(pFrustum.rightPlane) && this.topPlane.isEqual(pFrustum.topPlane) && this.bottomPlane.isEqual(pFrustum.bottomPlane) && this.nearPlane.isEqual(pFrustum.nearPlane) && this.farPlane.isEqual(pFrustum.farPlane));
            };
            Frustum.prototype.testPoint = function /** @no-inline */(v3fPoint) {
                if(this.leftPlane.signedDistance(v3fPoint) > 0. || this.rightPlane.signedDistance(v3fPoint) > 0. || this.topPlane.signedDistance(v3fPoint) > 0. || this.bottomPlane.signedDistance(v3fPoint) > 0. || this.nearPlane.signedDistance(v3fPoint) > 0. || this.farPlane.signedDistance(v3fPoint) > 0.) {
                    return false;
                }
                return true;
            };
            Frustum.prototype.testRect = function /** @no-inline */(pRect) {
                if(geometry.planeClassifyRect3d(this.leftPlane, pRect) == 0 /* PLANE_FRONT */  || geometry.planeClassifyRect3d(this.rightPlane, pRect) == 0 /* PLANE_FRONT */  || geometry.planeClassifyRect3d(this.topPlane, pRect) == 0 /* PLANE_FRONT */  || geometry.planeClassifyRect3d(this.bottomPlane, pRect) == 0 /* PLANE_FRONT */  || geometry.planeClassifyRect3d(this.nearPlane, pRect) == 0 /* PLANE_FRONT */  || geometry.planeClassifyRect3d(this.farPlane, pRect) == 0 /* PLANE_FRONT */ ) {
                    return false;
                }
                return true;
            };
            Frustum.prototype.testSphere = function /** @no-inline */(pSphere) {
                if(geometry.planeClassifySphere(this.leftPlane, pSphere) == 0 /* PLANE_FRONT */  || geometry.planeClassifySphere(this.rightPlane, pSphere) == 0 /* PLANE_FRONT */  || geometry.planeClassifySphere(this.topPlane, pSphere) == 0 /* PLANE_FRONT */  || geometry.planeClassifySphere(this.bottomPlane, pSphere) == 0 /* PLANE_FRONT */  || geometry.planeClassifySphere(this.nearPlane, pSphere) == 0 /* PLANE_FRONT */  || geometry.planeClassifySphere(this.farPlane, pSphere) == 0 /* PLANE_FRONT */ ) {
                    return false;
                }
                return true;
            };
            Frustum.prototype.testFrustum = function /** @no-inline */(pFrustum) {
                var pFrustumVertices1 = this.frustumVertices;
                var pFrustumVertices2 = pFrustum.frustumVertices;
                if(pFrustumVertices1 == null) {
                    pFrustumVertices1 = this.calculateFrustumVertices();
                }
                if(pFrustumVertices2 == null) {
                    pFrustumVertices2 = pFrustum.calculateFrustumVertices();
                }
                var pFrustumPlanes = Frustum.frustumPlanesKeys;
                var nTest;
                for(var i = 0; i < 6; i++) {
                    var pPlane = this[pFrustumPlanes[i]];
                    nTest = 0;
                    for(var j = 0; j < 8; j++) {
                        if(pPlane.signedDistance(pFrustumVertices2[j]) > 0) {
                            nTest++;
                        }
                    }
                    if(nTest == 8) {
                        //frustums don't intersecting
                        return false;
                    }
                }
                //second batch of test for minimizing possible error
                for(var i = 0; i < 6; i++) {
                    var pPlane = pFrustum[pFrustumPlanes[i]];
                    nTest = 0;
                    for(var j = 0; j < 8; j++) {
                        if(pPlane.signedDistance(pFrustumVertices1[j]) > 0) {
                            nTest++;
                        }
                    }
                    if(nTest == 8) {
                        //frustums don't intersecting
                        return false;
                    }
                }
                return true;
            };
            Frustum.frustumPlanesKeys = [
                "leftPlane", 
                "rightPlane", 
                "topPlane", 
                "bottomPlane", 
                "nearPlane", 
                "farPlane"
            ];
            return Frustum;
        })();
        geometry.Frustum = Frustum;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        (function (objects) {
            (function (ECameraFlags) {
                ECameraFlags._map = [];
                ECameraFlags.k_NewProjectionMatrix = 0;
            })(objects.ECameraFlags || (objects.ECameraFlags = {}));
            var ECameraFlags = objects.ECameraFlags;
            ;
            var DLTechnique = (function () {
                function /** @no-inline */DLTechnique(pList, pCamera) {
                    this._pPrevResult = null;
                    this.list = pList;
                    this.camera = pCamera;
                }
                DLTechnique.prototype.findObjects = function /** @inline */(pResultArray, bQuickSearch) {
                    if (typeof bQuickSearch === "undefined") { bQuickSearch = false; }
                    var pResult = this.list._findObjects(this.camera, pResultArray, bQuickSearch && akra.isDefAndNotNull(this._pPrevResult));
                    if(akra.isNull(this._pPrevResult)) {
                        this._pPrevResult = pResult;
                    }
                    return this._pPrevResult;
                };
                return DLTechnique;
            })();
            objects.DLTechnique = DLTechnique;            
            var Camera = (function (_super) {
                __extends(Camera, _super);
                function /** @no-inline */Camera(pScene) {
                                _super.call(this, pScene);
                    /** camera type */
                    /**@protected*/ this._eCameraType = 0 /* PERSPECTIVE */ ;
                    /** camera options */
                    /**@protected*/ this._iCameraOptions = 0;
                    /** update projection bit flag */
                    /**@protected*/ this._iUpdateProjectionFlags = 0;
                    /** View matrix */
                    /**@protected*/ this._m4fView = new akra.Mat4();
                    /** internal, un-biased projection matrix */
                    /**@protected*/ this._m4fProj = new akra.Mat4();
                    /**@protected*/ this._m4fUnitProj = new akra.Mat4();
                    /** internal, un-biased projection+view matrix */
                    /**@protected*/ this._m4fProjView = new akra.Mat4();
                    /** Biased for use during current render stage */
                    /**@protected*/ this._m4fRenderStageProj = new akra.Mat4();
                    /**@protected*/ this._m4fRenderStageProjView = new akra.Mat4();
                    /** Search rect for scene culling */
                    /**@protected*/ this._pSearchRect = new akra.geometry.Rect3d();
                    /** Position */
                    /**@protected*/ this._v3fTargetPos = new akra.Vec3();
                    /** Attributes for projection matrix */
                    /**@protected*/ this._fFOV = akra.math.PI / 5.;
                    /**@protected*/ this._fAspect = 4. / 3.;
                    /**@protected*/ this._fNearPlane = 0.1;
                    /**@protected*/ this._fFarPlane = 500.;
                    /**@protected*/ this._fWidth = 0.;
                    /**@protected*/ this._fHeight = 0.;
                    /**@protected*/ this._fMinX = 0.;
                    /**@protected*/ this._fMaxX = 0.;
                    /**@protected*/ this._fMinY = 0.;
                    /**@protected*/ this._fMaxY = 0.;
                    /**@protected*/ this._pFrustum = new akra.geometry.Frustum();
                    /**@protected*/ this._pLastViewport = null;
                    /**@protected*/ this._pDLTechniques = [];
                    /**@protected*/ this._pDLResultStorage = [];
                    this._iGuid = eval("this._iGuid || akra.sid()");
                    this._pUnicastSlotMap = null;
                    this._pBroadcastSlotList = null;
                    this._eType = 4 /* CAMERA */ ;
                }
                Object.defineProperty(Camera.prototype, "viewMatrix", {
                    get: // protected _pPrevObjects: ISceneNode[] = null;
                    // protected _p
                    function /** @inline */() {
                        return this._m4fView;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "projectionMatrix", {
                    get: function /** @inline */() {
                        return this._m4fRenderStageProj;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "projViewMatrix", {
                    get: function /** @inline */() {
                        return this._m4fRenderStageProjView;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "internalProjectionMatrix", {
                    get: function /** @inline */() {
                        return this._m4fProj;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "internalViewProjMatrix", {
                    get: function /** @inline */() {
                        return this._m4fProjView;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "targetPos", {
                    get: function /** @inline */() {
                        return this._v3fTargetPos;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "fov", {
                    get: function /** @inline */() {
                        return this._fFOV;
                    },
                    set: function /** @inline */(fFOV) {
                        this._fFOV = fFOV;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "aspect", {
                    get: function /** @inline */() {
                        return this._fAspect;
                    },
                    set: function /** @inline */(fAspect) {
                        this._fAspect = fAspect;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "nearPlane", {
                    get: function /** @inline */() {
                        return this._fNearPlane;
                    },
                    set: function /** @inline */(fNearPlane) {
                        this._fNearPlane = fNearPlane;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "farPlane", {
                    get: function /** @inline */() {
                        return this._fFarPlane;
                    },
                    set: function /** @inline */(fFarPlane) {
                        this._fFarPlane = fFarPlane;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "viewDistance", {
                    get: function /** @inline */() {
                        return this._fFarPlane - this._fNearPlane;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "searchRect", {
                    get: function /** @inline */() {
                        return this._pSearchRect;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "frustum", {
                    get: function /** @inline */() {
                        return this._pFrustum;
                    },
                    enumerable: true,
                    configurable: true
                });
                Camera.prototype.create = function /** @no-inline */() {
                    var isOK = _super.prototype.create.call(this);
                    if(isOK) {
                        this._v3fTargetPos.set(this._m4fLocalMatrix.data[8], this._m4fLocalMatrix.data[9], this._m4fLocalMatrix.data[10]);
                        this._v3fTargetPos.negate();
                        this.setProjParams(this._fFOV, this._fAspect, this._fNearPlane, this._fFarPlane);
                        this.recalcMatrices();
                        var pScene = this._pScene;
                        this.connect(pScene, "displayListAdded", "_addDisplayList");
                        this.connect(pScene, "displayListRemoved", "_removeDisplayList");
                        for(var i = 0; i < pScene.totalDL; ++i) {
                            var pList = pScene.getDisplayList(i);
                            if(!akra.isNull(pList)) {
                                this._addDisplayList(pScene, pList, i);
                            }
                        }
                    }
                    return isOK;
                };
                Camera.prototype.prepareForUpdate = function /** @no-inline */() {
                    _super.prototype.prepareForUpdate.call(this);
                    //reset culling cache for all display lists
                    // for (var i: int = 0; i < this._pDLTechniques.length; ++ i) {
                    // 	if (this._pDLTechniques[i] != null) {
                    // 		this._pDLTechniques.reset();
                    // 	}
                    // }
                                    };
                Camera.prototype.display = /*DL_DEFAULT*/
                function /** @no-inline */(iList) {
                    if (typeof iList === "undefined") { iList = 0; }
                    var pObjects = this._pDLTechniques[iList].findObjects(this._pDLResultStorage[iList], !this.isUpdated());
                    return pObjects;
                };
                Camera.prototype.setParameter = function /** @no-inline */(eParam, pValue) {
                    if(eParam === 1 /* CONST_ASPECT */  && pValue) {
                        ((this._iCameraOptions) |= (eParam));
                    }
                };
                Camera.prototype.isConstantAspect = function /** @no-inline */() {
                    return (((this._iCameraOptions) & (1 /* CONST_ASPECT */ )) != 0);
                };
                Camera.prototype.setProjParams = function /** @no-inline */(fFOV, fAspect, fNearPlane, fFarPlane) {
                    // Set attributes for the projection matrix
                    this._fFOV = fFOV;
                    this._fAspect = fAspect;
                    this._fNearPlane = fNearPlane;
                    this._fFarPlane = fFarPlane;
                    this._eCameraType = 0 /* PERSPECTIVE */ ;
                    // create the regular projection matrix
                    akra.Mat4.perspective(fFOV, fAspect, fNearPlane, fFarPlane, this._m4fProj);
                    // create a unit-space matrix
                    // for sky box geometry.
                    // this ensures that the
                    // near and far plane enclose
                    // the unit space around the camera
                    akra.Mat4.perspective(fFOV, fAspect, 0.01, 2.0, this._m4fUnitProj);
                    ((this._iUpdateProjectionFlags) |= (1 << (0 /* k_NewProjectionMatrix */ )));
                };
                Camera.prototype.setOrthoParams = function /** @no-inline */(fWidth, fHeight, fNearPlane, fFarPlane) {
                    akra.logger.setSourceLocation("objects/Camera.ts", 208);
                    akra.logger.criticalError("TODO: setOrthoParams();");
                    ;
                    /*
                    
                    this._fWidth = fWidth;
                    this._fHeight = fHeight;
                    this._fNearPlane = fNearPlane;
                    this._fFarPlane = fFarPlane;
                    this._eCameraType = ECameraTypes.ORTHO;
                    
                    // create the regular projection matrix
                    Mat4.matrixOrthoRH(fWidth, fHeight, fNearPlane, fFarPlane, this._m4fProj);
                    
                    // create a unit-space matrix
                    // for sky box geometry.
                    // this ensures that the
                    // near and far plane enclose
                    // the unit space around the camera
                    Mat4.matrixOrthoRH(fWidth, fHeight, 0.01, 2.0, this._m4fUnitProj);
                    
                    TRUE_BIT(this._iUpdateProjectionFlags, ECameraFlags.k_NewProjectionMatrix);
                    
                    */
                                    };
                Camera.prototype.setOffsetOrthoParams = function /** @no-inline */(fMinX, fMaxX, fMinY, fMaxY, fNearPlane, fFarPlane) {
                    this._fMinX = fMinX;
                    this._fMaxX = fMaxX;
                    this._fMinY = fMinY;
                    this._fMaxY = fMaxY;
                    this._fNearPlane = fNearPlane;
                    this._fFarPlane = fFarPlane;
                    this._eCameraType = 2 /* OFFSET_ORTHO */ ;
                    // create the regular projection matrix
                    /*orthogonalProjection*/
                    akra.Mat4.orthogonalProjectionAsymmetric(fMinX, fMaxX, fMinY, fMaxY, fNearPlane, fFarPlane, this._m4fProj);
                    // create a unit-space matrix
                    // for sky box geometry.
                    // this ensures that the
                    // near and far plane enclose
                    // the unit space around the camera
                    /*orthogonalProjection*/
                    akra.Mat4.orthogonalProjectionAsymmetric(fMinX, fMaxX, fMinY, fMaxY, 0.01, 2.0, this._m4fUnitProj);
                    ((this._iUpdateProjectionFlags) |= (1 << (0 /* k_NewProjectionMatrix */ )));
                };
                Camera.prototype.recalcMatrices = function /** @no-inline */() {
                    this._v3fTargetPos.set(this._m4fLocalMatrix.data[8], this._m4fLocalMatrix.data[9], this._m4fLocalMatrix.data[10]);
                    this._v3fTargetPos.negate();
                    // the camera view matrix is the
                    // inverse of the world matrix
                    this._m4fView.set(this.inverseWorldMatrix);
                    // sky boxes use the inverse
                    // world matrix of the camera (the
                    // camera view matrix) without
                    // any translation information.
                    //this.m4fSkyBox.set(this.m4fView);
                    // this.m4fSkyBox.data[__14] = 0.0;
                    // this.m4fSkyBox.data[__24] = 0.0;
                    // this.m4fSkyBox.data[__34] = 0.0;
                    // this is combined with the unit
                    // space projection matrix to form
                    // the sky box viewing matrix
                    //this.m4fSkyBox.multiply(this.m4fUnitProj, this.m4fSkyBox);
                    // billboard objects use our world matrix
                    // without translation
                    // this.m4fBillboard.set(this.worldMatrix());
                    // this.m4fBillboard.data[__14] = 0.0;
                    // this.m4fBillboard.data[__24] = 0.0;
                    // this.m4fBillboard.data[__34] = 0.0;
                                    };
                Camera.prototype.update = function /** @no-inline */() {
                    var isUpdated = _super.prototype.update.call(this);
                    if(this.isWorldMatrixNew() || ((this._iUpdateProjectionFlags & (1 << (0 /* k_NewProjectionMatrix */ ))) != 0)) {
                        this._pFrustum.extractFromMatrix(this._m4fProj, this._m4fWorldMatrix, this._pSearchRect);
                        // our projView matrix is the projection
                        //matrix multiplied by the inverse of our world matrix
                        this._m4fProj.multiply(this._m4fView, this._m4fRenderStageProjView);
                        isUpdated = true;
                        ((this._iUpdateProjectionFlags) &= ~(1 << (0 /* k_NewProjectionMatrix */ )));
                    }
                    return isUpdated;
                };
                Camera.prototype.applyRenderStageBias = function /** @no-inline */(iStage) {
                    var fZ_bias = iStage > 1 ? 0.001 : 0.0;
                    this._m4fRenderStageProj.set(this._m4fProj);
                    this._m4fRenderStageProjView.set(this._m4fProjView);
                    this._m4fRenderStageProj[14] -= fZ_bias;
                    this._m4fRenderStageProjView[14] -= fZ_bias;
                };
                Camera.prototype.lookAt = function /** @no-inline */(v3f) {
                    var v3fFrom, v3fCenter, v3fUp;
                    if(arguments.length < 3) {
                        v3fFrom = this.worldPosition;
                        v3fCenter = arguments[0];
                        v3fUp = arguments[1];
                    } else {
                        v3fFrom = arguments[0];
                        v3fCenter = arguments[1];
                        v3fUp = arguments[2];
                    }
                    v3fUp = v3fUp || akra.vec3(0., 1., 0.);
                    var v3fParentPos = (this.parent).worldPosition;
                    var m4fTemp = akra.Mat4.lookAt(v3fFrom, v3fCenter, v3fUp, akra.mat4()).inverse();
                    var pData = m4fTemp.data;
                    switch(this._eInheritance) {
                        case 2 /* ALL */ :
                            (this._pParent).inverseWorldMatrix.multiply(m4fTemp, m4fTemp);
                            m4fTemp.toQuat4(this._qRotation);
                            this.setPosition(pData[12], pData[13], pData[14]);
                            break;
                        case 1 /* ROTSCALE */ :
                            var m3fTemp = m4fTemp.toMat3();
                            m3fTemp = (this._pParent).inverseWorldMatrix.toMat3().multiply(m3fTemp, akra.mat3());
                            m3fTemp.toQuat4(this._qRotation);
                            this.setPosition(pData[12], pData[13], pData[14]);
                            break;
                        default:
                            m4fTemp.toQuat4(this._qRotation);
                            this.setPosition(pData[12] - v3fParentPos.x, pData[13] - v3fParentPos.y, pData[14] - v3fParentPos.z);
                    }
                };
                Camera.prototype._renderScene = function /** @no-inline */(pViewport) {
                    //update the pixel display ratio
                    // if (this._eCameraType == ECameraTypes.PERSPECTIVE) {
                    // 	mPixelDisplayRatio = (2. * math.tan(this._fFOV * 0.5)) / pViewport.actualHeight;
                    // }
                    // else {
                    // 	mPixelDisplayRatio = (mTop - mBottom) / vp->getActualHeight();
                    // }
                    //notify prerender scene
                    this.preRenderScene();
                    pViewport.update();
                    //notify postrender scene
                    this.postRenderScene();
                };
                Camera.prototype._keepLastViewport = function /** @no-inline */(pViewport) {
                    this._pLastViewport = pViewport;
                };
                Camera.prototype._getLastViewport = function /** @no-inline */() {
                    return this._pLastViewport;
                };
                Camera.prototype._getNumRenderedFaces = function /** @no-inline */() {
                    return 0;
                };
                Camera.prototype._notifyRenderedFaces = function /** @no-inline */(nFaces) {
                };
                Camera.prototype.toString = function /** @no-inline */(isRecursive, iDepth) {
                    if (typeof isRecursive === "undefined") { isRecursive = false; }
                    if (typeof iDepth === "undefined") { iDepth = 0; }
                    if(!isRecursive) {
                        return "<camera" + (this._sName ? " " + this._sName : "") + ">";
                    }
                    return _super.prototype.toString.call(this, isRecursive, iDepth);
                };
                Camera.prototype._addDisplayList = function /** @no-inline */(pScene, pList, index) {
                    this._pDLTechniques[index] = new DLTechnique(pList, this);
                    this._pDLResultStorage[index] = new akra.util.ObjectArray();
                };
                Camera.prototype._removeDisplayList = function /** @no-inline */(pScene, pList, index) {
                    this._pDLTechniques[index] = null;
                    this._pDLResultStorage[index] = null;
                };
                Camera._pEventTable = new akra.events.EventTable();
                Camera.prototype.getEventTable = function /** @inline */() {
                    return Camera._pEventTable;
                };
                Camera.prototype.getGuid = function /** @no-inline */() {
                    return this._iGuid < 0 ? (this._iGuid = akra.sid()) : this._iGuid;
                };
                Camera.prototype.connect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                    return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
                };
                Camera.prototype.disconnect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                    return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
                };
                Camera.prototype.bind = function /** @inline */(sSignal, fnListener, eType) {
                    return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType);
                };
                Camera.prototype.unbind = function /** @inline */(sSignal, fnListener, eType) {
                    return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType);
                };
                Camera.prototype.preRenderScene = function /** @no-inline */() {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                    var _broadcast = (this._pBroadcastSlotList).preRenderScene;
                    var _recivier = this;
                    if(akra.isDef(_broadcast)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                Camera.prototype.postRenderScene = function /** @no-inline */() {
                    this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                    var _broadcast = (this._pBroadcastSlotList).postRenderScene;
                    var _recivier = this;
                    if(akra.isDef(_broadcast)) {
                        for(var i = 0; i < _broadcast.length; ++i) {
                            _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                        }
                    }
                };
                return Camera;
            })(scene.SceneNode);
            objects.Camera = Camera;            
        })(scene.objects || (scene.objects = {}));
        var objects = scene.objects;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (model) {
        var Skin = (function () {
            function /** @no-inline */Skin(pMesh) {
                this._pSkeleton = null;
                // name of bones/nodes
                this._pNodeNames = null;
                //BONE_MATRIX = WORLD_MATRIX x OFFSET_MATRIX
                this._pBoneTransformMatrices = null;
                /**
                * Common buffer for all transform matrices.
                * _pBoneOffsetMatrixBuffer = [_pBoneTransformMatrices[0], ..., _pBoneTransformMatrices[N]]
                */
                this._pBoneOffsetMatrixBuffer = null;
                // bone offset matrices from collada
                this._pBoneOffsetMatrices = null;
                /**
                * Pointers to nodes, that affect to this skin.
                */
                this._pAffectingNodes = null;
                /**
                * Format:
                * BONE_INF_COUNT - number of bones, that influence to the vertex.
                * BONE_INF_LOC - address of influence, pointer to InfData structire list.
                * ..., [BONE_INF_COUNT: float, BONE_INF_LOC: float], ...
                *
                */
                this._pInfMetaData = null;
                /**
                * Format:
                * BONE_INF_DATA - bone matrix address, pointer to BONE_MATRIX list
                * BONE_WEIGHT_IND - bone weight address, pointer to BONE_WEIGHT list
                * ..., [BONE_INF_DATA: float, BONE_WEIGHT_IND: float], ...
                */
                this._pInfData = null;
                /**
                * Format:
                * ..., [BONE_MATRIX: matrix4], ...
                */
                this._pBoneTransformMatrixData = null;
                /**
                * Format:
                * ..., [BONE_WEIGHT: float], ...
                */
                this._pWeightData = null;
                /**
                * Links to VertexData, that contain meta from this skin.
                */
                this._pTiedData = [];
                akra.logger.setSourceLocation("Skin.ts", 106);
                akra.logger.assert(akra.isDefAndNotNull(pMesh), "you must specify mesh for skin");
                ;
                this._pMesh = pMesh;
            }
            Object.defineProperty(Skin.prototype, "data", {
                get: function /** @inline */() {
                    return this._pMesh.data;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Skin.prototype, "skeleton", {
                get: function /** @inline */() {
                    return this._pSkeleton;
                },
                set: function /** @inline */(pSkeleton) {
                    if(akra.isNull(pSkeleton) || pSkeleton.totalBones < this.totalBones) {
                        akra.logger.setSourceLocation("Skin.ts", 88);
                        akra.logger.warning("cannnot set skeletonm because skeleton has to little bones");
                        ;
                        return;
                    }
                    for(var i = 0, nMatrices = this.totalBones; i < nMatrices; i++) {
                        this._pAffectingNodes[i] = pSkeleton.findJoint(this._pNodeNames[i]);
                        akra.logger.setSourceLocation("Skin.ts", 94);
                        akra.logger.assert(akra.isDefAndNotNull(this._pAffectingNodes[i]), "joint<" + this._pNodeNames[i] + "> must exists...");
                        ;
                    }
                    this._pSkeleton = pSkeleton;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Skin.prototype, "totalBones", {
                get: function /** @inline */() {
                    return this._pNodeNames.length;
                },
                enumerable: true,
                configurable: true
            });
            Skin.prototype.setBindMatrix = function /** @no-inline */(m4fMatrix) {
                this._m4fBindMatrix.set(m4fMatrix);
            };
            Skin.prototype.getBindMatrix = function /** @no-inline */() {
                return this._m4fBindMatrix;
            };
            Skin.prototype.getBoneOffsetMatrices = function /** @no-inline */() {
                return this._pBoneOffsetMatrices;
            };
            Skin.prototype.getBoneOffsetMatrix = function /** @no-inline */(sBoneName) {
                var pBoneNames = this._pNodeNames;
                for(var i = 0; i < pBoneNames.length; i++) {
                    if(pBoneNames[i] === sBoneName) {
                        return this._pBoneOffsetMatrices[i];
                    }
                }
                ;
                return null;
            };
            Skin.prototype.setSkeleton = function /** @no-inline */(pSkeleton) {
                if(!pSkeleton || pSkeleton.totalBones < this.totalBones) {
                    return false;
                }
                for(var i = 0, nMatrices = this.totalBones; i < nMatrices; i++) {
                    this._pAffectingNodes[i] = pSkeleton.findJoint(this._pNodeNames[i]);
                    akra.logger.setSourceLocation("Skin.ts", 142);
                    akra.logger.assert(!akra.isNull(this._pAffectingNodes[i]), "joint<" + this._pNodeNames[i] + "> must exists...");
                    ;
                }
                this._pSkeleton = pSkeleton;
                return true;
            };
            Skin.prototype.attachToScene = function /** @no-inline */(pRootNode) {
                for(var i = 0, nMatrices = this.totalBones; i < nMatrices; i++) {
                    this._pAffectingNodes[i] = pRootNode.findEntity(this._pNodeNames[i]);
                    akra.logger.setSourceLocation("Skin.ts", 153);
                    akra.logger.assert(akra.isDefAndNotNull(this._pAffectingNodes[i]), "node<" + this._pNodeNames[i] + "> must exists...");
                    ;
                }
                return true;
            };
            Skin.prototype.setBoneNames = function /** @no-inline */(pNames) {
                if(akra.isNull(pNames)) {
                    return false;
                }
                this._pNodeNames = pNames;
                this._pAffectingNodes = new Array(pNames.length);
                return true;
            };
            Skin.prototype.setBoneOffsetMatrices = function /** @no-inline */(pMatrices) {
                var pMatrixNames = this._pNodeNames;
                akra.logger.setSourceLocation("Skin.ts", 176);
                akra.logger.assert(akra.isDefAndNotNull(pMatrices) && akra.isDefAndNotNull(pMatrixNames) && pMatrixNames.length === pMatrices.length, "number of matrix names must equal matrices data length:\n" + pMatrixNames.length + " / " + pMatrices.length);
                ;
                var nMatrices = pMatrixNames.length;
                var pData = this.data;
                var pMatrixData = new Float32Array(nMatrices * 16);
                //FIXME: правильно положить матрицы...			this._pBoneOffsetMatrices = pMatrices;
                this._pBoneTransformMatrixData = pData._allocateData([
                    akra.VE_MAT4("BONE_MATRIX")
                ], pMatrixData);
                this._pBoneTransformMatrices = new Array(nMatrices);
                for(var i = 0; i < nMatrices; i++) {
                    this._pBoneTransformMatrices[i] = new akra.Mat4(pMatrixData.subarray(i * 16, (i + 1) * 16), true);
                }
                this._pBoneOffsetMatrixBuffer = pMatrixData;
            };
            Skin.prototype.setWeights = function /** @no-inline */(pWeights) {
                this._pWeightData = this.data._allocateData([
                    akra.VE_FLOAT("BONE_WEIGHT")
                ], pWeights);
                return this._pWeightData !== null;
            };
            Skin.prototype.getWeights = function /** @no-inline */() {
                return this._pWeightData;
            };
            Skin.prototype.getInfluenceMetaData = function /** @no-inline */() {
                return this._pInfMetaData;
            };
            Skin.prototype.getInfluences = function /** @no-inline */() {
                return this._pInfData;
            };
            Skin.prototype.setIfluences = function /** @no-inline */(pInfluencesCount, pInfluences) {
                akra.logger.setSourceLocation("Skin.ts", 213);
                akra.logger.assert(this._pInfMetaData == null && this._pInfData == null, "vertex weights already setuped.");
                ;
                akra.logger.setSourceLocation("Skin.ts", 214);
                akra.logger.assert(!akra.isNull(this.getWeights()), "you must set weight data before setup influences");
                ;
                var pData = this.data;
                var pInfluencesMeta = new Float32Array(pInfluencesCount.length * 2);
                var iInfLoc = 0;
                var iTransformLoc = 0;
                var iWeightsLoc = 0;
                //получаем копию массива влияний
                pInfluences = new Float32Array(pInfluences);
                //вычисляем адресса матриц транфсормации и весов
                iTransformLoc = this._pBoneTransformMatrixData.byteOffset / 4 /* BYTES_PER_FLOAT */ ;
                iWeightsLoc = this._pWeightData.byteOffset / 4 /* BYTES_PER_FLOAT */ ;
                for(var i = 0, n = pInfluences.length; i < n; i += 2) {
                    pInfluences[i] = pInfluences[i] * 16 + iTransformLoc;
                    pInfluences[i + 1] += iWeightsLoc;
                }
                //запоминаем модифицированную информацию о влияниях
                this._pInfData = pData._allocateData([], //адрес матрицы кости			                                         VE_FLOAT('BONE_INF_DATA'),
                //адрес весового коэффициента			                                         VE_FLOAT('BONE_WEIGHT_IND')
                pInfluences);
                iInfLoc = this._pInfData.byteOffset / 4 /* BYTES_PER_FLOAT */ ;
                //подсчет мета данных, которые укажут, где взять влияния на кость..
                for(var i = 0, j = 0, n = iInfLoc; i < pInfluencesMeta.length; i += 2) {
                    var iCount = pInfluencesCount[j++];
                    //число влияний на вершину			    pInfluencesMeta[i] = iCount;
                    //адресс начала информации о влияниях 			    pInfluencesMeta[i + 1] = n;
                    //(пары индекс коэф. веса и индекс матрицы)
                    n += 2 * iCount;
                }
                //influences meta: разметка влияний
                this._pInfMetaData = pData._allocateData([], //число костей и весов, влияющих на вершину			                                             VE_FLOAT('BONE_INF_COUNT'),
                //адресс начала влияний на вершину			                                             VE_FLOAT('BONE_INF_LOC'),
                pInfluencesMeta);
                return this._pInfMetaData !== null && this._pInfData !== null;
            };
            Skin.prototype.setVertexWeights = function /** @no-inline */(pInfluencesCount, pInfluences, pWeights) {
                akra.logger.setSourceLocation("Skin.ts", 265);
                akra.logger.assert(arguments.length > 1, 'you must specify all parameters');
                ;
                //загружаем веса
                if(pWeights) {
                    this.setWeights(pWeights);
                }
                return this.setIfluences(pInfluencesCount, pInfluences);
            };
            Skin.prototype.applyBoneMatrices = function /** @no-inline */(bForce) {
                if (typeof bForce === "undefined") { bForce = false; }
                var pData;
                var bResult;
                var pNode;
                var isUpdated = false;
                for(var i = 0, nMatrices = this.totalBones; i < nMatrices; ++i) {
                    pNode = this._pAffectingNodes[i];
                    if(pNode.isWorldMatrixNew() || bForce) {
                        pNode.worldMatrix.multiply(this._pBoneOffsetMatrices[i], this._pBoneTransformMatrices[i]);
                        isUpdated = true;
                    }
                }
                if(isUpdated) {
                    pData = this._pBoneOffsetMatrixBuffer;
                    return this._pBoneTransformMatrixData.setData(pData, 0, pData.byteLength);
                }
                return false;
            };
            Skin.prototype.isReady = function /** @no-inline */() {
                return !(akra.isNull(this._pInfMetaData) || akra.isNull(this._pInfData) || akra.isNull(this._pWeightData) || akra.isNull(this._pBoneOffsetMatrixBuffer) || akra.isNull(this._pBoneOffsetMatrices) || akra.isNull(this._pNodeNames) || akra.isNull(this._m4fBindMatrix));
            };
            Skin.prototype.getBoneTransforms = function /** @no-inline */() {
                return this._pBoneTransformMatrixData;
            };
            Skin.prototype.isAffect = function /** @no-inline */(pData) {
                if(akra.isDefAndNotNull(pData)) {
                    for(var i = 0; i < this._pTiedData.length; i++) {
                        if(this._pTiedData[i] === pData) {
                            return true;
                        }
                    }
                }
                return false;
            };
            Skin.prototype.attach = function /** @no-inline */(pData) {
                akra.logger.setSourceLocation("Skin.ts", 323);
                akra.logger.assert(pData.stride === 16, "you cannot add skin to mesh with POSITION: {x, y, z}" + "\nyou need POSITION: {x, y, z, w}");
                ;
                pData.getVertexDeclaration().append(akra.VE_FLOAT(akra.DeclUsages.BLENDMETA, 12));
                this._pTiedData.push(pData);
            };
            Skin.debugMeshSubset = function /** @no-inline */debugMeshSubset(pSubMesh) {
                var pMesh = pSubMesh.mesh;
                var pSkin = pSubMesh.skin;
                var pMatData = pSkin.getBoneTransforms();
                var pPosData;
                var pEngine = pMesh.getEngine();
                pPosData = (pSubMesh.data._getData("POSITION")).getTypedData(akra.DeclUsages.BLENDMETA);
                var pVideoBuffer = pSubMesh.mesh.data.buffer;
                var iFrom = 2618, iTo = 2619;
                var pWeights = pSkin.getWeights().getTypedData('BONE_WEIGHT');
                akra.logger.setSourceLocation("Skin.ts", 345);
                akra.logger.log('===== debug vertices from ', iFrom, 'to', iTo, ' ======');
                ;
                akra.logger.setSourceLocation("Skin.ts", 346);
                akra.logger.log('transformation data location:', pMatData.byteOffset / 4.);
                ;
                akra.logger.setSourceLocation("Skin.ts", 347);
                akra.logger.log('155 weight: ', pSkin.getWeights().getTypedData('BONE_WEIGHT')[155]);
                ;
                akra.logger.setSourceLocation("Skin.ts", 348);
                akra.logger.log('vertices info ===================>');
                ;
                for(var i = iFrom; i < iTo; i++) {
                    akra.logger.setSourceLocation("Skin.ts", 351);
                    akra.logger.log(pPosData[i], '<< inf meta location');
                    ;
                    var pMetaData = new Float32Array(8);
                    if(!pVideoBuffer.readData(4 * pPosData[i], 8, pMetaData)) {
                        akra.logger.setSourceLocation("Skin.ts", 355);
                        akra.logger.error("cannot read back meta data");
                        ;
                    }
                    akra.logger.setSourceLocation("Skin.ts", 358);
                    akra.logger.log(pMetaData[0], '<< count');
                    ;
                    akra.logger.setSourceLocation("Skin.ts", 359);
                    akra.logger.log(pMetaData[1], '<< inf. location');
                    ;
                    for(var j = 0; j < pMetaData[0]; ++j) {
                        var pInfData = new Float32Array(8);
                        if(!pVideoBuffer.readData(4 * (pMetaData[1] + 2 * j), 8, pInfData)) {
                            akra.logger.setSourceLocation("Skin.ts", 364);
                            akra.logger.error("cannot read influence data");
                            ;
                        }
                        akra.logger.setSourceLocation("Skin.ts", 367);
                        akra.logger.log(pInfData[0], '<< matrix location');
                        ;
                        akra.logger.setSourceLocation("Skin.ts", 368);
                        akra.logger.log(pInfData[1], '/', pInfData[1] - 30432, '<< weight location / index');
                        ;
                        var pWeightData = new Float32Array(4);
                        if(!pVideoBuffer.readData(4 * (pInfData[1]), 4, pWeightData)) {
                            akra.logger.setSourceLocation("Skin.ts", 373);
                            akra.logger.error("cannot read weight data");
                            ;
                        }
                        akra.logger.setSourceLocation("Skin.ts", 376);
                        akra.logger.log(pWeightData[0], '<< weight');
                        ;
                        var pMatrixData = new Float32Array(4 * 16);
                        if(!pVideoBuffer.readData(4 * (pInfData[0]), 4 * 16, pMatrixData)) {
                            akra.logger.setSourceLocation("Skin.ts", 380);
                            akra.logger.error("cannot read matrix data");
                            ;
                        }
                        akra.logger.setSourceLocation("Skin.ts", 383);
                        akra.logger.log(pMatrixData.toString());
                        ;
                    }
                }
                akra.logger.setSourceLocation("Skin.ts", 387);
                akra.logger.log('#############################################');
                ;
                for(var i = 0; i < pPosData.length; i++) {
                    var pMetaData = new Float32Array(8);
                    if(!pVideoBuffer.readData(4 * pPosData[i], 8, pMetaData)) {
                        akra.logger.setSourceLocation("Skin.ts", 392);
                        akra.logger.error("cannot read meta data");
                        ;
                    }
                    for(var j = 0; j < pMetaData[0]; ++j) {
                        var pInfData = new Float32Array(8);
                        if(!pVideoBuffer.readData(4 * (pMetaData[1] + 2 * j), 8, pInfData)) {
                            akra.logger.setSourceLocation("Skin.ts", 399);
                            akra.logger.error("cannot read influence data");
                            ;
                        }
                        var iWeightsIndex = pInfData[1] - 30432;
                        var fWeightOrigin = pWeights[iWeightsIndex];
                        var pWeightData = new Float32Array(4);
                        if(!pVideoBuffer.readData(4 * (pInfData[1]), 4, pWeightData)) {
                            akra.logger.setSourceLocation("Skin.ts", 407);
                            akra.logger.error("cannot read weight data");
                            ;
                        }
                        var fWeight = pWeightData[0];
                        if(Math.abs(fWeight - fWeightOrigin) > 0.001) {
                            alert("1");
                            akra.logger.setSourceLocation("Skin.ts", 413);
                            akra.logger.log("weight with index", iWeightsIndex, "has wrong weight", fWeightOrigin, "/", fWeightOrigin);
                            ;
                        }
                        //var pWeightData: Float32Array = new Float32Array(pVideoBuffer.getData(4 * (pInfData[1]), 4));
                        //var pMatrixData: Float32Array = new Float32Array(pVideoBuffer.getData(4 * (pInfData[0]), 4 * 16));
                                            }
                }
                akra.logger.setSourceLocation("Skin.ts", 421);
                akra.logger.log('##############################################');
                ;
                // var pBoneTransformMatrices = pSkin._pBoneTransformMatrixData;
                // var pBonetmData = pBoneTransformMatrices.getTypedData('BONE_MATRIX');
                // for (var i = 0; i < pBonetmData.length; i += 16) {
                //     LOG('bone transform matrix data >>> ');
                //     LOG(Mat4.str(pBonetmData.subarray(i, i + 16)));
                // };
                //for (var i = 0; i < pMesh.length; i++) {
                // var i = pMesh.length - 1;
                //     var pPosData = pMesh[i].data.getData('POSITION').getTypedData('POSITION');
                //     var pIndData = pMesh[i].data._pIndexData.getTypedData('INDEX0');
                //     var j = pIndData[pIndData.length - 1];
                //     var j0 = pMesh[i].data.getData('POSITION').byteOffset/4;
                //     j -= j0;
                //     j/=4;
                //     LOG('last index >> ', j);
                //     LOG('pos data size', pPosData.length);
                //     var pVertex = pPosData.subarray(j * 3, j * 3 + 3);
                //     LOG('last vertex in submesh >> ', pVertex[0], pVertex[1], pVertex[2]);
                //         var pSceneNode = pEngine.appendMesh(
                //             pEngine.pCubeMesh.clone(a.Mesh.GEOMETRY_ONLY|a.Mesh.SHARED_GEOMETRY),
                //             pEngine.getRootNode());
                //         pSceneNode.setPosition(pVertex);
                //         pSceneNode.setScale(0.1);
                //     var pMeta = pSkin.getInfluenceMetaData().getTypedData('BONE_INF_COUNT');
                //     LOG(pMeta[j], 'count << ');
                //};
                            };
            return Skin;
        })();
        model.Skin = Skin;        
        function /** @no-inline */createSkin(pMesh) {
            return new Skin(pMesh);
        }
        model.createSkin = createSkin;
    })(akra.model || (akra.model = {}));
    var model = akra.model;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (geometry) {
        var Ray2d = (function () {
            function /** @no-inline */Ray2d() {
                this.point = new akra.Vec2();
                this.normal = new akra.Vec2();
            }
            return Ray2d;
        })();
        geometry.Ray2d = Ray2d;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (geometry) {
        var Ray3d = (function () {
            function /** @no-inline */Ray3d() {
                this.point = new akra.Vec3();
                this.normal = new akra.Vec3();
            }
            return Ray3d;
        })();
        geometry.Ray3d = Ray3d;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (geometry) {
        var Segment2d = (function () {
            function /** @no-inline */Segment2d() {
                this.ray = new geometry.Ray2d();
                this.distance = 0.;
            }
            Object.defineProperty(Segment2d.prototype, "point", {
                get: function /** @no-inline */() {
                    return this.ray.point;
                },
                set: function /** @no-inline */(v2fPoint) {
                    this.ray.point.set(v2fPoint);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Segment2d.prototype, "normal", {
                get: function /** @no-inline */() {
                    return this.ray.normal;
                },
                set: function /** @no-inline */(v2fNormal) {
                    this.ray.normal.set(v2fNormal);
                },
                enumerable: true,
                configurable: true
            });
            return Segment2d;
        })();
        geometry.Segment2d = Segment2d;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (geometry) {
        var Segment3d = (function () {
            function /** @no-inline */Segment3d() {
                this.ray = new geometry.Ray3d();
                this.distance = 0.;
            }
            Object.defineProperty(Segment3d.prototype, "point", {
                get: function /** @no-inline */() {
                    return this.ray.point;
                },
                set: function /** @no-inline */(v3fPoint) {
                    this.ray.point.set(v3fPoint);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Segment3d.prototype, "normal", {
                get: function /** @no-inline */() {
                    return this.ray.normal;
                },
                set: function /** @no-inline */(v3fNormal) {
                    this.ray.normal.set(v3fNormal);
                },
                enumerable: true,
                configurable: true
            });
            return Segment3d;
        })();
        geometry.Segment3d = Segment3d;        
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (geometry) {
        function /** @no-inline */intersectPlane2dRay2d(pPlane, pRay) {
            var fDistance = pPlane.signedDistance(pRay.point);
            var fNdotV = pPlane.normal.dot(pRay.normal);
            if(fDistance == 0.) {
                return true;
            } else {
                if(fNdotV == 0.) {
                    return false;
                } else {
                    if(fDistance / fNdotV < 0.) {
                        return true;
                    } else {
                        return false;
                    }
                }
            }
        }
        geometry.intersectPlane2dRay2d = intersectPlane2dRay2d;
        ;
        function /** @no-inline */intersectPlane3dRay3d(pPlane, pRay) {
            var fDistance = pPlane.signedDistance(pRay.point);
            var fNdotV = pPlane.normal.dot(pRay.normal);
            if(fDistance == 0.) {
                return true;
            } else {
                if(fNdotV == 0.) {
                    return false;
                } else {
                    if(fDistance / fNdotV < 0.) {
                        return true;
                    } else {
                        return false;
                    }
                }
            }
        }
        geometry.intersectPlane3dRay3d = intersectPlane3dRay3d;
        ;
        function /** @no-inline */intersectCircleRay2d(pCircle, pRay) {
            var v2fCenterToPoint = pRay.point.subtract(pCircle.center, akra.vec2());
            var v2fNormal = pRay.normal;
            //a*t^2+ 2b*t + c = 0;
            var fA = v2fNormal.lengthSquare();
            var fB = v2fCenterToPoint.dot(v2fNormal);
            var fC = v2fCenterToPoint.lengthSquare() - pCircle.radius * pCircle.radius;
            /*b^2/4 - a*c*/
            var fDiscriminant = fB * fB - fA * fC;
            if(fDiscriminant < 0.) {
                return false;
            }
            var fSqrtDiscriminant = akra.math.sqrt(fDiscriminant);
            var fT1 = (-fB + fSqrtDiscriminant) / fA;
            //var fT2: float = (-fB - fSqrtDiscriminant)/fA;
            //fT2 don't needed because fT2 < fT1 always
            //since fA > 0
            if(fT1 < 0.) {
                return false;
            } else {
                return true;
            }
        }
        geometry.intersectCircleRay2d = intersectCircleRay2d;
        ;
        function /** @no-inline */intersectSphereRay3d(pSphere, pRay) {
            var v3fCenterToPoint = pRay.point.subtract(pSphere.center, akra.vec3());
            var v3fNormal = pRay.normal;
            //a*t^2+ 2b*t + c = 0;
            var fA = v3fNormal.lengthSquare();
            var fB = v3fCenterToPoint.dot(v3fNormal);
            var fC = v3fCenterToPoint.lengthSquare() - pSphere.radius * pSphere.radius;
            /*b^2/4 - a*c*/
            var fDiscriminant = fB * fB - fA * fC;
            if(fDiscriminant < 0.) {
                return false;
            }
            var fSqrtDiscriminant = akra.math.sqrt(fDiscriminant);
            var fT1 = (-fB + fSqrtDiscriminant) / fA;
            //var fT2: float = (-fB - fSqrtDiscriminant)/fA;
            //fT2 don't needed because fT2 < fT1 always
            //since fA > 0
            if(fT1 < 0.) {
                return false;
            } else {
                return true;
            }
        }
        geometry.intersectSphereRay3d = intersectSphereRay3d;
        ;
        function /** @no-inline */intersectRect2dRay2d(pRect, pRay) {
            var v2fNormal = pRay.normal;
            var v2fPoint = pRay.point;
            var fT1, fT2;
            var fX1, fX2;
            var fY1, fY2;
            if(v2fNormal.x != 0.) {
                fT1 = (pRect.x0 - v2fPoint.x) / v2fNormal.x;
                fT2 = (pRect.x1 - v2fPoint.x) / v2fNormal.x;
            } else {
                fT1 = (pRect.y0 - v2fPoint.y) / v2fNormal.y;
                fT2 = (pRect.y1 - v2fPoint.y) / v2fNormal.y;
            }
            if(fT1 < 0 && fT2 < 0) {
                return false;
            }
            fT1 = akra.math.max(fT1, 0.);
            fT2 = akra.math.max(fT2, 0.);
            fX1 = v2fPoint.x + fT1 * v2fNormal.x;
            fX2 = v2fPoint.x + fT2 * v2fNormal.x;
            fY1 = v2fPoint.y + fT1 * v2fNormal.y;
            fY2 = v2fPoint.y + fT2 * v2fNormal.y;
            if((fX1 < pRect.x0 && fX2 < pRect.x0) || (fX1 > pRect.x1 && fX2 > pRect.x1) || (fY1 < pRect.y0 && fY2 < pRect.y0) || (fY1 > pRect.y1 && fY2 > pRect.y1)) {
                return false;
            }
            return true;
        }
        geometry.intersectRect2dRay2d = intersectRect2dRay2d;
        ;
        function /** @no-inline */intersectRect3dRay3d(pRect, pRay) {
            var v3fNormal = pRay.normal;
            var v3fPoint = pRay.point;
            var fT1, fT2;
            var fX1, fX2;
            var fY1, fY2;
            var fZ1, fZ2;
            if(v3fNormal.x != 0.) {
                fT1 = (pRect.x0 - v3fPoint.x) / v3fNormal.x;
                fT2 = (pRect.x1 - v3fPoint.x) / v3fNormal.x;
            } else if(v3fNormal.y != 0.) {
                fT1 = (pRect.y0 - v3fPoint.y) / v3fNormal.y;
                fT2 = (pRect.y1 - v3fPoint.y) / v3fNormal.y;
            } else {
                fT1 = (pRect.z0 - v3fPoint.z) / v3fNormal.z;
                fT2 = (pRect.z1 - v3fPoint.z) / v3fNormal.z;
            }
            if(fT1 < 0 && fT2 < 0) {
                return false;
            }
            fT1 = akra.math.max(fT1, 0.);
            fT2 = akra.math.max(fT2, 0.);
            fX1 = v3fPoint.x + fT1 * v3fNormal.x;
            fX2 = v3fPoint.x + fT2 * v3fNormal.x;
            fY1 = v3fPoint.y + fT1 * v3fNormal.y;
            fY2 = v3fPoint.y + fT2 * v3fNormal.y;
            fZ1 = v3fPoint.z + fT1 * v3fNormal.z;
            fZ2 = v3fPoint.z + fT2 * v3fNormal.z;
            if((fX1 < pRect.x0 && fX2 < pRect.x0) || (fX1 > pRect.x1 && fX2 > pRect.x1) || (fY1 < pRect.y0 && fY2 < pRect.y0) || (fY1 > pRect.y1 && fY2 > pRect.y1) || (fZ1 < pRect.z0 && fZ2 < pRect.z0) || (fZ1 > pRect.z1 && fZ2 > pRect.z1)) {
                return false;
            }
            return true;
        }
        geometry.intersectRect3dRay3d = intersectRect3dRay3d;
        ;
        function /** @no-inline */intersectCircleCircle(pCircle1, pCircle2) {
            var v2fCenter1 = pCircle1.center;
            var v2fCenter2 = pCircle2.center;
            var fX = v2fCenter2.x - v2fCenter1.x;
            var fY = v2fCenter2.y - v2fCenter1.y;
            var fContactRadius = pCircle1.radius + pCircle2.radius;
            if((fX * fX + fY * fY) > fContactRadius * fContactRadius) {
                return false;
            }
            return true;
        }
        geometry.intersectCircleCircle = intersectCircleCircle;
        ;
        function /** @no-inline */intersectSphereSphere(pSphere1, pSphere2) {
            var v3fCenter1 = pSphere1.center;
            var v3fCenter2 = pSphere2.center;
            var fX = v3fCenter2.x - v3fCenter1.x;
            var fY = v3fCenter2.y - v3fCenter1.y;
            var fZ = v3fCenter2.z - v3fCenter1.z;
            var fContactRadius = pSphere1.radius + pSphere2.radius;
            if((fX * fX + fY * fY + fZ * fZ) > fContactRadius * fContactRadius) {
                return false;
            }
            return true;
        }
        geometry.intersectSphereSphere = intersectSphereSphere;
        ;
        function /** @no-inline */intersectRect2dCircle(pRect, pCircle) {
            var v2fCenter = pCircle.center;
            var fOffsetX = 0., fOffsetY = 0.;
            var nInside = 0;
            if(v2fCenter.x < pRect.x0) {
                fOffsetX = pRect.x0 - v2fCenter.x;
            } else if(v2fCenter.x > pRect.x1) {
                fOffsetX = v2fCenter.x - pRect.x1;
            } else {
                nInside++;
            }
            if(v2fCenter.y < pRect.y0) {
                fOffsetY = pRect.y0 - v2fCenter.y;
            } else if(v2fCenter.y > pRect.y1) {
                fOffsetY = v2fCenter.y - pRect.y1;
            } else {
                nInside++;
            }
            //if nInside == 2 then circle inside rect
            if(nInside === 2) {
                return true;
            }
            var fOffsetLengthSquare = fOffsetX * fOffsetX + fOffsetY * fOffsetY;
            var fRadius = pCircle.radius;
            if(fOffsetLengthSquare > fRadius * fRadius) {
                return false;
            }
            return true;
        }
        geometry.intersectRect2dCircle = intersectRect2dCircle;
        ;
        function /** @no-inline */intersectRect3dSphere(pRect, pSphere) {
            var v3fCenter = pSphere.center;
            var fOffsetX = 0., fOffsetY = 0., fOffsetZ = 0.;
            var nInside = 0;
            if(v3fCenter.x < pRect.x0) {
                fOffsetX = pRect.x0 - v3fCenter.x;
            } else if(v3fCenter.x > pRect.x1) {
                fOffsetX = v3fCenter.x - pRect.x1;
            } else {
                nInside++;
            }
            if(v3fCenter.y < pRect.y0) {
                fOffsetY = pRect.y0 - v3fCenter.y;
            } else if(v3fCenter.y > pRect.y1) {
                fOffsetY = v3fCenter.y - pRect.y1;
            } else {
                nInside++;
            }
            if(v3fCenter.z < pRect.z0) {
                fOffsetZ = pRect.z0 - v3fCenter.z;
            } else if(v3fCenter.z > pRect.z1) {
                fOffsetZ = v3fCenter.z - pRect.z1;
            } else {
                nInside++;
            }
            //if nInside == 3 then sphere inside rect
            if(nInside === 3) {
                return true;
            }
            var fOffsetLengthSquare = fOffsetX * fOffsetX + fOffsetY * fOffsetY + fOffsetZ * fOffsetZ;
            var fRadius = pSphere.radius;
            if(fOffsetLengthSquare > fRadius * fRadius) {
                return false;
            }
            return true;
        }
        geometry.intersectRect3dSphere = intersectRect3dSphere;
        ;
        function /** @no-inline */intersectRect2dRect2d(pRect1, pRect2, pResult) {
            if(!akra.isDef(pResult)) {
                var fX0 = akra.math.max(pRect1.x0, pRect2.x0);
                var fX1 = akra.math.min(pRect1.x1, pRect2.x1);
                if(fX0 <= fX1) {
                    var fY0 = akra.math.max(pRect1.y0, pRect2.y0);
                    var fY1 = akra.math.min(pRect1.y1, pRect2.y1);
                    if(fY0 <= fY1) {
                        return true;
                    }
                }
                return false;
            } else {
                pResult.x0 = akra.math.max(pRect1.x0, pRect2.x0);
                pResult.x1 = akra.math.min(pRect1.x1, pRect2.x1);
                pResult.y0 = akra.math.max(pRect1.y0, pRect2.y0);
                pResult.y1 = akra.math.min(pRect1.y1, pRect2.y1);
                return pResult.isValid();
            }
        }
        geometry.intersectRect2dRect2d = intersectRect2dRect2d;
        ;
        function /** @no-inline */intersectRect3dRect3d(pRect1, pRect2, pResult) {
            if(!akra.isDef(pResult)) {
                var fX0 = akra.math.max(pRect1.x0, pRect2.x0);
                var fX1 = akra.math.min(pRect1.x1, pRect2.x1);
                if(fX0 <= fX1) {
                    var fY0 = akra.math.max(pRect1.y0, pRect2.y0);
                    var fY1 = akra.math.min(pRect1.y1, pRect2.y1);
                    if(fY0 <= fY1) {
                        var fZ0 = akra.math.max(pRect1.z0, pRect2.z0);
                        var fZ1 = akra.math.min(pRect1.z1, pRect2.z1);
                        if(fZ0 <= fZ1) {
                            return true;
                        }
                    }
                }
                return false;
            } else {
                pResult.x0 = akra.math.max(pRect1.x0, pRect2.x0);
                pResult.x1 = akra.math.min(pRect1.x1, pRect2.x1);
                pResult.y0 = akra.math.max(pRect1.y0, pRect2.y0);
                pResult.y1 = akra.math.min(pRect1.y1, pRect2.y1);
                pResult.z0 = akra.math.max(pRect1.z0, pRect2.z0);
                pResult.z1 = akra.math.min(pRect1.z1, pRect2.z1);
                return pResult.isValid();
            }
        }
        geometry.intersectRect3dRect3d = intersectRect3dRect3d;
        ;
                                                                                                        function /** @no-inline */intersect(pRect1, pRect2, pResult) {
            var nArgumentsLength = arguments.length;
            if(nArgumentsLength === 3) {
                if(arguments[2] instanceof geometry.Rect2d) {
                    return intersectRect2dRect2d(arguments[0], arguments[1], arguments[2]);
                } else {
                    return intersectRect3dRect3d(arguments[0], arguments[1], arguments[2]);
                }
            } else {
                var pArg0 = arguments[0];
                var pArg1 = arguments[1];
                if(pArg1 instanceof geometry.Ray2d) {
                    if(pArg0 instanceof geometry.Plane2d) {
                        return intersectPlane2dRay2d(pArg0, pArg1);
                    } else if(pArg0 instanceof geometry.Circle) {
                        return intersectCircleRay2d(pArg0, pArg1);
                    } else {
                        return intersectRect2dRay2d(pArg0, pArg1);
                    }
                } else if(pArg1 instanceof geometry.Ray3d) {
                    if(pArg0 instanceof geometry.Plane3d) {
                        return intersectPlane3dRay3d(pArg0, pArg1);
                    } else if(pArg0 instanceof geometry.Sphere) {
                        return intersectSphereRay3d(pArg0, pArg1);
                    } else {
                        return intersectRect3dRay3d(pArg0, pArg1);
                    }
                } else if(pArg1 instanceof geometry.Circle) {
                    if(pArg0 instanceof geometry.Circle) {
                        return intersectCircleCircle(pArg0, pArg1);
                    } else {
                        return intersectRect2dCircle(pArg0, pArg1);
                    }
                } else if(pArg1 instanceof geometry.Sphere) {
                    if(pArg0 instanceof geometry.Sphere) {
                        return intersectSphereSphere(pArg0, pArg1);
                    } else {
                        return intersectRect3dSphere(pArg0, pArg1);
                    }
                } else {
                    if(pArg0 instanceof geometry.Rect2d) {
                        return intersectRect2dRect2d(pArg0, pArg1);
                    } else {
                        return intersectRect3dRect3d(pArg0, pArg1);
                    }
                }
            }
        }
        geometry.intersect = intersect;
        ;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
;
var akra;
(function (akra) {
    (function (geometry) {
                                                                /**
        * Computes a coordinate-axis oriented bounding box.
        */
        function /** @no-inline */computeBoundingBox(pVertexData, pBoundingBox) {
            var fX0 = 0, fY0 = 0, fZ0 = 0, fX1 = 0, fY1 = 0, fZ1 = 0;
            var fTemp, pTempData;
            var i = 0;
            var pVertexDeclaration, pVertexElement, pData;
            var nStride, nCount;
            pVertexDeclaration = pVertexData.getVertexDeclaration();
            if(akra.isNull(pVertexDeclaration)) {
                return false;
            }
            pVertexElement = pVertexDeclaration.findElement(akra.DeclUsages.POSITION, 3);
            if(akra.isNull(pVertexElement)) {
                return false;
            }
            nCount = pVertexData.length;
            nStride = pVertexElement.size;
            pData = pVertexData.getData(pVertexElement.offset, pVertexElement.size);
            if(akra.isNull(pData)) {
                return false;
            }
            pTempData = new Float32Array(pData, 0, 3);
            fX0 = fX1 = pTempData[0];
            fY0 = fY1 = pTempData[1];
            fZ0 = fZ1 = pTempData[2];
            for(i = nStride; i < nStride * nCount; i += nStride) {
                pTempData = new Float32Array(pData, i, 3);
                fTemp = pTempData[0];
                //Min			fX0 = fX0 > fTemp ? fTemp : fX0;
                //Max			fX1 = fX1 > fTemp ? fX1 : fTemp;
                fTemp = pTempData[1];
                //Min			fY0 = fY0 > fTemp ? fTemp : fY0;
                //Max			fY1 = fY1 > fTemp ? fY1 : fTemp;
                fTemp = pTempData[2];
                //Min			fZ0 = fZ0 > fTemp ? fTemp : fZ0;
                //Max			fZ1 = fZ1 > fTemp ? fZ1 : fTemp;
                            }
            pBoundingBox.set(fX0, fX1, fY0, fY1, fZ0, fZ1);
            return true;
        }
        geometry.computeBoundingBox = computeBoundingBox;
        ;
        /** расчет данных для отрисовки бокса */
        function /** @no-inline */computeDataForCascadeBoundingBox(pBoundingBox, ppVertexes, ppIndexes, fMinSize) {
            if (typeof fMinSize === "undefined") { fMinSize = .25; }
            var pInd;
            var pPoints;
            var i, j, k;
            pPoints = new Array(8);
            for(i = 0; i < 8; i++) {
                pPoints[i] = new Array(4);
                for(j = 0; j < 4; j++) {
                    pPoints[i][j] = new akra.Vec3(0);
                }
            }
            //Выставление точек Rect3d
            pPoints[0][0].set([
                pBoundingBox.x0, 
                pBoundingBox.y0, 
                pBoundingBox.z0
            ]);
            pPoints[1][0].set([
                pBoundingBox.x0, 
                pBoundingBox.y1, 
                pBoundingBox.z0
            ]);
            pPoints[2][0].set([
                pBoundingBox.x0, 
                pBoundingBox.y0, 
                pBoundingBox.z1
            ]);
            pPoints[3][0].set([
                pBoundingBox.x0, 
                pBoundingBox.y1, 
                pBoundingBox.z1
            ]);
            pPoints[4][0].set([
                pBoundingBox.x1, 
                pBoundingBox.y0, 
                pBoundingBox.z0
            ]);
            pPoints[5][0].set([
                pBoundingBox.x1, 
                pBoundingBox.y1, 
                pBoundingBox.z0
            ]);
            pPoints[6][0].set([
                pBoundingBox.x1, 
                pBoundingBox.y0, 
                pBoundingBox.z1
            ]);
            pPoints[7][0].set([
                pBoundingBox.x1, 
                pBoundingBox.y1, 
                pBoundingBox.z1
            ]);
            var fTempFunc = function /** @no-inline */(pPoints, iPoint, iToPoint1, iToPoint2, iToPoint3) {
                for(var i = 0; i < 3; i++) {
                    pPoints[arguments[i + 2]][0].subtract(pPoints[iPoint][0], pPoints[iPoint][i + 1]);
                    if(pPoints[iPoint][i + 1].length() > fMinSize) {
                        pPoints[iPoint][i + 1].scale(0.1);
                    }
                    pPoints[iPoint][i + 1].add(pPoints[iPoint][0]);
                }
            };
            fTempFunc(pPoints, 0, 1, 2, 4);
            fTempFunc(pPoints, 1, 0, 3, 5);
            fTempFunc(pPoints, 2, 0, 3, 6);
            fTempFunc(pPoints, 3, 1, 2, 7);
            fTempFunc(pPoints, 4, 0, 5, 6);
            fTempFunc(pPoints, 5, 1, 4, 7);
            fTempFunc(pPoints, 6, 2, 4, 7);
            fTempFunc(pPoints, 7, 3, 5, 6);
            for(i = 0; i < 8; i++) {
                for(j = 0; j < 4; j++) {
                    ppVertexes[i * 12 + j * 3 + 0] = pPoints[i][j].x;
                    ppVertexes[i * 12 + j * 3 + 1] = pPoints[i][j].y;
                    ppVertexes[i * 12 + j * 3 + 2] = pPoints[i][j].z;
                }
            }
            pInd = [
                0, 
                1, 
                0, 
                2, 
                0, 
                3, 
                4, 
                5, 
                4, 
                6, 
                4, 
                7, 
                8, 
                9, 
                8, 
                10, 
                8, 
                11, 
                12, 
                13, 
                12, 
                14, 
                12, 
                15, 
                16, 
                17, 
                16, 
                18, 
                16, 
                19, 
                20, 
                21, 
                20, 
                22, 
                20, 
                23, 
                24, 
                25, 
                24, 
                26, 
                24, 
                27, 
                28, 
                29, 
                28, 
                30, 
                28, 
                31
            ];
            for(var i = 0; i < pInd.length; ++i) {
                ppIndexes[i] = pInd[i];
            }
            return true;
        }
        geometry.computeDataForCascadeBoundingBox = computeDataForCascadeBoundingBox;
        /** подсчет обобщающей сферы над двумя сферами */
        function /** @no-inline */computeGeneralizingSphere(pSphereA, pSphereB, pSphereDest) {
            if(!akra.isDef(pSphereDest)) {
                pSphereDest = pSphereA;
            }
            var fR1 = pSphereA.radius;
            var fR2 = pSphereB.radius;
            var v3fC1 = pSphereA.center;
            var v3fC2 = pSphereB.center;
            var v3fD = new akra.Vec3();
            v3fC1.subtract(v3fC2, v3fD);
            var fD = v3fD.length();
            if(fD < fR1 && fR1 > fR2) {
                pSphereDest.set(pSphereA);
                return false;
            }
            if(fD < fR2) {
                pSphereDest.set(pSphereB);
                return false;
            }
            var v3fN = new akra.Vec3();
            v3fD.normalize(v3fN);
            pSphereDest.radius = v3fD.add(v3fN.scale(fR1 + fR2)).length() / 2.0;
            var v3fTemp = v3fD;
            pSphereDest.center = v3fC1.add(v3fC2, v3fTemp).add(v3fN.scale((fR1 - fR2) / (fR1 + fR2))).scale(.5);
            return true;
        }
        geometry.computeGeneralizingSphere = computeGeneralizingSphere;
        /** расчет данных для отрисовки сферы */
        function /** @no-inline */computeDataForCascadeBoundingSphere(pBoundingSphere, ppVertexes, ppIndexes, fMinSize) {
            if (typeof fMinSize === "undefined") { fMinSize = 0.25; }
            var fTheta, fDelta, fAlpha;
            var nCount = 10;
            var i, j, k, a;
            fDelta = 2 * Math.PI / nCount;
            for(i = 0; i <= nCount / 2; i++) {
                fTheta = -Math.PI + (i * fDelta);
                for(j = 0; j <= nCount; j++) {
                    fAlpha = j * fDelta;
                    ppVertexes[(i * (nCount + 1) + j) * 3 + 0] = pBoundingSphere.center.x + pBoundingSphere.radius * Math.sin(fTheta) * Math.cos(fAlpha);
                    ppVertexes[(i * (nCount + 1) + j) * 3 + 1] = pBoundingSphere.center.y + pBoundingSphere.radius * Math.sin(fTheta) * Math.sin(fAlpha);
                    ppVertexes[(i * (nCount + 1) + j) * 3 + 2] = pBoundingSphere.center.z + pBoundingSphere.radius * Math.cos(fTheta);
                }
            }
            for(i = 0; i < nCount / 2; i++) {
                for(j = 0; j < nCount; j++) {
                    ppIndexes[(i * (nCount) + j) * 12 + 0] = i * (nCount + 1) + j;
                    ppIndexes[(i * (nCount) + j) * 12 + 1] = i * (nCount + 1) + j + 1;
                    ppIndexes[(i * (nCount) + j) * 12 + 2] = i * (nCount + 1) + j + 2 + nCount;
                    ppIndexes[(i * (nCount) + j) * 12 + 3] = i * (nCount + 1) + j;
                    ppIndexes[(i * (nCount) + j) * 12 + 4] = i * (nCount + 1) + j + 1;
                    ppIndexes[(i * (nCount) + j) * 12 + 5] = i * (nCount + 1) + j + 2 + nCount;
                    ppIndexes[(i * (nCount) + j) * 12 + 6] = i * (nCount + 1) + j;
                    ppIndexes[(i * (nCount) + j) * 12 + 7] = i * (nCount + 1) + j + 1 + nCount;
                    ppIndexes[(i * (nCount) + j) * 12 + 8] = i * (nCount + 1) + j + 2 + nCount;
                    ppIndexes[(i * (nCount) + j) * 12 + 9] = i * (nCount + 1) + j + 1 + nCount;
                    ppIndexes[(i * (nCount) + j) * 12 + 10] = i * (nCount + 1) + j + 2 + nCount;
                    ppIndexes[(i * (nCount) + j) * 12 + 11] = i * (nCount + 1) + j;
                }
            }
            return true;
        }
        geometry.computeDataForCascadeBoundingSphere = computeDataForCascadeBoundingSphere;
        /**
        * Computes a bounding sphere.
        * При использование быстрого вычисления, опционально можно получить баундинг бокс.
        */
        function /** @no-inline */computeBoundingSphere(pVertexData, pSphere, bFastMethod, pBoundingBox) {
            if (typeof bFastMethod === "undefined") { bFastMethod = true; }
            if (typeof pBoundingBox === "undefined") { pBoundingBox = null; }
            if(bFastMethod) {
                return computeBoundingSphereFast(pVertexData, pSphere, pBoundingBox);
            } else {
                return computeBoundingSphereMinimal(pVertexData, pSphere);
            }
        }
        geometry.computeBoundingSphere = computeBoundingSphere;
        /**
        * Computes a bounding sphere - not minimal. Also if it need compute dounding box
        */
        function /** @no-inline */computeBoundingSphereFast(pVertexData, pSphere, pBoundingBox) {
            if (typeof pBoundingBox === "undefined") { pBoundingBox = null; }
            var i;
            var pVertexDeclaration, pVertexElement;
            var nCount, nStride;
            var pData, pTempData;
            pVertexDeclaration = pVertexData.getVertexDeclaration();
            if(akra.isNull(pVertexDeclaration)) {
                return false;
            }
            pVertexElement = pVertexDeclaration.findElement(akra.DeclUsages.POSITION, 3);
            if(akra.isNull(pVertexElement)) {
                return false;
            }
            nCount = pVertexData.length;
            nStride = pVertexElement.size;
            pData = pVertexData.getData(pVertexElement.offset, pVertexElement.size);
            if(akra.isNull(pData)) {
                return false;
            }
            if(akra.isNull(pBoundingBox)) {
                pBoundingBox = geometry.Rect3d.stackCeil;
            }
            if(pBoundingBox.isClear()) {
                if(!computeBoundingBox(pVertexData, pBoundingBox)) {
                    return false;
                }
            }
            var fCenterX = (pBoundingBox.x0 + pBoundingBox.x1) / 2;
            var fCenterY = (pBoundingBox.y0 + pBoundingBox.y1) / 2;
            var fCenterZ = (pBoundingBox.z0 + pBoundingBox.z1) / 2;
            var fRadius = 0;
            var fDistance = 0;
            for(i = 0; i < nStride * nCount; i += nStride) {
                pTempData = new Float32Array(pData, i, 3);
                fDistance = (pTempData[0] - fCenterX) * (pTempData[0] - fCenterX) + (pTempData[1] - fCenterY) * (pTempData[1] - fCenterY) + (pTempData[2] - fCenterZ) * (pTempData[2] - fCenterZ);
                fRadius = fDistance > fRadius ? fDistance : fRadius;
            }
            pSphere.set(fCenterX, fCenterY, fCenterZ, Math.sqrt(fRadius));
            return true;
        }
        geometry.computeBoundingSphereFast = computeBoundingSphereFast;
        /**
        * Computes a bounding sphere - minimal.
        */
        function /** @no-inline */computeBoundingSphereMinimal(pVertexData, pSphere) {
            var i = 0, j = 0, k = 0;
            var points = [];
            var length = 0;
            var isAdd = false;
            var isNew = true;
            var fDiametr = 0;
            var fDistance = 0;
            var pVertexDeclaration, pVertexElement;
            var nCount, nStride;
            var pData, pTempData1, pTempData2;
            pVertexDeclaration = pVertexData.getVertexDeclaration();
            if(akra.isNull(pVertexData)) {
                return false;
            }
            if(akra.isNull(pVertexDeclaration)) {
                return false;
            }
            pVertexElement = pVertexDeclaration.findElement(akra.DeclUsages.POSITION, 3);
            if(akra.isNull(pVertexElement)) {
                return false;
            }
            nCount = pVertexData.length;
            nStride = pVertexElement.size;
            pData = pVertexData.getData(pVertexElement.offset, pVertexElement.size);
            if(!pData) {
                return false;
            }
            for(i = 0; i < nStride * nCount; i += nStride) {
                isNew = true;
                isAdd = false;
                pTempData1 = new Float32Array(pData, i, 3);
                for(k = 0; k < points.length; k += 3) {
                    if(points[k] == pTempData1[0] && points[k + 1] == pTempData1[1] && points[k + 2] == pTempData1[2]) {
                        isNew = false;
                        break;
                    }
                }
                if(isNew) {
                    for(j = i + nStride; j < nStride * nCount; j += nStride) {
                        pTempData2 = new Float32Array(pData, j, 3);
                        fDistance = (pTempData1[0] - pTempData2[0]) * (pTempData1[0] - pTempData2[0]) + (pTempData1[1] - pTempData2[1]) * (pTempData1[1] - pTempData2[1]) + (pTempData1[2] - pTempData2[2]) * (pTempData1[2] - pTempData2[2]);
                        if(fDistance > fDiametr) {
                            fDiametr = fDistance;
                            isAdd = true;
                            points[0] = pTempData2[0];
                            points[1] = pTempData2[1];
                            points[2] = pTempData2[2];
                            length = 3;
                        } else if(fDistance.toFixed(7) == fDiametr.toFixed(7)) {
                            isAdd = true;
                            for(k = 0; k < points.length; k += 3) {
                                if(points[k] == pTempData2[0] && points[k + 1] == pTempData2[1] && points[k + 2] == pTempData2[2]) {
                                    isNew = false;
                                    break;
                                }
                            }
                            if(isNew) {
                                points[length] = pTempData2[0];
                                points[length + 1] = pTempData2[1];
                                points[length + 2] = pTempData2[2];
                                length += 3;
                            }
                        }
                    }
                    if(isAdd) {
                        points[length] = pTempData1[0];
                        points[length + 1] = pTempData1[1];
                        points[length + 2] = pTempData1[2];
                        length += 3;
                    }
                }
            }
            var fX = 0, fY = 0, fZ = 0;
            for(i = 0; i < points.length; i += 3) {
                fX += points[i];
                fY += points[i + 1];
                fZ += points[i + 2];
            }
            var x = pSphere.center.x = fX / points.length * 3;
            var y = pSphere.center.y = fY / points.length * 3;
            var z = pSphere.center.z = fZ / points.length * 3;
            pSphere.radius = Math.sqrt((points[0] - x) * (points[0] - x) + (points[1] - y) * (points[1] - y) + (points[2] - z) * (points[2] - z));
            return true;
        }
        geometry.computeBoundingSphereMinimal = computeBoundingSphereMinimal;
    })(akra.geometry || (akra.geometry = {}));
    var geometry = akra.geometry;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (model) {
        var MeshSubset = (function (_super) {
            __extends(MeshSubset, _super);
            function /** @no-inline */MeshSubset(pMesh, pRenderData, sName) {
                if (typeof sName === "undefined") { sName = null; }
                        _super.call(this);
                /**@protected*/ this._pRenderData = null;
                /**@protected*/ this._sName = null;
                /**@protected*/ this._pMesh = null;
                /**@protected*/ this._pSkin = null;
                /**@protected*/ this._pBoundingBox = null;
                /**@protected*/ this._pBoundingSphere = null;
                this._iGuid = eval("this._iGuid || akra.sid()");
                this._pUnicastSlotMap = null;
                this._pBroadcastSlotList = null;
                this.setup(pMesh, pRenderData, sName);
            }
            Object.defineProperty(MeshSubset.prototype, "boundingBox", {
                get: function /** @inline */() {
                    return this._pBoundingBox;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MeshSubset.prototype, "boundingSphere", {
                get: function /** @inline */() {
                    return this._pBoundingSphere;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MeshSubset.prototype, "data", {
                get: function /** @inline */() {
                    return this._pRenderData;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MeshSubset.prototype, "skin", {
                get: function /** @inline */() {
                    return this._pSkin;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MeshSubset.prototype, "name", {
                get: function /** @inline */() {
                    return this._sName;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MeshSubset.prototype, "mesh", {
                get: function /** @inline */() {
                    return this._pMesh;
                },
                enumerable: true,
                configurable: true
            });
            MeshSubset.prototype.setup = /**@protected*/ function /** @no-inline */(pMesh, pRenderData, sName) {
                akra.logger.setSourceLocation("MeshSubset.ts", 38);
                akra.logger.assert(this._pMesh === null, "mesh subset already prepared");
                ;
                this._pMesh = pMesh;
                this._pRenderData = pRenderData;
                this._sName = sName;
                _super.prototype._setup.call(this, pMesh.getEngine().getRenderer());
            };
            MeshSubset.prototype.createBoundingBox = function /** @no-inline */() {
                var pVertexData;
                var pNewBoundingBox;
                pNewBoundingBox = new akra.geometry.Rect3d();
                pVertexData = this.data._getData(akra.DeclUsages.POSITION);
                if(akra.isNull(pVertexData)) {
                    return false;
                }
                if(akra.geometry.computeBoundingBox(pVertexData, pNewBoundingBox) == false) {
                    return false;
                }
                this._pBoundingBox = pNewBoundingBox;
                return true;
            };
            MeshSubset.prototype.deleteBoundingBox = function /** @no-inline */() {
                this._pBoundingBox = null;
                return true;
            };
            MeshSubset.prototype.showBoundingBox = function /** @no-inline */() {
                var pMaterial;
                var iData;
                var iCurrentIndexSet;
                var pPoints, pIndexes;
                if(akra.isNull(this._pBoundingBox)) {
                    return false;
                }
                pPoints = new Array();
                pIndexes = new Array();
                akra.geometry.computeDataForCascadeBoundingBox(this._pBoundingBox, pPoints, pIndexes, 10.0);
                iCurrentIndexSet = this.data.getIndexSet();
                if(!this.data.selectIndexSet(".BoundingBox")) {
                    this.data.addIndexSet(true, 1 /* LINELIST */ , ".BoundingBox");
                    iData = this.data.allocateData([
                        akra.VE_FLOAT3(akra.DeclUsages.POSITION)
                    ], new Float32Array(pPoints));
                    this.data.allocateIndex([
                        akra.VE_FLOAT(akra.DeclUsages.INDEX0)
                    ], new Float32Array(pIndexes));
                    this.data.index(iData, akra.DeclUsages.INDEX0);
                    this.applyFlexMaterial(".MaterialBoundingBox");
                    //TODO: некорректно задавать так boundingBox, т.к. надо рендерится со своим рендер методом, а его никто не выбирает.
                    pMaterial = this.getFlexMaterial(".MaterialBoundingBox");
                    pMaterial.emissive = new akra.Color(0.0, 0.0, 1.0, 1.0);
                    pMaterial.diffuse = new akra.Color(0.0, 0.0, 1.0, 1.0);
                } else {
                    this.data._getData(akra.DeclUsages.POSITION).setData(new Float32Array(pPoints), akra.DeclUsages.POSITION);
                }
                this.data.setRenderable(this.data.getIndexSet(), true);
                this.data.selectIndexSet(iCurrentIndexSet);
                return true;
            };
            MeshSubset.prototype.hideBoundingBox = function /** @no-inline */() {
                var iCurrentIndexSet;
                iCurrentIndexSet = this.data.getIndexSet();
                if(!this.data.selectIndexSet(".BoundingBox")) {
                    return false;
                } else {
                    this.data.setRenderable(this.data.getIndexSet(), false);
                }
                return this.data.selectIndexSet(iCurrentIndexSet);
            };
            MeshSubset.prototype.createBoundingSphere = function /** @no-inline */() {
                var pVertexData;
                var pNewBoundingSphere;
                pNewBoundingSphere = new akra.geometry.Sphere();
                pVertexData = this.data._getData(akra.DeclUsages.POSITION);
                if(!pVertexData) {
                    return false;
                }
                if(!akra.geometry.computeBoundingSphere(pVertexData, pNewBoundingSphere, false, this._pBoundingBox)) {
                    return false;
                }
                this._pBoundingSphere = pNewBoundingSphere;
                return true;
            };
            MeshSubset.prototype.deleteBoundingSphere = function /** @no-inline */() {
                this._pBoundingSphere = null;
                return true;
            };
            MeshSubset.prototype.showBoundingSphere = function /** @no-inline */() {
                var pMaterial;
                var iData;
                var iCurrentIndexSet;
                var pPoints, pIndexes;
                if(akra.isNull(this._pBoundingSphere)) {
                    return false;
                }
                pPoints = new Array();
                pIndexes = new Array();
                akra.geometry.computeDataForCascadeBoundingSphere(this._pBoundingSphere, pPoints, pIndexes);
                iCurrentIndexSet = this.data.getIndexSet();
                if(!this.data.selectIndexSet(".BoundingSphere")) {
                    this.data.addIndexSet(false, 1 /* LINELIST */ , ".BoundingSphere");
                    iData = this.data.allocateData([
                        akra.VE_FLOAT3(akra.DeclUsages.POSITION)
                    ], new Float32Array(pPoints));
                    this.data.allocateIndex([
                        akra.VE_FLOAT(akra.DeclUsages.INDEX0)
                    ], new Float32Array(pIndexes));
                    this.data.index(iData, akra.DeclUsages.INDEX0);
                    this.applyFlexMaterial(".MaterialBoundingSphere");
                    pMaterial = this.getFlexMaterial(".MaterialBoundingSphere");
                    pMaterial.emissive = new akra.Color(0.0, 0.0, 1.0, 1.0);
                    pMaterial.diffuse = new akra.Color(0.0, 0.0, 1.0, 1.0);
                } else {
                    this.data._getData(akra.DeclUsages.POSITION).setData(new Float32Array(pPoints), akra.DeclUsages.POSITION);
                }
                this.data.setRenderable(this.data.getIndexSet(), true);
                this.data.selectIndexSet(iCurrentIndexSet);
                return true;
            };
            MeshSubset.prototype.hideBoundingSphere = function /** @no-inline */() {
                var iCurrentIndexSet = this.data.getIndexSet();
                if(!this.data.selectIndexSet(".BoundingSphere")) {
                    return false;
                } else {
                    this.data.setRenderable(this.data.getIndexSet(), false);
                }
                return this.data.selectIndexSet(iCurrentIndexSet);
            };
            MeshSubset.prototype.computeNormals = function /** @no-inline */() {
                //TODO: calc normals
                            };
            MeshSubset.prototype.computeTangents = function /** @no-inline */() {
                //TODO: compute normals
                            };
            MeshSubset.prototype.computeBinormals = function /** @no-inline */() {
                //TODO: calc binormals
                            };
            MeshSubset.prototype.isSkinned = function /** @no-inline */() {
                return this._pSkin !== null;
            };
            MeshSubset.prototype.getSkin = function /** @no-inline */() {
                return this._pSkin;
            };
            MeshSubset.prototype.applyFlexMaterial = function /** @no-inline */(sMaterial, pMaterialData) {
                if (typeof pMaterialData === "undefined") { pMaterialData = null; }
                if(this._pMesh.addFlexMaterial(sMaterial, pMaterialData)) {
                    return this.setFlexMaterial(sMaterial);
                }
                return false;
            };
            MeshSubset.prototype.getFlexMaterial = function /** @no-inline */(iMaterial) {
                return this._pMesh.getFlexMaterial(iMaterial);
            };
            MeshSubset.prototype.hasFlexMaterial = function /** @no-inline */() {
                return this._pRenderData.hasSemantics(akra.DeclUsages.MATERIAL);
            };
            MeshSubset.prototype.setFlexMaterial = function /** @no-inline */(iMaterial) {
                var pRenderData = this._pRenderData;
                var pIndexData = pRenderData.getIndices();
                var pMatFlow = pRenderData._getFlow(akra.DeclUsages.MATERIAL);
                var eSemantics = akra.DeclUsages.INDEX10;
                var pIndexDecl, pFloatArray;
                var iMatFlow;
                var pMaterial = this._pMesh.getFlexMaterial(iMaterial);
                var iMat = (pMaterial).data.byteOffset;
                if(akra.isNull(pMaterial)) {
                    return false;
                }
                if(pMatFlow) {
                    iMatFlow = pMatFlow.flow;
                    eSemantics = pMatFlow.mapper.semantics;
                    pIndexData = pMatFlow.mapper.data;
                    pRenderData._addData((pMaterial).data, iMatFlow);
                    return pRenderData.index(iMat, eSemantics, true);
                }
                pIndexDecl = akra.createVertexDeclaration([
                    akra.VE_FLOAT(eSemantics)
                ]);
                pFloatArray = new Float32Array((pIndexData).length);
                iMatFlow = pRenderData._addData((pMaterial).data);
                akra.logger.setSourceLocation("MeshSubset.ts", 281);
                akra.logger.assert(iMatFlow >= 0, "cannot add data flow with material for mesh subsset");
                ;
                if(!pRenderData.allocateIndex(pIndexDecl, pFloatArray)) {
                    akra.logger.setSourceLocation("MeshSubset.ts", 284);
                    akra.logger.log("cannot allocate index for material!!!");
                    ;
                    return false;
                }
                return pRenderData.index(iMat, eSemantics, true);
            };
            MeshSubset.prototype._draw = function /** @no-inline */() {
                this._pRenderData._draw();
            };
            MeshSubset.prototype.show = function /** @no-inline */() {
                this.data.setRenderable(true);
            };
            MeshSubset.prototype.hide = function /** @no-inline */() {
                this.data.setRenderable(false);
            };
            MeshSubset.prototype.setSkin = //исходим из того, что данные скина 1:1 соотносятся с вершинами.
            function /** @no-inline */(pSkin) {
                var pPosData;
                var pPositionFlow;
                var pMetaData;
                //мета данные разметки
                var pInfMetaData;
                //адресс мета данных во флотах
                var iInfMetaDataLoc;
                //шаг мета данных во флотах
                var iInfMetaDataStride;
                /*
                Получаем данные вершин, чтобы проложить в {W} компоненту адерсс мета информации,
                о влиянии на данную вершины.
                */
                //получаем поток данных с вершиными
                pPositionFlow = this.data._getFlow(akra.DeclUsages.POSITION);
                akra.logger.setSourceLocation("MeshSubset.ts", 324);
                akra.logger.assert(akra.isDefAndNotNull(pPositionFlow), "skin require position with indices in mesh subset");
                ;
                pPosData = pPositionFlow.data;
                //проверяем, что данные еще не подвязаны к другому Skin'у
                if(pPosData.hasSemantics(akra.DeclUsages.BLENDMETA)) {
                    //тоже самый skin?
                    if(pSkin.isAffect(pPosData)) {
                        this._pSkin = pSkin;
                        return true;
                    }
                    akra.logger.setSourceLocation("MeshSubset.ts", 336);
                    akra.logger.error("mesh subset already has another skin");
                    ;
                    return false;
                }
                //проверяем, что текущий подмеш пренадлежит мешу, на который натягивается skin,
                //или его клону.
                akra.logger.setSourceLocation("MeshSubset.ts", 343);
                akra.logger.assert(this.data.buffer == pSkin.data, "can not bind to skin mesh subset that does not belong skin's mesh.");
                //подвязывем скин, к данным с вершинами текущего подмеша.
                //т.е. добавляем разметку в конец каждого пикселя
                pSkin.attach(pPosData);
                //получаем данные разметки
                pMetaData = pPosData.getTypedData(akra.DeclUsages.BLENDMETA);
                //если по каким то причинам нет разметки...
                akra.logger.setSourceLocation("MeshSubset.ts", 353);
                akra.logger.assert(akra.isDefAndNotNull(pMetaData), "you must specify location for storage blending data");
                ;
                //выставляем разметку мета данных в��ршин, так чтобы они адрессовали сразу на данные
                pInfMetaData = pSkin.getInfluenceMetaData();
                iInfMetaDataLoc = pInfMetaData.byteOffset / 4 /* BYTES_PER_FLOAT */ ;
                iInfMetaDataStride = pInfMetaData.stride / 4 /* BYTES_PER_FLOAT */ ;
                for(var i = 0; i < pMetaData.length; ++i) {
                    pMetaData[i] = iInfMetaDataLoc + i * iInfMetaDataStride;
                }
                //обновляем адресса мета данных вершин
                pPosData.setData(pMetaData, akra.DeclUsages.BLENDMETA);
                //trace(this.data.toString());
                this._pSkin = pSkin;
                return true;
            };
            MeshSubset._pEventTable = new akra.events.EventTable();
            MeshSubset.prototype.getEventTable = function /** @inline */() {
                return MeshSubset._pEventTable;
            };
            MeshSubset.prototype.getGuid = function /** @no-inline */() {
                return this._iGuid < 0 ? (this._iGuid = akra.sid()) : this._iGuid;
            };
            MeshSubset.prototype.connect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            MeshSubset.prototype.disconnect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            MeshSubset.prototype.bind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType);
            };
            MeshSubset.prototype.unbind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType);
            };
            return MeshSubset;
        })(akra.render.RenderableObject);
        model.MeshSubset = MeshSubset;        
    })(akra.model || (akra.model = {}));
    var model = akra.model;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (model) {
        var Mesh = (function (_super) {
            __extends(Mesh, _super);
            function /** @no-inline */Mesh(pEngine, eOptions, sName, pDataBuffer) {
                        _super.call(this);
                this._pFlexMaterials = null;
                this._pBuffer = null;
                this._eOptions = 0;
                this._pSkeleton = null;
                this._pBoundingBox = null;
                this._pBoundingSphere = null;
                this._pSubMeshes = [];
                this._bShadow = false;
                this._iGuid = eval("this._iGuid || akra.sid()");
                this._pUnicastSlotMap = null;
                this._pBroadcastSlotList = null;
                this._sName = sName || null;
                this._pEngine = pEngine;
                this.setup(sName, eOptions, pDataBuffer);
            }
            Object.defineProperty(Mesh.prototype, "length", {
                get: function /** @inline */() {
                    return this._pSubMeshes.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mesh.prototype, "flexMaterials", {
                get: function /** @inline */() {
                    return this._pFlexMaterials;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mesh.prototype, "name", {
                get: function /** @inline */() {
                    return this._sName;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mesh.prototype, "data", {
                get: function /** @inline */() {
                    return this._pBuffer;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mesh.prototype, "skeleton", {
                get: function /** @inline */() {
                    return this._pSkeleton;
                },
                set: function /** @inline */(pSkeleton) {
                    this._pSkeleton = pSkeleton;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mesh.prototype, "boundingBox", {
                get: function /** @inline */() {
                    if(akra.isNull(this._pBoundingBox)) {
                        if(!this.createBoundingBox()) {
                            akra.logger.setSourceLocation("model/Mesh.ts", 66);
                            akra.logger.warning("could not compute bounding box fo mesh");
                            ;
                        }
                    }
                    return this._pBoundingBox;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mesh.prototype, "boundingSphere", {
                get: function /** @inline */() {
                    if(akra.isNull(this._pBoundingSphere)) {
                        if(!this.createBoundingSphere()) {
                            akra.logger.setSourceLocation("model/Mesh.ts", 76);
                            akra.logger.warning("could not compute bounding sphere for mesh");
                            ;
                        }
                    }
                    return this._pBoundingSphere;
                },
                enumerable: true,
                configurable: true
            });
            Mesh.prototype.setSkeleton = function /** @no-inline */(pSkeleton) {
                this.skeleton = pSkeleton;
            };
            Mesh.prototype.getOptions = function /** @no-inline */() {
                return this._eOptions;
            };
            Mesh.prototype.getEngine = function /** @no-inline */() {
                return this._pEngine;
            };
            Mesh.prototype._drawSubset = function /** @no-inline */(iSubset) {
                this._pBuffer._draw(iSubset);
            };
            Mesh.prototype._draw = function /** @no-inline */() {
                for(var i = 0; i < this.length; i++) {
                    this._pSubMeshes[i]._draw();
                }
                ;
            };
            Mesh.prototype.isReadyForRender = function /** @no-inline */() {
                for(var i = 0; i < this._pSubMeshes.length; ++i) {
                    if(!this._pSubMeshes[i].isReadyForRender()) {
                        return false;
                    }
                }
                return true;
            };
            Mesh.prototype.setup = function /** @no-inline */(sName, eOptions, pDataCollection) {
                akra.logger.setSourceLocation("model/Mesh.ts", 124);
                akra.logger.assert(this._pBuffer === null, "mesh already setuped.");
                ;
                if(akra.isNull(pDataCollection)) {
                    this._pBuffer = this._pEngine.createRenderDataCollection(eOptions);
                } else {
                    akra.logger.setSourceLocation("model/Mesh.ts", 131);
                    akra.logger.assert(pDataCollection.getEngine() === this.getEngine(), "you can not use a buffer with a different context");
                    ;
                    this._pBuffer = pDataCollection;
                    eOptions |= pDataCollection.getOptions();
                }
                this._pBuffer.addRef();
                this._eOptions = eOptions || 0;
                this._sName = sName || "unknown";
                return true;
            };
            Mesh.prototype.createSubset = function /** @no-inline */(sName, ePrimType, eOptions) {
                if (typeof eOptions === "undefined") { eOptions = 0; }
                var pData;
                //TODO: modify options and create options for data dactory.
                pData = this._pBuffer.getEmptyRenderData(ePrimType, eOptions);
                pData.addRef();
                if(akra.isNull(pData)) {
                    return null;
                }
                return this.appendSubset(sName, pData);
            };
            Mesh.prototype.appendSubset = function /** @no-inline */(sName, pData) {
                akra.logger.setSourceLocation("model/Mesh.ts", 158);
                akra.logger.assert(pData.buffer === this._pBuffer, "invalid data used");
                ;
                var pSubMesh = new model.MeshSubset(this, pData, sName);
                this._pSubMeshes.push(pSubMesh);
                this.connect(pSubMesh, "shadow", "shadow", 1 /* UNICAST */ );
                return pSubMesh;
            };
            Mesh.prototype.replaceFlexMaterials = function /** @no-inline */(pFlexMaterials) {
                this._pFlexMaterials = pFlexMaterials;
            };
            Mesh.prototype.freeSubset = function /** @no-inline */(sName) {
                akra.logger.setSourceLocation("model/Mesh.ts", 173);
                akra.logger.error("Метод freeSubset не реализован");
                ;
                return false;
            };
            Mesh.prototype.getFlexMaterial = function /** @no-inline */(arg) {
                if(!this._pFlexMaterials) {
                    return null;
                }
                if(typeof arguments[0] === 'number') {
                    return this._pFlexMaterials[arguments[0]] || null;
                } else {
                    for(var i = 0, pMaterials = this._pFlexMaterials; i < pMaterials.length; ++i) {
                        if(pMaterials[i].name === arguments[0]) {
                            return pMaterials[i];
                        }
                    }
                }
                return null;
            };
            Mesh.prototype.addFlexMaterial = function /** @no-inline */(sName, pMaterialData) {
                if (typeof pMaterialData === "undefined") { pMaterialData = null; }
                var pMaterial;
                var pMaterialId;
                akra.logger.setSourceLocation("model/Mesh.ts", 202);
                akra.logger.assert(arguments.length < 7, "only base material supported now...");
                ;
                //debug_assert(this.getFlexMaterial(sName) === null, 'material with name <' + sName + '> already exists');
                sName = sName || 'unknown';
                pMaterial = this.getFlexMaterial(sName);
                if(pMaterial) {
                    if(pMaterialData) {
                        pMaterial.set(pMaterialData);
                    }
                    return true;
                }
                if(!this._pFlexMaterials) {
                    this._pFlexMaterials = [];
                }
                pMaterialId = this._pFlexMaterials.length;
                pMaterial = akra.material._createFlex(sName, this._pBuffer._allocateData(akra.material.VERTEX_DECL, null));
                if(!pMaterialData) {
                    pMaterialData = akra.material.create(null, akra.material.DEFAULT);
                }
                pMaterial.set(pMaterialData);
                //pMaterial.id = pMaterialId;
                this._pFlexMaterials.push(pMaterial);
                return true;
            };
            Mesh.prototype.setFlexMaterial = function /** @no-inline */(iMaterial) {
                var bResult = true;
                for(var i = 0; i < this.length; ++i) {
                    if(!this._pSubMeshes[i].setFlexMaterial(iMaterial)) {
                        akra.logger.setSourceLocation("model/Mesh.ts", 243);
                        akra.logger.warning("cannot set material<" + iMaterial + "> for mesh<" + this.name + "> subset<" + this._pSubMeshes[i].name + ">");
                        ;
                        bResult = false;
                    }
                }
                return bResult;
            };
            Mesh.prototype.destroy = function /** @no-inline */() {
                this._pFlexMaterials = null;
                this._pSubMeshes = null;
                /*this*/
                this._pBuffer.destroy();
            };
            Mesh.prototype.getSubset = function /** @no-inline */(i) {
                if(akra.isInt(arguments[0])) {
                    return this._pSubMeshes[arguments[0]];
                } else {
                    for(var i = 0; i < this.length; ++i) {
                        if(this._pSubMeshes[i].name === arguments[0]) {
                            return this._pSubMeshes[i];
                        }
                    }
                }
                return null;
            };
            Mesh.prototype.setSkin = function /** @no-inline */(pSkin) {
                for(var i = 0; i < this.length; ++i) {
                    this._pSubMeshes[i].setSkin(pSkin);
                }
                ;
            };
            Mesh.prototype.createSkin = function /** @no-inline */() {
                var pSkin = model.createSkin(this);
                this.setSkin(pSkin);
                return pSkin;
            };
            Mesh.prototype.clone = function /** @no-inline */(iCloneOptions) {
                var pClone = null;
                var pRenderData;
                var pSubMesh;
                if(iCloneOptions & 1 /* SHARED_GEOMETRY */ ) {
                    pClone = this.getEngine().createMesh(this.name, this.getOptions(), this.data);
                    for(var i = 0; i < this.length; ++i) {
                        pRenderData = this._pSubMeshes[i].data;
                        pRenderData.addRef();
                        pClone.appendSubset(this._pSubMeshes[i].name, pRenderData);
                    }
                    pClone.replaceFlexMaterials(this.flexMaterials);
                    //trace('created clone', pClone);
                                    } else {
                    //TODO: clone mesh data.
                                    }
                if(iCloneOptions & 0 /* GEOMETRY_ONLY */ ) {
                    return pClone;
                } else {
                    //TODO: clone mesh shading
                                    }
                return pClone;
            };
            Mesh.prototype.createAndShowSubBoundingBox = function /** @no-inline */() {
                for(var i = 0; i < this.length; i++) {
                    var pSubMesh = this.getSubset(i);
                    pSubMesh.createBoundingBox();
                    pSubMesh.showBoundingBox();
                    //console.log("SubMesh" + i);
                                    }
            };
            Mesh.prototype.createAndShowSubBoundingSphere = function /** @no-inline */() {
                for(var i = 0; i < this.length; i++) {
                    var pSubMesh = this.getSubset(i);
                    pSubMesh.createBoundingSphere();
                    pSubMesh.showBoundingSphere();
                    //console.log("SubMesh" + i);
                                    }
            };
            Mesh.prototype.createBoundingBox = function /** @no-inline */() {
                var pVertexData;
                var pSubMesh;
                var pNewBoundingBox;
                var pTempBoundingBox;
                var i;
                pNewBoundingBox = new akra.geometry.Rect3d();
                pTempBoundingBox = new akra.geometry.Rect3d();
                pSubMesh = this.getSubset(0);
                pVertexData = pSubMesh.data._getData(akra.DeclUsages.POSITION);
                if(akra.isNull(pVertexData)) {
                    return false;
                }
                if(akra.geometry.computeBoundingBox(pVertexData, pNewBoundingBox) == false) {
                    return false;
                }
                if(pSubMesh.isSkinned()) {
                    pNewBoundingBox.transform(pSubMesh.skin.getBindMatrix());
                    pNewBoundingBox.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
                }
                for(i = 1; i < this.length; i++) {
                    pSubMesh = this.getSubset(i);
                    pVertexData = pSubMesh.data._getData(akra.DeclUsages.POSITION);
                    //trace(pSubMesh.name);
                    if(!pVertexData) {
                        return false;
                    }
                    if(akra.geometry.computeBoundingBox(pVertexData, pTempBoundingBox) == false) {
                        return false;
                    }
                    //trace('>>> before box >>');
                    if(pSubMesh.isSkinned()) {
                        //trace('calc skinned box');
                        pTempBoundingBox.transform(pSubMesh.skin.getBindMatrix());
                        pTempBoundingBox.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
                    }
                    // trace('<<< after box <<');
                    pNewBoundingBox.x0 = Math.min(pNewBoundingBox.x0, pTempBoundingBox.x0);
                    pNewBoundingBox.y0 = Math.min(pNewBoundingBox.y0, pTempBoundingBox.y0);
                    pNewBoundingBox.z0 = Math.min(pNewBoundingBox.z0, pTempBoundingBox.z0);
                    pNewBoundingBox.x1 = Math.max(pNewBoundingBox.x1, pTempBoundingBox.x1);
                    pNewBoundingBox.y1 = Math.max(pNewBoundingBox.y1, pTempBoundingBox.y1);
                    pNewBoundingBox.z1 = Math.max(pNewBoundingBox.z1, pTempBoundingBox.z1);
                }
                this._pBoundingBox = pNewBoundingBox;
                return true;
            };
            Mesh.prototype.deleteBoundingBox = function /** @no-inline */() {
                this._pBoundingBox = null;
                return true;
            };
            Mesh.prototype.showBoundingBox = function /** @no-inline */() {
                var pSubMesh;
                var pMaterial;
                var iData;
                var pPoints, pIndexes;
                if(akra.isNull(this._pBoundingBox)) {
                    return false;
                }
                pPoints = new Array();
                pIndexes = new Array();
                akra.geometry.computeDataForCascadeBoundingBox(this._pBoundingBox, pPoints, pIndexes, 0.1);
                pSubMesh = this.getSubset(".BoundingBox");
                if(!pSubMesh) {
                    pSubMesh = this.createSubset(".BoundingBox", 1 /* LINELIST */ , 1 /* STATIC */ );
                    if(akra.isNull(pSubMesh)) {
                        return false;
                    }
                    iData = pSubMesh.data.allocateData([
                        akra.VE_FLOAT3(akra.DeclUsages.POSITION)
                    ], new Float32Array(pPoints));
                    pSubMesh.data.allocateIndex([
                        akra.VE_FLOAT(akra.DeclUsages.INDEX0)
                    ], new Float32Array(pIndexes));
                    pSubMesh.data.index(iData, akra.DeclUsages.INDEX0);
                    // pSubMesh.applyFlexMaterial(".MaterialBoundingBox");
                    /*getFlexMaterial(".MaterialBoundingBox");*/
                    pMaterial = pSubMesh.material;
                    pMaterial.emissive = new akra.Color(1.0, 1.0, 1.0, 1.0);
                    pMaterial.diffuse = new akra.Color(1.0, 1.0, 1.0, 1.0);
                    pMaterial.ambient = new akra.Color(1.0, 1.0, 1.0, 1.0);
                    pMaterial.specular = new akra.Color(1.0, 1.0, 1.0, 1.0);
                    pSubMesh.effect.create();
                    pSubMesh.effect.addComponent("akra.system.mesh_texture");
                    pSubMesh.effect.addComponent("akra.system.prepareForDeferredShading");
                } else {
                    pSubMesh.data._getData(akra.DeclUsages.POSITION).setData(new Float32Array(pPoints), akra.DeclUsages.POSITION);
                }
                pSubMesh.data.setRenderable(pSubMesh.data.getIndexSet(), true);
                return true;
            };
            Mesh.prototype.hideBoundingBox = function /** @no-inline */() {
                var pSubMesh = this.getSubset(".BoundingBox");
                if(!pSubMesh) {
                    return false;
                }
                //TODO: hide bounding box!!
                return false;
                //return pSubMesh.data.setRenderable(this.data.getIndexSet(), false);
                            };
            Mesh.prototype.createBoundingSphere = function /** @no-inline */() {
                var pVertexData;
                var pSubMesh;
                var pNewBoundingSphere, pTempBoundingSphere;
                var i;
                pNewBoundingSphere = new akra.geometry.Sphere();
                pTempBoundingSphere = new akra.geometry.Sphere();
                pSubMesh = this.getSubset(0);
                pVertexData = pSubMesh.data._getData(akra.DeclUsages.POSITION);
                if(!pVertexData) {
                    return false;
                }
                if(akra.geometry.computeBoundingSphere(pVertexData, pNewBoundingSphere) == false) {
                    return false;
                }
                if(pSubMesh.isSkinned()) {
                    pNewBoundingSphere.transform(pSubMesh.skin.getBindMatrix());
                    pNewBoundingSphere.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
                }
                for(i = 1; i < this.length; i++) {
                    pSubMesh = this.getSubset(i);
                    pVertexData = pSubMesh.data._getData(akra.DeclUsages.POSITION);
                    if(akra.isNull(pVertexData)) {
                        return false;
                    }
                    if(akra.geometry.computeBoundingSphere(pVertexData, pTempBoundingSphere) == false) {
                        return false;
                    }
                    if(pSubMesh.isSkinned()) {
                        pTempBoundingSphere.transform(pSubMesh.skin.getBindMatrix());
                        pTempBoundingSphere.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
                        // trace(pTempBoundingSphere.fRadius, '<<<');
                                            }
                    akra.geometry.computeGeneralizingSphere(pNewBoundingSphere, pTempBoundingSphere);
                }
                // trace(pNewBoundingSphere, '<<<<<<<<<<<<<<<<<<<<<<<<<')
                this._pBoundingSphere = pNewBoundingSphere;
                return true;
            };
            Mesh.prototype.deleteBoundingSphere = function /** @no-inline */() {
                this._pBoundingSphere = null;
                return true;
            };
            Mesh.prototype.showBoundingSphere = function /** @no-inline */() {
                var pSubMesh, pMaterial;
                var iData;
                var pPoints, pIndexes;
                if(!this._pBoundingSphere) {
                    return false;
                }
                pPoints = new Array();
                pIndexes = new Array();
                akra.geometry.computeDataForCascadeBoundingSphere(this._pBoundingSphere, pPoints, pIndexes);
                pSubMesh = this.getSubset(".BoundingSphere");
                if(!pSubMesh) {
                    pSubMesh = this.createSubset(".BoundingSphere", 1 /* LINELIST */ , 1 /* STATIC */ );
                    if(akra.isNull(pSubMesh)) {
                        return false;
                    }
                    iData = pSubMesh.data.allocateData([
                        akra.VE_FLOAT3(akra.DeclUsages.POSITION)
                    ], new Float32Array(pPoints));
                    pSubMesh.data.allocateIndex([
                        akra.VE_FLOAT(akra.DeclUsages.INDEX0)
                    ], new Float32Array(pIndexes));
                    pSubMesh.data.index(iData, akra.DeclUsages.INDEX0);
                    // pSubMesh.applyFlexMaterial(".MaterialBoundingSphere");
                    // //pSubMesh.getFlexMaterial(".MaterialBoundingSphere");
                    pMaterial = pSubMesh.material;
                    pMaterial.emissive = new akra.Color(1.0, 0.0, 0.0, 1.0);
                    pMaterial.diffuse = new akra.Color(1.0, 0.0, 0.0, 1.0);
                    pMaterial.ambient = new akra.Color(1.0, 0.0, 0.0, 1.0);
                    pMaterial.specular = new akra.Color(1.0, 0.0, 0.0, 1.0);
                } else {
                    pSubMesh.data._getData(akra.DeclUsages.POSITION).setData(new Float32Array(pPoints), akra.DeclUsages.POSITION);
                }
                pSubMesh.data.setRenderable(pSubMesh.data.getIndexSet(), true);
                return true;
            };
            Mesh.prototype.hideBoundingSphere = function /** @no-inline */() {
                var pSubMesh;
                pSubMesh = this.getSubset(".BoundingSphere");
                if(!pSubMesh) {
                    return false;
                }
                //TODO: hide bounding sphere
                return false;
                //return pSubMeshs.data.setRenderable(this.data.getIndexSet(),false);
                            };
            Mesh.prototype.hasShadow = function /** @inline */() {
                return this._bShadow;
            };
            Mesh.prototype.setShadow = function /** @no-inline */(bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                for(var i = 0; i < this._pSubMeshes.length; ++i) {
                    this._pSubMeshes[i].setShadow(bValue);
                }
            };
            Mesh.prototype.toSceneModel = function /** @no-inline */(pParent, sName) {
                if (typeof sName === "undefined") { sName = null; }
                if(akra.isNull(pParent)) {
                    return null;
                }
                var pSceneModel = pParent.scene.createModel(sName);
                if(!pSceneModel.create()) {
                    return null;
                }
                pSceneModel.mesh = this;
                pSceneModel.attachToParent(pParent);
                return pSceneModel;
            };
            Mesh._pEventTable = new akra.events.EventTable();
            Mesh.prototype.getEventTable = function /** @inline */() {
                return Mesh._pEventTable;
            };
            Mesh.prototype.getGuid = function /** @no-inline */() {
                return this._iGuid < 0 ? (this._iGuid = akra.sid()) : this._iGuid;
            };
            Mesh.prototype.connect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            Mesh.prototype.disconnect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            Mesh.prototype.bind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType);
            };
            Mesh.prototype.unbind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType);
            };
            Mesh.prototype.shadow = function /** @no-inline */(pSubMesh, bShadow) {
                this._bShadow = bShadow;
                if(!bShadow) {
                    for(var i = 0; i < this._pSubMeshes.length; ++i) {
                        if(this._pSubMeshes[i].hasShadow()) {
                            this._bShadow = true;
                            break;
                        }
                    }
                }
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).shadow;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pSubMesh, bShadow) : _broadcast[i].listener(_recivier, pSubMesh, bShadow);
                    }
                }
                ;
            };
            return Mesh;
        })(akra.util.ReferenceCounter);        
        function /** @no-inline */createMesh(pEngine, sName, eOptions, pDataBuffer) {
            if (typeof sName === "undefined") { sName = null; }
            if (typeof eOptions === "undefined") { eOptions = 0; }
            if (typeof pDataBuffer === "undefined") { pDataBuffer = null; }
            return new Mesh(pEngine, eOptions, sName, pDataBuffer);
        }
        model.createMesh = createMesh;
    })(akra.model || (akra.model = {}));
    var model = akra.model;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        var SceneModel = (function (_super) {
            __extends(SceneModel, _super);
            function /** @no-inline */SceneModel(pScene) {
                        _super.call(this, pScene);
                this.type = 65 /* MODEL */ ;
            }
            Object.defineProperty(SceneModel.prototype, "mesh", {
                get: function /** @inline */() {
                    return this._pMesh;
                },
                set: function /** @inline */(pMesh) {
                    if(!akra.isNull(this._pMesh)) {
                        this.accessLocalBounds().set(0.01, 0.01, 0.01);
                        this._pMesh = null;
                    }
                    if(!akra.isNull(pMesh)) {
                        this.accessLocalBounds().set(pMesh.boundingBox);
                        this._pMesh = pMesh;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SceneModel.prototype, "totalRenderable", {
                get: function /** @inline */() {
                    return akra.isNull(this._pMesh) ? 0 : this._pMesh.length;
                },
                enumerable: true,
                configurable: true
            });
            SceneModel.prototype.getRenderable = function /** @inline */(i) {
                if (typeof i === "undefined") { i = 0; }
                return this._pMesh.getSubset(i);
            };
            SceneModel.prototype.hasShadow = function /** @inline */() {
                return this._pMesh.hasShadow();
            };
            SceneModel.prototype.setShadow = function /** @inline */(bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                this._pMesh.setShadow(bValue);
            };
            SceneModel.prototype.toString = function /** @no-inline */(isRecursive, iDepth) {
                if (typeof isRecursive === "undefined") { isRecursive = false; }
                if (typeof iDepth === "undefined") { iDepth = 0; }
                if(!isRecursive) {
                    var sData = "<model" + (this.name ? " " + this.name : "") + "(" + String(akra.isNull(this._pMesh)) + ")" + '>';
                    if(!akra.isNull(this._pMesh)) {
                        sData += "( " + this._pMesh.name + " )";
                    }
                    return sData;
                }
                return _super.prototype.toString.call(this, isRecursive, iDepth);
            };
            return SceneModel;
        })(scene.SceneObject);
        scene.SceneModel = SceneModel;        
        function /** @inline */isModel(pEntity) {
            return pEntity.type === 65 /* MODEL */ ;
        }
        scene.isModel = isModel;
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        var Scene3d = (function () {
            function /** @no-inline */Scene3d(pSceneManager) {
                // protected _pNodeList: ISceneNode[];
                // protected _pObjectList: ISceneObject[];
                /**@protected*/ this._pDisplayLists = [];
                /**@protected*/ this._pDisplayListsCount = 0;
                /**@protected*/ this._isUpdated = false;
                this.type = 0 /* TYPE_3D */ ;
                this._iGuid = eval("this._iGuid || akra.sid()");
                this._pUnicastSlotMap = null;
                this._pBroadcastSlotList = null;
                this._pSceneManager = pSceneManager;
                this._pRootNode = this.createNode("root-node");
                this._pRootNode.create();
                var i;
                // this._pNodeList = [];
                // this._pObjectList = [];
                //TODO передача пользовательских параметров в OcTree
                // i = this.addDisplayList(new OcTree);
                // debug_assert(i == DL_DEFAULT, "invalid default list index");
                //TODO передача пользовательских параметров в LightGraph
                // i = this.addDisplayList(new LightGraph);
                // debug_assert(i == DL_LIGHTING, "invalid lighting list index");
                            }
            Object.defineProperty(Scene3d.prototype, "totalDL", {
                get: function /** @inline */() {
                    return this._pDisplayListsCount;
                },
                enumerable: true,
                configurable: true
            });
            Scene3d.prototype.getManager = function /** @inline */() {
                return this._pSceneManager;
            };
            Scene3d.prototype.isUpdated = function /** @inline */() {
                return this._isUpdated;
            };
            Scene3d.prototype.getRootNode = function /** @inline */() {
                return this._pRootNode;
            };
            Scene3d.prototype.recursivePreUpdate = function /** @no-inline */() {
                this._isUpdated = false;
                this._pRootNode.recursivePreUpdate();
            };
            Scene3d.prototype.recursiveUpdate = function /** @no-inline */() {
                this._isUpdated = this._pRootNode.recursiveUpdate();
            };
            Scene3d.prototype.updateCamera = function /** @no-inline */() {
                return false;
            };
            Scene3d.prototype.updateScene = function /** @no-inline */() {
                return false;
            };
            Scene3d.prototype.createNode = function /** @no-inline */(sName) {
                if (typeof sName === "undefined") { sName = null; }
                var pNode = new scene.SceneNode(this);
                if(!pNode.create()) {
                    akra.logger.setSourceLocation("Scene3d.ts", 92);
                    akra.logger.error("cannot create scene node..");
                    ;
                    return null;
                }
                return this.setupNode(pNode, sName);
            };
            Scene3d.prototype.createModel = function /** @no-inline */(sName) {
                if (typeof sName === "undefined") { sName = null; }
                var pNode = new scene.SceneModel(this);
                if(!pNode.create()) {
                    akra.logger.setSourceLocation("Scene3d.ts", 103);
                    akra.logger.error("cannot create model..");
                    ;
                    return null;
                }
                return this.setupNode(pNode, sName);
            };
            Scene3d.prototype.createCamera = function /** @no-inline */(sName) {
                if (typeof sName === "undefined") { sName = null; }
                var pCamera = new scene.objects.Camera(this);
                if(!pCamera.create()) {
                    akra.logger.setSourceLocation("Scene3d.ts", 114);
                    akra.logger.error("cannot create camera..");
                    ;
                    return null;
                }
                return this.setupNode(pCamera, sName);
            };
            Scene3d.prototype.createLightPoint = function /** @no-inline */(sName) {
                if (typeof sName === "undefined") { sName = null; }
                return null;
            };
            Scene3d.prototype.createSprite = function /** @no-inline */(sName) {
                if (typeof sName === "undefined") { sName = null; }
                return null;
            };
            Scene3d.prototype.createJoint = function /** @no-inline */(sName) {
                if (typeof sName === "undefined") { sName = null; }
                return this.setupNode(new scene.Joint(this), sName);
            };
            Scene3d.prototype.createText3d = function /** @no-inline */(sName) {
                if (typeof sName === "undefined") { sName = null; }
                return null;
            };
            Scene3d.prototype.getDisplayList = // inline getAllNodes(): ISceneNode[] {
            // 	return this._pNodeList;
            // }
            // inline getAllObjects(): ISceneObject[] {
            // 	return this._pObjectList;
            // }
            function /** @inline */(i) {
                akra.logger.setSourceLocation("Scene3d.ts", 146);
                akra.logger.assert(akra.isDefAndNotNull(this._pDisplayLists[i]), "display list not defined");
                ;
                return this._pDisplayLists[i];
            };
            Scene3d.prototype.getDisplayListByName = function /** @no-inline */(csName) {
                for(var i = 0; i < this._pDisplayLists.length; ++i) {
                    if(this._pDisplayLists[i].name === csName) {
                        return i;
                    }
                }
                return -1;
            };
            Scene3d.prototype._render = // _findObjects(pCamera: ICamera, csList: string = null): ISceneObject[] {
            // 	var pList: IDisplayList = this._pDisplayListMap[csList || DEFAULT_DLIST];
            // 	debug_assert(!isNull(pList), "display list not founded.");
            // 	return pList.findObjects(pCamera);
            // }
            function /** @no-inline */(pCamera, pViewport) {
            };
            Scene3d.prototype.setupNode = function /** @no-inline */(pNode, sName) {
                if (typeof sName === "undefined") { sName = null; }
                pNode.name = sName;
                // this.connect(pNode, SIGNAL(attached), SLOT(nodeAttachment), EEventTypes.UNICAST);
                // this.connect(pNode, SIGNAL(detached), SLOT(nodeDetachment), EEventTypes.UNICAST);
                return pNode;
            };
            Scene3d.prototype.delDisplayList = function /** @no-inline */(index) {
                var pLists = this._pDisplayLists;
                for(var i = 0; i < pLists.length; ++i) {
                    if(i === index && akra.isDefAndNotNull(pLists[i])) {
                        pLists[i] = null;
                        this._pDisplayListsCount--;
                        this.displayListRemoved(pLists[i], i);
                        return true;
                    }
                }
                ;
                return false;
            };
            Scene3d.prototype.addDisplayList = function /** @inline */(pList) {
                akra.logger.setSourceLocation("Scene3d.ts", 201);
                akra.logger.assert(akra.isDefAndNotNull(this.getDisplayListByName(pList.name)), "DL with name <" + pList.name + "> already exists");
                ;
                var pLists = this._pDisplayLists;
                var iIndex = this._pDisplayLists.length;
                for(var i = 0; i < pLists.length; ++i) {
                    if(pLists[i] === null) {
                        pLists[i] = pList;
                        iIndex = i;
                        break;
                    }
                }
                ;
                if(iIndex == this._pDisplayLists.length) {
                    this._pDisplayLists.push(pList);
                }
                pList._setup(this);
                this.displayListAdded(pList, iIndex);
                this._pDisplayListsCount++;
                return iIndex;
            };
            Scene3d._pEventTable = new akra.events.EventTable();
            Scene3d.prototype.getEventTable = function /** @inline */() {
                return Scene3d._pEventTable;
            };
            Scene3d.prototype.getGuid = function /** @no-inline */() {
                return this._iGuid < 0 ? (this._iGuid = akra.sid()) : this._iGuid;
            };
            Scene3d.prototype.connect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            Scene3d.prototype.disconnect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            Scene3d.prototype.bind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType);
            };
            Scene3d.prototype.unbind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType);
            };
            Scene3d.prototype.nodeAttachment = function /** @no-inline */(pNode) {
                // this._pNodeList.push(pNode);
                // if (SceneObject.isSceneObject(pNode)) {
                // 	this._pObjectList.push(<ISceneObject>pNode);
                // }
                // console.warn("------>here");
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).nodeAttachment;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pNode) : _broadcast[i].listener(_recivier, pNode);
                    }
                }
                ;
            };
            Scene3d.prototype.nodeDetachment = function /** @no-inline */(pNode) {
                // for (var i: int = 0; i < this._pNodeList.length; ++ i) {
                // 	if (pNode == this._pNodeList[i]) {
                // 		this._pNodeList.splice(i, 1);
                // 		break;
                // 	}
                // };
                // if (SceneObject.isSceneObject(pNode)) {
                // 	for (var i: int = 0; i < this._pObjectList.length; ++ i) {
                // 		if (<ISceneObject>pNode == this._pObjectList[i]) {
                // 			this._pObjectList.splice(i, 1);
                // 			break;
                // 		}
                // 	};
                // }
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).nodeDetachment;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pNode) : _broadcast[i].listener(_recivier, pNode);
                    }
                }
                ;
            };
            Scene3d.prototype.displayListAdded = function /** @no-inline */(list, index) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).displayListAdded;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, list, index) : _broadcast[i].listener(_recivier, list, index);
                    }
                }
            };
            Scene3d.prototype.displayListRemoved = function /** @no-inline */(list, index) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).displayListRemoved;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, list, index) : _broadcast[i].listener(_recivier, list, index);
                    }
                }
            };
            return Scene3d;
        })();
        scene.Scene3d = Scene3d;        
        // BROADCAST(nodeAttachment, CALL(pNode));
        // BROADCAST(nodeDetachment, CALL(pNode));
            })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (scene) {
        var SceneManager = (function () {
            function /** @no-inline */SceneManager(pEngine) {
                this._pEngine = null;
                this._pSceneList = [];
                this._fUpdateTimeCount = 0.;
                this._fMillisecondsPerTick = 0.0333;
                this._pEngine = pEngine;
                this._pTimer = pEngine.getTimer();
            }
            SceneManager.prototype.getEngine = function /** @no-inline */() {
                return this._pEngine;
            };
            SceneManager.prototype.update = function /** @no-inline */() {
                var isSceneUpdated = false;
                // add the real time elapsed to our
                // internal delay counter
                this._fUpdateTimeCount += this._pTimer.elapsedTime;
                // is there an update ready to happen?
                var fUpdateTime = this._fUpdateTimeCount;
                while(this._fUpdateTimeCount > this._fMillisecondsPerTick) {
                    // update the scene
                    this.notifyUpdateScene();
                    // subtract the time interval
                    // emulated with each tick
                    this._fUpdateTimeCount -= this._fMillisecondsPerTick;
                }
                if(fUpdateTime !== this._fUpdateTimeCount) {
                    this.notifyPreUpdateScene();
                }
            };
            SceneManager.prototype.notifyUpdateScene = function /** @no-inline */() {
                // update the scene attached to the root node
                for(var i = 0; i < this._pSceneList.length; ++i) {
                    var pScene = this._pSceneList[i];
                    if(pScene.type != 0 /* TYPE_3D */ ) {
                        continue;
                    }
                    (pScene).recursiveUpdate();
                }
            };
            SceneManager.prototype.notifyPreUpdateScene = function /** @no-inline */() {
                for(var i = 0; i < this._pSceneList.length; ++i) {
                    var pScene = this._pSceneList[i];
                    if(pScene.type != 0 /* TYPE_3D */ ) {
                        continue;
                    }
                    (pScene).recursivePreUpdate();
                }
            };
            SceneManager.prototype.createScene3D = function /** @no-inline */() {
                var pScene = new scene.Scene3d(this);
                this._pSceneList.push(pScene);
                return pScene;
            };
            SceneManager.prototype.createScene2D = function /** @no-inline */() {
                return null;
            };
            SceneManager.prototype.getScene3D = function /** @no-inline */(iScene) {
                if (typeof iScene === "undefined") { iScene = 0; }
                var pScene;
                if(iScene === 0 && this._pSceneList.length === 0) {
                    akra.logger.setSourceLocation("scene/SceneManager.ts", 95);
                    akra.logger.log("creating default scene...");
                    ;
                    this.createScene3D();
                }
                pScene = this._pSceneList[iScene];
                if(pScene && pScene.type === 0 /* TYPE_3D */ ) {
                    return pScene;
                }
                return null;
            };
            SceneManager.prototype.getScene2D = function /** @no-inline */(IScene) {
                var pScene = this._pSceneList[IScene];
                if(pScene && pScene.type === 1 /* TYPE_2D */ ) {
                    return pScene;
                }
                return null;
            };
            SceneManager.prototype.getScene = function /** @no-inline */(IScene, eType) {
                return this._pSceneList[IScene] || null;
            };
            SceneManager.prototype.initialize = function /** @no-inline */() {
                //this.initText2Dlayer();
                return true;
            };
            SceneManager.prototype.destroy = function /** @no-inline */() {
            };
            return SceneManager;
        })();
        scene.SceneManager = SceneManager;        
    })(akra.scene || (akra.scene = {}));
    var scene = akra.scene;
})(akra || (akra = {}));
var akra;
(function (akra) {
    /** @inline */
    /*
    draw2DText(iX: int = 0, iY: int = 0, sText: string = "", pFont: IFont2d = new util.Font2d()): IString2d {
    return (new a.String2D(iX, iY, pFont, sStr, this.pTextLayer));
    }
    
    
    
    private initText2Dlayer(): void {
    var pCanvas: HTMLCanvasElement = this.pEngine.canvas;
    var x: int = findPosX(pCanvas);
    var y: int = findPosY(pCanvas);
    
    var pDiv: HTMLDivElement = <HTMLDivElement>document.createElement('div');
    var pStyle: CSSStyleDeclaration = pDiv.style;
    var pScreen: IScreenInfo = info.screen;
    
    var iBorder: int = 0;
    
    pDiv.setAttribute("id", "akra-canvas-overlay");
    
    pStyle.width = String(pScreen.width) + "px";
    pStyle.height = String(pScreen.height) + "px";
    
    if (pCanvas.style.border != "none") {
    iBorder = parseInt(pCanvas.style.border);
    }
    
    pStyle.position = 'absolute';
    pStyle.left = String(x) + 'px';
    pStyle.top = String(y) + 'px';
    
    pStyle.overflow = 'hidden';
    pStyle.whiteSpace = 'nowrap';
    
    if (pCanvas.style.zIndex) {
    pStyle.zIndex = pCanvas.style.zIndex + 1;
    }
    else {
    pStyle.zIndex = 2;
    }
    
    document.body.appendChild(pDiv);
    
    this.pTextLayer = pDiv;
    }
    */
    (function (util) {
        var UtilTimer = (function () {
            function UtilTimer() {
                this.isTimerInitialized = false;
                this.isTimerStopped = false;
                this.fTicksPerSec = 0.;
                this.iStopTime = 0;
                this.iLastElapsedTime = 0;
                this.iBaseTime = 0;
            }
            Object.defineProperty(UtilTimer.prototype, "absoluteTime", {
                get: function /** @no-inline */() {
                    return this.execCommand(4 /* TIMER_GET_ABSOLUTE_TIME */ );
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UtilTimer.prototype, "appTime", {
                get: function /** @no-inline */() {
                    return this.execCommand(5 /* TIMER_GET_APP_TIME */ );
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UtilTimer.prototype, "elapsedTime", {
                get: function /** @no-inline */() {
                    return this.execCommand(6 /* TIMER_GET_ELAPSED_TIME */ );
                },
                enumerable: true,
                configurable: true
            });
            UtilTimer.prototype.start = function /** @no-inline */() {
                return this.execCommand(1 /* TIMER_START */ ) === 0;
            };
            UtilTimer.prototype.stop = function /** @no-inline */() {
                return this.execCommand(2 /* TIMER_STOP */ ) === 0;
            };
            UtilTimer.prototype.reset = function /** @no-inline */() {
                return this.execCommand(0 /* TIMER_RESET */ ) === 0;
            };
            UtilTimer.prototype.execCommand = function /** @no-inline */(eCommand) {
                var fTime = 0.;
                var fElapsedTime = 0.;
                var iTime;
                if(this.isTimerInitialized == false) {
                    this.isTimerInitialized = true;
                    this.fTicksPerSec = 1000;
                }
                // Get either the current time or the stop time, depending
                // on whether we're stopped and what command was sent
                if(this.iStopTime != 0 && eCommand != 1 /* TIMER_START */  && eCommand != 4 /* TIMER_GET_ABSOLUTE_TIME */ ) {
                    iTime = this.iStopTime;
                } else {
                    iTime = (new Date()).getTime();
                }
                // Return the elapsed time
                if(eCommand == 6 /* TIMER_GET_ELAPSED_TIME */ ) {
                    fElapsedTime = (iTime - this.iLastElapsedTime) / this.fTicksPerSec;
                    this.iLastElapsedTime = iTime;
                    return fElapsedTime;
                }
                // Return the current time
                if(eCommand == 5 /* TIMER_GET_APP_TIME */ ) {
                    var fAppTime = (iTime - this.iBaseTime) / this.fTicksPerSec;
                    return fAppTime;
                }
                // Reset the timer
                if(eCommand == 0 /* TIMER_RESET */ ) {
                    this.iBaseTime = iTime;
                    this.iLastElapsedTime = iTime;
                    this.iStopTime = 0;
                    this.isTimerStopped = false;
                    return 0;
                }
                // Start the timer
                if(eCommand == 1 /* TIMER_START */ ) {
                    if(this.isTimerStopped) {
                        this.iBaseTime += iTime - this.iStopTime;
                    }
                    this.iStopTime = 0;
                    this.iLastElapsedTime = iTime;
                    this.isTimerStopped = false;
                    return 0;
                }
                // Stop the timer
                if(eCommand == 2 /* TIMER_STOP */ ) {
                    if(!this.isTimerStopped) {
                        this.iStopTime = iTime;
                        this.iLastElapsedTime = iTime;
                        this.isTimerStopped = true;
                    }
                    return 0;
                }
                // Advance the timer by 1/10th second
                if(eCommand == 3 /* TIMER_ADVANCE */ ) {
                    this.iStopTime += this.fTicksPerSec / 10;
                    return 0;
                }
                if(eCommand == 4 /* TIMER_GET_ABSOLUTE_TIME */ ) {
                    fTime = iTime / this.fTicksPerSec;
                    return fTime;
                }
                // Invalid command specified		    return -1;
                            };
            UtilTimer.start = function /** @no-inline */start() {
                var pTimer = new UtilTimer();
                if(pTimer.start()) {
                    return pTimer;
                }
                util.logger.setSourceLocation("util/UtilTimer.ts", 123);
                util.logger.error('cannot start util timer');
                ;
                return null;
            };
            return UtilTimer;
        })();
        util.UtilTimer = UtilTimer;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    // #ifndef IAFXEFFECT_TS
    // #define IAFXEFFECT_TS
    // #include "IResourcePoolItem.ts"
    // module akra {
    // 	export interface IAFXEffect extends IResourcePoolItem {
    // 	}
    // }
    // #endif
    // #ifndef IAFXEFFECT_TS
    // #define IAFXEFFECT_TS
    // #include "IResourcePoolItem.ts"
    // module akra {
    // 	export interface IAFXEffect extends IResourcePoolItem {
    // 	}
    // }
    // #endif
    (function (fx) {
        //Errors
        akra.logger.registerCode(2201, "You trying to redefine system type: {typeName}. In line: {line}. In column: {column}");
        akra.logger.registerCode(2202, "You trying to redefine type: {typeName}. In line: {line}. In column: {column}");
        akra.logger.registerCode(2203, "You try to use unssuported type declaration. We implement it soon. In line: {line}.");
        akra.logger.registerCode(2204, "You try to use unssuported expr: {exprName}. We implement it soon. In line: {line}.");
        akra.logger.registerCode(2205, "Unknown variable name: {varName}. In line: {line}. In column: {column}");
        akra.logger.registerCode(2206, "Invalid arithmetic operation!. There no operator '{operator}'    						  for left-type '{leftTypeName}'     						 and right-type '{rightTypeName}'. In line: {line}.");
        akra.logger.registerCode(2207, "Invalid arithmetic-assignment operation!.     						 There no operator {operator} for left-type '{leftTypeName}'     						 and right-type '{rightTypeName}'. In line: {line}.");
        akra.logger.registerCode(2208, "Invalid assignment operation!. It`s no possible to do assignment     						 between left-type '{leftTypeName}'     						 and right-type '{rightTypeName}'. In line: {line}.");
        akra.logger.registerCode(2209, "Invalid relational operation!. There no operator {operator}     						 for left-type '{leftTypeName}'     						 and right-type '{rightTypeName}'. In line: {line}.");
        akra.logger.registerCode(2210, "Invalid logical operation!. In operator: {operator}.     						 Cannot convert type '{typeName}' to 'bool'. In line: {line}.");
        akra.logger.registerCode(2211, "Invalid conditional expression!. Cannot convert type '{typeName}' to 'bool'.     						 In line: {line}.");
        akra.logger.registerCode(2212, "Invalid conditional expression!. Type '{leftTypeName}' and type '{rightTypeName}'    						  are not equal. In line: {line}.");
        akra.logger.registerCode(2213, "Invalid type cast!. Bad type casting. Only base types without usages are supported.     						 WebGL don`t support so casting. In line: {line}.");
        akra.logger.registerCode(2214, "Invalid type cast!. Bad type for casting '{typeName}'.     						 WebGL support only base-type casting. In line: {line}.");
        akra.logger.registerCode(2216, "Invalid unary expression!. Bad type: '{typeName}'     						 for operator '{opeator}'. In line: {line}.");
        akra.logger.registerCode(2217, "Invalid postfix-array expression!.     						 Type of expression is not array: '{typeName}'. In line: {line}.");
        akra.logger.registerCode(2218, "Invalid postfix-array expression!. Bad type of index: '{typeName}'.     						 Must be 'int'. In line: {line}.");
        akra.logger.registerCode(2219, "Invalid postfix-point expression!. Type '{typeName}' has no field '{fieldName}'.     						 In line: {line}.");
        akra.logger.registerCode(2220, "Invalid postfix-point expression!. Type '{typeName}' is not pointer.     						 In line: {line}.");
        akra.logger.registerCode(2221, "Invalid postfix-arithmetic expression!. Bad type '{typeName}'     						 for operator {operator}. In line: {line}.");
        akra.logger.registerCode(2222, "Invalid primary expression!. Bad type '{typeName}'.    						 It`s not pointer. In line: {line}.");
        akra.logger.registerCode(2223, "Invalid function call expression!. Could not find function-signature     						 with name {funcName} and so types. In line: {line}.");
        akra.logger.registerCode(2224, "Invalid constructor call!. There are not so type. In line: {line}.");
        akra.logger.registerCode(2225, "Invalid constructor call!. Could not find constructor-signature     						 with name {typeName} and so types. In line: {line}.");
        akra.logger.registerCode(2226, "Invalid compile expression!. Could not find function-signature     						 with name {funcName} and so types. In line: {line}.");
        akra.logger.registerCode(2227, "You try to redefine function. With name {funcName}. In line: {line}.");
        akra.logger.registerCode(2228, "Bad type of while-condition. Must be 'bool' but it is '{typeName}'. 							 In line: {line}.");
        akra.logger.registerCode(2229, "Bad type of do-while-condition. Must be 'bool' but it is '{typeName}'. 							 In line: {line}.");
        akra.logger.registerCode(2230, "Bad type of if-condition. Must be 'bool' but it is '{typeName}'. 							 In line: {line}.");
        akra.logger.registerCode(2231, "Bad for-init expression. WebGL support only VariableDecl as for-init expression, 							 like \"int i = 0;\" or \"float i = 0.0;\". 							 In line: {line}.");
        akra.logger.registerCode(2232, "Bad for-init expression. WebGL support only VariableDecl as for-init expression, 							 like \"int i = 0;\" or \"float i = 0.0;\". 							 In line: {line}.");
        akra.logger.registerCode(2233, "Bad for-cond expression. WebGL does not support empty conditional expression in for-loop. 							 In line: {line}.");
        akra.logger.registerCode(2238, "Bad for-cond expression. WebGL support only relational expression for condition in for-loop. 							 In line: {line}.");
        akra.logger.registerCode(2239, "Bad for-step expression. WebGL does not support empty step expression. 							 In line: {line}.");
        akra.logger.registerCode(2240, "Bad for-step expression. WebGL does not support operator '{operator}' in step expression. 							 In line: {line}.");
        akra.logger.registerCode(2241, "Bad for-step expression. WebGL support only unary and assignment expression in for-step. 							 In line: {line}.");
        akra.logger.registerCode(2235, "You trying to redefine system variable: {varName}. In line: {line}. In column: {column}");
        akra.logger.registerCode(2234, "You trying to redefine variable: {varName}. In line: {line}. In column: {column}");
        akra.logger.registerCode(2237, "You trying to redefine system function: {funcName}. In line: {line}. In column: {column}");
        akra.logger.registerCode(2236, "You trying to redefine function: {funcName}. In line: {line}. In column: {column}");
        akra.logger.registerCode(2242, "You trying to add field to struct with name '{varName}', but it`s already in it.     						 In line: {line}. In column: {column}");
        akra.logger.registerCode(2243, "You trying to add field to struct with semantic '{semanticName}',    	 					  but struct already has this semantic.    	 					  In line: {line}. In column: {column}");
        akra.logger.registerCode(2244, "Bad variable name '{varName}'. Annotation already has variable with that name.    	 					  In line: {line}. In column: {column}");
        akra.logger.registerCode(2245, "Bad parameter '{varName}' in function '{funcName}'. Need default value.                              In line: {line}. In column: {column}");
        akra.logger.registerCode(2246, "Bad function call. There are two or more call signatures for function '{funcName}'.                              In line: {line}. In column: {column}");
        akra.logger.registerCode(2247, "Bad function definition. There are two or more different retturn type signatures for function '{funcName}'.                              In line: {line}. In column: {column}");
        akra.logger.registerCode(2248, "Bad system function '{funcName}'. Already have this function.");
        akra.logger.registerCode(2250, "Bad type. Could not find type with name '{typeName}'.                              In line: {line}. In column: {column}");
        akra.logger.registerCode(2251, "Bad type. We don`t support vector and matrix typename.                              In line: {line}. In column: {column}");
        akra.logger.registerCode(2252, "Bad technique name '{techName}'. Effect already have technique with that name.                              In line: {line}. In column: {column}");
        akra.logger.registerCode(2253, "Bad 'memof'-operator argument. Literal for its argument is bad idea.                              In line: {line}. In column: {column}");
        akra.logger.registerCode(2254, "Bad 'memof'-operator argument. No buffer for argument.                              In line: {line}. In column: {column}");
        akra.logger.registerCode(2255, "Bad function '{funcDef}'. It is recursion.");
        akra.logger.registerCode(2256, "Bad function '{funcDef}'. It use bad-function with recursion.");
        akra.logger.registerCode(2257, "Bad function '{funcDef}'. Can not use in vertex-shader.");
        akra.logger.registerCode(2258, "Bad function '{funcDef}'. Can not use in pixel-shader.");
        akra.logger.registerCode(2259, "Bad function with defenition '{funcDef}'. Can not be used as vertex-shader.");
        akra.logger.registerCode(2260, "Bad function with defenition '{funcDef}'. Can not be used as pixel-shader.");
        akra.logger.registerCode(2261, "Bad return stmt. You try to return something in void-function.                              In line: {line}. In column: {column}");
        akra.logger.registerCode(2262, "Bad return stmt. You can not call empty return in non-void-function.                              In line: {line}. In column: {column}");
        akra.logger.registerCode(2263, "Bad return stmt. Types of return expression and return type of function are not equal.                              In line: {line}. In column: {column}");
        akra.logger.registerCode(2264, "Bad return type for '{funcName}'. Return type for function can not contain or be sampler/pointer.                              In line: {line}. In column: {column}");
        akra.logger.registerCode(2265, "Bad parameter '{varName}' in function '{funcName}'. Bad usage.                              In line: {line}. In column: {column}");
        akra.logger.registerCode(2266, "Bad variable with name 'Out'. It is sytem for used like return variable in shaders.                              In line: {line}. In column: {column}");
        akra.logger.registerCode(2267, "Variable type is not writable.                              In line: {line}. In column: {column}");
        akra.logger.registerCode(2300, "We don`t support array of pinters now. Only pointe to array.                              In line: {line}. In column: {column}");
        function /** @no-inline */sourceLocationToString(pLocation) {
            var sLocation = "[" + pLocation.file + ":" + pLocation.line.toString() + "]: ";
            return sLocation;
        }
        function /** @no-inline */syntaxErrorLogRoutine(pLogEntity) {
            var sPosition = sourceLocationToString(pLogEntity.location);
            var sError = "Code: " + pLogEntity.code.toString() + ". ";
            var pParseMessage = pLogEntity.message.split(/\{(\w+)\}/);
            var pInfo = pLogEntity.info;
            for(var i = 0; i < pParseMessage.length; i++) {
                if(akra.isDef(pInfo[pParseMessage[i]])) {
                    pParseMessage[i] = pInfo[pParseMessage[i]];
                }
            }
            var sMessage = sPosition + sError + pParseMessage.join("");
            console["error"].call(console, sMessage);
        }
        akra.logger.setCodeFamilyRoutine("EffectSyntaxErrors", syntaxErrorLogRoutine, 8 /* ERROR */ );
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        (function (EScopeType) {
            EScopeType._map = [];
            EScopeType._map[0] = "k_Default";
            EScopeType.k_Default = 0;
            EScopeType._map[1] = "k_Struct";
            EScopeType.k_Struct = 1;
            EScopeType._map[2] = "k_Annotation";
            EScopeType.k_Annotation = 2;
        })(fx.EScopeType || (fx.EScopeType = {}));
        var EScopeType = fx.EScopeType;
        var ProgramScope = (function () {
            function /** @no-inline */ProgramScope() {
                this._pScopeMap = {
                };
                this._iCurrentScope = null;
                this._nScope = 0;
            }
            ProgramScope.prototype.isStrictMode = function /** @no-inline */(iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                var pScope = this._pScopeMap[iScope];
                while(!akra.isNull(pScope)) {
                    if(pScope.isStrictMode) {
                        return true;
                    }
                    pScope = pScope.parent;
                }
            };
            ProgramScope.prototype.setStrictModeOn = function /** @no-inline */(iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                this._pScopeMap[iScope].isStrictMode = true;
            };
            ProgramScope.prototype.newScope = function /** @no-inline */(eType) {
                var isFirstScope = false;
                var pParentScope;
                if(akra.isNull(this._iCurrentScope)) {
                    pParentScope = null;
                } else {
                    pParentScope = this._pScopeMap[this._iCurrentScope];
                }
                this._iCurrentScope = this._nScope++;
                var pNewScope = {
                    parent: pParentScope,
                    index: this._iCurrentScope,
                    type: eType,
                    isStrictMode: false,
                    variableMap: null,
                    typeMap: null,
                    functionMap: null
                };
                this._pScopeMap[this._iCurrentScope] = pNewScope;
            };
            ProgramScope.prototype.resumeScope = function /** @no-inline */() {
                if(this._nScope === 0) {
                    return;
                }
                this._iCurrentScope = this._nScope - 1;
            };
            ProgramScope.prototype.setScope = function /** @no-inline */(iScope) {
                this._iCurrentScope = iScope;
            };
            ProgramScope.prototype.getScope = function /** @no-inline */() {
                return this._iCurrentScope;
            };
            ProgramScope.prototype.endScope = function /** @no-inline */() {
                if(akra.isNull(this._iCurrentScope)) {
                    return;
                }
                var pOldScope = this._pScopeMap[this._iCurrentScope];
                var pNewScope = pOldScope.parent;
                if(akra.isNull(pNewScope)) {
                    this._iCurrentScope = null;
                } else {
                    this._iCurrentScope = pNewScope.index;
                }
            };
            ProgramScope.prototype.getScopeType = function /** @inline */() {
                return this._pScopeMap[this._iCurrentScope].type;
            };
            ProgramScope.prototype.getVariable = function /** @no-inline */(sVariableName, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                if(akra.isNull(iScope)) {
                    return null;
                }
                var pScope = this._pScopeMap[iScope];
                while(!akra.isNull(pScope)) {
                    var pVariableMap = pScope.variableMap;
                    if(!akra.isNull(pVariableMap)) {
                        var pVariable = pVariableMap[sVariableName];
                        if(akra.isDef(pVariable)) {
                            return pVariable;
                        }
                    }
                    pScope = pScope.parent;
                }
                return null;
            };
            ProgramScope.prototype.getType = function /** @no-inline */(sTypeName, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                var pTypeDecl = this.getTypeDecl(sTypeName, iScope);
                if(!akra.isNull(pTypeDecl)) {
                    return pTypeDecl.getType();
                } else {
                    return null;
                }
            };
            ProgramScope.prototype.getTypeDecl = function /** @no-inline */(sTypeName, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                if(akra.isNull(iScope)) {
                    return null;
                }
                var pScope = this._pScopeMap[iScope];
                while(!akra.isNull(pScope)) {
                    var pTypeMap = pScope.typeMap;
                    if(!akra.isNull(pTypeMap)) {
                        var pType = pTypeMap[sTypeName];
                        if(akra.isDef(pType)) {
                            return pType;
                        }
                    }
                    pScope = pScope.parent;
                }
                return null;
            };
            ProgramScope.prototype.getFunction = /**
            * get function by name and list of types
            * return null - if threre are not function; undefined - if there more then one function; function - if all ok
            */
            function /** @no-inline */(sFuncName, pArgumentTypes, iScope) {
                if (typeof iScope === "undefined") { iScope = 0; }
                if(akra.isNull(iScope)) {
                    return null;
                }
                var pScope = this._pScopeMap[iScope];
                var pFunction = null;
                while(!akra.isNull(pScope)) {
                    var pFunctionListMap = pScope.functionMap;
                    if(!akra.isNull(pFunctionListMap)) {
                        var pFunctionList = pFunctionListMap[sFuncName];
                        if(akra.isDef(pFunctionList)) {
                            for(var i = 0; i < pFunctionList.length; i++) {
                                var pTestedFunction = pFunctionList[i];
                                var pTestedArguments = pTestedFunction.getArguments();
                                if(pArgumentTypes.length > pTestedArguments.length || pArgumentTypes.length < pTestedFunction.getNumNeededArguments()) {
                                    continue;
                                }
                                var isParamsEqual = true;
                                for(var j = 0; j < pArgumentTypes.length; j++) {
                                    isParamsEqual = false;
                                    if(!pArgumentTypes[j].getType().isEqual(pTestedArguments[j].getType())) {
                                        break;
                                    }
                                    isParamsEqual = true;
                                }
                                if(isParamsEqual) {
                                    if(!akra.isNull(pFunction)) {
                                        return undefined;
                                    }
                                    pFunction = pTestedFunction;
                                }
                            }
                        }
                    }
                    pScope = pScope.parent;
                }
                return pFunction;
            };
            ProgramScope.prototype.getShaderFunction = /**
            * get shader function by name and list of types
            * return null - if threre are not function; undefined - if there more then one function; function - if all ok
            */
            function /** @no-inline */(sFuncName, pArgumentTypes, iScope) {
                if (typeof iScope === "undefined") { iScope = 0; }
                if(akra.isNull(iScope)) {
                    return null;
                }
                var pScope = this._pScopeMap[iScope];
                var pFunction = null;
                while(!akra.isNull(pScope)) {
                    var pFunctionListMap = pScope.functionMap;
                    if(!akra.isNull(pFunctionListMap)) {
                        var pFunctionList = pFunctionListMap[sFuncName];
                        if(akra.isDef(pFunctionList)) {
                            for(var i = 0; i < pFunctionList.length; i++) {
                                var pTestedFunction = pFunctionList[i];
                                var pTestedArguments = pTestedFunction.getArguments();
                                if(pArgumentTypes.length > pTestedArguments.length) {
                                    continue;
                                }
                                var isParamsEqual = true;
                                var iArg = 0;
                                if(pArgumentTypes.length === 0) {
                                    if(!akra.isNull(pFunction)) {
                                        return undefined;
                                    }
                                    pFunction = pTestedFunction;
                                    continue;
                                }
                                for(var j = 0; j < pTestedArguments.length; j++) {
                                    isParamsEqual = false;
                                    if(iArg >= pArgumentTypes.length) {
                                        if(pTestedArguments[j].isUniform()) {
                                            break;
                                        } else {
                                            isParamsEqual = true;
                                        }
                                    } else if(pTestedArguments[j].isUniform()) {
                                        if(!pArgumentTypes[iArg].getType().isEqual(pTestedArguments[j].getType())) {
                                            break;
                                        } else {
                                            iArg++;
                                            isParamsEqual = true;
                                        }
                                    }
                                }
                                if(isParamsEqual) {
                                    if(!akra.isNull(pFunction)) {
                                        return undefined;
                                    }
                                    pFunction = pTestedFunction;
                                }
                            }
                        }
                    }
                    pScope = pScope.parent;
                }
                return pFunction;
            };
            ProgramScope.prototype.addVariable = function /** @no-inline */(pVariable, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                if(akra.isNull(iScope)) {
                    return false;
                }
                var pScope = this._pScopeMap[iScope];
                var pVariableMap = pScope.variableMap;
                if(!akra.isDef(pVariableMap)) {
                    pVariableMap = pScope.variableMap = {
                    };
                }
                var sVariableName = pVariable.getName();
                if(this.hasVariableInScope(sVariableName, iScope)) {
                    return false;
                }
                pVariableMap[sVariableName] = pVariable;
                return true;
            };
            ProgramScope.prototype.addType = function /** @no-inline */(pType, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                if(akra.isNull(iScope)) {
                    return false;
                }
                var pScope = this._pScopeMap[iScope];
                var pTypeMap = pScope.typeMap;
                if(!akra.isDef(pTypeMap)) {
                    pTypeMap = pScope.typeMap = {
                    };
                }
                var sTypeName = pType.getName();
                if(this.hasTypeInScope(sTypeName, iScope)) {
                    return false;
                }
                pTypeMap[sTypeName] = pType;
                return true;
            };
            ProgramScope.prototype.addFunction = function /** @no-inline */(pFunction, iScope) {
                if (typeof iScope === "undefined") { iScope = 0; }
                if(akra.isNull(iScope)) {
                    return false;
                }
                var pScope = this._pScopeMap[iScope];
                var pFunctionMap = pScope.functionMap;
                if(!akra.isDef(pFunctionMap)) {
                    pFunctionMap = pScope.functionMap = {
                    };
                }
                var sFuncName = pFunction.getName();
                if(this.hasFunctionInScope(pFunction, iScope)) {
                    return false;
                }
                if(!akra.isDef(pFunctionMap[sFuncName])) {
                    pFunctionMap[sFuncName] = [];
                }
                pFunctionMap[sFuncName].push(pFunction);
                return true;
            };
            ProgramScope.prototype.hasVariable = function /** @no-inline */(sVariableName, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                if(akra.isNull(iScope)) {
                    return false;
                }
                var pScope = this._pScopeMap[iScope];
                while(!akra.isNull(pScope)) {
                    var pVariableMap = pScope.variableMap;
                    if(!akra.isNull(pVariableMap)) {
                        var pVariable = pVariableMap[sVariableName];
                        if(akra.isDef(pVariable)) {
                            return true;
                        }
                    }
                    pScope = pScope.parent;
                }
                return false;
            };
            ProgramScope.prototype.hasType = function /** @no-inline */(sTypeName, iScope) {
                if (typeof iScope === "undefined") { iScope = this._iCurrentScope; }
                if(akra.isNull(iScope)) {
                    return false;
                }
                var pScope = this._pScopeMap[iScope];
                while(!akra.isNull(pScope)) {
                    var pTypeMap = pScope.typeMap;
                    if(!akra.isNull(pTypeMap)) {
                        var pType = pTypeMap[sTypeName];
                        if(akra.isDef(pType)) {
                            return true;
                        }
                    }
                    pScope = pScope.parent;
                }
                return false;
            };
            ProgramScope.prototype.hasFunction = function /** @no-inline */(sFuncName, pArgumentTypes, iScope) {
                if (typeof iScope === "undefined") { iScope = 0; }
                if(akra.isNull(iScope)) {
                    return false;
                }
                var pScope = this._pScopeMap[iScope];
                while(!akra.isNull(pScope)) {
                    var pFunctionListMap = pScope.functionMap;
                    if(!akra.isNull(pFunctionListMap)) {
                        var pFunctionList = pFunctionListMap[sFuncName];
                        if(akra.isDef(pFunctionList)) {
                            var pFunction = null;
                            for(var i = 0; i < pFunctionList.length; i++) {
                                var pTestedFunction = pFunctionList[i];
                                var pTestedArguments = pTestedFunction.getArguments();
                                if(pArgumentTypes.length > pTestedArguments.length || pArgumentTypes.length < pTestedFunction.getNumNeededArguments()) {
                                    continue;
                                }
                                var isParamsEqual = true;
                                for(var j = 0; j < pArgumentTypes.length; j++) {
                                    isParamsEqual = false;
                                    if(!pArgumentTypes[j].getType().isEqual(pTestedArguments[j].getType())) {
                                        break;
                                    }
                                    isParamsEqual = true;
                                }
                                if(isParamsEqual) {
                                    return true;
                                }
                            }
                        }
                    }
                    pScope = pScope.parent;
                }
                return false;
            };
            ProgramScope.prototype.hasVariableInScope = function /** @inline */(sVariableName, iScope) {
                return akra.isDef(this._pScopeMap[iScope].variableMap[sVariableName]);
            };
            ProgramScope.prototype.hasTypeInScope = function /** @inline */(sTypeName, iScope) {
                return akra.isDef(this._pScopeMap[iScope].typeMap[sTypeName]);
            };
            ProgramScope.prototype.hasFunctionInScope = function /** @no-inline */(pFunction, iScope) {
                if(akra.isNull(iScope)) {
                    return false;
                }
                var pScope = this._pScopeMap[iScope];
                var pFunctionListMap = pScope.functionMap;
                var pFunctionList = pFunctionListMap[pFunction.getName()];
                if(!akra.isDef(pFunctionList)) {
                    return false;
                }
                var pFunctionArguments = pFunction.getArguments();
                var hasFunction = false;
                for(var i = 0; i < pFunctionList.length; i++) {
                    var pTestedArguments = pFunctionList[i].getArguments();
                    if(pTestedArguments.length !== pFunctionArguments.length) {
                        continue;
                    }
                    var isParamsEqual = true;
                    for(var j = 0; j < pFunctionArguments.length; j++) {
                        isParamsEqual = false;
                        if(!pTestedArguments[j].getType().isEqual(pFunctionArguments[j].getType())) {
                            break;
                        }
                        isParamsEqual = true;
                    }
                    if(isParamsEqual) {
                        hasFunction = true;
                        break;
                    }
                }
                return hasFunction;
            };
            return ProgramScope;
        })();
        fx.ProgramScope = ProgramScope;        
        var ExprTemplateTranslator = (function () {
            function /** @no-inline */ExprTemplateTranslator(sExprTemplate) {
                this._pInToOutArgsMap = null;
                this._pExprPart = null;
                this._pInToOutArgsMap = {
                };
                this._pExprPart = [];
                var pSplitTemplate = sExprTemplate.split(/(\$\d+)/);
                for(var i = 0; i < pSplitTemplate.length; i++) {
                    if(pSplitTemplate[i]) {
                        if(pSplitTemplate[i][0] !== '$') {
                            this._pExprPart.push(new fx.SimpleInstruction(pSplitTemplate[i]));
                        } else {
                            this._pExprPart.push(null);
                            this._pInToOutArgsMap[this._pExprPart.length - 1] = (((pSplitTemplate[i].substr(1))) * 1 - 1);
                        }
                    }
                }
            }
            ExprTemplateTranslator.prototype.toInstructionList = function /** @no-inline */(pArguments) {
                var pOutputInstructionList = [];
                for(var i = 0; i < this._pExprPart.length; i++) {
                    if(akra.isNull(this._pExprPart[i])) {
                        pOutputInstructionList.push(pArguments[this._pInToOutArgsMap[i]]);
                    } else {
                        pOutputInstructionList.push(this._pExprPart[i]);
                    }
                }
                return pOutputInstructionList;
            };
            return ExprTemplateTranslator;
        })();
        fx.ExprTemplateTranslator = ExprTemplateTranslator;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        function /** @no-inline */getEffectBaseType(sTypeName) {
            return !akra.isNull(fx.Effect.pSystemTypes[sTypeName]) ? (fx.Effect.pSystemTypes[sTypeName] || null) : null;
        }
        fx.getEffectBaseType = getEffectBaseType;
        function /** @no-inline */isSamplerType(pType) {
            return pType.isEqual(getEffectBaseType("sampler")) || pType.isEqual(getEffectBaseType("sampler2D")) || pType.isEqual(getEffectBaseType("samplerCUBE")) || pType.isEqual(getEffectBaseType("video_buffer"));
        }
        fx.isSamplerType = isSamplerType;
        var Instruction = (function () {
            function /** @no-inline */Instruction() {
                /**@protected*/ this._pParentInstruction = null;
                /**@protected*/ this._sOperatorName = null;
                /**@protected*/ this._pInstructionList = null;
                /**@protected*/ this._nInstuctions = 0;
                /**@protected*/ this._eInstructionType = 0;
                /**@protected*/ this._pLastError = null;
                /**@protected*/ this._iInstructionID = 0;
                this._iInstructionID = Instruction._nInstructionCounter++;
                this._pParentInstruction = null;
                this._sOperatorName = null;
                this._pInstructionList = null;
                this._nInstuctions = 0;
                this._eInstructionType = 0 /* k_Instruction */ ;
                this._pLastError = {
                    code: 0,
                    info: null
                };
            }
            Instruction._nInstructionCounter = 0;
            Instruction.prototype.getParent = function /** @inline */() {
                return this._pParentInstruction;
            };
            Instruction.prototype.setParent = function /** @inline */(pParentInstruction) {
                this._pParentInstruction = pParentInstruction;
            };
            Instruction.prototype.getOperator = function /** @inline */() {
                return this._sOperatorName;
            };
            Instruction.prototype.setOperator = function /** @inline */(sOperator) {
                this._sOperatorName = sOperator;
            };
            Instruction.prototype.getInstructions = function /** @inline */() {
                return this._pInstructionList;
            };
            Instruction.prototype.setInstructions = function /** @inline */(pInstructionList) {
                this._pInstructionList = pInstructionList;
            };
            Instruction.prototype._getInstructionType = function /** @inline */() {
                return this._eInstructionType;
            };
            Instruction.prototype._getInstructionID = function /** @inline */() {
                return this._iInstructionID;
            };
            Instruction.prototype.getLastError = function /** @inline */() {
                return this._pLastError;
            };
            Instruction.prototype.setError = function /** @inline */(eCode, pInfo) {
                this._pLastError.code = eCode;
                this._pLastError.info = pInfo;
            };
            Instruction.prototype.push = function /** @no-inline */(pInstruction, isSetParent) {
                if (typeof isSetParent === "undefined") { isSetParent = false; }
                if(!akra.isNull(this._pInstructionList)) {
                    this._pInstructionList[this._nInstuctions] = pInstruction;
                    this._nInstuctions += 1;
                }
                if(isSetParent && !akra.isNull(pInstruction)) {
                    pInstruction.setParent(this);
                }
            };
            Instruction.prototype.addRoutine = function /** @no-inline */(fnRoutine, iPriority) {
                //TODO
                            };
            Instruction.prototype.check = /**
            * Проверка валидности инструкции
            */
            function /** @no-inline */(eStage, pInfo) {
                if (typeof pInfo === "undefined") { pInfo = null; }
                return true;
            };
            Instruction.prototype.prepare = /**
            * Подготовка интсрукции к дальнейшему анализу
            */
            function /** @no-inline */() {
                return true;
            };
            Instruction.prototype.toString = function /** @no-inline */() {
                return null;
            };
            Instruction.prototype.clone = function /** @no-inline */(pRelationMap) {
                if (typeof pRelationMap === "undefined") { pRelationMap = {
                }; }
                if(akra.isDef(pRelationMap[this._getInstructionID()])) {
                    return pRelationMap[this._getInstructionID()];
                }
                var pNewInstruction = new this["constructor"]();
                var pParent = this.getParent() || null;
                if(!akra.isNull(pParent) && akra.isDef(pRelationMap[pParent._getInstructionID()])) {
                    pParent = pRelationMap[pParent._getInstructionID()];
                }
                pNewInstruction.setParent(pParent);
                pRelationMap[this._getInstructionID()] = pNewInstruction;
                for(var i = 0; i < this._pInstructionList.length; i++) {
                    pNewInstruction.push(this._pInstructionList[i].clone(pRelationMap));
                }
                pNewInstruction.setOperator(this.getOperator());
                return pNewInstruction;
            };
            return Instruction;
        })();
        fx.Instruction = Instruction;        
        var SimpleInstruction = (function (_super) {
            __extends(SimpleInstruction, _super);
            function /** @no-inline */SimpleInstruction(sValue) {
                        _super.call(this);
                this._sValue = "";
                this._pInstructionList = null;
                this._eInstructionType = 1 /* k_SimpleInstruction */ ;
                this._sValue = sValue;
            }
            SimpleInstruction.prototype.setValue = function /** @inline */(sValue) {
                this._sValue = sValue;
            };
            SimpleInstruction.prototype.isValue = function /** @inline */(sValue) {
                return (this._sValue === sValue);
            };
            SimpleInstruction.prototype.toString = function /** @no-inline */() {
                return this._sValue;
            };
            return SimpleInstruction;
        })(Instruction);
        fx.SimpleInstruction = SimpleInstruction;        
        var TypedInstruction = (function (_super) {
            __extends(TypedInstruction, _super);
            function /** @no-inline */TypedInstruction() {
                        _super.call(this);
                this._pType = null;
                this._eInstructionType = 5 /* k_TypedInstruction */ ;
            }
            TypedInstruction.prototype.getType = function /** @no-inline */() {
                return this._pType;
            };
            TypedInstruction.prototype.setType = function /** @no-inline */(pType) {
                this._pType = pType;
            };
            TypedInstruction.prototype.clone = function /** @no-inline */(pRelationMap) {
                if (typeof pRelationMap === "undefined") { pRelationMap = {
                }; }
                var pClonedInstruction = (_super.prototype.clone.call(this, pRelationMap));
                pClonedInstruction.setType(this._pType.clone(pRelationMap));
                return pClonedInstruction;
            };
            return TypedInstruction;
        })(Instruction);
        fx.TypedInstruction = TypedInstruction;        
        var DeclInstruction = (function (_super) {
            __extends(DeclInstruction, _super);
            function /** @no-inline */DeclInstruction() {
                        _super.call(this);
                /**@protected*/ this._sSemantic = "";
                /**@protected*/ this._pAnnotation = null;
                /**@protected*/ this._bForPixel = true;
                /**@protected*/ this._bForVertex = true;
                this._eInstructionType = 6 /* k_DeclInstruction */ ;
            }
            DeclInstruction.prototype.setSemantic = function /** @no-inline */(sSemantic) {
                this._sSemantic = sSemantic;
            };
            DeclInstruction.prototype.setAnnotation = function /** @no-inline */(pAnnotation) {
                this._pAnnotation = pAnnotation;
            };
            DeclInstruction.prototype.getName = function /** @no-inline */() {
                return "";
            };
            DeclInstruction.prototype.getNameId = function /** @no-inline */() {
                return null;
            };
            DeclInstruction.prototype.getSemantic = function /** @inline */() {
                return this._sSemantic;
            };
            DeclInstruction.prototype._isForAll = function /** @inline */() {
                return this._bForVertex && this._bForPixel;
            };
            DeclInstruction.prototype._isForPixel = function /** @inline */() {
                return this._bForPixel;
            };
            DeclInstruction.prototype._isForVertex = function /** @inline */() {
                return this._bForVertex;
            };
            DeclInstruction.prototype._setForAll = function /** @inline */(canUse) {
                this._bForVertex = canUse;
                this._bForPixel = canUse;
            };
            DeclInstruction.prototype._setForPixel = function /** @inline */(canUse) {
                this._bForPixel = canUse;
            };
            DeclInstruction.prototype._setForVertex = function /** @inline */(canUse) {
                this._bForVertex = canUse;
            };
            DeclInstruction.prototype.clone = function /** @no-inline */(pRelationMap) {
                if (typeof pRelationMap === "undefined") { pRelationMap = {
                }; }
                var pClonedInstruction = (_super.prototype.clone.call(this, pRelationMap));
                pClonedInstruction.setSemantic(this._sSemantic);
                pClonedInstruction.setAnnotation(this._pAnnotation);
                return pClonedInstruction;
            };
            return DeclInstruction;
        })(TypedInstruction);
        fx.DeclInstruction = DeclInstruction;        
        var IdInstruction = (function (_super) {
            __extends(IdInstruction, _super);
            /**
            * EMPTY_OPERATOR EMPTY_ARGUMENTS
            */
            function /** @no-inline */IdInstruction() {
                        _super.call(this);
                this._sName = "";
                this._sRealName = "";
                this._eInstructionType = 11 /* k_IdInstruction */ ;
            }
            IdInstruction.prototype.getName = function /** @inline */() {
                return this._sName;
            };
            IdInstruction.prototype.getRealName = function /** @inline */() {
                return this._sRealName;
            };
            IdInstruction.prototype.setName = function /** @inline */(sName) {
                this._sName = sName;
            };
            IdInstruction.prototype.setRealName = function /** @inline */(sRealName) {
                this._sRealName = sRealName;
            };
            IdInstruction.prototype.toString = function /** @no-inline */() {
                return this._sRealName;
            };
            IdInstruction.prototype.clone = function /** @no-inline */(pRelationMap) {
                var pClonedInstruction = (_super.prototype.clone.call(this, pRelationMap));
                pClonedInstruction.setName(this._sName);
                pClonedInstruction.setRealName(this._sRealName);
                return pClonedInstruction;
            };
            return IdInstruction;
        })(Instruction);
        fx.IdInstruction = IdInstruction;        
        var KeywordInstruction = (function (_super) {
            __extends(KeywordInstruction, _super);
            /**
            * EMPTY_OPERATOR EMPTY_ARGUMENTS
            */
            function /** @no-inline */KeywordInstruction() {
                        _super.call(this);
                this._sValue = "";
                this._eInstructionType = 12 /* k_KeywordInstruction */ ;
            }
            KeywordInstruction.prototype.setValue = function /** @inline */(sValue) {
                this._sValue = sValue;
            };
            KeywordInstruction.prototype.isValue = function /** @inline */(sTestValue) {
                return this._sValue === sTestValue;
            };
            KeywordInstruction.prototype.toString = function /** @no-inline */() {
                return this._sValue;
            };
            return KeywordInstruction;
        })(Instruction);
        fx.KeywordInstruction = KeywordInstruction;        
        var AnnotationInstruction = (function (_super) {
            __extends(AnnotationInstruction, _super);
            function /** @no-inline */AnnotationInstruction() {
                        _super.call(this);
                this._eInstructionType = 15 /* k_AnnotationInstruction */ ;
            }
            return AnnotationInstruction;
        })(Instruction);
        fx.AnnotationInstruction = AnnotationInstruction;        
        var TechniqueInstruction = (function (_super) {
            __extends(TechniqueInstruction, _super);
            function /** @no-inline */TechniqueInstruction() {
                        _super.call(this);
                this._sName = "";
                this._hasComplexName = false;
                this._pParseNode = null;
                this._pSharedVariableList = null;
                this._pInstructionList = null;
                this._eInstructionType = 55 /* k_TechniqueInstruction */ ;
                this._pSharedVariableList = [];
            }
            TechniqueInstruction.prototype.setName = function /** @no-inline */(sName, isComplexName) {
                this._sName = sName;
                this._hasComplexName = isComplexName;
            };
            TechniqueInstruction.prototype.getName = function /** @no-inline */() {
                return this._sName;
            };
            TechniqueInstruction.prototype.hasComplexName = function /** @no-inline */() {
                return this._hasComplexName;
            };
            TechniqueInstruction.prototype.getSharedVariables = function /** @no-inline */() {
                return this._pSharedVariableList;
            };
            TechniqueInstruction.prototype._setParseNode = function /** @no-inline */(pNode) {
                this._pParseNode = pNode;
            };
            TechniqueInstruction.prototype._getParseNode = function /** @no-inline */() {
                return this._pParseNode;
            };
            TechniqueInstruction.prototype.addPass = function /** @no-inline */() {
            };
            return TechniqueInstruction;
        })(DeclInstruction);
        fx.TechniqueInstruction = TechniqueInstruction;        
        // export class TypeInstruction extends Instruction {
        // 	/**
        // 	 * Represent [usages] IdInstruction
        // 	 * EMPTY_OPERATOR KeywordInstruction ... KeywordInstruction IdInstruction
        // 	 */
        // }
        // export class VariableInitInstruction extends Instruction {
        // 	/**
        // 	 * Represent varname [ [someIndex] ][ = SomeExpr;]
        // 	 * ('=' || EMPTY_OPERATOR) VariableInstruction ExprInstruction
        // 	 */
        // }
        // export class VariableInstruction extends Instruction{
        // 	/**
        // 	 * Represent varname [ [someIndex] ]
        // 	 * EMPTY_OPERATOR IdInstruction IndexInstruction ... IndexInstruction
        // 	 */
        // }
        // export class IndexInstruction extends Instruction {
        // 	/**
        // 	 * Represent [ [someIndex] ]
        // 	 * EMPTY_OPERATOR ExprInstruction
        // 	 */
        // }
        // export class ExprInstruction extends Instruction {
        // 	/**
        // 	 * Represent someExpr
        // 	 * EMPTY_OPERATOR [SomeOfExprassionInstruction]
        // 	 */
        // }
        // export class ArithmeticExprInstruction extends Instruction {
        // 	/**
        // 	 * Represent someExpr +,/,-,*,% someExpr
        // 	 * (+|-|*|/|%) Instruction Instruction
        // 	 */
        // }
        // export class RelationExprInstruction extends Instruction {
        // 	/**
        // 	 * Represent someExpr <,>,>=,<=,!=,== someExpr
        // 	 * (<|>|<=|=>|!=|==) Instruction Instruction
        // 	 */
        // }
        // export class LogicalExprInstruction extends Instruction {
        // 	/**
        // 	 * Represent someExpr &&,|| someExpr
        // 	 * (&& | ||) Instruction Instruction
        // 	 */
        // }
        // export class FunctionCallInstruction extends Instruction {
        // 	/**
        // 	 * Represent func([params])
        // 	 * call IdInstruction ExprInstruction ... ExprInstruction
        // 	 */
        // }
        // export class TypeCastInstruction extends Instruction {
        // 	/**
        // 	 * Represent (type)(Expr)
        // 	 * typeCast IdInstruction ExprInstruction
        // 	 */
        // }
        // export class TypeConstructorInstruction extends Instruction {
        // 	/**
        // 	 * Represent type(Expr)
        // 	 * constructor IdInstruction ExprInstruction
        // 	 */
        // }
            })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        var TypeDeclInstruction = (function (_super) {
            __extends(TypeDeclInstruction, _super);
            // EMPTY_OPERATOR VariableTypeInstruction
            function /** @no-inline */TypeDeclInstruction() {
                        _super.call(this);
                this._eInstructionType = 13 /* k_TypeDeclInstruction */ ;
            }
            TypeDeclInstruction.prototype.getType = function /** @inline */() {
                return this._pInstructionList[0];
            };
            TypeDeclInstruction.prototype.clone = function /** @no-inline */(pRelationMap) {
                return _super.prototype.clone.call(this, pRelationMap);
            };
            return TypeDeclInstruction;
        })(fx.DeclInstruction);
        fx.TypeDeclInstruction = TypeDeclInstruction;        
        var VariableTypeInstruction = (function (_super) {
            __extends(VariableTypeInstruction, _super);
            function /** @no-inline */VariableTypeInstruction() {
                        _super.call(this);
                // EMPTY_OPERATOR TypeInstruction ArrayInstruction PointerInstruction
                this._isWritable = null;
                this._isReadable = null;
                this._bUsedForWrite = false;
                this._bUsedForRead = false;
                this._sHash = "";
                this._sStrongHash = "";
                this._isArray = false;
                this._isPointer = false;
                this._isStrictPointer = false;
                this._isPointIndex = null;
                this._isConst = null;
                this._iLength = 0xffffff;
                this._pArrayIndexExpr = null;
                this._pArrayElementType = null;
                this._pFieldIdMap = null;
                this._pUsedFieldMap = null;
                this._pVideoBuffer = null;
                this._pNextPointIndex = null;
                this._nPointerDim = 0;
                this._pPointerList = null;
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = 2 /* k_VariableTypeInstruction */ ;
            }
            VariableTypeInstruction.prototype.pushInVariableType = function /** @no-inline */(pVariableType) {
                if(this._nInstuctions > 0) {
                    return false;
                } else {
                    var pUsageType = new UsageTypeInstruction();
                    pUsageType.push(pVariableType, false);
                    this.push(pUsageType, true);
                    return false;
                }
            };
            VariableTypeInstruction.prototype.isolateType = function /** @no-inline */() {
                var pVariableType = new VariableTypeInstruction();
                var pUsageType = new UsageTypeInstruction();
                pVariableType.push(pUsageType, true);
                pUsageType.push(this, false);
                return pVariableType;
            };
            VariableTypeInstruction.prototype.addArrayIndex = function /** @no-inline */(pExpr) {
                //TODO: add support for v[][10]
                this._pArrayElementType = new VariableTypeInstruction();
                this._pArrayElementType.push(this._pInstructionList[0], false);
                this._pArrayElementType.setParent(this);
                this._pArrayIndexExpr = pExpr;
                this._iLength = this._pArrayIndexExpr.evaluate() || 0xffffff;
                this._isArray = true;
            };
            VariableTypeInstruction.prototype.addPointIndex = function /** @no-inline */(isStrict) {
                if (typeof isStrict === "undefined") { isStrict = true; }
                this._nPointerDim++;
                this._isPointer = true;
                if(isStrict) {
                    this._isStrictPointer = true;
                }
            };
            VariableTypeInstruction.prototype._addPointIndexInDepth = function /** @no-inline */() {
                if(!this.isComplex()) {
                    return;
                }
                var pFieldNameList = this.getFieldNameList();
                for(var i = 0; i < pFieldNameList.length; i++) {
                    var pFieldType = this.getFieldType(pFieldNameList[i]);
                    if(!pFieldType.isPointer()) {
                        pFieldType.addPointIndex(false);
                        pFieldType._setVideoBufferInDepth();
                    }
                }
            };
            VariableTypeInstruction.prototype.getPointDim = function /** @no-inline */() {
                return this._nPointerDim || (this.getSubType()._getInstructionType() === 2 /* k_VariableTypeInstruction */ ) ? (this.getSubType()).getPointDim() : 0;
            };
            VariableTypeInstruction.prototype.setVideoBuffer = function /** @no-inline */(pBuffer) {
                if(this.isPointIndex()) {
                    (this._pParentInstruction).setVideoBuffer(pBuffer);
                    return;
                }
                this._pVideoBuffer = pBuffer;
                if(!this.isComplex()) {
                    return;
                }
                var pFieldNameList = this.getFieldNameList();
                for(var i = 0; i < pFieldNameList.length; i++) {
                    var pFieldType = this.getFieldType(pFieldNameList[i]);
                    if(pFieldType.isPointer()) {
                        pFieldType.setVideoBuffer(pBuffer);
                    }
                }
            };
            VariableTypeInstruction.prototype._setVideoBufferInDepth = function /** @no-inline */() {
                if(this.isPointer()) {
                    this.setVideoBuffer(fx.Effect.createVideoBufferVariable());
                } else if(this.isComplex() && this._containPointer()) {
                    var pFieldNameList = this.getFieldNameList();
                    for(var i = 0; i < pFieldNameList.length; i++) {
                        var pFieldType = this.getFieldType(pFieldNameList[i]);
                        pFieldType._setVideoBufferInDepth();
                    }
                }
            };
            VariableTypeInstruction.prototype.getVideoBuffer = function /** @no-inline */() {
                if(this.isPointIndex()) {
                    return (this._pParentInstruction).getVideoBuffer();
                }
                return this._pVideoBuffer;
            };
            VariableTypeInstruction.prototype.hasVideoBuffer = function /** @no-inline */() {
                return !akra.isNull(this.getVideoBuffer());
            };
            VariableTypeInstruction.prototype.isBase = function /** @inline */() {
                return this.getSubType().isBase() && this._isArray === false;
            };
            VariableTypeInstruction.prototype.isArray = function /** @inline */() {
                return this._isArray || (this.getSubType().isArray());
            };
            VariableTypeInstruction.prototype.isNotBaseArray = function /** @inline */() {
                return this._isArray || (this.getSubType().isNotBaseArray());
            };
            VariableTypeInstruction.prototype.isComplex = function /** @inline */() {
                return this.getSubType().isComplex();
            };
            VariableTypeInstruction.prototype.isEqual = function /** @no-inline */(pType) {
                if(this.isArray() && pType.isArray() && pType._getInstructionType() !== 3 /* k_SystemTypeInstruction */  && (this.getLength() !== pType.getLength() || this.getLength() === 0xffffff || pType.getLength() === 0xffffff)) {
                    return false;
                }
                if(this.getHash() !== pType.getHash()) {
                    return false;
                }
                return true;
            };
            VariableTypeInstruction.prototype.isConst = function /** @inline */() {
                if(akra.isNull(this._isConst)) {
                    this._isConst = (this._pInstructionList[0]).hasUsage("const");
                }
                return this._isConst;
            };
            VariableTypeInstruction.prototype.isWritable = function /** @no-inline */() {
                if(!akra.isNull(this._isWritable)) {
                    return this._isWritable;
                }
                if(this.isArray() && !this.isBase()) {
                    this._isWritable = false;
                } else {
                    this._isWritable = this.getSubType().isWritable();
                }
                return this._isWritable;
            };
            VariableTypeInstruction.prototype.isReadable = function /** @no-inline */() {
                if(!akra.isNull(this._isReadable)) {
                    return this._isReadable;
                }
                if(this.getUsageType().hasUsage("out")) {
                    this._isReadable = false;
                } else {
                    this._isReadable = this.getSubType().isReadable();
                }
                return this._isReadable;
            };
            VariableTypeInstruction.prototype._canWrite = function /** @inline */(isWritable) {
                this._isWritable = isWritable;
            };
            VariableTypeInstruction.prototype._canRead = function /** @inline */(isReadable) {
                this._isReadable = isReadable;
            };
            VariableTypeInstruction.prototype._containArray = function /** @no-inline */() {
                return this.isBase() ? false : (this.getSubType())._containArray();
            };
            VariableTypeInstruction.prototype._containSampler = function /** @no-inline */() {
                return this.isBase() ? false : (this.getSubType())._containSampler();
            };
            VariableTypeInstruction.prototype._containPointer = function /** @no-inline */() {
                return this.isBase() ? false : (this.getSubType())._containSampler();
            };
            VariableTypeInstruction.prototype.isPointer = function /** @no-inline */() {
                return this._isPointer || (this.getSubType()._getInstructionType() === 2 /* k_VariableTypeInstruction */  && (this.getSubType()).isPointer());
            };
            VariableTypeInstruction.prototype.isStrictPointer = function /** @no-inline */() {
                return this._isStrictPointer || (this.getSubType()._getInstructionType() === 2 /* k_VariableTypeInstruction */  && (this.getSubType()).isStrictPointer());
            };
            VariableTypeInstruction.prototype._setPointerToStrict = function /** @no-inline */() {
                this._isStrictPointer = true;
            };
            VariableTypeInstruction.prototype.isPointIndex = function /** @no-inline */() {
                if(akra.isNull(this._isPointIndex)) {
                    this._isPointIndex = this.isEqual(fx.getEffectBaseType("ptr"));
                }
                return this._isPointIndex;
            };
            VariableTypeInstruction.prototype.getHash = function /** @no-inline */() {
                if(this._sHash === "") {
                    this.calcHash();
                }
                return this._sHash;
            };
            VariableTypeInstruction.prototype.getStrongHash = function /** @no-inline */() {
                if(this._sStrongHash === "") {
                    this.calcStrongHash();
                }
                return this._sStrongHash;
            };
            VariableTypeInstruction.prototype.getSubType = function /** @inline */() {
                return (this._pInstructionList[0]).getTypeInstruction();
            };
            VariableTypeInstruction.prototype.hasUsage = function /** @no-inline */(sUsage) {
                return (this._pInstructionList[0]).hasUsage(sUsage);
            };
            VariableTypeInstruction.prototype.hasField = function /** @no-inline */(sFieldName) {
                return this.getSubType().hasField(sFieldName);
            };
            VariableTypeInstruction.prototype._usedForWrite = function /** @no-inline */() {
                if(!this.isWritable()) {
                    return false;
                }
                this._bUsedForWrite = true;
                return true;
            };
            VariableTypeInstruction.prototype._usedForRead = function /** @no-inline */() {
                if(!this.isReadable()) {
                    return false;
                }
                this._bUsedForRead = true;
                return true;
            };
            VariableTypeInstruction.prototype.hasFieldWithSematic = function /** @no-inline */(sSemantic) {
                if(!this.isComplex()) {
                    return false;
                }
                return this.getSubType().hasFieldWithSematic(sSemantic);
            };
            VariableTypeInstruction.prototype.hasAllUniqueSemantics = function /** @no-inline */() {
                if(!this.isComplex()) {
                    return false;
                }
                return this.getSubType().hasAllUniqueSemantics();
            };
            VariableTypeInstruction.prototype.hasFieldWithoutSemantic = function /** @no-inline */() {
                if(!this.isComplex()) {
                    return false;
                }
                return this.getSubType().hasFieldWithoutSemantic();
            };
            VariableTypeInstruction.prototype.getField = function /** @no-inline */(sFieldName, isCreateExpr) {
                if(!this.hasField(sFieldName)) {
                    return null;
                }
                if(akra.isNull(this._pFieldIdMap)) {
                    this._pFieldIdMap = {
                    };
                }
                if(akra.isDef(this._pFieldIdMap[sFieldName])) {
                    return this._pFieldIdMap[sFieldName];
                }
                var pUsageType = this._pInstructionList[0];
                var pSubType = pUsageType.getTypeInstruction();
                var pFieldIdExpr = pSubType.getField(sFieldName);
                var pFieldType = new VariableTypeInstruction();
                pFieldType.pushInVariableType(pFieldIdExpr.getType());
                pFieldType.setParent(this);
                pFieldIdExpr.setType(pFieldType);
                this._pFieldIdMap[sFieldName] = pFieldIdExpr;
                return pFieldIdExpr;
            };
            VariableTypeInstruction.prototype.getFieldType = function /** @no-inline */(sFieldName) {
                return this.getField(sFieldName, false).getType();
            };
            VariableTypeInstruction.prototype.getFieldNameList = function /** @no-inline */() {
                return this.getSubType().getFieldNameList();
            };
            VariableTypeInstruction.prototype.getBaseType = function /** @no-inline */() {
                return this.getSubType().getBaseType();
            };
            VariableTypeInstruction.prototype.getPointer = function /** @no-inline */() {
                if(!this.isPointer() && !this.hasVideoBuffer() && !this.isPointIndex()) {
                    return null;
                }
                if(!akra.isNull(this._pNextPointIndex)) {
                    return this._pNextPointIndex;
                }
                if(this.isPointIndex()) {
                    return null;
                }
                this.initializePointers();
                return this._pNextPointIndex;
            };
            VariableTypeInstruction.prototype.initializePointers = function /** @no-inline */() {
                this._pPointerList = [];
                for(var i = 0; i < this._nPointerDim; i++) {
                    var pPointer = new fx.VariableDeclInstruction();
                    var pPointerType = new VariableTypeInstruction();
                    var pPointerId = new fx.IdInstruction();
                    pPointer.push(pPointerType, true);
                    pPointer.push(pPointerId, true);
                    pPointerType.pushInVariableType(fx.getEffectBaseType("ptr"));
                    pPointerId.setName("undef");
                    if(i > 0) {
                        (this._pPointerList[i - 1].getType())._setNextPointer(pPointer);
                    }
                    pPointer.setParent(this);
                }
                this._pNextPointIndex = this._pPointerList[0];
            };
            VariableTypeInstruction.prototype.getSize = function /** @no-inline */() {
                if(this._isArray) {
                    var iSize = this._pArrayElementType.getSize();
                    if(this._iLength === 0xffffff || iSize === 0xffffff) {
                        return 0xffffff;
                    } else {
                        return iSize * this._iLength;
                    }
                } else {
                    return this.getSubType().getSize();
                }
            };
            VariableTypeInstruction.prototype.getLength = function /** @no-inline */() {
                if(!this.isArray()) {
                    this._iLength = 0;
                    return 0;
                }
                if(this._iLength === 0xffffff) {
                    var isEval = this._pArrayIndexExpr.evaluate();
                    if(isEval) {
                        this._iLength = this._pArrayIndexExpr.getEvalValue();
                    }
                }
                return this._iLength;
            };
            VariableTypeInstruction.prototype.getArrayElementType = function /** @no-inline */() {
                if(!this.isArray()) {
                    return null;
                }
                if(akra.isNull(this._pArrayElementType)) {
                    this._pArrayElementType = new VariableTypeInstruction();
                    this._pArrayElementType.pushInVariableType(this.getSubType().getArrayElementType());
                    this._pArrayElementType.setParent(this);
                }
                return this._pArrayElementType;
            };
            VariableTypeInstruction.prototype.wrap = function /** @no-inline */() {
                var pCloneType = new VariableTypeInstruction();
                pCloneType.pushInVariableType(this);
                return pCloneType;
            };
            VariableTypeInstruction.prototype.clone = function /** @no-inline */(pRelationMap) {
                if (typeof pRelationMap === "undefined") { pRelationMap = {
                }; }
                if(akra.isDef(pRelationMap[this._getInstructionID()])) {
                    return pRelationMap[this._getInstructionID()];
                }
                if(this._pParentInstruction === null || !akra.isDef(pRelationMap[this._pParentInstruction._getInstructionID()]) || pRelationMap[this._pParentInstruction._getInstructionID()] === this._pParentInstruction) {
                    //pRelationMap[this._getInstructionID()] = this;
                    return this;
                }
                var pClone = _super.prototype.clone.call(this, pRelationMap);
                pClone._canWrite(this._isWritable);
                pClone._canRead(this._isReadable);
                pClone._setCloneHash(this._sHash, this._sStrongHash);
                if(this._isArray) {
                    this._setCloneArrayIndex(this._pArrayElementType.clone(pRelationMap), this._pArrayIndexExpr.clone(pRelationMap), this._iLength);
                }
                if(this._isPointer) {
                    var pClonePointerList = new Array(this._pPointerList.length);
                    for(var i = 0; i < this._pPointerList.length; i++) {
                        pClonePointerList[i] = this._pPointerList[i].clone(pRelationMap);
                        if(i > 0) {
                            (pClonePointerList[i - 1].getType())._setNextPointer(pClonePointerList[i]);
                        }
                    }
                    this._setClonePointeIndexes(this._nPointerDim, pClonePointerList);
                }
                if(!akra.isNull(this._pFieldIdMap)) {
                    var sFieldName = null;
                    var pCloneFieldMap = {
                    };
                    for(sFieldName in this._pFieldIdMap) {
                        pCloneFieldMap[sFieldName] = this._pFieldIdMap[sFieldName].clone(pRelationMap);
                    }
                    this._setCloneFields(pCloneFieldMap);
                }
                return pClone;
            };
            VariableTypeInstruction.prototype._setNextPointer = function /** @inline */(pNextPointIndex) {
                this._pNextPointIndex = pNextPointIndex;
            };
            VariableTypeInstruction.prototype._setCloneHash = function /** @no-inline */(sHash, sStrongHash) {
                this._sHash = sHash;
                this._sStrongHash = sStrongHash;
            };
            VariableTypeInstruction.prototype._setCloneArrayIndex = function /** @no-inline */(pElementType, pIndexExpr, iLength) {
                this._isArray = true;
                this._pArrayElementType = pElementType;
                this._pArrayIndexExpr = pIndexExpr;
                this._iLength = iLength;
            };
            VariableTypeInstruction.prototype._setClonePointeIndexes = function /** @no-inline */(nDim, pPointerList) {
                this._isPointer = true;
                this._nPointerDim = nDim;
                this._pPointerList = pPointerList;
                this._pNextPointIndex = this._pPointerList[0];
            };
            VariableTypeInstruction.prototype._setCloneFields = function /** @no-inline */(pFieldMap) {
                this._pFieldIdMap = pFieldMap;
            };
            VariableTypeInstruction.prototype.calcHash = function /** @no-inline */() {
                var sHash = this.getSubType().getHash();
                if(this.isArray()) {
                    sHash += "[";
                    var iLength = this.getLength();
                    if(iLength === 0xffffff) {
                        sHash += "undef";
                    } else {
                        sHash += iLength.toString();
                    }
                    sHash += "]";
                }
                this._sHash = sHash;
            };
            VariableTypeInstruction.prototype.calcStrongHash = function /** @no-inline */() {
            };
            VariableTypeInstruction.prototype.getUsageType = function /** @inline */() {
                return this._pInstructionList[0];
            };
            return VariableTypeInstruction;
        })(fx.Instruction);
        fx.VariableTypeInstruction = VariableTypeInstruction;        
        var UsageTypeInstruction = (function (_super) {
            __extends(UsageTypeInstruction, _super);
            function /** @no-inline */UsageTypeInstruction() {
                        _super.call(this);
                // EMPTY_OPERATOR KeywordInstruction ... KeywordInstruction IAFXTypeInstruction
                this._pUsageList = null;
                this._pType = null;
                this._pUsageList = [];
                this._eInstructionType = 16 /* k_UsageTypeInstruction */ ;
            }
            UsageTypeInstruction.prototype.getTypeInstruction = function /** @inline */() {
                return this._pType;
            };
            UsageTypeInstruction.prototype.setTypeInstruction = function /** @no-inline */(pType) {
                //TODO: check compatibility test for type and usages
                this._pType = pType;
                return true;
            };
            UsageTypeInstruction.prototype.hasUsage = function /** @no-inline */(sUsage) {
                for(var i = 0; i < this._pUsageList.length; i++) {
                    if(this._pUsageList[i] === sUsage) {
                        return true;
                    }
                }
                if(this._pType._getInstructionType() === 2 /* k_VariableTypeInstruction */ ) {
                    return (this._pType).hasUsage(sUsage);
                }
                return false;
            };
            UsageTypeInstruction.prototype.addUsage = function /** @no-inline */(sUsage) {
                //TODO: check compatibility test for usage and usage
                this._pUsageList.push(sUsage);
                return true;
            };
            UsageTypeInstruction.prototype.clone = function /** @no-inline */(pRelationMap) {
                if (typeof pRelationMap === "undefined") { pRelationMap = {
                }; }
                var pClone = _super.prototype.clone.call(this, pRelationMap);
                for(var i = 0; i < this._pUsageList.length; i++) {
                    pClone.addUsage(this._pUsageList[i]);
                }
                pClone.setTypeInstruction(this._pType.clone(pRelationMap));
                return pClone;
            };
            return UsageTypeInstruction;
        })(fx.Instruction);
        fx.UsageTypeInstruction = UsageTypeInstruction;        
        var SystemTypeInstruction = (function (_super) {
            __extends(SystemTypeInstruction, _super);
            function /** @no-inline */SystemTypeInstruction() {
                        _super.call(this);
                this._sName = "";
                this._sRealName = "";
                this._pElementType = null;
                this._iLength = 1;
                this._iSize = null;
                this._pFieldIdMap = null;
                this._isArray = false;
                this._isWritable = true;
                this._isReadable = true;
                this._pFieldNameList = null;
                this._pWrapVariableType = null;
                this._eInstructionType = 3 /* k_SystemTypeInstruction */ ;
                this._pFieldIdMap = {
                };
                this._pWrapVariableType = new VariableTypeInstruction();
                this._pWrapVariableType.pushInVariableType(this);
            }
            SystemTypeInstruction.prototype.setName = function /** @inline */(sName) {
                this._sName = sName;
            };
            SystemTypeInstruction.prototype.setRealName = function /** @inline */(sRealName) {
                this._sRealName = sRealName;
            };
            SystemTypeInstruction.prototype.setSize = function /** @inline */(iSize) {
                this._iSize = iSize;
            };
            SystemTypeInstruction.prototype.addIndex = function /** @no-inline */(pType, iLength) {
                this._pElementType = pType;
                this._iLength = iLength;
                this._iSize = iLength * pType.getSize();
                this._isArray = true;
            };
            SystemTypeInstruction.prototype.addField = function /** @no-inline */(sFieldName, pType, isWrite, sRealFieldName) {
                if (typeof isWrite === "undefined") { isWrite = true; }
                if (typeof sRealFieldName === "undefined") { sRealFieldName = sFieldName; }
                var pFieldType = new VariableTypeInstruction();
                pFieldType.push(new UsageTypeInstruction(), true);
                pFieldType.getInstructions()[0].push(pType, false);
                pFieldType._canWrite(isWrite);
                var pFieldId = new fx.IdInstruction();
                pFieldId.setName(sFieldName);
                pFieldId.setRealName(sRealFieldName);
                var pFieldIdExpr = new fx.IdExprInstruction();
                pFieldIdExpr.push(pFieldId, true);
                pFieldIdExpr.setType(pFieldType);
                pFieldIdExpr.setParent(this);
                this._pFieldIdMap[sFieldName] = pFieldIdExpr;
                if(akra.isNull(this._pFieldNameList)) {
                    this._pFieldNameList = [];
                }
                this._pFieldNameList.push(sFieldName);
            };
            SystemTypeInstruction.prototype.isBase = function /** @inline */() {
                return true;
            };
            SystemTypeInstruction.prototype.isArray = function /** @inline */() {
                return this._isArray;
            };
            SystemTypeInstruction.prototype.isNotBaseArray = function /** @inline */() {
                return false;
            };
            SystemTypeInstruction.prototype.isComplex = function /** @inline */() {
                return false;
            };
            SystemTypeInstruction.prototype.isEqual = function /** @inline */(pType) {
                return this.getHash() === pType.getHash();
            };
            SystemTypeInstruction.prototype.isConst = function /** @inline */() {
                return false;
            };
            SystemTypeInstruction.prototype.isWritable = function /** @inline */() {
                return this._isWritable;
            };
            SystemTypeInstruction.prototype.isReadable = function /** @inline */() {
                return this._isReadable;
            };
            SystemTypeInstruction.prototype._canWrite = function /** @inline */(isWritable) {
                this._isWritable = isWritable;
            };
            SystemTypeInstruction.prototype._canRead = function /** @inline */(isReadable) {
                this._isReadable = isReadable;
            };
            SystemTypeInstruction.prototype.getHash = function /** @inline */() {
                return this._sName;
            };
            SystemTypeInstruction.prototype.getStrongHash = function /** @inline */() {
                return this._sName;
            };
            SystemTypeInstruction.prototype.hasField = //inline getNameId()
            function /** @inline */(sFieldName) {
                return akra.isDef(this._pFieldIdMap[sFieldName]);
            };
            SystemTypeInstruction.prototype.hasFieldWithSematic = function /** @no-inline */(sSemantic) {
                return false;
            };
            SystemTypeInstruction.prototype.hasAllUniqueSemantics = function /** @no-inline */() {
                return false;
            };
            SystemTypeInstruction.prototype.hasFieldWithoutSemantic = function /** @no-inline */() {
                return false;
            };
            SystemTypeInstruction.prototype.getField = function /** @inline */(sFieldName, isCreateExpr) {
                return akra.isDef(this._pFieldIdMap[sFieldName]) ? this._pFieldIdMap[sFieldName] : null;
            };
            SystemTypeInstruction.prototype.getFieldType = function /** @inline */(sFieldName) {
                return akra.isDef(this._pFieldIdMap[sFieldName]) ? this._pFieldIdMap[sFieldName].getType() : null;
            };
            SystemTypeInstruction.prototype.getFieldNameList = function /** @inline */() {
                return this._pFieldNameList;
            };
            SystemTypeInstruction.prototype.getSize = function /** @inline */() {
                return this._iSize;
            };
            SystemTypeInstruction.prototype.getBaseType = function /** @inline */() {
                return this;
            };
            SystemTypeInstruction.prototype.getVariableType = function /** @inline */() {
                return this._pWrapVariableType;
            };
            SystemTypeInstruction.prototype.getArrayElementType = function /** @inline */() {
                return this._pElementType;
            };
            SystemTypeInstruction.prototype.getLength = function /** @inline */() {
                return this._iLength;
            };
            SystemTypeInstruction.prototype.clone = function /** @inline */(pRelationMap) {
                return this;
            };
            return SystemTypeInstruction;
        })(fx.Instruction);
        fx.SystemTypeInstruction = SystemTypeInstruction;        
        var ComplexTypeInstruction = (function (_super) {
            __extends(ComplexTypeInstruction, _super);
            function /** @no-inline */ComplexTypeInstruction() {
                        _super.call(this);
                this._sName = "";
                this._sRealName = "";
                this._sHash = "";
                this._sStrongHash = "";
                this._iSize = 0;
                this._pFieldDeclMap = null;
                this._pFieldIdMap = null;
                this._pFieldDeclList = null;
                this._pFieldNameList = null;
                this._pFieldDeclBySemanticMap = null;
                this._hasAllUniqueSemantics = true;
                this._hasFieldWithoutSemantic = false;
                this._isContainArray = false;
                this._isContainSampler = false;
                this._isContainPointer = false;
                this._eInstructionType = 4 /* k_ComplexTypeInstruction */ ;
            }
            ComplexTypeInstruction.prototype.addField = function /** @no-inline */(pVariable) {
                if(akra.isNull(this._pFieldIdMap)) {
                    this._pFieldIdMap = {
                    };
                    this._pFieldDeclMap = {
                    };
                    this._pFieldNameList = [];
                }
                var sVarName = pVariable.getName();
                this._pFieldDeclMap[sVarName] = pVariable;
                var pVarIdExpr = new fx.IdExprInstruction();
                pVarIdExpr.push(pVariable.getNameId(), false);
                pVarIdExpr.setType(pVariable.getType());
                this._pFieldIdMap[sVarName] = pVarIdExpr;
                if(this._iSize !== 0xffffff) {
                    var iSize = pVariable.getType().getSize();
                    if(iSize !== 0xffffff) {
                        this._iSize += iSize;
                    } else {
                        this._iSize = 0xffffff;
                    }
                }
                this._pFieldNameList.push(sVarName);
                var pType = pVariable.getType();
                if(pType.isNotBaseArray() || pType._containArray()) {
                    this._isContainArray = true;
                }
                if(fx.isSamplerType(pType) || pType._containSampler()) {
                    this._isContainSampler = true;
                }
                if(pType.isPointer() || pType._containPointer()) {
                    this._isContainPointer = true;
                }
            };
            ComplexTypeInstruction.prototype.setName = function /** @inline */(sName) {
                this._sName = sName;
            };
            ComplexTypeInstruction.prototype.setRealName = function /** @inline */(sRealName) {
                this._sRealName = sRealName;
            };
            ComplexTypeInstruction.prototype.setSize = function /** @inline */(iSize) {
                this._iSize = iSize;
            };
            ComplexTypeInstruction.prototype.setWriteMode = function /** @inline */(isWrite) {
            };
            ComplexTypeInstruction.prototype.isBase = function /** @inline */() {
                return false;
            };
            ComplexTypeInstruction.prototype.isArray = function /** @inline */() {
                return false;
            };
            ComplexTypeInstruction.prototype.isNotBaseArray = function /** @inline */() {
                return false;
            };
            ComplexTypeInstruction.prototype.isComplex = function /** @inline */() {
                return true;
            };
            ComplexTypeInstruction.prototype.isWritable = function /** @inline */() {
                return true;
            };
            ComplexTypeInstruction.prototype.isReadable = function /** @inline */() {
                return true;
            };
            ComplexTypeInstruction.prototype._containArray = function /** @inline */() {
                return this._isContainArray;
            };
            ComplexTypeInstruction.prototype._containSampler = function /** @inline */() {
                return this._isContainSampler;
            };
            ComplexTypeInstruction.prototype._containPointer = function /** @inline */() {
                return this._isContainPointer;
            };
            ComplexTypeInstruction.prototype._canWrite = function /** @inline */() {
            };
            ComplexTypeInstruction.prototype._canRead = function /** @inline */() {
            };
            ComplexTypeInstruction.prototype.isEqual = function /** @inline */(pType) {
                return this.getHash() === pType.getHash();
            };
            ComplexTypeInstruction.prototype.isConst = function /** @inline */() {
                return false;
            };
            ComplexTypeInstruction.prototype.getHash = function /** @no-inline */() {
                if(this._sHash === "") {
                    this.calcHash();
                }
                return this._sHash;
            };
            ComplexTypeInstruction.prototype.getStrongHash = function /** @no-inline */() {
                if(this._sStrongHash === "") {
                    this.calcStrongHash();
                }
                return this._sStrongHash;
            };
            ComplexTypeInstruction.prototype.hasField = //inline getNameId()
            function /** @inline */(sFieldName) {
                return akra.isDef(this._pFieldDeclMap[sFieldName]);
            };
            ComplexTypeInstruction.prototype.hasFieldWithSematic = function /** @no-inline */(sSemantic) {
                if(akra.isNull(this._pFieldDeclBySemanticMap)) {
                    this.analyzeSemantics();
                }
                return akra.isDef(this._pFieldDeclBySemanticMap[sSemantic]);
            };
            ComplexTypeInstruction.prototype.hasAllUniqueSemantics = function /** @no-inline */() {
                if(akra.isNull(this._pFieldDeclBySemanticMap)) {
                    this.analyzeSemantics();
                }
                return this._hasAllUniqueSemantics;
            };
            ComplexTypeInstruction.prototype.hasFieldWithoutSemantic = function /** @no-inline */() {
                if(akra.isNull(this._pFieldDeclBySemanticMap)) {
                    this.analyzeSemantics();
                }
                return this._hasFieldWithoutSemantic;
            };
            ComplexTypeInstruction.prototype.getField = function /** @inline */(sFieldName, isCreateExpr) {
                if (typeof isCreateExpr === "undefined") { isCreateExpr = true; }
                if(!akra.isDef(this._pFieldDeclMap[sFieldName])) {
                    return null;
                }
                // if(isCreateExpr) {
                // 	var pVariable: IAFXVariableDeclInstruction = this._pFieldDeclMap[sFieldName];
                // 	var pVarIdExpr: IAFXIdExprInstruction = new IdExprInstruction();
                // 	var pVariableType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
                // 	pVariableType.pushInVariableType(pVariable.getType());
                // 	pVarIdExpr.push(pVariable.getNameId(), false);
                // 	pVarIdExpr.setType(pVariableType);
                // 	return pVarIdExpr;
                // }
                // else {
                return this._pFieldIdMap[sFieldName];
                // }
                            };
            ComplexTypeInstruction.prototype.getFieldType = function /** @inline */(sFieldName) {
                return akra.isDef(this._pFieldDeclMap[sFieldName]) ? this._pFieldDeclMap[sFieldName].getType() : null;
            };
            ComplexTypeInstruction.prototype.getFieldNameList = function /** @inline */() {
                return this._pFieldNameList;
            };
            ComplexTypeInstruction.prototype.getSize = function /** @inline */() {
                if(this._iSize === 0xffffff) {
                    this._iSize = this._calcSize();
                }
                return this._iSize;
            };
            ComplexTypeInstruction.prototype.getBaseType = function /** @inline */() {
                return null;
            };
            ComplexTypeInstruction.prototype.getArrayElementType = function /** @inline */() {
                return null;
            };
            ComplexTypeInstruction.prototype.getLength = function /** @inline */() {
                return 0;
            };
            ComplexTypeInstruction.prototype.addFields = function /** @no-inline */(pFieldCollector, isSetParent) {
                if (typeof isSetParent === "undefined") { isSetParent = true; }
                this._pFieldDeclList = (pFieldCollector.getInstructions());
                for(var i = 0; i < this._pFieldDeclList.length; i++) {
                    this.addField(this._pFieldDeclList[i]);
                    this._pFieldDeclList[i].setParent(this);
                }
            };
            ComplexTypeInstruction.prototype.clone = function /** @inline */(pRelationMap) {
                if (typeof pRelationMap === "undefined") { pRelationMap = {
                }; }
                if(this._pParentInstruction === null || !akra.isDef(pRelationMap[this._pParentInstruction._getInstructionID()]) || pRelationMap[this._pParentInstruction._getInstructionID()] === this._pParentInstruction) {
                    //pRelationMap[this._getInstructionID()] = this;
                    return this;
                }
                var pClone = _super.prototype.clone.call(this, pRelationMap);
                pClone._setCloneName(this._sName, this._sRealName);
                pClone._setCloneHash(this._sHash, this._sStrongHash);
                pClone._setCloneContain(this._isContainArray, this._isContainSampler);
                var pFieldDeclList = new Array(this._pFieldDeclList.length);
                var pFieldNameList = new Array(this._pFieldNameList.length);
                var pFieldDeclMap = {
                };
                var pFieldIdMap = {
                };
                for(var i = 0; i < this._pFieldDeclList.length; i++) {
                    var pCloneVar = this._pFieldDeclList[i].clone(pRelationMap);
                    var sVarName = pCloneVar.getName();
                    pFieldDeclList[i] = pCloneVar;
                    pFieldNameList[i] = sVarName;
                    pFieldDeclMap[sVarName] = pCloneVar;
                    pFieldIdMap[sVarName] = this._pFieldIdMap[sVarName].clone(pRelationMap);
                }
                pClone._setCloneFields(pFieldDeclList, pFieldNameList, pFieldDeclMap, pFieldIdMap);
                pClone.setSize(this._iSize);
                return pClone;
            };
            ComplexTypeInstruction.prototype._setCloneName = function /** @no-inline */(sName, sRealName) {
                this._sName = sName;
                this._sRealName = sRealName;
            };
            ComplexTypeInstruction.prototype._setCloneHash = function /** @no-inline */(sHash, sStrongHash) {
                this._sHash = sHash;
                this._sStrongHash = sStrongHash;
            };
            ComplexTypeInstruction.prototype._setCloneContain = function /** @no-inline */(isContainArray, isContainSampler) {
                this._isContainArray = isContainArray;
                this._isContainSampler = isContainSampler;
            };
            ComplexTypeInstruction.prototype._setCloneFields = function /** @no-inline */(pFieldDeclList, pFieldNameList, pFieldDeclMap, pFieldIdMap) {
                this._pFieldDeclList = pFieldDeclList;
                this._pFieldNameList = pFieldNameList;
                this._pFieldDeclMap = pFieldDeclMap;
                this._pFieldIdMap = pFieldIdMap;
            };
            ComplexTypeInstruction.prototype._calcSize = function /** @no-inline */() {
                var iSize = 0;
                for(var i = 0; i < this._pFieldDeclList.length; i++) {
                    var iFieldSize = this._pFieldDeclList[i].getType().getSize();
                    if(iFieldSize === 0xffffff) {
                        iSize = 0xffffff;
                        break;
                    } else {
                        iSize += iFieldSize;
                    }
                }
                return iSize;
            };
            ComplexTypeInstruction.prototype.calcHash = function /** @no-inline */() {
                var sHash = "{";
                for(var i = 0; i < this._pFieldDeclList.length; i++) {
                    sHash += this._pFieldDeclList[i].getType().getHash() + ";";
                }
                sHash += "}";
                this._sHash = sHash;
            };
            ComplexTypeInstruction.prototype.calcStrongHash = function /** @no-inline */() {
                var sStrongHash = "{";
                for(var i = 0; i < this._pFieldDeclList.length; i++) {
                    sStrongHash += this._pFieldDeclList[i].getType().getStrongHash() + ";";
                }
                sStrongHash += "}";
                this._sStrongHash = sStrongHash;
            };
            ComplexTypeInstruction.prototype.analyzeSemantics = function /** @no-inline */() {
                this._pFieldDeclBySemanticMap = {
                };
                for(var i = 0; i < this._pFieldDeclList.length; i++) {
                    var pVar = this._pFieldDeclList[i];
                    var sSemantic = pVar.getSemantic();
                    if(sSemantic === "") {
                        this._hasFieldWithoutSemantic = true;
                    }
                    if(akra.isDef(this._pFieldDeclBySemanticMap[sSemantic])) {
                        this._hasAllUniqueSemantics = false;
                    }
                    this._pFieldDeclBySemanticMap[sSemantic] = pVar;
                    this._hasFieldWithoutSemantic = this._hasFieldWithoutSemantic || pVar.getType().hasFieldWithoutSemantic();
                    this._hasAllUniqueSemantics = !(this._hasAllUniqueSemantics) ? false : pVar.getType().hasAllUniqueSemantics();
                }
            };
            return ComplexTypeInstruction;
        })(fx.Instruction);
        fx.ComplexTypeInstruction = ComplexTypeInstruction;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        var VariableDeclInstruction = (function (_super) {
            __extends(VariableDeclInstruction, _super);
            /**
            * Represent type var_name [= init_expr]
            * EMPTY_OPERATOR VariableTypeInstruction IdInstruction InitExprInstruction
            */
            function /** @no-inline */VariableDeclInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null, 
                    null
                ];
                this._eInstructionType = 14 /* k_VariableDeclInstruction */ ;
            }
            VariableDeclInstruction.prototype.hasInitializer = function /** @no-inline */() {
                return false;
            };
            VariableDeclInstruction.prototype.getInitializeExpr = function /** @no-inline */() {
                return null;
            };
            VariableDeclInstruction.prototype.getType = function /** @inline */() {
                return this._pInstructionList[0];
            };
            VariableDeclInstruction.prototype.setType = function /** @inline */(pType) {
                this._pInstructionList[0] = pType;
                pType.setParent(this);
                if(this._nInstuctions === 0) {
                    this._nInstuctions = 1;
                }
            };
            VariableDeclInstruction.prototype.setName = function /** @no-inline */(sName) {
                var pName = new fx.IdInstruction();
                pName.setName(sName);
                pName.setParent(this);
                this._pInstructionList[1] = pName;
                if(this._nInstuctions < 2) {
                    this._nInstuctions = 2;
                }
            };
            VariableDeclInstruction.prototype.getName = function /** @no-inline */() {
                return (this._pInstructionList[1]).getName();
            };
            VariableDeclInstruction.prototype.isUniform = function /** @no-inline */() {
                return this.getType().hasUsage("uniform");
            };
            VariableDeclInstruction.prototype.clone = function /** @no-inline */(pRelationMap) {
                return _super.prototype.clone.call(this, pRelationMap);
            };
            return VariableDeclInstruction;
        })(fx.DeclInstruction);
        fx.VariableDeclInstruction = VariableDeclInstruction;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        /**
        * Represent all kind of statements
        */
        var StmtInstruction = (function (_super) {
            __extends(StmtInstruction, _super);
            function /** @no-inline */StmtInstruction() {
                        _super.call(this);
                this._eInstructionType = 45 /* k_StmtInstruction */ ;
            }
            return StmtInstruction;
        })(fx.Instruction);
        fx.StmtInstruction = StmtInstruction;        
        /**
        * Represent {stmts}
        * EMPTY_OPERATOR StmtInstruction ... StmtInstruction
        */
        var StmtBlockInstruction = (function (_super) {
            __extends(StmtBlockInstruction, _super);
            function /** @no-inline */StmtBlockInstruction() {
                        _super.call(this);
                this._pInstructionList = [];
                this._eInstructionType = 46 /* k_StmtBlockInstruction */ ;
            }
            return StmtBlockInstruction;
        })(StmtInstruction);
        fx.StmtBlockInstruction = StmtBlockInstruction;        
        /**
        * Represent expr;
        * EMPTY_OPERTOR ExprInstruction
        */
        var ExprStmtInstruction = (function (_super) {
            __extends(ExprStmtInstruction, _super);
            function /** @no-inline */ExprStmtInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = 47 /* k_ExprStmtInstruction */ ;
            }
            return ExprStmtInstruction;
        })(StmtInstruction);
        fx.ExprStmtInstruction = ExprStmtInstruction;        
        /**
        * Reprsernt continue; break; discard;
        * (continue || break || discard)
        */
        var BreakStmtInstruction = (function (_super) {
            __extends(BreakStmtInstruction, _super);
            function /** @no-inline */BreakStmtInstruction() {
                        _super.call(this);
                this._pInstructionList = null;
                this._eInstructionType = 48 /* k_BreakStmtInstruction */ ;
            }
            return BreakStmtInstruction;
        })(StmtInstruction);
        fx.BreakStmtInstruction = BreakStmtInstruction;        
        /**
        * Represent while(expr) stmt
        * ( while || do_while) ExprInstruction StmtInstruction
        */
        var WhileStmtInstruction = (function (_super) {
            __extends(WhileStmtInstruction, _super);
            function /** @no-inline */WhileStmtInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._eInstructionType = 49 /* k_WhileStmtInstruction */ ;
            }
            return WhileStmtInstruction;
        })(StmtInstruction);
        fx.WhileStmtInstruction = WhileStmtInstruction;        
        /**
        * Represent for(forInit forCond ForStep) stmt
        * for ExprInstruction or VarDeclInstruction ExprInstruction ExprInstruction StmtInstruction
        */
        var ForStmtInstruction = (function (_super) {
            __extends(ForStmtInstruction, _super);
            function /** @no-inline */ForStmtInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null, 
                    null, 
                    null
                ];
                this._eInstructionType = 50 /* k_ForStmtInstruction */ ;
            }
            return ForStmtInstruction;
        })(StmtInstruction);
        fx.ForStmtInstruction = ForStmtInstruction;        
        /**
        * Represent if(expr) stmt or if(expr) stmt else stmt
        * ( if || if_else ) Expr Stmt [Stmt]
        */
        var IfStmtInstruction = (function (_super) {
            __extends(IfStmtInstruction, _super);
            function /** @no-inline */IfStmtInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null, 
                    null
                ];
                this._eInstructionType = 51 /* k_IfStmtInstruction */ ;
            }
            return IfStmtInstruction;
        })(StmtInstruction);
        fx.IfStmtInstruction = IfStmtInstruction;        
        /**
        * Represent TypeDecl or VariableDecl or VarStructDecl
        * EMPTY DeclInstruction
        */
        var DeclStmtInstruction = (function (_super) {
            __extends(DeclStmtInstruction, _super);
            function /** @no-inline */DeclStmtInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = 52 /* k_DeclStmtInstruction */ ;
            }
            return DeclStmtInstruction;
        })(StmtInstruction);
        fx.DeclStmtInstruction = DeclStmtInstruction;        
        /**
        * Represent return expr;
        * return ExprInstruction
        */
        var ReturnStmtInstruction = (function (_super) {
            __extends(ReturnStmtInstruction, _super);
            function /** @no-inline */ReturnStmtInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._sOperatorName = "return";
                this._eInstructionType = 53 /* k_ReturnStmtInstruction */ ;
            }
            return ReturnStmtInstruction;
        })(StmtInstruction);
        fx.ReturnStmtInstruction = ReturnStmtInstruction;        
        /**
        * Represent empty statement only semicolon ;
        * ;
        */
        var SemicolonStmtInstruction = (function (_super) {
            __extends(SemicolonStmtInstruction, _super);
            function /** @no-inline */SemicolonStmtInstruction() {
                        _super.call(this);
                this._pInstructionList = [];
                this._eInstructionType = 54 /* k_SemicolonStmtInstruction */ ;
            }
            return SemicolonStmtInstruction;
        })(StmtInstruction);
        fx.SemicolonStmtInstruction = SemicolonStmtInstruction;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        /**
        * Represent type func(...args)[:Semantic] [<Annotation> {stmts}]
        * EMPTY_OPERTOR FunctionDefInstruction StmtBlockInstruction
        */
        var FunctionDeclInstruction = (function (_super) {
            __extends(FunctionDeclInstruction, _super);
            function /** @no-inline */FunctionDeclInstruction() {
                        _super.call(this);
                /**@protected*/ this._pFunctionDefenition = null;
                /**@protected*/ this._pImplementation = null;
                /**@protected*/ this._eFunctionType = NaN /* k_Function */ ;
                /**@protected*/ this._bUsedAsFunction = false;
                /**@protected*/ this._bUsedAsVertex = false;
                /**@protected*/ this._bUsedAsPixel = false;
                /**@protected*/ this._bUsedInVertex = false;
                /**@protected*/ this._bUsedInPixel = false;
                /**@protected*/ this._bCanUsedAsFunction = true;
                /**@protected*/ this._pParseNode = null;
                /**@protected*/ this._iScope = 0;
                /**@protected*/ this._pUsedFunctionMap = null;
                /**@protected*/ this._pUsedFunctionList = null;
                /**@protected*/ this._isInBlackList = false;
                /**@protected*/ this._pOutVariable = null;
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._eInstructionType = 41 /* k_FunctionDeclInstruction */ ;
            }
            FunctionDeclInstruction.prototype.getType = function /** @inline */() {
                return this.getReturnType();
            };
            FunctionDeclInstruction.prototype.getName = function /** @inline */() {
                return this._pFunctionDefenition.getName();
            };
            FunctionDeclInstruction.prototype.getNameId = function /** @inline */() {
                return this._pFunctionDefenition.getNameId();
            };
            FunctionDeclInstruction.prototype.getArguments = function /** @no-inline */() {
                return this._pFunctionDefenition.getArguments();
            };
            FunctionDeclInstruction.prototype.getNumNeededArguments = function /** @inline */() {
                return this._pFunctionDefenition.getNumNeededArguments();
            };
            FunctionDeclInstruction.prototype.hasImplementation = function /** @inline */() {
                return !akra.isNull(this._pImplementation) || !akra.isNull(this._pParseNode);
            };
            FunctionDeclInstruction.prototype.getReturnType = function /** @inline */() {
                return this._pFunctionDefenition.getReturnType();
            };
            FunctionDeclInstruction.prototype.setParseNode = function /** @inline */(pNode) {
                this._pParseNode = pNode;
            };
            FunctionDeclInstruction.prototype.setScope = function /** @inline */(iScope) {
                this._iScope = iScope;
            };
            FunctionDeclInstruction.prototype.getParseNode = function /** @inline */() {
                return this._pParseNode;
            };
            FunctionDeclInstruction.prototype.getScope = function /** @inline */() {
                return this._iScope;
            };
            FunctionDeclInstruction.prototype.setFunctionDef = function /** @no-inline */(pFunctionDef) {
                this._pFunctionDefenition = pFunctionDef;
                this._pInstructionList[0] = pFunctionDef;
                pFunctionDef.setParent(this);
                this._nInstuctions = this._nInstuctions === 0 ? 1 : this._nInstuctions;
            };
            FunctionDeclInstruction.prototype.setImplementation = function /** @no-inline */(pImplementation) {
                this._pImplementation = pImplementation;
                this._pInstructionList[1] = pImplementation;
                pImplementation.setParent(pImplementation);
                this._nInstuctions = 2;
                this._pParseNode = null;
            };
            FunctionDeclInstruction.prototype.clone = function /** @no-inline */(pRelationMap) {
                if (typeof pRelationMap === "undefined") { pRelationMap = {
                }; }
                var pClone = _super.prototype.clone.call(this, pRelationMap);
                if(!akra.isNull(this._pOutVariable)) {
                    pClone._setOutVariable(pRelationMap[this._pOutVariable._getInstructionID()]);
                }
                pClone._setUsedFunctions(this._pUsedFunctionMap, this._pUsedFunctionList);
                pClone._initAfterClone();
                return pClone;
            };
            FunctionDeclInstruction.prototype._addOutVariable = function /** @no-inline */(pVariable) {
                if(!akra.isNull(this._pOutVariable)) {
                    return false;
                }
                if(!pVariable.getType().isEqual(this.getReturnType())) {
                    return false;
                }
                this._pOutVariable = pVariable;
                return true;
            };
            FunctionDeclInstruction.prototype._getOutVariable = function /** @no-inline */() {
                return this._pOutVariable;
            };
            FunctionDeclInstruction.prototype._usedAs = function /** @no-inline */(eUsedType) {
                switch(eUsedType) {
                    case 0 /* k_Vertex */ :
                        this._bUsedInVertex = true;
                        this._bUsedAsVertex = true;
                        break;
                    case 1 /* k_Pixel */ :
                        this._bUsedInPixel = true;
                        this._bUsedAsPixel = true;
                        break;
                    case NaN /* k_Function */ :
                        this._bUsedAsFunction = true;
                        break;
                }
            };
            FunctionDeclInstruction.prototype._isUsedAs = function /** @no-inline */(eUsedType) {
                switch(eUsedType) {
                    case 0 /* k_Vertex */ :
                        return this._bUsedAsVertex;
                    case 1 /* k_Pixel */ :
                        return this._bUsedAsPixel;
                    case NaN /* k_Function */ :
                        return this._bUsedAsFunction;
                }
            };
            FunctionDeclInstruction.prototype._isUsedAsFunction = function /** @no-inline */() {
                return this._bUsedAsFunction;
            };
            FunctionDeclInstruction.prototype._isUsedAsVertex = function /** @no-inline */() {
                return this._bUsedAsVertex;
            };
            FunctionDeclInstruction.prototype._isUsedAsPixel = function /** @no-inline */() {
                return this._bUsedAsPixel;
            };
            FunctionDeclInstruction.prototype._usedInVertex = function /** @no-inline */() {
                this._bUsedInVertex = true;
            };
            FunctionDeclInstruction.prototype._usedInPixel = function /** @no-inline */() {
                this._bUsedInPixel = true;
            };
            FunctionDeclInstruction.prototype._isUsedInVertex = function /** @no-inline */() {
                return this._bUsedInVertex;
            };
            FunctionDeclInstruction.prototype._isUsedInPixel = function /** @no-inline */() {
                return this._bUsedInPixel;
            };
            FunctionDeclInstruction.prototype._isUsed = function /** @no-inline */() {
                return this._bUsedAsFunction || this._bUsedAsVertex || this._bUsedAsPixel;
            };
            FunctionDeclInstruction.prototype._checkVertexUsage = function /** @no-inline */() {
                return this._usedInVertex() ? this._isForVertex() : true;
            };
            FunctionDeclInstruction.prototype._checkPixelUsage = function /** @no-inline */() {
                return this._usedInPixel() ? this._isForPixel() : true;
            };
            FunctionDeclInstruction.prototype._checkDefenitionForVertexUsage = function /** @no-inline */() {
                return this._pFunctionDefenition._checkForVertexUsage();
            };
            FunctionDeclInstruction.prototype._checkDefenitionForPixelUsage = function /** @no-inline */() {
                return this._pFunctionDefenition._checkForPixelUsage();
            };
            FunctionDeclInstruction.prototype._canUsedAsFunction = function /** @no-inline */() {
                return this._bCanUsedAsFunction && this._pFunctionDefenition._canUsedAsFunction();
            };
            FunctionDeclInstruction.prototype._notCanUsedAsFunction = function /** @no-inline */() {
                this._bCanUsedAsFunction = false;
            };
            FunctionDeclInstruction.prototype._addUsedFunction = function /** @no-inline */(pFunction) {
                if(akra.isNull(this._pUsedFunctionMap)) {
                    this._pUsedFunctionMap = {
                    };
                    this._pUsedFunctionList = [];
                }
                var iFuncId = pFunction._getInstructionID();
                if(!akra.isDef(this._pUsedFunctionMap[iFuncId])) {
                    this._pUsedFunctionMap[iFuncId] = pFunction;
                    this._pUsedFunctionList.push(pFunction);
                    return true;
                }
                return false;
            };
            FunctionDeclInstruction.prototype._addUsedVariable = function /** @no-inline */(pVariable) {
            };
            FunctionDeclInstruction.prototype._getUsedFunctionList = function /** @no-inline */() {
                return this._pUsedFunctionList;
            };
            FunctionDeclInstruction.prototype._isBlackListFunction = function /** @no-inline */() {
                return this._isInBlackList;
            };
            FunctionDeclInstruction.prototype._addToBlackList = function /** @no-inline */() {
                this._isInBlackList = true;
            };
            FunctionDeclInstruction.prototype._getStringDef = function /** @no-inline */() {
                return this._pFunctionDefenition._getStringDef();
            };
            FunctionDeclInstruction.prototype._convertToVertexShader = function /** @no-inline */() {
                if((!this._canUsedAsFunction() || !this._isUsedAsFunction()) && (!this._checkPixelUsage())) {
                    this._eFunctionType = 0 /* k_Vertex */ ;
                    return this;
                }
                var pShader = this.clone();
                pShader._setFunctionType(0 /* k_Vertex */ );
                return pShader;
            };
            FunctionDeclInstruction.prototype._convertToPixelShader = function /** @no-inline */() {
                if((!this._canUsedAsFunction() || !this._isUsedAsFunction()) && (!this._checkVertexUsage())) {
                    this._eFunctionType = 1 /* k_Pixel */ ;
                    return this;
                }
                var pShader = this.clone();
                pShader._setFunctionType(0 /* k_Vertex */ );
                return pShader;
            };
            FunctionDeclInstruction.prototype._setOutVariable = function /** @no-inline */(pVar) {
                this._pOutVariable = pVar;
            };
            FunctionDeclInstruction.prototype._setUsedFunctions = function /** @no-inline */(pUsedFunctionMap, pUsedFunctionList) {
                this._pUsedFunctionMap = pUsedFunctionMap;
                this._pUsedFunctionList = pUsedFunctionList;
            };
            FunctionDeclInstruction.prototype._setFunctionType = function /** @no-inline */(eFunctionType) {
                this._eFunctionType = eFunctionType;
            };
            FunctionDeclInstruction.prototype._initAfterClone = function /** @no-inline */() {
                this._pFunctionDefenition = this._pInstructionList[0];
                this._pImplementation = this._pInstructionList[1];
            };
            return FunctionDeclInstruction;
        })(fx.DeclInstruction);
        fx.FunctionDeclInstruction = FunctionDeclInstruction;        
        // cloneTo(eConvertTo: EFunctionType): ShaderFunctionInstruction {
        // 	if(eConvertTo === EFunctionType.k_Function) {
        // 		//nothing to do
        // 	}
        // 	return null;
        // }
        var SystemFunctionInstruction = (function (_super) {
            __extends(SystemFunctionInstruction, _super);
            function /** @no-inline */SystemFunctionInstruction(sName, pReturnType, pExprTranslator, pArgumentTypes) {
                        _super.call(this);
                this._pExprTranslator = null;
                this._pName = null;
                this._pReturnType = null;
                this._pArguments = null;
                this._eInstructionType = 43 /* k_SystemFunctionInstruction */ ;
                this._pName = new fx.IdInstruction();
                this._pName.setName(sName);
                this._pName.setParent(this);
                this._pReturnType = new fx.VariableTypeInstruction();
                this._pReturnType.pushInVariableType(this._pReturnType);
                this._pReturnType.setParent(this);
                this._pArguments = [];
                for(var i = 0; i < pArgumentTypes.length; i++) {
                    var pArgument = new fx.TypedInstruction();
                    pArgument.setType(pArgumentTypes[i]);
                    pArgument.setParent(this);
                    this._pArguments.push(pArgument);
                }
                this._pExprTranslator = pExprTranslator;
            }
            SystemFunctionInstruction.prototype.setExprTranslator = function /** @no-inline */(pExprTranslator) {
                this._pExprTranslator = pExprTranslator;
            };
            SystemFunctionInstruction.prototype.getNameId = function /** @no-inline */() {
                return this._pName;
            };
            SystemFunctionInstruction.prototype.getArguments = function /** @no-inline */() {
                return this._pArguments;
            };
            SystemFunctionInstruction.prototype.getNumNeededArguments = function /** @inline */() {
                return this._pArguments.length;
            };
            SystemFunctionInstruction.prototype.hasImplementation = function /** @inline */() {
                return true;
            };
            SystemFunctionInstruction.prototype.getReturnType = function /** @inline */() {
                return this._pReturnType;
            };
            SystemFunctionInstruction.prototype.closeArguments = function /** @no-inline */(pArguments) {
                return this._pExprTranslator.toInstructionList(pArguments);
            };
            SystemFunctionInstruction.prototype.setFunctionDef = function /** @no-inline */(pFunctionDef) {
            };
            SystemFunctionInstruction.prototype.setImplementation = function /** @no-inline */(pImplementation) {
            };
            SystemFunctionInstruction.prototype.clone = function /** @inline */(pRelationMap) {
                return this;
            };
            SystemFunctionInstruction.prototype._addOutVariable = function /** @no-inline */(pVariable) {
                return false;
            };
            SystemFunctionInstruction.prototype._getOutVariable = function /** @no-inline */() {
                return null;
            };
            SystemFunctionInstruction.prototype._usedAs = function /** @no-inline */(eUsedType) {
            };
            SystemFunctionInstruction.prototype._isUsedAs = function /** @no-inline */(eUsedType) {
                return true;
            };
            SystemFunctionInstruction.prototype._isUsedAsFunction = function /** @no-inline */() {
                return true;
            };
            SystemFunctionInstruction.prototype._isUsedAsVertex = function /** @no-inline */() {
                return true;
            };
            SystemFunctionInstruction.prototype._isUsedAsPixel = function /** @no-inline */() {
                return true;
            };
            SystemFunctionInstruction.prototype._usedInVertex = function /** @no-inline */() {
            };
            SystemFunctionInstruction.prototype._usedInPixel = function /** @no-inline */() {
            };
            SystemFunctionInstruction.prototype._isUsedInVertex = function /** @no-inline */() {
                return null;
            };
            SystemFunctionInstruction.prototype._isUsedInPixel = function /** @no-inline */() {
                return null;
            };
            SystemFunctionInstruction.prototype._isUsed = function /** @no-inline */() {
                return null;
            };
            SystemFunctionInstruction.prototype._checkVertexUsage = function /** @no-inline */() {
                return this._isForVertex();
            };
            SystemFunctionInstruction.prototype._checkPixelUsage = function /** @no-inline */() {
                return this._isForPixel();
            };
            SystemFunctionInstruction.prototype._checkDefenitionForVertexUsage = function /** @no-inline */() {
                return false;
            };
            SystemFunctionInstruction.prototype._checkDefenitionForPixelUsage = function /** @no-inline */() {
                return false;
            };
            SystemFunctionInstruction.prototype._canUsedAsFunction = function /** @no-inline */() {
                return true;
            };
            SystemFunctionInstruction.prototype._notCanUsedAsFunction = function /** @no-inline */() {
            };
            SystemFunctionInstruction.prototype._addUsedFunction = function /** @no-inline */(pFunction) {
                return false;
            };
            SystemFunctionInstruction.prototype._addUsedVariable = function /** @no-inline */(pVariable) {
            };
            SystemFunctionInstruction.prototype._getUsedFunctionList = function /** @no-inline */() {
                return null;
            };
            SystemFunctionInstruction.prototype._isBlackListFunction = function /** @no-inline */() {
                return false;
            };
            SystemFunctionInstruction.prototype._addToBlackList = function /** @no-inline */() {
            };
            SystemFunctionInstruction.prototype._getStringDef = function /** @no-inline */() {
                return "system_func";
            };
            SystemFunctionInstruction.prototype._convertToVertexShader = function /** @no-inline */() {
                return null;
            };
            SystemFunctionInstruction.prototype._convertToPixelShader = function /** @no-inline */() {
                return null;
            };
            return SystemFunctionInstruction;
        })(fx.DeclInstruction);
        fx.SystemFunctionInstruction = SystemFunctionInstruction;        
        /**
        * Represent type func(...args)[:Semantic]
        * EMPTY_OPERTOR VariableTypeInstruction IdInstruction VarDeclInstruction ... VarDeclInstruction
        */
        var FunctionDefInstruction = (function (_super) {
            __extends(FunctionDefInstruction, _super);
            //private _sHash: string = "";
            function /** @no-inline */FunctionDefInstruction() {
                        _super.call(this);
                this._pParameterList = null;
                this._pParamListForShaderCompile = null;
                this._pParamListForShaderInput = null;
                this._isComplexShaderInput = false;
                this._pReturnType = null;
                this._pFunctionName = null;
                this._nParamsNeeded = 0;
                this._sDefinition = "";
                this._isAnalyzedForVertexUsage = false;
                this._isAnalyzedForPixelUsage = false;
                this._bCanUsedAsFunction = true;
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._pParameterList = [];
                this._eInstructionType = 44 /* k_FunctionDefInstruction */ ;
            }
            FunctionDefInstruction.prototype.setType = function /** @inline */(pType) {
                this.setReturnType(pType);
            };
            FunctionDefInstruction.prototype.getType = function /** @inline */() {
                return this.getReturnType();
            };
            FunctionDefInstruction.prototype.setReturnType = function /** @inline */(pReturnType) {
                this._pReturnType = pReturnType;
                pReturnType.setParent(this);
                return true;
            };
            FunctionDefInstruction.prototype.getReturnType = function /** @inline */() {
                return this._pReturnType;
            };
            FunctionDefInstruction.prototype.setFunctionName = function /** @inline */(pNameId) {
                this._pFunctionName = pNameId;
                pNameId.setParent(this);
                return true;
            };
            FunctionDefInstruction.prototype.getName = function /** @inline */() {
                return this._pFunctionName.getName();
            };
            FunctionDefInstruction.prototype.getNameId = function /** @inline */() {
                return this._pFunctionName;
            };
            FunctionDefInstruction.prototype.getArguments = function /** @inline */() {
                return this._pParameterList;
            };
            FunctionDefInstruction.prototype.getNumNeededArguments = function /** @inline */() {
                return this._nParamsNeeded;
            };
            FunctionDefInstruction.prototype.addParameter = function /** @no-inline */(pParameter, isStrictModeOn) {
                if(this._pParameterList.length > this._nParamsNeeded && !pParameter.hasInitializer()) {
                    this.setError(2245, {
                        funcName: this._pFunctionName.getName(),
                        varName: pParameter.getName()
                    });
                    return false;
                }
                var pParameterType = pParameter.getType();
                if(akra.isDef(isStrictModeOn)) {
                    if(pParameterType.isPointer() || pParameterType._containPointer()) {
                        if(pParameterType.hasUsage("uniform") || pParameterType.hasUsage("out") || pParameterType.hasUsage("inout")) {
                            this.setError(2265, {
                                funcName: this._pFunctionName.getName(),
                                varName: pParameter.getName()
                            });
                            return false;
                        }
                        this._isAnalyzedForVertexUsage = false;
                        this._isAnalyzedForPixelUsage = true;
                        this._setForPixel(false);
                        this._bCanUsedAsFunction = false;
                        pParameterType._setVideoBufferInDepth();
                    } else if(!isStrictModeOn) {
                        if(pParameterType.isComplex() && !pParameterType.hasFieldWithoutSemantic() && pParameterType.hasAllUniqueSemantics()) {
                            if(pParameter.getSemantic() === "" && pParameterType.hasFieldWithSematic("POSITION")) {
                                pParameterType._addPointIndexInDepth();
                            } else {
                                pParameterType.addPointIndex(false);
                                pParameterType._setVideoBufferInDepth();
                            }
                        } else if(pParameter.getSemantic() !== "") {
                            pParameterType.addPointIndex(false);
                            pParameterType._setVideoBufferInDepth();
                        }
                    }
                }
                this._pParameterList.push(pParameter);
                pParameter.setParent(this);
                if(!pParameter.hasInitializer()) {
                    this._nParamsNeeded++;
                }
                return true;
            };
            FunctionDefInstruction.prototype.clone = function /** @no-inline */(pRelationMap) {
                if (typeof pRelationMap === "undefined") { pRelationMap = {
                }; }
                var pClone = _super.prototype.clone.call(this, pRelationMap);
                pClone.setFunctionName(this._pFunctionName.clone(pRelationMap));
                pClone.setReturnType(this.getReturnType().clone(pRelationMap));
                for(var i = 0; i < this._pParameterList.length; i++) {
                    pClone.addParameter(this._pParameterList[i].clone(pRelationMap));
                }
                return pClone;
            };
            FunctionDefInstruction.prototype._getStringDef = function /** @no-inline */() {
                if(this._sDefinition === "") {
                    this._sDefinition = this._pReturnType.getHash() + " " + this.getName() + "(";
                    for(var i = 0; i < this._pParameterList.length; i++) {
                        this._sDefinition += this._pParameterList[i].getType().getHash() + ",";
                    }
                    this._sDefinition += ")";
                }
                return this._sDefinition;
            };
            FunctionDefInstruction.prototype._canUsedAsFunction = function /** @no-inline */() {
                return this._bCanUsedAsFunction;
            };
            FunctionDefInstruction.prototype._checkForVertexUsage = function /** @no-inline */() {
                if(this._isAnalyzedForVertexUsage) {
                    return this._isForVertex();
                }
                this._isAnalyzedForVertexUsage = true;
                var isGood = true;
                isGood = this.checkReturnTypeForVertexUsage();
                if(!isGood) {
                    this._setForVertex(false);
                    return false;
                }
                isGood = this.checkArgumentsForVertexUsage();
                if(!isGood) {
                    this._setForVertex(false);
                    return false;
                }
                this._setForVertex(true);
                return true;
            };
            FunctionDefInstruction.prototype._checkForPixelUsage = function /** @no-inline */() {
                if(this._isAnalyzedForPixelUsage) {
                    return this._isForPixel();
                }
                this._isAnalyzedForPixelUsage = true;
                var isGood = true;
                isGood = this.checkReturnTypeForPixelUsage();
                if(!isGood) {
                    this._setForPixel(false);
                    return false;
                }
                isGood = this.checkArgumentsForPixelUsage();
                if(!isGood) {
                    this._setForPixel(false);
                    return false;
                }
                this._setForPixel(true);
                return true;
            };
            FunctionDefInstruction.prototype.checkReturnTypeForVertexUsage = function /** @no-inline */() {
                var pReturnType = this._pReturnType;
                var isGood = true;
                if(pReturnType.isEqual(fx.getEffectBaseType("void"))) {
                    return true;
                }
                if(pReturnType.isComplex()) {
                    isGood = !pReturnType.hasFieldWithoutSemantic();
                    if(!isGood) {
                        return false;
                    }
                    isGood = pReturnType.hasAllUniqueSemantics();
                    if(!isGood) {
                        return false;
                    }
                    isGood = pReturnType.hasFieldWithSematic("POSITION");
                    if(!isGood) {
                        return false;
                    }
                    isGood = !pReturnType._containSampler();
                    if(!isGood) {
                        return false;
                    }
                    isGood = !pReturnType._containPointer() && !pReturnType.isPointer();
                    if(!isGood) {
                        return false;
                    }
                    return true;
                } else {
                    isGood = pReturnType.isEqual(fx.getEffectBaseType("float4"));
                    if(!isGood) {
                        return false;
                    }
                    isGood = (this.getSemantic() === "POSITION");
                    if(!isGood) {
                        return false;
                    }
                    return true;
                }
            };
            FunctionDefInstruction.prototype.checkReturnTypeForPixelUsage = function /** @no-inline */() {
                var pReturnType = this._pReturnType;
                var isGood = true;
                if(pReturnType.isEqual(fx.getEffectBaseType("void"))) {
                    return true;
                }
                isGood = pReturnType.isBase();
                if(!isGood) {
                    return false;
                }
                isGood = pReturnType.isEqual(fx.getEffectBaseType("float4"));
                if(!isGood) {
                    return false;
                }
                isGood = this.getSemantic() === "COLOR";
                if(!isGood) {
                    return false;
                }
                return true;
            };
            FunctionDefInstruction.prototype.checkArgumentsForVertexUsage = function /** @no-inline */() {
                var pArguments = this._pParameterList;
                var isAttributeByStruct = false;
                var isAttributeByParams = false;
                var isStartAnalyze = false;
                this._pParamListForShaderInput = [];
                this._pParamListForShaderCompile = [];
                for(var i = 0; i < pArguments.length; i++) {
                    var pParam = pArguments[i];
                    if(pParam.isUniform()) {
                        this._pParamListForShaderCompile.push(pParam);
                        continue;
                    }
                    if(!isStartAnalyze) {
                        if(pParam.getSemantic() === "") {
                            if(pParam.getType().isBase() || pParam.getType().hasFieldWithoutSemantic() || !pParam.getType().hasAllUniqueSemantics()) {
                                return false;
                            }
                            isAttributeByStruct = true;
                        } else if(pParam.getSemantic() !== "") {
                            if(pParam.getType().isComplex() && (pParam.getType().hasFieldWithoutSemantic() || !pParam.getType().hasAllUniqueSemantics())) {
                                return false;
                            }
                            isAttributeByParams = true;
                        }
                        isStartAnalyze = true;
                    } else if(isAttributeByStruct) {
                        return false;
                    } else if(isAttributeByParams) {
                        if(pParam.getSemantic() === "") {
                            return false;
                        }
                        if(pParam.getType().isComplex() && (pParam.getType().hasFieldWithoutSemantic() || !pParam.getType().hasAllUniqueSemantics())) {
                            return false;
                        }
                    }
                    this._pParamListForShaderInput.push(pParam);
                }
                if(isAttributeByStruct) {
                    this._isComplexShaderInput = true;
                }
                return true;
            };
            FunctionDefInstruction.prototype.checkArgumentsForPixelUsage = function /** @no-inline */() {
                var pArguments = this._pParameterList;
                var isVaryingsByStruct = false;
                var isVaryingsByParams = false;
                var isStartAnalyze = false;
                this._pParamListForShaderInput = [];
                this._pParamListForShaderCompile = [];
                for(var i = 0; i < pArguments.length; i++) {
                    var pParam = pArguments[i];
                    if(pParam.isUniform()) {
                        this._pParamListForShaderCompile.push(pParam);
                        continue;
                    }
                    if(!isStartAnalyze) {
                        if(pParam.getSemantic() === "") {
                            if(pParam.getType().isBase() || pParam.getType().hasFieldWithoutSemantic() || !pParam.getType().hasAllUniqueSemantics() || pParam.getType()._containSampler() || pParam.getType()._containPointer() || pParam.getType().isPointer()) {
                                return false;
                            }
                            isVaryingsByStruct = true;
                        } else if(pParam.getSemantic() !== "") {
                            if(pParam.getType().isPointer() || pParam.getType()._containPointer() || pParam.getType()._containSampler() || fx.isSamplerType(pParam.getType())) {
                                return false;
                            }
                            if(pParam.getType().isComplex() && (pParam.getType().hasFieldWithoutSemantic() || !pParam.getType().hasAllUniqueSemantics())) {
                                return false;
                            }
                            isVaryingsByParams = true;
                        }
                        isStartAnalyze = true;
                    } else if(isVaryingsByStruct) {
                        return false;
                    } else if(isVaryingsByParams) {
                        if(pParam.getSemantic() === "") {
                            return false;
                        }
                        if(pParam.getType().isPointer() || pParam.getType()._containPointer() || pParam.getType()._containSampler() || fx.isSamplerType(pParam.getType())) {
                            return false;
                        }
                        if(pParam.getType().isComplex() && (pParam.getType().hasFieldWithoutSemantic() || !pParam.getType().hasAllUniqueSemantics())) {
                            return false;
                        }
                    }
                    this._pParamListForShaderInput.push(pParam);
                }
                if(isVaryingsByStruct) {
                    this._isComplexShaderInput = true;
                }
                return true;
            };
            return FunctionDefInstruction;
        })(fx.DeclInstruction);
        fx.FunctionDefInstruction = FunctionDefInstruction;        
        // getHash(): string {
        // 	if(this._sHash === "") {
        // 		this.calcHash();
        // 	}
        // 	return this._sHash;
        // }
        // private calcHash(): void {
        // 	var sHash: string = "";
        // 	sHash = this._pFunctionName.getName();
        // 	sHash += "(";
        // 	for(var i: uint = 0; i < this._pParameterList.length; i++){
        // 		sHash += this._pParameterList[i]
        // 	}
        // }
            })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        var ExprInstruction = (function (_super) {
            __extends(ExprInstruction, _super);
            /**
            * Respresent all kind of instruction
            */
            function /** @no-inline */ExprInstruction() {
                        _super.call(this);
                this._eInstructionType = 20 /* k_ExprInstruction */ ;
            }
            ExprInstruction.prototype.evaluate = function /** @no-inline */() {
                return false;
            };
            ExprInstruction.prototype.simplify = function /** @no-inline */() {
                return false;
            };
            ExprInstruction.prototype.getEvalValue = function /** @no-inline */() {
                return null;
            };
            ExprInstruction.prototype.isConst = function /** @no-inline */() {
                return false;
            };
            ExprInstruction.prototype.clone = function /** @no-inline */(pRelationMap) {
                return _super.prototype.clone.call(this, pRelationMap);
            };
            return ExprInstruction;
        })(fx.TypedInstruction);
        fx.ExprInstruction = ExprInstruction;        
        var IntInstruction = (function (_super) {
            __extends(IntInstruction, _super);
            /**
            * EMPTY_OPERATOR EMPTY_ARGUMENTS
            */
            function /** @no-inline */IntInstruction() {
                        _super.call(this);
                this._iValue = 0;
                this._pType = fx.getEffectBaseType("int");
                this._eInstructionType = 7 /* k_IntInstruction */ ;
            }
            IntInstruction.prototype.setValue = function /** @inline */(iValue) {
                this._iValue = iValue;
            };
            IntInstruction.prototype.toString = function /** @no-inline */() {
                return this._iValue;
            };
            IntInstruction.prototype.isConst = function /** @inline */() {
                return true;
            };
            IntInstruction.prototype.clone = function /** @no-inline */(pRelationMap) {
                var pClonedInstruction = (_super.prototype.clone.call(this, pRelationMap));
                pClonedInstruction.setValue(this._iValue);
                return pClonedInstruction;
            };
            return IntInstruction;
        })(ExprInstruction);
        fx.IntInstruction = IntInstruction;        
        var FloatInstruction = (function (_super) {
            __extends(FloatInstruction, _super);
            /**
            * EMPTY_OPERATOR EMPTY_ARGUMENTS
            */
            function /** @no-inline */FloatInstruction() {
                        _super.call(this);
                this._fValue = 0.0;
                this._pType = fx.getEffectBaseType("float");
                this._eInstructionType = 8 /* k_FloatInstruction */ ;
            }
            FloatInstruction.prototype.setValue = function /** @inline */(fValue) {
                this._fValue = fValue;
            };
            FloatInstruction.prototype.toString = function /** @no-inline */() {
                return this._fValue;
            };
            FloatInstruction.prototype.isConst = function /** @inline */() {
                return true;
            };
            FloatInstruction.prototype.clone = function /** @no-inline */(pRelationMap) {
                var pClonedInstruction = (_super.prototype.clone.call(this, pRelationMap));
                pClonedInstruction.setValue(this._fValue);
                return pClonedInstruction;
            };
            return FloatInstruction;
        })(ExprInstruction);
        fx.FloatInstruction = FloatInstruction;        
        var BoolInstruction = (function (_super) {
            __extends(BoolInstruction, _super);
            /**
            * EMPTY_OPERATOR EMPTY_ARGUMENTS
            */
            function /** @no-inline */BoolInstruction() {
                        _super.call(this);
                this._bValue = true;
                this._pType = fx.getEffectBaseType("bool");
                this._eInstructionType = 9 /* k_BoolInstruction */ ;
            }
            BoolInstruction._pBoolType = null;
            BoolInstruction.prototype.setValue = function /** @inline */(bValue) {
                this._bValue = bValue;
            };
            BoolInstruction.prototype.toString = function /** @no-inline */() {
                return this._bValue;
            };
            BoolInstruction.prototype.isConst = function /** @inline */() {
                return true;
            };
            BoolInstruction.prototype.clone = function /** @no-inline */(pRelationMap) {
                var pClonedInstruction = (_super.prototype.clone.call(this, pRelationMap));
                pClonedInstruction.setValue(this._bValue);
                return pClonedInstruction;
            };
            return BoolInstruction;
        })(ExprInstruction);
        fx.BoolInstruction = BoolInstruction;        
        var StringInstruction = (function (_super) {
            __extends(StringInstruction, _super);
            /**
            * EMPTY_OPERATOR EMPTY_ARGUMENTS
            */
            function /** @no-inline */StringInstruction() {
                        _super.call(this);
                this._sValue = "";
                this._pType = fx.getEffectBaseType("string");
                this._eInstructionType = 10 /* k_StringInstruction */ ;
            }
            StringInstruction._pStringType = null;
            StringInstruction.prototype.setValue = function /** @inline */(sValue) {
                this._sValue = sValue;
            };
            StringInstruction.prototype.toString = function /** @no-inline */() {
                return this._sValue;
            };
            StringInstruction.prototype.isConst = function /** @inline */() {
                return true;
            };
            StringInstruction.prototype.clone = function /** @no-inline */(pRelationMap) {
                var pClonedInstruction = (_super.prototype.clone.call(this, pRelationMap));
                pClonedInstruction.setValue(this._sValue);
                return pClonedInstruction;
            };
            return StringInstruction;
        })(ExprInstruction);
        fx.StringInstruction = StringInstruction;        
        var IdExprInstruction = (function (_super) {
            __extends(IdExprInstruction, _super);
            function /** @no-inline */IdExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = 21 /* k_IdExprInstruction */ ;
            }
            IdExprInstruction.prototype.getType = function /** @no-inline */() {
                if(!akra.isNull(this._pType)) {
                    return this._pType;
                } else {
                    var pVar = this._pInstructionList[0];
                    this._pType = (pVar.getParent()).getType();
                    return this._pType;
                }
            };
            IdExprInstruction.prototype.isConst = function /** @no-inline */() {
                return this.getType().isConst();
            };
            IdExprInstruction.prototype.clone = function /** @no-inline */(pRelationMap) {
                return _super.prototype.clone.call(this, pRelationMap);
            };
            return IdExprInstruction;
        })(ExprInstruction);
        fx.IdExprInstruction = IdExprInstruction;        
        /**
        * Represent someExpr + / - * % someExpr
        * (+|-|*|/|%) Instruction Instruction
        */
        var ArithmeticExprInstruction = (function (_super) {
            __extends(ArithmeticExprInstruction, _super);
            function /** @no-inline */ArithmeticExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._eInstructionType = 22 /* k_ArithmeticExprInstruction */ ;
            }
            return ArithmeticExprInstruction;
        })(ExprInstruction);
        fx.ArithmeticExprInstruction = ArithmeticExprInstruction;        
        /**
        * Represent someExpr = += -= /= *= %= someExpr
        * (=|+=|-=|*=|/=|%=) Instruction Instruction
        */
        var AssignmentExprInstruction = (function (_super) {
            __extends(AssignmentExprInstruction, _super);
            function /** @no-inline */AssignmentExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._eInstructionType = 23 /* k_AssignmentExprInstruction */ ;
            }
            return AssignmentExprInstruction;
        })(ExprInstruction);
        fx.AssignmentExprInstruction = AssignmentExprInstruction;        
        /**
        * Represent someExpr == != < > <= >= someExpr
        * (==|!=|<|>|<=|>=) Instruction Instruction
        */
        var RelationalExprInstruction = (function (_super) {
            __extends(RelationalExprInstruction, _super);
            function /** @no-inline */RelationalExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._eInstructionType = 24 /* k_RelationalExprInstruction */ ;
            }
            return RelationalExprInstruction;
        })(ExprInstruction);
        fx.RelationalExprInstruction = RelationalExprInstruction;        
        /**
        * Represent boolExpr && || boolExpr
        * (&& | ||) Instruction Instruction
        */
        var LogicalExprInstruction = (function (_super) {
            __extends(LogicalExprInstruction, _super);
            function /** @no-inline */LogicalExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._eInstructionType = 25 /* k_LogicalExprInstruction */ ;
            }
            return LogicalExprInstruction;
        })(ExprInstruction);
        fx.LogicalExprInstruction = LogicalExprInstruction;        
        /**
        * Represen boolExpr ? someExpr : someExpr
        * EMPTY_OPERATOR Instruction Instruction Instruction
        */
        var ConditionalExprInstruction = (function (_super) {
            __extends(ConditionalExprInstruction, _super);
            function /** @no-inline */ConditionalExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null, 
                    null
                ];
                this._eInstructionType = 26 /* k_ConditionalExprInstruction */ ;
            }
            return ConditionalExprInstruction;
        })(ExprInstruction);
        fx.ConditionalExprInstruction = ConditionalExprInstruction;        
        /**
        * Represent (type) expr
        * EMPTY_OPERATOR VariableTypeInstruction Instruction
        */
        var CastExprInstruction = (function (_super) {
            __extends(CastExprInstruction, _super);
            function /** @no-inline */CastExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._eInstructionType = 27 /* k_CastExprInstruction */ ;
            }
            return CastExprInstruction;
        })(ExprInstruction);
        fx.CastExprInstruction = CastExprInstruction;        
        /**
        * Represent + - ! ++ -- expr
        * (+|-|!|++|--|) Instruction
        */
        var UnaryExprInstruction = (function (_super) {
            __extends(UnaryExprInstruction, _super);
            function /** @no-inline */UnaryExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = 28 /* k_UnaryExprInstruction */ ;
            }
            return UnaryExprInstruction;
        })(ExprInstruction);
        fx.UnaryExprInstruction = UnaryExprInstruction;        
        /**
        * Represent someExpr[someIndex]
        * EMPTY_OPERATOR Instruction ExprInstruction
        */
        var PostfixIndexInstruction = (function (_super) {
            __extends(PostfixIndexInstruction, _super);
            function /** @no-inline */PostfixIndexInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._eInstructionType = 29 /* k_PostfixIndexInstruction */ ;
            }
            return PostfixIndexInstruction;
        })(ExprInstruction);
        fx.PostfixIndexInstruction = PostfixIndexInstruction;        
        /*
        * Represent someExpr.id
        * EMPTY_OPERATOR Instruction IdInstruction
        */
        var PostfixPointInstruction = (function (_super) {
            __extends(PostfixPointInstruction, _super);
            function /** @no-inline */PostfixPointInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._eInstructionType = 30 /* k_PostfixPointInstruction */ ;
            }
            return PostfixPointInstruction;
        })(ExprInstruction);
        fx.PostfixPointInstruction = PostfixPointInstruction;        
        /**
        * Represent someExpr ++
        * (-- | ++) Instruction
        */
        var PostfixArithmeticInstruction = (function (_super) {
            __extends(PostfixArithmeticInstruction, _super);
            function /** @no-inline */PostfixArithmeticInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = 31 /* k_PostfixArithmeticInstruction */ ;
            }
            return PostfixArithmeticInstruction;
        })(ExprInstruction);
        fx.PostfixArithmeticInstruction = PostfixArithmeticInstruction;        
        /**
        * Represent @ Expr
        * @ Instruction
        */
        var PrimaryExprInstruction = (function (_super) {
            __extends(PrimaryExprInstruction, _super);
            function /** @no-inline */PrimaryExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = 32 /* k_PrimaryExprInstruction */ ;
            }
            return PrimaryExprInstruction;
        })(ExprInstruction);
        fx.PrimaryExprInstruction = PrimaryExprInstruction;        
        /**
        * Represent (expr)
        * EMPTY_OPERATOR ExprInstruction
        */
        var ComplexExprInstruction = (function (_super) {
            __extends(ComplexExprInstruction, _super);
            function /** @no-inline */ComplexExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = 33 /* k_ComplexExprInstruction */ ;
            }
            return ComplexExprInstruction;
        })(ExprInstruction);
        fx.ComplexExprInstruction = ComplexExprInstruction;        
        /**
        * Respresnt func(arg1,..., argn)
        * EMPTY_OPERATOR IdExprInstruction ExprInstruction ... ExprInstruction
        */
        var FunctionCallInstruction = (function (_super) {
            __extends(FunctionCallInstruction, _super);
            function /** @no-inline */FunctionCallInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = 34 /* k_FunctionCallInstruction */ ;
            }
            return FunctionCallInstruction;
        })(ExprInstruction);
        fx.FunctionCallInstruction = FunctionCallInstruction;        
        /**
        * Respresnt system_func(arg1,..., argn)
        * EMPTY_OPERATOR SimpleInstruction ... SimpleInstruction
        */
        var SystemCallInstruction = (function (_super) {
            __extends(SystemCallInstruction, _super);
            function /** @no-inline */SystemCallInstruction() {
                        _super.call(this);
                this._pSystemFunction = null;
                this._pInstructionList = null;
                this._eInstructionType = 35 /* k_SystemCallInstruction */ ;
            }
            SystemCallInstruction.prototype.setSystemCallFunction = function /** @no-inline */(pFunction) {
                this._pSystemFunction = pFunction;
                this.setType(pFunction.getType());
            };
            SystemCallInstruction.prototype.setInstructions = function /** @no-inline */(pInstructionList) {
                this._pInstructionList = pInstructionList;
                for(var i = 0; i < pInstructionList.length; i++) {
                    pInstructionList[i].setParent(this);
                }
            };
            SystemCallInstruction.prototype.fillByArguments = function /** @no-inline */(pArguments) {
                this.setInstructions(this._pSystemFunction.closeArguments(pArguments));
            };
            return SystemCallInstruction;
        })(ExprInstruction);
        fx.SystemCallInstruction = SystemCallInstruction;        
        /**
        * Respresnt ctor(arg1,..., argn)
        * EMPTY_OPERATOR IdInstruction ExprInstruction ... ExprInstruction
        */
        var ConstructorCallInstruction = (function (_super) {
            __extends(ConstructorCallInstruction, _super);
            function /** @no-inline */ConstructorCallInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = 36 /* k_ConstructorCallInstruction */ ;
            }
            return ConstructorCallInstruction;
        })(ExprInstruction);
        fx.ConstructorCallInstruction = ConstructorCallInstruction;        
        /**
        * Represetn compile vs_func(...args)
        * compile IdExprInstruction ExprInstruction ... ExprInstruction
        */
        var CompileExprInstruction = (function (_super) {
            __extends(CompileExprInstruction, _super);
            function /** @no-inline */CompileExprInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = 37 /* k_CompileExprInstruction */ ;
            }
            CompileExprInstruction.prototype.getFunction = function /** @inline */() {
                return this._pInstructionList[0].getParent();
            };
            return CompileExprInstruction;
        })(ExprInstruction);
        fx.CompileExprInstruction = CompileExprInstruction;        
        var MemExprInstruction = (function (_super) {
            __extends(MemExprInstruction, _super);
            function /** @no-inline */MemExprInstruction() {
                        _super.call(this);
                this._pBuffer = null;
                this._pInstructionList = null;
                this._eInstructionType = 40 /* k_MemExprInstruction */ ;
            }
            MemExprInstruction.prototype.getBuffer = function /** @no-inline */() {
                return this._pBuffer;
            };
            MemExprInstruction.prototype.setBuffer = function /** @no-inline */(pBuffer) {
                this._pBuffer = pBuffer;
                this.setType(pBuffer.getType());
            };
            return MemExprInstruction;
        })(ExprInstruction);
        fx.MemExprInstruction = MemExprInstruction;        
        /**
        * Represetn sampler_state { states }
        * sampler_state IdExprInstruction ExprInstruction ... ExprInstruction
        */
        var SamplerStateBlockInstruction = (function (_super) {
            __extends(SamplerStateBlockInstruction, _super);
            function /** @no-inline */SamplerStateBlockInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null
                ];
                this._eInstructionType = 38 /* k_SamplerStateBlockInstruction */ ;
            }
            return SamplerStateBlockInstruction;
        })(ExprInstruction);
        fx.SamplerStateBlockInstruction = SamplerStateBlockInstruction;        
        var SamplerStateInstruction = (function (_super) {
            __extends(SamplerStateInstruction, _super);
            function /** @no-inline */SamplerStateInstruction() {
                        _super.call(this);
                this._pInstructionList = [
                    null, 
                    null
                ];
                this._eInstructionType = 39 /* k_SamplerStateInstruction */ ;
            }
            return SamplerStateInstruction;
        })(ExprInstruction);
        fx.SamplerStateInstruction = SamplerStateInstruction;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        var Effect = (function () {
            function /** @no-inline */Effect(pComposer) {
                this._pComposer = null;
                this._pParseTree = null;
                this._pAnalyzedNode = null;
                this._pEffectScope = null;
                this._pCurrentInstruction = null;
                this._pCurrentFunction = null;
                this._pStatistics = null;
                this._sAnalyzedFileName = "";
                this._pSystemTypes = null;
                this._pSystemFunctionsMap = null;
                this._pSystemFunctionHashMap = null;
                this._pSystemVariables = null;
                this._pFunctionWithImplementationList = null;
                this._pTechniqueList = null;
                this._pTechniqueMap = null;
                this._pComposer = pComposer;
                this._pParseTree = null;
                this._pAnalyzedNode = null;
                this._pEffectScope = new fx.ProgramScope();
                this._pCurrentInstruction = null;
                this._pStatistics = null;
                this._sAnalyzedFileName = "";
                this._pFunctionWithImplementationList = [];
                this._pTechniqueList = [];
                this._pTechniqueMap = {
                };
                this.initSystemTypes();
                this.initSystemFunctions();
                this.initSystemVariables();
            }
            Effect.pSystemTypes = null;
            Effect.pSystemFunctions = null;
            Effect.pSystemVariables = null;
            Effect.prototype.analyze = function /** @no-inline */(pTree) {
                var pRootNode = pTree.root;
                var iParseTime = akra.now();
                this._pParseTree = pTree;
                this._pStatistics = {
                    time: 0
                };
                this.newScope();
                this.analyzeGlobalUseDecls();
                this.analyzeGlobalTypeDecls();
                this.analyzeFunctionDefinitions();
                this.analyzeGlobalImports();
                this.analyzeTechniqueImports();
                this.analyzeVariableDecls();
                this.analyzeFunctionDecls();
                this.analyzeTechniques();
                // this.analyzeTypes();
                // this.preAnalyzeFunctions();
                // this.preAnalyzeVariables();
                // this.preAnalyzeTechniques();
                // this.analyzeDecls();
                // this.analyzeEffect();
                // this.postAnalyzeEffect();
                // this.checkEffect();
                this.endScope();
                //Stats
                iParseTime = akra.now() - iParseTime;
                this._pStatistics.time = iParseTime;
                return true;
            };
            Effect.prototype.getStats = function /** @no-inline */() {
                return this._pStatistics;
            };
            Effect.prototype.setAnalyzedFileName = function /** @no-inline */(sFileName) {
                this._sAnalyzedFileName = sFileName;
            };
            Effect.prototype.clear = function /** @no-inline */() {
            };
            Effect.getSystemType = function /** @no-inline */getSystemType(sTypeName) {
                //bool, string, float and others
                return akra.isDef(Effect.pSystemTypes[sTypeName]) ? Effect.pSystemTypes[sTypeName] : null;
            };
            Effect.getSystemVariable = function /** @no-inline */getSystemVariable(sName) {
                return akra.isDef(Effect.pSystemVariables[sName]) ? Effect.pSystemVariables[sName] : null;
            };
            Effect.findSystemFunction = function /** @no-inline */findSystemFunction(sFunctionName, pArguments) {
                var pSystemFunctions = Effect.pSystemFunctions[sFunctionName];
                if(!akra.isDef(pSystemFunctions)) {
                    return null;
                }
                for(var i = 0; i < pSystemFunctions.length; i++) {
                    if(pArguments.length !== pSystemFunctions[i].getNumNeededArguments()) {
                        continue;
                    }
                    var pTestedArguments = pSystemFunctions[i].getArguments();
                    var isOk = true;
                    for(var j = 0; j < pArguments.length; j++) {
                        isOk = false;
                        if(pArguments[j].getType().isEqual(pTestedArguments[j].getType())) {
                            break;
                        }
                        isOk = true;
                    }
                    if(isOk) {
                        return pSystemFunctions[i];
                    }
                }
            };
            Effect.createVideoBufferVariable = function /** @no-inline */createVideoBufferVariable() {
                var pBuffer = new fx.VariableDeclInstruction();
                var pBufferType = new fx.VariableTypeInstruction();
                var pBufferName = new fx.IdInstruction();
                pBufferType.pushInVariableType(Effect.getSystemType("video_buffer"));
                pBuffer.push(pBufferType, true);
                pBuffer.push(pBufferName, true);
                return pBuffer;
            };
            Effect.prototype.generateSuffixLiterals = function /** @no-inline */(pLiterals, pOutput, iDepth) {
                if (typeof iDepth === "undefined") { iDepth = 0; }
                if(iDepth >= pLiterals.length) {
                    return;
                }
                if(iDepth === 0) {
                    for(var i = 0; i < pLiterals.length; i++) {
                        pOutput[pLiterals[i]] = true;
                    }
                    iDepth = 1;
                }
                var pOutputKeys = Object.keys(pOutput);
                for(var i = 0; i < pLiterals.length; i++) {
                    for(var j = 0; j < pOutputKeys.length; j++) {
                        if(pOutputKeys[j].indexOf(pLiterals[i]) !== -1) {
                            pOutput[pOutputKeys[j] + pLiterals[i]] = false;
                        } else {
                            pOutput[pOutputKeys[j] + pLiterals[i]] = (pOutput[pOutputKeys[j]] === false) ? false : true;
                        }
                    }
                }
                iDepth++;
                this.generateSuffixLiterals(pLiterals, pOutput, iDepth);
            };
            Effect.prototype.initSystemTypes = function /** @no-inline */() {
                if(akra.isNull(Effect.pSystemTypes)) {
                    this._pSystemTypes = Effect.pSystemTypes = {
                    };
                    this.addSystemTypeScalar();
                    this.addSystemTypeVector();
                    this.addSystemTypeMatrix();
                }
                this._pSystemTypes = Effect.pSystemTypes;
            };
            Effect.prototype.initSystemFunctions = function /** @no-inline */() {
                if(akra.isNull(Effect.pSystemFunctions)) {
                    this._pSystemFunctionsMap = Effect.pSystemFunctions = {
                    };
                    this.addSystemFunctions();
                }
                this._pSystemFunctionsMap = Effect.pSystemFunctions;
            };
            Effect.prototype.initSystemVariables = function /** @no-inline */() {
                if(akra.isNull(Effect.pSystemVariables)) {
                    this._pSystemVariables = Effect.pSystemVariables = {
                    };
                    this.addSystemVariables();
                }
                this._pSystemVariables = Effect.pSystemVariables;
            };
            Effect.prototype.addSystemVariables = function /** @no-inline */() {
                this.generateSystemVariable("fragCoord", "gl_FragCoord", "float4", false, true, true);
                this.generateSystemVariable("frontFacing", "gl_FrontFacing", "bool", false, true, true);
                this.generateSystemVariable("pointCoord", "gl_PointCoord", "float2", false, true, true);
            };
            Effect.prototype.generateSystemVariable = function /** @no-inline */(sName, sRealName, sTypeName, isForVertex, isForPixel, isOnlyRead) {
                if(akra.isDef(this._pSystemVariables[sName])) {
                    return;
                }
                var pVariableDecl = new fx.VariableDeclInstruction();
                var pName = new fx.IdInstruction();
                var pType = new fx.VariableTypeInstruction();
                pName.setName(sName);
                pName.setRealName(sRealName);
                pType.pushInVariableType(Effect.getSystemType(sTypeName));
                if(isOnlyRead) {
                    pType._canWrite(false);
                }
                pVariableDecl._setForVertex(isForVertex);
                pVariableDecl._setForPixel(isForPixel);
                pVariableDecl.push(pName, true);
                pVariableDecl.push(pType, true);
                this._pSystemVariables[sName] = pVariableDecl;
            };
            Effect.prototype.addSystemFunctions = function /** @no-inline */() {
                this._pSystemFunctionHashMap = {
                };
                this.generateSystemFunction("dot", "dot($1,$2)", "float", [
                    "template", 
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("mul", "$1*$2", "template", [
                    "template", 
                    "template"
                ], [
                    "float", 
                    "int", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("mod", "mod($1,$2)", "float", [
                    "float", 
                    "float"
                ], null);
                this.generateSystemFunction("floor", "floor($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("ceil", "ceil($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("fract", "fract($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("abs", "abs($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("normalize", "normalize($1)", "float", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("length", "length($1)", "float", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("reflect", "reflect($1,$2)", "template", [
                    "template", 
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("max", "max($1,$2)", "template", [
                    "template", 
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("max", "max($1,$2)", "template", [
                    "template", 
                    "float"
                ], [
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("min", "min($1,$2)", "template", [
                    "template", 
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("min", "min($1,$2)", "template", [
                    "template", 
                    "float"
                ], [
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("clamp", "clamp($1,$2,$3)", "template", [
                    "template", 
                    "template", 
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("clamp", "clamp($1,$2,$3)", "template", [
                    "template", 
                    "float", 
                    "float"
                ], [
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("pow", "pow($1,$2)", "template", [
                    "template", 
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("mod", "mod($1,$2)", "template", [
                    "template", 
                    "template"
                ], [
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("mod", "mod($1,$2)", "template", [
                    "template", 
                    "float"
                ], [
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("exp", "exp($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("exp2", "exp2($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("log", "log($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("log2", "log2($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("inversesqrt", "inversesqrt($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("sqrt", "sqrt($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("all", "all($1)", "bool", [
                    "template"
                ], [
                    "bool2", 
                    "bool3", 
                    "bool4"
                ]);
                this.generateSystemFunction("lessThanEqual", "lessThanEqual($1,$2)", "bool2", [
                    "template", 
                    "template"
                ], [
                    "float2", 
                    "int2"
                ]);
                this.generateSystemFunction("lessThanEqual", "lessThanEqual($1,$2)", "bool3", [
                    "template", 
                    "template"
                ], [
                    "float3", 
                    "int3"
                ]);
                this.generateSystemFunction("lessThanEqual", "lessThanEqual($1,$2)", "bool4", [
                    "template", 
                    "template"
                ], [
                    "float4", 
                    "int4"
                ]);
                this.generateSystemFunction("radians", "radians($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("degrees", "degrees($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("sin", "sin($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("cos", "cos($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("tan", "tan($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("asin", "asin($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("acos", "acos($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("atan", "atan($1)", "template", [
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("atan", "atan($1, $2)", "template", [
                    "template", 
                    "template"
                ], [
                    "float", 
                    "float2", 
                    "float3", 
                    "float4"
                ]);
                this.generateSystemFunction("tex2D", "texture2D($1,$2)", "float4", [
                    "sampler", 
                    "float2"
                ], null);
                this.generateSystemFunction("tex2D", "texture2D($1,$2)", "float4", [
                    "sampler2D", 
                    "float2"
                ], null);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", [
                    "sampler", 
                    "float3"
                ], null);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", [
                    "sampler2D", 
                    "float3"
                ], null);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", [
                    "sampler", 
                    "float4"
                ], null);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", [
                    "sampler2D", 
                    "float4"
                ], null);
                this.generateSystemFunction("texCUBE", "textureCube($1,$2)", "float4", [
                    "sampler", 
                    "float3"
                ], null);
                this.generateSystemFunction("texCUBE", "textureCube($1,$2)", "float4", [
                    "samplerCUBE", 
                    "float3"
                ], null);
                this.generateSystemFunction("tex2D", "texture2D($1,$2,$3)", "float4", [
                    "sampler", 
                    "float2", 
                    "float"
                ], null, false, true);
                this.generateSystemFunction("tex2D", "texture2D($1,$2,$3)", "float4", [
                    "sampler2D", 
                    "float2", 
                    "float"
                ], null, false, true);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", [
                    "sampler", 
                    "float3", 
                    "float"
                ], null, false, true);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", [
                    "sampler2D", 
                    "float3", 
                    "float"
                ], null, false, true);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", [
                    "sampler", 
                    "float4", 
                    "float"
                ], null, false, true);
                this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", [
                    "sampler2D", 
                    "float4", 
                    "float"
                ], null, false, true);
                this.generateSystemFunction("texCUBE", "textureCube($1,$2,$3)", "float4", [
                    "sampler", 
                    "float3", 
                    "float"
                ], null, false, true);
                this.generateSystemFunction("texCUBE", "textureCube($1,$2,$3)", "float4", [
                    "samplerCUBE", 
                    "float3", 
                    "float"
                ], null, false, true);
                this.generateSystemFunction("tex2DLod", "texture2DLod($1,$2,$3)", "float4", [
                    "sampler", 
                    "float2", 
                    "float"
                ], null, true, false);
                this.generateSystemFunction("tex2DLod", "texture2DLod($1,$2,$3)", "float4", [
                    "sampler2D", 
                    "float2", 
                    "float"
                ], null, true, false);
                this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", [
                    "sampler", 
                    "float3", 
                    "float"
                ], null, true, false);
                this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", [
                    "sampler2D", 
                    "float3", 
                    "float"
                ], null, true, false);
                this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", [
                    "sampler", 
                    "float4", 
                    "float"
                ], null, true, false);
                this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", [
                    "sampler2D", 
                    "float4", 
                    "float"
                ], null, true, false);
                this.generateSystemFunction("texCUBELod", "textureCubeLod($1,$2,$3)", "float4", [
                    "sampler", 
                    "float3", 
                    "float"
                ], null, true, false);
                this.generateSystemFunction("texCUBELod", "textureCubeLod($1,$2,$3)", "float4", [
                    "samplerCUBE", 
                    "float3", 
                    "float"
                ], null, true, false);
            };
            Effect.prototype.generateSystemFunction = function /** @no-inline */(sName, sTranslationExpr, sReturnTypeName, pArgumentsTypes, pTemplateTypes, isForVertex, isForPixel) {
                if (typeof isForVertex === "undefined") { isForVertex = true; }
                if (typeof isForPixel === "undefined") { isForPixel = true; }
                var pExprTranslator = new fx.ExprTemplateTranslator(sTranslationExpr);
                var pSystemFunctions = this._pSystemFunctionsMap;
                var pTypes = null;
                var sFunctionHash = "";
                var pReturnType = null;
                var pFunction = null;
                if(!akra.isNull(pTemplateTypes)) {
                    for(var i = 0; i < pTemplateTypes.length; i++) {
                        pTypes = [];
                        sFunctionHash = sName + "(";
                        pReturnType = (sReturnTypeName === "template") ? Effect.getSystemType(pTemplateTypes[i]) : Effect.getSystemType(sReturnTypeName);
                        for(var j = 0; j < pArgumentsTypes.length; j++) {
                            if(pArgumentsTypes[j] === "template") {
                                pTypes.push(Effect.getSystemType(pTemplateTypes[i]));
                                sFunctionHash += pTemplateTypes[i] + ",";
                            } else {
                                pTypes.push(Effect.getSystemType(pArgumentsTypes[j]));
                                sFunctionHash += pArgumentsTypes[j] + ",";
                            }
                        }
                        sFunctionHash += ")";
                        if(this._pSystemFunctionHashMap[sFunctionHash]) {
                            this._error(2248, {
                                funcName: sFunctionHash
                            });
                        }
                        pFunction = new fx.SystemFunctionInstruction(sName, pReturnType, pExprTranslator, pTypes);
                        if(!akra.isDef(pSystemFunctions[sName])) {
                            pSystemFunctions[sName] = [];
                        }
                        pFunction._setForVertex(isForVertex);
                        pFunction._setForPixel(isForPixel);
                        pSystemFunctions[sName].push(pFunction);
                    }
                } else {
                    if(sReturnTypeName === "template") {
                        akra.logger.criticalError("Bad return type(TEMPLATE_TYPE) for system function '" + sName + "'.");
                    }
                    pReturnType = Effect.getSystemType(sReturnTypeName);
                    pTypes = [];
                    sFunctionHash = sName + "(";
                    for(var i = 0; i < pArgumentsTypes.length; i++) {
                        if(pArgumentsTypes[i] === "template") {
                            akra.logger.criticalError("Bad argument type(TEMPLATE_TYPE) for system function '" + sName + "'.");
                        } else {
                            pTypes.push(Effect.getSystemType(pArgumentsTypes[i]));
                            sFunctionHash += pArgumentsTypes[i] + ",";
                        }
                    }
                    sFunctionHash += ")";
                    if(this._pSystemFunctionHashMap[sFunctionHash]) {
                        this._error(2248, {
                            funcName: sFunctionHash
                        });
                    }
                    pFunction = new fx.SystemFunctionInstruction(sName, pReturnType, pExprTranslator, pTypes);
                    pFunction._setForVertex(isForVertex);
                    pFunction._setForPixel(isForPixel);
                    if(!akra.isDef(pSystemFunctions[sName])) {
                        pSystemFunctions[sName] = [];
                    }
                    pSystemFunctions[sName].push(pFunction);
                }
            };
            Effect.prototype.generateSystemType = function /** @no-inline */(sName, sRealName, iSize, isArray, pElementType, iLength) {
                if (typeof iSize === "undefined") { iSize = 1; }
                if (typeof isArray === "undefined") { isArray = false; }
                if (typeof pElementType === "undefined") { pElementType = null; }
                if (typeof iLength === "undefined") { iLength = 1; }
                if(akra.isDef(this._pSystemTypes[sName])) {
                    return null;
                }
                var pSystemType = new fx.SystemTypeInstruction();
                pSystemType.setName(sName);
                pSystemType.setRealName(sRealName);
                pSystemType.setSize(iSize);
                if(isArray) {
                    pSystemType.addIndex(pElementType, iLength);
                }
                this._pSystemTypes[sName] = pSystemType;
                return pSystemType;
            };
            Effect.prototype.addSystemTypeScalar = function /** @no-inline */() {
                this.generateSystemType("void", "void", 0);
                this.generateSystemType("int", "int", 1);
                this.generateSystemType("bool", "bool", 1);
                this.generateSystemType("float", "float", 1);
                this.generateSystemType("ptr", "float", 1);
                this.generateSystemType("string", "", 0);
                this.generateSystemType("texture", "", 0);
                this.generateSystemType("sampler", "sampler2D", 1);
                this.generateSystemType("sampler2D", "sampler2D", 1);
                this.generateSystemType("samplerCUBE", "samplerCube", 1);
                this.generateSystemType("video_buffer", "sampler2D", 1);
            };
            Effect.prototype.addSystemTypeVector = function /** @no-inline */() {
                var pXYSuffix = {
                };
                var pXYZSuffix = {
                };
                var pXYZWSuffix = {
                };
                var pRGSuffix = {
                };
                var pRGBSuffix = {
                };
                var pRGBASuffix = {
                };
                var pSTSuffix = {
                };
                var pSTPSuffix = {
                };
                var pSTPQSuffix = {
                };
                this.generateSuffixLiterals([
                    "x", 
                    "y"
                ], pXYSuffix);
                this.generateSuffixLiterals([
                    "x", 
                    "y", 
                    "z"
                ], pXYZSuffix);
                this.generateSuffixLiterals([
                    "x", 
                    "y", 
                    "z", 
                    "w"
                ], pXYZWSuffix);
                this.generateSuffixLiterals([
                    "r", 
                    "g"
                ], pRGSuffix);
                this.generateSuffixLiterals([
                    "r", 
                    "g", 
                    "b"
                ], pRGBSuffix);
                this.generateSuffixLiterals([
                    "r", 
                    "g", 
                    "b", 
                    "a"
                ], pRGBASuffix);
                this.generateSuffixLiterals([
                    "s", 
                    "t"
                ], pSTSuffix);
                this.generateSuffixLiterals([
                    "s", 
                    "t", 
                    "p"
                ], pSTPSuffix);
                this.generateSuffixLiterals([
                    "s", 
                    "t", 
                    "p", 
                    "q"
                ], pSTPQSuffix);
                var pFloat = Effect.getSystemType("float");
                var pInt = Effect.getSystemType("int");
                var pBool = Effect.getSystemType("bool");
                var pFloat2 = this.generateSystemType("float2", "vec2", 0, true, pFloat, 2);
                var pFloat3 = this.generateSystemType("float3", "vec3", 0, true, pFloat, 3);
                var pFloat4 = this.generateSystemType("float4", "vec3", 0, true, pFloat, 4);
                var pInt2 = this.generateSystemType("int2", "ivec2", 0, true, pInt, 2);
                var pInt3 = this.generateSystemType("int3", "ivec3", 0, true, pInt, 3);
                var pInt4 = this.generateSystemType("int4", "ivec3", 0, true, pInt, 4);
                var pBool2 = this.generateSystemType("bool2", "bvec2", 0, true, pBool, 2);
                var pBool3 = this.generateSystemType("bool3", "bvec3", 0, true, pBool, 3);
                var pBool4 = this.generateSystemType("bool4", "bvec3", 0, true, pBool, 4);
                this.addFieldsToVectorFromSuffixObject(pXYSuffix, pFloat2, "float");
                this.addFieldsToVectorFromSuffixObject(pRGSuffix, pFloat2, "float");
                this.addFieldsToVectorFromSuffixObject(pSTSuffix, pFloat2, "float");
                this.addFieldsToVectorFromSuffixObject(pXYZSuffix, pFloat3, "float");
                this.addFieldsToVectorFromSuffixObject(pRGBSuffix, pFloat3, "float");
                this.addFieldsToVectorFromSuffixObject(pSTPSuffix, pFloat3, "float");
                this.addFieldsToVectorFromSuffixObject(pXYZWSuffix, pFloat4, "float");
                this.addFieldsToVectorFromSuffixObject(pRGBASuffix, pFloat4, "float");
                this.addFieldsToVectorFromSuffixObject(pSTPQSuffix, pFloat4, "float");
                this.addFieldsToVectorFromSuffixObject(pXYSuffix, pInt2, "int");
                this.addFieldsToVectorFromSuffixObject(pRGSuffix, pInt2, "int");
                this.addFieldsToVectorFromSuffixObject(pSTSuffix, pInt2, "int");
                this.addFieldsToVectorFromSuffixObject(pXYZSuffix, pInt3, "int");
                this.addFieldsToVectorFromSuffixObject(pRGBSuffix, pInt3, "int");
                this.addFieldsToVectorFromSuffixObject(pSTPSuffix, pInt3, "int");
                this.addFieldsToVectorFromSuffixObject(pXYZWSuffix, pInt4, "int");
                this.addFieldsToVectorFromSuffixObject(pRGBASuffix, pInt4, "int");
                this.addFieldsToVectorFromSuffixObject(pSTPQSuffix, pInt4, "int");
                this.addFieldsToVectorFromSuffixObject(pXYSuffix, pBool2, "bool");
                this.addFieldsToVectorFromSuffixObject(pRGSuffix, pBool2, "bool");
                this.addFieldsToVectorFromSuffixObject(pSTSuffix, pBool2, "bool");
                this.addFieldsToVectorFromSuffixObject(pXYZSuffix, pBool3, "bool");
                this.addFieldsToVectorFromSuffixObject(pRGBSuffix, pBool3, "bool");
                this.addFieldsToVectorFromSuffixObject(pSTPSuffix, pBool3, "bool");
                this.addFieldsToVectorFromSuffixObject(pXYZWSuffix, pBool4, "bool");
                this.addFieldsToVectorFromSuffixObject(pRGBASuffix, pBool4, "bool");
                this.addFieldsToVectorFromSuffixObject(pSTPQSuffix, pBool4, "bool");
            };
            Effect.prototype.addSystemTypeMatrix = function /** @no-inline */() {
                var pFloat2 = Effect.getSystemType("float2");
                var pFloat3 = Effect.getSystemType("float3");
                var pFloat4 = Effect.getSystemType("float4");
                var pInt2 = Effect.getSystemType("int2");
                var pInt3 = Effect.getSystemType("int3");
                var pInt4 = Effect.getSystemType("int4");
                var pBool2 = Effect.getSystemType("bool2");
                var pBool3 = Effect.getSystemType("bool3");
                var pBool4 = Effect.getSystemType("bool4");
                this.generateSystemType("float2x2", "mat2", 0, true, pFloat2, 2);
                this.generateSystemType("float2x3", "mat2x3", 0, true, pFloat2, 3);
                this.generateSystemType("float2x4", "mat2x4", 0, true, pFloat2, 4);
                this.generateSystemType("float3x2", "mat3x2", 0, true, pFloat3, 2);
                this.generateSystemType("float3x3", "mat3", 0, true, pFloat3, 3);
                this.generateSystemType("float3x4", "mat3x4", 0, true, pFloat3, 4);
                this.generateSystemType("float4x2", "mat4x2", 0, true, pFloat4, 2);
                this.generateSystemType("float4x3", "mat4x3", 0, true, pFloat4, 3);
                this.generateSystemType("float4x4", "mat4", 0, true, pFloat4, 4);
                this.generateSystemType("int2x2", "imat2", 0, true, pInt2, 2);
                this.generateSystemType("int2x3", "imat2x3", 0, true, pInt2, 3);
                this.generateSystemType("int2x4", "imat2x4", 0, true, pInt2, 4);
                this.generateSystemType("int3x2", "imat3x2", 0, true, pInt3, 2);
                this.generateSystemType("int3x3", "imat3", 0, true, pInt3, 3);
                this.generateSystemType("int3x4", "imat3x4", 0, true, pInt3, 4);
                this.generateSystemType("int4x2", "imat4x2", 0, true, pInt4, 2);
                this.generateSystemType("int4x3", "imat4x3", 0, true, pInt4, 3);
                this.generateSystemType("int4x4", "imat4", 0, true, pInt4, 4);
                this.generateSystemType("bool2x2", "bmat2", 0, true, pBool2, 2);
                this.generateSystemType("bool2x3", "bmat2x3", 0, true, pBool2, 3);
                this.generateSystemType("bool2x4", "bmat2x4", 0, true, pBool2, 4);
                this.generateSystemType("bool3x2", "bmat3x2", 0, true, pBool3, 2);
                this.generateSystemType("bool3x3", "bmat3", 0, true, pBool3, 3);
                this.generateSystemType("bool3x4", "bmat3x4", 0, true, pBool3, 4);
                this.generateSystemType("bool4x2", "bmat4x2", 0, true, pBool4, 2);
                this.generateSystemType("bool4x3", "bmat4x3", 0, true, pBool4, 3);
                this.generateSystemType("bool4x4", "bmat4", 0, true, pBool4, 4);
            };
            Effect.prototype.addFieldsToVectorFromSuffixObject = function /** @no-inline */(pSuffixMap, pType, sBaseType) {
                var sSuffix = null;
                for(sSuffix in pSuffixMap) {
                    var sFieldTypeName = sBaseType + ((sSuffix.length > 1) ? sSuffix.length.toString() : "");
                    var pFieldType = Effect.getSystemType(sFieldTypeName);
                    (pType).addField(sSuffix, pFieldType, pSuffixMap[sSuffix]);
                }
            };
            Effect.prototype.getVariable = function /** @inline */(sName) {
                return Effect.getSystemVariable(sName) || this._pEffectScope.getVariable(sName);
            };
            Effect.prototype.getType = function /** @no-inline */(sTypeName) {
                return Effect.getSystemType(sTypeName) || this._pEffectScope.getType(sTypeName);
            };
            Effect.prototype.isSystemFunction = function /** @no-inline */(pFunction) {
                return false;
            };
            Effect.prototype.isSystemVariable = function /** @no-inline */(pVariable) {
                return false;
            };
            Effect.prototype.isSystemType = function /** @no-inline */(pType) {
                return false;
            };
            Effect.prototype._errorFromInstruction = function /** @inline */(pError) {
                this._error(pError.code, pError.info);
            };
            Effect.prototype._error = function /** @no-inline */(eCode, pInfo) {
                if (typeof pInfo === "undefined") { pInfo = {
                }; }
                var sFileName = this._sAnalyzedFileName;
                var pLocation = {
                    file: this._sAnalyzedFileName,
                    line: 0
                };
                var pLineColumn = this.getNodeSourceLocation(this.getAnalyzedNode());
                switch(eCode) {
                    case 2202:
                    case 2201:
                    case 2203:
                        pInfo.line = pLineColumn.line;
                        pInfo.column = pLineColumn.column;
                        pLocation.line = pLocation.line;
                        break;
                }
                var pLogEntity = {
                    code: eCode,
                    info: pInfo,
                    location: pLocation
                };
                akra.logger["error"](pLogEntity);
                throw new Error(eCode.toString());
            };
            Effect.prototype.setAnalyzedNode = function /** @inline */(pNode) {
                this._pAnalyzedNode = pNode;
            };
            Effect.prototype.getAnalyzedNode = function /** @inline */() {
                return this._pAnalyzedNode;
            };
            Effect.prototype.isStrictMode = function /** @inline */() {
                return this._pEffectScope.isStrictMode();
            };
            Effect.prototype.setStrictModeOn = function /** @inline */() {
                return this._pEffectScope.setStrictModeOn();
            };
            Effect.prototype.newScope = function /** @inline */(eScopeType) {
                if (typeof eScopeType === "undefined") { eScopeType = 0 /* k_Default */ ; }
                this._pEffectScope.newScope(eScopeType);
            };
            Effect.prototype.resumeScope = function /** @inline */() {
                this._pEffectScope.resumeScope();
            };
            Effect.prototype.getScope = function /** @inline */() {
                return this._pEffectScope.getScope();
            };
            Effect.prototype.setScope = function /** @inline */(iScope) {
                this._pEffectScope.setScope(iScope);
            };
            Effect.prototype.endScope = function /** @inline */() {
                this._pEffectScope.endScope();
            };
            Effect.prototype.getScopeType = function /** @inline */() {
                return this._pEffectScope.getScopeType();
            };
            Effect.prototype.setCurrentAnalyzedFunction = function /** @inline */(pFunction) {
                this._pCurrentFunction = pFunction;
            };
            Effect.prototype.getCurrentAnalyzedFunction = function /** @inline */() {
                return this._pCurrentFunction;
            };
            Effect.prototype.setOperator = // private inline newInstruction(pInstruction: IAFXInstruction): void {
            // 	pInstruction.setParent(this._pCurrentInstruction);
            // 	this._pCurrentInstruction = pInstruction;
            // }
            // private inline endInstruction(): void {
            // 	this._pCurrentInstruction = this._pCurrentInstruction.getParent();
            // }
            // private inline pushCommand(pInstruction: IAFXInstruction, isSetParent?: bool = false): void {
            // 	if(!isNull(this._pCurrentInstruction)){
            // 		this._pCurrentInstruction.push(pInstruction, isSetParent);
            // 	}
            // }
            // private inline pushAndSet(pInstruction: IAFXInstruction): void {
            // 	if(!isNull(this._pCurrentInstruction)){
            // 		this._pCurrentInstruction.push(pInstruction, true);
            // 	}
            // 	this.newInstruction(pInstruction);
            // }
            function /** @inline */(sOperator) {
                if(!akra.isNull(this._pCurrentInstruction)) {
                    this._pCurrentInstruction.setOperator(sOperator);
                }
            };
            Effect.prototype.findFunction = function /** @no-inline */(sFunctionName, pArguments) {
                return Effect.findSystemFunction(sFunctionName, pArguments) || this._pEffectScope.getFunction(sFunctionName, pArguments);
            };
            Effect.prototype.findConstructor = function /** @no-inline */(pType, pArguments) {
                var pVariableType = new fx.VariableTypeInstruction();
                pVariableType.pushInVariableType(pType);
                return pVariableType;
            };
            Effect.prototype.findShaderFunction = function /** @no-inline */(sFunctionName, pArguments) {
                return this._pEffectScope.getShaderFunction(sFunctionName, pArguments);
            };
            Effect.prototype.findFunctionByDef = function /** @no-inline */(pDef) {
                return this.findFunction(pDef.getName(), pDef.getArguments());
            };
            Effect.prototype.addVariableDecl = // private addVariable(pVariable: IAFXVariable): void {
            // }
            function /** @no-inline */(pVariable) {
                if(this.isSystemVariable(pVariable)) {
                    this._error(2235, {
                        varName: pVariable.getName()
                    });
                }
                var isVarAdded = this._pEffectScope.addVariable(pVariable);
                if(!isVarAdded) {
                    var eScopeType = this.getScopeType();
                    switch(eScopeType) {
                        case 0 /* k_Default */ :
                            this._error(2234, {
                                varName: pVariable.getName()
                            });
                            break;
                        case 1 /* k_Struct */ :
                            this._error(2242, {
                                fieldName: pVariable.getName()
                            });
                            break;
                        case 2 /* k_Annotation */ :
                            this._error(2244, {
                                varName: pVariable.getName()
                            });
                            break;
                    }
                }
                if(pVariable.getName() === "Out" && !akra.isNull(this.getCurrentAnalyzedFunction())) {
                    var isOk = this.getCurrentAnalyzedFunction()._addOutVariable(pVariable);
                    if(!isOk) {
                        this._error(2266);
                    }
                }
            };
            Effect.prototype.addTypeDecl = function /** @no-inline */(pType) {
                if(this.isSystemType(pType)) {
                    this._error(2201, {
                        typeName: pType.getName()
                    });
                }
                var isTypeAdded = this._pEffectScope.addType(pType);
                if(!isTypeAdded) {
                    this._error(2202, {
                        typeName: pType.getName()
                    });
                }
            };
            Effect.prototype.addFunctionDecl = function /** @no-inline */(pFunction) {
                if(this.isSystemFunction(pFunction)) {
                    this._error(2237, {
                        funcName: pFunction.getName()
                    });
                }
                var isFunctionAdded = this._pEffectScope.addFunction(pFunction);
                if(!isFunctionAdded) {
                    this._error(2236, {
                        funcName: pFunction.getName()
                    });
                }
            };
            Effect.prototype.addTechnique = function /** @no-inline */(pTechnique) {
                var sName = pTechnique.getName();
                if(akra.isDef(this._pTechniqueMap[sName])) {
                    this._error(2252, {
                        techName: sName
                    });
                    return;
                }
                this._pTechniqueMap[sName] = pTechnique;
                this._pTechniqueList.push(pTechnique);
            };
            Effect.prototype.analyzeGlobalUseDecls = function /** @no-inline */() {
                var pChildren = this._pParseTree.root.children;
                var i = 0;
                for(i = pChildren.length - 1; i >= 0; i--) {
                    if(pChildren[i].name === "UseDecl") {
                        this.analyzeUseDecl(pChildren[i]);
                    }
                }
            };
            Effect.prototype.analyzeGlobalTypeDecls = function /** @no-inline */() {
                var pChildren = this._pParseTree.root.children;
                var i = 0;
                for(i = pChildren.length - 1; i >= 0; i--) {
                    if(pChildren[i].name === "TypeDecl") {
                        this.analyzeTypeDecl(pChildren[i]);
                    }
                }
            };
            Effect.prototype.analyzeFunctionDefinitions = function /** @no-inline */() {
                var pChildren = this._pParseTree.root.children;
                var i = 0;
                for(i = pChildren.length - 1; i >= 0; i--) {
                    if(pChildren[i].name === "FunctionDecl") {
                        this.analyzeFunctionDeclOnlyDefinition(pChildren[i]);
                    }
                }
            };
            Effect.prototype.analyzeGlobalImports = function /** @no-inline */() {
                var pChildren = this._pParseTree.root.children;
                var i = 0;
                for(i = pChildren.length - 1; i >= 0; i--) {
                    if(pChildren[i].name === "ImportDecl") {
                        this.analyzeImportDecl(pChildren[i]);
                    }
                }
            };
            Effect.prototype.analyzeTechniqueImports = function /** @no-inline */() {
                var pChildren = this._pParseTree.root.children;
                var i = 0;
                for(i = pChildren.length - 1; i >= 0; i--) {
                    if(pChildren[i].name === "TechniqueDecl") {
                        this.analyzeTechniqueForImport(pChildren[i]);
                    }
                }
            };
            Effect.prototype.analyzeVariableDecls = function /** @no-inline */() {
                var pChildren = this._pParseTree.root.children;
                var i = 0;
                for(i = pChildren.length - 1; i >= 0; i--) {
                    if(pChildren[i].name === "VariableDecl") {
                        this.analyzeVariableDecl(pChildren[i]);
                    } else if(pChildren[i].name === "VarStructDecl") {
                        this.analyzeVarStructDecl(pChildren[i]);
                    }
                }
            };
            Effect.prototype.analyzeFunctionDecls = function /** @no-inline */() {
                for(var i = 0; i < this._pFunctionWithImplementationList.length; i++) {
                    this.resumeFunctionAnalysis(this._pFunctionWithImplementationList[i]);
                }
                this.checkFunctionsForRecursion();
                this.checkFunctionForCorrectUsage();
                this.generateShadersFromFunctions();
            };
            Effect.prototype.analyzeTechniques = function /** @no-inline */() {
                for(var i = 0; i < this._pTechniqueList.length; i++) {
                    this.resumeTechniqueAnalysis(this._pTechniqueList[i]);
                }
            };
            Effect.prototype.checkFunctionsForRecursion = function /** @no-inline */() {
                var pFunctionList = this._pFunctionWithImplementationList;
                var isNewAdd = true;
                var isNewDelete = true;
                while(isNewAdd || isNewDelete) {
                    isNewAdd = false;
                    isNewDelete = false;
                    mainFor:
for(var i = 0; i < pFunctionList.length; i++) {
                        var pTestedFunction = pFunctionList[i];
                        var pUsedFunctionList = pTestedFunction._getUsedFunctionList();
                        if(!pTestedFunction._isUsed()) {
                            //WARNING("Unused function '" + pTestedFunction._getStringDef() + "'.");
                            continue mainFor;
                        }
                        if(pTestedFunction._isBlackListFunction()) {
                            continue mainFor;
                        }
                        if(akra.isNull(pUsedFunctionList)) {
                            continue mainFor;
                        }
                        for(var j = 0; j < pUsedFunctionList.length; j++) {
                            var pAddedUsedFunctionList = pUsedFunctionList[j]._getUsedFunctionList();
                            if(akra.isNull(pAddedUsedFunctionList)) {
                                continue mainFor;
                            }
                            for(var k = 0; k < pAddedUsedFunctionList.length; k++) {
                                var pAddedFunction = pAddedUsedFunctionList[k];
                                if(pTestedFunction === pAddedFunction) {
                                    pTestedFunction._addToBlackList();
                                    isNewDelete = true;
                                    this._error(2255, {
                                        funcDef: pTestedFunction._getStringDef()
                                    });
                                    continue mainFor;
                                }
                                if(pAddedFunction._isBlackListFunction() || !pAddedFunction._canUsedAsFunction()) {
                                    pTestedFunction._addToBlackList();
                                    this._error(2256, {
                                        funcDef: pTestedFunction._getStringDef()
                                    });
                                    isNewDelete = true;
                                    continue mainFor;
                                }
                                if(pTestedFunction._addUsedFunction(pAddedFunction)) {
                                    isNewAdd = true;
                                }
                            }
                        }
                    }
                }
            };
            Effect.prototype.checkFunctionForCorrectUsage = function /** @no-inline */() {
                var pFunctionList = this._pFunctionWithImplementationList;
                var isNewUsageSet = true;
                var isNewDelete = true;
                while(isNewUsageSet || isNewDelete) {
                    isNewUsageSet = false;
                    isNewDelete = false;
                    mainFor:
for(var i = 0; i < pFunctionList.length; i++) {
                        var pTestedFunction = pFunctionList[i];
                        var pUsedFunctionList = pTestedFunction._getUsedFunctionList();
                        if(!pTestedFunction._isUsed()) {
                            //WARNING("Unused function '" + pTestedFunction._getStringDef() + "'.");
                            continue mainFor;
                        }
                        if(pTestedFunction._isBlackListFunction()) {
                            continue mainFor;
                        }
                        if(!pTestedFunction._checkVertexUsage()) {
                            this._error(2257, {
                                funcDef: pTestedFunction._getStringDef()
                            });
                            pTestedFunction._addToBlackList();
                            isNewDelete = true;
                            continue mainFor;
                        }
                        if(!pTestedFunction._checkPixelUsage()) {
                            this._error(2258, {
                                funcDef: pTestedFunction._getStringDef()
                            });
                            pTestedFunction._addToBlackList();
                            isNewDelete = true;
                            continue mainFor;
                        }
                        if(akra.isNull(pUsedFunctionList)) {
                            continue mainFor;
                        }
                        for(var j = 0; j < pUsedFunctionList.length; j++) {
                            var pUsedFunction = pUsedFunctionList[j];
                            if(pTestedFunction._isUsedInVertex()) {
                                if(!pUsedFunction._isForVertex()) {
                                    this._error(2257, {
                                        funcDef: pTestedFunction._getStringDef()
                                    });
                                    pTestedFunction._addToBlackList();
                                    isNewDelete = true;
                                    continue mainFor;
                                }
                                if(!pUsedFunction._isUsedInVertex()) {
                                    pUsedFunction._usedInVertex();
                                    isNewUsageSet = true;
                                }
                            }
                            if(pTestedFunction._isUsedInPixel()) {
                                if(!pUsedFunction._isForPixel()) {
                                    this._error(2258, {
                                        funcDef: pTestedFunction._getStringDef()
                                    });
                                    pTestedFunction._addToBlackList();
                                    isNewDelete = true;
                                    continue mainFor;
                                }
                                if(!pUsedFunction._isUsedInPixel()) {
                                    pUsedFunction._usedInPixel();
                                    isNewUsageSet = true;
                                }
                            }
                        }
                    }
                }
            };
            Effect.prototype.generateShadersFromFunctions = function /** @no-inline */() {
                var pFunctionList = this._pFunctionWithImplementationList;
            };
            Effect.prototype.analyzeVariableDecl = // private addType(pType: IAFXType): void {
            // 	if(this.isSystemType(pType)){
            // 		this._error(EFFECT_REDEFINE_SYSTEM_TYPE, {typeName: pType.getName()});
            // 	}
            // 	var isTypeAdded: bool = this._pEffectScope.addType(pType);
            // 	if(!isTypeAdded){
            // 		this._error(EFFECT_REDEFINE_TYPE, {typeName: pType.getName()});
            // 	}
            // }
            // private addTypeDecl(pType: IAFXType): void {
            // 	//check
            // 	this.addType(pType);
            // }
            // private analyzeDecls(): void {
            // 	var pChildren: IParseNode[] = this._pParseTree.root.children;
            // 	var i: uint;
            // 	for(i = pChildren.length - 1; i >=0; i--){
            // 		this.analyzeDecl(pChildren[i]);
            // 	}
            // }
            // private analyzeDecl(pNode: IParseNode): void {
            // 	switch (pNode.name) {
            //         case "VariableDecl":
            //             this.analyzeVariableDecl(pNode, null);
            //             break;
            //         case "TypeDecl":
            //             this.analyzeTypeDecl(pNode);
            //             break;
            //         case "FunctionDecl":
            //             this.analyzeFunctionDecl(pNode);
            //             break;
            //         case "VarStructDecl":
            //             this.analyzeVarStructDecl(pNode);
            //     	    break;
            //         case "TechniqueDecl":
            //             this.analyzeTechniqueDecl(pNode);
            //             break;
            //         case "UseDecl":
            //             this.analyzeUseDecl(pNode);
            //             break;
            //         case "ProvideDecl":
            //             this.analyzeProvideDecl(pNode);
            //             break;
            //         case "ImportDecl":
            //             this.analyzeImportDecl(pNode);
            //             break;
            //     }
            // }
            function /** @no-inline */(pNode, pInstruction) {
                if (typeof pInstruction === "undefined") { pInstruction = null; }
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pUsageType;
                var pVariable;
                var i = 0;
                pUsageType = this.analyzeUsageType(pChildren[pChildren.length - 1]);
                for(i = pChildren.length - 2; i >= 1; i--) {
                    if(pChildren[i].name === "Variable") {
                        pVariable = this.analyzeVariable(pChildren[i], pUsageType);
                        if(!akra.isNull(pInstruction)) {
                            pInstruction.push(pVariable, true);
                        }
                    }
                }
            };
            Effect.prototype.analyzeUsageType = function /** @no-inline */(pNode) {
                var pChildren = pNode.children;
                var i = 0;
                var pType = new fx.UsageTypeInstruction();
                for(i = pChildren.length - 1; i >= 0; i--) {
                    if(pChildren[i].name === "Type") {
                        var pMainType = this.analyzeType(pChildren[i]);
                        pType.setTypeInstruction(pMainType);
                    } else if(pChildren[i].name === "Usage") {
                        var sUsage = this.analyzeUsage(pChildren[i]);
                        pType.addUsage(sUsage);
                    }
                }
                if(!pType.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pType.getLastError());
                }
                ;
                return pType;
            };
            Effect.prototype.analyzeType = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pType = null;
                switch(pNode.name) {
                    case "T_TYPE_ID":
                        pType = this.getType(pNode.value);
                        if(akra.isNull(pType)) {
                            this._error(2250, {
                                typeName: pNode.value
                            });
                        }
                        break;
                    case "Struct":
                        pType = this.analyzeStruct(pNode);
                        break;
                    case "T_KW_VOID":
                        pType = Effect.getSystemType("void");
                        break;
                    case "ScalarType":
                    case "ObjectType":
                        pType = this.getType(pChildren[pChildren.length - 1].value);
                        if(akra.isNull(pType)) {
                            this._error(2250, {
                                typeName: pChildren[pChildren.length - 1].value
                            });
                        }
                        break;
                    case "VectorType":
                    case "MatrixType":
                        this._error(2251);
                        break;
                    case "BaseType":
                    case "Type":
                        return this.analyzeType(pChildren[0]);
                }
                return pType;
            };
            Effect.prototype.analyzeUsage = function /** @no-inline */(pNode) {
                pNode = pNode.children[0];
                return pNode.value;
            };
            Effect.prototype.analyzeVariable = function /** @no-inline */(pNode, pUsageType) {
                var pChildren = pNode.children;
                var pVarDecl = new fx.VariableDeclInstruction();
                var pVariableType = new fx.VariableTypeInstruction();
                var pAnnotation;
                var sSemantic;
                var pInitExpr;
                pVarDecl.push(pVariableType, true);
                pVariableType.push(pUsageType, true);
                this.analyzeVariableDim(pChildren[pChildren.length - 1], pVarDecl);
                var i = 0;
                for(i = pChildren.length - 2; i >= 0; i--) {
                    if(pChildren[i].name === "Annotation") {
                        pAnnotation = this.analyzeAnnotation(pChildren[i]);
                        pVarDecl.setAnnotation(pAnnotation);
                    } else if(pChildren[i].name === "Semantic") {
                        sSemantic = this.analyzeSemantic(pChildren[i]);
                        pVarDecl.setSemantic(sSemantic);
                    } else if(pChildren[i].name === "Initializer") {
                        pInitExpr = this.analyzeInitializer(pChildren[i]);
                        pVarDecl.push(pInitExpr, true);
                    }
                }
                if(!pVarDecl.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pVarDecl.getLastError());
                }
                ;
                this.addVariableDecl(pVarDecl);
                //TODO: Here must be additing to scope
                // this.addVariableDecl(pVarDecl);
                // var pVariable: IAFXVariable = new Variable();
                // pVariable.initializeFromInstruction(pVarDecl);
                // this.addVariableDecl(pVariable);
                return pVarDecl;
            };
            Effect.prototype.analyzeVariableDim = function /** @no-inline */(pNode, pVariableDecl) {
                var pChildren = pNode.children;
                var pVariableType = pVariableDecl.getType();
                if(pChildren.length === 1) {
                    var pName = new fx.IdInstruction();
                    pName.setName(pChildren[0].value);
                    pVariableDecl.push(pName, true);
                    return;
                }
                if(pChildren.length === 3) {
                    pVariableType.addPointIndex();
                } else if(pChildren.length === 4 && pChildren[0].name === "FromExpr") {
                    var pBuffer = this.analyzeFromExpr(pChildren[0]);
                    pVariableType.setVideoBuffer(pBuffer);
                } else {
                    if(pVariableType.isPointer()) {
                        //TODO: add support for v[][10]
                        this._error(2300);
                    }
                    var pIndexExpr = this.analyzeExpr(pChildren[pChildren.length - 3]);
                    pVariableType.addArrayIndex(pIndexExpr);
                }
                this.analyzeVariableDim(pChildren[pChildren.length - 1], pVariableDecl);
            };
            Effect.prototype.analyzeAnnotation = function /** @no-inline */(pNode) {
                return null;
            };
            Effect.prototype.analyzeSemantic = function /** @no-inline */(pNode) {
                var sSemantic = pNode.children[0].value;
                // var pDecl: IAFXDeclInstruction = <IAFXDeclInstruction>this._pCurrentInstruction;
                // pDecl.setSemantic(sSemantic);
                return sSemantic;
            };
            Effect.prototype.analyzeInitializer = function /** @no-inline */(pNode) {
                return null;
            };
            Effect.prototype.analyzeFromExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pBuffer = null;
                if(pChildren[1].name === "T_NON_TYPE_ID") {
                    pBuffer = this.getVariable(pChildren[1].value);
                } else {
                    pBuffer = (this.analyzeMemExpr(pChildren[1])).getBuffer();
                }
                return pBuffer;
            };
            Effect.prototype.analyzeExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var sName = pNode.name;
                switch(sName) {
                    case "ObjectExpr":
                        return this.analyzeObjectExpr(pNode);
                    case "ComplexExpr":
                        return this.analyzeComplexExpr(pNode);
                    case "PrimaryExpr":
                        return this.analyzePrimaryExpr(pNode);
                    case "PostfixExpr":
                        return this.analyzePostfixExpr(pNode);
                    case "UnaryExpr":
                        return this.analyzeUnaryExpr(pNode);
                    case "CastExpr":
                        return this.analyzeCastExpr(pNode);
                    case "ConditionalExpr":
                        return this.analyzeConditionalExpr(pNode);
                    case "MulExpr":
                    case "AddExpr":
                        return this.analyzeArithmeticExpr(pNode);
                    case "RelationalExpr":
                    case "EqualityExpr":
                        return this.analyzeRelationExpr(pNode);
                    case "AndExpr":
                    case "OrExpr":
                        return this.analyzeLogicalExpr(pNode);
                    case "AssignmentExpr":
                        return this.analyzeAssignmentExpr(pNode);
                    case "T_NON_TYPE_ID":
                        return this.analyzeIdExpr(pNode);
                    case "T_STRING":
                    case "T_UINT":
                    case "T_FLOAT":
                    case "T_KW_TRUE":
                    case "T_KW_FALSE":
                        return this.analyzeSimpleExpr(pNode);
                    case "MemExpr":
                        return this.analyzeMemExpr(pNode);
                    default:
                        this._error(2204, {
                            exprName: sName
                        });
                        break;
                }
                return null;
            };
            Effect.prototype.analyzeObjectExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var sName = pNode.children[pNode.children.length - 1].value;
                switch(sName) {
                    case "T_KW_COMPILE":
                        return this.analyzeCompileExpr(pNode);
                    case "T_KW_SAMPLER_STATE":
                        return this.analyzeSamplerStateBlock(pNode);
                }
            };
            Effect.prototype.analyzeCompileExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pExpr = new fx.CompileExprInstruction();
                var pExprType;
                var pArguments = null;
                var sShaderFuncName = pChildren[pChildren.length - 2].value;
                var pShaderFunc = null;
                var i = 0;
                if(pChildren.length > 3) {
                    var pArgumentExpr;
                    pArguments = [];
                    for(i = pChildren.length - 3; i > 0; i--) {
                        if(pChildren[i].value !== ",") {
                            pArgumentExpr = this.analyzeExpr(pChildren[i]);
                            pArguments.push(pArgumentExpr);
                        }
                    }
                }
                pShaderFunc = this.findShaderFunction(sShaderFuncName, pArguments);
                if(akra.isNull(pShaderFunc)) {
                    this._error(2226, {
                        funcName: sShaderFuncName
                    });
                    return null;
                }
                pExprType = (pShaderFunc.getType()).wrap();
                pExpr.setType(pExprType);
                pExpr.setOperator("complile");
                pExpr.push(pShaderFunc.getNameId(), false);
                if(!akra.isNull(pArguments)) {
                    for(i = 0; i < pArguments.length; i++) {
                        pExpr.push(pArguments[i], true);
                    }
                }
                if(!pExpr.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pExpr.getLastError());
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeSamplerStateBlock = function /** @no-inline */(pNode) {
                pNode = pNode.children[0];
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pExpr = new fx.SamplerStateBlockInstruction();
                var pSamplerState;
                var i = 0;
                pExpr.setOperator("sample_state");
                for(i = pChildren.length - 2; i >= 1; i--) {
                    pSamplerState = this.analyzeSamplerState(pChildren[i]);
                    pExpr.push(pSamplerState);
                }
                if(!pExpr.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pExpr.getLastError());
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeSamplerState = function /** @no-inline */(pNode) {
                return null;
            };
            Effect.prototype.analyzeComplexExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var sFirstNodeName = pChildren[pChildren.length - 1].name;
                switch(sFirstNodeName) {
                    case "T_NON_TYPE_ID":
                        return this.analyzeFunctionCallExpr(pNode);
                    case "BaseType":
                    case "T_TYPE_ID":
                        return this.analyzeConstructorCallExpr(pNode);
                    default:
                        return this.analyzeSimpleComplexExpr(pNode);
                }
            };
            Effect.prototype.analyzeFunctionCallExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pExpr = null;
                var pExprType = null;
                var pArguments = null;
                var sFuncName = pChildren[pChildren.length - 1].value;
                var pFunction = null;
                var pFunctionId = null;
                var i = 0;
                if(pChildren.length > 3) {
                    var pArgumentExpr;
                    pArguments = [];
                    for(i = pChildren.length - 3; i > 0; i--) {
                        if(pChildren[i].value !== ",") {
                            pArgumentExpr = this.analyzeExpr(pChildren[i]);
                            pArguments.push(pArgumentExpr);
                        }
                    }
                }
                pFunction = this.findFunction(sFuncName, pArguments);
                if(akra.isNull(pFunction)) {
                    this._error(2223, {
                        funcName: sFuncName
                    });
                    return null;
                }
                if(!akra.isDef(pFunction)) {
                    this._error(2246, {
                        funcName: sFuncName
                    });
                    return null;
                }
                if(!akra.isNull(this.getCurrentAnalyzedFunction())) {
                    if(!pFunction._isForPixel()) {
                        this.getCurrentAnalyzedFunction()._setForPixel(false);
                    }
                    if(!pFunction._isForVertex()) {
                        this.getCurrentAnalyzedFunction()._setForVertex(false);
                    }
                }
                if(pFunction._getInstructionType() === 41 /* k_FunctionDeclInstruction */ ) {
                    var pFunctionCallExpr = new fx.FunctionCallInstruction();
                    pFunctionId = new fx.IdExprInstruction();
                    pFunctionId.push(pFunction.getNameId(), false);
                    pExprType = (pFunction.getType()).wrap();
                    pFunctionCallExpr.setType(pExprType);
                    pFunctionCallExpr.push(pFunctionId, true);
                    if(!akra.isNull(pArguments)) {
                        for(i = 0; i < pArguments.length; i++) {
                            pFunctionCallExpr.push(pArguments[i], true);
                        }
                        var pFunctionArguments = (pFunction).getArguments();
                        for(i = pArguments.length; i < pFunctionArguments.length; i++) {
                            pFunctionCallExpr.push(pFunctionArguments[i].getInitializeExpr(), false);
                        }
                    }
                    if(!akra.isNull(this.getCurrentAnalyzedFunction())) {
                        this.getCurrentAnalyzedFunction()._addUsedFunction(pFunction);
                    }
                    pFunction._usedAs(NaN /* k_Function */ );
                    pExpr = pFunctionCallExpr;
                } else {
                    var pSystemCallExpr = new fx.SystemCallInstruction();
                    pSystemCallExpr.setSystemCallFunction(pFunction);
                    pSystemCallExpr.fillByArguments(pArguments);
                    pExpr = pSystemCallExpr;
                }
                if(!pExpr.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pExpr.getLastError());
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeConstructorCallExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pExpr = new fx.ConstructorCallInstruction();
                var pExprType;
                var pArguments = null;
                var pConstructorType;
                var i = 0;
                pConstructorType = this.analyzeType(pChildren[pChildren.length - 1]);
                if(akra.isNull(pConstructorType)) {
                    this._error(2224);
                    return null;
                }
                if(pChildren.length > 3) {
                    var pArgumentExpr;
                    pArguments = [];
                    for(i = pChildren.length - 3; i > 0; i--) {
                        if(pChildren[i].value !== ",") {
                            pArgumentExpr = this.analyzeExpr(pChildren[i]);
                            pArguments.push(pArgumentExpr);
                        }
                    }
                }
                pExprType = this.findConstructor(pConstructorType, pArguments);
                if(akra.isNull(pExprType)) {
                    this._error(2225, {
                        typeName: pConstructorType.toString()
                    });
                    return null;
                }
                pExpr.setType(pExprType);
                pExpr.push(pConstructorType, false);
                if(!akra.isNull(pArguments)) {
                    for(i = 0; i < pArguments.length; i++) {
                        pExpr.push(pArguments[i], true);
                    }
                }
                if(!pExpr.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pExpr.getLastError());
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeSimpleComplexExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pExpr = new fx.ComplexExprInstruction();
                var pComplexExpr;
                var pExprType;
                pComplexExpr = this.analyzeExpr(pChildren[1]);
                pExprType = pComplexExpr.getType();
                pExpr.setType(pExprType);
                pExpr.push(pComplexExpr, true);
                if(!pExpr.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pExpr.getLastError());
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzePrimaryExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pExpr = new fx.PrimaryExprInstruction();
                var pPrimaryExpr;
                var pPointer = null;
                var pPrimaryExprType;
                pPrimaryExpr = this.analyzeExpr(pChildren[0]);
                pPrimaryExprType = pPrimaryExpr.getType();
                pPointer = pPrimaryExprType.getPointer();
                if(akra.isNull(pPointer)) {
                    this._error(2222, {
                        typeName: pPrimaryExprType.toString()
                    });
                    return null;
                }
                var pPointerVarType = pPrimaryExprType.getParent();
                if(!pPointerVarType.isStrictPointer()) {
                    this.getCurrentAnalyzedFunction()._setForPixel(false);
                    this.getCurrentAnalyzedFunction()._notCanUsedAsFunction();
                    pPointerVarType._setPointerToStrict();
                }
                pExpr.setType(pPointer.getType());
                pExpr.setOperator("@");
                pExpr.push(pPointer, false);
                if(!pExpr.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pExpr.getLastError());
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzePostfixExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var sSymbol = pChildren[pChildren.length - 2].value;
                switch(sSymbol) {
                    case "[":
                        return this.analyzePostfixIndex(pNode);
                    case ".":
                        return this.analyzePostfixPoint(pNode);
                    case "++":
                    case "--":
                        return this.analyzePostfixArithmetic(pNode);
                }
            };
            Effect.prototype.analyzePostfixIndex = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pExpr = new fx.PostfixIndexInstruction();
                var pPostfixExpr;
                var pIndexExpr;
                var pExprType;
                var pPostfixExprType;
                var pIndexExprType;
                var pIntType;
                pPostfixExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pPostfixExprType = pPostfixExpr.getType();
                if(!pPostfixExprType.isArray()) {
                    this._error(2217, {
                        typeName: pPostfixExprType.toString()
                    });
                    return null;
                }
                pIndexExpr = this.analyzeExpr(pChildren[pChildren.length - 3]);
                pIndexExprType = pIndexExpr.getType();
                pIntType = Effect.getSystemType("int");
                if(!pIndexExprType.isEqual(pIntType)) {
                    this._error(2218, {
                        typeName: pIndexExprType.toString()
                    });
                    return null;
                }
                pExprType = (pPostfixExprType.getArrayElementType());
                pExpr.setType(pExprType);
                pExpr.push(pPostfixExpr, true);
                pExpr.push(pIndexExpr, true);
                if(!pExpr.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pExpr.getLastError());
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzePostfixPoint = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pExpr = new fx.PostfixPointInstruction();
                var pPostfixExpr = null;
                var sFieldName = "";
                var pFieldNameExpr = null;
                var pExprType = null;
                var pPostfixExprType = null;
                pPostfixExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pPostfixExprType = pPostfixExpr.getType();
                sFieldName = pChildren[pChildren.length - 3].value;
                pFieldNameExpr = pPostfixExprType.getField(sFieldName);
                if(akra.isNull(pFieldNameExpr)) {
                    this._error(2219, {
                        typeName: pPostfixExprType.toString(),
                        fieldName: sFieldName
                    });
                    return null;
                }
                pExprType = pFieldNameExpr.getType();
                if(pChildren.length === 4) {
                    if(!pExprType.isPointer()) {
                        this._error(2220, {
                            typeName: pExprType.toString()
                        });
                        return null;
                    }
                    var pBuffer = this.analyzeFromExpr(pChildren[0]);
                    pExprType.setVideoBuffer(pBuffer);
                }
                pExpr.setType(pExprType);
                pExpr.push(pPostfixExpr, true);
                pExpr.push(pFieldNameExpr, true);
                if(!pExpr.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pExpr.getLastError());
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzePostfixArithmetic = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var sOperator = pChildren[0].value;
                var pExpr = new fx.PostfixArithmeticInstruction();
                var pPostfixExpr;
                var pExprType;
                var pPostfixExprType;
                pPostfixExpr = this.analyzeExpr(pChildren[1]);
                pPostfixExprType = pPostfixExpr.getType();
                pExprType = this.checkOneOperandExprType(sOperator, pPostfixExprType);
                if(akra.isNull(pExprType)) {
                    this._error(2221, {
                        operator: sOperator,
                        typeName: pPostfixExprType.toString()
                    });
                    return null;
                }
                pExpr.setType(pExprType);
                pExpr.setOperator(sOperator);
                pExpr.push(pPostfixExpr, true);
                if(!pExpr.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pExpr.getLastError());
                }
                ;
                return null;
            };
            Effect.prototype.analyzeUnaryExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var sOperator = pChildren[1].value;
                var pExpr = new fx.UnaryExprInstruction();
                var pUnaryExpr;
                var pExprType;
                var pUnaryExprType;
                pUnaryExpr = this.analyzeExpr(pChildren[0]);
                pUnaryExprType = pUnaryExpr.getType();
                pExprType = this.checkOneOperandExprType(sOperator, pUnaryExprType);
                if(akra.isNull(pExprType)) {
                    this._error(2216, {
                        operator: sOperator,
                        tyepName: pUnaryExprType.toString()
                    });
                    return null;
                }
                pExpr.setOperator(sOperator);
                pExpr.setType(pExprType);
                pExpr.push(pUnaryExpr, true);
                if(!pExpr.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pExpr.getLastError());
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeCastExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pExpr = new fx.CastExprInstruction();
                var pExprType;
                var pCastedExpr;
                pExprType = this.analyzeConstTypeDim(pChildren[2]);
                pCastedExpr = this.analyzeExpr(pChildren[0]);
                pExpr.setType(pExprType);
                pExpr.push(pExprType, true);
                pExpr.push(pCastedExpr, true);
                if(!pExpr.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pExpr.getLastError());
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeConditionalExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pExpr = new fx.ConditionalExprInstruction();
                var pConditionExpr;
                var pTrueExpr;
                var pFalseExpr;
                var pConditionType;
                var pTrueExprType;
                var pFalseExprType;
                var pExprType;
                var pBoolType;
                pConditionExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pTrueExpr = this.analyzeExpr(pChildren[pChildren.length - 3]);
                pFalseExpr = this.analyzeExpr(pChildren[0]);
                pConditionType = pConditionExpr.getType();
                pTrueExprType = pTrueExpr.getType();
                pFalseExprType = pFalseExpr.getType();
                pBoolType = Effect.getSystemType("bool");
                if(!pConditionType.isEqual(pBoolType)) {
                    this._error(2211, {
                        typeName: pConditionType.toString()
                    });
                    return null;
                }
                if(!pTrueExprType.isEqual(pFalseExprType)) {
                    this._error(2212, {
                        leftTypeName: pTrueExprType.toString(),
                        rightTypeName: pFalseExprType.toString()
                    });
                    return null;
                }
                pExpr.setType(pTrueExprType);
                pExpr.push(pConditionExpr, true);
                pExpr.push(pTrueExpr, true);
                pExpr.push(pFalseExpr, true);
                if(!pExpr.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pExpr.getLastError());
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeArithmeticExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var sOperator = pNode.children[1].value;
                var pExpr = new fx.ArithmeticExprInstruction();
                var pLeftExpr;
                var pRightExpr;
                var pLeftType;
                var pRightType;
                var pExprType;
                pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pRightExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pLeftType = pLeftExpr.getType();
                pRightType = pRightExpr.getType();
                pExprType = this.checkTwoOperandExprTypes(sOperator, pLeftType, pRightType);
                if(akra.isNull(pExprType)) {
                    this._error(2206, {
                        operator: sOperator,
                        leftTypeName: pLeftType.toString(),
                        rightTypeName: pRightType.toString()
                    });
                    return null;
                }
                pExpr.setOperator(sOperator);
                pExpr.setType(pExprType);
                pExpr.push(pLeftExpr, true);
                pExpr.push(pRightExpr, true);
                if(!pExpr.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pExpr.getLastError());
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeRelationExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var sOperator = pNode.children[1].value;
                var pExpr = new fx.RelationalExprInstruction();
                var pLeftExpr;
                var pRightExpr;
                var pLeftType;
                var pRightType;
                var pExprType;
                pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pRightExpr = this.analyzeExpr(pChildren[0]);
                pLeftType = pLeftExpr.getType();
                pRightType = pRightExpr.getType();
                pExprType = this.checkTwoOperandExprTypes(sOperator, pLeftType, pRightType);
                if(akra.isNull(pExprType)) {
                    this._error(2209, {
                        operator: sOperator,
                        leftTypeName: pLeftType.toString(),
                        rightTypeName: pRightType.toString()
                    });
                    return null;
                }
                pExpr.setOperator(sOperator);
                pExpr.setType(pExprType);
                pExpr.push(pLeftExpr, true);
                pExpr.push(pRightExpr, true);
                if(!pExpr.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pExpr.getLastError());
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeLogicalExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var sOperator = pNode.children[1].value;
                var pExpr = new fx.LogicalExprInstruction();
                var pLeftExpr;
                var pRightExpr;
                var pLeftType;
                var pRightType;
                var pBoolType;
                pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pRightExpr = this.analyzeExpr(pChildren[0]);
                pLeftType = pLeftExpr.getType();
                pRightType = pRightExpr.getType();
                pBoolType = Effect.getSystemType("bool");
                if(!pLeftType.isEqual(pBoolType)) {
                    this._error(2210, {
                        operator: sOperator,
                        typeName: pLeftType.toString()
                    });
                    return null;
                }
                if(!pRightType.isEqual(pBoolType)) {
                    this._error(2210, {
                        operator: sOperator,
                        typeName: pRightType.toString()
                    });
                    return null;
                }
                pExpr.setOperator(sOperator);
                pExpr.setType(pBoolType);
                pExpr.push(pLeftExpr, true);
                pExpr.push(pRightExpr, true);
                if(!pExpr.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pExpr.getLastError());
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeAssignmentExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var sOperator = pChildren[1].value;
                var pExpr = new fx.AssignmentExprInstruction();
                var pLeftExpr;
                var pRightExpr;
                var pLeftType;
                var pRightType;
                var pExprType;
                pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
                pRightExpr = this.analyzeExpr(pChildren[0]);
                pLeftType = pLeftExpr.getType();
                pRightType = pRightExpr.getType();
                if(!pLeftType._usedForWrite()) {
                    this._error(2267);
                    return null;
                }
                //pRightType._usedForRead();
                if(sOperator !== "=") {
                    pExprType = this.checkTwoOperandExprTypes(sOperator, pLeftType, pRightType);
                    if(akra.isNull(pExprType)) {
                        this._error(2207, {
                            operator: sOperator,
                            leftTypeName: pLeftType.toString(),
                            rightTypeName: pRightType.toString()
                        });
                    }
                } else {
                    pExprType = pRightType;
                }
                pExprType = this.checkTwoOperandExprTypes("=", pLeftType, pExprType);
                if(akra.isNull(pExprType)) {
                    this._error(2208, {
                        leftTypeName: pLeftType.toString(),
                        rightTypeName: pRightType.toString()
                    });
                }
                pExpr.setOperator(sOperator);
                pExpr.setType(pExprType);
                pExpr.push(pLeftExpr, true);
                pExpr.push(pRightExpr, true);
                if(!pExpr.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pExpr.getLastError());
                }
                ;
                return pExpr;
            };
            Effect.prototype.analyzeIdExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var sName = pNode.value;
                var pVariable = this.getVariable(sName);
                if(akra.isNull(pVariable)) {
                    this._error(2205, {
                        varName: sName
                    });
                    return null;
                }
                if(!akra.isNull(this.getCurrentAnalyzedFunction())) {
                    if(!pVariable._isForPixel()) {
                        this.getCurrentAnalyzedFunction()._setForPixel(false);
                    }
                    if(!pVariable._isForVertex()) {
                        this.getCurrentAnalyzedFunction()._setForVertex(false);
                    }
                }
                var pVarId = new fx.IdExprInstruction();
                pVarId.push(pVariable.getNameId(), false);
                if(!pVarId.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pVarId.getLastError());
                }
                ;
                return pVarId;
            };
            Effect.prototype.analyzeSimpleExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pInstruction = null;
                var sName = pNode.name;
                var sValue = pNode.value;
                switch(sName) {
                    case "T_UINT":
                        pInstruction = new fx.IntInstruction();
                        pInstruction.setValue((sValue) * 1);
                        break;
                    case "T_FLOAT":
                        pInstruction = new fx.FloatInstruction();
                        pInstruction.setValue((sValue) * 1.0);
                        break;
                    case "T_STRING":
                        pInstruction = new fx.StringInstruction();
                        pInstruction.setValue(sValue);
                        break;
                    case "T_KW_TRUE":
                        pInstruction = new fx.BoolInstruction();
                        pInstruction.setValue(true);
                        break;
                    case "T_KW_FALSE":
                        pInstruction = new fx.BoolInstruction();
                        pInstruction.setValue(false);
                        break;
                }
                // this.pushCommand(pInstruction, true);
                return pInstruction;
            };
            Effect.prototype.analyzeMemExpr = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pMemExpr = new fx.MemExprInstruction();
                var pPostfixExpr = this.analyzeExpr(pChildren[0]);
                var pPostfixExprType = pPostfixExpr.getType();
                if(pPostfixExpr._getInstructionType() !== 2 /* k_VariableTypeInstruction */ ) {
                    this._error(2253);
                    return null;
                }
                var pBuffer = pPostfixExprType.getVideoBuffer();
                if(akra.isNull(pBuffer)) {
                    this._error(2254);
                }
                if(!pPostfixExprType.isStrictPointer() && !akra.isNull(this.getCurrentAnalyzedFunction())) {
                    this.getCurrentAnalyzedFunction()._setForPixel(false);
                    this.getCurrentAnalyzedFunction()._notCanUsedAsFunction();
                    pPostfixExprType._setPointerToStrict();
                }
                pMemExpr.setBuffer(pBuffer);
                return pMemExpr;
            };
            Effect.prototype.analyzeConstTypeDim = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                //var pVariableType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
                //var pType: TypeInstruction = new TypeInstruction();
                if(pChildren.length > 1) {
                    this._error(2213);
                    return null;
                }
                //var pMainType: IAFXTypeInstruction;
                var pType;
                pType = (this.analyzeType(pChildren[0]));
                //pType = pMainType;//this.generateVariableTypeFromId(pMainType);
                if(!pType.isBase()) {
                    this._error(2214, {
                        typeName: pType.toString()
                    });
                }
                if(!pType.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pType.getLastError());
                }
                ;
                return pType;
            };
            Effect.prototype.analyzeVarStructDecl = function /** @no-inline */(pNode, pInstruction) {
                if (typeof pInstruction === "undefined") { pInstruction = null; }
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pUsageType = null;
                var pVariable = null;
                var i = 0;
                pUsageType = this.analyzeUsageStructDecl(pChildren[pChildren.length - 1]);
                for(i = pChildren.length - 2; i >= 1; i--) {
                    if(pChildren[i].name === "Variable") {
                        pVariable = this.analyzeVariable(pChildren[i], pUsageType);
                        if(!akra.isNull(pInstruction)) {
                            pInstruction.push(pVariable, true);
                        }
                    }
                }
            };
            Effect.prototype.analyzeUsageStructDecl = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var i = 0;
                var pType = new fx.UsageTypeInstruction();
                for(i = pChildren.length - 1; i >= 0; i--) {
                    if(pChildren[i].name === "StructDecl") {
                        var pMainType = this.analyzeStructDecl(pChildren[i]);
                        pType.setTypeInstruction(pMainType);
                        var pTypeDecl = new fx.TypeDeclInstruction();
                        pTypeDecl.push(pMainType, true);
                        this.addTypeDecl(pTypeDecl);
                    } else if(pChildren[i].name === "Usage") {
                        var sUsage = this.analyzeUsage(pChildren[i]);
                        pType.addUsage(sUsage);
                    }
                }
                if(!pType.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pType.getLastError());
                }
                ;
                return pType;
            };
            Effect.prototype.analyzeTypeDecl = function /** @no-inline */(pNode, pParentInstruction) {
                if (typeof pParentInstruction === "undefined") { pParentInstruction = null; }
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pTypeDeclInstruction = new fx.TypeDeclInstruction();
                // var pType: IAFXType = new Type();
                // this.newInstruction(pTypeDeclInstruction);
                if(pChildren.length === 2) {
                    var pStructInstruction = this.analyzeStructDecl(pChildren[1]);
                    pTypeDeclInstruction.push(pStructInstruction, true);
                } else {
                    this._error(2203);
                }
                // this.endInstruction();
                // this.pushCommand(pTypeDeclInstruction, true);
                // pType.initializeFromInstruction(pTypeDeclInstruction);
                if(!pTypeDeclInstruction.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pTypeDeclInstruction.getLastError());
                }
                ;
                this.addTypeDecl(pTypeDeclInstruction);
                pNode.isAnalyzed = true;
                if(!akra.isNull(pParentInstruction)) {
                    pParentInstruction.push(pTypeDeclInstruction, true);
                }
                return pTypeDeclInstruction;
            };
            Effect.prototype.analyzeStructDecl = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pStruct = new fx.ComplexTypeInstruction();
                var pFieldCollector = new fx.Instruction();
                var sName = pChildren[pChildren.length - 2].value;
                pStruct.setName(sName);
                this.newScope(1 /* k_Struct */ );
                var i = 0;
                for(i = pChildren.length - 4; i >= 1; i--) {
                    if(pChildren[i].name === "VariableDecl") {
                        this.analyzeVariableDecl(pChildren[i], pFieldCollector);
                    }
                }
                this.endScope();
                pStruct.push(pFieldCollector, true);
                if(!pStruct.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pStruct.getLastError());
                }
                ;
                return pStruct;
            };
            Effect.prototype.analyzeStruct = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pStruct = new fx.ComplexTypeInstruction();
                var pFieldCollector = new fx.Instruction();
                this.newScope(1 /* k_Struct */ );
                var i = 0;
                for(i = pChildren.length - 4; i >= 1; i--) {
                    if(pChildren[i].name === "VariableDecl") {
                        this.analyzeVariableDecl(pChildren[i], pFieldCollector);
                    }
                }
                this.endScope();
                pStruct.addFields(pFieldCollector, true);
                if(!pStruct.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pStruct.getLastError());
                }
                ;
                return pStruct;
            };
            Effect.prototype.analyzeFunctionDeclOnlyDefinition = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pFunction = null;
                var pFunctionDef = null;
                var pStmtBlock = null;
                var pAnnotation = null;
                var sLastNodeValue = pChildren[0].value;
                var bNeedAddFunction = false;
                pFunctionDef = this.analyzeFunctionDef(pChildren[pChildren.length - 1]);
                pFunction = this.findFunctionByDef(pFunctionDef);
                if(!akra.isDef(pFunction)) {
                    this._error(2246, {
                        funcName: pFunction.getNameId().toString()
                    });
                    return null;
                }
                if(!akra.isNull(pFunction) && pFunction.hasImplementation()) {
                    this._error(2227, {
                        funcName: pFunction.getNameId().toString()
                    });
                    return null;
                }
                if(akra.isNull(pFunction)) {
                    pFunction = new fx.FunctionDeclInstruction();
                    bNeedAddFunction = true;
                } else {
                    if(!pFunction.getReturnType().isEqual(pFunctionDef.getReturnType())) {
                        this._error(2247, {
                            funcName: pFunction.getNameId().toString()
                        });
                        return null;
                    }
                    bNeedAddFunction = false;
                }
                pFunction.setFunctionDef(pFunctionDef);
                this.resumeScope();
                if(pChildren.length === 3) {
                    pAnnotation = this.analyzeAnnotation(pChildren[1]);
                    pFunction.setAnnotation(pAnnotation);
                }
                if(sLastNodeValue !== ";") {
                    pFunction.setParseNode(pNode);
                    pFunction.setScope(this.getScope());
                    this._pFunctionWithImplementationList.push(pFunction);
                }
                this.endScope();
                if(bNeedAddFunction) {
                    this.addFunctionDecl(pFunction);
                }
            };
            Effect.prototype.resumeFunctionAnalysis = function /** @no-inline */(pAnalzedFunction) {
                var pFunction = pAnalzedFunction;
                var pNode = pFunction.getParseNode();
                this.setAnalyzedNode(pNode);
                this.setScope(pFunction.getScope());
                var pChildren = pNode.children;
                var pStmtBlock = null;
                this.setCurrentAnalyzedFunction(pFunction);
                pStmtBlock = this.analyzeStmtBlock(pChildren[0]);
                pFunction.setImplementation(pStmtBlock);
                this.setCurrentAnalyzedFunction(null);
                this.endScope();
                if(!pFunction.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pFunction.getLastError());
                }
                ;
            };
            Effect.prototype.analyzeFunctionDef = //    private analyzeFunctionDecl(pNode: IParseNode): IAFXFunctionDeclInstruction {
            //    	this.setAnalyzedNode(pNode);
            //    	var pChildren: IParseNode[] = pNode.children;
            //    	var pFunction: IAFXFunctionDeclInstruction = null;
            //    	var pFunctionDef: FunctionDefInstruction = null;
            //    	var pStmtBlock: StmtBlockInstruction = null;
            //    	var pAnnotation: IAFXAnnotationInstruction = null;
            //    	var sLastNodeValue: string = pChildren[0].value;
            //    	pFunctionDef = this.analyzeFunctionDef(pChildren[pChildren.length - 1]);
            //    	pFunction = this.findFunctionByDef(pFunctionDef);
            //    	if(!isDef(pFunction)){
            //    		this._error(EFFECT_BAD_CANNOT_CHOOSE_FUNCTION, {funcName: pFunction.getNameId().toString() });
            //    		return null;
            //    	}
            //    	if(!isNull(pFunction) && pFunction.hasImplementation()){
            //    		this._error(EFFECT_BAD_REDEFINE_FUNCTION, { funcName: pFunction.getNameId().toString() });
            //    		return null;
            //    	}
            //    	if(isNull(pFunction)){
            //    		pFunction = new FunctionDeclInstruction();
            //    	}
            //    	else {
            //    		if(!pFunction.getReturnType().isEqual(pFunctionDef.getReturnType())){
            //    			this._error(EFFECT_BAD_FUNCTION_DEF_RETURN_TYPE, {funcName: pFunction.getNameId().toString() });
            //    			return null;
            //    		}
            //    	}
            // 	pFunction.setFunctionDef(<IAFXDeclInstruction>pFunctionDef);
            //    	//this.newInstruction(pFunction);
            //    	this.resumeScope();
            //    	if(pChildren.length === 3) {
            //    		pAnnotation = this.analyzeAnnotation(pChildren[1]);
            //    		pFunction.setAnnotation(pAnnotation);
            //    	}
            //    	if(sLastNodeValue !== ";") {
            // pStmtBlock = <StmtBlockInstruction>this.analyzeStmtBlock(pChildren[0]);
            // pFunction.setImplementation(<IAFXStmtInstruction>pStmtBlock);
            //    	}
            //    	this.endScope();
            //  		// this.endInstruction();
            //  		CHECK_INSTRUCTION(pFunction, ECheckStage.CODE_TARGET_SUPPORT);
            //  		this.addFunctionDecl(pFunction);
            //  		return pFunction;
            //    }
            function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pFunctionDef = new fx.FunctionDefInstruction();
                var pReturnType = null;
                var pUsageType = null;
                var pFuncName = null;
                var pArguments = null;
                var sFuncName = pChildren[pChildren.length - 2].value;
                pUsageType = this.analyzeUsageType(pChildren[pChildren.length - 1]);
                pReturnType = new fx.VariableTypeInstruction();
                pReturnType.push(pUsageType, true);
                if(pReturnType.isPointer() || pReturnType._containSampler() || pReturnType._containPointer()) {
                    this._error(2264, {
                        funcName: sFuncName
                    });
                    return null;
                }
                pFuncName = new fx.IdInstruction();
                pFuncName.setName(sFuncName);
                pFunctionDef.setReturnType(pReturnType);
                pFunctionDef.setFunctionName(pFuncName);
                if(pChildren.length === 4) {
                    var sSemantic = this.analyzeSemantic(pChildren[0]);
                    pFunctionDef.setSemantic(sSemantic);
                }
                this.newScope();
                this.analyzeParamList(pChildren[pChildren.length - 3], pFunctionDef);
                this.endScope();
                if(!pFunctionDef.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pFunctionDef.getLastError());
                }
                ;
                return pFunctionDef;
            };
            Effect.prototype.analyzeParamList = function /** @no-inline */(pNode, pFunctionDef) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pParameter;
                var i = 0;
                for(i = pChildren.length - 2; i >= 1; i--) {
                    if(pChildren[i].name === "ParameterDecl") {
                        pParameter = this.analyzeParameterDecl(pChildren[i]);
                        pFunctionDef.addParameter(pParameter, this.isStrictMode());
                    }
                }
            };
            Effect.prototype.analyzeParameterDecl = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pType;
                var pParameter;
                pType = this.analyzeParamUsageType(pChildren[1]);
                pParameter = this.analyzeVariable(pChildren[0], pType);
                return pParameter;
            };
            Effect.prototype.analyzeParamUsageType = function /** @no-inline */(pNode) {
                var pChildren = pNode.children;
                var i = 0;
                var pType = new fx.UsageTypeInstruction();
                for(i = pChildren.length - 1; i >= 0; i--) {
                    if(pChildren[i].name === "Type") {
                        var pMainType = this.analyzeType(pChildren[i]);
                        pType.setTypeInstruction(pMainType);
                    } else if(pChildren[i].name === "ParamUsage") {
                        var sUsage = this.analyzeUsage(pChildren[i]);
                        pType.addUsage(sUsage);
                    }
                }
                if(!pType.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pType.getLastError());
                }
                ;
                return pType;
            };
            Effect.prototype.analyzeStmtBlock = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pStmtBlock = new fx.StmtBlockInstruction();
                var pStmt;
                var i = 0;
                this.newScope();
                for(i = pChildren.length - 2; i > 0; i--) {
                    pStmt = this.analyzeStmt(pChildren[i]);
                    if(!akra.isNull(pStmt)) {
                        pStmtBlock.push(pStmt);
                    }
                }
                this.endScope();
                if(!pStmtBlock.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pStmtBlock.getLastError());
                }
                ;
                return pStmtBlock;
            };
            Effect.prototype.analyzeStmt = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var sFirstNodeName = pChildren[pChildren.length - 1].name;
                switch(sFirstNodeName) {
                    case "SimpleStmt":
                        return this.analyzeSimpleStmt(pChildren[0]);
                    case "UseDecl":
                        this.analyzeUseDecl(pChildren[0]);
                        return null;
                    case "T_KW_WHILE":
                        return this.analyzeWhileStmt(pNode);
                    case "T_KW_FOR":
                        return this.analyzeForStmt(pNode);
                    case "T_KW_IF":
                        return this.analyzeIfStmt(pNode);
                }
            };
            Effect.prototype.analyzeSimpleStmt = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var sFirstNodeName = pChildren[pChildren.length - 1].name;
                switch(sFirstNodeName) {
                    case "T_KW_RETURN":
                        return this.analyzeReturnStmt(pNode);
                    case "T_KW_DO":
                        return this.analyzeWhileStmt(pNode);
                    case "StmtBlock":
                        return this.analyzeStmtBlock(pChildren[0]);
                    case "T_KW_DISCARD":
                    case "T_KW_BREAK":
                    case "T_KW_CONTINUE":
                        return this.analyzeBreakStmt(pNode);
                    case "TypeDecl":
                    case "VariableDecl":
                    case "VarStructDecl":
                        return this.analyzeDeclStmt(pChildren[0]);
                    default:
                        if(pChildren.length === 2) {
                            return this.analyzeExprStmt(pNode);
                        } else {
                            return (new fx.SemicolonStmtInstruction());
                        }
                }
            };
            Effect.prototype.analyzeReturnStmt = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pReturnStmtInstruction = new fx.ReturnStmtInstruction();
                var pFunctionReturnType = this.getCurrentAnalyzedFunction().getReturnType();
                if(pFunctionReturnType.isEqual(Effect.getSystemType("void")) && pChildren.length === 3) {
                    this._error(2261);
                    return null;
                } else if(!pFunctionReturnType.isEqual(Effect.getSystemType("void")) && pChildren.length === 2) {
                    this._error(2262);
                    return null;
                }
                if(pChildren.length === 3) {
                    var pExprInstruction = this.analyzeExpr(pChildren[1]);
                    var pOutVar = this.getCurrentAnalyzedFunction()._getOutVariable();
                    if(!akra.isNull(pOutVar) && pOutVar.getType() !== pExprInstruction.getType()) {
                        this._error(2263);
                        return null;
                    }
                    if(!pFunctionReturnType.isEqual(pExprInstruction.getType())) {
                        this._error(2263);
                        return null;
                    }
                    pReturnStmtInstruction.push(pExprInstruction, true);
                }
                if(!pReturnStmtInstruction.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pReturnStmtInstruction.getLastError());
                }
                ;
                return pReturnStmtInstruction;
            };
            Effect.prototype.analyzeBreakStmt = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pBreakStmtInstruction = new fx.BreakStmtInstruction();
                var sOperatorName = pChildren[1].value;
                pBreakStmtInstruction.setOperator(sOperatorName);
                if(sOperatorName === "discard" && !akra.isNull(this.getCurrentAnalyzedFunction())) {
                    this.getCurrentAnalyzedFunction()._setForVertex(false);
                }
                if(!pBreakStmtInstruction.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pBreakStmtInstruction.getLastError());
                }
                ;
                return pBreakStmtInstruction;
            };
            Effect.prototype.analyzeDeclStmt = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var sNodeName = pNode.name;
                var pDeclStmtInstruction = new fx.DeclStmtInstruction();
                switch(sNodeName) {
                    case "TypeDecl":
                        this.analyzeTypeDecl(pNode, pDeclStmtInstruction);
                        break;
                    case "VariableDecl":
                        this.analyzeVariableDecl(pNode, pDeclStmtInstruction);
                        break;
                    case "VarStructDecl":
                        //TODO: add varstruct
                        break;
                }
                if(!pDeclStmtInstruction.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pDeclStmtInstruction.getLastError());
                }
                ;
                return pDeclStmtInstruction;
            };
            Effect.prototype.analyzeExprStmt = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pExprStmtInstruction = new fx.ExprStmtInstruction();
                var pExprInstruction = this.analyzeExpr(pChildren[1]);
                pExprStmtInstruction.push(pExprInstruction, true);
                if(!pExprStmtInstruction.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pExprStmtInstruction.getLastError());
                }
                ;
                return pExprStmtInstruction;
            };
            Effect.prototype.analyzeWhileStmt = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var isDoWhile = (pChildren[pChildren.length - 1].value === "do");
                var isNonIfStmt = (pNode.name === "NonIfStmt") ? true : false;
                var pWhileStmt = new fx.WhileStmtInstruction();
                var pCondition = null;
                var pConditionType = null;
                var pBoolType = Effect.getSystemType("bool");
                var pStmt = null;
                if(isDoWhile) {
                    pWhileStmt.setOperator("do_while");
                    pCondition = this.analyzeExpr(pChildren[2]);
                    pConditionType = pCondition.getType();
                    if(!pConditionType.isEqual(pBoolType)) {
                        this._error(2229, {
                            typeName: pConditionType.toString()
                        });
                        return null;
                    }
                    pStmt = this.analyzeStmt(pChildren[0]);
                } else {
                    pWhileStmt.setOperator("while");
                    pCondition = this.analyzeExpr(pChildren[2]);
                    pConditionType = pCondition.getType();
                    if(!pConditionType.isEqual(pBoolType)) {
                        this._error(2228, {
                            typeName: pConditionType.toString()
                        });
                        return null;
                    }
                    if(isNonIfStmt) {
                        pStmt = this.analyzeNonIfStmt(pChildren[0]);
                    } else {
                        pStmt = this.analyzeStmt(pChildren[0]);
                    }
                    pWhileStmt.push(pCondition, true);
                    pWhileStmt.push(pStmt, true);
                }
                if(!pWhileStmt.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pWhileStmt.getLastError());
                }
                ;
                return pWhileStmt;
            };
            Effect.prototype.analyzeIfStmt = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var isIfElse = (pChildren.length === 7);
                var pIfStmtInstruction = new fx.IfStmtInstruction();
                var pCondition = this.analyzeExpr(pChildren[pChildren.length - 3]);
                var pConditionType = pCondition.getType();
                var pBoolType = Effect.getSystemType("bool");
                var pIfStmt = null;
                var pElseStmt = null;
                if(!pConditionType.isEqual(pBoolType)) {
                    this._error(2230, {
                        typeName: pConditionType.toString()
                    });
                    return null;
                }
                pIfStmtInstruction.push(pCondition, true);
                if(isIfElse) {
                    pIfStmtInstruction.setOperator("if_else");
                    pIfStmt = this.analyzeNonIfStmt(pChildren[2]);
                    pElseStmt = this.analyzeStmt(pChildren[0]);
                    pIfStmtInstruction.push(pIfStmt, true);
                    pIfStmtInstruction.push(pElseStmt, true);
                } else {
                    pIfStmtInstruction.setOperator("if");
                    pIfStmt = this.analyzeNonIfStmt(pChildren[0]);
                    pIfStmtInstruction.push(pIfStmt, true);
                }
                if(!pIfStmtInstruction.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pIfStmtInstruction.getLastError());
                }
                ;
                return pIfStmtInstruction;
            };
            Effect.prototype.analyzeNonIfStmt = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var sFirstNodeName = pChildren[pChildren.length - 1].name;
                switch(sFirstNodeName) {
                    case "SimpleStmt":
                        return this.analyzeSimpleStmt(pChildren[0]);
                    case "T_KW_WHILE":
                        return this.analyzeWhileStmt(pNode);
                    case "T_KW_FOR":
                        return this.analyzeForStmt(pNode);
                }
            };
            Effect.prototype.analyzeForStmt = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var isNonIfStmt = (pNode.name === "NonIfStmt");
                var pForStmtInstruction = new fx.ForStmtInstruction();
                var pStmt = null;
                // if(pChildren.length !== 7){
                // 	//Empty for-step
                // 	this._error(EFFECT_BAD_FOR_STEP_EMPTY);
                // 	return null;
                // }
                this.newScope();
                this.analyzeForInit(pChildren[pChildren.length - 3], pForStmtInstruction);
                this.analyzeForCond(pChildren[pChildren.length - 4], pForStmtInstruction);
                if(pChildren.length === 7) {
                    this.analyzeForStep(pChildren[2], pForStmtInstruction);
                } else {
                    pForStmtInstruction.push(null);
                }
                if(isNonIfStmt) {
                    pStmt = this.analyzeNonIfStmt(pChildren[0]);
                } else {
                    pStmt = this.analyzeIfStmt(pChildren[0]);
                }
                pForStmtInstruction.push(pStmt, true);
                this.endScope();
                if(!pForStmtInstruction.check(0 /* CODE_TARGET_SUPPORT */ )) {
                    this._errorFromInstruction(pForStmtInstruction.getLastError());
                }
                ;
                return pForStmtInstruction;
            };
            Effect.prototype.analyzeForInit = function /** @no-inline */(pNode, pForStmtInstruction) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var sFirstNodeName = pChildren[pChildren.length - 1].name;
                switch(sFirstNodeName) {
                    case "VariableDecl":
                        this.analyzeVariableDecl(pChildren[0], pForStmtInstruction);
                        break;
                    case "Expr":
                        var pExpr = this.analyzeExpr(pChildren[0]);
                        pForStmtInstruction.push(pExpr, true);
                        break;
                    default:
                        // ForInit : ';'
                        //this._error(EFFECT_BAD_FOR_INIT_EMPTY_ITERATOR);
                        pForStmtInstruction.push(null);
                        break;
                }
                return;
            };
            Effect.prototype.analyzeForCond = function /** @no-inline */(pNode, pForStmtInstruction) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                if(pChildren.length === 1) {
                    pForStmtInstruction.push(null);
                    //this._error(EFFECT_BAD_FOR_COND_EMPTY);
                    return;
                }
                var pConditionExpr = this.analyzeExpr(pChildren[1]);
                // if(pConditionExpr._getInstructionType() !== EAFXInstructionTypes.k_RelationalExprInstruction){
                // 	this._error(EFFECT_BAD_FOR_COND_RELATION);
                // 	return;
                // }
                pForStmtInstruction.push(pConditionExpr, true);
                return;
            };
            Effect.prototype.analyzeForStep = function /** @no-inline */(pNode, pForStmtInstruction) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pStepExpr = this.analyzeExpr(pChildren[0]);
                // if(pStepExpr._getInstructionType() === EAFXInstructionTypes.k_UnaryExprInstruction ||
                //    pStepExpr._getInstructionType() === EAFXInstructionTypes.k_AssignmentExprInstruction){
                // 	var sOperator: string = pStepExpr.getOperator();
                // 	if (sOperator !== "++" && sOperator !== "--" &&
                // 	    sOperator !== "+=" && sOperator !== "-=") {
                // 		this._error(EFFECT_BAD_FOR_STEP_OPERATOR, {operator: sOperator});
                // 	}
                // }
                // else {
                // 	this._error(EFFECT_BAD_FOR_STEP_EXPRESSION);
                // }
                pForStmtInstruction.push(pStepExpr, true);
                return;
            };
            Effect.prototype.analyzeUseDecl = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                this.setStrictModeOn();
            };
            Effect.prototype.analyzeTechniqueForImport = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var pTechnique = new fx.TechniqueInstruction();
                var sTechniqueName = this.analyzeComplexName(pChildren[pChildren.length - 2]);
                var isComplexName = pChildren[pChildren.length - 2].children.length !== 1;
                pTechnique.setName(sTechniqueName, isComplexName);
                for(var i = pChildren.length - 3; i >= 0; i--) {
                    if(pChildren[i].name === "Annotation") {
                        var pAnnotation = this.analyzeAnnotation(pChildren[i]);
                        pTechnique.setAnnotation(pAnnotation);
                    } else if(pChildren[i].name === "Semantic") {
                        var sSemantic = this.analyzeSemantic(pChildren[i]);
                        pTechnique.setSemantic(sSemantic);
                    } else {
                        this.analyzeTechniqueBodyForImports(pChildren[i]);
                    }
                }
                this.addTechnique(pTechnique);
                pTechnique._setParseNode(pNode);
            };
            Effect.prototype.analyzeComplexName = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                var sName = "";
                for(var i = pChildren.length - 1; i >= 0; i--) {
                    sName += pChildren[i].value;
                }
                return sName;
            };
            Effect.prototype.analyzeTechniqueBodyForImports = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                for(var i = pChildren.length - 2; i >= 1; i--) {
                    this.analyzePassDeclForImports(pChildren[i]);
                }
            };
            Effect.prototype.analyzePassDeclForImports = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                if(pChildren[0].name === "ImportDecl") {
                    this.analyzeImportDecl(pChildren[0]);
                } else if(pChildren.length > 1) {
                    this.analyzePassStateBlockForShaders(pChildren[0]);
                }
            };
            Effect.prototype.analyzePassStateBlockForShaders = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                for(var i = pChildren.length - 2; i >= 1; i--) {
                    this.analyzePassStateForShader(pChildren[i]);
                }
            };
            Effect.prototype.analyzePassStateForShader = function /** @no-inline */(pNode) {
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                if(pChildren.length === 1) {
                    return;
                }
                var sType = pChildren[pChildren.length - 1].value.toUpperCase();
                var eShaderType = 0 /* k_Vertex */ ;
                if(sType === "VERTEXSHADER") {
                    eShaderType = 0 /* k_Vertex */ ;
                } else if(sType === "PIXELSHADER") {
                    eShaderType = 1 /* k_Pixel */ ;
                } else {
                    return;
                }
                var pStateExprNode = pChildren[pChildren.length - 3];
                var pExprNode = pStateExprNode.children[pStateExprNode.children.length - 1];
                var pCompileExpr = this.analyzeExpr(pExprNode);
                var pShaderFunc = pCompileExpr.getFunction();
                if(eShaderType === 0 /* k_Vertex */ ) {
                    if(!pShaderFunc._checkDefenitionForVertexUsage()) {
                        this._error(2259, {
                            funcDef: pShaderFunc._getStringDef()
                        });
                    }
                } else {
                    if(!pShaderFunc._checkDefenitionForPixelUsage()) {
                        this._error(2260, {
                            funcDef: pShaderFunc._getStringDef()
                        });
                    }
                }
                pShaderFunc._usedAs(eShaderType);
            };
            Effect.prototype.resumeTechniqueAnalysis = function /** @no-inline */(pTechnique) {
                var pNode = pTechnique._getParseNode();
                this.setAnalyzedNode(pNode);
                var pChildren = pNode.children;
                //return null;
                            };
            Effect.prototype.analyzeImportDecl = function /** @no-inline */(pNode) {
                return null;
            };
            Effect.prototype.analyzeProvideDecl = function /** @no-inline */(pNode) {
                return null;
            };
            Effect.prototype.checkTwoOperandExprTypes = /**
            * Проверят возможность использования оператора между двумя типами.
            * Возращает тип получаемый в результате приминения опрератора, или, если применить его невозможно - null.
            *
            * @sOperator {string} Один из операторов: + - * / % += -= *= /= %= = < > <= >= == != =
            * @pLeftType {IAFXVariableTypeInstruction} Тип левой части выражения
            * @pRightType {IAFXVariableTypeInstruction} Тип правой части выражения
            */
            function /** @no-inline */(sOperator, pLeftType, pRightType) {
                var isComplex = pLeftType.isComplex() || pRightType.isComplex();
                var isArray = pLeftType.isNotBaseArray() || pRightType.isNotBaseArray();
                var isSampler = this.isSamplerType(pLeftType) || this.isSamplerType(pRightType);
                var pBoolType = Effect.getSystemType("bool").getVariableType();
                if(isArray || isSampler) {
                    return null;
                }
                if(isComplex) {
                    if(sOperator === "=" && pLeftType.isEqual(pRightType)) {
                        return pLeftType;
                    } else if(this.isEqualOperator(sOperator) && !pLeftType._containArray() && !pLeftType._containSampler()) {
                        return pBoolType;
                    } else {
                        return null;
                    }
                }
                if(sOperator === "%" || sOperator === "%=") {
                    return null;
                }
                var pReturnType = null;
                var pLeftBaseType = (pLeftType.getBaseType()).getVariableType();
                var pRightBaseType = (pRightType.getBaseType()).getVariableType();
                if(pLeftType.isConst() && this.isBadForConstOperator(sOperator)) {
                    return null;
                }
                if(pLeftType.isEqual(pRightType)) {
                    if(this.isArithmeticalOperator(sOperator)) {
                        if(!this.isMatrixType(pLeftType) || (sOperator !== "/" && sOperator !== "/=")) {
                            return pLeftBaseType;
                        } else {
                            return null;
                        }
                    } else if(this.isRelationalOperator(sOperator)) {
                        if(this.isScalarType(pLeftType)) {
                            return pBoolType;
                        } else {
                            return null;
                        }
                    } else if(this.isEqualOperator(sOperator)) {
                        return pBoolType;
                    } else if(sOperator === "=") {
                        return pLeftBaseType;
                    } else {
                        return null;
                    }
                }
                if(this.isArithmeticalOperator(sOperator)) {
                    if(this.isBoolBasedType(pLeftType) || this.isBoolBasedType(pRightType) || this.isFloatBasedType(pLeftType) !== this.isFloatBasedType(pRightType) || this.isIntBasedType(pLeftType) !== this.isIntBasedType(pRightType)) {
                        return null;
                    }
                    if(this.isScalarType(pLeftType)) {
                        return pRightBaseType;
                    }
                    if(this.isScalarType(pRightType)) {
                        return pLeftType;
                    }
                    if(sOperator === "*" || sOperator === "*=") {
                        if(this.isMatrixType(pLeftType) && this.isVectorType(pRightType) && pLeftType.getLength() === pRightType.getLength()) {
                            return pRightBaseType;
                        } else if(this.isMatrixType(pRightType) && this.isVectorType(pLeftType) && pLeftType.getLength() === pRightType.getLength()) {
                            return pLeftBaseType;
                        } else {
                            return null;
                        }
                    }
                }
                return null;
            };
            Effect.prototype.checkOneOperandExprType = /**
            * Проверят возможность использования оператора к типу данных.
            * Возращает тип получаемый в результате приминения опрератора, или, если применить его невозможно - null.
            *
            * @sOperator {string} Один из операторов: + - ! ++ --
            * @pLeftType {IAFXVariableTypeInstruction} Тип операнда
            */
            function /** @no-inline */(sOperator, pType) {
                var isComplex = pType.isComplex();
                var isArray = pType.isNotBaseArray();
                var isSampler = this.isSamplerType(pType);
                if(isComplex || isArray || isSampler) {
                    return null;
                }
                if(sOperator === "!") {
                    var pBoolType = Effect.getSystemType("bool").getVariableType();
                    if(pType.isEqual(pBoolType)) {
                        return pBoolType;
                    } else {
                        return null;
                    }
                } else {
                    if(this.isBoolBasedType(pType)) {
                        return null;
                    } else {
                        return (pType.getBaseType()).getVariableType();
                    }
                }
                //return null;
                            };
            Effect.prototype.isBadForConstOperator = function /** @no-inline */(sOperator) {
                return sOperator === "+=" || sOperator === "-=" || sOperator === "*=" || sOperator === "/=" || sOperator === "%=" || sOperator === "=";
            };
            Effect.prototype.isArithmeticalOperator = function /** @no-inline */(sOperator) {
                return sOperator === "+" || sOperator === "+=" || sOperator === "-" || sOperator === "-=" || sOperator === "*" || sOperator === "*=" || sOperator === "/" || sOperator === "/=";
            };
            Effect.prototype.isRelationalOperator = function /** @no-inline */(sOperator) {
                return sOperator === ">" || sOperator === ">=" || sOperator === "<" || sOperator === "<=";
            };
            Effect.prototype.isEqualOperator = function /** @no-inline */(sOperator) {
                return sOperator === "==" || sOperator === "!=";
            };
            Effect.prototype.isMatrixType = function /** @no-inline */(pType) {
                return pType.isEqual(Effect.getSystemType("float2x2")) || pType.isEqual(Effect.getSystemType("float3x3")) || pType.isEqual(Effect.getSystemType("float4x4")) || pType.isEqual(Effect.getSystemType("int2x2")) || pType.isEqual(Effect.getSystemType("int3x3")) || pType.isEqual(Effect.getSystemType("int4x4")) || pType.isEqual(Effect.getSystemType("bool2x2")) || pType.isEqual(Effect.getSystemType("bool3x3")) || pType.isEqual(Effect.getSystemType("bool4x4"));
            };
            Effect.prototype.isVectorType = function /** @no-inline */(pType) {
                return pType.isEqual(Effect.getSystemType("float2")) || pType.isEqual(Effect.getSystemType("float3")) || pType.isEqual(Effect.getSystemType("float4")) || pType.isEqual(Effect.getSystemType("bool2")) || pType.isEqual(Effect.getSystemType("bool3")) || pType.isEqual(Effect.getSystemType("bool4")) || pType.isEqual(Effect.getSystemType("int2")) || pType.isEqual(Effect.getSystemType("int3")) || pType.isEqual(Effect.getSystemType("int4"));
            };
            Effect.prototype.isScalarType = function /** @no-inline */(pType) {
                return pType.isEqual(Effect.getSystemType("bool")) || pType.isEqual(Effect.getSystemType("int")) || pType.isEqual(Effect.getSystemType("ptr")) || pType.isEqual(Effect.getSystemType("float"));
            };
            Effect.prototype.isFloatBasedType = function /** @no-inline */(pType) {
                return pType.isEqual(Effect.getSystemType("float")) || pType.isEqual(Effect.getSystemType("float2")) || pType.isEqual(Effect.getSystemType("float3")) || pType.isEqual(Effect.getSystemType("float4")) || pType.isEqual(Effect.getSystemType("float2x2")) || pType.isEqual(Effect.getSystemType("float3x3")) || pType.isEqual(Effect.getSystemType("float4x4")) || pType.isEqual(Effect.getSystemType("ptr"));
            };
            Effect.prototype.isIntBasedType = function /** @no-inline */(pType) {
                return pType.isEqual(Effect.getSystemType("int")) || pType.isEqual(Effect.getSystemType("int2")) || pType.isEqual(Effect.getSystemType("int3")) || pType.isEqual(Effect.getSystemType("int4")) || pType.isEqual(Effect.getSystemType("int2x2")) || pType.isEqual(Effect.getSystemType("int3x3")) || pType.isEqual(Effect.getSystemType("int4x4"));
            };
            Effect.prototype.isBoolBasedType = function /** @no-inline */(pType) {
                return pType.isEqual(Effect.getSystemType("bool")) || pType.isEqual(Effect.getSystemType("bool2")) || pType.isEqual(Effect.getSystemType("bool3")) || pType.isEqual(Effect.getSystemType("bool4")) || pType.isEqual(Effect.getSystemType("bool2x2")) || pType.isEqual(Effect.getSystemType("bool3x3")) || pType.isEqual(Effect.getSystemType("bool4x4"));
            };
            Effect.prototype.isSamplerType = function /** @no-inline */(pType) {
                return pType.isEqual(Effect.getSystemType("sampler")) || pType.isEqual(Effect.getSystemType("sampler2D")) || pType.isEqual(Effect.getSystemType("samplerCUBE")) || pType.isEqual(Effect.getSystemType("video_buffer"));
            };
            Effect.prototype.getNodeSourceLocation = function /** @no-inline */(pNode) {
                if(akra.isDef(pNode.line)) {
                    return {
                        line: pNode.line,
                        column: pNode.start
                    };
                } else {
                    return this.getNodeSourceLocation(pNode.children[pNode.children.length - 1]);
                }
            };
            return Effect;
        })();
        fx.Effect = Effect;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (fx) {
        var Composer = (function () {
            function /** @no-inline */Composer(pEngine) {
                this._pEngine = null;
                this._pEngine = pEngine;
            }
            Composer.prototype.getImportTechnique = function /** @no-inline */(sModuleName) {
            };
            Composer.prototype.getEngine = function /** @inline */() {
                return this._pEngine;
            };
            Composer.prototype._loadEffectFromSyntaxTree = function /** @no-inline */(pTree, sFileName) {
                var pEffect = new akra.fx.Effect(this);
                akra.logger.setSourceLocation("fx/Composer.ts", 36);
                akra.logger.log(pTree);
                ;
                // pEffect.setAnalyzedFileName(sFileName);
                // pEffect.analyze(pParseTree);
                            };
            Composer.prototype._loadEffectFromBinary = function /** @no-inline */(pData, sFileName) {
            };
            return Composer;
        })();
        fx.Composer = Composer;        
    })(akra.fx || (akra.fx = {}));
    var fx = akra.fx;
})(akra || (akra = {}));
var akra;
(function (akra) {
    //include sub creation classes.
    (function (render) {
        ;
        var RenderData = (function (_super) {
            __extends(RenderData, _super);
            function /** @no-inline */RenderData(pCollection) {
                if (typeof pCollection === "undefined") { pCollection = null; }
                        _super.call(this);
                /**
                * Options.
                */
                this._eOptions = 0;
                /**
                * Buffer, that create this class.
                */
                this._pBuffer = null;
                /**
                * ID of this data.
                */
                this._iId = -1;
                /**
                * Buffer with indices.
                * If the data is the simplest mesh, with no more
                * than one index, the type will be IndexBuffer,
                * otherwise VertexBuffer.
                */
                this._pIndexBuffer = null;
                /**
                * Buffer with attributes.
                */
                this._pAttribBuffer = null;
                /**
                * Data with indices.
                * If _pIndexBuffer has type IndexBuffer, indices data
                * has type IndexData, otherwise VertexData.
                */
                this._pIndexData = null;
                /**
                * Data with attributes.
                */
                this._pAttribData = null;
                /**
                * Buffer map for current index set.
                */
                this._pMap = null;
                /**
                * Buffer maps of all index sets.
                */
                this._pIndicesArray = [];
                /**
                * Current index set.
                */
                this._iIndexSet = 0;
                this._iRenderable = 1;
                this._pBuffer = pCollection;
            }
            Object.defineProperty(RenderData.prototype, "buffer", {
                get: function /** @inline */() {
                    return this._pBuffer;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderData.prototype, "indexSet", {
                get: function /** @inline */() {
                    return this._pIndicesArray[this._iIndexSet];
                },
                enumerable: true,
                configurable: true
            });
            RenderData.prototype.allocateData = function /** @no-inline */(pDecl, pData, hasIndex) {
                if (typeof hasIndex === "undefined") { hasIndex = true; }
                var pDataDecl = akra.createVertexDeclaration(pDecl);
                var eType = 1 /* INDEXED */ ;
                if(!hasIndex || this.useSingleIndex()) {
                    eType = 3 /* DIRECT */ ;
                } else if(this.useAdvancedIndex()) {
                    eType = 2 /* I2I */ ;
                }
                return this._allocateData(pDataDecl, pData, eType);
            };
            RenderData.prototype.releaseData = /**
            * Remove data from this render data.
            */
            function /** @no-inline */(iDataLocation) {
                //TODO: release data.
                            };
            RenderData.prototype.allocateAttribute = function /** @no-inline */(pAttrDecl, pData) {
                var pIndexData = this._pIndexData;
                var pAttribData = this._pAttribData;
                var pAttribBuffer = this._pAttribBuffer;
                var pBuffer = this._pBuffer;
                if(!pAttribData) {
                    if(!pAttribBuffer) {
                        pAttribBuffer = pBuffer.getEngine().getResourceManager().createVertexBuffer('render_data_attrs_' + akra.sid());
                        pAttribBuffer.create(8 /* BACKUP_COPY */ );
                        this._pAttribBuffer = pAttribBuffer;
                    }
                    this._pAttribData = this._pAttribBuffer.allocateData(pAttrDecl, pData);
                    this._pIndicesArray[this._iIndexSet].pAttribData = this._pAttribData;
                    this._pMap.flow(this._pAttribData);
                    return this._pAttribData !== null;
                }
                if(!pAttribData.extend(pAttrDecl, pData)) {
                    akra.logger.setSourceLocation("RenderData.ts", 135);
                    akra.logger.log('invalid data for allocation:', arguments);
                    ;
                    akra.logger.setSourceLocation("RenderData.ts", 136);
                    akra.logger.warning('cannot allocate attribute in data subset..');
                    ;
                    return false;
                }
                return true;
            };
            RenderData.prototype.allocateIndex = function /** @no-inline */(pDecl, pData) {
                var pAttrDecl = akra.createVertexDeclaration(pDecl);
                if(this.useAdvancedIndex()) {
                    return this._allocateAdvancedIndex(pAttrDecl, pData);
                }
                return this._allocateIndex(pAttrDecl, pData);
            };
            RenderData.prototype.getAdvancedIndexData = function /** @no-inline */(sSemantics) {
                return this._getData(sSemantics, true);
            };
            RenderData.prototype.addIndexSet = /**
            * Add new set of indices.
            */
            function /** @no-inline */(usePreviousDataSet, ePrimType, sName) {
                if (typeof usePreviousDataSet === "undefined") { usePreviousDataSet = true; }
                if (typeof ePrimType === "undefined") { ePrimType = 4 /* TRIANGLELIST */ ; }
                if (typeof sName === "undefined") { sName = null; }
                // if (this._pIndexData === null) {
                //     return false;
                // }
                if(usePreviousDataSet) {
                    this._pMap = this._pMap.clone(false);
                    if(!this._pMap) {
                        return -1;
                    }
                } else {
                    this._pMap = this._pBuffer.getEngine().createBufferMap();
                    this._pAttribData = null;
                }
                this._pMap.primType = ePrimType;
                this._pIndexData = null;
                this._iIndexSet = this._pIndicesArray.length;
                this._pIndicesArray.push({
                    pMap: this._pMap,
                    pIndexData: this._pIndexData,
                    pAttribData: this._pAttribData,
                    sName: sName,
                    pI2IDataCache: null,
                    pAdditionCache: null
                });
                return this._iIndexSet;
            };
            RenderData.prototype.getNumIndexSet = function /** @no-inline */() {
                return this._pIndicesArray.length;
            };
            RenderData.prototype.getIndexSetName = function /** @no-inline */(iSet) {
                if (typeof iSet === "undefined") { iSet = this._iIndexSet; }
                return this._pIndicesArray[iSet].sName;
            };
            RenderData.prototype.selectIndexSet = function /** @no-inline */(a) {
                var iSet = -1;
                if(akra.isString(arguments[0])) {
                    for(var i = 0; i < this._pIndicesArray.length; ++i) {
                        if(this._pIndicesArray[i].sName === arguments[0]) {
                            iSet = i;
                            break;
                        }
                    }
                    ;
                    if(iSet < 0) {
                        return false;
                    }
                }
                var pIndexSet = this._pIndicesArray[iSet];
                if(pIndexSet) {
                    this._pMap = pIndexSet.pMap;
                    this._pIndexData = pIndexSet.pIndexData;
                    this._pAttribData = pIndexSet.pAttribData;
                    this._iIndexSet = iSet;
                    return true;
                }
                return false;
            };
            RenderData.prototype.getIndexSet = /**
            * Get number of current index set.
            */
            function /** @no-inline */() {
                return this._iIndexSet;
            };
            RenderData.prototype.useAdvancedIndex = /**
            * Specifies uses advanced index.
            */
            function /** @no-inline */() {
                return (this._eOptions & 65536 /* ADVANCED_INDEX */ ) != 0;
            };
            RenderData.prototype.useSingleIndex = function /** @no-inline */() {
                return (this._eOptions & 131072 /* SINGLE_INDEX */ ) != 0;
            };
            RenderData.prototype.useMultiIndex = function /** @no-inline */() {
                return (this._eOptions & 131072 /* SINGLE_INDEX */ ) == 0;
            };
            RenderData.prototype.setRenderable = function /** @no-inline */(iIndexSet, bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                if(arguments.length < 2) {
                    //mark all render data as renderable or not
                    if(arguments[0]) {
                        ((this._eOptions) |= (262144 /* RENDERABLE */ ));
                    } else {
                        ((this._eOptions) &= ~(262144 /* RENDERABLE */ ));
                    }
                }
                //mark index set is renderable or not
                (bValue ? ((this._iRenderable) |= (1 << (iIndexSet))) : ((this._iRenderable) &= ~(1 << (iIndexSet))));
            };
            RenderData.prototype.isRenderable = function /** @no-inline */(iIndexSet) {
                if(arguments.length > 0) {
                    //is this index set renderable ?
                    return ((this._iRenderable & (1 << (iIndexSet))) != 0);
                }
                //is this data renderable ?
                return this._eOptions & 262144 /* RENDERABLE */  ? true : false;
            };
            RenderData.prototype.hasSemantics = /**
            * Check whether the semantics used in this data set.
            */
            function /** @no-inline */(sSemantics, bSearchComplete) {
                if (typeof bSearchComplete === "undefined") { bSearchComplete = true; }
                return this._getFlow(sSemantics, bSearchComplete) !== null;
            };
            RenderData.prototype.getDataLocation = function /** @no-inline */(sSemantics) {
                var pData = this._getData(sSemantics);
                return pData ? pData.byteLength : -1;
            };
            RenderData.prototype.getIndices = /**
            * Get indices that uses in current index set.
            */
            function /** @no-inline */() {
                return this._pIndexData;
            };
            RenderData.prototype.getPrimitiveCount = /**
            * Get number of primitives for rendering.
            */
            function /** @no-inline */() {
                return this._pMap.primCount;
            };
            RenderData.prototype.index = function /** @no-inline */(data, sSemantics, useSame, iBeginWith) {
                iBeginWith = iBeginWith || 0;
                useSame = useSame || false;
                var iData = arguments[0];
                var iFlow = -1;
                var iAddition, iRealAddition, iPrevAddition;
                var pFlow;
                var pData, pRealData;
                var pFloat32Array;
                var iIndexOffset;
                var pIndexData = this._pIndexData;
                var sData;
                var iStride;
                var iTypeSize = 4 /* BYTES_PER_FLOAT */ ;
                if(this.useAdvancedIndex()) {
                    pRealData = this._getData(arguments[0]);
                    iAddition = pRealData.byteLength;
                    iStride = pRealData.stride;
                    //индекс, который подал юзер
                    pData = this._getData(sSemantics, true);
                    pData.applyModifier(sSemantics, function /** @no-inline */(pTypedData) {
                        for(var i = 0; i < pTypedData.length; i++) {
                            pTypedData[i] = (pTypedData[i] * iStride + iAddition) / iTypeSize;
                        }
                        ;
                    });
                    iData = pData.byteLength;
                    sSemantics = "INDEX_" + sSemantics;
                } else if(akra.isString(arguments[0])) {
                    if(arguments[0] === "TEXCOORD") {
                        iData = this.getDataLocation("TEXCOORD0");
                    } else {
                        iData = this.getDataLocation(arguments[0]);
                    }
                    akra.logger.setSourceLocation("RenderData.ts", 370);
                    akra.logger.assert(iData >= 0, "cannot find data with semantics: " + arguments[0]);
                    ;
                }
                pFlow = this._getFlow(iData);
                if(pFlow === null) {
                    return false;
                }
                iFlow = pFlow.flow;
                iIndexOffset = (pIndexData).getVertexDeclaration().findElement(sSemantics).offset;
                pFloat32Array = (pIndexData).getTypedData(sSemantics);
                iAddition = iData;
                if(!pFloat32Array) {
                    return false;
                }
                iStride = pFlow.data.stride;
                if(this.indexSet.pAdditionCache[iIndexOffset] !== iAddition) {
                    if(!useSame) {
                        iPrevAddition = this.indexSet.pAdditionCache[iIndexOffset] || 0;
                        iRealAddition = iAddition - iPrevAddition;
                        for(var i = 0; i < pFloat32Array.length; i++) {
                            pFloat32Array[i] = (pFloat32Array[i] * iStride + iRealAddition) / iTypeSize;
                        }
                        ;
                    } else {
                        iRealAddition = iAddition;
                        for(var i = 0; i < pFloat32Array.length; i++) {
                            pFloat32Array[i] = (iBeginWith + iRealAddition) / iTypeSize;
                        }
                        ;
                    }
                    //remeber addition, that we added to index.
                    this.indexSet.pAdditionCache[iIndexOffset] = iAddition;
                    if(!(pIndexData).setData(pFloat32Array, sSemantics)) {
                        return false;
                    }
                }
                return this._pMap.mapping(iFlow, pIndexData, sSemantics);
            };
            RenderData.prototype._setup = /*Setup.*/
            function /** @no-inline */(pCollection, iId, ePrimType, eOptions) {
                if (typeof ePrimType === "undefined") { ePrimType = 4 /* TRIANGLELIST */ ; }
                if (typeof eOptions === "undefined") { eOptions = 0; }
                if(this._pBuffer === null && arguments.length < 2) {
                    return false;
                }
                this.setRenderable(true);
                this._eOptions |= eOptions;
                this._pBuffer = pCollection;
                this._iId = iId;
                //setup buffer map
                this._pMap = pCollection.getEngine().createBufferMap();
                this._pMap.primType = ePrimType;
                //setup default index set
                this._pIndicesArray.push({
                    sName: ".main",
                    pMap: this._pMap,
                    pIndexData: null,
                    pAttribData: null,
                    pI2IDataCache: {
                    },
                    pAdditionCache: null
                });
                akra.logger.setSourceLocation("RenderData.ts", 447);
                akra.logger.assert(this.useSingleIndex() === false, "single indexed data not implimented");
                ;
                return true;
            };
            RenderData.prototype._allocateData = function /** @no-inline */(pDataDecl, pData, eType) {
                if(eType === 3 /* DIRECT */ ) {
                    return this.allocateAttribute(pDataDecl, pData) ? 0 : -1;
                }
                var iFlow;
                var pVertexData = this._pBuffer._allocateData(pDataDecl, pData);
                var iOffset = pVertexData.byteLength;
                iFlow = this._addData(pVertexData, undefined, eType);
                if(iFlow < 0) {
                    akra.logger.setSourceLocation("RenderData.ts", 467);
                    akra.logger.log("invalid data", pDataDecl, pData);
                    ;
                    akra.logger.setSourceLocation("RenderData.ts", 468);
                    akra.logger.error("cannot allocate data for submesh");
                    ;
                    return -1;
                }
                return iOffset;
            };
            RenderData.prototype._addData = /**
            * Add vertex data to this render data.
            */
            function /** @no-inline */(pVertexData, iFlow, eType) {
                if (typeof eType === "undefined") { eType = 3 /* DIRECT */ ; }
                if((arguments.length < 3 && this.useAdvancedIndex()) || arguments[2] === 2 /* I2I */ ) {
                    return this._registerData(pVertexData);
                }
                return (!akra.isDef(iFlow) ? this._pMap.flow(pVertexData) : this._pMap.flow(iFlow, pVertexData));
            };
            RenderData.prototype._registerData = /**
            * Register data in this render.
            * Necessary for index to index mode, when data realy
            * not using in this render data for building final buffer map.
            */
            function /** @no-inline */(pVertexData) {
                'use strict';
                var iOffset = pVertexData.byteLength;
                var pDataDecl = pVertexData.getVertexDeclaration();
                //необходимо запоминать расположение данных, которые подаются,
                //т.к. иначе их потом нельзя будет найти среди других данных
                for(var i = 0; i < pDataDecl.length; i++) {
                    this.indexSet.pI2IDataCache[pDataDecl[i].eUsage] = iOffset;
                }
                return 0;
            };
            RenderData.prototype._allocateAdvancedIndex = function /** @no-inline */(pAttrDecl, pData) {
                var pDecl = akra.createVertexDeclaration(pAttrDecl);
                var nCount = pData.byteLength / pDecl.stride;
                //TODO: remove index dublicates
                var iIndLoc = this._allocateData(pAttrDecl, pData, 1 /* INDEXED */ );
                var pI2IData = new Float32Array(nCount);
                var pI2IDecl = [];
                for(var i = 0; i < pDecl.length; i++) {
                    pI2IDecl.push(akra.VE_FLOAT('INDEX_' + pDecl[i].eUsage, 0));
                }
                ;
                for(var i = 0; i < pI2IData.length; i++) {
                    pI2IData[i] = i;
                }
                ;
                if(!this._allocateIndex(pI2IDecl, pI2IData)) {
                    this.releaseData(iIndLoc);
                    pI2IData = null;
                    pI2IDecl = null;
                    akra.logger.setSourceLocation("RenderData.ts", 540);
                    akra.logger.warning('cannot allocate index for index in render data subset');
                    ;
                    return false;
                }
                return true;
            };
            RenderData.prototype._createIndex = function /** @no-inline */(pAttrDecl, pData) {
                'use strict';
                if(!this._pIndexBuffer) {
                    if(this.useMultiIndex()) {
                        this._pIndexBuffer = this._pBuffer.getEngine().getResourceManager().createVertexBuffer('subset_' + akra.sid());
                        this._pIndexBuffer.create(8 /* BACKUP_COPY */ );
                    } else {
                        //TODO: add support for sinle indexed mesh.
                                            }
                }
                this._pIndexData = (this._pIndexBuffer).allocateData(pAttrDecl, pData);
                this.indexSet.pIndexData = this._pIndexData;
                this.indexSet.pAdditionCache = {
                };
                return this._pIndexData !== null;
            };
            RenderData.prototype._allocateIndex = function /** @no-inline */(pDecl, pData) {
                'use strict';
                var pAttrDecl = akra.createVertexDeclaration(pDecl);
                var pIndexData = this._pIndexData;
                var pIndexBuffer = this._pIndexBuffer;
                var pBuffer = this._pBuffer;
                for(var i = 0; i < pAttrDecl.length; i++) {
                    if(pAttrDecl[i].eType !== 5126 /* FLOAT */ ) {
                        return false;
                    }
                }
                if(!this._pIndexData) {
                    return this._createIndex(pAttrDecl, pData);
                }
                if(!(this._pIndexData).extend(pAttrDecl, pData)) {
                    akra.logger.setSourceLocation("RenderData.ts", 601);
                    akra.logger.log('invalid data for allocation:', arguments);
                    ;
                    akra.logger.setSourceLocation("RenderData.ts", 602);
                    akra.logger.warning('cannot allocate index in data subset..');
                    ;
                    return false;
                }
                return true;
            };
            RenderData.prototype._setIndexLength = function /** @no-inline */(iLength) {
                var bResult = (this._pIndexData).resize(iLength);
                if(bResult) {
                    this._pMap._length = iLength;
                }
                return bResult;
            };
            RenderData.prototype._getFlow = function /** @no-inline */(a, b) {
                if(typeof arguments[0] === 'string') {
                    return this._pMap.getFlow(arguments[0], arguments[1]);
                }
                for(var i = 0, n = this._pMap.limit; i < n; ++i) {
                    var pFlow = this._pMap.getFlow(i, false);
                    if(pFlow.data && pFlow.data.byteLength === arguments[0]) {
                        return pFlow;
                    }
                }
                return null;
            };
            RenderData.prototype._getData = function /** @no-inline */(a, b) {
                var pFlow;
                if(this.useAdvancedIndex() && arguments.length < 2) {
                    if(typeof arguments[0] === 'string') {
                        return this._getData(this.indexSet.pI2IDataCache[arguments[0]]);
                    }
                    return this._pBuffer.getData(arguments[0]);
                }
                if(typeof arguments[0] === 'string') {
                    for(var i = 0, n = this._pMap.limit; i < n; ++i) {
                        pFlow = this._pMap.getFlow(i, false);
                        if(pFlow.data != null && pFlow.data.hasSemantics(arguments[0])) {
                            return pFlow.data;
                        }
                    }
                    //this._pBuffer._getData(arguments[0]);        	    return null;
                                    }
                pFlow = this._getFlow(arguments[0]);
                return pFlow === null ? null : pFlow.data;
            };
            RenderData.prototype._draw = /**
            * Draw this data.
            */
            function /** @no-inline */() {
                for(var i = 0; i < this._pIndicesArray.length; i++) {
                    if(this.isRenderable(i)) {
                        this._pIndicesArray[i].pMap._draw();
                    }
                }
            };
            RenderData.prototype.toString = //applyMe(): bool;
            function /** @no-inline */() {
                var s;
                s = 'RENDER DATA SUBSET: #' + this._iId + '\n';
                s += '        ATTRIBUTES: ' + (this._pAttribData ? 'TRUE' : 'FALSE') + '\n';
                s += '----------------------------------------------------------------\n';
                s += this._pMap.toString();
                return s;
            };
            return RenderData;
        })(akra.util.ReferenceCounter);
        render.RenderData = RenderData;        
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (render) {
        var RenderDataCollection = (function (_super) {
            __extends(RenderDataCollection, _super);
            function /** @no-inline */RenderDataCollection(pEngine, eOptions) {
                if (typeof eOptions === "undefined") { eOptions = 0; }
                        _super.call(this);
                this._pDataBuffer = null;
                this._pEngine = null;
                this._eDataOptions = 0;
                this._pDataArray = [];
                this._pEngine = pEngine;
                this.setup(eOptions);
            }
            Object.defineProperty(RenderDataCollection.prototype, "buffer", {
                get: function /** @inline */() {
                    return this._pDataBuffer;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderDataCollection.prototype, "length", {
                get: function /** @inline */() {
                    return this._pDataArray.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderDataCollection.prototype, "byteLength", {
                get: function /** @inline */() {
                    return this._pDataBuffer.byteLength;
                },
                enumerable: true,
                configurable: true
            });
            RenderDataCollection.prototype.clone = function /** @no-inline */(pSrc) {
                akra.logger.setSourceLocation("render/RenderDataCollection.ts", 37);
                akra.logger.criticalError("TODO: RenderDataCollection::clone();");
                ;
                return false;
            };
            RenderDataCollection.prototype.getEngine = function /** @no-inline */() {
                return this._pEngine;
            };
            RenderDataCollection.prototype.getOptions = function /** @no-inline */() {
                return this._eDataOptions;
            };
            RenderDataCollection.prototype.getData = function /** @no-inline */(a) {
                var pBuffer = this._pDataBuffer;
                var pData;
                var n;
                if(!akra.isNull(pBuffer)) {
                    n = this._pDataBuffer.length;
                    if(akra.isString(arguments[0])) {
                        for(var i = 0; i < n; i++) {
                            pData = pBuffer.getVertexData(i);
                            if(pData.hasSemantics(arguments[0])) {
                                return pData;
                            }
                        }
                        ;
                    } else {
                        for(var i = 0; i < n; i++) {
                            pData = pBuffer.getVertexData(i);
                            if(pData.byteLength === arguments[0]) {
                                return pData;
                            }
                        }
                        ;
                    }
                }
                return null;
            };
            RenderDataCollection.prototype._allocateData = function /** @no-inline */(pDecl, pData) {
                if(!this._pDataBuffer) {
                    this.createDataBuffer();
                }
                var pVertexDecl = akra.createVertexDeclaration(pDecl);
                var pVertexData;
                if((arguments.length < 2) || akra.isNumber(arguments[1]) || akra.isNull(arguments[1])) {
                    pVertexData = this._pDataBuffer.getEmptyVertexData(pData || 1, pVertexDecl);
                } else {
                    pVertexData = this._pDataBuffer.allocateData(pVertexDecl, pData);
                }
                akra.logger.setSourceLocation("render/RenderDataCollection.ts", 108);
                akra.logger.assert(pVertexData !== null, "cannot allocate data:\n" + pVertexDecl.toString());
                ;
                return pVertexData;
            };
            RenderDataCollection.prototype.allocateData = function /** @no-inline */(pDecl, pData, isCommon) {
                if (typeof isCommon === "undefined") { isCommon = true; }
                var pVertexData;
                var pDataDecl = akra.createVertexDeclaration(pDecl);
                for(var i = 0; i < pDataDecl.length; i++) {
                    if(this.getData(pDataDecl[i].eUsage) !== null && pDataDecl[i].nCount !== 0) {
                        akra.logger.setSourceLocation("render/RenderDataCollection.ts", 127);
                        akra.logger.warning("data buffer already contains data with similar vertex decloration <" + pDataDecl[i].eUsage + ">.");
                        ;
                    }
                }
                ;
                pVertexData = this._allocateData(pDataDecl, pData);
                if(isCommon) {
                    for(var i = 0; i < this._pDataArray.length; ++i) {
                        this._pDataArray[i]._addData(pVertexData);
                    }
                }
                return pVertexData.byteLength;
            };
            RenderDataCollection.prototype.getDataLocation = function /** @no-inline */(sSemantics) {
                if(this._pDataBuffer) {
                    var pData;
                    for(var i = 0, n = this._pDataBuffer.length; i < n; i++) {
                        pData = this._pDataBuffer.getVertexData(i);
                        if(pData.hasSemantics(sSemantics)) {
                            return pData.byteLength;
                        }
                    }
                    ;
                }
                return -1;
            };
            RenderDataCollection.prototype.createDataBuffer = function /** @no-inline */() {
                //TODO: add support for eOptions
                var iVbOption = 0;
                var eOptions = this._eDataOptions;
                if(eOptions & akra.ERenderDataBufferOptions.VB_READABLE) {
                    (true ? ((iVbOption) |= (1 << (1 << (4 /* READABLE */ )))) : ((iVbOption) &= ~(1 << (1 << (4 /* READABLE */ )))));
                }
                //trace('creating new video buffer for render data buffer ...');
                this._pDataBuffer = this._pEngine.getResourceManager().createVideoBuffer("render_data_buffer" + "_" + akra.sid());
                this._pDataBuffer.create(iVbOption);
                this._pDataBuffer.addRef();
                return this._pDataBuffer !== null;
            };
            RenderDataCollection.prototype.getRenderData = function /** @no-inline */(iSubset) {
                return this._pDataArray[iSubset];
            };
            RenderDataCollection.prototype.getEmptyRenderData = function /** @no-inline */(ePrimType, eOptions) {
                if (typeof eOptions === "undefined") { eOptions = 0; }
                var iSubsetId = this._pDataArray.length;
                var pDataset = new render.RenderData(this);
                eOptions |= this._eDataOptions;
                if(!pDataset._setup(this, iSubsetId, ePrimType, eOptions)) {
                    akra.logger.setSourceLocation("render/RenderDataCollection.ts", 186);
                    akra.logger.error("cannot setup submesh...");
                    ;
                }
                this._pDataArray.push(pDataset);
                return pDataset;
            };
            RenderDataCollection.prototype._draw = function /** @no-inline */(iSubset) {
                if(arguments.length > 0) {
                    this._pDataArray[iSubset]._draw();
                }
                for(var i = 0; i < this._pDataArray.length; i++) {
                    this._pDataArray[i]._draw();
                }
                ;
            };
            RenderDataCollection.prototype.destroy = function /** @no-inline */() {
                this._pDataArray = null;
                if(this._pDataBuffer) {
                    // this._pDataBuffer.release();
                    this._pDataBuffer.destroy();
                    this._pDataBuffer = null;
                }
                this._pEngine = null;
                this._eDataOptions = 0;
            };
            RenderDataCollection.prototype.setup = function /** @no-inline */(eOptions) {
                if (typeof eOptions === "undefined") { eOptions = 0; }
                this._eDataOptions = eOptions;
            };
            return RenderDataCollection;
        })(akra.util.ReferenceCounter);
        render.RenderDataCollection = RenderDataCollection;        
        // inline isValid(): bool { return true; }
        // inline isDynamic(): bool { return false; }
        // inline isStatic(): bool { return false; }
        // inline isStream(): bool { return false; }
        // inline isReadable(): bool { return true; }
        // inline isBackupPresent(): bool { return true; }
        function /** @no-inline */createRenderDataCollection(pEngine, eOptions) {
            if (typeof eOptions === "undefined") { eOptions = 0; }
            return new RenderDataCollection(pEngine, eOptions);
        }
        render.createRenderDataCollection = createRenderDataCollection;
    })(akra.render || (akra.render = {}));
    var render = akra.render;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        var BufferMap = (function (_super) {
            __extends(BufferMap, _super);
            function /** @no-inline */BufferMap(pEngine) {
                        _super.call(this);
                this._pFlows = null;
                this._pMappers = null;
                this._pIndex = null;
                this._nLength = 0;
                this._pCompleteFlows = null;
                this._nCompleteFlows = 0;
                this._nCompleteVideoBuffers = 0;
                this._pCompleteVideoBuffers = null;
                this._nUsedFlows = 0;
                this._pEngine = null;
                this._nStartIndex = 0;
                this._pBuffersCompatibleMap = null;
                this._pEngine = pEngine;
                this.reset();
            }
            Object.defineProperty(BufferMap.prototype, "primType", {
                get: function /** @inline */() {
                    return this._pIndex ? this._pIndex.getPrimitiveType() : this._ePrimitiveType;
                },
                set: function /** @inline */(eType) {
                    this._ePrimitiveType = eType;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "primCount", {
                get: function /** @inline */() {
                    return akra.data.IndexData.getPrimitiveCount(this._ePrimitiveType, this.length);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "index", {
                get: function /** @inline */() {
                    return this._pIndex;
                },
                set: function /** @inline */(pIndexData) {
                    if(this._pIndex === pIndexData) {
                        return;
                    }
                    this._pIndex = pIndexData;
                    this.update();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "limit", {
                get: function /** @inline */() {
                    return this._pFlows.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "length", {
                get: function /** @inline */() {
                    return (this._pIndex ? this._pIndex.getPrimitiveCount() : this._nLength);
                },
                set: function /** @inline */(nLength) {
                    this._nLength = Math.min(this._nLength, nLength);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "_length", {
                set: function /** @inline */(nLength) {
                    this._nLength = nLength;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "startIndex", {
                get: function /** @inline */() {
                    return this._nStartIndex;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "size", {
                get: function /** @inline */() {
                    return this._nCompleteFlows;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "flows", {
                get: function /** @inline */() {
                    return this._pCompleteFlows;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "mappers", {
                get: function /** @inline */() {
                    return this._pMappers;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BufferMap.prototype, "offset", {
                get: function /** @inline */() {
                    return (this._pIndex ? this._pIndex.byteOffset : 0);
                },
                enumerable: true,
                configurable: true
            });
            BufferMap.prototype._draw = function /** @no-inline */() {
                this._pEngine.getRenderer().getActiveProgram().applyBufferMap(this);
                akra.isNull(this._pIndex) ? this.drawArrays() : this.drawElements();
            };
            BufferMap.prototype.drawArrays = function /** @inline */() {
                (this._pEngine.getRenderer()).getWebGLContext().drawArrays(akra.webgl.getWebGLPrimitiveType(this._ePrimitiveType), this._nStartIndex, this._nLength);
            };
            BufferMap.prototype.drawElements = function /** @inline */() {
                (this._pEngine.getRenderer()).getWebGLContext().drawElements(this.primCount, this._pIndex.getPrimitiveCount(), akra.webgl.getWebGLPrimitiveType(this._ePrimitiveType), this._pIndex.byteOffset / 4);
                //FIXME: offset of drawElement() in Glintptr = long long = 32 byte???
                            };
            BufferMap.prototype.getFlow = function /** @no-inline */(iFlow, bComplete) {
                if (typeof bComplete === "undefined") { bComplete = true; }
                if(akra.isString(arguments[0])) {
                    var nTotal;
                    var pFlows;
                    if(bComplete) {
                        pFlows = this._pCompleteFlows;
                        nTotal = this._nCompleteFlows;
                    } else {
                        pFlows = this._pFlows;
                        nTotal = this._pFlows.length;
                    }
                    for(var i = 0; i < nTotal; ++i) {
                        if(!pFlows[i].data) {
                            continue;
                        }
                        if(pFlows[i].data.hasSemantics(arguments[0])) {
                            return pFlows[i];
                        }
                    }
                    return null;
                }
                if(bComplete) {
                    for(var i = 0, pFlows = this._pCompleteFlows; i < this._nCompleteFlows; ++i) {
                        if(pFlows[i].flow == iFlow) {
                            return pFlows[i];
                        }
                    }
                    return null;
                }
                return this._pFlows[iFlow];
            };
            BufferMap.prototype.reset = function /** @no-inline */() {
                this._pIndex = null;
                this._ePrimitiveType = 4 /* TRIANGLELIST */ ;
                var nFlowLimit = 16;
                /*webgl.maxVertexTextureImageUnits*/
                nFlowLimit = Math.min(16, akra.webgl.maxVertexAttributes);
                this._pMappers = [];
                this._pFlows = new Array(nFlowLimit);
                for(var i = 0; i < nFlowLimit; i++) {
                    this._pFlows[i] = {
                        flow: i,
                        data: null,
                        type: 0 /* UNMAPPABLE */ ,
                        mapper: null
                    };
                }
                this._nLength = akra.MAX_INT32;
                this._pCompleteFlows = new Array(nFlowLimit);
                this._nCompleteFlows = 0;
                this._nStartIndex = akra.MAX_INT32;
                this._pBuffersCompatibleMap = {
                };
                this._pCompleteVideoBuffers = new Array(nFlowLimit);
                this._nCompleteVideoBuffers = 0;
                this._nUsedFlows = 0;
            };
            BufferMap.prototype.flow = function /** @no-inline */(iFlow, pData) {
                var pFlow = null;
                var pVertexData = null;
                if(arguments.length < 2) {
                    pVertexData = arguments[0];
                    iFlow = (this._nUsedFlows++);
                }
                // trace(iFlow, '<<==', pVertexData.getVertexDeclaration().toString());
                // console.log((new Error).stack);
                pFlow = this._pFlows[iFlow];
                util.logger.setSourceLocation("util/BufferMap.ts", 218);
                util.logger.assert(iFlow < this.limit, 'Invalid strem. Maximum allowable number of stream ' + this.limit + '.');
                ;
                if(!pVertexData || pFlow.data === pVertexData) {
                    return -1;
                }
                if(pVertexData.buffer instanceof akra.core.pool.resources.VertexBuffer) {
                    pFlow.type = 0 /* UNMAPPABLE */ ;
                    this.length = pVertexData.length;
                    //this.startIndex = pVertexData.getStartIndex();
                    util.logger.setSourceLocation("util/BufferMap.ts", 229);
                    util.logger.assert(this.checkData(pVertexData), 'You can use several unmappable data flows from one buffer.');
                    ;
                    this.pushEtalon(pVertexData);
                } else {
                    pFlow.type = 1 /* MAPPABLE */ ;
                }
                pFlow.data = pVertexData;
                return this.update() ? iFlow : -1;
            };
            BufferMap.prototype.checkData = function /** @no-inline */(pData) {
                var pEtalon = this._pBuffersCompatibleMap[pData.getBufferHandle()];
                if(!pEtalon || pEtalon.byteOffset === pData.byteOffset) {
                    return true;
                }
                return false;
            };
            BufferMap.prototype.findMapping = /**@protected*/ function /** @no-inline */(pMap, eSemantics, iAddition) {
                util.logger.setSourceLocation("util/BufferMap.ts", 251);
                util.logger.assert(this.checkData(pMap), 'You can use several different maps from one buffer.');
                ;
                for(var i = 0, pMappers = this._pMappers, pExistsMap; i < pMappers.length; i++) {
                    pExistsMap = pMappers[i].data;
                    if(pExistsMap === pMap) {
                        //если уже заданные маппинг менял свой стартовый индекс(наприм��р при расширении)
                        //то необходимо сменить стартовый индекс на новый
                        if(pMappers[i].semantics === eSemantics && pMappers[i].addition == iAddition) {
                            return pMappers[i];
                        }
                    } else {
                        util.logger.setSourceLocation("util/BufferMap.ts", 263);
                        util.logger.assert(pExistsMap.getStartIndex() === pMap.getStartIndex(), 'You can not use maps with different indexing');
                        ;
                    }
                }
                return null;
            };
            BufferMap.prototype.mapping = function /** @no-inline */(iFlow, pMap, eSemantics, iAddition) {
                iAddition = iAddition || 0;
                var pMapper = this.findMapping(pMap, eSemantics, iAddition);
                var pFlow = this._pFlows[iFlow];
                util.logger.setSourceLocation("util/BufferMap.ts", 277);
                util.logger.assert(pFlow.data && pFlow.type === 1 /* MAPPABLE */ , 'Cannot mapping empty/unmappable flow.');
                ;
                util.logger.setSourceLocation("util/BufferMap.ts", 278);
                util.logger.assert(akra.isDef(pMap), 'Passed empty mapper.');
                ;
                if(!eSemantics) {
                    eSemantics = pMap.getVertexDeclaration()[0].eUsage;
                } else if(pMap.hasSemantics(eSemantics) === false) {
                    util.logger.setSourceLocation("util/BufferMap.ts", 284);
                    util.logger.error('Passed mapper does not have semantics: ' + eSemantics + '.');
                    ;
                    return false;
                }
                if(pMapper) {
                    if(pFlow.mapper === pMapper) {
                        return pMapper.semantics === eSemantics && pMapper.addition === iAddition ? true : false;
                    }
                } else {
                    pMapper = {
                        data: pMap,
                        semantics: eSemantics,
                        addition: iAddition
                    };
                    this._pMappers.push(pMapper);
                    this.length = pMap.length;
                    //this.startIndex = pMap.getStartIndex();
                    this.pushEtalon(pMap);
                }
                pFlow.mapper = pMapper;
                return this.update();
            };
            BufferMap.prototype.pushEtalon = function /** @no-inline */(pData) {
                this._pBuffersCompatibleMap[pData.getBufferHandle()] = pData;
            };
            BufferMap.prototype.update = function /** @no-inline */() {
                var pFlows = this._pFlows;
                var pFlow, pMapper;
                var isMappable = false;
                var pCompleteFlows = this._pCompleteFlows;
                var nCompleteFlows = 0;
                var pCompleteVideoBuffers = this._pCompleteVideoBuffers;
                var nCompleteVideoBuffers = 0;
                var nUsedFlows = 0;
                var pVideoBuffer;
                var isVideoBufferAdded = false;
                var nStartIndex = akra.MAX_INT32, nCurStartxIndex;
                for(var i = 0; i < pFlows.length; i++) {
                    pFlow = pFlows[i];
                    pMapper = pFlow.mapper;
                    isMappable = (pFlow.type === 1 /* MAPPABLE */ );
                    if(pFlow.data) {
                        nUsedFlows++;
                    }
                    if(pFlow.data === null || (isMappable && pMapper === null)) {
                        continue;
                    }
                    pCompleteFlows[nCompleteFlows++] = pFlow;
                    if(isMappable) {
                        nCurStartxIndex = pMapper.data.getStartIndex();
                        pVideoBuffer = pFlow.data.buffer;
                        for(var j = 0; j < nCompleteVideoBuffers; j++) {
                            if(pCompleteVideoBuffers[j] === pVideoBuffer) {
                                isVideoBufferAdded = true;
                                break;
                            }
                        }
                        if(!isVideoBufferAdded) {
                            pCompleteVideoBuffers[nCompleteVideoBuffers++] = pVideoBuffer;
                        }
                    } else {
                        nCurStartxIndex = pFlow.data.getStartIndex();
                    }
                    if(nStartIndex === akra.MAX_INT32) {
                        nStartIndex = nCurStartxIndex;
                        continue;
                    }
                    util.logger.setSourceLocation("util/BufferMap.ts", 363);
                    util.logger.assert(nStartIndex == nCurStartxIndex, 'You can not use a maps or unmappable buffers having different starting index.');
                    ;
                }
                this._nStartIndex = nStartIndex;
                this._nCompleteFlows = nCompleteFlows;
                this._nCompleteVideoBuffers = nCompleteVideoBuffers;
                this._nUsedFlows = nUsedFlows;
                return true;
            };
            BufferMap.prototype.clone = function /** @no-inline */(bWithMapping) {
                bWithMapping = akra.isDef(bWithMapping) ? bWithMapping : true;
                var pMap = new BufferMap(this._pEngine);
                for(var i = 0, pFlows = this._pFlows; i < pFlows.length; ++i) {
                    if(pFlows[i].data === null) {
                        continue;
                    }
                    if(pMap.flow(pFlows[i].flow, pFlows[i].data) < 0) {
                        pMap = null;
                        return null;
                    }
                    if(!bWithMapping) {
                        continue;
                    }
                    if(pFlows[i].mapper) {
                        pMap.mapping(pFlows[i].flow, pFlows[i].mapper.data, pFlows[i].mapper.semantics, pFlows[i].mapper.addition);
                    }
                }
                return pMap;
            };
            BufferMap.prototype.toString = function /** @no-inline */() {
                function /** @no-inline */_an(sValue, n, bBackward) {
                    sValue = String(sValue);
                    bBackward = bBackward || false;
                    if(sValue.length < n) {
                        for(var i = 0, l = sValue.length; i < n - l; ++i) {
                            if(!bBackward) {
                                sValue += ' ';
                            } else {
                                sValue = ' ' + sValue;
                            }
                        }
                    }
                    return sValue;
                }
                var s = '\n\n', t;
                s += '      Complete Flows     : OFFSET / SIZE   |   BUFFER / OFFSET   :      Mapping  / Shift    : OFFSET |    Additional    \n';
                t = '-------------------------:-----------------+---------------------:--------------------------:--------+------------------\n';
                // = '#%1 [ %2 ]           :     %6 / %7     |       %3 / %4       :         %5       :        |                  \n';
                // = '#%1 [ %2 ]           :     %6 / %7     |       %3 / %4       :         %5       :        |                  \n';
                s += t;
                for(var i = 0; i < this._nCompleteFlows; ++i) {
                    var pFlow = this._pCompleteFlows[i];
                    var pMapper = pFlow.mapper;
                    var pVertexData = pFlow.data;
                    var pDecl = pVertexData.getVertexDeclaration();
                    //trace(pMapper); window['pMapper'] = pMapper;
                    s += '#' + _an(pFlow.flow, 2) + ' ' + _an('[ ' + (pDecl.element(0).usage !== akra.DeclUsages.END ? pDecl.element(0).usage : '<end>') + ' ]', 20) + ' : ' + _an(pDecl.element(0).offset, 6, true) + ' / ' + _an(pDecl.element(0).size, 6) + ' | ' + _an(pVertexData.getBufferHandle(), 8, true) + ' / ' + _an(pVertexData.byteOffset, 8) + ' : ' + (pMapper ? _an(pMapper.semantics, 15, true) + ' / ' + _an(pMapper.addition, 7) + ': ' + _an(pMapper.data.getVertexDeclaration().findElement(pMapper.semantics).offset, 6) : _an('-----', 25) + ': ' + _an('-----', 6)) + ' |                  \n';
                    for(var j = 1; j < pDecl.length; ++j) {
                        s += '    ' + _an('[ ' + (pDecl.element(j).usage !== akra.DeclUsages.END ? pDecl.element(j).usage : '<end>') + ' ]', 20) + ' : ' + _an(pDecl[j].iOffset, 6, true) + ' / ' + _an(pDecl[j].iSize, 6) + ' |                     :                          :        |                  \n';
                    }
                    s += t;
                }
                ;
                s += '=================================================================\n';
                s += '      PRIMITIVE TYPE : ' + '0x' + Number(this.primType).toString(16) + '\n';
                s += '     PRIMITIVE COUNT : ' + this.primCount + '\n';
                s += '         START INDEX : ' + this.startIndex + '\n';
                s += '              LENGTH : ' + this.length + '\n';
                s += '  USING INDEX BUFFER : ' + (this.index ? 'TRUE' : 'FALSE') + '\n';
                s += '=================================================================\n';
                return s + '\n\n';
            };
            return BufferMap;
        })(util.ReferenceCounter);        
        function /** @no-inline */createBufferMap(pEngine) {
            return new BufferMap(pEngine);
        }
        util.createBufferMap = createBufferMap;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (animation) {
        var AnimationController = (function () {
            function /** @no-inline */AnimationController(pEngine, iOptions) {
                if (typeof iOptions === "undefined") { iOptions = 0; }
                this._pAnimations = [];
                this._eOptions = 0;
                this._pActiveAnimation = null;
                this._fnPlayAnimation = null;
                this._pEngine = pEngine;
                this.setOptions(iOptions);
            }
            Object.defineProperty(AnimationController.prototype, "totalAnimations", {
                get: function /** @inline */() {
                    return this._pAnimations.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AnimationController.prototype, "active", {
                get: function /** @inline */() {
                    return this._pActiveAnimation;
                },
                enumerable: true,
                configurable: true
            });
            AnimationController.prototype.getEngine = function /** @no-inline */() {
                return this._pEngine;
            };
            AnimationController.prototype.setOptions = function /** @no-inline */(iOptions) {
            };
            AnimationController.prototype.addAnimation = function /** @no-inline */(pAnimation) {
                if(this.findAnimation(pAnimation.name)) {
                    akra.logger.setSourceLocation("animation/AnimationController.ts", 41);
                    akra.logger.warning("Animation with name <" + pAnimation.name + "> already exists in this controller");
                    ;
                    return false;
                }
                //LOG('animation controller :: add animation >> ', pAnimation.name);
                this._pAnimations.push(pAnimation);
                this._pActiveAnimation = pAnimation;
            };
            AnimationController.prototype.removeAnimation = function /** @no-inline */() {
                var pAnimation = this.findAnimation(arguments[0]);
                var pAnimations = this._pAnimations;
                for(var i = 0; i < pAnimations.length; ++i) {
                    if(pAnimations[i] === pAnimation) {
                        pAnimations.splice(i, 1);
                        akra.logger.setSourceLocation("animation/AnimationController.ts", 58);
                        akra.logger.log("animation controller :: remove animation >> ", pAnimation.name);
                        ;
                        return true;
                    }
                }
                return false;
            };
            AnimationController.prototype.findAnimation = function /** @no-inline */(pAnimation) {
                var pAnimations = this._pAnimations;
                var iAnimation;
                var sAnimation;
                if(akra.isString(arguments[0])) {
                    sAnimation = arguments[0];
                    for(var i = 0; i < pAnimations.length; ++i) {
                        if(pAnimations[i].name === sAnimation) {
                            return pAnimations[i];
                        }
                    }
                    return null;
                }
                if(typeof arguments[0] === 'number') {
                    iAnimation = arguments[0];
                    return pAnimations[iAnimation] || null;
                }
                return arguments[0];
            };
            AnimationController.prototype.getAnimation = function /** @no-inline */(iAnim) {
                return this._pAnimations[iAnim];
            };
            AnimationController.prototype.setAnimation = function /** @no-inline */(iAnimation, pAnimation) {
                akra.logger.setSourceLocation("animation/AnimationController.ts", 99);
                akra.logger.assert(iAnimation < this._pAnimations.length, 'invalid animation slot');
                ;
                this._pAnimations[iAnimation] = pAnimation;
            };
            AnimationController.prototype.bind = function /** @no-inline */(pTarget) {
                var pAnimations = this._pAnimations;
                for(var i = 0; i < pAnimations.length; ++i) {
                    pAnimations[i].attach(pTarget);
                }
            };
            AnimationController.prototype.play = function /** @no-inline */(pAnimation, fRealTime) {
                var pAnimationNext = this.findAnimation(arguments[0]);
                var pAnimationPrev = this._pActiveAnimation;
                if(pAnimationNext && pAnimationNext !== pAnimationPrev) {
                    if(this._fnPlayAnimation) {
                        this._fnPlayAnimation(pAnimationNext);
                    }
                    //LOG('controller::play(', pAnimationNext.name, ')', pAnimationNext);
                    if(pAnimationPrev) {
                        pAnimationPrev.stop(fRealTime);
                    }
                    pAnimationNext.play(fRealTime);
                    this._pActiveAnimation = pAnimationNext;
                    return true;
                }
                return false;
            };
            AnimationController.prototype.update = function /** @no-inline */(fTime) {
                if(this._pActiveAnimation) {
                    this._pActiveAnimation.apply(fTime);
                }
            };
            return AnimationController;
        })();
        animation.AnimationController = AnimationController;        
        function /** @no-inline */createController(pEngine, iOptions) {
            return new AnimationController(pEngine, iOptions);
        }
        animation.createController = createController;
    })(akra.animation || (akra.animation = {}));
    var animation = akra.animation;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        (function (EDepsManagerStates) {
            EDepsManagerStates._map = [];
            EDepsManagerStates._map[0] = "IDLE";
            EDepsManagerStates.IDLE = 0;
            EDepsManagerStates._map[1] = "LOADING";
            EDepsManagerStates.LOADING = 1;
        })(util.EDepsManagerStates || (util.EDepsManagerStates = {}));
        var EDepsManagerStates = util.EDepsManagerStates;
        var DepsManager = (function () {
            function /** @no-inline */DepsManager(pEngine) {
                /**@protected*/ this._eState = 0 /* IDLE */ ;
                this._iGuid = eval("this._iGuid || akra.sid()");
                this._pUnicastSlotMap = null;
                this._pBroadcastSlotList = null;
                this._pEngine = pEngine;
            }
            DepsManager.prototype.getEngine = function /** @inline */() {
                return this._pEngine;
            };
            DepsManager.prototype.load = function /** @no-inline */(pDeps, sRoot) {
                if (typeof sRoot === "undefined") { sRoot = null; }
                if(!akra.isDefAndNotNull(pDeps)) {
                    return false;
                }
                if(this._eState === 1 /* LOADING */ ) {
                    util.logger.setSourceLocation("util/DepsManager.ts", 33);
                    util.logger.warning("deps manager in loading state");
                    ;
                    return false;
                }
                this.normalizeDepsPaths(pDeps, sRoot);
                this.createDepsResources(pDeps);
                this.loadDeps(pDeps);
                return true;
            };
            DepsManager.prototype.walk = function /** @no-inline */(pDeps, fn, iDepth) {
                if (typeof iDepth === "undefined") { iDepth = 0; }
                var pFiles = pDeps.files;
                if(akra.isDefAndNotNull(pFiles)) {
                    //normilize pathes to deps
                    for(var i = 0; i < pFiles.length; ++i) {
                        fn.call(this, pDeps, i, iDepth);
                    }
                }
                if(akra.isDefAndNotNull(pDeps.deps)) {
                    this.walk(pDeps.deps, fn, ++iDepth);
                }
            };
            DepsManager.prototype.normalizeDepsPaths = function /** @no-inline */(pDeps, sRoot) {
                this.walk(pDeps, function /** @no-inline */(pDeps, i) {
                    pDeps.files[i] = (sRoot || "") + "/" + pDeps.files[i];
                });
            };
            DepsManager.prototype.createDepsResources = function /** @no-inline */(pDeps) {
                var pRmgr = this.getEngine().getResourceManager();
                this.walk(pDeps, function /** @no-inline */(pDeps, i) {
                    var pFiles = pDeps.files;
                    switch(util.pathinfo(pFiles[i]).ext.toLowerCase()) {
                        case "afx":
                            if(!pRmgr.effectDataPool.findResource(pFiles[i])) {
                                util.logger.setSourceLocation("util/DepsManager.ts", 72);
                                util.logger.log("effectDataPool.createResource(" + pFiles[i] + ")");
                                ;
                                pRmgr.effectDataPool.createResource(pFiles[i]);
                            }
                            break;
                    }
                });
            };
            DepsManager.prototype.loadDeps = function /** @no-inline */(pDeps) {
                var _this = this;
                var pRmgr = this.getEngine().getResourceManager();
                var pRes;
                //if got empty dependency.
                if(!akra.isArray(pDeps.files) || pDeps.files.length === 0) {
                    this._onDependencyLoad(pDeps);
                }
                //walk single deps level
                this.walk({
                    files: pDeps.files
                }, function /** @no-inline */(pDep, i) {
                    var pFiles = pDeps.files;
                    var pManager = _this;
                    switch(util.pathinfo(pFiles[i]).ext.toLowerCase()) {
                        case "gr":
                            akra.io.fopen(pFiles[i], "r").read(function /** @no-inline */(pErr, sData) {
                                if(!akra.isNull(pErr)) {
                                    pManager.error(pErr);
                                }
                                //WARNING: only for HLSL grammar files.
                                akra.util.initAFXParser(sData);
                                pManager._onDependencyLoad(pDeps, i);
                            });
                            break;
                        case "afx":
                            pRes = pRmgr.effectDataPool.findResource(pFiles[i]);
                            if(pRes.loadResource(pFiles[i])) {
                                pManager._handleResourceEventOnce(pRes, "loaded", function /** @no-inline */(pItem) {
                                    util.logger.setSourceLocation("util/DepsManager.ts", 113);
                                    util.logger.log("[ LOADED ]  effectDataPool.loadResource(" + pFiles[i] + ")");
                                    ;
                                    pManager._onDependencyLoad(pDeps, i);
                                });
                            } else {
                                _this.error(new Error("could not laod resource: " + pFiles[i]));
                            }
                            break;
                        default:
                            util.logger.setSourceLocation("util/DepsManager.ts", 125);
                            util.logger.warning("dependence " + pFiles[i] + " unknown, and will be skipped.");
                            ;
                    }
                });
            };
            DepsManager.prototype._handleResourceEventOnce = function /** @no-inline */(pRsc, sSignal, fnHandler) {
                var fn;
                fn = function /** @no-inline */(pItem) {
                    fnHandler(pItem);
                    pRsc.unbind(sSignal, fn);
                };
                pRsc.bind(sSignal, fn);
            };
            DepsManager.prototype._onDependencyLoad = function /** @no-inline */(pDeps, n) {
                // debug_assert(isDefAndNotNull(pDeps.files) && isString(pDeps.files[i]), "something going wrong...");
                if(akra.isDef(n)) {
                    util.logger.setSourceLocation("util/DepsManager.ts", 145);
                    util.logger.log("loaded dependency: " + pDeps.files[n]);
                    ;
                    pDeps.files[n] = null;
                }
                for(var i = 0; i < pDeps.files.length; ++i) {
                    if(!akra.isNull(pDeps.files[i])) {
                        util.logger.setSourceLocation("util/DepsManager.ts", 151);
                        util.logger.log("waiting for > " + pDeps.files[i]);
                        ;
                        return;
                    }
                }
                ;
                if(akra.isDefAndNotNull(pDeps.deps)) {
                    this.loadDeps(pDeps.deps);
                } else {
                    this.loaded();
                }
            };
            DepsManager._pEventTable = new akra.events.EventTable();
            DepsManager.prototype.getEventTable = function /** @inline */() {
                return DepsManager._pEventTable;
            };
            DepsManager.prototype.getGuid = function /** @no-inline */() {
                return this._iGuid < 0 ? (this._iGuid = akra.sid()) : this._iGuid;
            };
            DepsManager.prototype.connect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            DepsManager.prototype.disconnect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            DepsManager.prototype.bind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType);
            };
            DepsManager.prototype.unbind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType);
            };
            DepsManager.prototype.loaded = function /** @no-inline */() {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).loaded;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            DepsManager.prototype.error = // BROADCAST(error, CALL(pErr));
            function /** @no-inline */(pErr) {
                if(true) {
                    throw pErr;
                }
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).error;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, pErr) : _broadcast[i].listener(_recivier, pErr);
                    }
                }
                ;
            };
            return DepsManager;
        })();        
        function /** @no-inline */createDepsManager(pEngine) {
            util.logger.setSourceLocation("util/DepsManager.ts", 177);
            util.logger.assert(akra.isDefAndNotNull(pEngine));
            ;
            return new DepsManager(pEngine);
        }
        util.createDepsManager = createDepsManager;
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (core) {
        var Engine = (function () {
            function /** @no-inline */Engine(pOptions) {
                if (typeof pOptions === "undefined") { pOptions = null; }
                this._iAppPausedCount = 0;
                /** is paused? */
                this._isActive = false;
                /** frame rendering sync / render next frame? */
                this._isFrameMoving = true;
                /** is all needed files loaded */
                this._isDepsLoaded = false;
                this._iGuid = eval("this._iGuid || akra.sid()");
                this._pUnicastSlotMap = null;
                this._pBroadcastSlotList = null;
                this._pResourceManager = new core.pool.ResourcePoolManager(this);
                this._pSceneManager = new akra.scene.SceneManager(this);
                this._pParticleManager = null;
                this._pRenderer = new akra.webgl.WebGLRenderer(this);
                this._pComposer = new akra.fx.Composer(this);
                if(!this._pResourceManager.initialize()) {
                    akra.logger.setSourceLocation("core/Engine.ts", 70);
                    akra.logger.error('cannot initialize ResourcePoolManager');
                    ;
                }
                if(!this._pSceneManager.initialize()) {
                    akra.logger.setSourceLocation("core/Engine.ts", 74);
                    akra.logger.error("cannot initialize SceneManager");
                    ;
                }
                this._pTimer = akra.util.UtilTimer.start();
                this.pause(false);
                // this.parseOptions(pOptions);
                            }
            Engine.prototype.parseOptions = function /** @no-inline */(pOptions) {
                //== Depends Managment ====================================
                var pDeps = Engine.DEPS;
                var sDepsRoot = Engine.DEPS_ROOT;
                var pDepsManager = akra.util.createDepsManager(this);
                //read options
                if(!akra.isNull(pOptions)) {
                    sDepsRoot = pOptions.depsRoot || Engine.DEPS_ROOT;
                    //default deps has higher priority!
                    if(akra.isDefAndNotNull(pOptions.deps)) {
                        pDeps.files = pDeps.files.concat(pOptions.deps.files || []);
                    }
                }
                //get loaded signal
                this.connect(pDepsManager, "loaded", "_depsLoaded");
                //load depends!
                if(!pDepsManager.load(pDeps, sDepsRoot)) {
                    akra.logger.setSourceLocation("core/Engine.ts", 104);
                    akra.logger.criticalError("load dependencies are not started.");
                    ;
                }
                //===========================================================
                            };
            Engine.prototype.getScene = function /** @inline */() {
                return this._pSceneManager.getScene3D(0);
            };
            Engine.prototype.getSceneManager = function /** @inline */() {
                return this._pSceneManager;
            };
            Engine.prototype.getParticleManager = function /** @inline */() {
                return null;
            };
            Engine.prototype.getResourceManager = function /** @inline */() {
                return this._pResourceManager;
            };
            Engine.prototype.getRenderer = function /** @inline */() {
                return this._pRenderer;
            };
            Engine.prototype.getComposer = function /** @inline */() {
                return this._pComposer;
            };
            Engine.prototype.isActive = function /** @inline */() {
                return this._isActive;
            };
            Engine.prototype.exec = function /** @no-inline */(bValue) {
                if (typeof bValue === "undefined") { bValue = true; }
                var pRenderer = this._pRenderer;
                var pEngine = this;
                // var pCanvas: HTMLCanvasElement = null;
                // pCanvas = (<IWebGLRenderer>pRenderer).getHTMLCanvas();
                akra.logger.setSourceLocation("core/Engine.ts", 149);
                akra.logger.assert(!akra.isNull(pRenderer));
                ;
                pRenderer._initRenderTargets();
                // Infinite loop, until broken out of by frame listeners
                // or break out by calling queueEndRendering()
                bValue ? this.active() : this.inactive();
                function /** @no-inline */render(iTime) {
                    if(pRenderer.isValid()) {
                        akra.logger.setSourceLocation("core/Engine.ts", 161);
                        akra.logger.error(pRenderer.getError());
                        ;
                    }
                    if(!pEngine.isActive()) {
                        return;
                    }
                    if(!pEngine.renderFrame()) {
                        akra.logger.setSourceLocation("core/Engine.ts", 169);
                        akra.logger.error("Engine::exec() error.");
                        ;
                        return;
                    }
                    /*, pCanvas*/
                    requestAnimationFrame(render);
                }
                render(0);
            };
            Engine.prototype.getTimer = function /** @inline */() {
                return this._pTimer;
            };
            Engine.prototype.renderFrame = function /** @no-inline */() {
                var fElapsedAppTime = this._pTimer.elapsedTime;
                if(0. == fElapsedAppTime && this._isFrameMoving) {
                    return true;
                }
                // FrameMove (animate) the scene
                if(this._isFrameMoving) {
                    this._pSceneManager.update();
                }
                // Render the scene as normal
                this.frameStarted();
                this._pRenderer._updateAllRenderTargets();
                this.frameEnded();
                return true;
            };
            Engine.prototype.play = function /** @no-inline */() {
                if(!this.isActive()) {
                    this._iAppPausedCount = 0;
                    this.active();
                    if(this._isFrameMoving) {
                        this._pTimer.start();
                    }
                }
                return this.isActive();
            };
            Engine.prototype.pause = function /** @no-inline */(isPause) {
                if (typeof isPause === "undefined") { isPause = false; }
                this._iAppPausedCount += (isPause ? +1 : -1);
                (this._iAppPausedCount ? this.inactive() : this.active());
                // Handle the first pause request (of many, nestable pause requests)
                if(isPause && (1 == this._iAppPausedCount)) {
                    // Stop the scene from animating
                    if(this._isFrameMoving) {
                        this._pTimer.stop();
                    }
                }
                if(0 == this._iAppPausedCount) {
                    // Restart the timers
                    if(this._isFrameMoving) {
                        this._pTimer.start();
                    }
                }
                return !this.isActive();
            };
            Engine.prototype.createMesh = function /** @inline */(sName, eOptions, pDataBuffer) {
                if (typeof sName === "undefined") { sName = null; }
                if (typeof eOptions === "undefined") { eOptions = 0; }
                if (typeof pDataBuffer === "undefined") { pDataBuffer = null; }
                return akra.model.createMesh(this, sName, eOptions, pDataBuffer);
            };
            Engine.prototype.createRenderDataCollection = function /** @inline */(iOptions) {
                if (typeof iOptions === "undefined") { iOptions = 0; }
                return akra.render.createRenderDataCollection(this, iOptions);
            };
            Engine.prototype.createBufferMap = function /** @inline */() {
                return akra.util.createBufferMap(this);
            };
            Engine.prototype.createAnimationController = function /** @inline */(iOptions) {
                if (typeof iOptions === "undefined") { iOptions = 0; }
                return akra.animation.createController(this, iOptions);
            };
            Engine.prototype._depsLoaded = function /** @no-inline */(pLoader) {
                alert("deps loaded!!!!!!!!!!!!!!!!!!!!!");
                this._isDepsLoaded = true;
            };
            Engine.DEPS_ROOT = "";
            Engine.DEPS = {
                files: [
                    "grammars/HLSL.gr"
                ],
                deps: {
                    files: [
                        "effects/SystemEffects.afx", 
                        "effects/prepareDeferredShading.afx", 
                        "effects/Plane.afx", 
                        "effects/mesh.afx", 
                        "effects/mesh_geometry.afx", 
                        "effects/mesh_texture.afx", 
                        "effects/TextureToScreen.afx", 
                        "effects/prepare_shadows.afx", 
                        "effects/deferredShading.afx", 
                        "effects/apply_lights_and_shadows.afx", 
                        "effects/fxaa.afx", 
                        "effects/skybox.afx"
                    ]
                }
            };
            Engine._pEventTable = new akra.events.EventTable();
            Engine.prototype.getEventTable = function /** @inline */() {
                return Engine._pEventTable;
            };
            Engine.prototype.getGuid = function /** @no-inline */() {
                return this._iGuid < 0 ? (this._iGuid = akra.sid()) : this._iGuid;
            };
            Engine.prototype.connect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            Engine.prototype.disconnect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            Engine.prototype.bind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType);
            };
            Engine.prototype.unbind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType);
            };
            Engine.prototype.frameStarted = function /** @no-inline */() {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).frameStarted;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            Engine.prototype.frameEnded = function /** @no-inline */() {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).frameEnded;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            Engine.prototype.inactive = function /** @no-inline */() {
                this._isActive = false;
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).inactive;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
                ;
            };
            Engine.prototype.active = function /** @no-inline */() {
                this._isActive = true;
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).active;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
                ;
            };
            return Engine;
        })();
        core.Engine = Engine;        
        // BROADCAST(inactive, VOID);
        // BROADCAST(active, VOID);
            })(akra.core || (akra.core = {}));
    var core = akra.core;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.createEngine = function /** @no-inline */(pOptions) {
        return new akra.core.Engine(pOptions);
    };
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (ERPCPacketTypes) {
        ERPCPacketTypes._map = [];
        ERPCPacketTypes._map[0] = "FAILURE";
        ERPCPacketTypes.FAILURE = 0;
        ERPCPacketTypes._map[1] = "REQUEST";
        ERPCPacketTypes.REQUEST = 1;
        ERPCPacketTypes._map[2] = "RESPONSE";
        ERPCPacketTypes.RESPONSE = 2;
    })(akra.ERPCPacketTypes || (akra.ERPCPacketTypes = {}));
    var ERPCPacketTypes = akra.ERPCPacketTypes;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (EPipeTypes) {
        EPipeTypes._map = [];
        EPipeTypes._map[0] = "UNKNOWN";
        EPipeTypes.UNKNOWN = 0;
        EPipeTypes._map[1] = "WEBSOCKET";
        /** Connect to websocket. */
        EPipeTypes.WEBSOCKET = 1;
        EPipeTypes._map[2] = "WEBWORKER";
        /** Connect to webworker. */
        EPipeTypes.WEBWORKER = 2;
    })(akra.EPipeTypes || (akra.EPipeTypes = {}));
    var EPipeTypes = akra.EPipeTypes;
    (function (EPipeDataTypes) {
        EPipeDataTypes._map = [];
        EPipeDataTypes._map[0] = "BINARY";
        EPipeDataTypes.BINARY = 0;
        EPipeDataTypes._map[1] = "STRING";
        EPipeDataTypes.STRING = 1;
    })(akra.EPipeDataTypes || (akra.EPipeDataTypes = {}));
    var EPipeDataTypes = akra.EPipeDataTypes;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (net) {
        /**@const*/ net.WEBSOCKET_PORT = 1337;
        var Pipe = (function () {
            function /** @no-inline */Pipe(sAddr) {
                if (typeof sAddr === "undefined") { sAddr = null; }
                /**@protected*/ this._pAddr = null;
                /** Number of sended messages.*/
                /**@protected*/ this._nMesg = 0;
                /**@protected*/ this._eType = 0 /* UNKNOWN */ ;
                /**@protected*/ this._pConnect = null;
                /**@protected*/ this._bSetupComplete = false;
                this._iGuid = eval("this._iGuid || akra.sid()");
                this._pUnicastSlotMap = null;
                this._pBroadcastSlotList = null;
                if(!akra.isNull(sAddr)) {
                    this.open(sAddr);
                }
            }
            Object.defineProperty(Pipe.prototype, "uri", {
                get: function /** @inline */() {
                    return akra.util.uri(this._pAddr.toString());
                },
                enumerable: true,
                configurable: true
            });
            Pipe.prototype.open = function /** @no-inline */(sAddr) {
                if (typeof sAddr === "undefined") { sAddr = null; }
                var pAddr;
                var eType;
                var pSocket = null;
                var pWorker = null;
                var pPipe = this;
                if(!akra.isNull(sAddr)) {
                    pAddr = akra.util.uri(sAddr);
                } else {
                    if(this.isCreated()) {
                        this.close();
                    }
                    pAddr = this.uri;
                }
                // pipe to websocket
                if(pAddr.protocol.toLowerCase() === "ws") {
                    //unknown port
                    if(!(pAddr.port > 0)) {
                        pAddr.port = net.WEBSOCKET_PORT;
                    }
                    //websocket unsupported
                    if(!akra.isDefAndNotNull(WebSocket)) {
                        akra.logger.setSourceLocation("Pipe.ts", 64);
                        akra.logger.error("Your browser does not support websocket api.");
                        ;
                        return false;
                    }
                    pSocket = new WebSocket(pAddr.toString());
                    pSocket.binaryType = "arraybuffer";
                    eType = 1 /* WEBSOCKET */ ;
                } else if(akra.util.pathinfo(pAddr.path).ext.toLowerCase() === "js") {
                    if(!akra.isDefAndNotNull(Worker)) {
                        akra.logger.setSourceLocation("Pipe.ts", 76);
                        akra.logger.error("Your browser does not support webworker api.");
                        ;
                        return false;
                    }
                    pWorker = new Worker(pAddr.toString());
                    eType = 2 /* WEBWORKER */ ;
                } else {
                    akra.logger.setSourceLocation("Pipe.ts", 84);
                    akra.logger.error("Pipe supported only websockets/webworkers.");
                    ;
                    return false;
                }
                this._pConnect = pWorker || pSocket;
                this._pAddr = pAddr;
                this._eType = eType;
                if(akra.isDefAndNotNull(window)) {
                    window.onunload = function /** @no-inline */() {
                        pPipe.close();
                    };
                }
                if(!akra.isNull(this._pConnect)) {
                    this.setupConnect();
                    return true;
                }
                return false;
            };
            Pipe.prototype.setupConnect = function /** @no-inline */() {
                var pConnect = this._pConnect;
                var pPipe = this;
                var pAddr = this._pAddr;
                if(this._bSetupComplete) {
                    return;
                }
                pConnect.onmessage = function /** @no-inline */(pMessage) {
                    if(akra.isArrayBuffer(pMessage.data)) {
                        pPipe.message(pMessage.data, 0 /* BINARY */ );
                    } else {
                        pPipe.message(pMessage.data, 1 /* STRING */ );
                    }
                };
                pConnect.onopen = function /** @no-inline */(pEvent) {
                    akra.logger.setSourceLocation("Pipe.ts", 126);
                    akra.logger.log("created connect to: " + pAddr.toString());
                    ;
                    pPipe.opened(pEvent);
                };
                pConnect.onerror = function /** @no-inline */(pErr) {
                    akra.logger.setSourceLocation("Pipe.ts", 132);
                    akra.logger.warning("pipe error detected: " + pErr.message);
                    ;
                    pPipe.error(pErr);
                };
                pConnect.onclose = function /** @no-inline */(pEvent) {
                    akra.logger.setSourceLocation("Pipe.ts", 137);
                    akra.logger.log("connection to " + pAddr.toString() + " closed");
                    ;
                    pPipe.closed(pEvent);
                };
                this._bSetupComplete = true;
            };
            Pipe.prototype.close = function /** @no-inline */() {
                var pSocket;
                var pWorker;
                if(this.isOpened()) {
                    switch(this._eType) {
                        case 1 /* WEBSOCKET */ :
                            pSocket = this._pConnect;
                            pSocket.onmessage = null;
                            pSocket.onerror = null;
                            pSocket.onopen = null;
                            pSocket.close();
                            break;
                        case 2 /* WEBWORKER */ :
                            pWorker = this._pConnect;
                            pWorker.terminate();
                    }
                }
                this._pConnect = null;
                this._bSetupComplete = false;
            };
            Pipe.prototype.write = function /** @no-inline */(pValue) {
                var pSocket;
                var pWorker;
                if(this.isOpened()) {
                    this._nMesg++;
                    switch(this._eType) {
                        case 1 /* WEBSOCKET */ :
                            pSocket = this._pConnect;
                            if(akra.isObject(pValue)) {
                                pValue = JSON.stringify(pValue);
                            }
                            pSocket.send(pValue);
                            return true;
                        case 2 /* WEBWORKER */ :
                            pWorker = this._pConnect;
                            if(akra.isDef(pValue.byteLength)) {
                                pWorker.postMessage(pValue, [
                                    pValue
                                ]);
                            } else {
                                pWorker.postMessage(pValue);
                            }
                            return true;
                    }
                }
                return false;
            };
            Pipe.prototype.isClosed = function /** @no-inline */() {
                switch(this._eType) {
                    case 1 /* WEBSOCKET */ :
                        return ((this._pConnect).readyState === WebSocket.CLOSED);
                }
                return akra.isNull(this._pConnect);
            };
            Pipe.prototype.isOpened = function /** @no-inline */() {
                switch(this._eType) {
                    case 1 /* WEBSOCKET */ :
                        return (this._pConnect).readyState === WebSocket.OPEN;
                }
                return !akra.isNull(this._pConnect);
            };
            Pipe.prototype.isCreated = function /** @inline */() {
                return !akra.isNull(this._pConnect);
            };
            Pipe._pEventTable = new akra.events.EventTable();
            Pipe.prototype.getEventTable = function /** @inline */() {
                return Pipe._pEventTable;
            };
            Pipe.prototype.getGuid = function /** @no-inline */() {
                return this._iGuid < 0 ? (this._iGuid = akra.sid()) : this._iGuid;
            };
            Pipe.prototype.connect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            Pipe.prototype.disconnect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            Pipe.prototype.bind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType);
            };
            Pipe.prototype.unbind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType);
            };
            Pipe.prototype.opened = function /** @no-inline */() {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).opened;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            Pipe.prototype.closed = function /** @no-inline */(ev) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).closed;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, ev) : _broadcast[i].listener(_recivier, ev);
                    }
                }
            };
            Pipe.prototype.error = function /** @no-inline */(err) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).error;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, err) : _broadcast[i].listener(_recivier, err);
                    }
                }
            };
            Pipe.prototype.message = function /** @no-inline */(data, type) {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).message;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier, data, type) : _broadcast[i].listener(_recivier, data, type);
                    }
                }
            };
            return Pipe;
        })();        
        function /** @no-inline */createPipe(sAddr) {
            if (typeof sAddr === "undefined") { sAddr = null; }
            return new Pipe(sAddr);
        }
        net.createPipe = createPipe;
    })(akra.net || (akra.net = {}));
    var net = akra.net;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        ;
        var ObjectList = (function () {
            function /** @no-inline */ObjectList(pData) {
                /**@protected*/ this._pHead = null;
                /**@protected*/ this._pTail = null;
                /**@protected*/ this._pCurrent = null;
                /**@protected*/ this._iLength = 0;
                /**@protected*/ this._bLock = false;
                if(arguments.length) {
                    this.fromArray(pData);
                }
            }
            Object.defineProperty(ObjectList.prototype, "length", {
                get: function /** @inline */() {
                    return this._iLength;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ObjectList.prototype, "first", {
                get: function /** @inline */() {
                    this._pCurrent = this._pHead;
                    return (akra.isDefAndNotNull(this._pCurrent)) ? this._pCurrent.data : null;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ObjectList.prototype, "last", {
                get: function /** @inline */() {
                    this._pCurrent = this._pTail;
                    return (akra.isDefAndNotNull(this._pCurrent)) ? this._pCurrent.data : null;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ObjectList.prototype, "current", {
                get: function /** @inline */() {
                    return (akra.isDefAndNotNull(this._pCurrent)) ? this._pCurrent.data : null;
                },
                enumerable: true,
                configurable: true
            });
            ObjectList.prototype.lock = function /** @inline */() {
                this._bLock = true;
            };
            ObjectList.prototype.unlock = function /** @inline */() {
                this._bLock = false;
            };
            ObjectList.prototype.isLocked = function /** @inline */() {
                return this._bLock;
            };
            ObjectList.prototype.value = function /** @inline */(n) {
                return this.find(n).data;
            };
            ObjectList.prototype.indexOf = function /** @no-inline */(pData, iFrom) {
                if (typeof iFrom === "undefined") { iFrom = 0.; }
                var pItem = this.find(iFrom);
                for(var i = iFrom; i < this._iLength; i++) {
                    if(pItem.data === pData) {
                        return i;
                    }
                    pItem = pItem.next;
                }
                return -1;
            };
            ObjectList.prototype.mid = function /** @no-inline */(iPos, iSize) {
                if (typeof iPos === "undefined") { iPos = 0; }
                if (typeof iSize === "undefined") { iSize = this._iLength; }
                iSize = Math.min(this._iLength - iPos, iSize);
                if(iPos > this._iLength - 1) {
                    return null;
                }
                var pNewList = new ObjectList();
                var pItem = this.find(iPos);
                for(var i = 0; i < iSize; ++i) {
                    pNewList.push(pItem.data);
                    pItem = pItem.next;
                }
                ;
                return pNewList;
            };
            ObjectList.prototype.slice = function /** @inline */(iStart, iEnd) {
                if (typeof iStart === "undefined") { iStart = 0; }
                if (typeof iEnd === "undefined") { iEnd = Math.max(this._iLength - iStart, 0); }
                return this.mid(iStart, iEnd - iStart);
            };
            ObjectList.prototype.move = function /** @inline */(iFrom, iTo) {
                return this.insert(iTo - 1, this.takeAt(iFrom));
            };
            ObjectList.prototype.replace = function /** @inline */(iPos, pData) {
                util.logger.setSourceLocation("util/ObjectList.ts", 102);
                util.logger.assert(!this.isLocked(), "list locked.");
                ;
                this.find(iPos).data = pData;
                return this;
            };
            ObjectList.prototype.erase = function /** @no-inline */(begin, end) {
                if(arguments.length < 2) {
                    this.takeAt(arguments[0]);
                } else {
                    end = Math.min(end, this._iLength);
                    for(var i = begin; i < end; i++) {
                        this.takeAt(i);
                    }
                }
                return this;
            };
            ObjectList.prototype.contains = function /** @inline */(pData) {
                return (this.indexOf(pData) >= 0);
            };
            ObjectList.prototype.removeAt = function /** @inline */(n) {
                this.takeAt(n);
            };
            ObjectList.prototype.removeOne = function /** @inline */(pData) {
                this.removeAt(this.indexOf(pData));
            };
            ObjectList.prototype.removeAll = function /** @inline */(pData) {
                var i;
                var n = this.length;
                while((i = this.indexOf(pData)) >= 0) {
                    this.removeAt(i);
                    i--;
                }
                return n;
            };
            ObjectList.prototype.swap = function /** @no-inline */(i, j) {
                util.logger.setSourceLocation("util/ObjectList.ts", 147);
                util.logger.assert(!this.isLocked(), "list locked.");
                ;
                i = Math.min(i, this._iLength - 1);
                j = Math.min(j, this._iLength - 1);
                if(i != j) {
                    var pItem1 = this.find(i);
                    var pItem2 = this.find(j);
                    var pTmp = pItem1.data;
                    pItem1.data = pItem2.data;
                    pItem2.data = pTmp;
                }
                return this;
            };
            ObjectList.prototype.add = function /** @no-inline */(pList) {
                pList.seek(0);
                if(pList.length > 1) {
                    this.push(pList.first());
                }
                for(var i = 1; i < pList.length; i++) {
                    this.push(pList.next());
                }
                return this;
            };
            ObjectList.prototype.seek = function /** @no-inline */(n) {
                if (typeof n === "undefined") { n = 0; }
                var pElement;
                n = Math.min(n, this._iLength - 1);
                if(n > this._iLength / 2) {
                    pElement = this._pTail;
                    for(var m = this._iLength - 1 - n; m > 0; --m) {
                        pElement = pElement.prev;
                    }
                } else {
                    pElement = this._pHead;
                    for(var i = 0; i < n; ++i) {
                        pElement = pElement.next;
                    }
                }
                this._pCurrent = pElement;
                return this;
            };
            ObjectList.prototype.next = function /** @inline */() {
                return (akra.isDefAndNotNull(this._pCurrent) && akra.isDefAndNotNull(this._pCurrent.next)) ? (this._pCurrent = this._pCurrent.next).data : null;
            };
            ObjectList.prototype.prev = function /** @inline */() {
                return (akra.isDefAndNotNull(this._pCurrent) && akra.isDefAndNotNull(this._pCurrent.prev)) ? (this._pCurrent = this._pCurrent.prev).data : null;
            };
            ObjectList.prototype.push = function /** @inline */(pElement) {
                return this.insert(this._iLength, pElement);
            };
            ObjectList.prototype.takeAt = function /** @inline */(n) {
                util.logger.setSourceLocation("util/ObjectList.ts", 217);
                util.logger.assert(!this.isLocked(), "list locked.");
                ;
                if(n < 0) {
                    return null;
                }
                return this.pullElement(this.find(n));
            };
            ObjectList.prototype.pullElement = function /** @no-inline */(pItem) {
                if(akra.isNull(pItem.prev)) {
                    this._pHead = pItem.next;
                } else {
                    pItem.prev.next = pItem.next;
                }
                if(akra.isNull(pItem.next)) {
                    this._pTail = pItem.prev;
                } else {
                    pItem.next.prev = pItem.prev;
                }
                this._iLength--;
                if(akra.isNull(pItem.next)) {
                    this._pCurrent = this._pTail;
                } else {
                    this._pCurrent = pItem.next;
                }
                return this.releaseItem(pItem);
            };
            ObjectList.prototype.takeFirst = function /** @inline */() {
                return this.takeAt(0);
            };
            ObjectList.prototype.takeLast = function /** @inline */() {
                return this.takeAt(this._iLength - 1);
            };
            ObjectList.prototype.takeCurrent = function /** @inline */(isPrev) {
                if (typeof isPrev === "undefined") { isPrev = false; }
                return this.pullElement(this._pCurrent);
            };
            ObjectList.prototype.pop = function /** @inline */() {
                return this.takeAt(this._iLength - 1);
            };
            ObjectList.prototype.prepend = function /** @inline */(pElement) {
                return this.insert(0, pElement);
            };
            ObjectList.prototype.find = function /** @inline */(n) {
                if(n < this._iLength) {
                    this.seek(n);
                    return this._pCurrent;
                }
                return null;
            };
            ObjectList.prototype.releaseItem = function /** @inline */(pItem) {
                var pData = pItem.data;
                pItem.next = null;
                pItem.prev = null;
                pItem.data = null;
                ObjectList.listItemPool.push(pItem);
                return pData;
            };
            ObjectList.prototype.createItem = function /** @inline */() {
                if(ObjectList.listItemPool.length == 0) {
                    // LOG("allocated object list item");
                    return {
                        next: null,
                        prev: null,
                        data: null
                    };
                }
                // LOG("before pop <----------", this._iLength, this.first);
                return ObjectList.listItemPool.pop();
            };
            ObjectList.prototype.fromArray = function /** @no-inline */(elements, iOffset, iSize) {
                if (typeof iOffset === "undefined") { iOffset = 0; }
                if (typeof iSize === "undefined") { iSize = elements.length; }
                iOffset = Math.min(iOffset, this._iLength);
                for(var i = 0; i < iSize; i++) {
                    this.insert(iOffset + i, elements[i]);
                }
                return this;
            };
            ObjectList.prototype.insert = function /** @no-inline */(n, pData) {
                util.logger.setSourceLocation("util/ObjectList.ts", 316);
                util.logger.assert(!this.isLocked(), "list locked.");
                ;
                var pNew = this.createItem();
                var pItem;
                n = Math.min(n, this._iLength);
                pNew.data = pData;
                if(n == 0) {
                    if(akra.isNull(this._pHead)) {
                        this._pTail = pNew;
                    }
                    pNew.next = this._pHead;
                    this._pHead = pNew;
                } else {
                    pItem = this.find(n - 1);
                    if(pItem == null) {
                        this._pHead = pNew;
                    } else {
                        if(pItem.next == null) {
                            this._pTail = pNew;
                        } else {
                            pNew.next = pItem.next;
                            pItem.next.prev = pNew;
                        }
                        pItem.next = pNew;
                        pNew.prev = pItem;
                    }
                }
                this._iLength++;
                this._pCurrent = pNew;
                return this;
            };
            ObjectList.prototype.isEqual = function /** @no-inline */(pList) {
                if(this._iLength == pList.length) {
                    if(this === pList) {
                        return true;
                    }
                    var l1 = this.first;
                    var l2 = pList.first;
                    for(var i = 0; i < this._iLength; ++i) {
                        if(l1 != l2) {
                            return false;
                        }
                        l1 = this.next();
                        l2 = pList.next();
                    }
                    return true;
                }
                return false;
            };
            ObjectList.prototype.clear = function /** @no-inline */() {
                util.logger.setSourceLocation("util/ObjectList.ts", 385);
                util.logger.assert(!this.isLocked(), "list locked.");
                ;
                var pPrev;
                var pNext;
                this._pCurrent = this._pHead;
                for(var i = 0; i < this._iLength; ++i) {
                    pPrev = this._pCurrent;
                    pNext = this._pCurrent = this._pCurrent.next;
                    this.releaseItem(pPrev);
                }
                this._pHead = this._pCurrent = this._pTail = null;
                this._iLength = 0;
                return this;
            };
            ObjectList.prototype.forEach = function /** @no-inline */(fn) {
                var pItem = this._pHead;
                var n = 0;
                do {
                    if(fn(pItem.data, n++) === false) {
                        return;
                    }
                }while((pItem = pItem.next));
            };
            ObjectList.listItemPool = new util.ObjectArray();
            return ObjectList;
        })();
        util.ObjectList = ObjectList;        
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var akra;
(function (akra) {
    akra.ObjectList = akra.util.ObjectList;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (net) {
        var RPC = (function () {
            function /** @no-inline */RPC(pAddr, pContext) {
                if (typeof pAddr === "undefined") { pAddr = null; }
                if (typeof pContext === "undefined") { pContext = null; }
                /**@protected*/ this._pPipe = null;
                //стек вызововы, которые были отложены
                /**@protected*/ this._pDefferedRequests = new akra.ObjectList();
                //стек вызовов, ожидающих результата
                //type: ObjectList<IRPCCallback>
                /**@protected*/ this._pCallbacks = new akra.ObjectList();
                //число совершенных вызовов
                /**@protected*/ this._nCalls = 0;
                //rejoin timer
                /**@protected*/ this._iReconnect = -1;
                /**@protected*/ this._pRemoteAPI = {
                };
                //контекст, у которого будут вызываться методы
                //при получении REQUEST запросов со стороны сервера
                /**@protected*/ this._pContext = null;
                this._iGuid = eval("this._iGuid || akra.sid()");
                this._pUnicastSlotMap = null;
                this._pBroadcastSlotList = null;
                if(!akra.isNull(pAddr)) {
                    this.join(pAddr);
                }
            }
            Object.defineProperty(RPC.prototype, "remote", {
                get: function /** @inline */() {
                    return this._pRemoteAPI;
                },
                enumerable: true,
                configurable: true
            });
            RPC.prototype.join = function /** @no-inline */(sAddr) {
                if (typeof sAddr === "undefined") { sAddr = null; }
                var pPipe = this._pPipe;
                var pRPC = this;
                var pDeffered = this._pDefferedRequests;
                if(akra.isNull(pPipe)) {
                    pPipe = akra.net.createPipe();
                    pPipe.bind("message", function /** @no-inline */(pPipe, pMessage, eType) {
                        // LOG(pMessage);
                        if(eType !== 0 /* BINARY */ ) {
                            pRPC.parse(JSON.parse(pMessage));
                        } else {
                            pRPC.parseBinary(new Uint8Array(pMessage));
                        }
                    });
                    pPipe.bind("opened", function /** @no-inline */(pPipe, pEvent) {
                        //if we have unhandled call in deffered...
                        if(pDeffered.length) {
                            pDeffered.seek(0);
                            while(pDeffered.length > 0) {
                                pPipe.write(pDeffered.current);
                                pRPC._releaseRequest(pDeffered.takeCurrent());
                            }
                            akra.logger.setSourceLocation("net/RPC.ts", 72);
                            akra.logger.assert(pDeffered.length === 0, "something going wrong. length is: " + pDeffered.length);
                            ;
                        }
                        pRPC.proc(RPC.PROC_LIST, function /** @no-inline */(pError, pList) {
                            if(!akra.isNull(pError)) {
                                akra.logger.setSourceLocation("net/RPC.ts", 78);
                                akra.logger.criticalError("could not get proc. list");
                                ;
                            }
                            //TODO: FIX akra. prefix...
                            if(!akra.isNull(pList) && akra.isArray(pList)) {
                                for(var i = 0; i < pList.length; ++i) {
                                    (function /** @no-inline */(sMethod) {
                                        pRPC.remote[sMethod] = function /** @no-inline */() {
                                            var pArguments = [
                                                sMethod
                                            ];
                                            for(var j = 0; j < arguments.length; ++j) {
                                                pArguments.push(arguments[j]);
                                            }
                                            return pRPC.proc.apply(pRPC, pArguments);
                                        };
                                    })(String(pList[i]));
                                }
                            }
                            pRPC.joined();
                        });
                    });
                    pPipe.bind("error", function /** @no-inline */(pPipe, pError) {
                        akra.logger.setSourceLocation("net/RPC.ts", 107);
                        akra.logger.error("pipe error occured...");
                        ;
                        pRPC.rejoin();
                    });
                    pPipe.bind("closed", function /** @no-inline */(pPipe, pEvent) {
                        pRPC.rejoin();
                    });
                }
                pPipe.open(sAddr);
                this._pPipe = pPipe;
            };
            RPC.prototype.rejoin = function /** @no-inline */() {
                var pRPC = this;
                clearTimeout(this._iReconnect);
                if(this._pPipe.isOpened()) {
                    return;
                }
                if(this._pPipe.isClosed()) {
                    // LOG("attempt to reconnecting...");
                    this._iReconnect = setTimeout(function /** @inline */() {
                        pRPC.join();
                    }, RPC.OPTIONS.RECONNECT_TIMEOUT);
                }
            };
            RPC.prototype.parse = function /** @no-inline */(pRes) {
                if(!akra.isDef(pRes.n)) {
                    akra.logger.setSourceLocation("net/RPC.ts", 143);
                    akra.logger.log(pRes);
                    ;
                    akra.logger.setSourceLocation("net/RPC.ts", 144);
                    akra.logger.warning("message droped, because seriial not recognized.");
                    ;
                }
                ;
                this.response(pRes.n, pRes.type, pRes.res);
            };
            RPC.prototype.parseBinary = function /** @no-inline */(pBuffer) {
                var pRes = pBuffer;
                var nMsg = (new Uint32Array(pBuffer.subarray(0, 4).buffer, 0, 4))[0];
                var eType = pBuffer[4];
                var pResult = new Uint8Array(pBuffer, 8);
                this.response(nMsg, eType, pResult);
            };
            RPC.prototype.response = function /** @no-inline */(nSerial, eType, pResult) {
                var pStack = this._pCallbacks;
                var fn = null;
                if(eType === 2 /* RESPONSE */ ) {
                    var pCallback = pStack.last;
                    // WARNING("---------------->",nSerial,"<-----------------");
                    do {
                        // LOG("#n: ", nSerial, " result: ", pResult);
                        if(pCallback.n === nSerial) {
                            fn = pCallback.fn;
                            this._releaseCallback(pStack.takeCurrent());
                            if(!akra.isNull(fn)) {
                                fn(null, pResult);
                            }
                            return;
                        }
                    }while(pCallback = pStack.prev());
                    akra.logger.setSourceLocation("net/RPC.ts", 180);
                    akra.logger.warning("package droped, invalid serial: " + nSerial);
                    ;
                } else if(eType === 1 /* REQUEST */ ) {
                    akra.logger.setSourceLocation("net/RPC.ts", 183);
                    akra.logger.error("TODO: REQUEST package type temprary unsupported.");
                    ;
                } else if(eType === 0 /* FAILURE */ ) {
                    akra.logger.setSourceLocation("net/RPC.ts", 186);
                    akra.logger.error("detected FAILURE on " + nSerial + " package");
                    ;
                } else {
                    akra.logger.setSourceLocation("net/RPC.ts", 189);
                    akra.logger.error("unsupported response type detected: " + eType);
                    ;
                }
            };
            RPC.prototype.free = function /** @no-inline */() {
                this._pDefferedRequests.clear();
                this._pCallbacks.clear();
            };
            RPC.prototype.proc = function /** @no-inline */() {
                var argv = [];
                for (var _i = 0; _i < (arguments.length - 0); _i++) {
                    argv[_i] = arguments[_i + 0];
                }
                var IRPCCallback = arguments.length - 1;
                var fnCallback = akra.isFunction(arguments[IRPCCallback]) ? arguments[IRPCCallback] : null;
                var nArg = arguments.length - (fnCallback ? 2 : 1);
                var pArgv = new Array(nArg);
                var pPipe = this._pPipe;
                var pCallback = null;
                var bResult;
                for(var i = 0; i < nArg; ++i) {
                    pArgv[i] = arguments[i + 1];
                }
                var pProc = this._createRequest();
                pProc.n = this._nCalls++;
                pProc.type = 1 /* REQUEST */ ;
                pProc.proc = String(arguments[0]);
                pProc.argv = pArgv;
                //if (!isNull(fnCallback)) {
                pCallback = this._createCallback();
                pCallback.n = pProc.n;
                pCallback.fn = fnCallback;
                //}
                if(akra.isNull(pPipe) || !pPipe.isOpened()) {
                    if(this._pDefferedRequests.length <= RPC.OPTIONS.DEFFERED_CALLS_LIMIT) {
                        this._pDefferedRequests.push(pProc);
                        this._pCallbacks.push(pCallback);
                    } else {
                        pCallback.fn(RPC.ERRORS.STACK_SIZE_EXCEEDED);
                        akra.logger.setSourceLocation("net/RPC.ts", 234);
                        akra.logger.warning(RPC.ERRORS.STACK_SIZE_EXCEEDED);
                        ;
                        this._releaseCallback(pCallback);
                    }
                    return false;
                }
                this._pCallbacks.push(pCallback);
                bResult = pPipe.write(pProc);
                this._releaseRequest(pProc);
                return bResult;
            };
            RPC.prototype._releaseRequest = function /** @inline */(pReq) {
                pReq.n = 0;
                pReq.proc = null;
                pReq.argv = null;
                RPC.requestPool.push(pReq);
            };
            RPC.prototype._createRequest = function /** @inline */() {
                if(RPC.requestPool.length == 0) {
                    // LOG("allocated rpc request");
                    return {
                        n: 0,
                        type: 1 /* REQUEST */ ,
                        proc: null,
                        argv: null
                    };
                }
                return RPC.requestPool.pop();
            };
            RPC.prototype._releaseCallback = function /** @inline */(pReq) {
                pReq.n = 0;
                pReq.fn = null;
                RPC.callbackPool.push(pReq);
            };
            RPC.prototype._createCallback = function /** @inline */() {
                if(RPC.callbackPool.length == 0) {
                    // LOG("allocated callback");
                    return {
                        n: 0,
                        fn: null
                    };
                }
                return RPC.callbackPool.pop();
            };
            RPC._pEventTable = new akra.events.EventTable();
            RPC.prototype.getEventTable = function /** @inline */() {
                return RPC._pEventTable;
            };
            RPC.prototype.getGuid = function /** @no-inline */() {
                return this._iGuid < 0 ? (this._iGuid = akra.sid()) : this._iGuid;
            };
            RPC.prototype.connect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().addDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            RPC.prototype.disconnect = function /** @inline */(pSender, sSignal, sSlot, eType) {
                return pSender.getEventTable().removeDestination(pSender.getGuid(), sSignal, this, sSlot, eType);
            };
            RPC.prototype.bind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType);
            };
            RPC.prototype.unbind = function /** @inline */(sSignal, fnListener, eType) {
                return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType);
            };
            RPC.prototype.joined = function /** @no-inline */() {
                this._pBroadcastSlotList = this._pBroadcastSlotList || this.getEventTable().findBroadcastList(this._iGuid);
                var _broadcast = (this._pBroadcastSlotList).joined;
                var _recivier = this;
                if(akra.isDef(_broadcast)) {
                    for(var i = 0; i < _broadcast.length; ++i) {
                        _broadcast[i].target ? _broadcast[i].target[_broadcast[i].callback](_recivier) : _broadcast[i].listener(_recivier);
                    }
                }
            };
            RPC.requestPool = new akra.ObjectArray();
            RPC.callbackPool = new akra.ObjectArray();
            RPC.OPTIONS = {
                DEFFERED_CALLS_LIMIT: 1024,
                RECONNECT_TIMEOUT: 2500
            };
            RPC.ERRORS = {
                STACK_SIZE_EXCEEDED: new Error("stack size exceeded")
            };
            RPC.PROC_LIST = "proc_list";
            return RPC;
        })();
        net.RPC = RPC;        
        function /** @no-inline */createRpc() {
            return new RPC();
        }
        net.createRpc = createRpc;
    })(akra.net || (akra.net = {}));
    var net = akra.net;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (terrain) {
        var MegaTexture = (function () {
            function /** @no-inline */MegaTexture(pEngine, pObject, sSurfaceTextures) {
                this._pEngine = null;
                // private _pDevice = null;
                this._pObject = null;
                this._pWorldExtents = null;
                //Координаты камеры на объекте
                this._v2fCameraCoord = new akra.Vec2(0, 0);
                //Путь откуда запрашиваются куски текстуры
                this._sSurfaceTextures = "";
                //Маскимальный размер стороны текстуры
                this._iOriginalTextureMaxSize = 8192;
                //Размер блока текстуры(минимальный размер выгружаемого куска текстуры)
                this._iBlockSize = 32;
                //Тип хранимых тектсур
                this._eTextureType = 11 /* BYTE_BGR */ ;
                this._iTextureHeight = 1024;
                this._iTextureWidth = 1024;
                this._pTexures = null;
                //Буффер, который в два раза шире МегаТекстур, используется что бы заранее подгружать чуть больше чем нужно для текущего отображения,
                //дает возможность начинать выгружать данные чуть раньше чем они понадобяться и в тож время сохраняет некий кеш,
                //чтобы в случае возвращения на старую точку не перзагружать что недавно использовалось
                this._iBufferHeight = 0;
                this._iBufferWidth = 0;
                this._pBuffer = null;
                //Карта с разметкой буфера, чтобы знать какой части буффер уже отсылалось задание на заполнение
                this._pBufferMap = null;
                this._pXY = null;
                //Всякие темповые буферы
                this._pDataFor = null;
                this._pMapDataFor = null;
                this._pMapDataNULL = null;
                this._pRPC = new akra.net.RPC('ws://192.168.194.132');
                this._fTexCourdXOld = undefined;
                this._fTexCourdYOld = undefined;
                this._nCountRender = 0;
                this._pEngine = pEngine;
                // this._pDevice = pEngine.pDevice;
                this._pObject = pObject;
                this._pWorldExtents = pObject.worldExtents();
                this._sSurfaceTextures = sSurfaceTextures;
                var iCountTex = akra.math.log2(this._iOriginalTextureMaxSize / akra.math.max(this._iTextureHeight, this._iTextureWidth)) + 1;
                this._pTexures = new Array(iCountTex);
                this._pBuffer = new Array(iCountTex);
                this._pBufferMap = new Array(iCountTex);
                this._pXY = new Array(iCountTex);
                this._iBufferHeight = this._iTextureHeight * 2;
                this._iBufferWidth = this._iTextureWidth * 2;
                this._pDataFor = new Uint8Array(this._iBufferWidth * this._iBufferHeight * akra.pixelUtil.getNumElemBytes(this._eTextureType));
                this._pMapDataFor = new Uint32Array(this._iBufferHeight * this._iBufferWidth / (this._iBlockSize * this._iBlockSize));
                this._pMapDataNULL = new Uint32Array(this._iBufferHeight * this._iBufferWidth / (this._iBlockSize * this._iBlockSize));
                for(var i = 0; i < this._pMapDataNULL.length; i++) {
                    this._pMapDataNULL[i] = 0;
                }
                this.setBufferMapNULL(this._pMapDataFor);
                //Создаем куски мегатекстуры
                for(var i = 0; i < this._pTexures.length; i++) {
                    /*this._pEngine*/
                    this._pTexures[i] = new akra.core.pool.resources.Texture();
                    this._pTexures[i].create(this._iTextureWidth, this._iTextureHeight, 1, new akra.Color(0, 0, 0, 1), akra.ETextureFlags.DYNAMIC, 1, 3553 /* TEXTURE_2D */ , this._eTextureType);
                    this._pTexures[i].setParameter(10242 /* WRAP_S */ , 33071 /* CLAMP_TO_EDGE */ );
                    this._pTexures[i].setParameter(10243 /* WRAP_T */ , 33071 /* CLAMP_TO_EDGE */ );
                    if(i == 0) {
                        this._pBuffer[i] = new Uint8Array(this._iTextureHeight * this._iTextureWidth * akra.pixelUtil.getNumElemBytes(this._eTextureType));
                        //на самом деле this._iTextureHeight*this._iTextureWidth
                        this._pBufferMap[i] = new Uint32Array(this._iBufferHeight * this._iBufferWidth / (this._iBlockSize * this._iBlockSize));
                        this.setBufferMapNULL(this._pBufferMap[i]);
                        //Худшего качества статична поэтому размер у буфера такойже как у текстуры this._iBlockSize
                                            } else {
                        this._pBuffer[i] = new Uint8Array(this._iBufferHeight * this._iBufferWidth * akra.pixelUtil.getNumElemBytes(this._eTextureType));
                        this._pBufferMap[i] = new Uint32Array(this._iBufferHeight * this._iBufferWidth / (this._iBlockSize * this._iBlockSize));
                        this.setBufferMapNULL(this._pBufferMap[i]);
                    }
                    /*Координты буфера в основной текстуре, для простыты должны быть кратну размеру блока*/
                    this._pXY[i] = {
                        iX: 0,
                        iY: 0,
                        iTexX: /*Координаты мегатекстуры в текстуре*/
                        0,
                        iTexY: 0,
                        isUpdated: true,
                        isLoaded: false
                    };
                }
                this.getDataFromServer(0, 0, 0, this._iTextureWidth, this._iTextureHeight);
            }
            MegaTexture.prototype.prepareForRender = function /** @no-inline */() {
                var pCamera = this._pEngine.getRenderer()._getViewport().getCamera();
                var v3fCameraPosition = pCamera.targetPos;
                //Вычисление текстурных координат над которыми находиться камера
                var fTexCourdX = (v3fCameraPosition.x - this._pWorldExtents.x0) / akra.math.abs(this._pWorldExtents.x1 - this._pWorldExtents.x0);
                var fTexCourdY = (v3fCameraPosition.y - this._pWorldExtents.y0) / akra.math.abs(this._pWorldExtents.y1 - this._pWorldExtents.y0);
                this._v2fCameraCoord.set(fTexCourdX, fTexCourdY);
                var iX, iX1, iX2;
                var iY, iY1, iY2;
                var iWidth, iHeight;
                //Нужно ли перекладвывать, отсавим на запас 8 блоков
                //Опираемся на текстуру самого хорошего разрешения
                iX = akra.math.round(fTexCourdX * (this.getWidthOrig(this._pTexures.length - 1)) - this._iTextureWidth / 2);
                iY = akra.math.round(fTexCourdY * (this.getHeightOrig(this._pTexures.length - 1)) - this._iTextureHeight / 2);
                iWidth = this._iTextureWidth;
                iHeight = this._iTextureHeight;
                //console.log("=> Смена координат")
                //console.log(iX,this._pXY[this._pTexures.length-1].iX,math.floor((iX-this._pXY[this._pTexures.length-1].iX)));
                //console.log(iY,this._pXY[this._pTexures.length-1].iY,math.floor((iY-this._pXY[this._pTexures.length-1].iY)));
                //console.log(iX,this._pXY[this._pTexures.length-1].iX+this._iTextureWidth,math.floor((this._iTextureHeight-iX+this._pXY[this._pTexures.length-1].iX)));
                //console.log(iY,this._pXY[this._pTexures.length-1].iY+this._iTextureHeight,math.floor((this._iTextureHeight-iY+this._pXY[this._pTexures.length-1].iY)));
                if(akra.math.floor((iX - this._pXY[this._pTexures.length - 1].iX) / this._iBlockSize) < 8 || akra.math.floor((iY - this._pXY[this._pTexures.length - 1].iY) / this._iBlockSize) < 8 || akra.math.floor((this._pXY[this._pTexures.length - 1].iX + this._iBufferWidth - (iX + iWidth)) / this._iBlockSize) < 8 || akra.math.floor((this._pXY[this._pTexures.length - 1].iY + this._iBufferHeight - (iY + iHeight)) / this._iBlockSize) < 8) {
                    console.log("Да");
                    //Перемещаем
                    for(i = 1; i < this._pTexures.length; i++) {
                        console.log("Уровень", i);
                        //Вычисляем новые координаты буфера в текстуре
                        var iXnew = akra.math.round(fTexCourdX * this.getWidthOrig(i) - this._iTextureWidth / 2);
                        var iYnew = akra.math.round(fTexCourdY * this.getHeightOrig(i) - this._iTextureHeight / 2);
                        iXnew -= (this._iBufferWidth - this._iTextureWidth) / 2;
                        iYnew -= (this._iBufferHeight - this._iTextureHeight) / 2;
                        //Округлили на размер блока
                        iXnew = akra.math.round((iXnew / this._iBlockSize)) * this._iBlockSize;
                        iYnew = akra.math.round((iYnew / this._iBlockSize)) * this._iBlockSize;
                        //Копирование совпадающего куска
                        var iXOverlappingBlockInOldBuf = iXnew - this._pXY[i].iX;
                        var iYOverlappingBlockInOldBuf = iYnew - this._pXY[i].iY;
                        var iXOverlappingBlockInNewBuf = -iXOverlappingBlockInOldBuf;
                        var iYOverlappingBlockInNewBuf = -iYOverlappingBlockInOldBuf;
                        iXOverlappingBlockInOldBuf = akra.math.max(0, iXOverlappingBlockInOldBuf);
                        iYOverlappingBlockInOldBuf = akra.math.max(0, iYOverlappingBlockInOldBuf);
                        iXOverlappingBlockInNewBuf = akra.math.max(0, iXOverlappingBlockInNewBuf);
                        iYOverlappingBlockInNewBuf = akra.math.max(0, iYOverlappingBlockInNewBuf);
                        if(iXOverlappingBlockInOldBuf < this._iBufferWidth && iYOverlappingBlockInOldBuf < this._iBufferHeight && iXOverlappingBlockInNewBuf < this._iBufferWidth && iYOverlappingBlockInNewBuf < this._iBufferHeight) {
                            //console.log(this._pXY[i].iX,this._pXY[i].iY,"==>",iXnew,iYnew)
                            //console.log("Из",iXOverlappingBlockInOldBuf,iYOverlappingBlockInOldBuf);
                            //console.log("В ",iXOverlappingBlockInNewBuf,iYOverlappingBlockInNewBuf);
                            //произошло совпадение кусков
                            var iOverlappingBlockWidth = this._iBufferWidth - akra.math.abs(iXnew - this._pXY[i].iX);
                            var iOverlappingBlockHeight = this._iBufferHeight - akra.math.abs(iYnew - this._pXY[i].iY);
                            //копируем данные
                            console.log("Копированеи совпадающей части");
                            //console.log(this._pDataFor.length,iXOverlappingBlockInNewBuf,iYOverlappingBlockInNewBuf,iOverlappingBlockWidth,iOverlappingBlockHeight);
                            this._setDataBetweenBuffer(this._pDataFor, iXOverlappingBlockInNewBuf, iYOverlappingBlockInNewBuf, this._pBuffer[i], iXOverlappingBlockInOldBuf, iYOverlappingBlockInOldBuf, iOverlappingBlockWidth, iOverlappingBlockHeight);
                            this.setBufferMapNULL(this._pMapDataFor);
                            this._setDataBetweenBufferMap(this._pMapDataFor, iXOverlappingBlockInNewBuf / this._iBlockSize, iYOverlappingBlockInNewBuf / this._iBlockSize, this._pBufferMap[i], iXOverlappingBlockInOldBuf / this._iBlockSize, iYOverlappingBlockInOldBuf / this._iBlockSize, iOverlappingBlockWidth / this._iBlockSize, iOverlappingBlockHeight / this._iBlockSize);
                            var t = this._pBuffer[i];
                            this._pBuffer[i] = this._pDataFor;
                            this._pDataFor = t;
                            var t = this._pBufferMap[i];
                            this._pBufferMap[i] = this._pMapDataFor;
                            this._pMapDataFor = t;
                        } else {
                            this.setBufferMapNULL(this._pBufferMap[i]);
                        }
                        console.log(this._pXY[i].iX, this._pXY[i].iY, "==>", iXnew, iYnew);
                        this._pXY[i].iX = iXnew;
                        this._pXY[i].iY = iYnew;
                        this._pXY[i].isUpdated = true;
                        console.log(this._pXY[i].iX, this._pXY[i].iY);
                    }
                }
                //Подгрузка части буфера которую ложиться в текстуру + 8 блоков
                //Нулевая статична, поэтому ее не меняем
                for(var i = 0; i < this._pTexures.length; i++) {
                    if(i != 0) {
                        iX = akra.math.round(fTexCourdX * this.getWidthOrig(i) - this._iTextureWidth / 2);
                        iY = akra.math.round(fTexCourdY * this.getHeightOrig(i) - this._iTextureHeight / 2);
                        iWidth = this._iTextureWidth;
                        iHeight = this._iTextureHeight;
                        //На данный момент нужен кусок текстуры таких размеров iX1,iY1,iWidth,iHeight,
                        var iAreaX1 = iX;
                        var iAreaY1 = iY;
                        var iAreaX2 = iX + iWidth;
                        var iAreaY2 = iY + iHeight;
                        //console.log("Запрос частей текстур на ��качивание");
                        //console.log(iX1,this._pXY[i].iX);
                        //console.log(iY1,this._pXY[i].iY);
                        //console.log(iX2,this._pXY[i].iX+this._iBufferWidth);
                        //console.log(iY2,this._pXY[i].iY+this._iBufferHeight);
                        //Смотрим попадаем ли мы в текущий буфер
                        if(iX >= this._pXY[i].iX && iY >= this._pXY[i].iY && iX + this._iTextureWidth < this._pXY[i].iX + this._iBufferWidth && iY + this._iTextureHeight < this._pXY[i].iY + this._iBufferHeight) {
                            //Типа попали
                            //Значит нужно загрузить необходимые куски
                            //Обрезаемся чтобы не вылезти за пределы
                            iX -= this._iBlockSize * 8;
                            iY -= this._iBlockSize * 8;
                            iWidth += this._iBlockSize * 16;
                            iHeight += this._iBlockSize * 16;
                            iX1 = akra.math.clamp(iX, 0, this.getWidthOrig(i));
                            iY1 = akra.math.clamp(iY, 0, this.getHeightOrig(i));
                            iX2 = akra.math.clamp(iX + iWidth, 0, this.getWidthOrig(i));
                            iY2 = akra.math.clamp(iY + iHeight, 0, this.getHeightOrig(i));
                            var iAreaX1 = akra.math.clamp(iAreaX1, 0, this.getWidthOrig(i));
                            var iAreaY1 = akra.math.clamp(iAreaY1, 0, this.getHeightOrig(i));
                            var iAreaX2 = akra.math.clamp(iAreaX2, 0, this.getWidthOrig(i));
                            var iAreaY2 = akra.math.clamp(iAreaY2, 0, this.getHeightOrig(i));
                            /*Остальные область проверки*/
                            this.getDataFromServer(i, iX1, iY1, iX2 - iX1, iY2 - iY1, iAreaX1, iAreaY1, iAreaX2 - iAreaX1, iAreaY2 - iAreaY1);
                        } else {
                            /*trace(iX, iY, iX + this._iTextureWidth, iY + this._iTextureWidth);
                            trace(i);
                            trace(this._pXY[i].iX, this._pXY[i].iY, this._pXY[i].iX + this._iBufferWidth,
                            this._pXY[i].iX + this._iBufferHeight);*/
                            akra.logger.setSourceLocation("terrain/MegaTexture.ts", 289);
                            akra.logger.error("Не может такого быть чтобы буфер не попал под текстуру");
                            ;
                        }
                    } else {
                        if(!this._pXY[0].isLoaded) {
                            this.getDataFromServer(0, 0, 0, this._iTextureWidth, this._iTextureHeight);
                        }
                    }
                }
                if(((this._nCountRender++) % 10) == 0) {
                    var iTexInBufX = 0;
                    var iTexInBufY = 0;
                    i = (akra.math.round(this._nCountRender / 10)) % this._pBuffer.length;
                    if(i == 0) {
                        if(this._pXY[i].isUpdated == true) {
                            this._pTexures[i].setPixelRGBA(0, 0, this._iTextureWidth, this._iTextureHeight, this._pBuffer[0]);
                        }
                    } else {
                        if(this._pXY[i].isLoaded == true && (this._pXY[i].isUpdated == true || this._fTexCourdXOld != fTexCourdX || this._fTexCourdYOld != fTexCourdY)) {
                            //координаты угла мегатекстуре на текстуре
                            iTexInBufX = akra.math.round(fTexCourdX * this.getWidthOrig(i) - this._iTextureWidth / 2);
                            iTexInBufY = akra.math.round(fTexCourdY * this.getHeightOrig(i) - this._iTextureHeight / 2);
                            this._pXY[i].iTexX = iTexInBufX / this.getWidthOrig(i);
                            this._pXY[i].iTexY = iTexInBufY / this.getHeightOrig(i);
                            iTexInBufX -= this._pXY[i].iX;
                            iTexInBufY -= this._pXY[i].iY;
                            this._setData(this._pDataFor, 0, 0, this._iTextureWidth, this._iTextureHeight, this._pBuffer[i], iTexInBufX, iTexInBufY, this._iBufferWidth, this._iBufferHeight, this._iTextureWidth, this._iTextureHeight, akra.pixelUtil.getNumElemBytes(this._eTextureType));
                            this._pTexures[i].setPixelRGBA(0, 0, this._iTextureWidth, this._iTextureHeight, this._pDataFor);
                            /*var c2d=document.getElementById('canvas1_'+i).getContext("2d");
                            var pData=c2d.getImageData(0,0,128,128);
                            //console.log("!!!");
                            //console.log(pData);
                            //console.log(pData.data.length,this._pBuffer[i][0],this._pBuffer[i][1],this._pBuffer[i][2]);
                            for(var p=0,p1=0;p<pData.data.length;p+=4,p1+=3*8)
                            {
                            pData.data[p+0]=this._pDataFor[p1+0];
                            pData.data[p+1]=this._pDataFor[p1+1];
                            pData.data[p+2]=this._pDataFor[p1+2];
                            pData.data[p+3]=255;
                            if(p1%(1024*3)==0&&p1!=0)
                            p1+=3*(1024*(8-1))
                            
                            }
                            c2d.putImageData(pData, 0, 0);*/
                                                    }
                    }
                    this._pXY[i].isUpdated = false;
                }
                if(((this._nCountRender++) % 11) == 0) {
                    for(var i = 0; i < this._pTexures.length; i++) {
                        var c2d = (document.getElementById('canvas' + i)).getContext("2d");
                        var pData = c2d.getImageData(0, 0, 128, 128);
                        if(i != 0) {
                            //console.log(pData.data.length,this._pBuffer[i][0],this._pBuffer[i][1],this._pBuffer[i][2]);
                            for(var p = 0, p1 = 0; p < pData.data.length; p += 4 , p1 += 3 * 16) {
                                pData.data[p + 0] = this._pBuffer[i][p1 + 0];
                                pData.data[p + 1] = this._pBuffer[i][p1 + 1];
                                pData.data[p + 2] = this._pBuffer[i][p1 + 2];
                                pData.data[p + 3] = 255;
                                if(p1 % (2048 * 3) == 0 && p1 != 0) {
                                    p1 += 3 * (2048 * (16 - 1));
                                }
                            }
                        } else {
                            //console.log(pData.data.length,this._pBuffer[i][0],this._pBuffer[i][1],this._pBuffer[i][2]);
                            for(var p = 0, p1 = 0; p < pData.data.length; p += 4 , p1 += 3 * 8) {
                                pData.data[p + 0] = this._pBuffer[i][p1 + 0];
                                pData.data[p + 1] = this._pBuffer[i][p1 + 1];
                                pData.data[p + 2] = this._pBuffer[i][p1 + 2];
                                pData.data[p + 3] = 255;
                                if(p1 % (1024 * 3) == 0 && p1 != 0) {
                                    p1 += 3 * (1024 * (8 - 1));
                                }
                            }
                        }
                        c2d.putImageData(pData, 0, 0);
                        if(i != 0) {
                            iTexInBufX = akra.math.round(fTexCourdX * this.getWidthOrig(i) - this._iTextureWidth / 2);
                            iTexInBufY = akra.math.round(fTexCourdY * this.getHeightOrig(i) - this._iTextureHeight / 2);
                            iTexInBufX -= this._pXY[i].iX;
                            iTexInBufY -= this._pXY[i].iY;
                            c2d.strokeStyle = '#fff';
                            c2d.lineWidth = 1;
                            c2d.strokeRect(akra.math.floor(iTexInBufX / 16) - 1, akra.math.floor(iTexInBufY / 16) - 1, akra.math.floor(this._iTextureWidth / 16) + 2, akra.math.floor(this._iTextureHeight / 16) + 2);
                            var c2d = (document.getElementById('canvas0_' + i)).getContext("2d");
                            var pData = c2d.getImageData(0, 0, 128, 128);
                            //console.log(pData.data.length,this._pBuffer[i][0],this._pBuffer[i][1],this._pBuffer[i][2]);
                            for(var p = 0, p1 = 0; p < pData.data.length; p += 4 , p1 += 3 * 16) {
                                pData.data[p + 0] = this._pDataFor[p1 + 0];
                                pData.data[p + 1] = this._pDataFor[p1 + 1];
                                pData.data[p + 2] = this._pDataFor[p1 + 2];
                                pData.data[p + 3] = 255;
                                if(p1 % (2048 * 3) == 0 && p1 != 0) {
                                    p1 += 3 * (2048 * (16 - 1));
                                }
                            }
                            c2d.putImageData(pData, 0, 0);
                            iTexInBufX = akra.math.round(fTexCourdX * this.getWidthOrig(i) - this._iTextureWidth / 2);
                            iTexInBufY = akra.math.round(fTexCourdY * this.getHeightOrig(i) - this._iTextureHeight / 2);
                            iTexInBufX -= this._pXY[i].iX;
                            iTexInBufY -= this._pXY[i].iY;
                            c2d.strokeStyle = '#fff';
                            c2d.lineWidth = 1;
                            c2d.strokeRect(akra.math.floor(iTexInBufX / 16) - 1, akra.math.floor(iTexInBufY / 16) - 1, akra.math.floor(this._iTextureWidth / 16) + 2, akra.math.floor(this._iTextureHeight / 16) + 2);
                        }
                        var c2d = (document.getElementById('canvas2_' + i)).getContext("2d");
                        //console.log(pData.data.length,this._pBuffer[i][0],this._pBuffer[i][1],this._pBuffer[i][2]);
                        var pData = c2d.getImageData(0, 0, 64, 64);
                        if(i != 0) {
                            for(var p = 0, p1 = 0; p < pData.data.length; p += 4 , p1 += 1) {
                                pData.data[p + 0] = (this._pBufferMap[i][p1] / 0xFFFFFFFF) * 255;
                                pData.data[p + 1] = (this._pBufferMap[i][p1] / 0xFFFFFFFF) * 255;
                                pData.data[p + 2] = (this._pBufferMap[i][p1] / 0xFFFFFFFF) * 255;
                                pData.data[p + 3] = 255;
                            }
                        } else {
                            for(var p = 0, p1 = 0; p < pData.data.length; p += 4 , p1 += 0.5) {
                                pData.data[p + 0] = (this._pBufferMap[i][akra.math.round(p1)] / 0xFFFFFFFF) * 255;
                                pData.data[p + 1] = (this._pBufferMap[i][akra.math.round(p1)] / 0xFFFFFFFF) * 255;
                                pData.data[p + 2] = (this._pBufferMap[i][akra.math.round(p1)] / 0xFFFFFFFF) * 255;
                                pData.data[p + 3] = 255;
                                if(p % (8 * 64) == 0 && p != 0) {
                                    p1 -= (32);
                                }
                            }
                        }
                        c2d.putImageData(pData, 0, 0);
                        if(i != 0) {
                            iTexInBufX = akra.math.round(fTexCourdX * this.getWidthOrig(i) - this._iTextureWidth / 2);
                            iTexInBufY = akra.math.round(fTexCourdY * this.getHeightOrig(i) - this._iTextureHeight / 2);
                            iTexInBufX -= this._pXY[i].iX;
                            iTexInBufY -= this._pXY[i].iY;
                            c2d.strokeStyle = '#f00';
                            c2d.lineWidth = 1;
                            c2d.strokeRect(akra.math.floor(iTexInBufX / (32)) - 1, akra.math.floor(iTexInBufY / (32)) - 1, akra.math.floor(this._iTextureWidth / (32)) + 2, akra.math.floor(this._iTextureHeight / (32)) + 2);
                        }
                    }
                }
                this._fTexCourdXOld = fTexCourdX;
                this._fTexCourdYOld = fTexCourdY;
            };
            MegaTexture.prototype.applyForRender = function /** @no-inline */(pSnapshot) {
                pSnapshot.setParameterBySemantic('CAMERA_COORD', this._v2fCameraCoord);
                for(var i = 0; i < this._pTexures.length; i++) {
                    pSnapshot.setParameter('textureCoord' + i, [
                        this._pXY[i].iTexX, 
                        this._pXY[i].iTexY
                    ]);
                    pSnapshot.setParameter('textureTerrainIsLoaded' + i, this._pXY[i].isLoaded);
                    pSnapshot.applyTextureBySemantic("TEXTURE" + i, this._pTexures[i]);
                }
            };
            MegaTexture.prototype.setBufferMapNULL = function /** @no-inline */(pBuffer) {
                pBuffer.set(this._pMapDataNULL, 0);
            };
            MegaTexture.prototype.setData = function /** @no-inline */(pBuffer, iX, iY, iWidth, iHeight, pBufferIn, iInX, iInY, iInWidth, iInHeight, iBlockWidth, iBlockHeight, iComponents) {
                iBlockHeight = akra.math.max(0, iBlockHeight);
                iBlockWidth = akra.math.max(0, iBlockWidth);
                iBlockHeight = akra.math.min(iBlockHeight, iHeight - iY, iInHeight - iInY);
                iBlockWidth = akra.math.min(iBlockWidth, iWidth - iX, iInWidth - iInX);
                if(pBuffer.length < ((iY + iBlockHeight - 1) * iWidth + iX + iBlockWidth) * iComponents) {
                    /*trace(pBuffer.length, iX, iY, iBlockWidth, iBlockHeight, iWidth, iHeight, iComponents);
                    trace(pBuffer.length, ((iY + iBlockHeight - 1) * iWidth + iX + iBlockWidth) * iComponents);*/
                    akra.logger.setSourceLocation("terrain/MegaTexture.ts", 492);
                    akra.logger.error("Выход за предел массива 1");
                    ;
                }
                if(pBufferIn.length < ((iInY + iBlockHeight - 1) * iInWidth + iInX + iBlockWidth) * iComponents) {
                    akra.logger.setSourceLocation("terrain/MegaTexture.ts", 496);
                    akra.logger.error("Выход за предел массива 2");
                    ;
                }
                for(var i = 0; i < iBlockHeight; i++) {
                    for(var j = 0; j < iBlockWidth; j++) {
                        for(var k = 0; k < iComponents; k++) {
                            pBuffer[((iY + i) * iWidth + iX + j) * iComponents + k] = pBufferIn[((iInY + i) * iInWidth + iInX + j) * iComponents + k];
                        }
                    }
                }
            };
            MegaTexture.prototype.setDataT = function /** @no-inline */(pBuffer, iX, iY, iWidth, iHeight, pBufferIn, iInX, iInY, iInWidth, iInHeight, iBlockWidth, iBlockHeight, iComponents) {
                iBlockHeight = akra.math.max(0, iBlockHeight);
                iBlockWidth = akra.math.max(0, iBlockWidth);
                iBlockHeight = akra.math.min(iBlockHeight, iHeight - iY, iInHeight - iInY);
                iBlockWidth = akra.math.min(iBlockWidth, iWidth - iX, iInWidth - iInX);
                if(pBuffer.length < ((iY + iBlockHeight - 1) * iWidth + iX + iBlockWidth) * iComponents) {
                    /*trace(pBuffer.length, iX, iY, iBlockWidth, iBlockHeight, iWidth, iHeight, iComponents);
                    trace(pBuffer.length, ((iY + iBlockHeight - 1) * iWidth + iX + iBlockWidth) * iComponents);*/
                    akra.logger.setSourceLocation("terrain/MegaTexture.ts", 518);
                    akra.logger.error("Выход за предел массива 1");
                    ;
                }
                if(pBufferIn.length < ((iInY + iBlockHeight - 1) * iInWidth + iInX + iBlockWidth) * iComponents) {
                    akra.logger.setSourceLocation("terrain/MegaTexture.ts", 521);
                    akra.logger.error("Выход за предел массива 2");
                    ;
                }
                var iLenStr = iBlockWidth * iComponents;
                var iStartIn = 0;
                var iStartOut = 0;
                for(var i = 0; i < iBlockHeight; i++) {
                    iStartIn = ((iInY + i) * iInWidth + iInX) * iComponents;
                    iStartOut = ((iY + i) * iWidth + iX) * iComponents;
                    if(pBufferIn.BYTES_PER_ELEMENT == 8) {
                        pBuffer.set(new Float64Array(pBufferIn.buffer.slice(iStartIn * 8, (iStartIn + iLenStr) * 8)), iStartOut);
                    } else if(pBufferIn.BYTES_PER_ELEMENT == 4) {
                        pBuffer.set(new Uint32Array(pBufferIn.buffer.slice(iStartIn * 4, (iStartIn + iLenStr) * 4)), iStartOut);
                    } else if(pBufferIn.BYTES_PER_ELEMENT == 2) {
                        pBuffer.set(new Uint16Array(pBufferIn.buffer.slice(iStartIn * 2, (iStartIn + iLenStr) * 2)), iStartOut);
                    } else {
                        pBuffer.set(new Uint8Array(pBufferIn.buffer.slice(iStartIn, iStartIn + iLenStr)), iStartOut);
                    }
                }
            };
            MegaTexture.prototype._setData = function /** @no-inline */(pBuffer, iX, iY, iWidth, iHeight, pBufferIn, iInX, iInY, iInWidth, iInHeight, iBlockWidth, iBlockHeight, iComponents) {
                this.setDataT(pBuffer, iX, iY, iWidth, iHeight, pBufferIn, iInX, iInY, iInWidth, iInHeight, iBlockWidth, iBlockHeight, iComponents);
            };
            MegaTexture.prototype._setDataBetweenBuffer = function /** @no-inline */(pBuffer, iX, iY, pBufferIn, iInX, iInY, iBlockWidth, iBlockHeight) {
                var iInWidth = this._iBufferWidth;
                var iInHeight = this._iBufferHeight;
                var iComponents = akra.pixelUtil.getNumElemBytes(this._eTextureType);
                var iWidth = this._iBufferWidth;
                var iHeight = this._iBufferHeight;
                this.setDataT(pBuffer, iX, iY, iWidth, iHeight, pBufferIn, iInX, iInY, iInWidth, iInHeight, iBlockWidth, iBlockHeight, iComponents);
            };
            MegaTexture.prototype._setDataBetweenBufferMap = function /** @no-inline */(pBuffer, iX, iY, pBufferIn, iInX, iInY, iBlockWidth, iBlockHeight) {
                var iInWidth = this._iBufferWidth / this._iBlockSize;
                var iInHeight = this._iBufferHeight / this._iBlockSize;
                var iComponents = 1;
                var iWidth = this._iBufferWidth / this._iBlockSize;
                var iHeight = this._iBufferHeight / this._iBlockSize;
                this.setDataT(pBuffer, iX, iY, iWidth, iHeight, pBufferIn, iInX, iInY, iInWidth, iInHeight, iBlockWidth, iBlockHeight, iComponents);
            };
            MegaTexture.prototype._setDataFromBlock = function /** @no-inline */(pBuffer, iX, iY, pBufferIn) {
                var iInX = 0;
                var iInY = 0;
                var iInWidth = this._iBlockSize;
                var iInHeight = this._iBlockSize;
                var iBlockWidth = this._iBlockSize;
                var iBlockHeight = this._iBlockSize;
                var iComponents = akra.pixelUtil.getNumElemBytes(this._eTextureType);
                var iWidth = 0;
                var iHeight = 0;
                if(pBuffer.length == this._iBufferWidth * this._iBufferHeight * iComponents) {
                    iWidth = this._iBufferWidth;
                    iHeight = this._iBufferHeight;
                } else if(pBuffer.length == this._iBufferWidth * this._iBufferHeight * iComponents / 4) {
                    iWidth = this._iBufferWidth / 2;
                    iHeight = this._iBufferHeight / 2;
                } else {
                    console.log("Странный размер массива", pBuffer, pBuffer.length, this._iBufferWidth * this._iBufferHeight * iComponents, this._iBufferWidth * this._iBufferHeight * iComponents / 4);
                }
                //в хроме бужет рабоать быстрее SetData
                this.setDataT(pBuffer, iX, iY, iWidth, iHeight, pBufferIn, iInX, iInY, iInWidth, iInHeight, iBlockWidth, iBlockHeight, iComponents);
            };
            MegaTexture.prototype.getWidthOrig = function /** @no-inline */(iLevel) {
                return this._iTextureWidth << iLevel;
            };
            MegaTexture.prototype.getHeightOrig = function /** @no-inline */(iLevel) {
                return this._iTextureHeight << iLevel;
            };
            MegaTexture.prototype.getDataFromServer = function /** @no-inline */(iLevelTex, iOrigTexX, iOrigTexY, iWidth, iHeight, iAreaX, iAreaY, iAreaWidth, iAreaHeight) {
                var iOrigTexEndX = akra.math.ceil((iOrigTexX + iWidth) / this._iBlockSize) * this._iBlockSize;
                var iOrigTexEndY = akra.math.ceil((iOrigTexY + iHeight) / this._iBlockSize) * this._iBlockSize;
                iOrigTexX = akra.math.max(0, iOrigTexX);
                iOrigTexY = akra.math.max(0, iOrigTexY);
                iOrigTexX = akra.math.floor(iOrigTexX / this._iBlockSize) * this._iBlockSize;
                iOrigTexY = akra.math.floor(iOrigTexY / this._iBlockSize) * this._iBlockSize;
                iOrigTexEndX = akra.math.min(iOrigTexEndX, this.getWidthOrig(iLevelTex));
                iOrigTexEndY = akra.math.min(iOrigTexEndY, this.getHeightOrig(iLevelTex));
                var iAreaEndX = iAreaX + iAreaWidth;
                var iAreaEndY = iAreaY + iAreaHeight;
                iAreaX = akra.math.max(0, iAreaX);
                iAreaY = akra.math.max(0, iAreaY);
                iAreaEndX = akra.math.min(iAreaEndX, this.getWidthOrig(iLevelTex));
                iAreaEndY = akra.math.min(iAreaEndY, this.getHeightOrig(iLevelTex));
                var isLoaded = true;
                //trace("Кординаты внутри оригинальной текстуре",iOrigTexX,iOrigTexY,iOrigTexEndX,iOrigTexEndY,iLevelTex);
                var me = this;
                var tCurrentTime = (me._pEngine.getTimer().absoluteTime * 1000) >>> 0;
                //	if(iLevelTex==2)
                //	{
                //		trace(iOrigTexX,iOrigTexY,iOrigTexEndX,iOrigTexEndY,"(",me._pXY[iLevelTex].iX,me._pXY[iLevelTex].iY,")");
                //	}
                for(var i = iOrigTexY; i < iOrigTexEndY; i += this._iBlockSize) {
                    for(var j = iOrigTexX; j < iOrigTexEndX; j += this._iBlockSize) {
                        //trace("Загрузка куска",i,j);
                        if(iLevelTex == 0) {
                            if(me._pBufferMap[iLevelTex][(i - me._pXY[iLevelTex].iY) / me._iBlockSize * (me._iTextureWidth / me._iBlockSize) + (j - me._pXY[iLevelTex].iX) / me._iBlockSize] != 0xFFFFFFFF) {
                                isLoaded = false;
                            }
                            if(tCurrentTime != 0 && tCurrentTime - me._pBufferMap[iLevelTex][(i - me._pXY[iLevelTex].iY) / me._iBlockSize * (me._iTextureWidth / me._iBlockSize) + (j - me._pXY[iLevelTex].iX) / me._iBlockSize] < 5000) {
                                continue;
                            }
                            if(me._pBufferMap[iLevelTex][(i - me._pXY[iLevelTex].iY) / me._iBlockSize * (me._iTextureWidth / me._iBlockSize) + (j - me._pXY[iLevelTex].iX) / me._iBlockSize] == 0xFFFFFFFF) {
                                continue;
                            }
                            me._pBufferMap[iLevelTex][(i - me._pXY[iLevelTex].iY) / me._iBlockSize * (me._iTextureWidth / me._iBlockSize) + (j - me._pXY[iLevelTex].iX) / me._iBlockSize] = tCurrentTime;
                        } else {
                            /*				if(me._pBufferMap[iLevelTex][(i-me._pXY[iLevelTex].iY)/me._iBlockSize*(me._iBufferWidth/me._iBlockSize)+(j-me._pXY[iLevelTex].iX)/me._iBlockSize]==0xFFFFFFFF)
                            {
                            if(iLevelTex==2&&i==0)
                            {
                            //console.log("!!");
                            }
                            continue;
                            }
                            
                            //trace("Кусок еще не загружен",iLevelTex,j,i,32,32);*/
                            //Проверка на выставление флага о полной загруженности вилимой области
                            if(j >= iAreaX && j < iAreaEndX && i >= iAreaY && i < iAreaEndY && me._pBufferMap[iLevelTex][(i - me._pXY[iLevelTex].iY) / me._iBlockSize * (me._iBufferWidth / me._iBlockSize) + (j - me._pXY[iLevelTex].iX) / me._iBlockSize] != 0xFFFFFFFF) {
                                isLoaded = false;
                            }
                            if(tCurrentTime - me._pBufferMap[iLevelTex][(i - me._pXY[iLevelTex].iY) / me._iBlockSize * (me._iBufferWidth / me._iBlockSize) + (j - me._pXY[iLevelTex].iX) / me._iBlockSize] < 5000) {
                                continue;
                            }
                            if(me._pBufferMap[iLevelTex][(i - me._pXY[iLevelTex].iY) / me._iBlockSize * (me._iBufferWidth / me._iBlockSize) + (j - me._pXY[iLevelTex].iX) / me._iBlockSize] == 0xFFFFFFFF) {
                                continue;
                            }
                            me._pBufferMap[iLevelTex][(i - me._pXY[iLevelTex].iY) / me._iBlockSize * (me._iBufferWidth / me._iBlockSize) + (j - me._pXY[iLevelTex].iX) / me._iBlockSize] = tCurrentTime;
                        }
                        (function /** @no-inline */(iLev, iX, iY) {
                            var sPiecePath = me._sSurfaceTextures;
                            //trace("Путь",sPiecePath);
                            /*a.fopen('filesystem://temporary/'+sPiecePath, 'rb').read(
                            function(pData) {
                            //trace('file exists in local storage:',pData);
                            //console.log(sPiecePath);
                            var pData8=new Uint8Array(pData);
                            me._setDataFromBlock(me._pBuffer[iLevelTex],iX-me._pXY[iLevelTex].iX,iY-me._pXY[iLevelTex].iY,pData8);
                            me._pXY[iLevelTex].isUpdated=true;
                            },
                            function ()
                            {
                            //trace('file not found... Load from server');*/
                            //console.log("=>", me._sSurfaceTextures)
                            me._pRPC.proc('getMegaTexture', me._sSurfaceTextures, me.getWidthOrig(iLev), me.getHeightOrig(iLev), iX, iY, me._iBlockSize, me._iBlockSize, me._eTextureType, function /** @no-inline */(pData) {
                                //console.log("<=")
                                //console.log(pData);
                                var pData8 = new Uint8Array(pData);
                                //console.log(me._pBuffer[iLevelTex].length,iX-me._pXY[iLevelTex].iX,iY-me._pXY[iLevelTex].iY);
                                var iXBuf;
                                var iYBuf;
                                if(iLev == 0) {
                                    //console.log("Подгрузился кусок для текстуры уровня 0. С координатами",iX,iY);
                                    iXBuf = iX - me._pXY[iLev].iX;
                                    iYBuf = iY - me._pXY[iLev].iY;
                                    if(iXBuf < 0 || iXBuf > me._iBufferWidth / 2 - me._iBlockSize || iYBuf < 0 || iYBuf > me._iBufferHeight / 2 - me._iBlockSize) {
                                        return;
                                    }
                                    me._pBufferMap[iLev][iYBuf / me._iBlockSize * (me._iTextureWidth / me._iBlockSize) + iXBuf / me._iBlockSize] = 0xFFFFFFFF;
                                } else {
                                    //console.log("Подгрузился кусок для текстуры уровня",iLevelTex,". С координатами",iX,iY);
                                    iXBuf = iX - me._pXY[iLev].iX;
                                    iYBuf = iY - me._pXY[iLev].iY;
                                    if(iLev == 2 && iY == 0) {
                                        //console.log(iX,iY,iXBuf,iYBuf);
                                                                            }
                                    if(iXBuf < 0 || iXBuf > me._iBufferWidth - me._iBlockSize || iYBuf < 0 || iYBuf > me._iBufferHeight - me._iBlockSize) {
                                        return;
                                    }
                                    me._pBufferMap[iLev][iYBuf / me._iBlockSize * (me._iBufferWidth / me._iBlockSize) + iXBuf / me._iBlockSize] = 0xFFFFFFFF;
                                }
                                me._setDataFromBlock(me._pBuffer[iLev], iXBuf, iYBuf, pData8);
                                me._pXY[iLev].isUpdated = true;
                                //a.fopen('filesystem://temporary/'+sPiecePath, 'wb').write(pData8);
                                                            });
                            //	}
                            //);
                                                    })(iLevelTex, j, i);
                    }
                }
                me._pXY[iLevelTex].isLoaded = isLoaded;
            };
            return MegaTexture;
        })();
        terrain.MegaTexture = MegaTexture;        
    })(akra.terrain || (akra.terrain = {}));
    var terrain = akra.terrain;
})(akra || (akra = {}));
var akra;
(function (akra) {
    ;
    ;
    ;
    ;
    ;
    function /** @no-inline */createSingleStripGrid(pIndexValues, iXVerts, iYVerts, iXStep, iYStep, iSride, iFlags) {
        //TRIANGLESTRIP
        var iTotalStrips = iYVerts - 1;
        var iTotalIndexesPerStrip = iXVerts << 1;
        // the total number of indices is equal
        // to the number of strips times the
        // indices used per strip plus one
        // degenerate triangle between each strip
        //общее количество идексов равно количесву линий умноженному на колчесвто идексов в линии + вырожденный треуголник между полосами
        var iTotalIndexes = (iTotalStrips * iTotalIndexesPerStrip) + (iTotalStrips << 1) - 2;
        if(pIndexValues.length < iTotalIndexes) {
            return 0;
        }
        var iIndex = 0;
        var iStartVert = 0;
        var iLineStep = iYStep * iSride;
        for(var j = 0; j < iTotalStrips; ++j) {
            var k = 0;
            var iVert = iStartVert;
            // create a strip for this row
            for(k = 0; k < iXVerts; ++k) {
                pIndexValues[iIndex++] = iVert;
                pIndexValues[iIndex++] = iVert + iLineStep;
                iVert += iXStep;
            }
            iStartVert += iLineStep;
            if(j + 1 < iTotalStrips) {
                // add a degenerate to attach to
                // the next row
                pIndexValues[iIndex++] = (iVert - iXStep) + iLineStep;
                pIndexValues[iIndex++] = iStartVert;
            }
        }
        // return
        return iTotalIndexes;
    }
    akra.createSingleStripGrid = createSingleStripGrid;
    function /** @no-inline */getCountIndexForStripGrid(iXVerts, iYVerts) {
        //TRIANGLESTRIP
        var iTotalStrips = iYVerts - 1;
        var iTotalIndexesPerStrip = iXVerts << 1;
        var iTotalIndexes = (iTotalStrips * iTotalIndexesPerStrip) + (iTotalStrips << 1) - 2;
        return iTotalIndexes;
    }
    akra.getCountIndexForStripGrid = getCountIndexForStripGrid;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (terrain) {
        var TerrainSection = (function (_super) {
            __extends(TerrainSection, _super);
            function /** @no-inline */TerrainSection(pEngine) {
                        _super.call(this, pEngine.getScene());
                this._pTerrainSystem = null;
                this._pRenderData = null;
                //Ращмеры сетки вершин
                /**@protected*/ this._iXVerts = 0;
                /**@protected*/ this._iYVerts = 0;
                //Положение сетора в мире
                /**@protected*/ this._pWorldRect = new akra.geometry.Rect3d();
                this._pEngine = null;
                this._pRenderableObject = new akra.render.RenderableObject();
                this._pVertexDescription = [
                    akra.VE_FLOAT3(akra.DeclarationUsages.POSITION), 
                    akra.VE_FLOAT2(akra.DeclarationUsages.TEXCOORD)
                ];
                this._pEngine = pEngine;
            }
            Object.defineProperty(TerrainSection.prototype, "sectorX", {
                get: function /** @inline */() {
                    return this._iSectorX;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainSection.prototype, "sectorY", {
                get: function /** @inline */() {
                    return this._iSectorY;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainSection.prototype, "terrainSystem", {
                get: function /** @inline */() {
                    return this._pTerrainSystem;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainSection.prototype, "sectionIndex", {
                get: function /** @inline */() {
                    return (this._iSectorY * this._pTerrainSystem.sectorCountX + this._iSectorX);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainSection.prototype, "heightX", {
                get: function /** @inline */() {
                    return akra.math.abs(this._pWorldRect.x1 - this._pWorldRect.x0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainSection.prototype, "heightY", {
                get: function /** @inline */() {
                    return akra.math.abs(this._pWorldRect.y1 - this._pWorldRect.y0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainSection.prototype, "vertexDescription", {
                get: function /** @inline */() {
                    return this._pVertexDescription;
                },
                enumerable: true,
                configurable: true
            });
            TerrainSection.prototype.create = function /** @no-inline */(pRootNode, pParentSystem, iSectorX, iSectorY, iHeightMapX, iHeightMapY, iXVerts, iYVerts, pWorldRect) {
                if(arguments.length != 9) {
                    akra.logger.setSourceLocation("terrain/TerrainSection.ts", 65);
                    akra.logger.criticalError("Not all arguments where passed");
                    ;
                }
                var bResult = _super.prototype.create.call(this);
                if(bResult) {
                    //
                    // Build a vertex buffer to
                    // hold the height and surface
                    // normal for this area of the terrain
                    //
                    this._pTerrainSystem = pParentSystem;
                    this._iXVerts = iXVerts;
                    this._iYVerts = iYVerts;
                    this._iSectorX = iSectorX;
                    this._iSectorY = iSectorY;
                    this._pWorldRect.x0 = pWorldRect.x0;
                    this._pWorldRect.x1 = pWorldRect.x1;
                    this._pWorldRect.y0 = pWorldRect.y0;
                    //??
                    this._pWorldRect.y1 = pWorldRect.y1;
                    this._iHeightMapX = iHeightMapX;
                    this._iHeightMapY = iHeightMapY;
                    bResult = this._createRenderDataForVertexAndIndex();
                    bResult = bResult && this._buildVertexBuffer();
                    bResult = bResult && this._buildIndexBuffer();
                    // set the scene object bounds data
                    this.accessLocalBounds().set(this._pWorldRect.x0, this._pWorldRect.x1, this._pWorldRect.y0, this._pWorldRect.y1, this._pWorldRect.z0, this._pWorldRect.z1);
                    if(bResult) {
                        this.attachToParent(pRootNode);
                    }
                }
                return bResult;
            };
            TerrainSection.prototype.setRenderData = function /** @no-inline */(pData) {
                this._pRenderData = pData;
            };
            TerrainSection.prototype._createRenderDataForVertexAndIndex = /**@protected*/ function /** @no-inline */() {
                akra.logger.setSourceLocation("terrain/TerrainSection.ts", 113);
                akra.logger.assert(this._pRenderData == null, "У терраин сектиона уже созданы данные");
                ;
                this._pRenderData = this.terrainSystem.dataFactory.getEmptyRenderData(5 /* TRIANGLESTRIP */ , 0);
                if(!this._pRenderData) {
                    return false;
                }
                return true;
            };
            TerrainSection.prototype._buildVertexBuffer = /**@protected*/ function /** @no-inline */() {
                this._pWorldRect.z0 = akra.MAX_FLOAT64;
                this._pWorldRect.z1 = akra.MIN_FLOAT64;
                /*кординаты вершин*/
                /*координаты нормалей*/
                /*текстурные координаты*/
                var pVerts = new Array(this._iXVerts * this._iYVerts * (3 + 3 + 2));
                var v3fNormal = new akra.Vec3();
                //размер ячейки сектора
                var v2fCellSize = new akra.Vec2();
                v2fCellSize.set(this.heightX / (this._iXVerts - 1), //размер сектора/количество ячеек в секторе
                this.heightY / (this._iYVerts - 1));
                //Координаты вершина в секторе
                var v2fVert = new akra.Vec2();
                v2fVert.set(0.0, 0.0);
                //console.log("-->",this._iSectorX,this._iSectorY,"--",this._pWorldRect.fX0,this._pWorldRect.fY0,"--",this._iXVerts,this._iYVerts)
                //console.log("--",v2fCellSize.X,v2fCellSize.Y,this.getHeightX(),this.getHeightY() )
                for(var y = 0; y < this._iYVerts; ++y) {
                    v2fVert.set(this._pWorldRect.x0, y * v2fCellSize.y + this._pWorldRect.y0);
                    for(var x = 0; x < this._iXVerts; ++x) {
                        var fHeight = this.terrainSystem.readWorldHeight(this._iHeightMapX + x, this._iHeightMapY + y);
                        pVerts[((y * this._iXVerts) + x) * 5 + 0] = v2fVert.x;
                        pVerts[((y * this._iXVerts) + x) * 5 + 1] = v2fVert.y;
                        pVerts[((y * this._iXVerts) + x) * 5 + 2] = fHeight;
                        //console.log(y*this._iXVerts + x,x,y,v2fVert.X,v2fVert.Y,fHeight);
                        //	pVerts[((y * this._iXVerts) + x) * 10 + 2],pVerts[((y * this._iXVerts) + x) * 10 + 1]);
                        pVerts[((y * this._iXVerts) + x) * 5 + 3] = (this._iSectorX + x / (this._iXVerts - 1)) / this.terrainSystem.sectorCountX;
                        pVerts[((y * this._iXVerts) + x) * 5 + 4] = (this._iSectorY + y / (this._iYVerts - 1)) / this.terrainSystem.sectorCountY;
                        //console.log(this._iSectorX,this.terrainSystem.getSectorCountX(), x,this._iXVerts);
                        //console.log(this._iSectorX/this.terrainSystem.getSectorCountX() + x / (this._iXVerts - 1));
                        this._pWorldRect.z0 = akra.math.min(this._pWorldRect.z0, fHeight);
                        this._pWorldRect.z1 = akra.math.max(this._pWorldRect.z1, fHeight);
                        v2fVert.x += v2fCellSize.x;
                    }
                }
                this._iVertexID = this._pRenderData.allocateData(this.vertexDescription, new Float32Array(pVerts));
                return true;
            };
            TerrainSection.prototype._buildIndexBuffer = /**@protected*/ function /** @no-inline */() {
                var pIndexList = new Float32Array(akra.getCountIndexForStripGrid(this._iXVerts, this._iYVerts));
                akra.createSingleStripGrid(pIndexList, /*width of grid*/
                this._iXVerts, /*height of grid*/
                this._iYVerts, /*horz vertex count per cell*/
                1, /*vert vertex count per cell*/
                1, /*horz vertex count in vbuffer*/
                this._iYVerts, 0);
                //
                this._pRenderData.allocateIndex(([
                    akra.VE_FLOAT(akra.DeclarationUsages.INDEX0)
                ]), pIndexList);
                this._pRenderData.index(this._iVertexID, akra.DeclarationUsages.INDEX0);
                return true;
            };
            TerrainSection.prototype.render = function /** @no-inline */() {
                akra.logger.setSourceLocation("terrain/TerrainSection.ts", 195);
                akra.logger.criticalError("Ваня, WTF?");
                ;
                return false;
                /*//	this.terrainSystem.applyForRender();
                var pRenderer = this._pEngine.shaderManager();
                var pLightManager = this._pEngine.lightManager();
                var pTerrain: ITerrainSystem = this.terrainSystem;
                var pSnapshot;
                
                pRenderer.activateSceneObject(this);
                pRenderer.setViewport(0, 0, this._pEngine.pCanvas.width, this._pEngine.pCanvas.height);
                
                this.switchRenderMethod(".default-render");
                this.startRender();
                
                pSnapshot = this._pActiveSnapshot;
                //    console.log(this, pSnapshot);
                
                for (var i: uint = 0; i < this.totalPasses(); i++) {
                this.activatePass(i);
                
                pRenderer.activateFrameBuffer(pLightManager.deferredFrameBuffers[i]);
                
                pTerrain.applyForRender(pSnapshot);
                
                this.applyRenderData(this._pRenderData);
                var pEntry = this.renderPass();
                //        console.log(pEntry.pTextures, pEntry.pUniforms, pEntry.pProgram);
                this.deactivatePass();
                pRenderer.activateFrameBuffer(null);
                }
                this.finishRender();
                pRenderer.deactivateSceneObject();
                return true;*/
                            };
            TerrainSection.prototype.prepareForRender = function /** @no-inline */() {
                return;
            };
            return TerrainSection;
        })(akra.scene.SceneObject);
        terrain.TerrainSection = TerrainSection;        
    })(akra.terrain || (akra.terrain = {}));
    var terrain = akra.terrain;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (terrain) {
        var Terrain = (function () {
            function /** @no-inline */Terrain(pEngine) {
                /**@protected*/ this._pEngine = null;
                // private _pDevice = null;
                //указатель на корень графа сцены
                /**@protected*/ this._pRootNode = null;
                /**@protected*/ this._pWorldExtents = new akra.geometry.Rect3d();
                this._v3fWorldSize = new akra.Vec3();
                this._v3fMapScale = new akra.Vec3();
                //массив подчиненный секций
                /**@protected*/ this._pSectorArray = null;
                /**@protected*/ this._pDataFactory = null;
                /**@protected*/ this._v2fSectorSize = new akra.Vec2();
                //Таблица(карта высот)
                this._pHeightTable = null;
                this._pNormalMap = null;
                this._pTempNormalColor = new akra.Color();
                //отоброжаемые куски текстуры
                this._pMegaTexures = null;
                /**@protected*/ this._fScale = 0.0;
                /**@protected*/ this._fLimit = 0.0;
                /**@protected*/ this._pDefaultRenderMethod = null;
                this._pEngine = pEngine;
                // this._pDevice = pEngine.pDevice;
                this._pDataFactory = new akra.render.RenderDataCollection(this._pEngine, akra.ERenderDataBufferOptions.VB_READABLE);
                // this._pDataFactory.dataType = a.RenderData;
                // this._pDataFactory.setup();
                this._initSystemData();
            }
            Object.defineProperty(Terrain.prototype, "dataFactory", {
                get: function /** @inline */() {
                    return this._pDataFactory;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "scale", {
                get: function /** @inline */() {
                    return this._fScale;
                },
                set: function /** @inline */(fScale) {
                    this._fScale = fScale;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "limit", {
                get: function /** @inline */() {
                    return this._fLimit;
                },
                set: function /** @inline */(fLimit) {
                    this._fLimit = fLimit;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "worldExtents", {
                get: function /** @inline */() {
                    return this._pWorldExtents;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "worldSize", {
                get: function /** @inline */() {
                    return this._v3fWorldSize;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "mapScale", {
                get: function /** @inline */() {
                    return this._v3fMapScale;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "sectorCountX", {
                get: function /** @inline */() {
                    return this._iSectorCountX;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "sectorCountY", {
                get: function /** @inline */() {
                    return this._iSectorCountY;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "sectorSize", {
                get: function /** @inline */() {
                    return this._v2fSectorSize;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "tableWidth", {
                get: function /** @inline */() {
                    return this._iTableWidth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "tableHeight", {
                get: function /** @inline */() {
                    return this._iTableHeight;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Terrain.prototype, "sectorShift", {
                get: function /** @inline */() {
                    return this._iSectorShift;
                },
                enumerable: true,
                configurable: true
            });
            Terrain.prototype._initSystemData = /**@protected*/ function /** @no-inline */() {
                akra.logger.setSourceLocation("terrain/Terrain.ts", 125);
                akra.logger.criticalError("ХЗ как это должно работать");
                ;
                return false;
            };
            Terrain.prototype.create = function /** @no-inline */(pRootNode, pMap, worldExtents, iShift, iShiftX, iShiftY, sSurfaceTextures) {
                //Основные параметры
                this._iSectorShift = iShift;
                this._iSectorUnits = 1 << iShift;
                this._iSectorVerts = this._iSectorUnits + 1;
                this._pRootNode = pRootNode;
                this._pWorldExtents = new akra.geometry.Rect3d(worldExtents.x0, worldExtents.x1, worldExtents.y0, worldExtents.y1, worldExtents.z0, worldExtents.z1);
                this._pWorldExtents.normalize();
                this._v3fWorldSize = this._pWorldExtents.size(this._v3fWorldSize);
                //this._iTableWidth >> this._iSectorShift;
                this._iSectorCountX = 1 << iShiftX;
                //this._iTableHeight >> this._iSectorShift;
                this._iSectorCountY = 1 << iShiftY;
                this._iTableWidth = this._iSectorCountX * this._iSectorUnits;
                this._iTableHeight = this._iSectorCountY * this._iSectorUnits;
                this._v2fSectorSize.set(this._v3fWorldSize.x / this._iSectorCountX, this._v3fWorldSize.y / this._iSectorCountY);
                this._v3fMapScale.x = this._v3fWorldSize.x / this._iTableWidth;
                this._v3fMapScale.y = this._v3fWorldSize.y / this._iTableHeight;
                this._v3fMapScale.z = this._v3fWorldSize.z / 255.0;
                //Мегатекстурные параметры
                this._pMegaTexures = new terrain.MegaTexture(this._pEngine, this, sSurfaceTextures);
                // convert the height map to
                // data stored in local tables
                this._buildHeightAndNormalTables(pMap["height"], pMap["normal"]);
                for(var sImgMap in pMap) {
                    if(pMap[sImgMap].destroyResource) {
                        pMap[sImgMap].destroyResource();
                    }
                }
                return this._allocateSectors();
            };
            Terrain.prototype.findSection = function /** @no-inline */(iX, iY) {
                var pSection = null;
                if(iX >= 0 && iX < this._iSectorCountX && iY >= 0 && iY < this._iSectorCountY) {
                    pSection = this._pSectorArray[(iY * this._iSectorCountX) + iX];
                } else {
                    // if we had additional cRoamTerrain objects,
                    // we could reach out here to link with neighbors
                                    }
                return pSection;
            };
            Terrain.prototype._allocateSectors = /**@protected*/ function /** @no-inline */() {
                var v2fSectorPos = new akra.Vec2();
                var r2fSectorRect = new akra.geometry.Rect2d();
                this._pSectorArray = new Array(this._iSectorCountX * this._iSectorCountY);
                // create the sector objects themselves
                for(var y = 0; y < this._iSectorCountY; ++y) {
                    for(var x = 0; x < this._iSectorCountX; ++x) {
                        v2fSectorPos.set(this._pWorldExtents.x0 + (x * this._v2fSectorSize.x), this._pWorldExtents.y0 + (y * this._v2fSectorSize.y));
                        r2fSectorRect.set(v2fSectorPos.x, v2fSectorPos.x + this._v2fSectorSize.x, v2fSectorPos.y, v2fSectorPos.y + this._v2fSectorSize.y);
                        var iXPixel = x << this._iSectorShift;
                        var iYPixel = y << this._iSectorShift;
                        var iIndex = (y * this._iSectorCountX) + x;
                        this._pSectorArray[iIndex] = new terrain.TerrainSection(this._pEngine);
                        if(!this._pSectorArray[iIndex].create(this._pRootNode, this, x, y, iXPixel, iYPixel, this._iSectorVerts, this._iSectorVerts, r2fSectorRect)) {
                            return false;
                        }
                    }
                }
                this._setRenderMethod(this._pDefaultRenderMethod, "ss");
            };
            Terrain.prototype._setRenderMethod = /**@protected*/ function /** @no-inline */(pRenderMethod, sName) {
                akra.logger.setSourceLocation("terrain/Terrain.ts", 228);
                akra.logger.criticalError("ХЗ как это должно работать");
                ;
            };
            Terrain.prototype._buildHeightAndNormalTables = /**@protected*/ function /** @no-inline */(pImageHightMap, pImageNormalMap) {
                var fHeight = 0;
                var iComponents = 4;
                this._pHeightTable = null;
                var iMaxY = this._iTableHeight;
                var iMaxX = this._iTableWidth;
                //trace("Terraim Map Size ", iMaxX, iMaxY);
                var pColorData = new Uint8Array(4 * iMaxY * iMaxX);
                //float			    this._pHeightTable = new Array(iMaxX * iMaxY);
                /*this._pEngine*/
                var temp = new akra.core.pool.resources.Texture();
                // first, build a table of heights
                if(pImageHightMap.isResourceLoaded()) {
                    temp.uploadImage(pImageHightMap);
                    temp.resize(iMaxX, iMaxY);
                    temp.getPixelRGBA(0, 0, iMaxX, iMaxY, pColorData);
                    iComponents = temp.numElementsPerPixel;
                    for(var i = 0; i < iMaxY * iMaxX; i++) {
                        fHeight = pColorData[i * iComponents + 0];
                        fHeight = (fHeight * this._v3fMapScale.z) + this._pWorldExtents.z0;
                        this._pHeightTable[i] = fHeight;
                    }
                } else {
                    akra.logger.setSourceLocation("terrain/Terrain.ts", 262);
                    akra.logger.warning("Карта высот не загружена");
                }
                if(pImageNormalMap.isResourceLoaded()) {
                    temp.uploadImage(pImageNormalMap);
                } else {
                    akra.logger.setSourceLocation("terrain/Terrain.ts", 269);
                    akra.logger.warning("Карта высот не загружена");
                }
                this._pNormalMap = temp;
            };
            Terrain.prototype.readWorldHeight = function /** @no-inline */(iMapX, iMapY) {
                if(arguments.length == 2) {
                    if(iMapX >= this._iTableWidth) {
                        iMapX = this._iTableWidth - 1;
                    }
                    if(iMapY >= this._iTableHeight) {
                        iMapY = this._iTableHeight - 1;
                    }
                    return this._pHeightTable[(iMapY * this._iTableWidth) + iMapX];
                } else {
                    var iMapIndex = iMapX;
                    akra.logger.setSourceLocation("terrain/Terrain.ts", 290);
                    akra.logger.assert(iMapIndex < this._iTableWidth * this._iTableHeight, "invalid index");
                    ;
                    return this._pHeightTable[iMapIndex];
                }
            };
            Terrain.prototype._tableIndex = /**@protected*/ function /** @no-inline */(iMapX, iMapY) {
                // clamp to the table dimensions
                if(iMapX >= this._iTableWidth) {
                    iMapX = this._iTableWidth - 1;
                }
                if(iMapY >= this._iTableHeight) {
                    iMapY = this._iTableHeight - 1;
                }
                return (iMapY * this._iTableWidth) + iMapX;
            };
            Terrain.prototype.readWorldNormal = function /** @no-inline */(v3fNormal, iMapX, iMapY) {
                if(iMapX >= this._pNormalMap.width) {
                    iMapX = this._pNormalMap.width - 1;
                }
                if(iMapY >= this._pNormalMap.height) {
                    iMapY = this._pNormalMap.height - 1;
                }
                // var iOffset: uint = this._pNormalMap.getPixelRGBA(iMapX, iMapY, 1, 1, this._pTempNormalColor)
                this._pNormalMap.getColorAt(this._pTempNormalColor, iMapX, iMapY);
                v3fNormal.set(this._pTempNormalColor.r, this._pTempNormalColor.g, this._pTempNormalColor.b);
                return v3fNormal;
            };
            Terrain.prototype.calcWorldHeight = function /** @no-inline */(fWorldX, fWorldY) {
                var fMapX = (fWorldX - this._pWorldExtents.x0) / this._pWorldExtents.sizeX();
                var fMapY = (fWorldY - this._pWorldExtents.y0) / this._pWorldExtents.sizeY();
                return this._calcMapHeight(fMapX, fMapY);
            };
            Terrain.prototype.calcWorldNormal = function /** @no-inline */(v3fNormal, fWorldX, fWorldY) {
                var fMapX = (fWorldX - this._pWorldExtents.x0) / this._pWorldExtents.sizeX();
                var fMapY = (fWorldY - this._pWorldExtents.y0) / this._pWorldExtents.sizeY();
                return this._calcMapNormal(v3fNormal, fMapX, fMapY);
            };
            Terrain.prototype._calcMapHeight = /**
            * Вычисляет высоту в координатах от 0 до 1
            */
            /**@protected*/ function /** @no-inline */(fMapX, fMapY) {
                var fTempMapX = fMapX * (this._iTableWidth - 1);
                var fTempMapY = fMapY * (this._iTableHeight - 1);
                var iMapX0 = akra.math.floor(fTempMapX);
                var iMapY0 = akra.math.floor(fTempMapY);
                fTempMapX -= iMapX0;
                fTempMapY -= iMapY0;
                iMapX0 = akra.math.clamp(iMapX0, 0, this._iTableWidth - 1);
                iMapY0 = akra.math.clamp(iMapY0, 0, this._iTableHeight - 1);
                var iMapX1 = akra.math.clamp(iMapX0 + 1, 0, this._iTableWidth - 1);
                var iMapY1 = akra.math.clamp(iMapY0 + 1, 0, this._iTableHeight - 1);
                // read 4 map values
                var fH0 = this.readWorldHeight(iMapX0, iMapY0);
                var fH1 = this.readWorldHeight(iMapX1, iMapY0);
                var fH2 = this.readWorldHeight(iMapX0, iMapY1);
                var fH3 = this.readWorldHeight(iMapX1, iMapY1);
                var fAvgLo = (fH1 * fTempMapX) + (fH0 * (1.0 - fTempMapX));
                var fAvgHi = (fH3 * fTempMapX) + (fH2 * (1.0 - fTempMapX));
                return (fAvgHi * fTempMapY) + (fAvgLo * (1.0 - fTempMapY));
            };
            Terrain.prototype._calcMapNormal = /**
            * Вычисляет нормаль в координатах от 0 до 1
            */
            /**@protected*/ function /** @no-inline */(v3fNormal, fMapX, fMapY) {
                var fTempMapX = fMapX * (this._pNormalMap.width - 1);
                var fTempMapY = fMapY * (this._pNormalMap.height - 1);
                //console.log(fTempMapX,fTempMapY)
                var iMapX0 = akra.math.floor(fTempMapX);
                var iMapY0 = akra.math.floor(fTempMapY);
                fTempMapX -= iMapX0;
                fTempMapY -= iMapY0;
                iMapX0 = akra.math.clamp(iMapX0, 0, this._pNormalMap.width - 1);
                iMapY0 = akra.math.clamp(iMapY0, 0, this._pNormalMap.height - 1);
                var iMapX1 = akra.math.clamp(iMapX0 + 1, 0, this._pNormalMap.width - 1);
                var iMapY1 = akra.math.clamp(iMapY0 + 1, 0, this._pNormalMap.height - 1);
                // read 4 map values
                var v3fH0 = akra.math.vec3();
                this.readWorldNormal(v3fH0, iMapX0, iMapY0);
                var v3fH1 = akra.math.vec3();
                this.readWorldNormal(v3fH1, iMapX1, iMapY0);
                var v3fH2 = akra.math.vec3();
                this.readWorldNormal(v3fH2, iMapX0, iMapY1);
                var v3fH3 = akra.math.vec3();
                this.readWorldNormal(v3fH3, iMapX1, iMapY1);
                var v3fAvgLo = akra.math.vec3();
                v3fAvgLo.set(v3fH1.scale(fTempMapX));
                v3fAvgLo.add(v3fH0.scale(1.0 - fTempMapX));
                var v3fAvgHi = akra.math.vec3();
                v3fAvgHi.set(v3fH3.scale(fTempMapX));
                v3fAvgHi.add(v3fH2.scale(1.0 - fTempMapX));
                v3fNormal.set(v3fAvgHi.scale(fTempMapY));
                v3fNormal.add(v3fAvgLo.scale(1.0 - fTempMapY));
                v3fNormal.normalize();
                return v3fNormal;
            };
            Terrain.prototype._generateTerrainImage = /**@protected*/ function /** @no-inline */(pTerrainImage, pTextureList, iTextureCount) {
                akra.logger.setSourceLocation("terrain/Terrain.ts", 419);
                akra.logger.criticalError("нехуй");
                ;
                var bSuccess = false;
                var x, y, i;
                var iImage_width = pTerrainImage.getWidth();
                var iImage_height = pTerrainImage.getHeight();
                var fUStep = 1.0 / (iImage_width - 1);
                var fVStep = 1.0 / (iImage_height - 1);
                //sample_data* pSamples = new sample_data[iTextureCount];
                var pSamples = new Array(iTextureCount);
                // lock all the textures we need
                pTerrainImage.lock();
                for(i = 0; i < iTextureCount; ++i) {
                    pTextureList[i].pImage.lock();
                }
                // step through and generate each pixel
                for(y = 0; y < iImage_height; ++y) {
                    for(x = 0; x < iImage_width; ++x) {
                        var fU = x * fUStep;
                        var fV = y * fVStep;
                        var fTotalBlend = 0.0;
                        var fMap_height = this._calcMapHeight(fU, fV);
                        var v3fNormal = new akra.Vec3();
                        this._calcMapNormal(v3fNormal, fU, fV);
                        // examine each elevation set
                        for(i = 0; i < iTextureCount; ++i) {
                            // how much of this texture do we want?
                            var fElevationScale = 0.0;
                            var fSlopeScale = 0.0;
                            if(fMap_height >= pTextureList[i].elevation.minElevation && fMap_height <= pTextureList[i].elevation.maxElevation) {
                                var fSpan = pTextureList[i].elevation.maxElevation - pTextureList[i].elevation.minElevation;
                                fElevationScale = fMap_height - pTextureList[i].elevation.minElevation;
                                fElevationScale *= 1.0 / fSpan;
                                fElevationScale -= 0.5;
                                fElevationScale *= 2.0;
                                fElevationScale *= fElevationScale;
                                fElevationScale = 1.0 - fElevationScale;
                            }
                            if(v3fNormal.z >= pTextureList[i].elevation.minNormalZ && v3fNormal.z <= pTextureList[i].elevation.maxNormalZ) {
                                var fSpan = pTextureList[i].elevation.maxNormalZ - pTextureList[i].elevation.minNormalZ;
                                fSlopeScale = v3fNormal.z - pTextureList[i].elevation.minNormalZ;
                                fSlopeScale *= 1.0 / fSpan;
                                fSlopeScale -= 0.5;
                                fSlopeScale *= 2.0;
                                fSlopeScale *= fSlopeScale;
                                fSlopeScale = 1.0 - fSlopeScale;
                            }
                            pSamples[i] = {
                                fScale: 0,
                                iColor: 0
                            };
                            pSamples[i].fScale = pTextureList[i].elevation.strength * fElevationScale * fSlopeScale;
                            fTotalBlend += pSamples[i].fScale;
                            //pTextureList[i] = new cTerrain.terrainTextureData()
                            pTextureList[i].pImage.sampleColor(fU * pTextureList[i].fUvScale, fV * pTextureList[i].fUvScale, pSamples[i].iColor);
                        }
                        // balance the data (so they add up to 1.0f)
                        var fBlendScale = 1.0 / fTotalBlend;
                        // now compute the actual color
                        var fRed = 0.0;
                        var fGreen = 0.0;
                        var fBlue = 0.0;
                        var fAlpha = 0.0;
                        for(i = 0; i < iTextureCount; ++i) {
                            var fScale = pSamples[i].fScale * fBlendScale;
                            fBlue += (pSamples[i].iColor & 0xff) * fScale;
                            fGreen += ((pSamples[i].iColor >> 8) & 0xff) * fScale;
                            fRed += ((pSamples[i].iColor >> 16) & 0xff) * fScale;
                            fAlpha += ((pSamples[i].iColor >> 24) & 0xff) * fScale;
                        }
                        var iR = akra.math.clamp(fRed, 0.0, 255.0);
                        var iG = akra.math.clamp(fGreen, 0.0, 255.0);
                        var iB = akra.math.clamp(fBlue, 0.0, 255.0);
                        var iA = akra.math.clamp(fAlpha, 0.0, 255.0);
                        var iColor = (iA << 24) + (iR << 16) + (iG << 8) + iB;
                        pTerrainImage.setColor(x, y, iColor);
                    }
                }
                // unlock all the images
                pTerrainImage.unlock();
                for(i = 0; i < iTextureCount; ++i) {
                    pTextureList[i].pImage.unlock();
                }
            };
            Terrain.prototype._computeWeight = /**@protected*/ function /** @no-inline */(fValue, fMinExtent, fMaxExtent) {
                akra.logger.setSourceLocation("terrain/Terrain.ts", 528);
                akra.logger.criticalError("нехуй");
                ;
                var fWeight = 0.0;
                if(fValue >= fMinExtent && fValue <= fMaxExtent) {
                    var fSpan = fMaxExtent - fMinExtent;
                    fWeight = fValue - fMinExtent;
                    // convert to a 0-1 range value
                    // based on its distance to the midpoint
                    // of the range extents
                    fWeight *= 1.0 / fSpan;
                    fWeight -= 0.5;
                    fWeight *= 2.0;
                    // square the result for non-linear falloff
                    fWeight *= fWeight;
                    // invert and bound-check the result
                    fWeight = 1.0 - akra.math.absoluteValue(fWeight);
                    fWeight = akra.math.clamp(fWeight, 0.001, 1.0);
                }
                return fWeight;
            };
            Terrain.prototype._generateBlendImage = //Как сварить борщ
            /**@protected*/ function /** @no-inline */(pBlendImage, pElevationData, iElevationDataCount, fnCallback) {
                //Ингредиенты
                //1 кг говядины (мякоть или на косточке)
                //500 г картофеля
                //300 г свежей капусты
                //400 г свеклы
                //200 г моркови
                //200 г лука
                //3 ст.л. томатной пасты
                //1 ч.л. уксуса 6%
                //2-3 зубчика чеснока
                //2-3 лавровых листа
                //соль
                //перец
                //растительное масло
                //зелень по вкусу
                akra.logger.setSourceLocation("terrain/Terrain.ts", 573);
                akra.logger.criticalError("нехуй");
                ;
                var bSuccess = false;
                var x, y, i;
                var pColor = new Uint8Array(4);
                akra.logger.setSourceLocation("terrain/Terrain.ts", 579);
                akra.logger.assert(pBlendImage != null, "pBlendImage is not valid");
                ;
                //Мясо залить водой, варить 1.5 часа.
                iElevationDataCount = akra.math.min(iElevationDataCount, 4);
                // Затем мясо нарезать небольшими кусочками.
                var iImg_width = pBlendImage.getWidth();
                var iImg_height = pBlendImage.getHeight();
                // Добавить в бульон.
                // Лук мелко покрошить.
                var fUStep = 1.0 / (iImg_width - 1);
                var fVStep = 1.0 / (iImg_height - 1);
                // Морковь натереть на средней терке.
                // Капусту нашинковать тонкой соломкой.
                // Свеклу нарезать тонкой соломкой.
                var v4fMask = new Array(4);
                v4fMask[0] = new akra.Vec4();
                v4fMask[0].set(1.0, 0.0, 0.0, 0.0);
                v4fMask[1] = new akra.Vec4();
                v4fMask[1].set(0.0, 1.0, 0.0, 0.0);
                v4fMask[2] = new akra.Vec4();
                v4fMask[2].set(0.0, 0.0, 1.0, 0.0);
                v4fMask[3] = new akra.Vec4();
                v4fMask[3].set(0.0, 0.0, 0.0, 1.0);
                for(y = 0; y < iImg_height; y++) {
                    for(x = 0; x < iImg_width; x++) {
                        var fTotalBlend = 0.0;
                        var v4fBlendFactors = new akra.Vec4();
                        v4fBlendFactors.set(0.0, 0.0, 0.0, 0.0);
                        if(iElevationDataCount == 3) {
                            v4fBlendFactors.w = 255;
                        }
                        // Свеклу обжарить на растительном масле.
                        var fU = x * fUStep;
                        var fV = y * fVStep;
                        var fMap_height = this._calcMapHeight(fU, fV);
                        var v3fNormal = new akra.Vec3();
                        var v4fTemp = new akra.Vec4();
                        this._calcMapNormal(v3fNormal, fU, fV);
                        // Добавить уксус и томатную пасту (если паста густая,
                        //	добавить немного воды), тушить 5-7 минут.
                        //
                        for(i = 0; i < iElevationDataCount; ++i) {
                            // На растительном масле обжарить лук.
                            var fElevationScale = this._computeWeight(fMap_height, pElevationData[i].fMinElevation, pElevationData[i].fMaxElevation);
                            // Добавить морковь, обжарить.
                            var fSlopeScale = this._computeWeight(v3fNormal.z, pElevationData[i].fMinNormalZ, pElevationData[i].fMaxNormalZ);
                            // Картофель нарезать кубиками или брусочками.
                            // В кипящий бульон добавить картофель, посолить.
                            var fScale = pElevationData[i].fStrength * fElevationScale * fSlopeScale;
                            // Когда бульон закипит, добавить капусту. Варить на небольшом огне 5 минут.
                            // Добавить свеклу, варить еще около 10 минут.
                            v4fTemp.set(v4fMask[i]);
                            v4fTemp.scale(fScale);
                            v4fBlendFactors.add(v4fTemp);
                            //v4fBlendFactors += v4fMask[i] * fScale;
                            // Добавить лук и морковь.
                            fTotalBlend += fScale;
                        }
                        // Следом добавить лавровый лист. Если необходимо, посолить, поперчить.
                        var fBlendScale = 255.0 / fTotalBlend;
                        // Добавить чеснок, выдавленный через чеснокодавку.
                        // Убрать с огня, дать настояться 15-20 минут.
                        // by the blend fScale
                        v4fBlendFactors.scale(fBlendScale);
                        // Готовый борщ разлить по тарелкам, добавить сметану и посыпать зеленью.
                        pColor[0] = akra.math.clamp(v4fBlendFactors.x, 0.0, 255.0);
                        pColor[1] = akra.math.clamp(v4fBlendFactors.y, 0.0, 255.0);
                        pColor[2] = akra.math.clamp(v4fBlendFactors.z, 0.0, 255.0);
                        pColor[3] = akra.math.clamp(v4fBlendFactors.w, 0.0, 255.0);
                        //так как текстура перевернута
                        pBlendImage.setPixelRGBA(x, iImg_height - y - 1, pColor);
                    }
                }
                // Приятного аппетита!
                            };
            Terrain.prototype._setTessellationParameters = //Спасибо большое за рецепт. Все изложено по порядку, думаю очень вкусно получится. Завтра приготовлю мужу на обед.
            //спасибо, очень вкусно получилось, хотя борщ варила первый раз.
            /**@protected*/ function /** @no-inline */(fScale, fLimit) {
                this._fScale = fScale;
                this._fLimit = fLimit;
            };
            Terrain.prototype.prepareForRender = /**
            * Подготовка терраина к рендерингу.
            */
            function /** @no-inline */() {
                akra.logger.setSourceLocation("terrain/Terrain.ts", 690);
                akra.logger.criticalError("нехуй");
                ;
                this._pMegaTexures.prepareForRender();
            };
            Terrain.prototype.applyForRender = /**
            * Применение параметров рендеринга для рендеринга текстуры.
            */
            function /** @no-inline */() {
                akra.logger.setSourceLocation("terrain/Terrain.ts", 697);
                akra.logger.criticalError("нехуй");
                ;
                /*var pMegaTexture = this._pMegaTexures;
                pMegaTexture.applyForRender(pSnapshot);
                pSnapshot.applyTextureBySemantic("TEXTURE6", this._pNormalMap);*/
                            };
            Terrain.prototype.reset = /**
            * Сброс параметров.
            */
            function /** @no-inline */() {
            };
            Terrain.prototype.readUserInput = /**
            * Обработка пользовательского ввода.
            */
            function /** @no-inline */() {
                /*//+
                if (this._pEngine.pKeymap.isKeyPress(a.KEY.ADD))
                {
                this._fLimit += 0.0001;
                }
                //-
                else if (this._pEngine.pKeymap.isKeyPress(a.KEY.SUBTRACT))
                {
                this._fLimit -= 0.0001;
                }
                
                //*
                if (this._pEngine.pKeymap.isKeyPress(a.KEY.MULTIPLY))
                {
                this._fScale += 0.0001;
                }
                // /
                else if (this._pEngine.pKeymap.isKeyPress(a.KEY.DIVIDE))
                {
                this._fScale -= 0.0001;
                }*/
                if(this._fLimit < 0.001) {
                    this._fLimit = 0.001;
                }
                if(this._fScale < 0.001) {
                    this._fScale = 0.001;
                }
                document.getElementById('setinfo4').innerHTML = "fScale1 " + this._fScale;
                document.getElementById('setinfo5').innerHTML = "fLimit1 " + this._fLimit;
            };
            return Terrain;
        })();
        terrain.Terrain = Terrain;        
    })(akra.terrain || (akra.terrain = {}));
    var terrain = akra.terrain;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (terrain) {
        var TerrainSectionROAM = (function (_super) {
            __extends(TerrainSectionROAM, _super);
            function /** @no-inline */TerrainSectionROAM(pEngine) {
                        _super.call(this, pEngine);
                //два дерева треугольников
                this._pRootTriangleA = new terrain.TriTreeNode();
                this._pRootTriangleB = new terrain.TriTreeNode();
                //Урове5нь погрещности для двух деревьев
                this._pVarianceTreeA = null;
                this._pVarianceTreeB = null;
                //расстояние от камеры до углов секции
                this._v3fDistance0 = new akra.Vec3();
                this._v3fDistance1 = new akra.Vec3();
                this._v3fDistance2 = new akra.Vec3();
                this._v3fDistance3 = new akra.Vec3();
                this._leftNeighborOfA = null;
                this._rightNeighborOfA = null;
                this._leftNeighborOfB = null;
                this._rightNeighborOfB = null;
                this._pEngine = pEngine;
                this._iStartIndex = undefined;
                this._pTerrainSystem = null;
                this._iTempTotalIndices = undefined;
                this._pTempIndexList = undefined;
                this._iMaxIndices = undefined;
                this._pEngine = pEngine;
            }
            Object.defineProperty(TerrainSectionROAM.prototype, "terrainSystem", {
                get: function /** @inline */() {
                    return this._pTerrainSystem;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainSectionROAM.prototype, "triangleA", {
                get: function /** @inline */() {
                    return this._pRootTriangleA;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainSectionROAM.prototype, "triangleB", {
                get: function /** @inline */() {
                    return this._pRootTriangleA;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainSectionROAM.prototype, "queueSortValue", {
                get: function /** @inline */() {
                    return this._fQueueSortValue;
                },
                enumerable: true,
                configurable: true
            });
            TerrainSectionROAM.prototype.create = function /** @no-inline */(pRootNode, pParentSystem, iSectorX, iSectorY, iHeightMapX, iHeightMapY, iXVerts, iYVerts, pWorldRect, iStartIndex) {
                if(arguments.length != 10) {
                    akra.logger.setSourceLocation("terrain/TerrainSectionROAM.ts", 73);
                    akra.logger.criticalError("Not all arguments where passed");
                    ;
                }
                var iVerts = akra.math.max(iXVerts, iYVerts);
                this._iStartIndex = iStartIndex;
                var bResult = _super.prototype.create.call(this, pRootNode, pParentSystem, iSectorX, iSectorY, iHeightMapX, iHeightMapY, iVerts, iVerts, pWorldRect);
                this._iTotalDetailLevels = akra.math.ceil(akra.math.log(iVerts) / akra.math.LN2) * 2 - 1;
                this._iTotalVariances = 1 << this._iTotalDetailLevels;
                this._pVarianceTreeA = new Array(this._iTotalVariances);
                // this._pVarianceTreeA.set(0);
                this._pVarianceTreeB = new Array(this._iTotalVariances);
                // this._pVarianceTreeB.set(0);
                for(var i = 0; i < this._iTotalVariances; i++) {
                    this._pVarianceTreeA[i] = 0;
                    this._pVarianceTreeB[i] = 0;
                }
                var pRoamTerrain = this.terrainSystem;
                var pNorthSection = pRoamTerrain.findSection(iSectorX, iSectorY - 1);
                var pSouthSection = pRoamTerrain.findSection(iSectorX, iSectorY + 1);
                var pEastSection = pRoamTerrain.findSection(iSectorX + 1, iSectorY);
                var pWestSection = pRoamTerrain.findSection(iSectorX - 1, iSectorY);
                if(pNorthSection) {
                    this._leftNeighborOfA = pNorthSection.triangleB;
                }
                if(pSouthSection) {
                    this._leftNeighborOfB = pSouthSection.triangleA;
                }
                if(pEastSection) {
                    this._rightNeighborOfB = pEastSection.triangleA;
                }
                if(pWestSection) {
                    this._rightNeighborOfA = pWestSection.triangleB;
                }
                // establish basic links
                this.reset();
                // build the variance trees
                this.computeVariance();
                return bResult;
            };
            TerrainSectionROAM.prototype.prepareForRender = function /** @no-inline */() {
                /*????*/
                _super.prototype.prepareForRender.call(this);
                /*getActiveCamera();*/
                var pCamera = this._pEngine.getRenderer()._getViewport().getCamera();
                var v3fViewPoint = pCamera.worldPosition;
                // compute view distance to our 4 corners
                var fHeight0 = this.terrainSystem.readWorldHeight(akra.math.ceil(this._iHeightMapX), akra.math.ceil(this._iHeightMapY));
                var fHeight1 = this.terrainSystem.readWorldHeight(akra.math.ceil(this._iHeightMapX), akra.math.ceil(this._iHeightMapY + this._iYVerts));
                var fHeight2 = this.terrainSystem.readWorldHeight(akra.math.ceil(this._iHeightMapX + this._iXVerts), akra.math.ceil(this._iHeightMapY));
                var fHeight3 = this.terrainSystem.readWorldHeight(akra.math.ceil(this._iHeightMapX + this._iXVerts), akra.math.ceil(this._iHeightMapY + this._iYVerts));
                this._v3fDistance0.set(v3fViewPoint.x - this._pWorldRect.x0, v3fViewPoint.y - this._pWorldRect.y0, v3fViewPoint.z - fHeight0);
                this._v3fDistance1.set(v3fViewPoint.x - this._pWorldRect.x0, v3fViewPoint.y - this._pWorldRect.y1, v3fViewPoint.z - fHeight1);
                this._v3fDistance2.set(v3fViewPoint.x - this._pWorldRect.x1, v3fViewPoint.y - this._pWorldRect.y1, v3fViewPoint.z - fHeight2);
                this._v3fDistance3.set(v3fViewPoint.x - this._pWorldRect.x1, v3fViewPoint.y - this._pWorldRect.y0, v3fViewPoint.z - fHeight3);
                this._fDistance0 = this._v3fDistance0.length();
                this._fDistance1 = this._v3fDistance1.length();
                this._fDistance2 = this._v3fDistance2.length();
                this._fDistance3 = this._v3fDistance3.length();
                // compute min distance as our sort value
                this._fQueueSortValue = akra.math.min(this._v3fDistance0.length(), this._v3fDistance1.length());
                this._fQueueSortValue = akra.math.min(this._fQueueSortValue, this._v3fDistance2.length());
                this._fQueueSortValue = akra.math.min(this._fQueueSortValue, this._v3fDistance3.length());
                // submit to the tessellation queue of our parent
                this.terrainSystem.addToTessellationQueue(this);
            };
            TerrainSectionROAM.prototype.reset = function /** @no-inline */() {
                this._pRootTriangleA.leftChild = null;
                this._pRootTriangleA.rightChild = null;
                this._pRootTriangleB.leftChild = null;
                this._pRootTriangleB.rightChild = null;
                this._pRootTriangleA.baseNeighbor = this._pRootTriangleB;
                this._pRootTriangleB.baseNeighbor = this._pRootTriangleA;
                // link to our neighbors
                this._pRootTriangleA.leftNeighbor = this._leftNeighborOfA;
                this._pRootTriangleA.rightNeighbor = this._rightNeighborOfA;
                this._pRootTriangleB.leftNeighbor = this._leftNeighborOfB;
                this._pRootTriangleB.rightNeighbor = this._rightNeighborOfB;
            };
            TerrainSectionROAM.prototype.tessellate = function /** @no-inline */(fScale, fLimit) {
                this.recursiveTessellate(this._pRootTriangleA, this._fDistance1, this._fDistance2, this._fDistance0, this._pVarianceTreeA, 1, fScale, fLimit);
                this.recursiveTessellate(this._pRootTriangleB, this._fDistance3, this._fDistance0, this._fDistance2, this._pVarianceTreeB, 1, fScale, fLimit);
            };
            TerrainSectionROAM.prototype.recursiveTessellate = function /** @no-inline */(pTri, fDistA, fDistB, fDistC, pVTree, iIndex, fScale, fLimit) {
                if((iIndex << 1) + 1 < this._iTotalVariances) {
                    //console.log("vIndex",vIndex,"totalVariances",this._totalVariances)
                    var fMidDist = (fDistB + fDistC) * 0.5;
                    // Если треугольник не поделен
                    if(!pTri.leftChild) {
                        // math.pow(fMidDist+0.0001,fLimit);
                        var fRatio = (pVTree[iIndex] * fScale) / (fMidDist + 0.0001);
                        if(fRatio > 1) {
                            // subdivide this triangle
                            //console.log("split");
                            this.split(pTri);
                        }
                    }
                    // Если треугольник поделен, продолжаем
                    if(pTri.leftChild) {
                        //debug_assert(tri->leftChild, "invalid triangle node");
                        //debug_assert(tri->rightChild, "invalid triangle node");
                        this.recursiveTessellate(pTri.leftChild, fMidDist, fDistA, fDistB, pVTree, iIndex << 1, fScale, fLimit);
                        this.recursiveTessellate(pTri.rightChild, fMidDist, fDistC, fDistA, pVTree, (iIndex << 1) + 1, fScale, fLimit);
                    }
                }
            };
            TerrainSectionROAM.prototype.split = function /** @no-inline */(pTri) {
                // Если разбит то смысла разбивать еще нет
                if(pTri.leftChild) {
                    return;
                }
                // If this triangle is not in a proper diamond, force split our base neighbor
                if(pTri.baseNeighbor && (pTri.baseNeighbor.baseNeighbor != pTri)) {
                    this.split(pTri.baseNeighbor);
                }
                // Create children and link into mesh
                pTri.leftChild = this.terrainSystem.requestTriNode();
                pTri.rightChild = this.terrainSystem.requestTriNode();
                //debug_assert(pTri.leftChild != pTri, "recursive link");
                //debug_assert(pTri.rightChild != pTri, "recursive link");
                // Если не удалось выделить треугольник, то не разбиваем
                if((!pTri.leftChild) || (!pTri.rightChild)) {
                    pTri.leftChild = null;
                    pTri.rightChild = null;
                    return;
                }
                // Fill in the information we can get from the parent (neighbor pointers)
                pTri.leftChild.baseNeighbor = pTri.leftNeighbor;
                pTri.leftChild.leftNeighbor = pTri.rightChild;
                pTri.rightChild.baseNeighbor = pTri.rightNeighbor;
                pTri.rightChild.rightNeighbor = pTri.leftChild;
                // Link our Left Neighbor to the new children
                if(pTri.leftNeighbor) {
                    if(pTri.leftNeighbor.baseNeighbor == pTri) {
                        pTri.leftNeighbor.baseNeighbor = pTri.leftChild;
                    } else if(pTri.leftNeighbor.leftNeighbor == pTri) {
                        pTri.leftNeighbor.leftNeighbor = pTri.leftChild;
                    } else if(pTri.leftNeighbor.rightNeighbor == pTri) {
                        pTri.leftNeighbor.rightNeighbor = pTri.leftChild;
                    } else {
                        console.log(pTri);
                        akra.logger.setSourceLocation("terrain/TerrainSectionROAM.ts", 266);
                        akra.logger.warning("Invalid Left Neighbor!");
                        ;
                        debugger;

                    }
                }
                // Link our Right Neighbor to the new children
                if(pTri.rightNeighbor) {
                    if(pTri.rightNeighbor.baseNeighbor == pTri) {
                        pTri.rightNeighbor.baseNeighbor = pTri.rightChild;
                    } else if(pTri.rightNeighbor.rightNeighbor == pTri) {
                        pTri.rightNeighbor.rightNeighbor = pTri.rightChild;
                    } else if(pTri.rightNeighbor.leftNeighbor == pTri) {
                        pTri.rightNeighbor.leftNeighbor = pTri.rightChild;
                    } else {
                        akra.logger.setSourceLocation("terrain/TerrainSectionROAM.ts", 280);
                        akra.logger.warning("Invalid Right Neighbor!");
                        ;
                    }
                }
                // Link our Base Neighbor to the new children
                if(pTri.baseNeighbor) {
                    if(pTri.baseNeighbor.leftChild) {
                        pTri.baseNeighbor.leftChild.rightNeighbor = pTri.rightChild;
                        pTri.baseNeighbor.rightChild.leftNeighbor = pTri.leftChild;
                        pTri.leftChild.rightNeighbor = pTri.baseNeighbor.rightChild;
                        pTri.rightChild.leftNeighbor = pTri.baseNeighbor.leftChild;
                    } else {
                        // Base Neighbor (in a diamond with us) was not split yet, so do that now.
                        this.split(pTri.baseNeighbor);
                    }
                } else {
                    // An edge triangle, trivial case.
                    pTri.leftChild.rightNeighbor = null;
                    pTri.rightChild.leftNeighbor = null;
                }
            };
            TerrainSectionROAM.prototype._createRenderDataForVertexAndIndex = function /** @no-inline */() {
                return true;
            };
            TerrainSectionROAM.prototype._buildIndexBuffer = function /** @no-inline */() {
                // this._iMaxIndices=a.TerrainROAM.MaxTriTreeNodes*3;
                this._iMaxIndices = this.terrainSystem.maxTriTreeNodes * 3;
                return true;
            };
            TerrainSectionROAM.prototype._buildVertexBuffer = function /** @no-inline */() {
                this._pWorldRect.z0 = akra.MAX_FLOAT64;
                this._pWorldRect.z1 = akra.MAX_FLOAT64;
                var pVerts = this.terrainSystem.verts;
                var v3fNormal = new akra.Vec3();
                // размер ячейки сектора
                var v2fCellSize = new akra.Vec2();
                v2fCellSize.set(this.heightX / (this._iXVerts - 1), /*размер сектора/количество ячеек в секторе*/
                this.heightY / (this._iYVerts - 1));
                //Координаты вершина в секторе
                var v2fVert = new akra.Vec2();
                v2fVert.set(0.0, 0.0);
                //console.log("-->",this._iSectorX,this._iSectorY,"--",this._pWorldRect.x0,this._pWorldRect.fY0,"--",this._iXVerts,this._iYVerts)
                //console.log("--",v2fCellSize.X,v2fCellSize.Y,this.getHeightX(),this.getHeightY() )
                for(var y = 0; y < this._iYVerts; ++y) {
                    v2fVert.set(this._pWorldRect.x0, y * v2fCellSize.y + this._pWorldRect.y0);
                    for(var x = 0; x < this._iXVerts; ++x) {
                        var fHeight = this.terrainSystem.readWorldHeight(this._iHeightMapX + x, this._iHeightMapY + y);
                        pVerts[((y * this._iXVerts) + x) * 5 + 0 + this._iStartIndex * 5] = v2fVert.x;
                        pVerts[((y * this._iXVerts) + x) * 5 + 1 + this._iStartIndex * 5] = v2fVert.y;
                        pVerts[((y * this._iXVerts) + x) * 5 + 2 + this._iStartIndex * 5] = fHeight;
                        //console.log(y*this._iXVerts + x,x,y,v2fVert.X,v2fVert.Y,fHeight);
                        //	pVerts[((y * this._iXVerts) + x) * 10 + 2],pVerts[((y * this._iXVerts) + x) * 10 + 1]);
                        pVerts[((y * this._iXVerts) + x) * 5 + 3 + this._iStartIndex * 5] = (this._iSectorX + x / (this._iXVerts - 1)) / this.terrainSystem.sectorCountX;
                        pVerts[((y * this._iXVerts) + x) * 5 + 4 + this._iStartIndex * 5] = (this._iSectorY + y / (this._iYVerts - 1)) / this.terrainSystem.sectorCountY;
                        //console.log(this._iSectorX,this.terrainSystem.getSectorCountX(), x,this._iXVerts);
                        //console.log(this._iSectorX/this.terrainSystem.getSectorCountX() + x / (this._iXVerts - 1));
                        this._pWorldRect.z0 = akra.math.min(this._pWorldRect.z0, fHeight);
                        this._pWorldRect.z1 = akra.math.max(this._pWorldRect.z1, fHeight);
                        v2fVert.x += v2fCellSize.x;
                    }
                }
                return true;
            };
            TerrainSectionROAM.prototype.buildTriangleList = function /** @no-inline */() {
                this._iTempTotalIndices = this.terrainSystem.totalIndex;
                this._pTempIndexList = this.terrainSystem.index;
                this._iVertexID = this.terrainSystem.vertexId;
                // add all the triangles to the roamTerrain
                // in root triangle A
                this.recursiveBuildTriangleList(this._pRootTriangleA, 0, this._iXVerts - 1, (this._iYVerts - 1) * this._iXVerts);
                // add all the triangles to the roamTerrain
                // in root triangle B
                this.recursiveBuildTriangleList(this._pRootTriangleB, (this._iYVerts * this._iXVerts) - 1, (this._iYVerts - 1) * this._iXVerts, this._iXVerts - 1);
                this.terrainSystem.totalIndex = this._iTempTotalIndices;
                this._iTempTotalIndices = undefined;
                this._iVertexID = undefined;
                this._pTempIndexList = null;
            };
            TerrainSectionROAM.prototype.render = function /** @no-inline */() {
                return this.terrainSystem.render(this.worldMatrix);
            };
            TerrainSectionROAM.prototype.recursiveBuildTriangleList = function /** @no-inline */(pTri, iPointBase, iPointLeft, iPointRight) {
                if(pTri.leftChild) {
                    if(!pTri.rightChild) {
                        akra.logger.setSourceLocation("terrain/TerrainSectionROAM.ts", 396);
                        akra.logger.warning("invalid triangle node");
                        ;
                    }
                    var iPointMid = (iPointLeft + iPointRight) * 0.5;
                    this.recursiveBuildTriangleList(pTri.leftChild, iPointMid, iPointBase, iPointLeft);
                    this.recursiveBuildTriangleList(pTri.rightChild, iPointMid, iPointRight, iPointBase);
                } else if(this._iTempTotalIndices + 3 < this._iMaxIndices) {
                    // add the local triangle to the index list
                    //20 = 5(элементов) * 4(бита)
                    this._pTempIndexList[this._iTempTotalIndices++] = ((iPointRight + this._iStartIndex) * 20 + this._iVertexID) / 4;
                    this._pTempIndexList[this._iTempTotalIndices++] = ((iPointLeft + this._iStartIndex) * 20 + this._iVertexID) / 4;
                    this._pTempIndexList[this._iTempTotalIndices++] = ((iPointBase + this._iStartIndex) * 20 + this._iVertexID) / 4;
                } else {
                    console.log("else", this._iTempTotalIndices, this._iMaxIndices);
                }
            };
            TerrainSectionROAM.prototype.computeVariance = function /** @no-inline */() {
                var iTableWidth = this.terrainSystem.tableWidth;
                var iTableHeight = this.terrainSystem.tableHeight;
                var iIndex0 = this.terrainSystem._tableIndex(this._iHeightMapX, this._iHeightMapY);
                var iIndex1 = this.terrainSystem._tableIndex(this._iHeightMapX, this._iHeightMapY + this._iYVerts - 1);
                var iIndex2 = this.terrainSystem._tableIndex(this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY + this._iYVerts - 1);
                var iIndex3 = this.terrainSystem._tableIndex(this._iHeightMapX + this._iXVerts - 1, this._iHeightMapY);
                var fHeight0 = this.terrainSystem.readWorldHeight(iIndex0);
                var fHeight1 = this.terrainSystem.readWorldHeight(iIndex1);
                var fHeight2 = this.terrainSystem.readWorldHeight(iIndex2);
                var fHeight3 = this.terrainSystem.readWorldHeight(iIndex3);
                //console.error(iIndex0, iIndex1, iIndex2, iIndex3);
                this.recursiveComputeVariance(iIndex1, iIndex2, iIndex0, fHeight1, fHeight2, fHeight0, this._pVarianceTreeA, 1);
                this.recursiveComputeVariance(iIndex3, iIndex0, iIndex2, fHeight3, fHeight0, fHeight2, this._pVarianceTreeB, 1);
            };
            TerrainSectionROAM.prototype.recursiveComputeVariance = function /** @no-inline */(iCornerA, iCornerB, iCornerC, fHeightA, fHeightB, fHeightC, pVTree, iIndex) {
                if(iIndex < pVTree.length) {
                    var iMidpoint = (iCornerB + iCornerC) >> 1;
                    //console.log(iCornerA, iCornerB, iCornerC,'mid point --->', iMidpoint);
                    var fMidHeight = this.terrainSystem.readWorldHeight(iMidpoint);
                    var iTW = this.terrainSystem.tableWidth;
                    var iTH = this.terrainSystem.tableHeight;
                    var iXB = iCornerB % iTW;
                    var iYB = akra.math.floor(iCornerB / iTW);
                    var iXC = iCornerC % iTW;
                    var iYC = akra.math.floor(iCornerC / iTW);
                    var pWorldSize = this.terrainSystem.worldSize;
                    var fLX = akra.math.abs(iXB - iXC) / iTW * pWorldSize.x;
                    var fLY = akra.math.abs(iYB - iYC) / iTH * pWorldSize.y;
                    var fX = akra.math.sqrt(fLY * fLY + fLX * fLX);
                    var fY = akra.math.abs(fHeightB - fHeightC);
                    var fInterpolatedHeight = (fHeightB + fHeightC) * 0.5;
                    var fVariance = akra.math.abs(fMidHeight - fInterpolatedHeight);
                    if(fX < fY) {
                        fVariance = fInterpolatedHeight * fX / fY;
                    }
                    // find the variance of our children
                    var fLeft = this.recursiveComputeVariance(iMidpoint, iCornerA, iCornerB, fMidHeight, fHeightA, fHeightB, pVTree, iIndex << 1);
                    var fRight = this.recursiveComputeVariance(iMidpoint, iCornerC, iCornerA, fMidHeight, fHeightC, fHeightA, pVTree, 1 + (iIndex << 1));
                    // local variance is the minimum of all three
                    fVariance = akra.math.max(fVariance, fLeft);
                    fVariance = akra.math.max(fVariance, fRight);
                    // store the variance as 1/(variance+1)
                    pVTree[iIndex] = fVariance;
                    //this.drawVariance(iIndex,iCornerA, iCornerB, iCornerC,pVTree);
                    return fVariance;
                }
                // return a value which will be ignored by the parent
                // (because the minimum function is used with this result)
                return 0;
            };
            TerrainSectionROAM.prototype.drawVariance = function /** @no-inline */(iIndex, iCornerA, iCornerB, iCornerC, pVTree) {
                var iLevel = akra.math.floor(akra.math.log(iIndex) / akra.math.LN2);
                var iStart = 0;
                if(iLevel >= iStart && iLevel < iStart + 4) {
                    //#####################################################################################
                    //Получение канваса
                    var pCanvas = document.getElementById("variance" + (iLevel - iStart));
                    var p2D = pCanvas.getContext("2d");
                    // цвет фона
                    p2D.fillStyle = "rgb(0," + akra.math.floor(pVTree[iIndex]) + ",0)";
                    //p2D.fillRect(0, 0, pCanvas.width, pCanvas.height);
                    //#####################################################################################
                    //Рисование треугольников
                    //цвет линий
                    p2D.strokeStyle = "#f00";
                    p2D.lineWidth = 1;
                    p2D.beginPath();
                    var iTW = this.terrainSystem.tableWidth;
                    var iTH = this.terrainSystem.tableHeight;
                    var iXA = iCornerA % iTW;
                    var iYA = akra.math.floor(iCornerA / iTW);
                    var iXB = iCornerB % iTW;
                    var iYB = akra.math.floor(iCornerB / iTW);
                    var iXC = iCornerC % iTW;
                    var iYC = akra.math.floor(iCornerC / iTW);
                    var iXMid = akra.math.floor((iXA + iXB + iXC) / 3);
                    var iYMid = akra.math.floor((iYA + iYB + iYC) / 3);
                    //console.log(iXMid/iTW*pCanvas.width,iYMid/iTH*pCanvas.height, math.floor(iXMid/iTW*pCanvas.width),math.floor(iYMid/iTH*pCanvas.height));
                    //console.warn(iXMid,iYMid)
                    p2D.arc(akra.math.floor(iXMid / iTW * pCanvas.width), akra.math.floor(iYMid / iTH * pCanvas.height), 5, 0, akra.math.PI * 2, false);
                    p2D.fill();
                    //console.log("Total ",pSec._iTotalIndices);
                    //console.log(this);
                                    }
            };
            return TerrainSectionROAM;
        })(terrain.TerrainSection);
        terrain.TerrainSectionROAM = TerrainSectionROAM;        
    })(akra.terrain || (akra.terrain = {}));
    var terrain = akra.terrain;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (terrain) {
        var TriTreeNode = (function () {
            function TriTreeNode() {
                this._pBaseNeighbor = null;
                this._pLeftNeighbor = null;
                this._pRightNeighbor = null;
                this._pLeftChild = null;
                this._pRightChild = null;
            }
            Object.defineProperty(TriTreeNode.prototype, "baseNeighbor", {
                get: function /** @inline */() {
                    return this._pBaseNeighbor;
                },
                set: function /** @inline */(pBaseNeighbor) {
                    this._pBaseNeighbor = pBaseNeighbor;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TriTreeNode.prototype, "leftNeighbor", {
                get: function /** @inline */() {
                    return this._pLeftNeighbor;
                },
                set: function /** @inline */(pLeftNeighbor) {
                    this._pLeftNeighbor = pLeftNeighbor;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TriTreeNode.prototype, "rightNeighbor", {
                get: function /** @inline */() {
                    return this._pRightNeighbor;
                },
                set: function /** @inline */(pRightNeighbor) {
                    this._pRightNeighbor = pRightNeighbor;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TriTreeNode.prototype, "leftChild", {
                get: function /** @inline */() {
                    return this._pLeftChild;
                },
                set: function /** @inline */(pLeftChild) {
                    this._pLeftChild = pLeftChild;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TriTreeNode.prototype, "rightChild", {
                get: function /** @inline */() {
                    return this._pRightChild;
                },
                set: function /** @inline */(pRightChild) {
                    this._pRightChild = pRightChild;
                },
                enumerable: true,
                configurable: true
            });
            return TriTreeNode;
        })();
        terrain.TriTreeNode = TriTreeNode;        
        var TriangleNodePool = (function () {
            function /** @no-inline */TriangleNodePool(iCount) {
                this._iNextTriNode = 0;
                this._iMaxCount = undefined;
                this._pPool = null;
                this._iMaxCount = iCount;
                this.pool = Array(iCount);
                console.log("TriangleNodePool", this.maxCount);
                for(var i = 0; i < this.maxCount; i++) {
                    this.pool[i] = new TriTreeNode();
                }
            }
            Object.defineProperty(TriangleNodePool.prototype, "nextTriNode", {
                get: function /** @inline */() {
                    return this._iNextTriNode;
                },
                set: function /** @inline */(iNextTriNode) {
                    this._iNextTriNode = iNextTriNode;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TriangleNodePool.prototype, "maxCount", {
                get: function /** @inline */() {
                    return this._iMaxCount;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TriangleNodePool.prototype, "pool", {
                get: function /** @inline */() {
                    return this._pPool;
                },
                set: function /** @inline */(pPool) {
                    this._pPool = pPool;
                },
                enumerable: true,
                configurable: true
            });
            TriangleNodePool.prototype.request = function /** @no-inline */() {
                var pNode = null;
                if(this.nextTriNode < this.maxCount) {
                    pNode = this.pool[this.nextTriNode];
                    pNode.baseNeighbor = null;
                    pNode.leftNeighbor = null;
                    pNode.rightNeighbor = null;
                    pNode.leftChild = null;
                    pNode.rightChild = null;
                    this.nextTriNode++;
                }
                return pNode;
            };
            TriangleNodePool.prototype.reset = function /** @no-inline */() {
                this.nextTriNode = 0;
            };
            return TriangleNodePool;
        })();
        terrain.TriangleNodePool = TriangleNodePool;        
    })(akra.terrain || (akra.terrain = {}));
    var terrain = akra.terrain;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (terrain) {
        var TerrainROAM = (function (_super) {
            __extends(TerrainROAM, _super);
            function /** @no-inline */TerrainROAM(pEngine) {
                        _super.call(this, pEngine);
                this._pRenderData = null;
                this._pDataIndex = null;
                this._pIndexList = null;
                this._pNodePool = null;
                this._pThistessellationQueue = null;
                this._iTessellationQueueCount = 0;
                this._isCreat = false;
                this._isRenderInThisFrame = false;
                /*64k triangle nodes*/
                this._iMaxTriTreeNodes = (1024 * 64);
                this._iTessellationQueueSize = undefined;
                this._isCreate = undefined;
                //массив подчиненный секций
                /**@protected*/ this._pSectorArray = null;
                this._iTessellationQueueCountOld = undefined;
                this._nCountRender = 0;
                this._pRenderData = this._pDataFactory.getEmptyRenderData(4 /* TRIANGLELIST */ , akra.ERenderDataBufferOptions.RD_ADVANCED_INDEX);
            }
            Object.defineProperty(TerrainROAM.prototype, "maxTriTreeNodes", {
                get: function /** @inline */() {
                    return this._iMaxTriTreeNodes;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainROAM.prototype, "verts", {
                get: function /** @inline */() {
                    return this._pVerts;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainROAM.prototype, "index", {
                get: function /** @inline */() {
                    return this._pIndexList;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainROAM.prototype, "totalIndex", {
                get: function /** @inline */() {
                    return this._iTotalIndices;
                },
                set: function /** @inline */(iTotalIndices) {
                    this._iTotalIndices = iTotalIndices;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TerrainROAM.prototype, "vertexId", {
                get: function /** @inline */() {
                    return this._iVertexID;
                },
                enumerable: true,
                configurable: true
            });
            TerrainROAM.prototype.create = /*private _fXOld = undefined;
            private _fYOld = undefined;*/
            function /** @no-inline */(pRootNode, pImgMap, worldExtents, iShift, iShiftX, iShiftY, sSurfaceTextures) {
                var bResult = _super.prototype.create.call(this, pRootNode, pImgMap, worldExtents, iShift, iShiftX, iShiftY, sSurfaceTextures);
                if(bResult) {
                    this._iTessellationQueueSize = this.sectorCountX * this.sectorCountY;
                    this._pNodePool = new terrain.TriangleNodePool(this._iMaxTriTreeNodes);
                    this._pThistessellationQueue = new Array(this._iTessellationQueueSize);
                    this._iTessellationQueueCount = 0;
                    this._isCreate = true;
                    this._iTotalIndicesMax = 0;
                }
                return bResult;
            };
            TerrainROAM.prototype.destroy = function /** @no-inline */() {
                delete this._pNodePool;
                delete this._pThistessellationQueue;
                this._iTessellationQueueCount = 0;
                this._fScale = 0;
                this._fLimit = 0;
                //Terrain.prototype.destroy.call(this); с какого то хуя этого метода не оказалось
                            };
            TerrainROAM.prototype.allocateSectors = function /** @no-inline */() {
                /*this._pSectorArray =
                new cTerrainSection[
                this._iSectorCountX*this._iSectorCountY];*/
                this._pSectorArray = new Array(this._iSectorCountX * this._iSectorCountY);
                //Вершинный буфер для всех
                /*количество секции*/
                /*размер секции в вершинах*/
                /*кординаты вершин*/
                /*текстурные координаты*/
                this._pVerts = new Array((this._iSectorCountX * this._iSectorCountY) * (this._iSectorVerts * this._iSectorVerts) * (3 + 2));
                for(var i = 0; i < this._pSectorArray.length; i++) {
                    this._pSectorArray[i] = new terrain.TerrainSectionROAM(this._pEngine);
                }
                this._setRenderMethod(this._pDefaultRenderMethod, "");
                // create the sector objects themselves
                for(var y = 0; y < this._iSectorCountY; ++y) {
                    for(var x = 0; x < this._iSectorCountX; ++x) {
                        //cVector2 sectorPos(
                        var v2fSectorPos = new akra.Vec2();
                        v2fSectorPos.set(this._pWorldExtents.x0 + (x * this._v2fSectorSize.x), this._pWorldExtents.y0 + (y * this._v2fSectorSize.y));
                        //cRect2d r2fSectorRect(
                        var r2fSectorRect = new akra.geometry.Rect2d();
                        r2fSectorRect.set(v2fSectorPos.x, v2fSectorPos.x + this._v2fSectorSize.x, v2fSectorPos.y, v2fSectorPos.y + this._v2fSectorSize.y);
                        var iXPixel = x << this._iSectorShift;
                        var iYPixel = y << this._iSectorShift;
                        var iIndex = (y * this._iSectorCountX) + x;
                        if(!this._pSectorArray[iIndex].create(/*Родительские нод*/
                        this._pRootNode, /*Терраин*/
                        this, /*Номер секции оп иксу и игрику*/
                        x, y, /*Координаты секции в картах нормалей и врешин*/
                        iXPixel, iYPixel, /*Количесвто вершин в секции по иску и игрику*/
                        this._iSectorVerts, this._iSectorVerts, r2fSectorRect, /*размер секции в вершинах*/
                        iIndex * (this._iSectorVerts * this._iSectorVerts))) {
                            return false;
                        }
                    }
                }
                var pVertexDescription = [
                    akra.VE_FLOAT3(akra.DeclarationUsages.POSITION), 
                    akra.VE_FLOAT2(akra.DeclarationUsages.TEXCOORD)
                ];
                this._iVertexID = this._pRenderData.allocateData(pVertexDescription, new Float32Array(this._pVerts));
                //Индексны буфер для всех
                this._iTotalIndices = 0;
                //Максимальное количество треугольников помноженное на 3 вершины на каждый треугольник
                this._pIndexList = new Float32Array(this._iMaxTriTreeNodes * 3);
                this._pRenderData.allocateIndex([
                    akra.VE_FLOAT(akra.DeclarationUsages.INDEX0)
                ], this._pIndexList);
                this._pRenderData.index(this._iVertexID, akra.DeclarationUsages.INDEX0);
                this._pDataIndex = this._pRenderData.getAdvancedIndexData(akra.DeclarationUsages.INDEX0);
                return true;
            };
            TerrainROAM.prototype.reset = function /** @no-inline */() {
                this._isRenderInThisFrame = false;
                if(this._isCreate) {
                    terrain.Terrain.prototype.reset.call(this);
                    // reset internal counters
                    this._iTessellationQueueCount = 0;
                    this._pThistessellationQueue.length = this._iTessellationQueueSize;
                    this._pNodePool.reset();
                    // reset each section
                    for(var i in this._pSectorArray) {
                        this._pSectorArray[i].reset();
                    }
                }
            };
            TerrainROAM.prototype.requestTriNode = function /** @no-inline */() {
                return this._pNodePool.request();
            };
            TerrainROAM.prototype.addToTessellationQueue = function /** @no-inline */(pSection) {
                if(this._iTessellationQueueCount < this._iTessellationQueueSize) {
                    this._pThistessellationQueue[this._iTessellationQueueCount] = pSection;
                    this._iTessellationQueueCount++;
                    return true;
                }
                // while we handle this failure gracefully
                // in release builds, we alert ourselves
                // to the situation with an assert in debug
                // builds so we can increase the queue size
                akra.logger.setSourceLocation("terrain/TerrainROAM.ts", 190);
                akra.logger.warning("increase the size of the ROAM tessellation queue");
                ;
                return false;
            };
            TerrainROAM.prototype.prepareForRender = function /** @no-inline */() {
                if(this._isCreate) {
                    terrain.Terrain.prototype.prepareForRender.call(this);
                    if(((this._nCountRender++) % 30) == 0) {
                        /*getActiveCamera();*/
                        var pCamera = this._pEngine.getRenderer()._getViewport().getCamera();
                        var v3fCameraPosition = pCamera.worldPosition;
                        var fX = (v3fCameraPosition.x - this.worldExtents.x0) / akra.math.abs(this.worldExtents.x1 - this.worldExtents.x0);
                        var fY = (v3fCameraPosition.y - this.worldExtents.y0) / akra.math.abs(this.worldExtents.y1 - this.worldExtents.y0);
                        if(this._iTessellationQueueCount != this._iTessellationQueueCountOld) {
                            this.processTessellationQueue();
                            this._iTessellationQueueCountOld = this._iTessellationQueueCount;
                        }
                    }
                }
                return;
            };
            TerrainROAM.prototype.render = function /** @no-inline */(pWorldMatrix) {
                if(this._isRenderInThisFrame == false) {
                    this._isRenderInThisFrame = true;
                    /*getActiveCamera();*/
                    var pCamera = this._pEngine.getRenderer()._getViewport().getCamera();
                    this._pSectorArray[0].setRenderData(this._pRenderData);
                    return terrain.TerrainSection.prototype.render.call(this._pSectorArray[0]);
                }
                return true;
            };
            TerrainROAM.prototype.processTessellationQueue = function /** @no-inline */() {
                this._pThistessellationQueue.length = this._iTessellationQueueCount;
                function /** @no-inline */fnSortSection(a, b) {
                    return a.getQueueSortValue() - b.getQueueSortValue();
                }
                this._pThistessellationQueue.sort(fnSortSection);
                for(var i = 0; i < this._iTessellationQueueCount; ++i) {
                    // split triangles based on the
                    // scale and limit values
                    this._pThistessellationQueue[i].tessellate(this._fScale, this._fLimit);
                }
                this._iTotalIndices = 0;
                // gather up all the triangles into
                // a final index buffer per section
                for(var i = 0; i < this._iTessellationQueueCount; ++i) {
                    this._pThistessellationQueue[i].buildTriangleList();
                }
                if(this._iTotalIndicesOld == this._iTotalIndices && this._iTotalIndices != this._iTotalIndicesMax) {
                    //console.log("!!!!_iTotalIndices",this._iTotalIndices);
                    return;
                }
                this._pRenderData.setIndexLength(this._iTotalIndices);
                this._pDataIndex.setData(this._pIndexList, 0, akra.getTypeSize(5126 /* FLOAT */ ), 0, this._iTotalIndices);
                this._iTotalIndicesOld = this._iTotalIndices;
                this._iTotalIndicesMax = akra.math.max(this._iTotalIndicesMax, this._iTotalIndices);
            };
            return TerrainROAM;
        })(terrain.Terrain);
        terrain.TerrainROAM = TerrainROAM;        
    })(akra.terrain || (akra.terrain = {}));
    var terrain = akra.terrain;
})(akra || (akra = {}));
var akra;
(function (akra) {
    (function (util) {
        window.prompt = function /** @no-inline */(message, defaul) {
            console.warn("prompt > " + message);
            return null;
        };
        window.alert = function /** @no-inline */(message) {
            console.warn("alert > " + message);
        };
        window.confirm = function /** @no-inline */(message) {
            console.warn("confirm > " + message);
            return false;
        };
        var pTestCondList = [];
        var pTestList = [];
        var isPassed;
        var pTest = null;
        var iBegin;
        function /** @no-inline */addCond(pCond) {
            pTestCondList.unshift(pCond);
        }
        var TestCond = (function () {
            function /** @no-inline */TestCond(sDescription) {
                this.sDescription = sDescription;
            }
            TestCond.prototype.toString = function /** @no-inline */() {
                return this.sDescription;
            };
            TestCond.prototype.verify = function /** @no-inline */(pArgv) {
                return false;
            };
            Object.defineProperty(TestCond.prototype, "description", {
                get: function /** @no-inline */() {
                    return this.sDescription;
                },
                enumerable: true,
                configurable: true
            });
            return TestCond;
        })();        
        var ArrayCond = (function (_super) {
            __extends(ArrayCond, _super);
            function /** @no-inline */ArrayCond(sDescription, pArr) {
                        _super.call(this, sDescription);
                this._pArr = pArr;
            }
            ArrayCond.prototype.verify = function /** @no-inline */(pArgv) {
                var pArr = pArgv[0];
                if(pArr.length != this._pArr.length) {
                    return false;
                }
                for(var i = 0; i < pArr.length; ++i) {
                    if(pArr[i] != this._pArr[i]) {
                        return false;
                    }
                }
                ;
                return true;
            };
            return ArrayCond;
        })(TestCond);        
        var ValueCond = (function (_super) {
            __extends(ValueCond, _super);
            function /** @no-inline */ValueCond(sDescription, pValue, isNegate) {
                if (typeof isNegate === "undefined") { isNegate = false; }
                        _super.call(this, sDescription);
                this._pValue = pValue;
                this._isNegate = isNegate;
            }
            ValueCond.prototype.verify = function /** @no-inline */(pArgv) {
                var bResult = pArgv[0] === this._pValue;
                // console.warn(">", pArgv[0], "!==", this._pValue);
                return this._isNegate ? !bResult : bResult;
            };
            return ValueCond;
        })(TestCond);        
        function /** @no-inline */output(sText) {
            document.body.innerHTML += sText;
        }
        function /** @no-inline */check() {
            var pArgv = [];
            for (var _i = 0; _i < (arguments.length - 0); _i++) {
                pArgv[_i] = arguments[_i + 0];
            }
            var pTest = pTestCondList.pop();
            var bResult;
            if(!pTest) {
                console.log(((new Error())).stack);
                console.warn("chech() without condition...");
                return;
            }
            bResult = pTest.verify(pArgv);
            isPassed = isPassed && bResult;
            if(bResult) {
                output("<pre style=\"margin: 0; margin-left: 20px;\"><span style=\"color: green;\"><b>[ PASSED ]</b></span> " + pTest.toString() + "</pre>");
            } else {
                output("<pre style=\"margin: 0; margin-left: 20px;\"><span style=\"color: red;\"><b>[ FAILED ]</b></span> " + pTest.toString() + "</pre>");
            }
        }
        util.check = check;
        function /** @no-inline */failed(e) {
            if(akra.isDef(e)) {
                printError(e.message, (e).stack);
            }
            var iTotal = pTestCondList.length;
            for(var i = 0; i < iTotal; ++i) {
                check(false);
            }
            isPassed = false;
            pTest = null;
            printResults();
            run();
        }
        util.failed = failed;
        function /** @no-inline */shouldBeTrue(sDescription) {
            addCond(new ValueCond(sDescription, true));
        }
        util.shouldBeTrue = shouldBeTrue;
        function /** @no-inline */shouldBeFalse(sDescription) {
            addCond(new ValueCond(sDescription, false));
        }
        util.shouldBeFalse = shouldBeFalse;
        function /** @no-inline */shouldBeArray(sDescription, pArr) {
            addCond(new ArrayCond(sDescription, pArr));
        }
        util.shouldBeArray = shouldBeArray;
        function /** @no-inline */shouldBe(sDescription, pValue) {
            addCond(new ValueCond(sDescription, pValue));
        }
        util.shouldBe = shouldBe;
        function /** @no-inline */shouldBeNotNull(sDescription) {
            addCond(new ValueCond(sDescription, null, true));
        }
        util.shouldBeNotNull = shouldBeNotNull;
                        function /** @no-inline */test(manifest, fnWrapper, isAsync) {
            if (typeof isAsync === "undefined") { isAsync = false; }
            var pManifest;
            if(akra.isString(manifest)) {
                pManifest = {
                    name: arguments[0],
                    description: null,
                    entry: fnWrapper
                };
            } else {
                pManifest = arguments[0];
                pManifest.entry = fnWrapper;
            }
            pManifest.async = isAsync;
            pTestList.unshift(pManifest);
        }
        util.test = test;
        function /** @no-inline */printInfo() {
            output("<h4 style=\"font-family: monospace;\">" + pTest.name || "" + "</h4>");
        }
        function /** @no-inline */printResults() {
            output("<pre style=\"margin-left: 20px;\">" + "<hr align=\"left\" style=\"border: 0; background-color: gray; height: 1px; width: 500px;\"/><span style=\"color: gray;\">total time: " + (akra.now() - iBegin) + " msec" + "</span>" + "<br /><b>" + (isPassed ? "<span style=\"color: green\">TEST PASSED</span>" : "<span style=\"color: red\">TEST FAILED</span>") + "</b>" + "</pre>");
        }
        function /** @no-inline */printError(message, stack) {
            message = "<b>" + message + "</b>";
            if(akra.isDef(stack)) {
                message += "\n" + stack;
            }
            output("<pre style=\"margin-left: 20px;\">" + "<span style=\"color: red; background-color: rgba(255, 0, 0, .1);\">" + message + "</span>" + "</pre>");
        }
        function /** @no-inline */asyncTest(manifest, fnWrapper) {
            test(manifest, fnWrapper, true);
        }
        util.asyncTest = asyncTest;
        function /** @no-inline */run() {
            //если вдруг остались тесты.
            if(pTestCondList.length) {
                failed();
            }
            //если предыдущий тест был асинхронным, значит он кончился и надо распечатать результаты
            if(!akra.isNull(pTest) && pTest.async == true) {
                printResults();
            }
            while(pTestList.length) {
                //начинаем новый тест
                pTest = pTestList.pop();
                iBegin = akra.now();
                isPassed = true;
                printInfo();
                //start test
                try  {
                    pTest.entry();
                } catch (e) {
                    failed(e);
                    return;
                }
                if(!pTest.async) {
                    printResults();
                    pTest = null;
                } else {
                    return;
                }
            }
            ;
        }
        util.run = run;
        window.onload = function /** @no-inline */() {
            run();
        };
    })(akra.util || (akra.util = {}));
    var util = akra.util;
})(akra || (akra = {}));
var test = akra.util.test;
var asyncTest = akra.util.asyncTest;
var failed = akra.util.failed;
var run = akra.util.run;
var shouldBe = akra.util.shouldBe;
var shouldBeArray = akra.util.shouldBeArray;
var shouldBeTrue = akra.util.shouldBeTrue;
var shouldBeFalse = akra.util.shouldBeFalse;
var shouldBeNotNull = akra.util.shouldBeNotNull;
var check = akra.util.check;
var ok = check;
var akra;
(function (akra) {
    test("init tests", function /** @inline */() {
        shouldBeNotNull("terrain");
        var pEngine = akra.createEngine();
        var pTerrain = new akra.terrain.TerrainROAM(pEngine);
        ok(pTerrain);
    });
})(akra || (akra = {}));
